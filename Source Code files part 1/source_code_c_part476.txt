cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    // Bounds for input A area.

    rc.left     = rc.right;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsPush
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsPush()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    // Bounds for input A area.

    rc.left     = m_lCurStretchWidth;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input A to the output.

    if (m_lCurStretchWidth == 0)
    {
        m_alInputIndex[m_cbndsDirty] = 0;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH;
    }

    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsPush


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcFullBoundsSpin
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcFullBoundsSpin()
{
    RECT rc;

    rc.left     = 0;
    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    // If at 0% progress, just copy all of input A to the output.

    if (0 == m_lCurStretchWidth)
    {
        rc.right    = m_sizeInput.cx;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        goto done;
    }

    // If at 100% progress, just copy all of input B to the output.

    if (m_sizeInput.cx == m_lCurStretchWidth)
    {
        rc.right    = m_sizeInput.cx;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 1;
        m_cbndsDirty++;

        goto done;
    }

    // Left side solid A.

    rc.right = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

    // Center stretch B.

    rc.left     = rc.right;
    rc.right    = rc.left + m_lCurStretchWidth;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    m_cbndsDirty++;

    // Right side solid A.

    rc.left     = rc.right;
    rc.right    = m_sizeInput.cx;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = 0;
    m_cbndsDirty++;

done:

    return S_OK;
}
//  CDXTStretchBase::_CalcFullBoundsSpin


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcOptBoundsHide
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcOptBoundsHide()
{
    RECT rc;

    // Bounds for stretched input B area.

    rc.left     = 0;
    rc.top      = 0;
    rc.right    = m_lCurStretchWidth;
    rc.bottom   = m_sizeInput.cy;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);

    // If bounds take up entire output, no need to do stretch, just copy all of
    // input B to the output.

    if (m_lCurStretchWidth == m_sizeInput.cx)
    {
        m_alInputIndex[m_cbndsDirty] = 1;
    }
    else // Do stretch.
    {
        m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    }

    m_cbndsDirty++;

    if (m_lCurStretchWidth < m_lPrevStretchWidth)
    {
        // Bounds for dirty input A area.

        rc.left     = m_lCurStretchWidth;
        rc.right    = m_lPrevStretchWidth;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    return S_OK;
}
//  CDXTStretchBase::_CalcOptBoundsHide


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_CalcOptBoundsSpin
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::_CalcOptBoundsSpin()
{
    RECT rc;

    rc.top      = 0;
    rc.bottom   = m_sizeInput.cy;

    if (m_lCurStretchWidth < m_lPrevStretchWidth)
    {
        long    lTemp = 0;

        // Left side solid A.

        rc.left     = (m_sizeInput.cx - m_lPrevStretchWidth) / 2;
        rc.right    = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;

        // Right side solid A.

        lTemp = rc.left;

        rc.left     = rc.right + m_lCurStretchWidth;
        rc.right    = lTemp + m_lPrevStretchWidth;

        m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
        m_alInputIndex[m_cbndsDirty] = 0;
        m_cbndsDirty++;
    }

    // Center stretch B.

    rc.left     = (m_sizeInput.cx - m_lCurStretchWidth) / 2;
    rc.right    = rc.left + m_lCurStretchWidth;

    m_abndsDirty[m_cbndsDirty].SetXYRect(rc);
    m_alInputIndex[m_cbndsDirty] = DO_STRETCH | 1;
    m_cbndsDirty++;

    return S_OK;
}
//  CDXTStretchBase::_CalcOptBoundsSpin


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::_HorizontalSquish
//
//  Arguments:  bndsSquish  Area on output surface to squish bndsSrc of input 
//                          into.
//              bndsDo      Portion of bndsSquish to actually draw relative to
//                          bndsSquish, must be same height as bndsSquish.
//              pSurfIn     Pointer to input surface.
//              bndsSrc     Portion of input to squish in to bndsSquish area.
//
//              dwFlags     dwFlags for DXBitBlt.
//              ulTimeout   Timeout for DXBitBlt.
//              pfContinue  Let's function know when to abort.
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::_HorizontalSquish(const CDXDBnds & bndsSquish, const CDXDBnds & bndsDo,
                            IDXSurface * pSurfIn, const CDXDBnds & bndsSrc, 
                            DWORD dwFlags, ULONG ulTimeout, BOOL * pfContinue)
{
    HRESULT hr              = S_OK;
    double  dblSquish2Src   = 0.0;
    ULONG   x               = 0;
    ULONG   y               = 0;
    ULONG   ulHeight        = (ULONG)bndsDo.Height();
    ULONG   ulWidth         = (ULONG)bndsDo.Width();

    DXPMSAMPLE *    pSrcBuffer          = NULL;
    DXPMSAMPLE *    pDestBuffer         = NULL;
    DXPMSAMPLE *    pScratchBuffer      = NULL;
    ULONG *         pulSquish2SrcIndex  = NULL;

    DXDITHERDESC    dxdd;
    CDXDBnds        bndsOutLock;

    CComPtr<IDXARGBReadPtr>         cpIn;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    // Vertical scaling not supported.  

    _ASSERT(bndsSquish.Height() == bndsSrc.Height());

    // Squishing only, no expanding.

    _ASSERT(bndsSquish.Width() <= bndsSrc.Width());

    // Make sure bndsDo fits in bndsSquish.

    _ASSERT(bndsDo.Left()   >= 0);
    _ASSERT(bndsDo.Top()    == 0);
    _ASSERT(bndsDo.Right()  <= (long)bndsSquish.Width());
    _ASSERT(bndsDo.Bottom() == (long)bndsSquish.Height());

    // Make sure we have an input pointer.

    _ASSERT(pSurfIn != NULL);

    // Get pointer to input surface.

    hr = pSurfIn->LockSurface(&bndsSrc, ulTimeout, DXLOCKF_READ, 
                              IID_IDXARGBReadPtr, (void **)&cpIn, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Calculate output lock bounds.

    bndsOutLock[DXB_X].Min = bndsSquish[DXB_X].Min + bndsDo[DXB_X].Min;
    bndsOutLock[DXB_X].Max = bndsSquish[DXB_X].Min + bndsDo[DXB_X].Max;
    bndsOutLock[DXB_Y].Min = bndsSquish[DXB_Y].Min + bndsDo[DXB_Y].Min;
    bndsOutLock[DXB_Y].Max = bndsSquish[DXB_Y].Min + bndsDo[DXB_Y].Max;

    // Get pointer to output surface.

    hr = OutputSurface()->LockSurface(&bndsOutLock, ulTimeout,
                                      DXLOCKF_READWRITE, 
                                      IID_IDXARGBReadWritePtr, (void **)&cpOut,
                                      NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    // Allocate source buffer.

    pSrcBuffer = DXPMSAMPLE_Alloca(m_sizeInput.cx);

    if (NULL == pSrcBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Allocate destination buffer.

    pDestBuffer = DXPMSAMPLE_Alloca(ulWidth);

    if (NULL == pDestBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Allocate scratch buffer if needed.

    if ((OutputSampleFormat() != DXPF_PMARGB32) && (dwFlags & DXBOF_DO_OVER))
    {
        pScratchBuffer = DXPMSAMPLE_Alloca(ulWidth);
    }

    // Allocate space for squish to source row index.
    // pulSquish2SrcIndex[SquishedColumn] = SourceColumn

    pulSquish2SrcIndex = new ULONG[ulWidth];

    if (NULL == pulSquish2SrcIndex)
    {
        hr = E_OUTOFMEMORY;
        goto done;
    }

    // Set up dither structure if needed.

    if (dwFlags & DXBOF_DITHER)
    {
        dxdd.x              = bndsSquish.Left() + bndsDo.Left();
        dxdd.y              = bndsSquish.Top() + bndsDo.Top();
        dxdd.pSamples       = pDestBuffer;
        dxdd.cSamples       = ulWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Calculate squish ratio.

    dblSquish2Src = (double)bndsSrc.Width() / (double)bndsSquish.Width();

    // Build squish to source row index.

    for (x = bndsDo.Left(); x < (ULONG)bndsDo.Right(); x++)
    {
        pulSquish2SrcIndex[x - bndsDo.Left()] = (ULONG)((double)x * dblSquish2Src);
    }

    // Loop through rows.

    for (y = 0; y < ulHeight; y++)
    {
        cpIn->MoveToRow(y);

        cpIn->UnpackPremult(pSrcBuffer, m_sizeInput.cx, FALSE);

        for (x = 0; x < ulWidth; x++)
        {
            pDestBuffer[x] = pSrcBuffer[pulSquish2SrcIndex[x]];
        }

        cpOut->MoveToRow(y);

        // Dither

        if (dwFlags & DXBOF_DITHER)
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (dwFlags & DXBOF_DO_OVER)
        {
            cpOut->OverArrayAndMove(pScratchBuffer, pDestBuffer, ulWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pDestBuffer, ulWidth);
        }
    }

done:

    if (pulSquish2SrcIndex)
    {
        delete [] pulSquish2SrcIndex;
    }

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::_HorizontalSquish


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::OnSetup(DWORD dwFlags)
{
    HRESULT hr;

    CDXDBnds InBounds(InputSurface(0), hr);
    if (SUCCEEDED(hr))
    {
        InBounds.GetXYSize(m_sizeInput);
    }
    return hr;

}
//  CDXTStretchBase::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                        CDXDVec & InVec) 
{
    HRESULT hr = S_OK;

    long lOutX = OutPoint.Left();
    long lOutY = OutPoint.Top();

    //
    // Calculate input surface picked
    //

    long lOffset        = (m_sizeInput.cx - m_lCurStretchWidth) / 2;

    if ( m_eStretchStyle == CRSTS_SPIN )
    {
        if (lOutX >= lOffset && lOutX < m_sizeInput.cx - lOffset)
        {
            ulInputIndex = 1;
        }
        else
        {
            ulInputIndex = 0;
        }
    }
    else
    {
        if (lOutX < m_lCurStretchWidth)
        {
            ulInputIndex = 1;
        }
        else
        {
            ulInputIndex = 0;
        }
    }

    //
    // Calculate input point picked
    //

    IDXARGBReadPtr*         pPtr;
    BOOL                    bFoundIt = FALSE;

    // Recalculate output point if needed

    POINT pt = {lOutX, lOutY};

    if ( 1 == ulInputIndex || m_eStretchStyle == CRSTS_PUSH )
    {
        if ( m_eStretchStyle == CRSTS_SPIN )
        {
            // If in spin mode, reduce output point value
            // by the distance between the left edge and
            // the beginning of input B.

            pt.x -= lOffset;
        }

        if ( 1 == ulInputIndex )
        {
            // If picked on input B, multiply the x coordinate by
            // the ratio of the original width of input B to the
            // currently displayed width of input B

            pt.x = (long)((float)pt.x * ((float)m_sizeInput.cx / (float)m_lCurStretchWidth));
        }
        else
        {
            // If picked on input A and in push mode, reduce the output
            // x value by the distance between the left edge and the beginning
            // of input A.  Then multiply the x coordinate by the ratio
            // of the original width of input A to the currently displayed
            // width of input A.

            pt.x -= m_lCurStretchWidth;
            pt.x =  (long)((float)pt.x * ((float)m_sizeInput.cx / (float)(m_sizeInput.cx - m_lCurStretchWidth)));
        }
    }

    // Create an adjusted output point to be used for
    // the rest of the calculations.

    CDXDBnds AdjustedOutPoint(OutPoint);

    AdjustedOutPoint.SetXYPoint(pt);

    // The following code was copied from the base class and 
    // modified to use AdjustedOutPoint and the appropriate
    // variable names for this function.

    if ( SUCCEEDED(hr) )
    {
        if ( HaveInput(ulInputIndex) )
        {
            CDXDBnds Out2InBnds(false);
            hr = MapBoundsOut2In(0, &AdjustedOutPoint, ulInputIndex, &Out2InBnds);
            if ( SUCCEEDED(hr) )
            {
                CDXDBnds InSurfBnds(InputSurface(ulInputIndex), hr);
                if ( SUCCEEDED(hr) && InSurfBnds.IntersectBounds(Out2InBnds) )
                {
                    IDXARGBReadPtr * pPtr;
                    hr = InputSurface(ulInputIndex)->LockSurface(&InSurfBnds, 
                                                                 m_ulLockTimeOut, 
                                                                 DXLOCKF_READ, 
                                                                 IID_IDXARGBReadPtr, 
                                                                 (void **)&pPtr, 
                                                                 NULL);
                    if( SUCCEEDED(hr) )
                    {
                        DXPMSAMPLE val;
                        pPtr->UnpackPremult(&val, 1, FALSE);
                        pPtr->Release();
                        if ( val.Alpha )
                        {
                            InSurfBnds.GetMinVector(InVec);
                            bFoundIt = TRUE;
                        }
                    }
                }   
            }
        }
    }
    if (SUCCEEDED(hr) & (!bFoundIt))
    {
        hr = S_FALSE;
    }

    return hr;
}
//  CDXTStretchBase::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    HRESULT hr = S_OK;

    // Reset number of dirty bounds.

    m_cbndsDirty = 0;

    // Calculate current stretch width.

    m_lCurStretchWidth = (long)(m_Progress * m_sizeInput.cx + 0.5);

    // If the inputs, output, or transform is dirty, or if we can't optimize we 
    // have to entirely redraw the output surface.  Otherwise we can create 
    // optimized dirty bounds.

    if (IsInputDirty(0) || IsInputDirty(1) || IsOutputDirty() 
        || IsTransformDirty() || DoOver() || !m_fOptimize
        || !m_fOptimizationPossible)
    {
        switch (m_eStretchStyle)
        {
        case CRSTS_HIDE:
            hr = _CalcFullBoundsHide();

            break;

        case CRSTS_PUSH:
            hr = _CalcFullBoundsPush();

            break;

        case CRSTS_SPIN:
            hr = _CalcFullBoundsSpin();

            break;

        default:
            _ASSERT(0);

            break;
        } // switch (m_eStretchStyle)
    }
    else
    {
        // We can call the functions that will generate bounds that only cover 
        // the dirty areas of the output surface.

        // If the stretch width hasn't changed, nothing needs to be updated.

        if (m_lCurStretchWidth == m_lPrevStretchWidth)
        {
            goto done;
        }

        switch (m_eStretchStyle)
        {
        case CRSTS_HIDE:
            hr = _CalcOptBoundsHide();

            break;

        case CRSTS_PUSH:
            hr = _CalcFullBoundsPush();

            break;

        case CRSTS_SPIN:
            hr = _CalcOptBoundsSpin();

            break;

        default:
            _ASSERT(0);

            break;
        } // switch (m_eStretchStyle)
    }

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::WorkProc, CDXBaseNTo1
//
//  Description:    This function is used to calculate the transformed image 
//                  based on the specified bounds and the current effect 
//                  progress.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStretchBase::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    ULONG   i       = 0;

    long    lInOutOffsetX = WI.OutputBnds.Left() - WI.DoBnds.Left();
    long    lInOutOffsetY = WI.OutputBnds.Top() - WI.DoBnds.Top();

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }


    for (i = 0; i < m_cbndsDirty; i++)
    {
        CDXDBnds    bndsSrc;
        CDXDBnds    bndsDest;

        if (bndsSrc.IntersectBounds(WI.DoBnds, m_abndsDirty[i]))
        {
            if (m_alInputIndex[i] & DO_STRETCH)
            {
                long        lInputIndex = m_alInputIndex[i] & (~DO_STRETCH);
                CDXDBnds    bndsDo;

                // Destination bounds.

                bndsDest = bndsSrc;

                bndsDest[DXB_X].Min  = m_abndsDirty[i].Left();
                bndsDest[DXB_X].Max  = m_abndsDirty[i].Right();

                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                // Do bounds.

                bndsDo = bndsSrc;
                bndsDo.Offset(-m_abndsDirty[i].Left(), -bndsDo.Top(), 0, 0);

                // Source bounds.

                bndsSrc[DXB_X].Min  = 0;
                bndsSrc[DXB_X].Max  = m_sizeInput.cx;

                hr = _HorizontalSquish(bndsDest, bndsDo, 
                                       InputSurface(lInputIndex), 
                                       bndsSrc, dwFlags, INFINITE, pbContinue);
            }
            else
            {
                bndsDest = bndsSrc;
                bndsDest.Offset(lInOutOffsetX, lInOutOffsetY, 0, 0);

                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_alInputIndex[i]), bndsSrc,
                              dwFlags, INFINITE);
            }

            if (FAILED(hr))
            {
                goto done;
            }
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
//  CDXTStretchBase::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStretchBase::OnFreeInstData(CDXTWorkInfoNTo1 & WorkInfo)
{
    m_lPrevStretchWidth = m_lCurStretchWidth;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTStretchBase::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::get_stretchStyle, ICrStretch
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTStretchBase::get_stretchStyle(BSTR * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    switch (m_eStretchStyle)
    {
    case CRSTS_HIDE:
        *pVal = SysAllocString (L"HIDE");
        break;

    case CRSTS_PUSH:
        *pVal = SysAllocString (L"PUSH");
        break;

    case CRSTS_SPIN:
        *pVal = SysAllocString (L"SPIN");
        break;

    default:
        _ASSERT(0);
        break;
    }

    if (NULL == *pVal)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTStretchBase::get_stretchStyle, ICrStretch


//+-----------------------------------------------------------------------------
//
//  CDXTStretchBase::put_stretchStyle, ICrStretch
//
//------------------------------------------------------------------------------
STDMETHODIMP CDXTStretchBase::put_stretchStyle(BSTR newVal)
{
    CRSTRETCHSTYLE eNewStyle = m_eStretchStyle;

    if (!newVal)
    {
        return E_POINTER;
    }

    if (!_wcsicmp(newVal, L"HIDE"))
    {
        eNewStyle = CRSTS_HIDE;
    }
    else if(!_wcsicmp(newVal, L"PUSH"))
    {
        eNewStyle = CRSTS_PUSH;
    }
    else if(!_wcsicmp(newVal, L"SPIN"))
    {
        eNewStyle = CRSTS_SPIN;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (eNewStyle != m_eStretchStyle)
    {
        Lock();
        m_eStretchStyle = eNewStyle;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CDXTStretchBase::put_stretchStyle, ICrStretch
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\strips.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   strips.h
//
//  Overview:   The strips transform.
//
//  Change History:
//  1999/10/01  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef __DXTSTRIPS_H_
#define __DXTSTRIPS_H_

#include "resource.h"   




class ATL_NO_VTABLE CDXTStrips : 
    public CDXBaseNTo1,
    public CComCoClass<CDXTStrips, &CLSID_DXTStrips>,
    public IDispatchImpl<IDXTStrips, &IID_IDXTStrips, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTStrips>,
    public IObjectSafetyImpl2<CDXTStrips>,
    public IPersistStorageImpl<CDXTStrips>,
    public IPersistPropertyBagImpl<CDXTStrips>
{
private:

    typedef enum {
        LEFT_DOWN = 0,
        LEFT_UP,
        RIGHT_DOWN,
        RIGHT_UP,
        MOTION_MAX
    } MOTION;

    MOTION                  m_eMotion;
    static const WCHAR *    s_astrMotion[MOTION_MAX];

    typedef enum {
        LEFT = 0,
        RIGHT,
        BNDSID_MAX
    } BNDSID;

    ULONG                   m_anInputIndex[BNDSID_MAX];
    CDXCBnds                m_abndsBase[BNDSID_MAX];

    long                    m_nStripSize;
    long                    m_cStripsY;
    float                   m_flPrevProgress;
    float                   m_flMaxProgress;
    SIZE                    m_sizeInput;
    CDXCVec                 m_vecNextStripOffset;

    CComPtr<IUnknown>       m_spUnkMarshaler;

    unsigned                m_fNoOp                 : 1;
    unsigned                m_fOptimizationPossible : 1;

    // Helper methods.

    void _CalcStripInfo();

public:

    CDXTStrips();

    DECLARE_POLY_AGGREGATABLE(CDXTStrips)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTSTRIPS)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTStrips)
        COM_INTERFACE_ENTRY(IDXTStrips)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTStrips>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTStrips)
        PROP_ENTRY("motion",    DISPID_DXTSTRIPS_MOTION,    CLSID_DXTStripsPP)
        PROP_PAGE(CLSID_DXTStripsPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);
    HRESULT OnFreeInstData(CDXTWorkInfoNTo1 & WI);

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, ULONG & ulInToTest, 
                                  ULONG aInIndex[], BYTE aWeight[]);

    // IDXTStrips properties.

    STDMETHOD(get_Motion)(BSTR * pbstrMotion);
    STDMETHOD(put_Motion)(BSTR bstrMotion);

    // IDXEffect properties.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__DXTSTRIPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\strips.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  Filename:   strips.cpp
//
//  Overview:   The strips transform.
//
//  Change History:
//  1999/10/01  a-matcal    Created.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "strips.h"




//+-----------------------------------------------------------------------------
//
//  CDXTStrips static variables initialization.
//
//------------------------------------------------------------------------------

const WCHAR * CDXTStrips::s_astrMotion[] = {
    L"leftdown",
    L"leftup",
    L"rightdown",
    L"rightup"
};


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::CDXTStrips
//
//------------------------------------------------------------------------------
CDXTStrips::CDXTStrips() :
    m_eMotion(LEFT_DOWN),
    m_nStripSize(7),
    m_cStripsY(0),
    m_flPrevProgress(0.0F),
    m_flMaxProgress(0.0F),
    m_fNoOp(false),
    m_fOptimizationPossible(false)
{
    long nCurBnds   = 0;

    m_sizeInput.cx  = 0;
    m_sizeInput.cy  = 0;

    // Although they aren't used, the Z and T bounds need to have some area for
    // intersections to work properly.

    for ( ; nCurBnds < (long)BNDSID_MAX; nCurBnds++)
    {
        m_abndsBase[nCurBnds].u.C[DXB_Z].Max = 1.0F;
        m_abndsBase[nCurBnds].u.C[DXB_T].Max = 1.0F;
    }

    // Base class members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
//  CDXTStrips::CDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_spUnkMarshaler.p);
}
//  CDXTStrips::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsInput;

    hr = bndsInput.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsInput.GetXYSize(m_sizeInput);

    m_cStripsY = (m_sizeInput.cy / m_nStripSize) + 1;

    _CalcStripInfo();

done:

    return hr;
} 
//  CDXTStrips::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CDXTStrips::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest,
                                  ULONG aInIndex[], BYTE aWeight[])
{
    HRESULT hr              = S_OK;
    float   flCurProgress   = m_flMaxProgress * m_Progress;

    long    nCurStrip       = 0;
    long    nCurBnds        = 0;

    CDXDBnds    bndsSrc;
    CDXCBnds    abnds[BNDSID_MAX];

    ulInToTest  = 0;    // No input yet found that corresponds to point.
    aWeight[0]  = 255;  // If found, it should be weighted at 100%.

    for ( ; nCurBnds < BNDSID_MAX ; nCurBnds++)
    {
        abnds[nCurBnds] = m_abndsBase[nCurBnds];

        abnds[nCurBnds].Offset(flCurProgress, 0.0F, 0.0F, 0.0F);
    }

    for ( ; (nCurStrip < m_cStripsY) && !ulInToTest ; nCurStrip++)
    {
        for (nCurBnds = 0 ; (nCurBnds < (long)BNDSID_MAX) && !ulInToTest 
             ; nCurBnds++)
        {
            bndsSrc.Copy(abnds[nCurBnds]);

            if (bndsSrc.IntersectBounds(OutPoint))
            {
                ulInToTest  = 1;
                aInIndex[0] = m_anInputIndex[nCurBnds];
            }
            
            abnds[nCurBnds].Offset(m_vecNextStripOffset);
        }
    }
}
//  CDXTStrips::OnGetSurfacePickOrder, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnInitInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStrips::OnInitInstData(CDXTWorkInfoNTo1 & WI, ULONG & ulNumBandsToDo)
{
    if (IsTransformDirty())
    {
        _CalcStripInfo();
    }
    else if ((m_Progress == m_flPrevProgress) && !IsInputDirty(0) 
             && !IsInputDirty(1) && !IsOutputDirty() && !DoOver()
             && m_fOptimizationPossible)
    {
        // The simplest optimization, make sure we don't do the same thing twice
        // in a row.

        m_fNoOp = true;
    }

    // TODO:  More complex optimization to only update pixels that need it.

    // If we were asked to draw the whole output this time, set the 
    // m_fOptimizePossible flag.  If the whole output wasn't drawn the
    // transform won't keep track of which parts are still dirty and
    // optimization won't be reliable.  Since this transform has the same
    // size output as input(s) we just compare the width and height of the
    // DoBnds to that of the input(s).

    if (((LONG)WI.DoBnds.Width() == m_sizeInput.cx) 
        && ((LONG)WI.DoBnds.Height() == m_sizeInput.cy))
    {
        m_fOptimizationPossible = true;
    }
    else
    {
        m_fOptimizationPossible = false;
    }

    return S_OK;
}
//  CDXTStrips::OnInitInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTStrips::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr              = S_OK;
    float   flCurProgress   = m_flMaxProgress * m_Progress;

    DWORD   dwFlags         = 0;
    long    nCurStrip       = 0;
    long    nCurBnds        = 0;

    CDXDVec     vecDo2OutputOffset(WI.OutputBnds.Left() - WI.DoBnds.Left(),
                                   WI.OutputBnds.Top() - WI.DoBnds.Top(), 0, 0);

    CDXDBnds    bndsSrc;
    CDXDBnds    bndsDest;
    CDXCBnds    abnds[BNDSID_MAX];

    // If this has been optimized out, leave function.

    if (m_fNoOp)
    {
        goto done;
    }

    // Copy base bounds to working bounds structures.

    for ( ; nCurBnds < BNDSID_MAX; nCurBnds++)
    {
        abnds[nCurBnds] = m_abndsBase[nCurBnds];

        abnds[nCurBnds].Offset(flCurProgress, 0.0F, 0.0F, 0.0F);
    }

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    // Draw left and right strips then transform the working bounds structures
    // to the next strip row.

    for ( ; nCurStrip < m_cStripsY; nCurStrip++)
    {
        for (nCurBnds = 0 ; nCurBnds < (long)BNDSID_MAX ; nCurBnds++)
        {
            bndsSrc.Copy(abnds[nCurBnds]);

            if (bndsSrc.IntersectBounds(WI.DoBnds))
            {
                bndsDest = bndsSrc;

                bndsDest.Offset(vecDo2OutputOffset);
        
                hr = DXBitBlt(OutputSurface(), bndsDest,
                              InputSurface(m_anInputIndex[nCurBnds]), bndsSrc,
                              dwFlags, INFINITE);

                if (FAILED(hr))
                {
                    goto done;
                }
            }
            
            abnds[nCurBnds].Offset(m_vecNextStripOffset);
        }
    }

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
} 
//  CDXTStrips::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::OnFreeInstData, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT
CDXTStrips::OnFreeInstData(CDXTWorkInfoNTo1 & WI)
{
    m_flPrevProgress    = m_Progress;
    m_fNoOp             = false;

    // Calling IsOutputDirty() clears the dirty condition.

    IsOutputDirty();

    // Clear transform dirty state.

    ClearDirty();

    return S_OK;
}
//  CDXTStrips::OnFreeInstData, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::get_Motion, IDXTStrips
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTStrips::get_Motion(BSTR * pbstrMotion)
{
    DXAUTO_OBJ_LOCK;

    if (NULL == pbstrMotion)
    {
        return E_POINTER;
    }

    if (*pbstrMotion != NULL)
    {
        return E_INVALIDARG;
    }

    *pbstrMotion = SysAllocString(s_astrMotion[m_eMotion]);

    if (NULL == *pbstrMotion)
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
//  CDXTStrips::get_Motion, IDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::put_Motion, IDXTStrips
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTStrips::put_Motion(BSTR bstrMotion)
{
    DXAUTO_OBJ_LOCK;

    int i = 0;

    if (NULL == bstrMotion)
    {
        return E_POINTER;
    }

    for ( ; i < (int)MOTION_MAX ; i++)
    {
        if (!_wcsicmp(bstrMotion, s_astrMotion[i]))
        {
            break;
        }
    }

    if ((int)MOTION_MAX == i)
    {
        return E_INVALIDARG;
    }

    if ((int)m_eMotion != i)
    {
        m_eMotion = (MOTION)i;

        SetDirty();
    }

    return S_OK;
}
//  CDXTStrips::put_Motion, IDXTStrips


//+-----------------------------------------------------------------------------
//
//  CDXTStrips::_CalcStripInfo
//
//------------------------------------------------------------------------------
void
CDXTStrips::_CalcStripInfo()
{
    float   flStripHeight   = (float)m_sizeInput.cy / (float)m_cStripsY;
    float   flStripPad      = flStripHeight * (float)(m_cStripsY - 1);

    if ((0 == m_sizeInput.cx) || (0 == m_sizeInput.cy))
    {
        goto done;
    }

    //
    // Left portion of strip.
    //

    // Left

    switch(m_eMotion)
    {
    case LEFT_UP:

        m_abndsBase[LEFT].u.C[DXB_X].Min = 0.0F;
        break;

    case LEFT_DOWN:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -flStripPad;
        break;
    
    case RIGHT_UP:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -((float)m_sizeInput.cx 
                                             + (flStripPad * 2.0F));
        break;

    case RIGHT_DOWN:

        m_abndsBase[LEFT].u.C[DXB_X].Min = -((float)m_sizeInput.cx 
                                             + flStripPad);
        break;

    default:

        _ASSERT(false);
    }

    // Top

    m_abndsBase[LEFT].u.C[DXB_Y].Min = 0.0F;

    // Right

    m_abndsBase[LEFT].u.C[DXB_X].Max = m_abndsBase[LEFT].Left() 
                                       + (float)m_sizeInput.cx + flStripPad;

    // Bottom

    m_abndsBase[LEFT].u.C[DXB_Y].Max = flStripHeight;

    //
    // Right portion of strip.
    //

    // Left.

    m_abndsBase[RIGHT].u.C[DXB_X].Min = m_abndsBase[LEFT].Right();

    // Top.

    m_abndsBase[RIGHT].u.C[DXB_Y].Min = 0.0F;

    // Right.

    m_abndsBase[RIGHT].u.C[DXB_X].Max = m_abndsBase[LEFT].Right()
                                        + m_abndsBase[LEFT].Width();

    // Bottom.

    m_abndsBase[RIGHT].u.C[DXB_Y].Max = m_abndsBase[LEFT].Bottom();

    //
    // Input indices related to the left and right bounds and max progress.
    //

    if ((LEFT_DOWN == m_eMotion) || (LEFT_UP == m_eMotion))
    {
        m_anInputIndex[LEFT]    = 0;
        m_anInputIndex[RIGHT]   = 1;
        m_flMaxProgress         = -m_abndsBase[LEFT].Width();
    }
    else
    {
        m_anInputIndex[LEFT]    = 1;
        m_anInputIndex[RIGHT]   = 0;
        m_flMaxProgress         = m_abndsBase[LEFT].Width();
    }

    // Vector to translate bounds for next strip down.

    m_vecNextStripOffset.u.C[DXB_Y] = m_abndsBase[LEFT].Bottom();

    if ((LEFT_DOWN == m_eMotion) || (RIGHT_UP == m_eMotion))
    {
        m_vecNextStripOffset.u.C[DXB_X] = m_abndsBase[LEFT].Bottom();
    }
    else
    {
        m_vecNextStripOffset.u.C[DXB_X] = -m_abndsBase[LEFT].Bottom();
    }

done:

    return;
}
//  CDXTStrips::_CalcStripInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\spiral.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		spiral.cpp
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrSpiral transform.
//
// History:
//
// 06/25/98     phillu  initial creation
// 07/01/98     phillu  change CellsPerRow to CellsPerCol in array dim to fix 
//                      overflow bug.
// 07/02/98     phillu  return E_INVALIDARG rather than an error string
// 07/09/98     phillu  implement OnSetSurfacePickOrder().
// 07/23/98     phillu  implement clipping
// 01/25/99     a-matcal    Moved cellsPerCol and cellsPerRow default settings
//                          to FinalConstruct.
// 05/01/99 a-matcal    Optimized.  Derived from CGridBase.
// 10/24/99 a-matcal    Changed CSpiral class to CDXTSpiralBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "spiral.h"




//+-----------------------------------------------------------------------------
//
//  CDXTSpiralBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSpiralBase::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CGridBase::FinalConstruct();

    if (FAILED(hr))
    {
        return hr;
    }

    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTSpiralBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTSpiralBase::OnDefineGridTraversalPath, CGridBase
//
//------------------------------------------------------------------------------
HRESULT 
CDXTSpiralBase::OnDefineGridTraversalPath()
{
    ULONG   ulCell      = 0;
    ULONG   ulDir       = 0;
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;
    RECT    rcBnd;

    // Starting x and y coordinates.

    int     x = 0;
    int     y = 0;

    // rcBnd represents the bounds that are not yet covered as the 
    // spiral moves around the matrix.

    rcBnd.left      = 0;
    rcBnd.right     = m_sizeGrid.cx;
    rcBnd.top       = 0;
    rcBnd.bottom    = m_sizeGrid.cy;

    // Traverse matrix and create index.

    while (ulCell < ulMax)
    {
        switch (ulDir)
        {
        case 0: // right

            y = rcBnd.top; // clockwise

            for (x = rcBnd.left; x < rcBnd.right; x++)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.top++;

            break;

        case 1: // down

            x = rcBnd.right - 1; // clockwise

            for (y = rcBnd.top; y < rcBnd.bottom; y++)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.right--;
            
            break;

        case 2: // left

            y = rcBnd.bottom - 1; // clockwise

            for (x = (rcBnd.right - 1); x >= rcBnd.left; x--)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.bottom--;

            break;

        case 3: // up

            x = rcBnd.left; // clockwise

            for (y = (rcBnd.bottom - 1); y >= rcBnd.top; y--)
            {
                m_paulIndex[ulCell] = (y * m_sizeGrid.cx) + x;
                ulCell++;
            }

            rcBnd.left++;

            break;

        default:

            _ASSERT(0);
        }

        // Change to next direction (clockwise).

        ulDir = (ulDir + 1) % 4;

    } // while (ulCell < ulEnd)

    return S_OK;
}
//  CDXTSpiralBase::OnDefineGridTraversalPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\wave.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    wave.h
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	header file for wave transform implementation CWave
//
// Change History:
//
// 1999/05/20   PhilLu      Move code from dtcss to dxtmsft. New algorithm.
// 1999/12/10   mcalkins    Added support for IDXTClipOrigin interface.
// 2000/02/04   mcalkins    Implement OnSurfacePick method.
// 2000/05/10   mcalkins    Support IObjectSafety appropriately.
//
//------------------------------------------------------------------------------

#ifndef __WAVE_H_
#define __WAVE_H_

#include "resource.h"




class ATL_NO_VTABLE CWave : 
    public CDXBaseNTo1,
    public CComCoClass<CWave, &CLSID_DXTWave>,
    public CComPropertySupport<CWave>,
    public IDispatchImpl<IDXTWave, &IID_IDXTWave, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public IObjectSafetyImpl2<CWave>,
    public IPersistStorageImpl<CWave>,
    public ISpecifyPropertyPagesImpl<CWave>,
    public IPersistPropertyBagImpl<CWave>,
    public IDXTClipOrigin
{
private:
    long    m_lStrength;
    long    m_cWaves;
    float   m_flPhase;
    float   m_flLightStrength;
    bool    m_fAdd;
    SIZE    m_sizeInput;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // Helpers
    inline BYTE NClamp(int i)
    {
        return (i < 0 ? 0 : (i > 255 ? 255 : i));
    }

    void _TransformRow(DXSAMPLE *pBuffer, int nWidth, int nHeight, int nRow);

public:

    CWave();

    DECLARE_POLY_AGGREGATABLE(CWave)
    DECLARE_REGISTER_DX_IMAGE_AUTHOR_TRANS(IDR_WAVE)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CWave)
        COM_INTERFACE_ENTRY(IDXTWave)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IDXTClipOrigin)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CWave>)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CWave)
        PROP_ENTRY("Add",           DISPID_DXTWAVE_ADD,             CLSID_DXTWavePP)
        PROP_ENTRY("Freq",          DISPID_DXTWAVE_FREQ,            CLSID_DXTWavePP)
        PROP_ENTRY("LightStrength", DISPID_DXTWAVE_LIGHTSTRENGTH,   CLSID_DXTWavePP)
        PROP_ENTRY("Phase",         DISPID_DXTWAVE_PHASE,           CLSID_DXTWavePP)
        PROP_ENTRY("Strength",      DISPID_DXTWAVE_STRENGTH,        CLSID_DXTWavePP)
        PROP_PAGE(CLSID_DXTWavePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides

    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinueProcessing);
    HRESULT OnSetup(DWORD dwFlags);
    HRESULT OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                          CDXDVec & InVec);
    HRESULT DetermineBnds(CDXDBnds & Bnds);

    // IDXTransform methods.

    STDMETHOD(MapBoundsOut2In)(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                               ULONG ulInIndex, DXBNDS * pInBounds);

    // IDXTClipOrigin methods.

    STDMETHOD(GetClipOrigin)(DXVEC * pvecClipOrigin);

    // IDXTWave methods

    STDMETHOD(get_Add)(VARIANT_BOOL * pVal);
    STDMETHOD(put_Add)(VARIANT_BOOL newVal);
    STDMETHOD(get_Freq)(long * pval);
    STDMETHOD(put_Freq)(long newVal);
    STDMETHOD(get_LightStrength)(int * pval);
    STDMETHOD(put_LightStrength)(int newVal);
    STDMETHOD(get_Phase)(int * pval);
    STDMETHOD(put_Phase)(int newVal);
    STDMETHOD(get_Strength)(long * pval);
    STDMETHOD(put_Strength)(long newVal);
};

#endif //__WAVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\wave.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
// FileName:    wave.cpp
//
// Created:     05/20/99
//
// Author:      phillu
//
// Discription:	Implementation the wave transform CWave
//
// Change History:
//
// 1999/05/20   PhilLu      Move code from dtcss to dxtmsft. New implementation
//                          of wave generation algorithm.
// 1999/09/28   mcalkins    Changed property put_ functions to stop checking 
//                          parameters so they'll work like the old version's. 
// 2000/02/04   mcalkins    Implement OnSurfacePick method.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include <math.h>
#include "dxtmsft.h"
#include "Wave.h"

const float gc_PI = 3.14159265359f;


//+-----------------------------------------------------------------------------
//
//  CWave::CWave
//
//------------------------------------------------------------------------------
CWave::CWave():
    m_lStrength(1),
    m_cWaves(3),
    m_flPhase(0.0f),
    m_flLightStrength(1.0f),
    m_fAdd(false)
{
    m_ulMaxImageBands   = 1;
    m_ulMaxInputs       = 1;
    m_ulNumInRequired   = 1;
}
//  CWave::CWave


//+-----------------------------------------------------------------------------
//
//  CWave::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CWave::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CWave::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  CWave::get_Add, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Add(VARIANT_BOOL * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }

    if (m_fAdd)
    {
        *pVal = VARIANT_TRUE;
    }
    else 
    {
        *pVal = VARIANT_FALSE;
    }

    return S_OK;
}
//  CWave::get_Add, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Add, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Add(VARIANT_BOOL newVal)
{
    if (newVal != VARIANT_TRUE && newVal != VARIANT_FALSE)
    {
        return E_INVALIDARG;
    }

    Lock();
    bool fAdd = false;
    if (newVal == VARIANT_TRUE)
    {
        fAdd = true;
    }

    if (fAdd != m_fAdd)
    {
        m_fAdd = fAdd;
        SetDirty();
    }

    Unlock();
    return S_OK;
}
//  CWave::put_Add, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Freq, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Freq(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = m_cWaves;
    return S_OK;
}
//  CWave::get_Freq, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Freq, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Freq(long newVal)
{
    if (newVal < 1)
    {
        newVal = 1;
    }

    if (newVal != m_cWaves)
    {
        Lock();
        m_cWaves = newVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_Freq, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_LightStrength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_LightStrength(int * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = (int)(m_flLightStrength * 100.0f);
    return S_OK;
}
//  CWave::get_LightStrength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_LightStrength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_LightStrength(int newVal)
{
    // This is bad because instead of letting the user know their value is out
    // of range, you just change it for them.  They may or may not get what they
    // expect with a value of 505.  This mimics the behavior of the old filter.

    if (newVal < 0)
    {
        newVal = 0;
    }
    else if (newVal > 100)
    {
        newVal = 100;
    }

    float fVal = (float)newVal * 0.01f;
    if (fVal != m_flLightStrength)
    {
        Lock();
        m_flLightStrength = fVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_LightStrength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Phase, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Phase(int * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = (int)(m_flPhase * 100.0f);
    return S_OK;
}
//  CWave::get_Phase, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Phase, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Phase(int newVal)
{
    // This is how the old filter would parameter check for this particular 
    // property.  It's not necessarily the same as how it checks the other 
    // properties.

    newVal = newVal % 100;

    float fVal = (float)newVal * 0.01f;

    if (fVal != m_flPhase)
    {
        Lock();
        m_flPhase = fVal;
        SetDirty();
        Unlock();
    }

    return S_OK;
}
//  CWave::put_Phase, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::get_Strength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::get_Strength(long * pVal)
{
    if (DXIsBadWritePtr(pVal, sizeof(*pVal)))
    {
        return E_POINTER;
    }
    *pVal = m_lStrength;
    return S_OK;
}
//  CWave::get_Strength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::put_Strength, CDXTWave
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CWave::put_Strength(long newVal)
{
    if (newVal < 0)
    {
        return E_INVALIDARG;
    }

    if (newVal != m_lStrength)
    {
        Lock();
        m_lStrength = newVal;
        SetDirty();
        Unlock();
    }
    return S_OK;
}
//  CWave::put_Strength, CDXTWave


//+-----------------------------------------------------------------------------
//
//  CWave::OnSurfacePick, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CWave::OnSurfacePick(const CDXDBnds & OutPoint, ULONG & ulInputIndex, 
                     CDXDVec & InVec)
{
    HRESULT hr = S_OK;

    // compute the sine pattern which controls both the shift and lighting
    // note phase is given in fraction of cycles.
    
    float flCycle   = (float)(m_cWaves * OutPoint.Top()) 
                      / (float)m_sizeInput.cy;
    float flSine    = (float)sin(2.0f * gc_PI * (flCycle + m_flPhase));

    // horizontal offset (left or right)
    
    int nOffset = (int)(flSine * m_lStrength);


    if ((OutPoint.Left() < 0) 
        || (OutPoint.Left() >= (m_sizeInput.cx + (m_lStrength * 2)))
        || (OutPoint.Top() < 0) || (OutPoint.Top() >= m_sizeInput.cy))
    {
        hr = E_INVALIDARG;

        goto done;
    }
    
    OutPoint.GetMinVector(InVec);

    if (((InVec.u.D[DXB_X] - nOffset) < 0) 
        || ((InVec.u.D[DXB_X] - nOffset) >= m_sizeInput.cx))
    {
        hr = DXT_S_HITOUTPUT;
    }
    else
    {
        InVec.u.D[DXB_X] -= nOffset;

        DXSAMPLE                sample;
        CDXDBnds                bndsLock(InVec);
        CComPtr<IDXARGBReadPtr> spDXARGBReadPtr;

        hr = InputSurface()->LockSurface(&bndsLock, m_ulLockTimeOut, 
                                         DXLOCKF_READ, __uuidof(IDXARGBReadPtr),
                                         (void **)&spDXARGBReadPtr,
                                         NULL);

        if (FAILED(hr))
        {
            goto done;
        }

        spDXARGBReadPtr->Unpack(&sample, 1, FALSE);

        if (0 == sample.Alpha)
        {
            hr = S_FALSE;
        }
    }
    
done:

    return hr;
}
//  CWave::OnSurfacePick, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CWave::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CWave::OnSetup(DWORD dwFlags)
{
    HRESULT hr = S_OK;

    CDXDBnds bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (SUCCEEDED(hr))
    {
        bndsIn.GetXYSize(m_sizeInput);
    }

    return hr;

}
//  CWave::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  CWave::DetermineBnds, CDXBaseNTo1
//
//  This overrides the base function so as to map to an output surface larger
//  than the input surface.
//
//------------------------------------------------------------------------------
HRESULT 
CWave::DetermineBnds(CDXDBnds & Bnds)
{
    SIZE size;

    Bnds.GetXYSize(size);
    size.cx += (m_lStrength*2);
    Bnds.SetXYSize(size);
    return S_OK;
} /* CWave::DetermineBnds */


//+-----------------------------------------------------------------------------
//
//  Method: CWave::MapBoundsOut2In, IDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CWave::MapBoundsOut2In(ULONG ulOutIndex, const DXBNDS * pOutBounds,
                       ULONG ulInIndex, DXBNDS * pInBounds)
{
    CDXDBnds    bndsInput;

    if ((NULL == pOutBounds) || (NULL == pInBounds))
    {
        return E_POINTER;
    }

    if (ulOutIndex || ulInIndex)
    {
        return E_INVALIDARG;
    }

    if (NULL == InputSurface())
    {
        return E_UNEXPECTED;
    }

    // What we do is expand the bounds to the left and right by half of the
    // strength of the wave and then intersect
    // those bounds with the original input bounds.  This will give us the
    // input bounds needed to calculate the output area.

    *pInBounds = *pOutBounds;

    if (m_lStrength)
    {
        pInBounds->u.D[DXB_X].Min -= m_lStrength;
        pInBounds->u.D[DXB_X].Max += m_lStrength;
    }

    bndsInput.SetXYSize(m_sizeInput);

    ((CDXDBnds *)pInBounds)->IntersectBounds(bndsInput);

    return S_OK;
}
//  Method: CWave::MapBoundsOut2In, IDXTransform


//+-----------------------------------------------------------------------------
//
//  CWave::WorkProc, CDXBaseNTo1
//
//  The Wave transform creates a horizontal sine pattern of lighting strength 
//  as well as a sine-patterned shift on each line. Optionally the original 
//  image is added to the transformed image.
//
//------------------------------------------------------------------------------
HRESULT 
CWave::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL* pbContinueProcessing)
{
    HRESULT hr      = S_OK;
    int     y       = 0;

    DXSAMPLE *      pOperationBuffer = NULL;
    DXSAMPLE *      pRowInBuffer     = NULL;
    DXPMSAMPLE *    pOutBuff         = NULL;
    DXPMSAMPLE *    pPMBuff          = NULL;

    DXDITHERDESC    dxdd;

    CComPtr<IDXARGBReadWritePtr>    pDest;
    CComPtr<IDXARGBReadPtr>         pSrc;

    const int nOperationBufferWidth = m_sizeInput.cx + (m_lStrength * 2);
    const int nDoWidth              = WI.DoBnds.Width();
    const int nDoHeight             = WI.DoBnds.Height();

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr,
                                      (void**)&pDest, NULL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = InputSurface()->LockSurface(NULL, m_ulLockTimeOut, DXLOCKF_READ,
                                     IID_IDXARGBReadPtr, (void**)&pSrc, NULL);
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (DoOver() && OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(nDoWidth);
    }

    pOperationBuffer = DXSAMPLE_Alloca(nOperationBufferWidth);

    //
    //  Set up the dither structure
    //
    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = &pOperationBuffer[WI.DoBnds.Left()];
        dxdd.cSamples       = nDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    for (y = 0; y < nDoHeight; y++)
    {
        // Move to the correct input row.
        
        pSrc->MoveToRow(WI.DoBnds.Top() + y);
        
        // Read an input line to the operation buffer.     
        
        pSrc->Unpack(&pOperationBuffer[m_lStrength], m_sizeInput.cx, FALSE);

        // Transform this row of pixels.
        
        _TransformRow(pOperationBuffer, nOperationBufferWidth, m_sizeInput.cy, 
                      WI.DoBnds.Top() + y);

        // Move to appropriate output row.
        
        pDest->MoveToRow(y);

        // Dither if requested.
        
        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        // Blit row to output.
        
        if (DoOver())
        {
            pPMBuff = DXPreMultArray(&pOperationBuffer[WI.DoBnds.Left()], 
                                     nDoWidth);
                                     
            pDest->OverArrayAndMove(pOutBuff, pPMBuff, nDoWidth);
        }
        else
        {
            pDest->PackAndMove(&pOperationBuffer[WI.DoBnds.Left()], nDoWidth);
        }

    }

    return hr;
}
//  CWave::WorkProc, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method:  CWave::GetClipOrigin, IDXTClipOrigin
//
//------------------------------------------------------------------------------
STDMETHODIMP
CWave::GetClipOrigin(DXVEC * pvecClipOrigin)
{
    if (NULL == pvecClipOrigin)
    {
        return E_POINTER;
    }

    pvecClipOrigin->u.D[DXB_X] = m_lStrength;
    pvecClipOrigin->u.D[DXB_Y] = 0;

    return S_OK;
}
//  Method:  CWave::GetClipOrigin, IDXTClipOrigin


//+-----------------------------------------------------------------------------
//
//  CWave::_TransformRow
//
//  On entry, pBuffer contains a row of input pixels (placed at the middle of 
//  the array, with an offset of m_Strength from the start of array). The
//  first and last m_Strength elements of pBuffer are unspecified.
//
//  On return, pBuffer will contain a row of transformed image which is the 
//  input row shifted horizontally and modulated with a sine lighting pattern. 
//  Optionally the original input row is added to the transformed row.
//
//------------------------------------------------------------------------------
void 
CWave::_TransformRow(DXSAMPLE *pBuffer, int nWidth, int nHeight, int nRow)
{
    // compute the sine pattern which controls both the shift and lighting
    // note phase is given in fraction of cycles.
    
    float flCycle   = (float)(m_cWaves * nRow) / (float)nHeight;
    float flSine    = (float)sin(2.0f * gc_PI * (flCycle + m_flPhase));

    // horizontal offset (left or right)
    
    int nOffset = (int)(flSine * m_lStrength);
    
    // lighting weight: always in [0,1], maximum 1
    
    float flWeight = 1.0f - 0.5f * m_flLightStrength * (1.0f - flSine);

    int         nCount, nIndex, nInc, i;
    DXSAMPLE    pix;

    // shift and add the pixels to the original array. Either go forwards
    // or backwards to ensure a source pixel is not ovewritten before used.
    
    if (nOffset <= 0)
    {
        nIndex = -nOffset;
        nInc = 1;
        nCount = nWidth+nOffset;
    }
    else
    {
        nIndex = nWidth-1-nOffset;
        nInc = -1;
        nCount = nWidth-nOffset;
    }

    // The first and last m_lStrength elements of pBuffer are unspecified.
    // Fill in 0 values
    
    for (i=0; i<m_lStrength; i++)
    {
        pBuffer[i] = 0;
        pBuffer[nWidth-1-i] = 0;
    }

    while (nCount > 0)
    {
        DXSAMPLE pix = pBuffer[nIndex];
        if (m_fAdd)
        {
            DXSAMPLE srcPix = pBuffer[nIndex + nOffset];
            pix.Red = NClamp((int)(pix.Red * flWeight) + srcPix.Red);
            pix.Green = NClamp((int)(pix.Green * flWeight) + srcPix.Green);
            pix.Blue = NClamp((int)(pix.Blue * flWeight) + srcPix.Blue);
            pix.Alpha = max(pix.Alpha, srcPix.Alpha);
        }
        else
        {
            pix.Red = (BYTE)(pix.Red * flWeight);
            pix.Green = (BYTE)(pix.Green * flWeight);
            pix.Blue = (BYTE)(pix.Blue * flWeight);
        }

        pBuffer[nIndex+nOffset] = pix;
        nIndex += nInc;
        nCount--;
    }
}
//  CWave::_TransformRow
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\wheel.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998-1999
//
// FileName:		wheel.h
//
// Created:		07/06/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrWheel transformation
//
// 05/20/99 a-matcal    Code scrub.
//
//------------------------------------------------------------------------------

#ifndef __CRWHEEL_H_
#define __CRWHEEL_H_

#include "resource.h"




class ATL_NO_VTABLE CWheel : 
    public CDXBaseNTo1,
    public CComCoClass<CWheel, &CLSID_CrWheel>,
    public IDispatchImpl<ICrWheel, &IID_ICrWheel, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CWheel>,
    public IObjectSafetyImpl2<CWheel>,
    public IPersistStorageImpl<CWheel>,
    public ISpecifyPropertyPagesImpl<CWheel>,
    public IPersistPropertyBagImpl<CWheel>
{
private:

    SIZE    m_sizeInput;
    short   m_sSpokes;

    CComPtr<IUnknown> m_cpUnkMarshaler;

    void _ComputeTrigTables(float fProgress, double *sinAngle, double *cosAngle);
    void _ScanlineIntervals(long width, long height, double *sinAngle,
                            double *cosAngle, long YScanline, long *XBounds);
    void _ClipBounds(long offset, long width, long *XBounds);

public:

    CWheel();

    DECLARE_POLY_AGGREGATABLE(CWheel)
    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_WHEEL)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CWheel)
        COM_INTERFACE_ENTRY(ICrWheel)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CWheel>)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CWheel)
        PROP_ENTRY("spokes"       , 1, CLSID_CrWheelPP)
        PROP_PAGE(CLSID_CrWheelPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    void    OnGetSurfacePickOrder(const CDXDBnds & TestPoint, 
                                  ULONG & ulInToTest, ULONG aInIndex[], 
                                  BYTE aWeight[]);

    HRESULT WorkProc(const CDXTWorkInfoNTo1& WI, BOOL * pbContinue);
    HRESULT OnSetup(DWORD dwFlags);

    // ICrWheel methods.

    STDMETHOD(get_spokes)(/*[out, retval]*/ short *pVal);
    STDMETHOD(put_spokes)(/*[in]*/ short newVal);

    // IDXEffect methods.

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};

#endif //__CRWHEEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\zigzag.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		zigzag.cpp
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the implementation of the CrZigzag transform.
//
// History:
//
// 06/25/98     phillu      initial creation
// 07/01/98     phillu      change CellsPerRow to CellsPerCol in array dim to 
//                          fix overflow bug.
// 07/02/98     phillu      return E_INVALIDARG rather than an error string
// 07/19/98     kipo        fixed off-by-one bug in _GridBounds by increasing 
//                          size of stack-allocated array by one. Also checked 
//                          for invalid Y values to avoid wallking off the ends 
//                          of the array.
// 07/23/98     phillu      implement clipping
// 01/25/99     a-matcal    Moved default cellsPerCol and cellsPerRow settings
//                          to FinalConstruct and removed from OnSetup so that
//                          saved property bag settings will not be ignored.
// 05/01/99     a-matcal    Reimplemented transform to use the CGridBase class.
// 10/24/99     a-matcal    Changed CZigzag class to CDXTZigZagBase base class.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "zigzag.h"




//+-----------------------------------------------------------------------------
//
//  CDXTZigZagBase::FinalConstruct
//
//------------------------------------------------------------------------------
HRESULT CDXTZigZagBase::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CGridBase::FinalConstruct();

    if (FAILED(hr))
    {
        return hr;
    }

    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
//  CDXTZigZagBase::FinalConstruct


//+-----------------------------------------------------------------------------
//
//  CDXTZigZagBase::OnDefineGridTraversalPath, CGridBase
//
//------------------------------------------------------------------------------
HRESULT 
CDXTZigZagBase::OnDefineGridTraversalPath()
{
    ULONG   ulCell      = 0;
    ULONG   ulDir       = 0;
    ULONG   ulMax       = m_sizeGrid.cx * m_sizeGrid.cy;

    // Starting x and y coordinates.

    int     x = 0;
    int     y = 0;

    // Traverse matrix and create index.

    for (y = 0; y < m_sizeGrid.cy; y++)
    {
        ULONG ulRowStart = y * m_sizeGrid.cx;

        switch (ulDir)
        {
        case 0: // right

            for (x = 0; x < m_sizeGrid.cx; x++)
            {
                m_paulIndex[ulCell] = ulRowStart + x;
                ulCell++;
            }

            break;

        case 1: // left

            for (x = m_sizeGrid.cx - 1; x >= 0; x--)
            {
                m_paulIndex[ulCell] = ulRowStart + x;
                ulCell++;
            }

            break;

        default:

            _ASSERT(0);
        }

        // Change to next direction (clockwise).

        ulDir = (ulDir + 1) % 2;

    } // while (ulCell < ulEnd)

    return S_OK;
}
//  CDXTZigZagBase::OnDefineGridTraversalPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\zigzag.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:		zigzag.h
//
// Created:		06/25/98
//
// Author:		phillu
//
// Discription:		This is the header file for the CrZigzag transformation
//
// History:
//
// 05/01/99 a-matcal    Reimplemented transform to use the CGridBase class.
// 10/24/99 a-matcal    Changed CZigzag class to CDXTZigZagBase and created two
//                      new classes CDXTZigZag and CDXTZigZagOpt to represent  
//                      non-optimized and optimized versions respectively.
//
//------------------------------------------------------------------------------

#ifndef __CRZIGZAG_H_
#define __CRZIGZAG_H_

#include "resource.h"      
#include "gridbase.h"




class ATL_NO_VTABLE CDXTZigZagBase : 
    public CGridBase,
    public IDispatchImpl<ICrZigzag, &IID_ICrZigzag, &LIBID_DXTMSFTLib, 
                         DXTMSFT_TLB_MAJOR_VER, DXTMSFT_TLB_MINOR_VER>,
    public CComPropertySupport<CDXTZigZagBase>,
    public IObjectSafetyImpl2<CDXTZigZagBase>,
    public ISpecifyPropertyPagesImpl<CDXTZigZagBase>
{
private:

    CComPtr<IUnknown> m_cpUnkMarshaler;

    // CGridBase overrides

    HRESULT OnDefineGridTraversalPath();

public:

    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CDXTZigZagBase)
        COM_INTERFACE_ENTRY(ICrZigzag)
        COM_INTERFACE_ENTRY(IDXTGridSize)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_cpUnkMarshaler.p)
        COM_INTERFACE_ENTRY(IDXEffect)
        COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTZigZagBase>)
        COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
        COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTZigZagBase)
        PROP_ENTRY("gridSizeX"       , 1, CLSID_CrZigzagPP)
        PROP_ENTRY("gridSizeY"       , 2, CLSID_CrZigzagPP)
        PROP_PAGE(CLSID_CrZigzagPP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // IDXTGridSize, ICrZigzag

    DECLARE_IDXTGRIDSIZE_METHODS()

    // IDXEffect

    DECLARE_IDXEFFECT_METHODS(DXTET_MORPH)
};


class ATL_NO_VTABLE CDXTZigZag :
    public CDXTZigZagBase,
    public CComCoClass<CDXTZigZag, &CLSID_CrZigzag>,
    public IPersistStorageImpl<CDXTZigZag>,
    public IPersistPropertyBagImpl<CDXTZigZag>
{
public:

    CDXTZigZag()
    {
        m_fOptimize = false;
    }

    // Using DECLARE_REGISTRY_RESOURCEID will make the transform available for
    // use but won't add it to the "Image DirectTransform" category in the 
    // registry.

    DECLARE_REGISTRY_RESOURCEID(IDR_DXTZIGZAG)
    DECLARE_POLY_AGGREGATABLE(CDXTZigZag)

    BEGIN_COM_MAP(CDXTZigZag)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTZigZagBase)
    END_COM_MAP()
};


class ATL_NO_VTABLE CDXTZigZagOpt :
    public CDXTZigZagBase,
    public CComCoClass<CDXTZigZagOpt, &CLSID_DXTZigzag>,
    public IPersistStorageImpl<CDXTZigZagOpt>,
    public IPersistPropertyBagImpl<CDXTZigZagOpt>
{
public:

    CDXTZigZagOpt()
    {
        m_fOptimize = true;
    }

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTZIGZAGOPT)
    DECLARE_POLY_AGGREGATABLE(CDXTZigZagOpt)

    BEGIN_COM_MAP(CDXTZigZagOpt)
        COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
        COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
        COM_INTERFACE_ENTRY_CHAIN(CDXTZigZagBase)
    END_COM_MAP()
};


#endif //__CRZIGZAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\msft\src\wheel.cpp ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1998
//
// FileName:                wheel.cpp
//
// Created:                 07/01/98
//
// Author:                  PhilLu
//
// Discription:             This file implements the Wheel transform.
//
// 07/01/98 phillu      initial creation
// 07/09/98 phillu      implement OnSetSurfacePickOrder().
// 07/23/98 phillu      implement clipping
// 05/20/98 a-matcal    Code scrub.
//
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "dxtmsft.h"
#include "wheel.h"

const int MAXBOUNDS = 30;
const int MAXANGLES = 60;
const double gc_PI = 3.14159265358979323846;




//+-----------------------------------------------------------------------------
//
// CWheel::CWheel
//
//------------------------------------------------------------------------------
CWheel::CWheel() :
    m_sSpokes(4)
{
    m_sizeInput.cx = 0;
    m_sizeInput.cy = 0;

    // CDXBaseNTo1 members.

    m_ulMaxInputs       = 2;
    m_ulNumInRequired   = 2;
    m_dwOptionFlags     = DXBOF_SAME_SIZE_INPUTS | DXBOF_CENTER_INPUTS;
    m_Duration          = 1.0;
}
// CWheel::CWheel


//+-----------------------------------------------------------------------------
//
// CWheel::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT CWheel::FinalConstruct()
{
    return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                         &m_cpUnkMarshaler.p);
}
// CWheel::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
// CWheel::OnSetup, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT CWheel::OnSetup(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    CDXDBnds    bndsIn;

    hr = bndsIn.SetToSurfaceBounds(InputSurface(0));

    if (FAILED(hr))
    {
        goto done;
    }

    bndsIn.GetXYSize(m_sizeInput);

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CWheel::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
// CWheel::OnGetSurfacePickOrder, CDXBaseNTo1
//
//------------------------------------------------------------------------------
void 
CWheel::OnGetSurfacePickOrder(const CDXDBnds & OutPoint, ULONG & ulInToTest, 
                              ULONG aInIndex[], BYTE aWeight[])
{
    long    alXBounds[MAXBOUNDS];
    double  adblSinAngle[MAXANGLES];
    double  adblCosAngle[MAXANGLES];
    long    i = 0;

    if (m_Progress == 0.0)
    {
        aInIndex[0] = 0;
    }
    else if (m_Progress == 1.0)
    {
        aInIndex[0] = 1;
    }
    else
    {
        // prepare a list of cos and sin of angles

        _ComputeTrigTables(m_Progress, adblSinAngle, adblCosAngle);

        aInIndex[0] = 0;

        if ((OutPoint.Left() >= 0) && (OutPoint.Left() < m_sizeInput.cx) 
            && (OutPoint.Top() >= 0) && (OutPoint.Top() < m_sizeInput.cy))
        {
            _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, adblSinAngle, 
                               adblCosAngle, OutPoint.Top(), alXBounds);
    
            for (i = 0; alXBounds[i] < OutPoint.Left(); i++)
            {
                aInIndex[0] = 1 - aInIndex[0];
            }
        }
    }

    ulInToTest = 1;
    aWeight[0] = 255;
}
// CWheel::OnGetSurfacePickOrder, CDXBaseNTo1

//+-----------------------------------------------------------------------------
//
// CWheel::get_spokes, ICrWheel
//
//------------------------------------------------------------------------------
STDMETHODIMP CWheel::get_spokes(short * pVal)
{
   HRESULT hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
    }
    else
    {
        *pVal = m_sSpokes;
    }

    return hr;
}
// CWheel::get_spokes, ICrWheel


//+-----------------------------------------------------------------------------
//
// CWheel::put_spokes, ICrWheel
//
//------------------------------------------------------------------------------
STDMETHODIMP CWheel::put_spokes(short newVal)
{
    if ((newVal >= 2) && (newVal < 21))
    {
        if (m_sSpokes != newVal)
        {
            m_sSpokes = newVal;
            SetDirty();
        }
    }
    else
    {
        return E_INVALIDARG;
    }

    return S_OK;
}
// CWheel::put_spokes, ICrWheel


//+-----------------------------------------------------------------------------
//
// CWheel::_ScanlineIntervals
//
// A helper method that calculates the transition boundaries between the
// two image regions on a scanline. Based on the type of transform, the scanline
// consists of a series of alternating A and B image sections. The upper X
// bound of each section is calculated and saved in array XBounds. The number
// of useful entries in XBounds is variable. The end of array is determined
// when one entry equals to the scanline (image) width. It is assumed that
// XBounds[0] is the upper bound of the first A section. So if the scanline
// starts with a B section, XBounds[0] will be 0.
//
// Example 1: scanline length = 16, first section is from A image
//
//    AAAABBBBBAAABBAA      XBounds should contain {4, 9, 12, 14, 16}.
//
// Example 2: scanline length = 16, first section is from B image
//
//    BBBAAAAAABBBBBBB      XBounds should contain {0, 3, 9, 16}.
//
//
// Note: It is possible that some section has length 0 (i.e. two adjacent
//       bounds equal). {3, 9, 9, 16} is equivalent to {3, 16}.
//
// Parameters:
//
// width, height: width and height of both images.
// sinAngle, cosAngle: arrays of sin and cos of radial angles
// YScanline: Y cooridnate (height) of the current scanline
// XBounds: array to hold the computed X bounds on return.
//
//
// Created by: PhilLu    07/06/98
// 
//------------------------------------------------------------------------------
void 
CWheel::_ScanlineIntervals(long width, long height, 
                           double *sinAngle, double *cosAngle,
                           long YScanline, long *XBounds)
{
    long CenterX, CenterY, intercX, i;
    long index = 0;
    double deltaY;
    const double eps = 0.0001;

    // Center of image
    CenterX = width/2;
    CenterY = height/2;

    // plus 0.5 is to make the center in between two lines rather than on a grid.
    // that way the shape will be symmetric
    deltaY = YScanline - CenterY + 0.5;

    if (deltaY < 0)
    {
        XBounds[index++] = 0;
        for(i=1; i<2*m_sSpokes && sinAngle[i] >= 0; ++i)
        {
            if (sinAngle[i] > eps)
            {
                intercX = (long)(CenterX + deltaY*cosAngle[i]/sinAngle[i] + 0.5);
                intercX = min(max(intercX, 0), width);
            }
            else if (cosAngle[i] > 0)
            {
                intercX = 0;
            }
            else
            {
                intercX = width;
            }

            XBounds[index++] = intercX;
        }

        XBounds[index++] = width;
    }
    else // deltaY > 0
    {
        for(i=2*m_sSpokes-1; i>=0 && sinAngle[i] <= 0; --i)
        {
            if (sinAngle[i] < -eps)
            {
                intercX = (long)(CenterX + deltaY*cosAngle[i]/sinAngle[i] + 0.5);
                intercX = min(max(intercX, 0), width);
            }
            else if (cosAngle[i] > 0)
            {
                intercX = 0;
            }
            else
            {
                intercX = width;
            }
            
            XBounds[index++] = intercX;
        }

        XBounds[index++] = width;
    }		
}
// CWheel::_ScanlineIntervals


//+-----------------------------------------------------------------------------
//
// CWheel::_ComputeTrigTables
//
// Overview:    Compute the a list of sin and cos values of the angles. The 
//              arrays should be allocated before calling this function. Their 
//              bounds should be 2 * m_sSpokes.
//
//------------------------------------------------------------------------------
void CWheel::_ComputeTrigTables(float fProgress, double *sinAngle, double *cosAngle)
{
    for(long i=0; i<m_sSpokes; ++i)
    {
        // these angles are measured from 9 o'clock, clockwise
        double startAngle   = (double)i / (double)m_sSpokes * 2 * gc_PI;
        double endAngle     = startAngle + (double)fProgress * 2 * gc_PI / m_sSpokes;
   
        sinAngle[2 * i]     = sin(startAngle);
        cosAngle[2 * i]     = cos(startAngle);
        sinAngle[2 * i + 1] = sin(endAngle);
        cosAngle[2 * i + 1] = cos(endAngle);
    }
}
// CWheel::_ComputeTrigTables


//+-----------------------------------------------------------------------------
//
// CWheel::_ClipBounds
//
//  Overview:   Initially the X-bounds are specified relative to the entire 
//              image. After clipping, the bounds should be transformed to be 
//              relative to the clipping region.
//
//  Arguments:  offset:
//              width:      offset and width of the clipping region (along X)
//              XBounds:    array of X-bounds
//
//  Created by: PhilLu    07/21/98
//
//------------------------------------------------------------------------------
void 
CWheel::_ClipBounds(long offset, long width, long * XBounds)
{
    int i;

    for(i=0; XBounds[i] < offset+width; i++)
    {
        if (XBounds[i] < offset)
            XBounds[i] = 0;
        else
            XBounds[i] -= offset;
    }

    XBounds[i] = width;
}
// CWheel::_ClipBounds


//+-----------------------------------------------------------------------------
//
// CWheel::WorkProc, CDXBaseNTo1
//
//  OverView:   This function is used to calculate the transformed image based 
//              on the specified bounds and the current effect progress.
//
//  Created by: PhilLu    06/22/98
//
//------------------------------------------------------------------------------
HRESULT 
CWheel::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr = S_OK;

    long    lDoWidth    = WI.DoBnds.Width();
    long    lDoHeight   = WI.DoBnds.Height();
    long    lOutY       = 0;

    long    alXBounds[MAXBOUNDS];   // to hold the X bounds of A/B image sections on a scanline
    double  adblSinAngle[MAXANGLES];
    double  adblCosAngle[MAXANGLES];

    DXPMSAMPLE *    pRowBuff = NULL;
    DXPMSAMPLE *    pOutBuff = NULL;

    DXDITHERDESC dxdd;

    CComPtr<IDXARGBReadPtr>         cpInA;
    CComPtr<IDXARGBReadPtr>         cpInB;
    CComPtr<IDXARGBReadWritePtr>    cpOut;

    hr = InputSurface(0)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, 
                                      (void **)&cpInA, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface(1)->LockSurface(&WI.DoBnds, m_ulLockTimeOut, DXLOCKF_READ,
                                      IID_IDXARGBReadPtr, 
                                      (void **)&cpInB, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = OutputSurface()->LockSurface(&WI.OutputBnds, m_ulLockTimeOut, 
                                      DXLOCKF_READWRITE,
                                      IID_IDXARGBReadWritePtr, 
                                      (void **)&cpOut, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    pRowBuff = DXPMSAMPLE_Alloca(lDoWidth);

    // Allocate output buffer if needed.

    if (OutputSampleFormat() != DXPF_PMARGB32)
    {
        pOutBuff = DXPMSAMPLE_Alloca(lDoWidth);
    }

    //  Set up the dither structure.

    if (DoDither())
    {
        dxdd.x              = WI.OutputBnds.Left();
        dxdd.y              = WI.OutputBnds.Top();
        dxdd.pSamples       = pRowBuff;
        dxdd.cSamples       = lDoWidth;
        dxdd.DestSurfaceFmt = OutputSampleFormat();
    }

    // Prepare a list of cos and sin of angles.

    _ComputeTrigTables(m_Progress, adblSinAngle, adblCosAngle);
  
    for(lOutY = 0; *pbContinue && (lOutY < lDoHeight); lOutY++)
    {
        long lScanLength    = 0;    // Cumulative scan length on the current 
                                    // scanline.
        long i              = 0;

        // Compute the A/B image section bounds.

        if (m_Progress == 0.0F)
        {
            // special case: entire image is from A

            alXBounds[0] = lDoWidth;
        }
        else if (m_Progress == 1.0F)
        {
            // special case: entire image is from B

            alXBounds[0] = 0;
            alXBounds[1] = lDoWidth;
        }
        else
        {
            _ScanlineIntervals(m_sizeInput.cx, m_sizeInput.cy, 
                               adblSinAngle, adblCosAngle,
                               lOutY + WI.DoBnds.Top(), alXBounds);
            _ClipBounds(WI.DoBnds.Left(), lDoWidth, alXBounds);
        }

        // Compose the image.

        while(lScanLength < lDoWidth)
        {
            // Copy a section of A image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInA->MoveToXY(lScanLength, lOutY);
                cpInA->UnpackPremult(pRowBuff + lScanLength, 
                                     alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];

            if (lScanLength >= lDoWidth)
            {
                break;
            }

            // Copy a section of B image to output buffer.

            if (alXBounds[i] - lScanLength > 0)
            {
                cpInB->MoveToXY(lScanLength, lOutY);
                cpInB->UnpackPremult(pRowBuff + lScanLength, 
                                     alXBounds[i] - lScanLength, FALSE);
            }

            lScanLength = alXBounds[i++];
        }

        cpOut->MoveToRow(lOutY);

        if (DoDither())
        {
            DXDitherArray(&dxdd);
            dxdd.y++;
        }

        if (DoOver())
        {
            cpOut->OverArrayAndMove(pOutBuff, pRowBuff, lDoWidth);
        }
        else
        {
            cpOut->PackPremultAndMove(pRowBuff, lDoWidth);
        }
    } 

done:

    if (FAILED(hr))
    {
        return hr;
    }

    return S_OK;
}
// CWheel::WorkProc, CDXBaseNTo1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\proctexe.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

!ENDIF

DXTROOT = $(SUBPROJROOT:\proctexe=)
ROOT    = $(SUBPROJROOT:\src\dxt\proctexe=)

# Trident's common.inc says to treat level 4 warnings as errors.  We wish.

WARNING_LEVEL       = W3

PRIVATE_LIB_PATH    = $(_NTBINDIR)\private\lib

!include $(ROOT)\common.inc


USE_ATL=1
ATL_VER=21

!undef USE_MSVCRT

INCLUDES = \
    $(INCLUDES);                \
    $(DXTROOT)\idl\$(O);        \
    $(SUBPROJROOT)\inc;         \
    $(SUBPROJROOT)\src;         \
    $(ROOT)\src\core\include;   \
    $(SHELL_INC_PATH)   \

#C_DEFINES=$(C_DEFINES) -D_DXTRANSIMPL -D_WINDOWS -D_WINDLL

CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
    atlbase.h       \
    atlcom.h        \
    atlctl.h        \
    atlctl.cpp      \
    atlimpl.cpp     \
    macapi.h        \
    macnam1.h       \
    macname2.h      \
    macocidl.h      \
    macpub.h        \
    new             \
    rpcerr.h        \
    rpcmac.h        \
    statreg.cpp     \
    statreg.h       \
    thunk.h         \
    winwlm.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\inc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <dtbase.cpp>
#include <dxtguid.c>
#include <atlctl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by proctexe.rc
//
#define IDS_PROJNAME                    100
#define IDR_DXTADDITIVE                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\guids.c ===
#include <objbase.h>
#include <initguid.h>

#include <ddraw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\rsrc\makefile.inc ===
#
# makefile.inc
#
#     Makefile dependency rules for special files not
# automagically processed by BUILD.EXE.
#

proctexe.rc :                        \
    $(DXTROOT)\idl\$(O)\proctexe.tlb \
    additive.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\dll\proctexe.cpp ===
// proctexe.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f proctexeps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
//#include <initguid.h>
#include "proctexe.h"

#include "additive.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DispAdditive, CDXTAdditive)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllEnumClassObjects

STDAPI DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    if (i >= (sizeof(ObjectMap)/sizeof(ObjectMap[0])) - 1)
    {
        return S_FALSE;
    }

    *pclsid = *(ObjectMap[i].pclsid);
    return _Module.GetClassObject(*pclsid, IID_IUnknown, (LPVOID*)ppUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\defines.h ===
#define TABSIZE          256
#define TABMASK          (TABSIZE-1)
#define PERM(x)          gPerm[(x)&TABMASK]
#define INDEX(ix,iy,iz)  PERM((ix)+PERM((iy)+PERM(iz)))

#define PROCTEX_LATTICENOISE_LERP               0x01
#define PROCTEX_LATTICENOISE_SMOOTHSTEP         0x02
#define PROCTEX_LATTICENOISE_SPLINE             0x03

#define PROCTEX_LATTICETURBULENCE_LERP          0x11
#define PROCTEX_LATTICETURBULENCE_SMOOTHSTEP    0x12
#define PROCTEX_LATTICETURBULENCE_SPLINE        0x13

#define PROCTEX_MASKMODE_NONE                   0x00
#define PROCTEX_MASKMODE_CHROMAKEY              0x01
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\inc\stdafx.h ===
//+-----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       stdafx.h
//
//  Overview:       Include file for standard system include files, or project 
//                  specific include files that are used frequently, but are 
//                  changed infrequently.
//
//  Change History:
//  2000/03/15  mcalkins    Added include of w95wraps.h to support unicode on 
//                          Win9x.
//
//------------------------------------------------------------------------------

#if !defined(AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED_)
#define AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED

#include <w95wraps.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <dxtrans.h>
#include <dtbase.h>
#include <dxatlpb.h>

// TODO:  We could probably just change the code and remove these macros.

#define New new
#define Delete delete

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70E6C6ED_2F0A_4FC6_BAE2_8DFAFA858CE8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\additive.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.h
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------
#ifndef __ADDITIVE_H_
#define __ADDITIVE_H_

#include "resource.h"

extern DWORD gdwSmoothTable[];
extern DWORD gPerm[];

#include "utility.h"       



class ATL_NO_VTABLE CDXTAdditive : 
    public CProceduralTextureUtility,
    public CDXBaseNTo1,
    public CComCoClass<CDXTAdditive, &CLSID_DispAdditive>,
    public IDispatchImpl<IDispAdditive, &IID_IDispAdditive, &LIBID_PROCTEXELib>,
    public CComPropertySupport<CDXTAdditive>,
    public IObjectSafetyImpl2<CDXTAdditive>,
    public IPersistStorageImpl<CDXTAdditive>,
    public IPersistPropertyBagImpl<CDXTAdditive>,
    public IHTMLDXTransform
{
private:

    CComPtr<IUnknown>       m_spUnkMarshaler;
    CComPtr<IDXSurface>     m_spDXSurfBuffer;

    CDXDBnds                m_bndsInput;

    BSTR                    m_bstrHostUrl;

    //CPROCTEX *m_pObj;
    DWORD * m_valueTab;
    int     m_nSrcWidth;
    int     m_nSrcHeight;
    int     m_nSrcBPP;
    int     m_nDestWidth;
    int     m_nDestHeight;
    int     m_nDestBPP;
    int     m_nNoiseScale;
    int     m_nNoiseOffset;
    int     m_nTimeAnimateX;
    int     m_nTimeAnimateY;
    int     m_nScaleX;
    int     m_nScaleY;
    int     m_nScaleTime;
    int     m_nHarmonics;
    int     m_alphaActive;
    RECT    m_rActiveRect;
    DWORD   m_dwFunctionType;

    DWORD   m_ColorKey;
    DWORD   m_MaskMode;
    void *  m_pMask;
    int     m_nMaskPitch;

    int     m_nMaskHeight;
    int     m_nMaskWidth;
    int     m_nMaskBPP;

    int	    m_nIsMMX;			
    int     m_nPaletteSize;
    void *  m_pPalette;

    DWORD * m_pdwScanArray;
    DWORD   m_dwScanArraySize;

    unsigned char * m_pInitialBuffer;
    int             m_nBufferSize;
    int             m_GenerateSeed;

    void (CDXTAdditive::*m_pGenerateFunction)(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void (CDXTAdditive::*m_pCopyFunction)(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // CProceduralTextureUtility overrides.

    STDMETHOD(MyInitialize)(DWORD dwSeed, DWORD dwFunctionType, 
                            void * pInitInfo);

    // Helpers.

    void valueTabInit(int seed);
    DWORD vlattice(int ix, int iy, int iz)
    {
	    return m_valueTab[INDEX(ix,iy,iz)];
    }
    DWORD smoothstep(DWORD a, DWORD b, DWORD x) {
	    DWORD ix;
	    DWORD rval;

	    x = x >> 8;			// get the high 8 bits for our table lookup
	    x = gdwSmoothTable[x];
	    ix = 0xffff - x;
	    rval = x*b + a*ix;
	    return rval;
    }

    __inline DWORD smoothnoise      (int x, int y, int nTime, int scalex, int scaley, int scalet);
    __inline DWORD smoothturbulence (int x, int y, int nTime);

    // Generate methods.

    void addsmoothnoise8            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothnoise8mmx         (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8             (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8mmx          (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothnoise16           (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb16            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb32            (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mask     (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mmx      (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void addsmoothturb8to32mmxmask  (int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // Copy methods.

    void blit8to8                   (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void blit8to32                  (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);
    void blit8to32mask              (void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch);

    // Old filter base class stuff.

    void setCopyFunction(void);
    void setGenerateFunction(void);

    STDMETHOD(DoEffect)(IDirectDrawSurface* pddsIn, 
                        IDirectDrawSurface* pbsOut, 
                        RECT * prectBounds, RECT * prcInvalid);
    STDMETHOD(SetSource)(int nSrcWidth, int nSrcHeight, int nSrcBPP);
    STDMETHOD(SetTarget)(int nDestWidth, int nDestHeight, int nDestBPP);
    STDMETHOD(SetActiveRect)(LPRECT lprActiveRect);
    STDMETHOD(Generate)(int nTime, void * pDest, int nDestPitch, void * pSrc, 
                        int nSrcPitch); 

public:

    CDXTAdditive();
    virtual ~CDXTAdditive();

    DECLARE_REGISTER_DX_IMAGE_TRANS(IDR_DXTADDITIVE)
    DECLARE_POLY_AGGREGATABLE(CDXTAdditive)
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CDXTAdditive)
	    COM_INTERFACE_ENTRY(IDispAdditive)
	    COM_INTERFACE_ENTRY(IDispatch)
            COM_INTERFACE_ENTRY(IHTMLDXTransform)
	    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_spUnkMarshaler.p)
            COM_INTERFACE_ENTRY_IID(IID_IObjectSafety, IObjectSafetyImpl2<CDXTAdditive>)
            COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
            COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
            COM_INTERFACE_ENTRY_CHAIN(CDXBaseNTo1)
    END_COM_MAP()

    BEGIN_PROPERTY_MAP(CDXTAdditive)
        PROP_ENTRY("harmonics",     DISPID_DISPADDITIVE_HARMONICS, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("noisescale",    DISPID_DISPADDITIVE_NOISESCALE, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("noiseoffset",   DISPID_DISPADDITIVE_NOISEOFFSET, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("timex",         DISPID_DISPADDITIVE_TIMEX, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("timey",         DISPID_DISPADDITIVE_TIMEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scalex",        DISPID_DISPADDITIVE_SCALEX,
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scaley",        DISPID_DISPADDITIVE_SCALEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("scalet",        DISPID_DISPADDITIVE_SCALET, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("alpha",         DISPID_DISPADDITIVE_ALPHA, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("colorkey",      DISPID_DISPADDITIVE_COLORKEY, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("maskmode",      DISPID_DISPADDITIVE_MASKMODE, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("generateseed",  DISPID_DISPADDITIVE_GENERATESEED, 
                   CLSID_DispAdditivePP)
        PROP_ENTRY("bitmapseed",    DISPID_DISPADDITIVE_BITMAPSEED, 
                   CLSID_DispAdditivePP)
        PROP_PAGE(CLSID_DispAdditivePP)
    END_PROPERTY_MAP()

    // CComObjectRootEx overrides.

    HRESULT FinalConstruct();

    // CDXBaseNTo1 overrides.

    HRESULT OnSetup(DWORD dwFlags);
    HRESULT WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue);

    // IHTMLDXTransform methods.

    STDMETHOD(SetHostUrl)(BSTR bstrHostUrl);

    // IDispAdditive properties.

    STDMETHOD(get_Harmonics)(int * pnHarmonics);
    STDMETHOD(put_Harmonics)(int nHarmonics);
    STDMETHOD(get_NoiseScale)(int * pnNoiseScale);
    STDMETHOD(put_NoiseScale)(int nNoiseScale);
    STDMETHOD(get_NoiseOffset)(int * pnNoiseOffset);
    STDMETHOD(put_NoiseOffset)(int nNoiseOffset);
    STDMETHOD(get_TimeX)(int * pnTimeX);
    STDMETHOD(put_TimeX)(int nTimeX);
    STDMETHOD(get_TimeY)(int * pnTimeY);
    STDMETHOD(put_TimeY)(int nTimeY);
    STDMETHOD(get_ScaleX)(int * pnScaleX);
    STDMETHOD(put_ScaleX)(int nScaleX);
    STDMETHOD(get_ScaleY)(int * pnScaleY);
    STDMETHOD(put_ScaleY)(int nScaleY);
    STDMETHOD(get_ScaleT)(int * pnScaleT);
    STDMETHOD(put_ScaleT)(int nScaleT);
    STDMETHOD(get_Alpha)(int * pnAlpha);
    STDMETHOD(put_Alpha)(int nAlpha);
    STDMETHOD(get_ColorKey)(int * pnColorKey);
    STDMETHOD(put_ColorKey)(int nColorKey);
    STDMETHOD(get_MaskMode)(int * pnMaskMode);
    STDMETHOD(put_MaskMode)(int nMaskMode);
    STDMETHOD(get_GenerateSeed)(int * pnSeed);
    STDMETHOD(put_GenerateSeed)(int nSeed);
    STDMETHOD(get_BitmapSeed)(BSTR * pbstrBitmapSeed);
    STDMETHOD(put_BitmapSeed)(BSTR bstrBitmapSeed);
};

#endif //__ADDITIVE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\mmx.h ===
#ifndef _INC_MMX_H
#define _INC_MMX_H

		// IsMMXCpu() returns TRUE if the CPU
		// has Intel's MMX technology.
		// Link to the IHammer utils library
		// 
	__declspec(dllexport) BOOL IsMMXCpu( void );
	

#endif // _INC_MMX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\mmx.cpp ===
#include "stdafx.h"
#include "mmx.h"

// Define or undef the following to allow
// HKCU\Software\Microsoft\Internet Explorer  "TestMMX"=DWORD
// We logical AND this reg value with fIsMMX.

#define TEST_MMX

const  int  s_mmxvaruninit = 0xabcd;
static BOOL s_fIsMMX       = s_mmxvaruninit;

// ----------------------------------------------------------------------------------------

__declspec(dllexport)  BOOL    IsMMXCpu( void )
{

    if( s_mmxvaruninit == s_fIsMMX )
    {
		BOOL   fIsMMX = FALSE;

#if _M_IX86 >= 300  // INTEL TARGET
        __try               // THIS REQUIRES THE CRT
        {        
                // The 0x0fA2 opcode was a late addtion to the 486
                // Some 486 and all 386 chips will not have it.
                // Doubt it's emulated.  Execution on these chips will 
                // raise (and handle) EXCEPTION_ILLEGAL_INSTRUCTION.
		    #define _cpuid _emit 0x0f _asm _emit 0xa2
		    _asm {
			    mov eax,1
			    _cpuid
			    and edx, 00800000h
			    mov fIsMMX, edx
		    } // end asm
        }

        __except( EXCEPTION_EXECUTE_HANDLER )
        {            
            fIsMMX = FALSE;  // No 0x0fA2 opcode?  No MMX either!
        }
#endif // END _M_IX86 INTEL TARGET


#ifdef TEST_MMX
		HKEY  hkeyIE;
		if( ERROR_SUCCESS == RegOpenKeyEx( HKEY_CURRENT_USER,
				   TEXT("Software\\Microsoft\\Internet Explorer"),
				   0u, KEY_READ, &hkeyIE ) )
		{
			DWORD  dwVal = TRUE;
			DWORD  dwType = REG_DWORD;
			DWORD  dwSize = sizeof(dwVal);

			if ( ERROR_SUCCESS == 
				 RegQueryValueEx( hkeyIE, 
								  TEXT("TestMMX"), 
								  NULL, 
								  &dwType, 
								  reinterpret_cast<BYTE*>(&dwVal),
								  &dwSize ) )
			{
				fIsMMX = fIsMMX && dwVal;
			}
		}
#endif // TEST_MMX

        s_fIsMMX = fIsMMX;
    }

    return s_fIsMMX;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\additive.cpp ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.cpp
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------
#include "stdafx.h"
#include "proctexe.h"
#include "defines.h"
#include "additive.h"
#include "mmx.h"
#include "urlarchv.h"
#include <mshtml.h>
#include <shlwapi.h>

#ifdef _DEBUG
void * showme(IUnknown * pUnk);
#endif // _DEBUG




//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::CDXTAdditive
//
//------------------------------------------------------------------------------
CDXTAdditive::CDXTAdditive() :
    m_bstrHostUrl(NULL),
    m_nSrcWidth(0),
    m_nSrcHeight(0),
    m_nSrcBPP(0),
    m_nDestWidth(0),
    m_nDestHeight(0),
    m_nDestBPP(0),
    m_nNoiseScale(32),
    m_nNoiseOffset(0),
    m_nTimeAnimateX(0),
    m_nTimeAnimateY(0),
    m_nScaleX(0),
    m_nScaleY(0),
    m_nScaleTime(0),
    m_nHarmonics(1),
    m_dwFunctionType(0),
    m_nPaletteSize(0),
    m_pPalette(NULL),
    m_alphaActive(0),
    m_pInitialBuffer(NULL),
    m_nBufferSize(0),
    m_dwScanArraySize(0),
    m_pdwScanArray(0),
    m_pGenerateFunction(0),
    m_pCopyFunction(0),
    m_ColorKey(0),
    m_MaskMode(0),          // 0 no mask, other TBD
    m_pMask(0),
    m_nMaskPitch(0),
    m_GenerateSeed(0),      // 0 no seed, 1 flame, 2 water, 3 clouds, other TDB
    m_nMaskHeight(0),
    m_nMaskWidth(0),
    m_nMaskBPP(0),
    m_valueTab(NULL)
{
    memset(&m_rActiveRect, 0, sizeof(RECT));

    if (m_nIsMMX)
    {
        m_pGenerateFunction = addsmoothturb8to32mmx;
    }
    else
    {
        m_pGenerateFunction = addsmoothturb32;
    }

    // Base class members.

    m_ulNumInRequired   = 1;
    m_ulMaxInputs       = 1;

    // Don't bother supporting multi-threaded execution.

    m_ulMaxImageBands   = 1;

#ifdef _DEBUG
    showme(NULL);
#endif // _DEBUG
} 
//  Method:  CDXTAdditive::CDXTAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::~CDXTAdditive
//
//------------------------------------------------------------------------------
CDXTAdditive::~CDXTAdditive() 
{
    delete [] m_valueTab;
    delete [] m_pPalette;
    delete [] m_pdwScanArray;
    delete [] m_pInitialBuffer;
    
    SysFreeString(m_bstrHostUrl);
}
//  Method:  CDXTAdditive::~CDXTAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::FinalConstruct, CComObjectRootEx
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::FinalConstruct()
{
    HRESULT hr = S_OK;

    hr = CoCreateFreeThreadedMarshaler(GetControllingUnknown(), 
                                       &m_spUnkMarshaler.p);

    if (FAILED(hr))
    {
        goto done;
    }

    m_valueTab = new DWORD[TABSIZE];

    if (NULL == m_valueTab)
    {
        hr = E_OUTOFMEMORY;
    }

    MyInitialize(0, PROCTEX_LATTICETURBULENCE_SMOOTHSTEP, NULL);

done:

    return hr;
}
//  Method:  CDXTAdditive::FinalConstruct, CComObjectRootEx


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::SetHostUrl, IHTMLDXTransform
//
//------------------------------------------------------------------------------
STDMETHODIMP
CDXTAdditive::SetHostUrl(BSTR bstrHostUrl)
{
    HRESULT hr = S_OK;

    SysFreeString(m_bstrHostUrl);

    m_bstrHostUrl = NULL;

    if (bstrHostUrl)
    {
        m_bstrHostUrl = SysAllocString(bstrHostUrl);

        if (NULL == m_bstrHostUrl)
        {
            hr = E_OUTOFMEMORY;

            goto done;
        }
    }

done:

    return hr;
}
//  Method:  CDXTAdditive::SetHostUrl, IHTMLDXTransform

        
void
CDXTAdditive::valueTabInit(int seed)
{
    DWORD * table = m_valueTab;
    int     i;

    srand(seed);

    if (m_nIsMMX)
    {
	for(i = 0; i < TABSIZE; i++) 
        {
            *table++ = ((rand()*rand()) & 0xffff) >> 1;
	}
    }
    else 
    {
	for(i = 0; i < TABSIZE; i++) 
        {
            *table++ = (rand()*rand()) & 0xffff;
	}
    }
}


STDMETHODIMP
CDXTAdditive::MyInitialize(
	DWORD dwSeed, 
	DWORD dwFunctionType, 
	void *pInitInfo) 
{
    HRESULT hr = S_OK;

    m_nIsMMX = IsMMXCpu();

    valueTabInit(dwSeed);

    switch (dwFunctionType) 
    {
        case PROCTEX_LATTICENOISE_SMOOTHSTEP:
        case PROCTEX_LATTICENOISE_LERP:
            m_nHarmonics = 1;
        case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
        case PROCTEX_LATTICETURBULENCE_LERP:
            m_dwFunctionType = dwFunctionType;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            break;
    }

    return hr;
}


/*
STDMETHODIMP
CDXTAdditive::GetSource(
	int *pnSrcWidth, 
	int *pnSrcHeight, 
	int *pnSrcBPP) 
{
    if (pnSrcWidth != NULL) *pnSrcWidth   = m_nSrcWidth;
    if (pnSrcHeight != NULL) *pnSrcHeight = m_nSrcHeight;
    if (pnSrcBPP != NULL) *pnSrcBPP       = m_nSrcBPP;

    return S_OK;
}
*/


/*
STDMETHODIMP
CDXTAdditive::GetTarget(
	int *pnDestWidth, 
	int *pnDestHeight, 
	int *pnDestBPP) 
{
    if (pnDestWidth != NULL) *pnDestWidth   = m_nDestWidth;
    if (pnDestHeight != NULL) *pnDestHeight = m_nDestHeight;
    if (pnDestBPP != NULL) *pnDestBPP       = m_nDestBPP;

    return S_OK;
}
*/

//TODO:: Use get_TimeX and get_TimeY instead.

/*
STDMETHODIMP
CDXTAdditive::GetScaling(
	int *pnScaleX, 
	int *pnScaleY, 
	int *pnScaleTime) 
{
    if (pnScaleX != NULL) *pnScaleX = m_nScaleX;
    if (pnScaleY != NULL) *pnScaleY = m_nScaleY;
    if (pnScaleTime != NULL) *pnScaleTime = m_nScaleTime;

    return S_OK;
}
*/


/*
STDMETHODIMP
CDXTAdditive::GetActiveRect(LPRECT lprActiveRect) 
{
    if (lprActiveRect != NULL) 
    {
        memcpy(lprActiveRect, &m_rActiveRect, sizeof(RECT));

        return S_OK;
    }

    return E_INVALIDARG;
}
*/



STDMETHODIMP
CDXTAdditive::SetSource(
	int nSrcWidth, 
	int nSrcHeight, 
	int nSrcBPP) 
{
    if ((nSrcBPP != 8) && (nSrcBPP != 16))
    {
        return E_INVALIDARG;
    }

    m_nSrcWidth  = nSrcWidth;
    m_nSrcHeight = nSrcHeight;
    m_nSrcBPP    = nSrcBPP;

    return S_OK;
}



/*
STDMETHODIMP
CDXTAdditive::SetMaskBitmap(void * lpBits, int nMaskWidth, int nMaskHeight, 
                            int nMaskBPP) 
{
    int memsize = 0;

    if (nMaskWidth < 0) return E_INVALIDARG;
    if (nMaskHeight < 0) return E_INVALIDARG;

    if ((nMaskBPP != 1) && (nMaskBPP != 8) && (nMaskBPP != 16)
        && (nMaskBPP != 24) && (nMaskBPP != 32))
    {
        return E_INVALIDARG;
    }

    if (NULL == lpBits) return E_INVALIDARG;

    m_nMaskWidth  = nMaskWidth;
    m_nMaskPitch  = nMaskWidth * 4;
    m_nMaskHeight = nMaskHeight;
    m_nMaskBPP    = nMaskBPP;

    memsize = (m_nMaskWidth * m_nMaskHeight * m_nMaskBPP) / 8;

    m_pMask = (void *) new unsigned char[memsize];

    memcpy(m_pMask, lpBits, memsize);

    return S_OK;
}
*/



STDMETHODIMP
CDXTAdditive::SetTarget(
	int nDestWidth, 
	int nDestHeight, 
	int nDestBPP) 
{
    HRESULT hr              = S_OK;
    DWORD   dwFunctionField = 0;
    RECT    rect;

    if (   (nDestBPP != 8) 
        && (nDestBPP != 16) 
        && (nDestBPP != 24) 
        && (nDestBPP != 32)) 
    {
        hr = E_INVALIDARG;

        goto done;
    }

    m_nDestWidth    = nDestWidth;
    m_nDestHeight   = nDestHeight;
    m_nDestBPP      = nDestBPP;

    rect.top        = 0;
    rect.left       = 0;
    rect.right      = nDestWidth;
    rect.bottom     = nDestHeight;

    SetActiveRect(&rect);

    setGenerateFunction();
    setCopyFunction();

    if ((DWORD) m_nDestWidth > m_dwScanArraySize) 
    {
        delete [] m_pdwScanArray;

        m_pdwScanArray = NULL;

        switch (m_dwFunctionType) 
        {
            case PROCTEX_LATTICENOISE_SMOOTHSTEP:
            case PROCTEX_LATTICENOISE_LERP:
            case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
            case PROCTEX_LATTICETURBULENCE_LERP:

                m_pdwScanArray      = new DWORD[m_nDestWidth];

                if (NULL == m_pdwScanArray)
                {
                    hr = E_OUTOFMEMORY;

                    goto done;
                }

                m_dwScanArraySize   = m_nDestWidth;

                break;
        }
    }

done:

    return hr;
}



/*
STDMETHODIMP
CDXTAdditive::SetScaling(int nScaleX, int nScaleY, int nScaleTime) 
{
    if ((nScaleX < 0) || (nScaleY < 0) || (nScaleTime < 0)) 
    {
        return E_INVALIDARG;
    }

    m_nScaleX = nScaleX;
    m_nScaleY = nScaleY;
    m_nScaleTime = nScaleTime;

    return S_OK;
}
*/



STDMETHODIMP
CDXTAdditive::SetActiveRect(LPRECT lprActiveRect) 
{
    if (lprActiveRect != NULL) 
    {
        if (lprActiveRect->left < 0)                    return E_INVALIDARG;
        if (lprActiveRect->right > m_nDestWidth)        return E_INVALIDARG;
        if (lprActiveRect->top < 0)                     return E_INVALIDARG;
        if (lprActiveRect->bottom > m_nDestHeight)      return E_INVALIDARG;
        if (lprActiveRect->left > lprActiveRect->right) return E_INVALIDARG;
        if (lprActiveRect->top > lprActiveRect->bottom) return E_INVALIDARG;

        memcpy(&m_rActiveRect, lprActiveRect, sizeof(RECT));

        return S_OK;
    } 

    return E_INVALIDARG;
}



/*
STDMETHODIMP
CDXTAdditive::SetPalette(int nSize, WORD *pPalette) 
{
    if (m_pPalette) delete [] m_pPalette;

    m_nPaletteSize  = nSize;
    m_pPalette      = (void *)(new unsigned char[nSize]);

    if (m_pPalette == NULL) 
    {
        m_nPaletteSize = 0;

        return E_OUTOFMEMORY;
    }

    memcpy(m_pPalette, pPalette, nSize * sizeof(unsigned char));

    return S_OK;
}
*/


//+-----------------------------------------------------------------------------
//
//  Method: CDXTAdditive::OnSetup, CDXBaseNTo1
//
//  Overview:   All the mmx functions in this class were written to assume the
//              output surface is the same size as the input surface.  Rather
//              than muck with them, I've decided to just have an extra buffer
//              that is the same size as the input and then blit to the output.
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::OnSetup(DWORD dwFlags)
{
    HRESULT     hr              = S_OK;
    DXSAMPLE    sampleColorKey  = 0;

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<IDXSurfaceFactory>  spDXSurfaceFactory;

    m_spDXSurfBuffer.Release();

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(SID_SDXSurfaceFactory,
                                         __uuidof(IDXSurfaceFactory),
                                         (void **)&spDXSurfaceFactory);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->GetBounds(&m_bndsInput);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spDXSurfaceFactory->CreateSurface(NULL, NULL, &DDPF_RGB32,
                                           &m_bndsInput, 0, NULL,
                                           __uuidof(IDXSurface),
                                           (void **)&m_spDXSurfBuffer);
    
    if (FAILED(hr))
    {
        goto done;
    }

    hr = InputSurface()->GetColorKey(&sampleColorKey);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = m_spDXSurfBuffer->SetColorKey(sampleColorKey);

done:

    return hr;
}
//  Method: CDXTAdditive::OnSetup, CDXBaseNTo1


//+-----------------------------------------------------------------------------
//
//  Method: CDXTAdditive::WorkProc, CDXBaseNTo1
//
//------------------------------------------------------------------------------
HRESULT 
CDXTAdditive::WorkProc(const CDXTWorkInfoNTo1 & WI, BOOL * pbContinue)
{
    HRESULT hr      = S_OK;
    DWORD   dwFlags = 0;
    RECT    rcBounds;

    CComPtr<IDirectDrawSurface> spDDSurface;

    hr = m_spDXSurfBuffer->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                                (void **)&spDDSurface);

    if (FAILED(hr))
    {
        goto done;
    }

    // TODO:    In theory, we should be able to process just part of the image,
    //          but the mmx routines don't like that.  I don't the the old style
    //          filters ever dealt with that situation.
    //
    // WI.DoBnds.GetXYRect(rcBounds);

    m_bndsInput.GetXYRect(rcBounds);

    if (DoOver())
    {
        dwFlags |= DXBOF_DO_OVER;
    }

    if (DoDither())
    {
        dwFlags |= DXBOF_DITHER;
    }

    hr = DXBitBlt(m_spDXSurfBuffer, WI.DoBnds,
                  InputSurface(), WI.DoBnds,
                  0, INFINITE);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = DoEffect(spDDSurface, NULL, &rcBounds, &rcBounds);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = DXBitBlt(OutputSurface(), WI.OutputBnds,
                  m_spDXSurfBuffer, WI.DoBnds,
                  dwFlags, INFINITE);

done:

    return hr;
}
//  Method: CDXTAdditive::WorkProc, CDXBaseNTo1


STDMETHODIMP 
CDXTAdditive::DoEffect(IDirectDrawSurface * pddsIn, 
                        IDirectDrawSurface * /* pbsOut */, 
                        RECT *prectBounds, 
                        RECT* prcInvalid)
{
    HRESULT         hr;
    DDSURFACEDESC   ddsDesc;
    int             nMemSize;
    DWORD           i;
    static int      count = 0;	

    long            nWidth  = prectBounds->right - prectBounds->left;
    long            nHeight = prectBounds->bottom - prectBounds->top;

    count++;

    ZeroMemory(&ddsDesc, sizeof(ddsDesc));

    ddsDesc.dwSize = sizeof(ddsDesc);

    hr = pddsIn->Lock(prectBounds, &ddsDesc, 0, NULL);

    if (FAILED(hr))
    {
        goto done;
    }

    if (m_GenerateSeed) 
    {
        // SetSource(ddsDesc.dwWidth, ddsDesc.dwHeight, 8);
        SetSource(nWidth, nHeight, 8);
        //nMemSize = ddsDesc.dwWidth * ddsDesc.dwHeight * sizeof(DWORD);
        nMemSize = nWidth * nHeight * sizeof(DWORD);

        // Delete the buffer if it isn't large enough.

        if (m_pInitialBuffer && (nMemSize > m_nBufferSize))
        {
            delete [] m_pInitialBuffer;
            m_pInitialBuffer    = NULL;
            m_nBufferSize       = nMemSize;
        }

        if (!m_pInitialBuffer)
        {
            m_nBufferSize       = nMemSize;
            m_pInitialBuffer    = new unsigned char[m_nBufferSize];

            if (NULL == m_pInitialBuffer) 
            {
                m_nBufferSize   = 0;
                hr              = E_OUTOFMEMORY;

                goto done;
            }

            // This is a new buffer, initialize it.
            switch (m_GenerateSeed) 
            {
            case 1: // flame

                for (i = 0; i < ddsDesc.dwHeight ; i++) 
                {
                    memset(m_pInitialBuffer + i * ddsDesc.dwWidth, 
                           (255 * i)/ddsDesc.dwHeight, ddsDesc.dwWidth);
                }
                break;

            case 2: // water

                memset(m_pInitialBuffer, 0x80, nMemSize);
                break;

            case 3: // hey, you, get outta my cloud (<-- Intel comment)

                memset(m_pInitialBuffer, 0x40, nMemSize);
                break;
            }
        } // if (!m_pInitialBuffer)
    } // if (m_GenerateSeed)

    // If we aren't using generated buffer, use the output surface. ?

    if (!m_pInitialBuffer)
    {
        SetSource(ddsDesc.dwWidth, ddsDesc.dwHeight, 8);
    }

    // Old
    // SetTarget(ddsDesc.dwWidth, ddsDesc.dwHeight, 32);
    // New (takes into account that only invalid rect will be drawn)
    // TODO:  Will this always be 32BPP?

    hr = SetTarget(nWidth, nHeight, 32);

    if (FAILED(hr))
    {
        goto done;
    }
    
    SetActiveRect(prectBounds);

    memcpy(&m_rActiveRect, prectBounds, sizeof(RECT));

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) 
    {
        // The only way this should be non-NULL is if SetMaskBitmap is called.
        // And it isn't ever called from anywhere.  Look into removing.

        if (m_pMask) 
        {
            delete [] m_pMask;
        }

        m_pMask         = ddsDesc.lpSurface;
        m_nMaskPitch    = ddsDesc.lPitch;
    }

    Generate(count, ddsDesc.lpSurface, ddsDesc.lPitch, m_pInitialBuffer, 
             m_nSrcWidth);

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) 
    {
        m_pMask         = 0;
        m_nMaskPitch    = 0;
    }

done:

    pddsIn->Unlock(ddsDesc.lpSurface);

    return hr;
}


STDMETHODIMP
CDXTAdditive::Generate(int nTime, void * pDest, int nDestPitch, void * pSrc, 
                       int nSrcPitch) 
{
    if ((pDest == NULL) || ((pSrc == NULL) && (m_nDestBPP == 8))) return E_INVALIDARG;
    if (nDestPitch < m_nDestWidth) return E_INVALIDARG;
    if (nSrcPitch < m_nSrcWidth) return E_INVALIDARG;

    if (m_nNoiseScale != 32) 
    {
        if (NULL == m_pGenerateFunction) 
        {
            return E_FAIL;
        }

        (this->*m_pGenerateFunction)(nTime, pDest, nDestPitch, pSrc, nSrcPitch, 
                                     m_pMask, m_nMaskPitch);
    } 
    else 
    {
        if (NULL == m_pCopyFunction) 
        {
            return E_FAIL;
        }

        (this->*m_pCopyFunction)(pDest, nDestPitch, pSrc, nSrcPitch, m_pMask, 
                                 m_nMaskPitch);
    }

    return S_OK;
}


/*
STDMETHODIMP
CDXTAdditive::GenerateXY(int x, int y, int nTime, void * pSrc, int nSrcPitch,
                         DWORD * returnvalue)
{
    int     value   = 0;
    DWORD   noise   = 0;
    int	    signednoise;

    if (pSrc == NULL) return E_INVALIDARG;
    if (nSrcPitch < m_nSrcWidth) return E_INVALIDARG;

    if (m_nSrcBPP == 8) 
    {
        unsigned char * pPtr;

        pPtr    = (unsigned char *)pSrc;
        value   = pPtr[x+y*nSrcPitch];
    } 
    else if (m_nSrcBPP == 16) 
    {
        WORD * pPtr;

        pPtr    = (WORD *) pSrc;
        value   = pPtr[x + y*nSrcPitch];
    }

    switch(m_dwFunctionType) 
    {
    case PROCTEX_LATTICENOISE_LERP:
    case PROCTEX_LATTICENOISE_SMOOTHSTEP:

        if (m_nNoiseScale != 32) 
        {
            noise       = smoothnoise(x+nTime * m_nTimeAnimateX,
                                      y+nTime * m_nTimeAnimateY,
                                      nTime,
                                      m_nScaleX,
                                      m_nScaleY,
                                      m_nScaleTime);

            noise       = noise >> m_nNoiseScale;
            signednoise = noise;
            signednoise = signednoise - (1 << (31 - m_nNoiseScale));
            signednoise += m_nNoiseOffset;
            value       += signednoise;
        }

        break;

    case PROCTEX_LATTICETURBULENCE_LERP:
    case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:

        if (m_nNoiseScale != 32) 
        {
            signednoise = smoothturbulence(x+nTime * m_nTimeAnimateX,
                                           y+nTime * m_nTimeAnimateY,
                                           nTime);

            signednoise = signednoise >> m_nNoiseScale;
            signednoise += m_nNoiseOffset;
            value       += signednoise;
        }

        break;

    default:

        return E_FAIL;

        break;
    }


    if (m_nSrcBPP == 8) 
    {
        // clamp
        if (value < 0) value = 0;
        if (value > 255) value = 255;
    } 
    else if (m_nSrcBPP == 16) 
    {
        value = ((WORD *)m_pPalette)[value];
    }

    *returnvalue = value;

    return S_OK;
}
*/



void 
CDXTAdditive::setGenerateFunction(void) 
{
    #define FF_MMX      0x00000001
    #define FF_LNL      0x00000002
    #define FF_LTL      0x00000004
    #define FF_LNS      0x00000008
    #define FF_LTS      0x00000010
    #define FF_D8       0x00000020
    #define FF_D16      0x00000040
    #define FF_D24      0x00000080
    #define FF_D32      0x00000100
    #define FF_MASK_C   0x00000200

    DWORD dwFunctionField = 0;

    if (m_nIsMMX)
    {
        dwFunctionField |= FF_MMX;
    }

    if (PROCTEX_LATTICENOISE_LERP == m_dwFunctionType)              dwFunctionField |= FF_LNL;
    if (PROCTEX_LATTICETURBULENCE_LERP == m_dwFunctionType)         dwFunctionField |= FF_LTL;

    // This is the hardcoded value in the constructor.
    if (PROCTEX_LATTICENOISE_SMOOTHSTEP == m_dwFunctionType)        dwFunctionField |= FF_LNS;

    if (PROCTEX_LATTICETURBULENCE_SMOOTHSTEP == m_dwFunctionType)   dwFunctionField |= FF_LTS;
    if (8  == m_nDestBPP) dwFunctionField |= FF_D8;
    if (16 == m_nDestBPP) dwFunctionField |= FF_D16;
    if (24 == m_nDestBPP) dwFunctionField |= FF_D24;

    // This always be the case for a transform.  (and I think for this filter as well)

    if (32 == m_nDestBPP) dwFunctionField |= FF_D32;

    if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode) dwFunctionField |= FF_MASK_C;

    switch (dwFunctionField) 
    {
    case (FF_LNL | FF_D8):
    case (FF_LNS | FF_D8):
        m_pGenerateFunction = addsmoothnoise8;
        break;
    case (FF_LTL | FF_D8):
    case (FF_LTS | FF_D8):
        m_pGenerateFunction = addsmoothturb8;
        break;
    case (FF_LNL | FF_D16):
    case (FF_LNS | FF_D16):
        m_pGenerateFunction = addsmoothnoise16;
        break;
    case (FF_LTL | FF_D16):
    case (FF_LTS | FF_D16):
        m_pGenerateFunction = addsmoothturb16;
        break;
    case (FF_LNL | FF_D24):
    case (FF_LNS | FF_D24):
	    break;
    case (FF_LTL | FF_D24):
    case (FF_LTS | FF_D24):
	    break;
    case (FF_LNL | FF_D32):
    case (FF_LNS | FF_D32):
        m_pGenerateFunction = addsmoothturb32;
        break;
    case (FF_LTL | FF_D32):
    case (FF_LTS | FF_D32):
        m_pGenerateFunction = addsmoothturb32; // <-- Possible w/ transform.
        break;

    case (FF_LNL | FF_D8 | FF_MMX):
    case (FF_LNS | FF_D8 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8mmx;
        break;
    case (FF_LTL | FF_D8 | FF_MMX):
    case (FF_LTS | FF_D8 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8mmx;
        break;
    case (FF_LNL | FF_D16 | FF_MMX):
    case (FF_LNS | FF_D16 | FF_MMX):
        m_pGenerateFunction = addsmoothnoise16;
        break;
    case (FF_LTL | FF_D16 | FF_MMX):
    case (FF_LTS | FF_D16 | FF_MMX):
        m_pGenerateFunction = addsmoothturb16;
        break;
    case (FF_LNL | FF_D24 | FF_MMX):
    case (FF_LNS | FF_D24 | FF_MMX):
        break;
    case (FF_LTL | FF_D24 | FF_MMX):
    case (FF_LTS | FF_D24 | FF_MMX):
        break;
    case (FF_LNL | FF_D32 | FF_MMX):
    case (FF_LNS | FF_D32 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8to32mmx; // <-- Possible w/ transform.
        break;
    case (FF_LTL | FF_D32 | FF_MMX):
    case (FF_LTS | FF_D32 | FF_MMX):
        m_pGenerateFunction = addsmoothturb8to32mmx;
        break;
    case (FF_LTL | FF_D32 | FF_MASK_C):
    case (FF_LTS | FF_D32 | FF_MASK_C):
        m_pGenerateFunction = addsmoothturb8to32mask;
        break;
    case (FF_LTL | FF_D32 | FF_MMX | FF_MASK_C):
    case (FF_LTS | FF_D32 | FF_MMX | FF_MASK_C):
        m_pGenerateFunction = addsmoothturb8to32mmxmask;
        break;
    default:
        break;
    }
}



// This copy function takes into account the mask, we'll have to figure that out.


void 
CDXTAdditive::setCopyFunction(void) 
{
	#define FF_MMX		0x00000001
	#define FF_D8		0x00000020
	#define FF_D16		0x00000040
	#define FF_D24		0x00000080
	#define FF_D32		0x00000100
	#define FF_MASK_C	0x00000200

	DWORD dwFunctionField = 0;

//	if (m_nIsMMX)													dwFunctionField |= FF_MMX;
	if (8  == m_nDestBPP)											dwFunctionField |= FF_D8;
	if (16 == m_nDestBPP)											dwFunctionField |= FF_D16;
	if (24 == m_nDestBPP)											dwFunctionField |= FF_D24;
	if (32 == m_nDestBPP)											dwFunctionField |= FF_D32;
	if (PROCTEX_MASKMODE_CHROMAKEY == m_MaskMode)					dwFunctionField |= FF_MASK_C;

	switch (dwFunctionField) {
		case (FF_D8):
			m_pCopyFunction = blit8to8;
			break;
		case (FF_D16):
			m_pCopyFunction = 0;
			break;
		case (FF_D24):
			m_pCopyFunction = 0;
			break;
		case (FF_D32):
			m_pCopyFunction = blit8to32;
			break;

		case (FF_D32 | FF_MASK_C):
			m_pCopyFunction = blit8to32mask;
			break;
		default:
			break;
	}
}


void CDXTAdditive::blit8to8(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int y;
	unsigned char *pDestLine, *pSrcLine;

	if (pSrc) 
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((unsigned char *) pDest) + y*nDestPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			memcpy(pDest, pSrc, nDestPitch);
		}
}

void CDXTAdditive::blit8to32(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	DWORD alphamask;
	unsigned char *pSrcLine;
	DWORD *pDestLine;

	nDestPitch /=4;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	if (pSrc) {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			for (x=0; x<nDestPitch; x++) {
				pDestLine[x] = ((DWORD *)m_pPalette)[pSrcLine[x]] | alphamask;
			}
		}
	} else {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			for (x=0; x<nDestPitch; x++) {
				pDestLine[x] = 0x00808080 | alphamask;
			}
		}
	}
}

void CDXTAdditive::blit8to32mask(void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	DWORD alphamask;
	unsigned char *pSrcLine;
	DWORD *pDestLine, *pMaskLine;

	nDestPitch /=4;
	nMaskPitch /=4;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	if (pSrc) {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pMaskLine = ((DWORD *) pMask) + y*nMaskPitch;
			pSrcLine = ((unsigned char *) pSrc) + y*nSrcPitch;
			for (x=0; x<nDestPitch; x++) {
				if ((pMaskLine[x] & 0x00ffffff) == (m_ColorKey & 0x00ffffff))
					pDestLine[x] = ((DWORD *)m_pPalette)[pSrcLine[x]] | alphamask;
				else
					pDestLine[x] = pMaskLine[x] | 0xff000000;
			}
		}
	} else {
		for (y=0; y<m_nDestHeight; y++) {
			pDestLine = ((DWORD *) pDest) + y*nDestPitch;
			pMaskLine = ((DWORD *) pMask) + y*nMaskPitch;
			for (x=0; x<nDestPitch; x++) {
				if ((pMaskLine[x] & 0x00ffffff) == (m_ColorKey & 0x00ffffff))
					pDestLine[x] = 0x00808080 | alphamask;
				else
					pDestLine[x] = pMaskLine[x] | 0xff000000;
			}
		}
	}
}

__inline DWORD 
CDXTAdditive::smoothnoise(int x, int y, int t, int xscale, int yscale, 
                          int tscale)
{
    DWORD fx, fy, ft;
    DWORD ix, iy, it;
    DWORD v[8];

    x = (x & 0x0ffff) << 16;
    y = (y & 0x0ffff) << 16;
    t = (t & 0x0ffff) << 16;
    
    x = x >> xscale;	
    y = y >> yscale;	
    t = t >> tscale;	

    fx = x & 0x0ffff;
    fy = y & 0x0ffff;
    ft = t & 0x0ffff;

    ix = (x >> 16);
    iy = (y >> 16);
    it = (t >> 16);

    v[0] = vlattice(ix + 0, iy + 0, it + 0);
    v[1] = vlattice(ix + 1, iy + 0, it + 0);
    v[2] = vlattice(ix + 1, iy + 1, it + 0);
    v[3] = vlattice(ix + 0, iy + 1, it + 0);
    v[4] = vlattice(ix + 0, iy + 0, it + 1);
    v[5] = vlattice(ix + 1, iy + 0, it + 1);
    v[6] = vlattice(ix + 1, iy + 1, it + 1);
    v[7] = vlattice(ix + 0, iy + 1, it + 1);

    v[0] = smoothstep(v[0], v[4], ft) >> 16;
    v[1] = smoothstep(v[1], v[5], ft) >> 16;
    v[2] = smoothstep(v[2], v[6], ft) >> 16;
    v[3] = smoothstep(v[3], v[7], ft) >> 16;

    v[0] = smoothstep(v[0], v[3], fy) >> 16;
    v[1] = smoothstep(v[1], v[2], fy) >> 16;

    return (smoothstep(v[0], v[1], fx));
}


__inline DWORD 
CDXTAdditive::smoothturbulence(int x, int y, int t) 
{
    int     rval = 0;
    int     i;
    DWORD   noiseval;
    int     signednoiseval;
    int     xscale, yscale, tscale;

    xscale = m_nScaleX;
    yscale = m_nScaleY;
    tscale = m_nScaleTime;

    xscale += m_nHarmonics;
    yscale += m_nHarmonics;
    tscale += m_nHarmonics;

    for (i = 0 ; i < m_nHarmonics ; i++) 
    {
        noiseval = smoothnoise(x, y, t, xscale, yscale, tscale);
        xscale--; 
        yscale--; 
        tscale--;
        noiseval = noiseval >> 1;
        signednoiseval = noiseval;
        signednoiseval -= 0x3fffffff;
        signednoiseval = signednoiseval/(i+1);
        rval += signednoiseval;
    }

    return rval;
}


void 
CDXTAdditive::addsmoothnoise8(int nTime, void * pDest, int nDestPitch, 
                              void * pSrc, int nSrcPitch, void * pMask,
                              int nMaskPitch) 
{
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize;
	DWORD allone = 0xff;
	DWORD x_base, x_inc;
	DWORD lastix;
	DWORD vpp0;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line
	x_base = ((left + timexanimatex) & 0xffff) << 16;
	x_base = x_base >> m_nScaleX;

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it
	t = ((nTime) << 16) >> m_nScaleTime;
	it = t >> 16;
	ft = gdwSmoothTable[(t & 0xffff) >> 8];
	ift = 0xffff - ft;

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		iy = y >> 16;
		fy = gdwSmoothTable[(y & 0xffff) >> 8];
		ify = 0xffff - fy;

		ytPerm00 = PERM(iy+0 + PERM(it+0));
		ytPerm01 = PERM(iy+0 + PERM(it+1));
		ytPerm10 = PERM(iy+1 + PERM(it+0));
		ytPerm11 = PERM(iy+1 + PERM(it+1));

		x = x_base;
		x_loop = left;

		__asm {
			; first, calc v[0], v[4], v[3] and v[7]
			lea		edx, gPerm
			  mov	eax, x
			mov		edi, edx
			  mov	ebx, ytPerm01	; for v[4]
			shr		eax, 16
			  mov	ecx, ytPerm10	; for v[3]
			mov		esi, eax		; esi = ix
			  mov	eax, ytPerm00	; for v[0]
			add		eax, esi		; eax = ix + ytPerm00, for v[0]
			  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
			and		eax, TABMASK	; still generating v[0]
			  and	ebx, TABMASK	; still generating v[4]
			mov		edx, ytPerm11	; for v[7]
			  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
			add		edx, esi		; edx = ix + ytPerm11, for v[7]
			  mov	esi, pValueTab	; point esi to valuetable
			mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
			  and	ecx, TABMASK	; still generating v[3]
			mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
			  and	edx, TABMASK	; still generating v[7]
			mov		eax, [esi + 4*eax] ; eax = v[0]
			  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
			mov		ebx, [esi + 4*ebx] ; ebx = v[4]
			  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
			mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
			  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
			mov		edx, [esi + 4*edx] ; edx = v[7]
			  mov	esi, ift		; prepare to multiply with esi
			imul	ebx, edi		; ebx = v[4] * ft
			  ; wait 10 cycles
			imul	eax, esi		; eax = v[0] * ift
			  ; wait another 10 cycles
			imul	edx, edi		; edx = v[7] * ft
			  ; wait yet another 10 cycles
			imul	ecx, esi		; ecx = v[3] * ift
			  ; wait even yet another 10 cycles
			add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
			  mov	ebx, fy			; ebx = fy....
			shr		eax, 16			; eax = vp[0]
			  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
			shr		ecx, 16			; ecx = vp[3]
			  mov	edx, ify		; edx = ify
			imul	eax, edx		; eax = vp[0] * ify
			  ; wait more cycles
			imul	ecx, ebx		; ecx = vp[3] * fy
			  ; another 10 cycle hit
			add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
			  ;
			shr		eax, 16			; eax = vpp[0]
			  ;
			mov		vpp0, eax		; save off vpp[0] for later
		x_loop_calc:
			; assumptions:
			lea		edx, gPerm
			  mov	eax, x
			mov		edi, edx
			  mov	ebx, ytPerm01	; for v[5]
			shr		eax, 16
			  mov	ecx, ytPerm10	; for v[2]
			mov		lastix, eax		; save off this ix value to look at next time
			  inc	eax
			mov		esi, eax		; esi = ix + 1
			  mov	eax, ytPerm00	; for v[1]
			add		eax, esi		; eax = ix + ytPerm00, for v[1]
			  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
			and		eax, TABMASK	; still generating v[1]
			  and	ebx, TABMASK	; still generating v[5]
			mov		edx, ytPerm11	; for v[6]
			  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
			add		edx, esi		; edx = ix + ytPerm11, for v[6]
			  mov	esi, pValueTab	; point esi to valuetable
			mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
			  and	ecx, TABMASK	; still generating v[2]
			mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
			  and	edx, TABMASK	; still generating v[6]
			mov		eax, [esi + 4*eax] ; eax = v[1]
			  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
			mov		ebx, [esi + 4*ebx] ; ebx = v[5]
			  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
			mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
			  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
			mov		edx, [esi + 4*edx] ; edx = v[6]
			  mov	esi, ift		; prepare to multiply with esi
			imul	ebx, edi		; ebx = v[5] * ft
			  ; wait 10 cycles
			imul	eax, esi		; eax = v[1] * ift
			  ; wait another 10 cycles
			imul	edx, edi		; edx = v[6] * ft
			  ; wait yet another 10 cycles
			imul	ecx, esi		; ecx = v[2] * ift
			  ; wait even yet another 10 cycles
			add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
			  mov	ebx, fy			; ebx = fy....
			shr		eax, 16			; eax = vp[1]
			  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
			shr		ecx, 16			; ecx = vp[2]
			  mov	edx, ify		; edx = ify
			imul	eax, edx		; eax = vp[1] * ify
			  ; wait more cycles
			imul	ecx, ebx		; ecx = vp[2] * fy
			  ; another 10 cycle hit
			add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
			  ;
			shr		eax, 16			; eax = vpp[1]
		x_loop_nocalc:			
			mov		edx, x			; get the prescaled x
			  mov	ebx, x_inc		; get scaled x increment
		    add		ebx, edx		; ebx = x + x_inc -> new scaled x
			  lea	esi, gdwSmoothTable
			and		edx, 0xffff		; edx = fx
			  mov	x, ebx			; save off new x
			shr		edx, 8			; get upper 8 bits of fx
			  mov	ecx, vpp0		; get vpp[0]
			mov		ebx, 0xffff		; prepare to calc ifx
			  ; AGI
			  mov	edx, [esi + 4*edx]	; edx = smooth fx
			sub		ebx, edx		; ebx = ifx
			  ; imul is U pipe only
			imul	edx, eax		; edx = vpp[1] * fx
			  ; imul, besides being 10 cycles, is also not pairable
			imul	ecx, ebx		; ecx = vpp[0] * ifx
			  ; sigh
			mov		esi, pSrcLine	; prepare to read in 
			  mov	ebx, x_loop		; prepare to read in a value
			add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
			  mov	ecx, noisescale	; prepare to do scaling shift
			mov		bl, [esi + ebx]	; get the pixel value from the buffer
			  ; shr, below, is U-pipe only. get bl here to avoid partial register stall later
			shr		edx, cl			; scale the noise
			  ; shr dest, cl is a 4 clock, non-pairable 
			mov		ecx, normalize	; prepare to normalize the noise value
			  mov	edi, pDestLine	; for writing pixel value
			sub		edx, ecx		; normalize noise around 0
			  mov	ecx, noiseoffset	; prepare to normalize around non-zero
			add		edx, ecx		; noise is now normalized around m_nNoiseOffset
			  and	ebx, 0x0ff		; make sure we've only the lower 8 bits
			add		edx, ebx		; edx = new pixel value, but we gotta clamp it
			  mov	ebx, x_loop		; get x_loop again to write out pixel value 
			sets	cl				; if (value < 0) cl = 1, else cl = 0 
			  ; setcc doesn't pair
			dec		cl				; if (value < 0) cl = 0, else cl = 0x0ff
			  add	edi, ebx		; free up ebx
			cmp		edx, 0xff		; test to see if bigger than 255
			  ;						;
			setle	bl				; if (value > 255) bl = 0 else bl = 1
			  ; setcc still doesn't pair, darn it
			and		dl, cl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	bl				; if (value > 255) bl = 0xff else bl = 0
			or		dl, bl			; clamp to 255
			  mov	ecx, x_loop		; get x_loop AGAIN!
			mov		[edi], dl		; write out new pixel value
			  mov	ebx, right		; get right edge
			cmp		ecx, ebx		; check if at right edge of scan line
			  jge	x_loop_done		; if so, goto done code
			mov		edx, x			; get already-incremented x value
			  mov	ebx, lastix		; get last ix value
			shr		edx, 16			; get new ix value
			  inc	ecx				; x_loop++
			mov		x_loop, ecx		; save off x_loop
			  cmp	edx, ebx		; is lastix == ix?
			je		x_loop_nocalc	; if so, we only need to recalc a few things
			  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
			jmp		x_loop_calc		; go make more noise
		x_loop_done:
		}
	}


}

void CDXTAdditive::addsmoothnoise8mmx(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) 
{
	int x, y, y_loop, x_loop, xinc;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft;
	DWORD ift;
	DWORD iy, it;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pvaluetab, noisescale, scratch;
	DWORD allone = 0xff;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pvaluetab = m_valueTab;
	scratch = 1 << (30 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	__asm {
		mov		eax, noisescale
		mov		ebx, scratch
		movd	mm4, eax
		movd	mm0, scratch
		psllq	mm0, 32
		por		mm4, mm0		; mm4 = 1 << (31 - m_nNoiseScale):m_nNoiseScale
	}

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// Do the time mangling
	nTime = (nTime & 0xffff) << 16;
	nTime = nTime >> m_nScaleTime;
	ft = nTime & 0xffff;
	ift = 0xffff - ft;
	it = nTime >> 16;

	left = m_rActiveRect.left + timexanimatex;
	right = m_rActiveRect.right + timexanimatex;

	// put ft:ift:ft:ift into mm7
	__asm {
		mov 	eax, ft
		  mov 	ebx, ift
		movd 	mm7, ebx
		movd 	mm1, eax
		  psllq	mm7, 16
		por 	mm7, mm1
		movq 	mm1, mm7
		psllq 	mm7, 32
		por 	mm7, mm1
		psrlw	mm7, 1		; mm7 has ift:ft:ift:ft, 15 bits each (unsign -> sign)
	}
	// no emms necessary, since we've more MMX fun coming right up!
		
	xinc = (1 << 16) >> m_nScaleX;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		pDestLine = ((unsigned char *) pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *) pSrc ) + nSrcPitch *y_loop;
		y = y_loop;
		y += timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;
		iy = y >> 16;
		ytPerm00 = PERM(iy + 0 + PERM(it + 0));
		ytPerm01 = PERM(iy + 0 + PERM(it + 1));
		ytPerm10 = PERM(iy + 1 + PERM(it + 0));
		ytPerm11 = PERM(iy + 1 + PERM(it + 1));

		__asm {
			mov 	eax, left
			  lea 	ebx, gPerm
			mov		esi, ebx
			mov 	edi, pvaluetab
			  mov 	x_loop, eax
			shl		eax, 16
			  mov	ecx, scalex
			shr		eax, cl				; scale x
			mov		ebx, eax			; ebx has copy of scaled x
			  mov	edx, ytPerm00		; prepare to generate v[0]
			shr		ebx, 16				; ebx has ix
			  mov	ecx, ytPerm01		; prepare to generate v[4]
			add		edx, ebx			; edx = ix + PERM(iy + PERM(iz))
			  mov	x, eax				; free up eax
			and		edx, TABMASK		; still generating v[0]
			  mov	eax, ytPerm10		; prepare to generate v[3]
			add		ecx, ebx			; ix + ytPerm01, still for v[4]
			  add	eax, ebx			; ix + ytPerm10, still for v[3]
			mov		 dl, [esi + edx]	; edx = PERM(ix + PERM(iy + PERM(iz)))
			  and	ecx, TABMASK		; still generating v[4]
			and		eax, TABMASK		; still generating v[3]
			  ;
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix, iy, iz) = v[0]
			  mov	 cl, [esi + ecx]	; ecx = PERM(ix + PERM(iy + PERM(iz + 1)))
			movd	mm1, edx			; load mm1 with v[0]
			  ; must pair with an mmx instruction
			mov		ecx, [edi + 4*ecx]	; ecx = vlattice(ix, iy, iz+1) = v[4]
			  mov	 al, [esi + eax]	; eax = PERM(ix + PERM(iy + 1 + PERM(iz)))
			movd	mm0, ecx			; load mm0 with v[4]
			  psllq	mm1, 16				; mm1 has 0:0:v[0]:0
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix, iy+1, iz) = v[3]
			  mov	edx, ytPerm11		; prepare to generate v[7]
			add		edx, ebx			; edx = ix + ytPerm11, for v[7]
			  mov	ecx, x				; prepare to generate fx, ifx
			movd	mm2, eax			; load mm2 with v[3]
			  por	mm1, mm0			; mm1 has 0:0:v[0]:v[4]
			and		edx, TABMASK		; still generating v[7]
			  and	ecx, 0xffff			; generate fx
			movd	mm3, ecx			; load mm3 with fx
			  psllq	mm1, 32				; mm1 has v[0]:v[4]:0:0
			mov		 dl, [esi + edx]	; edx = PERM(ix + PERM(iy+1 + PERM(iz+1)))
			  mov	eax, 0x0ffff		; prepare to generate ifx
			sub		eax, ecx			; eax = 0xffff - fx = ifx
			  inc	ebx					; ebx = ix + 1
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix, iy+1, iz+1) = v[7]
			  ;
			movd	mm0, edx			; mm0 has 0:0:0:v[7]
			  psllq	mm2, 16				; mm2 has 0:0:v[3]:0
			movd	mm5, eax			; mm5 has 0:0:0:ifx
			  por	mm0, mm2			; mm0 has 0:0:v[3]:v[7]
			por		mm1, mm0			; mm1 has v[0]:v[4]:v[3]:v[7]
			  psllq	mm5, 16				; mm5 has 0:0:ifx:0
			pmaddwd	mm1, mm7			; mm1 has lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
			  mov	eax, y				; prepare to generate fy, ify
			mov		edx, 0xffff			; prepare to generate ify
			  and 	eax, 0xffff			; eax = fy
			sub 	edx, eax			; edx = ify
			  ;
			movd	mm0, eax			; mm0 has 0:0:0:fy
			  psrld	mm1, 15				; mm1 has vp[0]:vp[3], now signed 16 bits
			movd	mm6, edx			; mm6 has 0:0:0:ify
			  psllq	mm6, 16				; mm0 has 0:0:ify:0
			por		mm6, mm0			; mm6 has 0:0:ify:fy
			  packssdw mm1, mm1			; mm1 has vp[0]:vp[3]:vp[0]:vp[3]  
			psrlw	mm6, 1				; mm6 has 0:0:ify:fy, 15 bits (unsign -> sign)
			  por	mm5, mm3			; mm5 has 0:0:ifx:fx
			pmaddwd mm1, mm6			; mm1 has 0:lerp(vp[0], vp[3], fy)
			  psrlw	mm5, 1				; mm5 has 0:0:ifx:fx, 15 bits (unsign -> sign)
			  ;
			;
			  ;
			psrld	mm1, 15				; mm1 has vpp[0], now signed 16 bits 

			; at this point, the following registers have interesting things within:
;				ebx:		ix + 1
;				esi:		gPerm
;				edi:		pvaluetab
;				mm1:		0:vpp[0]
;				mm5:		0:0:fx:ifx
;				mm6:		0:0:fy:ify
;				mm7:		ft:ift:ft:ift
		
			; generate v[1], v[2], v[5] and v[6]
			; generate vp[1], vp[2]
			; generate vpp[1]
xloop_calc_vpp1:
			movq	mm0, mm1			; move vpp[0] to mm0
			  mov	eax, ytPerm00		; prepare to generate v[1]
			mov		ecx, ytPerm01		; prepare to generate v[5]
			  add	eax, ebx			; ix + 1 + ytPerm00 (v[1])
			add		ecx, ebx			; ix + 1 + ytPerm01 (v[5])
			  and	eax, TABMASK		; still generating v[1]
			and		ecx, TABMASK		; still generating v[5]
			  mov	edx, ytPerm10		; prepare to generate v[2]
			mov		 al, [esi + eax]	; eax = PERM(ix+1 + PERM(iy + PERM(iz)))
			  add	edx, ebx			; ix + 1 + ytPerm10 (v[2])
			mov		 cl, [esi + ecx]	; ecx = PERM(ix+1 + PERM(iy + PERM(iz+1)))
			  and	edx, TABMASK		; still generating v[2] 
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix+1, iy, iz) = v[1]
			  ;	AGI
			mov		ecx, [edi + 4*ecx]	; ecx = vlattice(ix+1, iy, iz+1) = v[5]
			  mov	 dl, [esi + edx]	; edx = PERM(ix+1 + PERM(iy+1 + PERM(iz)))
			movd	mm1, eax			; mm1 = 0:0:0:v[1]
			  psllq	mm0, 32				; mm1 = vpp[0]:0 still signed 16 bits
			movd	mm2, ecx			; mm2 = 0:0:0:v[5]
			  psllq	mm1, 16				; mm1 = 0:0:v[1]:0
			mov		edx, [edi + 4*edx]	; edx = vlattice(ix+1, iy+1, iz) = v[2]
			  mov	eax, ytPerm11		; prepare to generate v[6]
			add		eax, ebx			; ix + 1 + ytPerm11 (v[6])
			  por	mm1, mm2			; mm1 = 0:0:v[1]:v[5]
			and		eax, TABMASK		; still generating v[6]
			  psllq	mm1, 32				; mm1 = v[1]:v[5]:0:0
			movd	mm3, edx			; mm3 = 0:0:0:v[2]
			  ;
			mov		 al, [esi + eax]	; eax = PERM(ix+1 + PERM(iy+1 + PERM(iz+1)))
			  psllq mm3, 16				; mm3 = 0:0:v[2]:0
			por		mm1, mm3			; mm1 = v[1]:v[5]:v[2]:0
			  ; AGI
			mov		eax, [edi + 4*eax]	; eax = vlattice(ix + 1, iy + 1, iz + 1)
			  ;
			movd	mm3, eax			; mm3 = 0:0:0:v[6]
			  ;
			por		mm1, mm3			; mm1 = v[1]:v[5]:v[2]:v[6]
			  ;
			pmaddwd	mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
			  ;
			;
			  ;
			; 
			  ;
			psrld	mm1, 15				; mm1 = vp[1]:vp[2], now signed 16 bits
			  ;
			packssdw	mm1, mm1		; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
			  ;
			pmaddwd	mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
			  ;
			;
			  ;
			;
			  ;
			psrld	mm1, 15				; mm1 = 0:vpp[1]
			  ;
			por		mm0, mm1			; mm0 = vpp[0]:vpp[1]
			  ;
			packssdw	mm0, mm0		; mm0 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
			  ;
		xloop_nocalc_vpp1:
			movq	mm2, mm0			; copy mm0 so we can use it again sometime
			  mov	eax, xinc			; prepare to increment pre-scaled x
			movq	mm3, mm4			; get noisescale
			  pmaddwd	mm2, mm5	   	; mm2 = lerp(vpp[0], vpp[1], fx) = noise
		    mov 	edx, x				; prepare to increment pre-scaled x
			  psllq	mm3, 32				; clear out high 32 bits...
			psrlq	mm3, 32				; finish clearing bits
			  add 	edx, eax			; generate (x + 1) >> m_nScaleX
			mov		eax, ebx			; save off last ix + 1
			  mov	ebx, edx			; prepare to make new ix
			pslld	mm2, 1				; make back into unsigned 32 bit
			  mov	ecx, edx			; prepare to make fx
			shr		ebx, 16				; ebx = ix
			  and	ecx, 0xffff			; ecx = fx
			mov		x, edx				; save x
			  mov 	edx, 0xffff			; prepare to make ifx
			movq	mm1, mm4			; prepare to get 1 << (31 - m_nNoiseScale)
			  inc	ebx					; ebx = ix + 1
			mov		esi, pSrcLine		; get pointer to source data
			  movd	mm5, ecx			; mm5 = 0:0:0:fx
		    psrlq	mm2, mm3			; noise = noise >> m_nNoiseScale
		      sub 	edx, ecx			; new ifx
			mov		ecx, 0				; clear ecx, so we can load just the low 8 bits
			  psrlq	mm1, 32				; mm1 = 0:1 << (31 - m_nNoiseScale)
			mov		cl, [esi]			; ecx = value = pSrcLine[x]
			  movd	mm3, ecx			; mm3 = 0:value
			psubd	mm2, mm1			; mm2 = 0:signednoise - (1 << (31 - m_nNoiseScale))
			  movd	mm1, edx			; mm1 = 0:0:0:ifx
			paddd	mm2, noiseoffset	; 
			  psllq	mm1, 16				; mm1 = 0:0:ifx:0
			paddd	mm3, mm2			; mm3 = value += signednoise
			  por	mm5, mm1			; mm5 = 0:0:ifx:fx
			movd	mm2, allone			; mm1 = 0:ffffffff
			  pxor	mm1, mm1			; mm1 = 0
			pcmpgtd	mm1, mm3			; if mm3 < 0, mm1 is x:ffffffff
			  packssdw mm3, mm3			; mm3 = value:value:value:value (clamped)
			pandn	mm1, mm2			; mm1 = !(mm1)
			  packuswb	mm3, mm3		; mm3 = value:value:value:value:value:value:value:value
			pand	mm1, mm3			; clamps to zero
			  mov	ecx, x_loop			; get the all-important loop variable
			mov		edx, right			; get the loop limit
			  inc	esi
			mov		pSrcLine, esi		; save off new source data pointer
			  mov	edi, pDestLine		; get the dest pointer
			inc 	ecx					; x_loop++
			  psrlw	mm5, 1				; convert to signed 16 bits
			cmp		ecx, edx			; are we quite done yet?
			  jge	xloop_done			; all done.. write out last value and get on with outer loop
			movd	edx, mm1			; edx = value
			  ;
			mov		[edi], dl			; write out new value
			  ;
			inc		edi
			  mov	x_loop, ecx			; save off the loop variable
			mov		pDestLine, edi		; save off new dest pointer
			  lea 	ecx, gPerm
			mov		esi, ecx
			  mov 	edi, pvaluetab
			cmp 	eax, ebx			; is lastix == ix
			  je	xloop_nocalc_vpp1	; if so, all we have to do is the last lerp
			movq	mm1, mm0			; mm1 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
			  ;
			psllq	mm1, 48				; mm1 = vpp[1]:0:0:0
				psrlq	mm1, 48			; mm1 = 0:0:0:vpp[1]
			jmp		xloop_calc_vpp1		; if not, there be more calculating to do

		xloop_done:
			movd	edx, mm1			; edx = value
			  ;
			mov		[edi], dl			; write out new value
		}  
	}

	__asm {
		emms
	}

}


void CDXTAdditive::addsmoothturb8(int nTime, void *pDest, 
												int nDestPitch, void *pSrc, 
												int nSrcPitch, void *pMask, 
												int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pDestLine, *pSrcLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
#ifdef MEASURE_TIME
	FILE *fpOut;
	DWORD time, timeloop;
	static int lastxscale = -1;
	static int lastharmonics = -1;

	fpOut = fopen("c:\\inttime.txt", "a");
	if ((lastxscale != m_nScaleX) || (lastharmonics != m_nHarmonics)) {
		fprintf(fpOut, "X Scale = %d,  Harmonics = %d\n", m_nScaleX, m_nHarmonics);
		lastxscale = m_nScaleX;
		lastharmonics = m_nHarmonics;
	}
	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;

	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		__asm {
			mov		eax, left		; get left side of scan line
			  mov	edi, pScan		; get pointer to noise array
			mov		esi, pSrcLine	; get pointer to source data
			  mov	ecx, noisescale	; get noise scale into cl

		noise_loop:
			mov		edx, [edi+4*eax]; edx = pScan[x_loop]
			  xor	ebx, ebx		; zero out ebx
			mov		bl, [esi+eax]	; get source pixel value
			  mov	esi, pDestLine	; get pointer to dest data
			mov		dword ptr [edi+4*eax], 0x0000000	; zero out pScan[x_loop]
			  add	esi, eax		; free up eax
			sar		edx, cl			; scale the noise value
			  ; doesn't pair - 4 clocks
			mov		ecx, noiseoffset; get noiseoffset value
			  inc	eax				; x_loop++
			add		edx, ecx		; noise += noiseoffset
			  mov	ecx, right		; 
			add		ebx, edx		; value += noise
			  mov	edi, eax		; save x_loop++ for a little while 
			sets	dl				; if (value < 0) dl = 1, else dl = 0 
			  ; setcc doesn't pair
			dec		dl				; if (value < 0) dl = 0, else dl = 0x0ff
			  cmp	ebx, 0xff		; test to see if bigger than 255
			setle	al				; if (value > 255) al = 0 else al = 1
			  ; setcc still doesn't pair, darn it
			and		bl, dl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	al				; if (value > 255) bl = 0xff else bl = 0
			or		bl, al			; clamp to 255
			  mov	[esi], bl		; write new pixel value to dest
			mov		eax, edi		; get back x_loop++
			  mov	edi, pScan		; get pointer back
			cmp		eax, ecx		; see if we're done yet
			  mov	esi, pSrcLine	; get pointer to source buffer
			mov		ecx, noisescale	; get noise scale into cl
			  jle	noise_loop		; jump if not done with all the noise values
		} // end asm block
	} // end y loop
#ifdef MEASURE_TIME
	}
	fprintf(fpOut, "%d ms\n", timeGetTime() - time);
	fclose(fpOut);
#endif
}



void CDXTAdditive::addsmoothturb8mmx(int nTime, void *pDest, 
													int nDestPitch, void *pSrc, 
													int nSrcPitch, void *pMask, 
													int nMaskPitch) {
 
	DWORD x, y, t;
	DWORD	ft, fy, ift, ify, fx, ifx;
	DWORD iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	int y_loop, h_loop, x_loop;
	DWORD x_base, x_inc;
	int right, left;
	DWORD *pScan;
	DWORD timexanimatex, timexanimatey;
	DWORD *pValueTab, noiseoffset, noisescale;
	DWORD lastix;

	unsigned char *pSrcLine, *pDestLine;
#ifdef MEASURE_TIME
	FILE *fpOut;
	DWORD time, timeloop;
	static int lastxscale = -1;
	static int lastharmonics = -1;

	fpOut = fopen("c:\\mmxtime.txt", "a");
	if ((lastxscale != m_nScaleX) || (lastharmonics != m_nHarmonics)) {
		fprintf(fpOut, "X Scale = %d,  Harmonics = %d\n", m_nScaleX, m_nHarmonics);
		lastxscale = m_nScaleX;
		lastharmonics = m_nHarmonics;
	}
	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif

	nTime = nTime & 0xffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;

	noiseoffset = m_nNoiseOffset;
	noisescale = m_nNoiseScale;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		t = (nTime) << 16;
		t = t >> m_nScaleTime;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = ((left+timexanimatex) & 0xffff) << 16;
		x_base = x_base >> m_nScaleX;

		x_inc = (1 << 16) >> m_nScaleX;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ft = ft >> 1;			// cvt to signed
			ift = 0x7fff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			fy = fy >> 1;			// cvt to signed
			ify = 0x7fff - fy;

			fx = gdwSmoothTable[(x & 0xffff) >> 8];
			fx = fx >> 1;			// cvt to signed
			ifx = 0x7fff - fx;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				lea		edi, gPerm			; load edi with pointer to perm table
				  mov	eax, ift			; preparing to load mm7 with ift:ft:ift:ft
				movd	mm7, eax			; mm7 = 0:ift
				  ; must pair with an mmx inst.
				mov		eax, ft				; preparing to load mm7 with ift:ft:ift:ft
				  mov	esi, x				; preparing to get ix
				shr		esi, 16				; esi = ix
				  mov	ebx, ytPerm01		; for v[4]
				movd	mm4, eax			; mm4 = 0:ft
				  psllq	mm7, 32				; mm7 = ift:0
				mov		eax, ytPerm00		; for v[0]
				  add	ebx, esi			; ebx = ix + ytPerm01, for v[4]
				mov		ecx, ytPerm10		; for v[3]
				  add	eax, esi			; eax = ix + ytPerm00, for v[0]
				mov		edx, ytPerm11		; for v[7]
				  and	eax, TABMASK		; clamp to (0,255), for v[0]
				and		ebx, TABMASK		; clamp to (0,255), for v[4]
				  add	ecx, esi			; ecx = ix + ytPerm10, for v[3]
				add		edx, esi			; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab		; load esi with pointer to random value table
				mov		eax, [edi+4*eax]	; get hash value from table
				  and	ecx, TABMASK		; clamp to (0, 255), for v[3]
				mov		ebx, [edi+4*ebx]	; get hash value from table
				  and	edx, TABMASK		; clamp to (0, 255), for v[7]
				mov		ecx, [edi+4*ecx]	; get hash value from table
				  mov	eax, [esi+4*eax]	; eax = v[0]
				movd	mm0, eax			; mm0 = 0:v[0]
				  por	mm7, mm4			; mm7 = ift:ft
				mov		ebx, [esi+4*ebx]	; ebx = v[4]
				  mov	edx, [edi+4*edx]	; get hash value from table
				mov		ecx, [esi+4*ecx]	; ecx = v[3]
				  packssdw	mm7, mm7		; mm7 = ift:ft:ift:ft
				mov		eax, ify			; preparing to load mm6 with 0:0:ify:fy
				  mov	edx, [esi+4*edx]	; edx = v[7]
				movd	mm4, ebx			; mm4 = 0:v[4]
				  psllq	mm0, 32				; mm0 = v[0]:0
				movd	mm3, ecx			; mm3 = 0:v[3]
				  por	mm0, mm4			; mm0 = v[0]:v[4]
				movd	mm4, edx			; mm4 = 0:v[7]
				  psllq	mm3, 32				; mm3 = v[3]:0
				movd	mm6, eax			; mm2 = 0:ify
				  por	mm3, mm4			; mm3 = v[3]:v[7]
				packssdw	mm3, mm0		; mm3 = v[0]:v[4]:v[3]:v[7]
				  mov	eax, fy				; preparing to load mm6 with 0:0:ify:fy
				movd	mm2, eax			; mm2 = 0:fy
				pmaddwd	mm3, mm7			; mm3 = lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
				  mov	ebx, x				; prepare to get ix again
				shr		ebx, 16				; ebx = ix
				  psllq	mm6, 16				; mm6 = 0:0:ify:0
				por	mm6, mm2			; mm6 = 0:0:ify:fy
				  mov	eax, ifx			; prepare to setup mm5 with 0:0:ifx:fx
				psrld	mm3, 15				; mm3 has 0:vp[0]:0:vp[3], signed
				packssdw	mm3, mm3		; mm3 = vp[0]:vp[3]:vp[0]:vp[3]
				  mov	ecx, h_loop			; prepare to setup mm4 with h_loop (for shifting)
				movd	mm5, eax			; mm5 = 0:ifx
				  pmaddwd	mm3, mm6		; mm3 = 0:lerp(vp[0], vp[3], fy)
				mov		edx, fx				; prepare to setup mm5 with 0:0:ifx:fx
				  inc	ecx					; ecx = h_loop + 1 (gets rid of a shift by one later)
				movd	mm2, edx			; mm2 = 0:fx
				  psllq	mm5, 16				; mm5 = 0:0:ifx:0
				movd	mm4, ecx			; mm4 = h_loop+1
				  por	mm5, mm2			; mm5 = 0:0:ifx:fx
				inc		ebx					; ebx = ix + 1
				  psrld	mm3, 15				; mm3 = 0:vpp[0]

				; at this point, the following registers have interesting things contained within:
				; 
				; ebx		ix + 1
				; esi		pValueTab
				; edi		gPerm
				; mm3		vpp[0]
				; mm4		h_loop
				; mm5		0:0:ifx:fx
				; mm6		0:0:ify:fy
				; mm7		ift:ft:ift:ft
		x_calc_loop:
				mov			eax, ytPerm00	; prepare to calc v[1]
				  mov		ecx, ytPerm01	; prepare to calc v[5]
				add			eax, ebx		; eax = ix + 1 + ytPerm00, for v[1]
				  mov		edx, ytPerm10	; prepare to calc v[2]
				add			ecx, ebx		; ecx = ix + 1 + ytPerm01, for v[5]
				  and		eax, TABMASK	; clamp to (0, 255)
				and			ecx, TABMASK	; clamp to (0, 255)
				  add		edx, ebx		; edx = ix + 1 + ytPerm10, for v[2]
				and			edx, TABMASK	; clamp to (0, 255)
				  mov		eax, [edi + 4*eax]	; get hash value from table
				mov			ecx, [edi + 4*ecx]	; get hash value from table
				  mov		edx, [edi + 4*edx]	; get hash value from table (might be a bank conflict)
				mov			eax, [esi + 4*eax]	; eax = v[1]
				  ; movd, below, is U pipe only
				movd		mm0, eax			; mm0 = 0:v[1]
				  ; must pair with mmx instruction
				mov			eax, ytPerm11		; prepare to calc v[6]
				  mov		ecx, [esi + 4*ecx]	; ecx = v[5]
				add			eax, ebx			; eax = ix + 1 + ytPerm11, for v[6]
				  mov		edx, [esi + 4*edx]	; edx = v[2]
				and			eax, TABMASK		; clamp to (0, 255)
				  mov		lastix, ebx			; save off last ix+1 value
				movd		mm1, ecx			; mm1 = 0:v[5]
				  psllq		mm0, 32				; mm0 = v[1]:0
				mov			eax, [edi + 4*eax]	; get hash value from table for v[6]
				  mov		ecx, x				; prepare to calc fx
				movd		mm2, edx			; mm2 = 0:v[2]
				  por		mm0, mm1			; mm0 = v[1]:v[5]
				mov			eax, [esi + 4*eax]	; eax = v[6]
				  and		ecx, 0xffff			; ecx = fx
				movd		mm1, eax			; mm1 = 0:v[6]
				  psllq		mm2, 32				; mm2 = v[2]:0
				shr			ecx, 8				; ecx = upper 8 bits of fx
				  por		mm1, mm2			; mm1 = v[2]:v[6]
				packssdw	mm1, mm0			; mm1 = v[1]:v[5]:v[2]:v[6]
				  lea		edi, gdwSmoothTable	; load edi with pointer to smoothing table
				pmaddwd		mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
				  mov		eax, 0xffff			; prepare eax to get smooth ifx
				mov			ecx, [edi + 4*ecx]	; load up ecx with smooth fx
				  mov		esi, pScan			; load up esi with pointer to scan array
				sub			eax, ecx			; eax = smoothed ifx
				  mov		edx, x_loop			; load up edx with current x_loop
				movd		mm5, eax			; mm5 = 0:ifx
				  psrld		mm1, 15				; mm1 = vp[1]:vp[2]
				movd		mm0, ecx			; mm0 = 0:fx
				  packssdw	mm1, mm1			; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
				pmaddwd		mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
				  psllq		mm5, 16				; mm5 = 0:0:ifx:0
				por			mm5, mm0			; mm5 = 0:0:ifx:fx
				  lea		esi, [esi + 4*edx]	; load up esi with pointer to THIS VERY NOISE VALUE LOCATION!
				psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
				  ;
				psrld		mm1, 15				; mm1 = vpp[1]
				  psllq		mm3, 16				; mm3 = 0:0:vpp[0]:0
				por			mm3, mm1			; mm3 = 0:0:vpp[0]:vpp[1]
				; at this point, the following registers have interesting things contained within:
				;
				; ebx		ix + 1
				; edx		x_loop
				; esi		pScan + 4*x_loop
				; edi		gdwSmoothTable
				; mm1		vpp[1]
				; mm3		0:0:vpp[0]:vpp[1]
				; mm4		h_loop
				; mm5		0:0:ifx:fx
				; mm6		0:0:ify:fy
				; mm7		ift:ft:ift:ft
			x_nocalc_loop:
				pmaddwd		mm5, mm3			; mm5 = 0:lerp(vpp[0], vpp[1], fx)
				  mov		eax, [esi]			; eax = old noise value at this location
				mov			ecx, right			; load up the right edge
				  pcmpeqd	mm0, mm0			; load up mm0 with all ones
				psrlq		mm0, 35				; mm0 = 0:0x1fffffff
				  cmp		edx, ecx			; are we quite done yet?
				psubd		mm5, mm0			; mm5 = normalized about 0 noise
				  jge		x_loop_done			; if so, finish & bail
				inc			edx					; edx = x_loop++
				  psrad		mm5, mm4			; 'divide' by # of harmonics
				mov			x_loop, edx			; save off x_loop value
				  mov		ecx, x				; get last x value
				mov			edx, x_inc			; get x increment
				  ;
				add			ecx, edx			; generate new x
				  mov		ebx, ecx			; get copy of new x to calc new ix + 1
				mov			x, ecx				; save off new x
				shr			ebx, 16				; ebx = new ix
			      mov		edx, 0xffff			; to calc new ifx, new fx
				and			ecx, edx			; ecx = new fx
				  shr		ecx, 8				; ecx = upper 8 bits new fx
				; AGI
				mov			ecx, [edi + 4*ecx]	; ecx = smooth fx
				  inc		ebx					; ebx = new ix + 1
				sub			edx, ecx			; edx = new ifx
				  ;
				movd		mm0, edx			; mm0 = 0:0:0:ifx
				  ;
				movd		mm2, ecx			; mm2 = 0:0:0:fx
				  pslld		mm0, 16				; mm0 = 0:0:ifx:0
				movd		edx, mm5			; edx = new noise value to be added
			  	  por		mm0, mm2			; mm0 = 0:0:ifx:fx
				add			eax, edx			; eax = new noise value
				  movq		mm5, mm0			; mm5 = 0:0:ifx:fx
				mov			[esi], eax			; write out new noise value
				  add		esi, 4				; move pointer one DWORD
				mov			eax, lastix			; get lastix+1
				  mov		edx, x_loop			; get x_loop value back into edx
				cmp			eax, ebx			; does lastix+1 == new ix+1?
				psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
				  je		x_nocalc_loop		; if so, go do this again

				movq		mm1, mm3			; mm3 = new vpp[0] (old vpp[1])
				  mov		esi, pValueTab
				lea			edi, gPerm
				jmp			x_calc_loop
			x_loop_done:
				psrad		mm5, mm4			; 'divide' by # of harmonics
				  ; STALLOLA - should insert the c code below here.
				movd		edx, mm5			; edx = new noise value to be added
				  ;
				add			eax, edx			; eax = new noise value
				  ;
				mov			[esi], eax			; write out last noise value
			} // asm block (and x loop)

			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;

		} // harmonics loop


		pDestLine = ((unsigned char *)pDest) + nDestPitch*y_loop;
		pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

		__asm {
			mov		eax, left		; get left side of scan line
			  mov	edi, pScan		; get pointer to noise array
			mov		esi, pSrcLine	; get pointer to source data
			  mov	ecx, noisescale	; get noise scale into cl

		noise_loop:
			mov		edx, [edi+4*eax]; edx = pScan[x_loop]
			  xor	ebx, ebx		; zero out ebx
			mov		bl, [esi+eax]	; get source pixel value
			  mov	esi, pDestLine	; get pointer to dest data
			mov		dword ptr [edi+4*eax], 0x0000000	; zero out pScan[x_loop]
			  add	esi, eax		; free up eax
			sar		edx, cl			; scale the noise value
			  ; doesn't pair - 4 clocks
			mov		ecx, noiseoffset; get noiseoffset value
			  inc	eax				; x_loop++
			add		edx, ecx		; noise += noiseoffset
			  mov	ecx, right		; 
			add		ebx, edx		; value += noise
			  mov	edi, eax		; save x_loop++ for a little while 
			sets	dl				; if (value < 0) dl = 1, else dl = 0 
			  ; setcc doesn't pair
			dec		dl				; if (value < 0) dl = 0, else dl = 0x0ff
			  cmp	ebx, 0xff		; test to see if bigger than 255
			setle	al				; if (value > 255) al = 0 else al = 1
			  ; setcc still doesn't pair, darn it
			and		bl, dl			; if (value < 0) dl = 0 (clamp to 0)
			  dec	al				; if (value > 255) bl = 0xff else bl = 0
			or		bl, al			; clamp to 255
			  mov	[esi], bl		; write new pixel value to dest
			mov		eax, edi		; get back x_loop++
			  mov	edi, pScan		; get pointer back
			cmp		eax, ecx		; see if we're done yet
			  mov	esi, pSrcLine	; get pointer to source buffer
			mov		ecx, noisescale	; get noise scale into cl
			  jle	noise_loop		; jump if not done with all the noise values
		} // end asm block
	}

	__asm {
		emms
	}
#ifdef MEASURE_TIME
	}
	fprintf(fpOut, "%d ms\n", timeGetTime() - time);
	fclose(fpOut);
#endif

}


void CDXTAdditive::addsmoothnoise16(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	WORD *pDestLine, *pSrcLine;
    int value = 0;
	DWORD noise = 0;
	int	signednoise;
	int timexanimatex, timexanimatey;
	WORD *pwPalette;
						    
	pwPalette = (WORD *) m_pPalette;

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	for (y=m_rActiveRect.top; y<m_rActiveRect.bottom;y++) {
		pDestLine = ((WORD *)pDest) + nDestPitch*y;
		pSrcLine  = ((WORD *)pSrc)  + nSrcPitch *y;
		for (x=m_rActiveRect.left; x<m_rActiveRect.right; x++) {
			value = pSrcLine[x];
			if (m_nNoiseScale != 32) {
				noise = smoothnoise(x+timexanimatex, y+timexanimatey, nTime, m_nScaleX, m_nScaleY, m_nScaleTime);
				noise = noise >> m_nNoiseScale;
				signednoise = noise;
				signednoise = signednoise - (1 << (31 - m_nNoiseScale));

				signednoise += m_nNoiseOffset;
				value += signednoise;
				// clamp
				if (value < 0) value = 0;
				if (value > m_nPaletteSize) value = m_nPaletteSize;
			}
			pDestLine[x] = pwPalette[value];
		}
	}
}

void CDXTAdditive::addsmoothturb16(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	int x, y;
	WORD *pDestLine, *pSrcLine;
    int value = 0;
	DWORD noise = 0;
	int	signednoise;
	int timexanimatex, timexanimatey;
	WORD *pwPalette;
						    
	pwPalette = (WORD *) m_pPalette;

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	for (y=m_rActiveRect.top; y<m_rActiveRect.bottom;y++) {
		pDestLine = ((WORD *)pDest) + nDestPitch*y;
		pSrcLine  = ((WORD *)pSrc)  + nSrcPitch *y;
		for (x=m_rActiveRect.left; x<m_rActiveRect.right; x++) {
			value = pSrcLine[x];
			if (m_nNoiseScale != 32) {
				signednoise = smoothturbulence(x+timexanimatex, y+timexanimatey, nTime);
				signednoise = signednoise >> m_nNoiseScale;

				signednoise += m_nNoiseOffset;
				value += signednoise;
				if (value < 0) value = 0;
				if (value > m_nPaletteSize) value = m_nPaletteSize;
			}
			pDestLine[x] = pwPalette[value];
		}
	}
}

void CDXTAdditive::addsmoothturb32(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pSrcLine;
	DWORD *pDestLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
	DWORD *pPalette;
	DWORD	alphamask;




#ifdef MEASURE_TIME
	DWORD time, timeloop;
	char buf[80];

	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif
	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch = nDestPitch >> 2;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;
	pPalette = 	(DWORD *) m_pPalette;


	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		
		
		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  ;
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, pDestLine		; get pointer to dest buffer
				and		ebx, 0xff			; finish clamping to (0, 255)
				  mov	ecx, right			; prepare to see if we're done
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  ;
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				and		ebx, 0xff			; finish clamping to (0, 255)
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				mov		edi, pDestLine		; get pointer to dest buffer
				  mov	ecx, right			; prepare to see if we're done
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			} 
		}

	} // end y loop
#ifdef MEASURE_TIME
	}
	wsprintf(buf, "%d ms\n", timeGetTime() - time);
	OutputDebugString(buf);
#endif
}



void CDXTAdditive::addsmoothturb8to32mask(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
    int value = 0;
	DWORD noise = 0;

	int x, y, y_loop, x_loop, h_loop;
	unsigned char *pSrcLine;
	DWORD *pDestLine;
	DWORD *pMaskLine;
	int timexanimatex, timexanimatey;
	DWORD ft, ift, t;
	DWORD iy, it;
	DWORD fy, ify;
	DWORD ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	DWORD left, right;
	DWORD scalex, noiseoffset, *pValueTab, noisescale, normalize, *pScan;
	DWORD allone = 0xff;
	DWORD x_base, x_inc, x_base_save, x_inc_save;
	DWORD lastix;
	DWORD vpp0, vpp1;
	DWORD *pPalette;
	DWORD chromakey;
	DWORD alphamask;

#ifdef MEASURE_TIME
	DWORD time, timeloop;
	char buf[80];

	time = timeGetTime();

	for (timeloop=0;timeloop<100;timeloop++) {
#endif
	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch = nDestPitch >> 2;
	nMaskPitch = nMaskPitch >> 2;

	nTime = nTime & 0x0ffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	// copy some member variables into locals, since the inline assembler
	// can't access them... unless it would be through the this pointer, maybe
	scalex = m_nScaleX;
	noiseoffset = m_nNoiseOffset;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	normalize = 1 << (31 - m_nNoiseScale);
	noisescale = m_nNoiseScale;
	pPalette = 	(DWORD *) m_pPalette;
	chromakey = m_ColorKey;


	x_base_save = (((m_rActiveRect.left+timexanimatex) & 0xffff) << 16) >> m_nScaleX;
	left = m_rActiveRect.left;
	right = m_rActiveRect.right - 1;

	// setup the x_base -> prescaled x value at the left of every scan line

	// the scaled x value (starting at x_base) gets incremented this much 
	// at each texel
	x_inc_save = (1 << 16) >> m_nScaleX;

	// Time doesn't change at all in this function, so pre-cal all of it

	for (y_loop=m_rActiveRect.top; y_loop<m_rActiveRect.bottom;y_loop++) {
		// Setup the time vars
		t = (nTime) << 16;
		t = t >> m_nScaleTime;


		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = x_base_save;
		x_inc = x_inc_save;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ft = gdwSmoothTable[(t & 0xffff) >> 8];
			ift = 0xffff - ft;

			fy = gdwSmoothTable[(y & 0xffff) >> 8];
			ify = 0xffff - fy;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));
			__asm {
				; first, calc v[0], v[4], v[3] and v[7]
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[4]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[3]
				mov		esi, eax		; esi = ix
				  mov	eax, ytPerm00	; for v[0]
				add		eax, esi		; eax = ix + ytPerm00, for v[0]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[4]
				and		eax, TABMASK	; still generating v[0]
				  and	ebx, TABMASK	; still generating v[4]
				mov		edx, ytPerm11	; for v[7]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[3]
				add		edx, esi		; edx = ix + ytPerm11, for v[7]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[3]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[7]
				mov		eax, [esi + 4*eax] ; eax = v[0]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[4]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[3]
				mov		edx, [esi + 4*edx] ; edx = v[7]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[4] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[0] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[7] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[3] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[0], v[4], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[0]
				  add	ecx, edx		; ecx = smoothstep(v[3], v[7], ft)
				shr		ecx, 16			; ecx = vp[3]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[0] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[3] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[0], vp[3], fy)
				  ;
				shr		eax, 16			; eax = vpp[0]
				  ;
				mov		vpp0, eax		; save off vpp[0] for later
			x_loop_calc:
				; assumptions:
				lea		edx, gPerm
				  mov	eax, x
				mov		edi, edx
				  mov	ebx, ytPerm01	; for v[5]
				shr		eax, 16
				  mov	ecx, ytPerm10	; for v[2]
				mov		lastix, eax		; save off this ix value to look at next time
				  inc	eax
				mov		esi, eax		; esi = ix + 1
				  mov	eax, ytPerm00	; for v[1]
				add		eax, esi		; eax = ix + ytPerm00, for v[1]
				  add	ebx, esi		; ebx = ix + ytPerm01, for v[5]
				and		eax, TABMASK	; still generating v[1]
				  and	ebx, TABMASK	; still generating v[5]
				mov		edx, ytPerm11	; for v[6]
				  add	ecx, esi		; ecx = ix + ytPerm10, for v[2]
				add		edx, esi		; edx = ix + ytPerm11, for v[6]
				  mov	esi, pValueTab	; point esi to valuetable
				mov		eax, [edi + 4*eax] ; eax = PERM(ix+1 + PERM(iy+0 + PERM(it+0)))
				  and	ecx, TABMASK	; still generating v[2]
				mov		ebx, [edi + 4*ebx] ; ebx = PERM(ix+1 + PERM(iy+0 + PERM(it+1)))
				  and	edx, TABMASK	; still generating v[6]
				mov		eax, [esi + 4*eax] ; eax = v[1]
				  mov	ecx, [edi + 4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+0)))
				mov		ebx, [esi + 4*ebx] ; ebx = v[5]
				  mov	edx, [edi + 4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
				mov		edi, ft			; done with edi as a pointer, prepare to multiply with it
				  mov	ecx, [esi + 4*ecx] ; ecx = v[2]
				mov		edx, [esi + 4*edx] ; edx = v[6]
				  mov	esi, ift		; prepare to multiply with esi
				imul	ebx, edi		; ebx = v[5] * ft
				  ; wait 10 cycles
				imul	eax, esi		; eax = v[1] * ift
				  ; wait another 10 cycles
				imul	edx, edi		; edx = v[6] * ft
				  ; wait yet another 10 cycles
				imul	ecx, esi		; ecx = v[2] * ift
				  ; wait even yet another 10 cycles
				add		eax, ebx		; eax = smoothstep(v[1], v[5], ft)
				  mov	ebx, fy			; ebx = fy....
				shr		eax, 16			; eax = vp[1]
				  add	ecx, edx		; ecx = smoothstep(v[2], v[6], ft)
				shr		ecx, 16			; ecx = vp[2]
				  mov	edx, ify		; edx = ify
				imul	eax, edx		; eax = vp[1] * ify
				  ; wait more cycles
				imul	ecx, ebx		; ecx = vp[2] * fy
				  ; another 10 cycle hit
				add		eax, ecx		; eax = smoothstep(vp[1], vp[2], fy)
				  ;
				shr		eax, 16			; eax = vpp[1]
				  ;
				mov		vpp1, eax
			x_loop_nocalc:			
				mov		edx, x			; get the prescaled x
				  mov	ebx, x_inc		; get scaled x increment
				add		ebx, edx		; ebx = x + x_inc -> new scaled x
				  lea	esi, gdwSmoothTable
				and		edx, 0xffff		; edx = fx
				  mov	x, ebx			; save off new x
				shr		edx, 8			; get upper 8 bits of fx
				  mov	ecx, vpp0		; get vpp[0]
				mov		ebx, 0xffff		; prepare to calc ifx
				  mov	edi, pScan		; prepare to write out to scan array
				mov		edx, [esi + 4*edx]	; edx = smooth fx
				  sub	ebx, edx		; ebx = ifx
				imul	edx, eax		; edx = vpp[1] * fx
				  ; imul, besides being 10 cycles, is also not pairable
				imul	ecx, ebx		; ecx = vpp[0] * ifx
				  ; sigh
				add		edx, ecx		; edx = smoothstep(vpp[0], vpp[1], fx)
				  mov	eax, x_loop		; prepare to write out to scan array
				shr		edx, 1			; prepare to normalize around 0
				  mov	ecx, h_loop		; prepare to scale noisevalue as a function of harmonics
				sub		edx, 0x3fffffff	; normalize about 0
				  mov	ebx, [edi+4*eax]; get scan array value
				sar		edx, cl			; "divide" by harmonics value
				  ;	shift by cl doesn't pair
				add		edx, ebx		; edx = new scan array value
				  mov	ebx, right		; get right edge
				mov		[edi+4*eax], edx	; save off new scan array value
				  cmp	eax, ebx		; check if at right edge of scan line
				jge		x_loop_done		; if so, goto done code
				  mov	edx, x			; get already-incremented x value
				mov		ebx, lastix		; get last ix value
				  inc	eax				; x_loop++
				shr		edx, 16			; get new ix value
				  mov	x_loop, eax		; save off x_loop
				mov		eax, vpp1		; get back vpp[1]
				  cmp	edx, ebx		; is lastix == ix?
				je		x_loop_nocalc	; if so, we only need to recalc a few things
				  mov	vpp0, eax		; save off this vpp[1] to be the next vpp[0]
				jmp		x_loop_calc		; go make more noise
			x_loop_done:
			} // end asm block (and x loop)
			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;
		} // end harmonics loop

		
		
		if (pSrc) {
			// the following loop screams to be optimized. 
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			// the following loop screams to be optimized. 
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			}
		}
	} // end y loop
#ifdef MEASURE_TIME
	}
	wsprintf(buf, "%d ms\n", timeGetTime() - time);
	OutputDebugString(buf);
#endif
}

void 
CDXTAdditive::addsmoothturb8to32mmx(int nTime, void *pDest, int nDestPitch, 
                                    void *pSrc, int nSrcPitch, void *pMask, 
                                    int nMaskPitch) 
{
    DWORD   x, y, t;
    DWORD   ft, ift, fy, ify, fx, ifx;
    DWORD   iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
    int     y_loop, h_loop, x_loop;
    DWORD   x_base, x_inc, lastix;
    int     right, left;
    DWORD * pScan;
    DWORD   timexanimatex, timexanimatey;
    DWORD * pValueTab;
    DWORD * pPalette = (DWORD *) m_pPalette;
    DWORD   noisescale, noiseoffset;
    unsigned char *pSrcLine;
    DWORD * pDestLine;
    DWORD   alphamask;

    if (m_alphaActive == 1) 
	    alphamask = 0x80000000;
    else 
	    alphamask = 0xff000000;

    nDestPitch /= 4;


    nTime = nTime & 0xffff;		// keep things as expected...

    timexanimatex = nTime * m_nTimeAnimateX;
    timexanimatey = nTime * m_nTimeAnimateY;

    left = m_rActiveRect.left;
    right = m_rActiveRect.right - 1;

    pValueTab = m_valueTab;
    pScan = m_pdwScanArray;

    noiseoffset = m_nNoiseOffset;
    noisescale = m_nNoiseScale - 2;

    for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) 
    {
        t = (nTime) << 16;
        t = t >> m_nScaleTime;

        y = y_loop + timexanimatey;
        y = (y & 0xffff) << 16;
        y = y >> m_nScaleY;


        x_base = ((left+timexanimatex) & 0xffff) << 16;
        x_base = x_base >> m_nScaleX;

        x_inc = (1 << 16) >> m_nScaleX;

        for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) 
        {
            x_loop = m_rActiveRect.left;
            x = x_base;

            iy = y >> 16;
            it = t >> 16;

            ft = gdwSmoothTable[(t & 0xffff) >> 8];
            ft = ft >> 1;			// cvt to signed
            ift = 0x7fff - ft;

            fy = gdwSmoothTable[(y & 0xffff) >> 8];
            fy = fy >> 1;			// cvt to signed
            ify = 0x7fff - fy;

            fx = gdwSmoothTable[(x & 0xffff) >> 8];
            fx = fx >> 1;			// cvt to signed
            ifx = 0x7fff - fx;

            ytPerm00 = PERM(iy+0 + PERM(it+0));
            ytPerm01 = PERM(iy+0 + PERM(it+1));
            ytPerm10 = PERM(iy+1 + PERM(it+0));
            ytPerm11 = PERM(iy+1 + PERM(it+1));

            __asm {
                lea     edi, gPerm                      ; load edi with pointer to perm table
                    mov     eax, ift                    ; preparing to load mm7 with ift:ft:ift:ft
                movd    mm7, eax                        ; mm7 = 0:ift
                                                        ; must pair with an mmx inst.
                mov     eax, ft                         ; preparing to load mm7 with ift:ft:ift:ft
                    mov     esi, x                      ; preparing to get ix
                shr     esi, 16                         ; esi = ix
                  mov	ebx, ytPerm01		; for v[4]
                movd	mm4, eax			; mm4 = 0:ft
                  psllq	mm7, 32				; mm7 = ift:0
                mov		eax, ytPerm00		; for v[0]
                  add	ebx, esi			; ebx = ix + ytPerm01, for v[4]
                mov		ecx, ytPerm10		; for v[3]
                  add	eax, esi			; eax = ix + ytPerm00, for v[0]
                mov		edx, ytPerm11		; for v[7]
                  and	eax, TABMASK		; clamp to (0,255), for v[0]
                and		ebx, TABMASK		; clamp to (0,255), for v[4]
                  add	ecx, esi			; ecx = ix + ytPerm10, for v[3]
                add		edx, esi			; edx = ix + ytPerm11, for v[7]
                  mov	esi, pValueTab		; load esi with pointer to random value table
                mov		eax, [edi+4*eax]	; get hash value from table
                  and	ecx, TABMASK		; clamp to (0, 255), for v[3]
                mov		ebx, [edi+4*ebx]	; get hash value from table
                  and	edx, TABMASK		; clamp to (0, 255), for v[7]
                mov		ecx, [edi+4*ecx]	; get hash value from table
                  mov	eax, [esi+4*eax]	; eax = v[0]
                movd	mm0, eax			; mm0 = 0:v[0]
                  por	mm7, mm4			; mm7 = ift:ft
                mov		ebx, [esi+4*ebx]	; ebx = v[4]
                  mov	edx, [edi+4*edx]	; get hash value from table
                mov		ecx, [esi+4*ecx]	; ecx = v[3]
                  packssdw	mm7, mm7		; mm7 = ift:ft:ift:ft
                mov		eax, ify			; preparing to load mm6 with 0:0:ify:fy
                  mov	edx, [esi+4*edx]	; edx = v[7]
                movd	mm4, ebx			; mm4 = 0:v[4]
                  psllq	mm0, 32				; mm0 = v[0]:0
                movd	mm3, ecx			; mm3 = 0:v[3]
                  por	mm0, mm4			; mm0 = v[0]:v[4]
                movd	mm4, edx			; mm4 = 0:v[7]
                  psllq	mm3, 32				; mm3 = v[3]:0
                movd	mm6, eax			; mm2 = 0:ify
                  por	mm3, mm4			; mm3 = v[3]:v[7]
                packssdw	mm3, mm0		; mm3 = v[0]:v[4]:v[3]:v[7]
                  mov	eax, fy				; preparing to load mm6 with 0:0:ify:fy
                movd	mm2, eax			; mm2 = 0:fy
                pmaddwd	mm3, mm7			; mm3 = lerp(v[0], v[4], ft):lerp(v[3], v[7], ft)
                  mov	ebx, x				; prepare to get ix again
                shr		ebx, 16				; ebx = ix
                  psllq	mm6, 16				; mm6 = 0:0:ify:0
                por	mm6, mm2			; mm6 = 0:0:ify:fy
                  mov	eax, ifx			; prepare to setup mm5 with 0:0:ifx:fx
                psrld	mm3, 15				; mm3 has 0:vp[0]:0:vp[3], signed
                packssdw	mm3, mm3		; mm3 = vp[0]:vp[3]:vp[0]:vp[3]
                  mov	ecx, h_loop			; prepare to setup mm4 with h_loop (for shifting)
                movd	mm5, eax			; mm5 = 0:ifx
                  pmaddwd	mm3, mm6		; mm3 = 0:lerp(vp[0], vp[3], fy)
                mov		edx, fx				; prepare to setup mm5 with 0:0:ifx:fx
                  inc	ecx					; ecx = h_loop + 1 (gets rid of a shift by one later)
                movd	mm2, edx			; mm2 = 0:fx
                  psllq	mm5, 16				; mm5 = 0:0:ifx:0
                movd	mm4, ecx			; mm4 = h_loop+1
                  por	mm5, mm2			; mm5 = 0:0:ifx:fx
                inc		ebx					; ebx = ix + 1
                  psrld	mm3, 15				; mm3 = 0:vpp[0]

                ; at this point, the following registers have interesting things contained within:
                ; 
                ; ebx		ix + 1
                ; esi		pValueTab
                ; edi		gPerm
                ; mm3		vpp[0]
                ; mm4		h_loop
                ; mm5		0:0:ifx:fx
                ; mm6		0:0:ify:fy
                ; mm7		ift:ft:ift:ft
                x_calc_loop:
                mov			eax, ytPerm00	; prepare to calc v[1]
                  mov		ecx, ytPerm01	; prepare to calc v[5]
                add			eax, ebx		; eax = ix + 1 + ytPerm00, for v[1]
                  mov		edx, ytPerm10	; prepare to calc v[2]
                add			ecx, ebx		; ecx = ix + 1 + ytPerm01, for v[5]
                  and		eax, TABMASK	; clamp to (0, 255)
                and			ecx, TABMASK	; clamp to (0, 255)
                  add		edx, ebx		; edx = ix + 1 + ytPerm10, for v[2]
                and			edx, TABMASK	; clamp to (0, 255)
                  mov		eax, [edi + 4*eax]	; get hash value from table
                mov			ecx, [edi + 4*ecx]	; get hash value from table
                  mov		edx, [edi + 4*edx]	; get hash value from table (might be a bank conflict)
                mov			eax, [esi + 4*eax]	; eax = v[1]
                  ; movd, below, is U pipe only
                movd		mm0, eax			; mm0 = 0:v[1]
                  ; must pair with mmx instruction
                mov			eax, ytPerm11		; prepare to calc v[6]
                  mov		ecx, [esi + 4*ecx]	; ecx = v[5]
                add			eax, ebx			; eax = ix + 1 + ytPerm11, for v[6]
                  mov		edx, [esi + 4*edx]	; edx = v[2]
                and			eax, TABMASK		; clamp to (0, 255)
                  mov		lastix, ebx			; save off last ix+1 value
                movd		mm1, ecx			; mm1 = 0:v[5]
                  psllq		mm0, 32				; mm0 = v[1]:0
                mov			eax, [edi + 4*eax]	; get hash value from table for v[6]
                  mov		ecx, x				; prepare to calc fx
                movd		mm2, edx			; mm2 = 0:v[2]
                  por		mm0, mm1			; mm0 = v[1]:v[5]
                mov			eax, [esi + 4*eax]	; eax = v[6]
                  and		ecx, 0xffff			; ecx = fx
                movd		mm1, eax			; mm1 = 0:v[6]
                  psllq		mm2, 32				; mm2 = v[2]:0
                shr			ecx, 8				; ecx = upper 8 bits of fx
                  por		mm1, mm2			; mm1 = v[2]:v[6]
                packssdw	mm1, mm0			; mm1 = v[1]:v[5]:v[2]:v[6]
                  lea		edi, gdwSmoothTable	; load edi with pointer to smoothing table
                pmaddwd		mm1, mm7			; mm1 = lerp(v[1], v[5], ft):lerp(v[2], v[6], ft)
                  mov		eax, 0xffff			; prepare eax to get smooth ifx
                mov			ecx, [edi + 4*ecx]	; load up ecx with smooth fx
                  mov		esi, pScan			; load up esi with pointer to scan array
                sub			eax, ecx			; eax = smoothed ifx
                  mov		edx, x_loop			; load up edx with current x_loop
                movd		mm5, eax			; mm5 = 0:ifx
                  psrld		mm1, 15				; mm1 = vp[1]:vp[2]
                movd		mm0, ecx			; mm0 = 0:fx
                  packssdw	mm1, mm1			; mm1 = vp[1]:vp[2]:vp[1]:vp[2]
                pmaddwd		mm1, mm6			; mm1 = 0:lerp(vp[1], vp[2], fy)
                  psllq		mm5, 16				; mm5 = 0:0:ifx:0
                por			mm5, mm0			; mm5 = 0:0:ifx:fx
                  lea		esi, [esi + 4*edx]	; load up esi with pointer to THIS VERY NOISE VALUE LOCATION!
                psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
                  ;
                psrld		mm1, 15				; mm1 = vpp[1]
                  psllq		mm3, 16				; mm3 = 0:0:vpp[0]:0
                por			mm3, mm1			; mm3 = 0:0:vpp[0]:vpp[1]
                ; at this point, the following registers have interesting things contained within:
                ;
                ; ebx		ix + 1
                ; edx		x_loop
                ; esi		pScan + 4*x_loop
                ; edi		gdwSmoothTable
                ; mm1		vpp[1]
                ; mm3		0:0:vpp[0]:vpp[1]
                ; mm4		h_loop
                ; mm5		0:0:ifx:fx
                ; mm6		0:0:ify:fy
                ; mm7		ift:ft:ift:ft
                x_nocalc_loop:
                pmaddwd		mm5, mm3			; mm5 = 0:lerp(vpp[0], vpp[1], fx)
                  mov		eax, [esi]			; eax = old noise value at this location
                mov			ecx, right			; load up the right edge
                  pcmpeqd	mm0, mm0			; load up mm0 with all ones
                psrlq		mm0, 35				; mm0 = 0:0x1fffffff
                  cmp		edx, ecx			; are we quite done yet?
                psubd		mm5, mm0			; mm5 = normalized about 0 noise
                  jge		x_loop_done			; if so, finish & bail
                inc			edx					; edx = x_loop++
                  psrad		mm5, mm4			; 'divide' by # of harmonics
                mov			x_loop, edx			; save off x_loop value
                  mov		ecx, x				; get last x value
                mov			edx, x_inc			; get x increment
                  ;
                add			ecx, edx			; generate new x
                  mov		ebx, ecx			; get copy of new x to calc new ix + 1
                mov			x, ecx				; save off new x
                shr			ebx, 16				; ebx = new ix
                mov		edx, 0xffff			; to calc new ifx, new fx
                and			ecx, edx			; ecx = new fx
                  shr		ecx, 8				; ecx = upper 8 bits new fx
                ; AGI
                mov			ecx, [edi + 4*ecx]	; ecx = smooth fx
                  inc		ebx					; ebx = new ix + 1
                sub			edx, ecx			; edx = new ifx
                  ;
                movd		mm0, edx			; mm0 = 0:0:0:ifx
                  ;
                movd		mm2, ecx			; mm2 = 0:0:0:fx
                  pslld		mm0, 16				; mm0 = 0:0:ifx:0
                movd		edx, mm5			; edx = new noise value to be added
                  por		mm0, mm2			; mm0 = 0:0:ifx:fx
                add			eax, edx			; eax = new noise value
                  movq		mm5, mm0			; mm5 = 0:0:ifx:fx
                mov			[esi], eax			; write out new noise value
                  add		esi, 4				; move pointer one DWORD
                mov			eax, lastix			; get lastix+1
                  mov		edx, x_loop			; get x_loop value back into edx
                cmp			eax, ebx			; does lastix+1 == new ix+1?
                psrlw		mm5, 1				; mm5 = 0:0:ifx:fx, signed
                  je		x_nocalc_loop		; if so, go do this again

                movq		mm1, mm3			; mm3 = new vpp[0] (old vpp[1])
                  mov		esi, pValueTab
                lea			edi, gPerm
                jmp			x_calc_loop
                x_loop_done:
                psrad		mm5, mm4			; 'divide' by # of harmonics
                  ; STALLOLA - should insert the c code below here.
                movd		edx, mm5			; edx = new noise value to be added
                  ;
                add			eax, edx			; eax = new noise value
                  ;
                mov			[esi], eax			; write out last noise value
                } // asm block (and x loop)

                t = t >> 1;
                y = y >> 1;		
                x_base = x_base >> 1;
                x_inc = x_inc >> 1;
            } // harmonics loop


		
		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  ;
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, pDestLine		; get pointer to dest buffer
				and		ebx, 0xff			; finish clamping to (0, 255)
				  mov	ecx, right			; prepare to see if we're done
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  ;
				or		ebx, alphamask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				and		ebx, 0xff			; finish clamping to (0, 255)
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				mov		edi, pDestLine		; get pointer to dest buffer
				  or	ebx, alphamask
				mov		ecx, right			; prepare to see if we're done
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jle		noise_loop_nosrc
			} 
		}
	}

	__asm {
		emms
	}
}

void CDXTAdditive::addsmoothturb8to32mmxmask(int nTime, void *pDest, int nDestPitch, void *pSrc, int nSrcPitch, void *pMask, int nMaskPitch) {
	DWORD x, y, t;
	DWORD iy, it, ytPerm00, ytPerm01, ytPerm10, ytPerm11;
	int y_loop, h_loop, x_loop;
	DWORD x_base, x_inc, chromakey;
	int right, left;
	DWORD *pScan;
	DWORD timexanimatex, timexanimatey, noiseoffset, noisescale;
	DWORD *pValueTab;
	DWORD *pPalette = (DWORD *) m_pPalette;

	unsigned char *pSrcLine;
	DWORD *pDestLine, *pMaskLine;
	DWORD alphamask;

	if (m_alphaActive == 1) 
		alphamask = 0x80000000;
	else 
		alphamask = 0xff000000;

	nDestPitch /= 4;
	nMaskPitch /= 4;
	nTime = nTime & 0xffff;		// keep things as expected...

	timexanimatex = nTime * m_nTimeAnimateX;
	timexanimatey = nTime * m_nTimeAnimateY;

	left = m_rActiveRect.left;
	right = m_rActiveRect.right;

	noiseoffset = m_nNoiseOffset;
	noisescale = m_nNoiseScale - 1;
	pValueTab = m_valueTab;
	pScan = m_pdwScanArray;
	chromakey = m_ColorKey;

	for (y_loop = m_rActiveRect.top; y_loop < m_rActiveRect.bottom; y_loop++) {
		t = (nTime) << 16;
		t = t >> m_nScaleTime;

		y = y_loop + timexanimatey;
		y = (y & 0xffff) << 16;
		y = y >> m_nScaleY;

		
		x_base = ((left + timexanimatex)& 0xffff) << 16;
		x_base = x_base >> m_nScaleX;

		x_inc = (1 << 16) >> m_nScaleX;

		for (h_loop = m_nHarmonics - 1; h_loop >= 0; h_loop--) {
			x_loop = m_rActiveRect.left;
			x = x_base;

			iy = y >> 16;
			it = t >> 16;

			ytPerm00 = PERM(iy+0 + PERM(it+0));
			ytPerm01 = PERM(iy+0 + PERM(it+1));
			ytPerm10 = PERM(iy+1 + PERM(it+0));
			ytPerm11 = PERM(iy+1 + PERM(it+1));

			__asm {
				lea		ecx, gdwSmoothTable	; get the smoothstep table
				  mov	eax, t			; prepare to get ft
				mov		esi, ecx		; load table pointer into esi
				  and	eax, 0xffff		; eax = ft
				shr		eax, 8			; eax = upper 8 bits of ft
				  mov	edx, 0xffff		; prepare to get ift
				mov		ebx, y			; prepare to get fy
				  mov	ecx, 0xffff		; prepare to get ify
				mov		eax, [esi + 4*eax]	; eax = smoothstep ft
				  and	ebx, 0xffff		; ebx = fy
				sub		edx, eax		; edx = ift
				  shr	ebx, 8			; ebx = upper 8 bits of fy
				movd	mm7, edx		; mm7 = 0:0:0:ift
				  ; must pair with an mmx instruction
				movd	mm4, eax		; mm4 = 0:0:0:ft
				  psllq	mm7, 32			; mm7 = 0:ift:0:0
				mov		ebx, [esi + 4*ebx] ; ebx = smoothstep fy
				  por	mm7, mm4		; mm7 = 0:ift:0:ft
				sub		ecx, ebx		; ecx = ify
				  psrld	mm7, 1			; mm7 = 0:ift:0:ft, signed (but positive)
				movd	mm6, ecx		; mm6 = 0:0:0:ify
				  packssdw mm7, mm7		; mm7 = ift:ft:ift:ft
				movd	mm4, ebx		; mm4 = 0:0:0:fy
				  psllq	mm6, 32			; mm6 = 0:ify:0:0
				mov		ebx, x			; prepare to get ix
				  por	mm6, mm4		; mm6 = 0:ify:0:fy
				shr		ebx, 16			; ebx = ix
				  psrld mm6, 1			; mm6 = 0:ify:0:fy, signed (but positive)
				packssdw mm6, mm6		; mm6 = ify:fy:ify:fy
				  
			 	x_loop_start:
					; assumed:
					; 		ebx = ix 
					;		mm6 = fy:ify:fy:ify 
					;		mm7 = ft:ift:ft:ift
					lea		eax, gPerm
					  mov	edx, pValueTab
					mov		esi, eax
					  mov	edi, edx
					mov		eax, ytPerm00
					  mov	ecx, ytPerm01
					add		eax, ebx		; eax = ix + ytPerm00, for v[0]
					  add	ecx, ebx		; ecx = ix + ytPerm01, for v[4]
					mov		edx, eax		; edx = ix + ytPerm00, for v[1]
					  and	eax, TABMASK	; still generating v[0]
					inc		edx				; edx = ix + 1 + ytPerm00, for v[1]
					  and	ecx, TABMASK	; still generating v[4]
					and		edx, TABMASK	; still generating v[1]
					  mov	eax, [esi+4*eax] ; eax = PERM(ix + PERM(iy + PERM(it)))
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix + PERM(iy + PERM(it+1)))
					  ; AGI on edx
					mov		edx, [esi+4*edx] ; edx = PERM(ix+1 + PERM(iy + PERM(it)))
					  mov	eax, [edi+4*eax] ; eax = v[0]
					mov		ecx, [edi+4*ecx] ; ecx = v[4]
					  ; movd, below, must be in the u pipe
					movd	mm0, eax		; mm0 = 0:0:0:v[0]
					  ; must pair with an mmx instruction
					movd	mm1, ecx		; mm1 = 0:0:0:v[4]
					  psllq	mm0, 48			; mm0 = v[0]:0:0:0
					mov		edx, [edi+4*edx] ; edx = v[1]
					  mov	eax, ytPerm10	; for v[3]
					movd	mm4, edx		; mm4 = 0:0:0:v[1]
					  psllq	mm1, 32			; mm1 = 0:v[4]:0:0
					add		eax, ebx		; eax = ix + ytPerm10, for v[3]
					  mov	ecx, ytPerm11	; for v[7]
					mov		edx, eax		; edx = ix + ytPerm10, for v[2]
					  and	eax, TABMASK	; still generating v[3]
					add		ecx, ebx		; ecx = ix + ytPerm11, for v[7]
					and		ecx, TABMASK	; still generating v[7]
					  inc	edx				; edx = ix + 1 + ytPerm10, for v[2]
					and		edx, TABMASK	; still generating v[2]
					por		mm0, mm1		; mm0 = v[0]:v[4]:0:0
					  mov	eax, [esi+4*eax] ; eax = PERM(ix + PERM(iy+1 + PERM(it))), for v[3]
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix + PERM(iy+1 + PERM(it+1))), for v[7]
					  mov	edx, [esi+4*edx] ; edx = PERM(ix+1 + PERM(iy+1 + PERM(it))), for v[2]
					mov		eax, [edi+4*eax] ; eax = v[3]
					  psllq mm4, 48			; mm4 = v[1]:0:0:0
					movd	mm1, eax		; mm1 = 0:0:0:v[3]
					  ; must pair with mmx instruction
					mov		ecx, [edi+4*ecx] ; ecx = v[7]
					  mov	edx, [edi+4*edx] ; edx = v[2]
					movd	mm2, ecx		; mm2 = 0:0:0:v[7]
					  psllq mm1, 16			; mm1 = 0:0:v[3]:0
					movd	mm3, edx		; mm3 = 0:0:0:v[2]
					  por	mm0, mm1		; mm0 = v[0]:v[4]:v[3]:0
					mov		eax, ytPerm01	; for v[5]
					  mov	ecx, ytPerm11	; for v[6]
					add		eax, ebx		; eax = ix + ytPerm01, for v[5]
					  inc	ebx				; ebx = ix + 1
					add		ecx, ebx		; ecx = ix + 1 + ytPerm11, for v[6]
					  inc	eax				; eax = ix + 1 + ytPerm01, for v[5]
					and		ecx, TABMASK	; still generating v[6]
					  and	eax, TABMASK	; still generating v[5]
					por		mm0, mm2		; mm0 = v[0]:v[4]:v[3]:v[7]
					  psllq	mm3, 16			; mm3 = 0:0:v[2]:0
					mov		ecx, [esi+4*ecx] ; ecx = PERM(ix+1 + PERM(iy+1 + PERM(it+1)))
					  mov	eax, [esi+4*eax] ; eax = PERM(ix+1 + PERM(iy + PERM(it+1)))
					pmaddwd mm0, mm7		; mm0 = smooth(v[0], v[4], ft):smooth(v[3], v[7], ft)
					  mov	edx, x			; get the current prescaled x
					mov		eax, [edi+4*eax] ; eax = v[5]
					  mov	ecx, [edi+4*ecx] ; ecx = v[6]
					movd	mm1, eax		; mm1 = 0:0:0:v[5]
					  por	mm4, mm3		; mm4 = v[1]:0:v[2]:0
					movd	mm2, ecx		; mm2 = 0:0:0:v[6]
					  psllq	mm1, 32			; mm1 = 0:v[5]:0:0
					psrld	mm0, 15			; mm0 has 0:vp[0]:0:vp[3], signed
					  por	mm4, mm1		; mm4 = v[1]:v[5]:v[2]:0
					por		mm4, mm2		; mm4 = v[1]:v[5]:v[2]:v[6]
					  mov	ebx, edx		; ebx = x
					pmaddwd	mm4, mm7		; mm4 = smooth(v[1], v[5], ft):smooth(v[2], v[6], ft)
					  lea	esi, gdwSmoothTable
					mov		eax, 0xffff		; prepare eax to get ifx
					  and	edx, 0xffff		; edx = fx
					shr		edx, 8			; edx = upper 8 bits fx
					  mov	ecx, x_inc		; prepare to calculate new x
					add		ebx, ecx		; ebx = new x, prescaled
					  ; AGI
					mov		edx, [esi + 4*edx] ; edx = smoothstep fx
					  ; register dependency
					sub	eax, edx			; eax = ifx
					  ; movd must be in U pipe
					movd	mm5, edx		; mm5 = 0:0:0:fx
					  psrld	mm4, 15			; mm4 = 0:vp[1]:0:vp[2]
					movd	mm3, eax		; mm3 = 0:0:0:ifx
					  packssdw mm4, mm0		; mm0 = vp[0]:vp[3]:vp[1]:vp[2]
					pmaddwd	mm4, mm6		; mm4 = smooth(vp[0], vp[3], fy):smooth(vp[1],vp[2], fy)
					  psllq	mm3, 16			; mm3 = 0:0:ifx:0
					por		mm5, mm3		; mm5 = 0:0:ifx:fx
					  mov	eax, pScan		; get the base address of the scanline noise array
					psrlw	mm5, 1			; mm5 = 0:0:ifx:fx, signed 
					psrld	mm4, 15			; mm4 = 0:vpp[0]:0:vpp[1]
					  mov	edx, x_loop		; get the scan-line index
					packssdw mm4, mm4		; mm4 = vpp[0]:vpp[1]:vpp[0]:vpp[1]
					  inc	edx				; x_loop++
					pmaddwd	mm4, mm5		; mm4 = 0:smooth(vpp[0], vpp[1], fx)
					  mov	ecx, right		; 
					lea		esi, [eax+4*edx-4]; esi -> scanarray
					  mov	x_loop, edx		; save off new x_loop
					sub		edx, ecx		; if edx == 0, we're done with the loop.. test later
					  mov	ecx, 0x1fffffff	; used to normalize the noise value
					movd	eax, mm4		; eax = new noisevalue
					  ; gotta pair with an mmx instruction
					sub		eax, ecx		; normalize eax around 0
					  mov	ecx, h_loop		; ecx = current harmonic (starting at 0)
					sar		eax, cl			; scale the noise as a function of the harmonic
					  ; shr is an icky instruction
					mov		ecx, [esi]
					  mov	x, ebx			; save off new x 
					add		eax, ecx		; eax = new noisevalue for this pixel
					  shr	ebx, 16			; ebx = new ix
					mov		[esi], eax		; save off new noisevalue
					  test	edx, edx 
					jnz		x_loop_start	; if edx is not zero, x_loop
			} // asm block (and x loop)

			t = t >> 1;
			y = y >> 1;		
			x_base = x_base >> 1;
			x_inc = x_inc >> 1;

		} // harmonics loop


		if (pSrc) {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pSrcLine  = ((unsigned char *)pSrc)  + nSrcPitch *y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				mov		esi, pSrcLine
				  mov	ecx, noisescale
			noise_loop:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		bl, [esi + eax]		; ebx = src pixel index 
				  mov	esi, pPalette		; get pointer to palette table
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		ebx, [esi + 4*ebx]	; ebx = noisy RGBA
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jl		noise_loop
			}
		} else {
			pDestLine = ((DWORD *)pDest) + nDestPitch*y_loop;
			pMaskLine = ((DWORD *)pMask) + nMaskPitch*y_loop;

			__asm {
				mov		eax, left			
				  mov	edi, pScan
				  mov	ecx, noisescale
			noise_loop_nosrc:
				mov		edx, [edi + 4*eax]	; edx = pScan[x_loop]
				  xor	ebx, ebx			; ebx = 0
				mov		ebx, 80				; ebx = src pixel index 
				mov		dword ptr [edi + 4*eax], 0	; zero out scan array here
				  mov	edi, pMaskLine		; get pointer to this scanline of mask pixels
				sar		edx, cl				; scale the noise
				  ; doesn't pair
				mov		ecx, noiseoffset	; get noiseoffset
				  add	edx, ebx			; add noise to the pixel index
				add		edx, ecx			; bias the noise
				  xor	ebx, ebx			; zero out ebx
				sub		ebx, edx			; if (edx < 0) ebx will be positive...
				  inc	eax					; x_loop++
				sar		ebx, 31				; fill ebx with sign bit
				  mov	ecx, 0xff			; prepare to clamp high
				and		ebx, edx			; clamp to zero on low end - ebx now has clamped value
				  sub	ecx, edx			; still clamping high
				sar		ecx, 31				; fill ecx with its sign bit  
				  mov	edx, [edi + 4*eax - 4] ; get value from mask buffer 
				or		ebx, ecx			; ebx = clamped low and high, but upper 24 bits trash
				  mov	edi, edx			; save mask value with alpha info
				and		ebx, 0xff			; finish clamping to (0, 255)
				  and	edx, 0x00ffffff		; use just lower 24 bits
				mov		ecx, chromakey		; get chromakey value
				  or	edi, 0xff000000
				mov		esi, ebx			; save off value
				  ;
				shl		ebx, 8
				  or	ebx, esi
				shl		ebx, 8
				  or	ebx, esi
				
				  xor	esi, esi			; zero out esi
				or		ebx, alphamask
				  cmp	ecx, edx			; generate mask for chromakeying
				adc		esi, 0				; if key != mask, esi might be 1
				  cmp	edx, ecx			; still generating mask
				adc		esi, 0				; if key != mask, esi is now 1
				  mov	ecx, right			; prepare to see if we're done
				dec		esi					; if key == mask, esi = 0xffffffff, else 0
				  mov	edx, edi			; get back mask with alpha
				and		ebx, esi			; if key == mask, ebx = noisy RGBA else 0
				  not	esi					; uhhhhhh...
				and		edx, esi			; if key != mask, edx = mask else 0
				  mov	edi, pDestLine		; get pointer to dest buffer
				or		ebx, edx			; ebx = noisy RGBA or mask
				  cmp	eax, ecx			; we done yet?
				mov		[edi + 4*eax - 4], ebx	; write out the pixel
				  mov	edi, pScan			; get pointers back
				mov		esi, pSrcLine		; still getting them back
				  mov	ecx, noisescale		; and more setup for beginning of this loop
				jl		noise_loop_nosrc
			}
		}
	}

	__asm {
		emms
	}
}


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_Harmonics, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_Harmonics(int * pnHarmonics)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnHarmonics != NULL) 
    {
        *pnHarmonics = m_nHarmonics;

        return S_OK;
    }

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_Harmonics, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_Harmonics, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_Harmonics(int nHarmonics)
{ 
    DXAUTO_OBJ_LOCK;

    if (nHarmonics < 1) 
    {
        return E_INVALIDARG;
    }

    if ((nHarmonics != 1)
        && (m_dwFunctionType != PROCTEX_LATTICETURBULENCE_SMOOTHSTEP)
        && (m_dwFunctionType != PROCTEX_LATTICETURBULENCE_LERP)) 
    {
        m_nHarmonics = 1;

        return E_INVALIDARG;
    }

    m_nHarmonics = nHarmonics;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_Harmonics, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_NoiseScale, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_NoiseScale(int * pnNoiseScale)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnNoiseScale != NULL) 
    {
        *pnNoiseScale = (32 - m_nNoiseScale);

        return S_OK;
    } 

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_NoiseScale, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_NoiseScale, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_NoiseScale(int nNoiseScale)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nNoiseScale > 32) || (nNoiseScale < 0)) 
    {
        return E_INVALIDARG;
    }

    m_nNoiseScale = (32 - nNoiseScale);

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_NoiseScale, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_NoiseOffset, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_NoiseOffset(int * pnNoiseOffset)
{ 
    DXAUTO_OBJ_LOCK;

    if (pnNoiseOffset != NULL) 
    {
        *pnNoiseOffset = m_nNoiseOffset;

        return S_OK;
    }

    return E_INVALIDARG;
}
//  Method:  CDXTAdditive::get_NoiseOffset, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_NoiseOffset, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_NoiseOffset(int nNoiseOffset)
{ 
    DXAUTO_OBJ_LOCK;

    m_nNoiseOffset = nNoiseOffset;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_NoiseOffset, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_TimeX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_TimeX(int * pnTimeX)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnTimeX)
    {
        return E_POINTER;
    }

    *pnTimeX = m_nTimeAnimateX;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_TimeX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_TimeX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_TimeX(int nTimeX)
{ 
    DXAUTO_OBJ_LOCK;

    m_nTimeAnimateX = nTimeX;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_TimeX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_TimeY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_TimeY(int * pnTimeY)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnTimeY)
    {
        return E_POINTER;
    }

    *pnTimeY = m_nTimeAnimateY;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_TimeY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_TimeY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_TimeY(int nTimeY)
{ 
    DXAUTO_OBJ_LOCK;

    m_nTimeAnimateY = nTimeY;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_TimeY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleX(int * pnScaleX)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleX)
    {
        return E_POINTER;
    }

    *pnScaleX = m_nScaleX;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleX, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleX(int nScaleX)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleX < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleX = nScaleX;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleX, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleY(int * pnScaleY)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleY)
    {
        return E_POINTER;
    }

    *pnScaleY = m_nScaleY;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleY, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleY(int nScaleY)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleY < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleY = nScaleY;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleY, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ScaleT, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ScaleT(int * pnScaleT)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnScaleT)
    {
        return E_POINTER;
    }

    *pnScaleT = m_nScaleTime;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_ScaleT, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ScaleT, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ScaleT(int nScaleT)
{ 
    DXAUTO_OBJ_LOCK;

    if (nScaleT < 0)
    {
        return E_INVALIDARG;
    }

    m_nScaleTime = nScaleT;

    SetDirty();

    return S_OK; 
}
//  Method:  CDXTAdditive::put_ScaleT, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_Alpha, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_Alpha(int * pnAlpha)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnAlpha) 
    {
        return E_INVALIDARG;
    }

    *pnAlpha = m_alphaActive;

    return S_OK;
}
//  Method:  CDXTAdditive::get_Alpha, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_Alpha, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_Alpha(int nAlpha)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nAlpha < 0) || (nAlpha > 1))
    {
        return E_INVALIDARG;
    }

    m_alphaActive = nAlpha;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_Alpha, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_ColorKey, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_ColorKey(int * pnColorKey)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnColorKey) 
    {
        return E_INVALIDARG;
    }

    *pnColorKey = m_ColorKey;

    return S_OK;
}
//  Method:  CDXTAdditive::get_ColorKey, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_ColorKey, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_ColorKey(int nColorKey)
{ 
    DXAUTO_OBJ_LOCK;

    m_ColorKey = nColorKey;

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_ColorKey, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_MaskMode, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_MaskMode(int * pnMaskMode)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnMaskMode) 
    {
        return E_INVALIDARG;
    }

    *pnMaskMode = m_MaskMode;

    return S_OK;
}
//  Method:  CDXTAdditive::get_MaskMode, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_MaskMode, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_MaskMode(int nMaskMode)
{ 
    DXAUTO_OBJ_LOCK;

    if ((nMaskMode < 0) || (nMaskMode > 1))
    {
        return E_INVALIDARG;
    }

    m_MaskMode = nMaskMode;

    // TODO:  there used to be a specific copy function to do the masking,
    // this will need to be done some other way.

    // setCopyFunction();

    SetDirty();

    return S_OK;
}
//  Method:  CDXTAdditive::put_MaskMode, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_GenerateSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_GenerateSeed(int * pnSeed)
{ 
    DXAUTO_OBJ_LOCK;

    if (NULL == pnSeed)
    {
        return E_POINTER;
    }

    *pnSeed = m_GenerateSeed;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_GenerateSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_GenerateSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_GenerateSeed(int nSeed)
{ 
    DXAUTO_OBJ_LOCK;

    HRESULT hr      = S_OK;
    int     i       = 0;
    DWORD * pdwPal  = NULL;

    if ((nSeed < 0) || (nSeed > 3))
    {
        hr = E_INVALIDARG;

        goto done;
    }

    pdwPal = new DWORD[256];

    if (NULL == pdwPal)
    {
        hr = E_OUTOFMEMORY;

        goto done;
    }

    switch (nSeed)
    {
        case 0:

            // No auto effect.
            // TODO:  Will this cause a NULL pointer access?

            break;

        case 1:

            // Flame (black red yellow white blue.)

            m_nNoiseOffset  = -45;
            m_nNoiseScale   = 7;
            m_nHarmonics    = 3;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 2;
            m_nTimeAnimateX = 0;
            m_nTimeAnimateY = 1;

            // Set palette.

            for(i = 0 ; i < 64 ; i++) 
            {
                pdwPal[i]       = (i*4) << 16;
                pdwPal[i+64]    = 0x00ff0000 | ((i*4) << 8);
                pdwPal[i+128]   = 0x00ffff00 | (i*4);
                pdwPal[i+192]   = 0x000000ff | ((255 - i*1) << 16) | ((255 - i*1) << 8);
            }

            break;

        case 2:

            // Water (blue white.)

            m_nNoiseOffset  = 0;
            m_nNoiseScale   = 11;
            m_nHarmonics    = 5;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 1;
            m_nTimeAnimateX = 1;
            m_nTimeAnimateY = 1;

            // Set water palette.

            for(i =0 ; i < 64 ; i++) 
            {
                pdwPal[i]     = 0x000000ff | ((i*4) << 16) | ((i*4) << 8);
                pdwPal[i+64]  = 0x000000ff | (((63-i)*4) << 16) | (((63-i)*4) << 8);
                pdwPal[i+128] = 0x000000ff | ((i*4) << 16) | ((i*4) << 8);
                pdwPal[i+192] = 0x000000ff | (((63-i)*4) << 16) | (((63-i)*4) << 8);
            }

            break;

        case 3:

            // Clouds (blue white gray.)

            m_nNoiseOffset  = 0;
            m_nNoiseScale   = 0;
            m_nHarmonics    = 7;
            m_nScaleX       = 1;
            m_nScaleY       = 1;
            m_nScaleTime    = 2;
            m_nTimeAnimateX = 1;
            m_nTimeAnimateY = 0;

            // Set clouds palette.

            for(i = 0; i < 128 ; i++) 
            {
                pdwPal[i]     = 0x000000ff | ((i*2) << 16) | ((i*2) << 8);
                pdwPal[i+128] = ((255 - i) << 16) | ((255 - i) << 8) | (255 - i);
            }

        break;
    } // switch (nSeed)

    delete [] m_pInitialBuffer;
    delete [] m_pPalette;

    m_pInitialBuffer    = NULL;
    m_pPalette          = (void *)pdwPal;
    m_GenerateSeed      = nSeed;

    SetDirty();

done:

    if (FAILED(hr) && pdwPal)
    {
        delete [] pdwPal;
    }

    return hr; 
}
//  Method:  CDXTAdditive::put_GenerateSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::get_BitmapSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::get_BitmapSeed(BSTR * pbstrBitmapSeed)
{ 
    DXAUTO_OBJ_LOCK;

    return S_OK; 
}
//  Method:  CDXTAdditive::get_BitmapSeed, IDispAdditive


//+-----------------------------------------------------------------------------
//
//  Method:  CDXTAdditive::put_BitmapSeed, IDispAdditive
//
//------------------------------------------------------------------------------
STDMETHODIMP 
CDXTAdditive::put_BitmapSeed(BSTR bstrBitmapSeed)
{ 
    DXAUTO_OBJ_LOCK;

    HRESULT     hr              = S_OK;
    WCHAR       strURL[2048]    = L"";
    WCHAR *     pchBitmapSeed   = (WCHAR *)bstrBitmapSeed;
    DWORD       cchURL          = 2048;
    LONG        lFileSize       = 0;
    IUnknown *  pUnk            = GetControllingUnknown();
    BOOL        fAllow          = FALSE;

    CURLArchive urlArchive(pUnk);

    CComPtr<IServiceProvider>   spServiceProvider;
    CComPtr<ISecureUrlHost>     spSecureUrlHost;

    // If we're being hosted by a web page, allow relative URLs.

    if (m_bstrHostUrl)
    {
        HRESULT hrNonBlocking = ::UrlCombine(m_bstrHostUrl, bstrBitmapSeed, 
                                             strURL, &cchURL, URL_UNESCAPE );

        if (SUCCEEDED(hrNonBlocking))
        {
            pchBitmapSeed = strURL;
        }
    }

    hr = GetSite(__uuidof(IServiceProvider), (void **)&spServiceProvider);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spServiceProvider->QueryService(__uuidof(IElementBehaviorSite),
                                         __uuidof(ISecureUrlHost),
                                         (void **)&spSecureUrlHost);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = spSecureUrlHost->ValidateSecureUrl(&fAllow, pchBitmapSeed, 0);

    if (FAILED(hr))
    {
        goto done;
    }
    else if (!fAllow)
    {
        hr = E_FAIL;
        goto done;
    }
      
    hr = urlArchive.Create(pchBitmapSeed);

    if (FAILED(hr))
    {
        goto done;
    }

    hr = urlArchive.GetFileSize(lFileSize);

    if (FAILED(hr))
    {
        goto done;
    }

    BITMAPFILEHEADER bmfh;
    BITMAPINFOHEADER bmih;
    int i;
    RGBQUAD *pRGBQuad;
    DWORD dwColor;
    DWORD *pdwPalette;
    DWORD dwBytesRead;

    dwBytesRead = urlArchive.Read((unsigned char *)&bmfh, 
                                  sizeof(BITMAPFILEHEADER)); 

    if (dwBytesRead == sizeof(BITMAPFILEHEADER))
    {
        dwBytesRead = urlArchive.Read((unsigned char *)&bmih, 
                                      sizeof(BITMAPINFOHEADER)); 

        if (dwBytesRead == sizeof(BITMAPINFOHEADER))
        {
            BOOL bFlip = TRUE;

            if (bmih.biBitCount != 8) 
            {
                urlArchive.Close();
                hr = E_FAIL;

                goto done;
            }

            if (bmih.biCompression != BI_RGB) 
            {
                urlArchive.Close();
                hr = E_FAIL;

                goto done;
            } 


            if (bmih.biHeight < 0)
            {
                bFlip = FALSE;
                bmih.biHeight = -bmih.biHeight;
            }

            delete [] m_pPalette;

            m_pPalette = new unsigned char[sizeof(RGBQUAD) * 256];

            if (NULL == m_pPalette) 
            {
                urlArchive.Close();
                hr = E_OUTOFMEMORY;

                goto done;
            }

            dwBytesRead = urlArchive.Read((unsigned char *)m_pPalette, 
                                          sizeof(RGBQUAD) * 256 ); 

            if(dwBytesRead == sizeof(RGBQUAD) * 256)
            {
                pRGBQuad = (RGBQUAD *) m_pPalette;
                pdwPalette = (DWORD *) m_pPalette;

                for (i = 0 ; i < 256 ; i++) 
                {
                    dwColor = ((pRGBQuad->rgbRed) << 16) | ((pRGBQuad->rgbGreen) << 8) | (pRGBQuad->rgbBlue);
                    *pdwPalette = dwColor;
                    pdwPalette++;
                    pRGBQuad++;
                }
                
                // Allocate the source buffer for procedural texture mapping, 
                // and load the image data into it.

                delete [] m_pInitialBuffer;

                m_pInitialBuffer = new unsigned char[sizeof(unsigned char) * bmih.biHeight * bmih.biWidth];

                if (NULL == m_pInitialBuffer) 
                {
                    urlArchive.Close();
                    delete [] m_pPalette;
                    m_pPalette  = NULL;
                    hr          = E_OUTOFMEMORY;

                    goto done;
                }

                m_nSrcWidth     = bmih.biWidth;
                m_nSrcHeight    = bmih.biHeight;
                m_nSrcBPP       = 8;

                if ((bmih.biWidth % 4) != 0) 
                {
                    unsigned char aJunk[3];

                    dwBytesRead = 0;

                    for (i = 0 ; i < bmih.biHeight ; i++) 
                    {
                        dwBytesRead += urlArchive.Read(((unsigned char *)m_pInitialBuffer) + bmih.biWidth*i, 
                                                       sizeof(unsigned char) * bmih.biWidth); 
                        urlArchive.Read(aJunk, 4 - bmih.biWidth % 4);
                    }

                } 
                else 
                {
                    dwBytesRead = urlArchive.Read((unsigned char *)m_pInitialBuffer, 
                                                  sizeof(unsigned char) * bmih.biHeight * bmih.biWidth); 
                }

                if (dwBytesRead == sizeof(unsigned char) * bmih.biHeight * bmih.biWidth)
                {
                    if (bFlip)
                    {
                        unsigned char * temp1;
                        unsigned char * temp2;
                        unsigned char * save;

                        save = new unsigned char[m_nSrcWidth];

                        if (save) 
                        {
                            temp1 = m_pInitialBuffer + m_nSrcWidth*(m_nSrcHeight-1);
                            temp2 = m_pInitialBuffer;

                            for(int i = 0 ; i < (m_nSrcHeight) >> 1 ; i++)
                            {
                                memcpy(save, temp1, m_nSrcWidth);
                                memcpy(temp1, temp2, m_nSrcWidth);
                                memcpy(temp2, save, m_nSrcWidth);
                                temp1 -= m_nSrcWidth;
                                temp2 += m_nSrcWidth;
                            }
                        }

                        delete [] save;
                    }
                }
            }
        }
    } 

    urlArchive.Close();

    m_GenerateSeed = 0;

    SetDirty();

done:

    return hr; 
}
//  Method:  CDXTAdditive::put_BitmapSeed, IDispAdditive


#ifdef _DEBUG

void showme2(IDirectDrawSurface * surf, RECT * prc)
{
    HRESULT hr      = S_OK;
    HDC     srcDC;
    HDC     destDC  = GetDC(NULL);
    RECT    dr;
    RECT    sr;
    RECT    rcFrame;

    HBRUSH          hbrRed;
    HBRUSH          hbrGreen;
    LOGBRUSH        logbrush;
    DDSURFACEDESC   ddsd;

    hr = surf->GetDC(&srcDC);

    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;

    hr = surf->GetSurfaceDesc(&ddsd);

    SetRect(&sr, 0, 0, ddsd.dwWidth, ddsd.dwHeight);
    SetRect(&dr, 1, 1, ddsd.dwWidth + 1, ddsd.dwHeight + 1);
    SetRect(&rcFrame, 0, 0, ddsd.dwWidth + 2, ddsd.dwHeight + 2);
    
    StretchBlt(destDC,
               dr.left,
               dr.top,
               dr.right - dr.left,
               dr.bottom - dr.top,
               srcDC,
               sr.left,
               sr.top,
               sr.right - sr.left,
               sr.bottom - sr.top,
               SRCCOPY);

    logbrush.lbStyle    = BS_SOLID;
    logbrush.lbColor    = 0x000000FF;   // Red

    hbrRed = CreateBrushIndirect(&logbrush);

    logbrush.lbColor    = 0x0000FF00;   // Green

    hbrGreen = CreateBrushIndirect(&logbrush);

    FrameRect(destDC, &rcFrame, hbrRed);

    if (prc != NULL)
    {
        RECT    rcBounds = *prc;

        rcBounds.right += 2;
        rcBounds.bottom += 2;

        FrameRect(destDC, &rcBounds, hbrGreen);
    }

    hr = surf->ReleaseDC(srcDC);
    
    DeleteObject(hbrRed);
    DeleteObject(hbrGreen);
    ReleaseDC(NULL, destDC);    
}


void * showme(IUnknown * pUnk)
{
    HRESULT hr = S_OK;
    //RECT    rc;

    CComPtr<IDirectDrawSurface> spDDSurf;
    CComPtr<IDXSurface>         spDXSurf;

    if (NULL == pUnk)
    {
        goto done;
    }

    hr = pUnk->QueryInterface(IID_IDirectDrawSurface, (void **)&spDDSurf);

    if (FAILED(hr))
    {
        hr = pUnk->QueryInterface(IID_IDXSurface, (void **)&spDXSurf);

        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDXSurf->GetDirectDrawSurface(IID_IDirectDrawSurface,
                                            (void **)&spDDSurf);

        if (FAILED(hr))
        {
            goto done;
        }
    }

    /*
    if (pbnds)
    {
        pbnds->GetXYRect(rc);
    }
    */

    showme2(spDDSurf, NULL);

done:

    return pUnk;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\tables.cpp ===
/*
//   TABLES.CPP
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//
//      Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  PVCS:
//      $Workfile$
//      $Revision$
//      $Modtime$
//
//  PURPOSE:
//		this file contains global tables read by everyone, modified by none.                                  
//              
//
//  CONTENTS:
*/
#include "stdafx.h"
//#include "tables.h"
//#include <windows.h>
#include "defines.h"

DWORD gdwSmoothTable[256] = {
	    0,     2,    11,    26,    47,    74,   106,   144,   188,   237,   292,   352,   418,   489,   566,   648,
	  736,   828,   926,  1029,  1137,  1250,  1368,  1491,  1620,  1752,  1890,  2033,  2180,  2332,  2489,  2650,
	 2816,  2986,  3160,  3340,  3523,  3711,  3903,  4099,  4300,  4504,  4713,  4925,  5142,  5363,  5587,  5815,
	 6048,  6283,  6523,  6766,  7013,  7263,  7517,  7775,  8036,  8300,  8567,  8838,  9112,  9389,  9670,  9953,
	10240, 10529, 10821, 11117, 11415, 11716, 12020, 12326, 12636, 12947, 13262, 13579, 13898, 14220, 14544, 14871,
	15200, 15531, 15864, 16199, 16537, 16877, 17218, 17562, 17908, 18255, 18604, 18955, 19308, 19662, 20019, 20376,
	20736, 21096, 21458, 21822, 22187, 22553, 22921, 23290, 23660, 24031, 24403, 24776, 25150, 25525, 25901, 26278,
	26656, 27034, 27413, 27793, 28173, 28554, 28935, 29317, 29700, 30082, 30465, 30848, 31232, 31616, 32000, 32384,
	32768, 33151, 33535, 33919, 34303, 34687, 35070, 35453, 35836, 36218, 36600, 36981, 37362, 37742, 38122, 38501,
	38880, 39257, 39634, 40010, 40385, 40759, 41132, 41504, 41876, 42245, 42614, 42982, 43348, 43713, 44077, 44439,
	44800, 45159, 45516, 45873, 46227, 46580, 46931, 47280, 47628, 47973, 48317, 48658, 48998, 49336, 49671, 50004,
	50336, 50664, 50991, 51315, 51637, 51956, 52273, 52588, 52900, 53209, 53515, 53819, 54120, 54418, 54714, 55006,
	55296, 55582, 55865, 56146, 56423, 56697, 56968, 57235, 57500, 57760, 58018, 58272, 58522, 58769, 59012, 59252,
	59488, 59720, 59948, 60172, 60393, 60610, 60822, 61031, 61236, 61436, 61632, 61824, 62012, 62195, 62375, 62549,
	62720, 62885, 63046, 63203, 63355, 63502, 63645, 63783, 63916, 64044, 64167, 64285, 64398, 64506, 64609, 64707,
	64800, 64887, 64969, 65046, 65117, 65183, 65243, 65298, 65348, 65391, 65429, 65461, 65488, 65509, 65524, 65533};

DWORD gPerm[TABSIZE] = {
        225,155,210,108,175,199,221,144,203,116, 70,213, 69,158, 33,252,
          5, 82,173,133,222,139,174, 27,  9, 71, 90,246, 75,130, 91,191,
        169,138,  2,151,194,235, 81,  7, 25,113,228,159,205,253,134,142,
        248, 65,224,217, 22,121,229, 63, 89,103, 96,104,156, 17,201,129,
         36,  8,165,110,237,117,231, 56,132,211,152, 20,181,111,239,218,
        170,163, 51,172,157, 47, 80,212,176,250, 87, 49, 99,242,136,189,
        162,115, 44, 43,124, 94,150, 16,141,247, 32, 10,198,223,255, 72,
         53,131, 84, 57,220,197, 58, 50,208, 11,241, 28,  3,192, 62,202,
         18,215,153, 24, 76, 41, 15,179, 39, 46, 55,  6,128,167, 23,188,
        106, 34,187,140,164, 73,112,182,244,195,227, 13, 35, 77,196,185,
         26,200,226,119, 31,123,168,125,249, 68,183,230,177,135,160,180,
         12,  1,243,148,102,166, 38,238,251, 37,240,126, 64, 74,161, 40,
        184,149,171,178,101, 66, 29, 59,146, 61,254,107, 42, 86,154,  4,
        236,232,120, 21,233,209, 45, 98,193,114, 78, 19,206, 14,118,127,
         48, 79,147, 85, 30,207,219, 54, 88,234,190,122, 95, 67,143,109,
        137,214,145, 93, 92,100,245,  0,216,186, 60, 83,105, 97,204, 52
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\urlarchv.h ===
#ifndef _INC_URLARCHV_H
#define _INC_URLARCHV_H

#ifndef __urlmon_h__
  #include <urlmon.h>
#endif // __urlmon_h__

#ifndef EXPORT
  #define EXPORT __declspec( dllexport )
#endif // EXPORT

// -----------------------------
    
class CURLArchive
{
public:
    enum origin { start   = STREAM_SEEK_SET,
                  current = STREAM_SEEK_CUR,
                  end     = STREAM_SEEK_END };

public:
    EXPORT CURLArchive( IUnknown * pUnk = NULL );
    EXPORT virtual ~CURLArchive();

        // Opens or creates the file szURL
    EXPORT virtual HRESULT Create( LPCSTR szURL );

    EXPORT virtual HRESULT Create( LPCWSTR szwURL );    

        // Closes the file
    EXPORT virtual HRESULT Close( );

    EXPORT virtual HRESULT GetFileSize( long & lSize );

        // For folks that just can't resist...
    EXPORT virtual IStream * GetStreamInterface( void ) const;

        // Reads bytes from the file.
        // 
    EXPORT virtual DWORD     Read( LPBYTE lpb,
                                   DWORD    ctBytes );

    EXPORT virtual DWORD     ReadLine( LPSTR lpstr,
                                       DWORD ctBytes );

    EXPORT virtual DWORD     ReadLine( LPWSTR lpstrw,
                                       DWORD  ctChars );

    EXPORT virtual long    Seek( long ctBytes, origin orig );

        // Writes bytes to the file.
        //
    EXPORT virtual DWORD     Write( LPBYTE lpb,
                           DWORD ctBytes );    

        // Make a local copy of the file
    EXPORT virtual HRESULT CopyLocal( LPSTR szLocalFile, int ctChars );
    EXPORT virtual HRESULT CopyLocal( LPWSTR szwLocalFile, int ctChars );    

private:
    CURLArchive( const CURLArchive & );
    CURLArchive & operator=( const CURLArchive & );

private:    
    IStream *   m_pStream;
    IUnknown *  m_pUnk;
};

#endif // _INC_URLARCHV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\urlarchv.cpp ===
#include "stdafx.h"
#include <windows.h>
#include <stdlib.h>
#include <minmax.h>

#include "urlarchv.h"

#define MAX_URL  2060

#ifndef ARRAYDIM
  #define ARRAYDIM(a)   (sizeof(a) / sizeof(a[0]))
#endif // ARRAYDIM

#ifndef LOOPFOREVER
  #define LOOPFOREVER  for(;;)
#endif // LOOPFOREVER


// --------------------------------


EXPORT CURLArchive::CURLArchive( IUnknown * pUnk ) :
    m_pStream(NULL), m_pUnk(pUnk)
{
    if (m_pUnk)
    	m_pUnk->AddRef();
}


    // These are private methods; 
    // no one, even CURLArchive, should be calling them
CURLArchive::CURLArchive( const CURLArchive & )
{ NULL; }


CURLArchive & CURLArchive::operator=( const CURLArchive & )
{ return *this; }


EXPORT CURLArchive::~CURLArchive()
{
    Close( );
    if( m_pUnk )
        m_pUnk->Release();
}


EXPORT HRESULT CURLArchive::Close( )
{    
    if( m_pStream )
    {
        m_pStream->Release( );
        m_pStream = NULL;
    }
    return S_OK;
}


        
EXPORT HRESULT CURLArchive::CopyLocal( LPSTR szLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::CopyLocal( LPWSTR szwLocalFile, int ctChars )
{
    return E_NOTIMPL;
}



EXPORT HRESULT CURLArchive::Create( LPCSTR szURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamA( m_pUnk,
        szURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}


EXPORT HRESULT CURLArchive::Create( LPCWSTR szwURL )
{
    HRESULT  hr = E_FAIL;

    if( m_pStream )
        return E_ACCESSDENIED;

    if( !szwURL )
        return E_INVALIDARG;

    hr = URLOpenBlockingStreamW( m_pUnk,
        szwURL,
        &m_pStream,
        0u,
        NULL );

    return hr;
}



EXPORT HRESULT    CURLArchive::GetFileSize( long & lSize )
{
    lSize = -1;
    if( m_pStream )
    {
        HRESULT  hr;
        STATSTG  statStg;

        hr = m_pStream->Stat( &statStg, STATFLAG_NONAME );
        if( SUCCEEDED(hr) )
        {
            if( 0u == statStg.cbSize.HighPart )
            {
                lSize = statStg.cbSize.LowPart;
            }
            else
            {
                lSize = -1;
            }            
        }
        return hr;
    }
    return E_ACCESSDENIED;    
}


EXPORT IStream * CURLArchive::GetStreamInterface( void ) const
{
    return m_pStream;
}


EXPORT DWORD     CURLArchive::Read( LPBYTE lpb,
                             DWORD ctBytes )
{
    DWORD  ctBytesRead = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesRead );
        if( FAILED(hr) )
            ctBytesRead = 0u;    
    }
    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPSTR lpstr,
                                        DWORD ctBytes )
{
    if( !m_pStream || (ctBytes < 1) || !lpstr )
        return 0u;

    DWORD   ctBytesRead      = 0u;
    LPSTR   lpstrXfer        = lpstr;
    DWORD   ctBytesRemaining = ctBytes - 1u;
    char    chTemp[ 512 + 1 ];
    
    lpstr[0] = '\0';
    ZeroMemory( chTemp, sizeof(chTemp) );
    LOOPFOREVER
    {
        HRESULT hr;
        DWORD   ctBytesToRead;
        DWORD   ctBytesJustRead;

        ctBytesToRead = min( (DWORD) ctBytesRemaining, 
                             sizeof(chTemp) - 1u );
        hr = m_pStream->Read( chTemp, 
                              ctBytesToRead,
                              &ctBytesJustRead );

        for( DWORD i=0u; i<ctBytesJustRead; ++i )
        {
                // Is there a CRLF in here?
            if( ('\r' == chTemp[i]) || ('\n' == chTemp[i]) )
            {
                LARGE_INTEGER  li;

                    // Skip past any other line-breaks
                while( (++i < ctBytesJustRead) && 
                       (('\r' == chTemp[i]) || ('\n' == chTemp[i])) )
                {
                    NULL;  // increment i in while eval
                }
                       
                    // Rewind stream to the next non-empty line
                if( i < ctBytesJustRead )
                {
                    li.HighPart = -1L;
                    li.LowPart  = (DWORD)((long) i - 
                                          (long) ctBytesJustRead);
                    m_pStream->Seek( li, current, NULL );
                }

                *lpstrXfer = '\0';
                return ctBytesRead;
            }

            *lpstrXfer++ = chTemp[i];
            --ctBytesRemaining;
            ++ctBytesRead;
        }

           // IStream docs say EOF may or may not return S_ hr
           // Review(normb): What does failed hr mean given this?           
        if( FAILED(hr) || 
            (ctBytesJustRead != ctBytesToRead) || 
            (ctBytesRemaining < 1) )
        {
            break;
        }
    }

    return ctBytesRead;
}


EXPORT DWORD     CURLArchive::ReadLine( LPWSTR lpstrw,
                                        DWORD  ctChars )
{
    return 0u;
}




EXPORT long CURLArchive::Seek( long ctBytes, origin orig )
{
    long  lNewPos = -1L;

    if( m_pStream )
    {
        ULARGE_INTEGER  uli;
        LARGE_INTEGER   li;
        HRESULT         hr = E_FAIL;

        li.LowPart = ctBytes;
        if( ctBytes < 0 )
            li.HighPart = -1L;

        hr = m_pStream->Seek( li, orig, &uli );
        if( FAILED(hr) || uli.HighPart )
            return -1L;

        lNewPos = (long) uli.LowPart;
    }
    return lNewPos;
}


EXPORT DWORD     CURLArchive::Write( LPBYTE lpb,
                              DWORD ctBytes )
{   
    DWORD  ctBytesWritten = 0u;

    if( m_pStream )
    {
        HRESULT hr;

        hr = m_pStream->Read( lpb, ctBytes, &ctBytesWritten );
        if( FAILED(hr) )
            ctBytesWritten = 0u;
    }
    return ctBytesWritten;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\iutility.cpp ===
/*
//   IUTILITY.CPP
//
//              INTEL CORPORATION PROPRIETARY INFORMATION
//  This software is supplied under the terms of a license agreement or
//  nondisclosure agreement with Intel Corporation and may not be copied
//  or disclosed except in accordance with the terms of that agreement.
//
//      Copyright (c) 1997 Intel Corporation. All Rights Reserved.
//
//  PVCS:
//      $Workfile$
//      $Revision$
//      $Modtime$
//
//  PURPOSE:
//                                  
//              
//
//  CONTENTS:
*/
#include "stdafx.h"
#include "utility.h"

CProceduralTextureUtility::CProceduralTextureUtility() :
    m_nScaleX(0),
    m_nScaleY(0),
    m_nScaleTime(0),
    m_nHarmonics(0)
{
    ZeroMemory(m_adwValueTable, sizeof(DWORD) * TABSIZE);
}


void CProceduralTextureUtility::_ValueTableInit(int seed)
{
    DWORD *table = m_adwValueTable;
    int i;

    srand(seed);
    for(i = 0; i < TABSIZE; i++) {
		*table++ = (rand()*rand()) & 0xffff;
	}
		
}

STDMETHODIMP
CProceduralTextureUtility::MyInitialize(DWORD dwSeed, DWORD dwFunctionType, 
                                        void *pInitInfo) 
{
    _ValueTableInit(dwSeed);

    switch (dwFunctionType) 
    {
    case PROCTEX_LATTICENOISE_LERP:
    case PROCTEX_LATTICETURBULENCE_LERP:
    case PROCTEX_LATTICENOISE_SMOOTHSTEP:
    case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:

        m_dwFunctionType = dwFunctionType;
        return S_OK;
        break;

    default:

        m_dwFunctionType = 0;
        return E_INVALIDARG;
        break;
    }

    return E_FAIL;
}


STDMETHODIMP
CProceduralTextureUtility::SetScaling(int nSX, int nSY, int nST) {
	m_nScaleX = nSX;
	m_nScaleY = nSY;
	m_nScaleTime = nST;
	return S_OK;
}

STDMETHODIMP
CProceduralTextureUtility::SetHarmonics(int nHarmonics) {
	m_nHarmonics= nHarmonics;
	return(S_OK);
}

// lerp() expects that x be the fractional 16 bits of a signed 15:16 value
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::Lerp(DWORD a, DWORD b, DWORD x) {
	DWORD ix;
	DWORD rval;

	ix = 0xffff - x;
	rval = x * b  + a * ix;
	return rval;
}

// smoothstep() expects that x be the fractional 16 bits of a signed 15:16 value
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::SmoothStep(DWORD a, DWORD b, DWORD x) {
	DWORD ix;
	DWORD rval;

	x = x >> 8;			// get the high 8 bits for our table lookup
	x = gdwSmoothTable[x];
	ix = 0xffff - x;
	rval = x*b + a*ix;
	return rval;
}

// x, y and t are integer values to start. They are converted to
// signed 15.16 format, and then divided by 2^scale. 
// the value returned by lerpnoise is signed 0.31
STDMETHODIMP_(DWORD)
CProceduralTextureUtility::Noise(DWORD x, DWORD y, DWORD t) {
	DWORD fx, fy, ft;
	DWORD ix, iy, it;
	DWORD v[8];
	DWORD rval;

	x = (x & 0x0ffff) << 16;
	y = (y & 0x0ffff) << 16;
	t = (t & 0x0ffff) << 16;
	
	x = x >> m_nScaleX;	
	y = y >> m_nScaleY;	
	t = t >> m_nScaleTime;	

	fx = x & 0x0ffff;
	fy = y & 0x0ffff;
	ft = t & 0x0ffff;

	ix = (x >> 16);
	iy = (y >> 16);
	it = (t >> 16);

	v[0] = vlattice(ix + 0, iy + 0, it + 0);
	v[1] = vlattice(ix + 1, iy + 0, it + 0);
	v[2] = vlattice(ix + 1, iy + 1, it + 0);
	v[3] = vlattice(ix + 0, iy + 1, it + 0);
	v[4] = vlattice(ix + 0, iy + 0, it + 1);
	v[5] = vlattice(ix + 1, iy + 0, it + 1);
	v[6] = vlattice(ix + 1, iy + 1, it + 1);
	v[7] = vlattice(ix + 0, iy + 1, it + 1);

	switch(m_dwFunctionType) {
		case PROCTEX_LATTICENOISE_LERP:
		case PROCTEX_LATTICETURBULENCE_LERP:
			v[0] = Lerp(v[0], v[4], ft) >> 16;
			v[1] = Lerp(v[1], v[5], ft) >> 16;
			v[2] = Lerp(v[2], v[6], ft) >> 16;
			v[3] = Lerp(v[3], v[7], ft) >> 16;

			v[0] = Lerp(v[0], v[3], fy) >> 16;
			v[1] = Lerp(v[1], v[2], fy) >> 16;

			rval = Lerp(v[0], v[1], fx);
			break;
		case PROCTEX_LATTICENOISE_SMOOTHSTEP:
		case PROCTEX_LATTICETURBULENCE_SMOOTHSTEP:
			v[0] = SmoothStep(v[0], v[4], ft) >> 16;
			v[1] = SmoothStep(v[1], v[5], ft) >> 16;
			v[2] = SmoothStep(v[2], v[6], ft) >> 16;
			v[3] = SmoothStep(v[3], v[7], ft) >> 16;

			v[0] = SmoothStep(v[0], v[3], fy) >> 16;
			v[1] = SmoothStep(v[1], v[2], fy) >> 16;

			rval = SmoothStep(v[0], v[1], fx);
			break;

	}
	return rval;
}

STDMETHODIMP_(int)
CProceduralTextureUtility::Turbulence(DWORD x, DWORD y, DWORD t) {
	int rval = 0;
	int i;
	DWORD	noiseval;
	int		signednoiseval;
	int xscale, yscale, tscale;

	xscale = m_nScaleX;
	yscale = m_nScaleY;
	tscale = m_nScaleTime;

	xscale += m_nHarmonics;
	yscale += m_nHarmonics;
	tscale += m_nHarmonics;

	for (i=0; i<m_nHarmonics; i++) {
		noiseval = Noise(x, y, t);
		xscale--; 
		yscale--; 
		tscale--;
		noiseval = noiseval >> 1;
		signednoiseval = noiseval;
		signednoiseval -= 0x3fffffff;
		signednoiseval = signednoiseval/(i+1);
		rval += signednoiseval;
	}
	return rval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\uuid\makefile.inc ===
#
# Explicit rules for copying generated *_i.c files from ..\idl\$(O) to $(O)
#

$(O)\proctexe_i.c : ..\idl\$(O)\proctexe_i.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\dxt\proctexe\src\utility.h ===
//------------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1999
//
//  FileName:       additive.cpp
//
//  Description:    Intel's additive procedural texture.
//
//  Change History:
//  1999/12/07  a-matcal    Created.
//
//------------------------------------------------------------------------------

#ifndef _UTILITY_H__
#define _UTILITY_H__

#include "defines.h"

extern DWORD gdwSmoothTable[];
extern DWORD gPerm[];




class CProceduralTextureUtility
{
public:

    CProceduralTextureUtility();

    // Utility functions.

    STDMETHOD(MyInitialize)(DWORD dwSeed, DWORD dwFunctionType, void *pInitInfo);
    STDMETHOD(SetScaling)(int nSX, int nSY, int nSTime);
    STDMETHOD(SetHarmonics)(int nHarmonics);
    STDMETHOD_(DWORD, Lerp)(DWORD dwLeft, DWORD dwRight, DWORD dwX);
    STDMETHOD_(DWORD, SmoothStep)(DWORD dwLeft, DWORD dwRight, DWORD dwX);
    STDMETHOD_(DWORD, Noise)(DWORD x, DWORD y, DWORD nTime);
    STDMETHOD_(int, Turbulence)(DWORD x, DWORD y, DWORD nTime);

private:

    DWORD       m_adwValueTable[TABSIZE];
    int         m_nScaleX;
    int         m_nScaleY;
    int         m_nScaleTime;
    int         m_nHarmonics;
    DWORD       m_dwFunctionType;

    DWORD       vlattice(int ix, int iy, int iz) 
                {
                    return m_adwValueTable[INDEX(ix, iy, iz)];
                }

    void        _ValueTableInit(int seed);
};

#endif // _UTILITY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\autourl.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       autourl.cxx
//
//  Contents:   Implementation of url autodetector object
//
//  History:    05-11-99 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_AUTOURL_HXX_
#define X_AUTOURL_HXX_
#include "autourl.hxx"
#endif

#ifndef _X_ANCHOR_H_
#define _X_ANCHOR_H_
#include "anchor.h"
#endif

#ifndef X_VRSSCAN_H_
#define X_VRSSCAN_H_
#include "vrsscan.h"
#endif

// TODO: consider creating scratch pointers for url autodetector [ashrafm]

using namespace EdUtil;

DeclareTag( tagDisableAutodetector, "UrlAutodetector", "Disable URL Autodetector" );

//
// AutoUrl Land
//

// TODO (t-johnh, 8/5/98): The following structs/tables/etc. are 
//  copied from src\site\text\text.cxx.  These either need to be 
//  kept in sync or merged into a single, easily accessible table

#define AUTOURL_WILDCARD_CHAR   _T('\b')

//
// TODO: use in CTxtPtr::IsInsideUrl [ashrafm]
//
// TODO: (tomfakes) This needs to be in-step with the same table in TEXT.CXX

#define MAX_URL_PREFIX_LEN 20

AUTOURL_TAG const s_urlTags[] = {
    { FALSE, 7,  1,  {_T("www."),         _T("http://www.")}},
    { FALSE, 7,  1,  {_T("http://"),      _T("http://")}},
    { FALSE, 8,  2,  {_T("https://"),     _T("https://")}},
    { FALSE, 6,  3,  {_T("ftp."),         _T("ftp://ftp.")}},
    { FALSE, 6,  3,  {_T("ftp://"),       _T("ftp://")}},
    { FALSE, 9,  4,  {_T("gopher."),      _T("gopher://gopher.")}},
    { FALSE, 9,  4,  {_T("gopher://"),    _T("gopher://")}},
    { FALSE, 7,  5,  {_T("mailto:"),      _T("mailto:")}},
    { FALSE, 5,  6,  {_T("news:"),        _T("news:")}},
    { FALSE, 6,  7,  {_T("snews:"),       _T("snews:")}},
    { FALSE, 7,  8,  {_T("telnet:"),      _T("telnet:")}},
    { FALSE, 5,  9,  {_T("wais:"),        _T("wais:")}},
    { FALSE, 7,  10, {_T("file://"),      _T("file://")}},
    { FALSE, 10, 10, {_T("file:\\\\"),    _T("file:///\\\\")}},
    { FALSE, 7,  11, {_T("nntp://"),      _T("nntp://")}},
    { FALSE, 7,  12, {_T("newsrc:"),      _T("newsrc:")}},
    { FALSE, 7,  13, {_T("ldap://"),      _T("ldap://")}},
    { FALSE, 8,  14, {_T("ldaps://"),     _T("ldaps://")}},
    { FALSE, 8,  15, {_T("outlook:"),     _T("outlook:")}},
    { FALSE, 6,  16, {_T("mic://"),       _T("mic://")}},
    { FALSE, 0,  17, {_T("url:"),         _T("")}}, 

    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    // N.B. The following have wildcard characters.
    // If you change \b to something else make sure you also change
    // the AUTOURL_WILDCARD_CHAR macro defined above.
    //
    // Note that there should be the same number of wildcards in the left and right strings.
    // Also, all characters in in both strings must be identical after the FIRST wildcard.
    // For example: LEGAL:   {_T("\b@\b"),   _T("mailto:\b@\b")},     [since @\b == @\b]
    //              ILLEGAL: {_T("\b@hi\b"), _T("mailto:\b@there\b")} [since @hi != @there]

    { TRUE,  0, 10, {_T("\\\\\b"),         _T("file://\\\\\b")}},
#if 0 // to be consistent with word2k
    { TRUE,  0, 10, {_T("//\b"),           _T("file://\b")}},
#endif
    { TRUE,  0, 5, {_T("\b@\b"),       _T("mailto:\b@\b")}},

};


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CAutoUrlDetector
//
//  Synopsis:   ctor
//
//  Arguments:  [pEd]           CHTMLEditor pointer
//
//-----------------------------------------------------------------------------
CAutoUrlDetector::CAutoUrlDetector(CHTMLEditor *pEd)
{
    Assert(pEd);

    _pEd = pEd;
    _fEnabled = TRUE;
    _fCanUpdateText = TRUE;
    _lLastContentVersion = 0;
    _dwLastSelectionVersion = 0;    
    _pLastMarkup = NULL;
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CAutoUrlDetector
//
//  Synopsis:   dtor
//
//+----------------------------------------------------------------------------

CAutoUrlDetector::~CAutoUrlDetector()
{
    ReleaseInterface(_pLastMarkup);
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::ShouldPerformAutoDetection
//
//  Synopsis:   Helper function for URL Autodetection.
//      Determines whether autodetection should be performed, based
//      upon the context of the given markup pointer.
//
//  Arguments:  [pmp]           MarkupPointer at which to autodetect
//              [pfAutoDetect]  Filled with TRUE if autodetection should happen
//
//  Returns:    HRESULT         S_OK if all is well, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::ShouldPerformAutoDetection(
    IMarkupPointer      *   pmp,
    BOOL                *   pfAutoDetect )
{
    HRESULT                 hr              = S_OK;
    IHTMLElement        *   pFlowElement    = NULL;
    VARIANT_BOOL            fMultiLine;
    VARIANT_BOOL            fEditable;
    ELEMENT_TAG_ID          tagFlowElement;
    VARIANT_BOOL            fHTML           = VARIANT_FALSE;
    SP_IHTMLElement3        spElement3;

    Assert( pmp && pfAutoDetect );

    *pfAutoDetect = FALSE;
   
    hr = THR( GetEditor()->GetFlowElement( pmp, &pFlowElement ) );
    if( FAILED(hr) )
        goto Cleanup;

    hr = S_OK;

    if( !pFlowElement )
        goto Cleanup;    

    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    hr = THR(spElement3->get_isMultiLine(&fMultiLine));
    if( hr )
        goto Cleanup;

    if( fMultiLine )
    {
        // Check if it's a container
        hr = THR(spElement3->get_canHaveHTML(&fHTML));
        if( hr )
            goto Cleanup;

        hr = THR(spElement3->get_isContentEditable(&fEditable));
        if( hr )
            goto Cleanup;

        hr = THR( GetMarkupServices()->GetElementTagId( pFlowElement, &tagFlowElement ) );
        if( hr )
            goto Cleanup;

        // Buttons are a no-no as well
        fHTML = fHTML && fEditable && tagFlowElement != TAGID_BUTTON;
    }

    *pfAutoDetect = fHTML;

Cleanup:
    ReleaseInterface( pFlowElement );

    RRETURN( hr );
}
        
//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::CreateAnchorElement
//
//  Synopsis:   Helper function for URL Autodetection.
//      Creates an anchor element and inserts it over the range
//      bounded by pStart and pEnd.  This does not set the href or any other
//      properties.
//
//  Arguments:  [pMS]       MarkupServices to work in
//              [pStart]    Start of range over which to insert the anchor
//              [pEnd]      End of range over which to insert the anchor
//              [ppAnchor]  Filled with the anchor element inserted.
//
//  Returns:    HRESULT     S_OK if successful, otherwise an error.
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::CreateAnchorElement(
    IMarkupPointer      *   pStart,
    IMarkupPointer      *   pEnd,
    IHTMLAnchorElement  **  ppAnchorElement)
{
    HRESULT hr;
    IHTMLElement *pElement = NULL;

    // Check our arguments
    Assert( pStart && pEnd && ppAnchorElement );

    // Create the anchor
    hr = THR( GetMarkupServices()->CreateElement(TAGID_A, NULL, &pElement ) );
    if( hr )
        goto Cleanup;

    // Slam it into the tree
    hr = THR( InsertElement(GetMarkupServices(), pElement, pStart, pEnd ) );
    if( hr )
        goto Cleanup;

    // Get a nice parting gift for our caller - a real live anchor!
    hr = THR( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **)ppAnchorElement ) );
    if( hr )
        goto Cleanup;

Cleanup:
    ReleaseInterface( pElement );
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::GetPlainText
//
//  Synopsis:   Helper function for URL Autodetection.
//      Retrieves the plain text between the start and end pointers
//      of the URL
//
//
//  Arguments:  [pMS]       MarkupServices
//              [pUrlStart] Beginning of text
//              [pUrlEnd]   End of text
//              [achText]   Buffer to fill with text
//
//  Returns:    HRESULT     S_OK if successful, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::GetPlainText(
    IMarkupPointer  * pUrlStart,
    IMarkupPointer  * pUrlEnd,
    TCHAR             achText[MAX_URL_LENGTH + 1] )
{
    IMarkupPointer *    pCurr       = NULL;
    int                 iComparison;
    HRESULT             hr;
    long                cchBuffer   = 0;
    MARKUP_CONTEXT_TYPE context;

    Assert( pUrlStart && pUrlEnd );

    //
    // Create and position a pointer for text scanning
    //
    hr = THR( GetEditor()->CreateMarkupPointer( &pCurr ) );
    if( hr )
        goto Cleanup;

    hr = THR( pCurr->MoveToPointer( pUrlStart ) );
    if( hr )
        goto Cleanup;

    hr = THR( OldCompare( pCurr, pUrlEnd, &iComparison ) );
    if( hr )
        goto Cleanup;

    //
    // Keep getting characters until we've scooted up to the end
    //
    while( iComparison == RIGHT && cchBuffer < MAX_URL_LENGTH)
    {
        long cchOne = 1;

        // Get a character
        hr = THR( pCurr->Right( FALSE, &context, NULL, &cchOne, achText + cchBuffer ) );
        if( hr ) 
            goto Cleanup;
        if( context == CONTEXT_TYPE_Text )
        {
            ++cchBuffer;
        }

        // It's just a jump to the left... and then a step to the right...
        hr = THR( pCurr->MoveUnit( MOVEUNIT_NEXTCHAR ) );
        if( hr )
            goto Cleanup;

        hr = THR( OldCompare( pCurr, pUrlEnd, &iComparison ) );
        if( hr )
            goto Cleanup;
    }

    // Terminate.
    achText[cchBuffer] = 0;

Cleanup:
    ReleaseInterface( pCurr );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::FindPattern
//
//  Synopsis:   Helper function for URL Autodetection.
//      Determines which URL pattern was matched, so that we know
//      how to translate it into an HREF string for the anchor
//
//  Arguments:  [pstrText]      The text of the URL
//              [ppTag]         Filled with a pointer to the pattern tag
//
//  Returns:    BOOL            TRUE if found a pattern
//
//-----------------------------------------------------------------------------
BOOL
CAutoUrlDetector::FindPattern( LPTSTR pstrText, const AUTOURL_TAG ** ppTag )
{
    int i;

    // Scan through the table
    for( i = 0; i < ARRAY_SIZE( s_urlTags ); i++ )
    {
        BOOL    fMatch = FALSE;
        const TCHAR * pszPattern = s_urlTags[i].pszPattern[AUTOURL_TEXT_PREFIX];

        if( !s_urlTags[i].fWildcard )
        {
            long cchLen = _tcslen( pszPattern );
#ifdef UNIX
            //IEUNIX: We need a correct count for UNIX version.
            long iStrLen = _tcslen( pstrText );
            if ((iStrLen > cchLen) && !_tcsnicmp(pszPattern, cchLen, pstrText, cchLen))
#else
            if (!StrCmpNIC(pszPattern, pstrText, cchLen) && pstrText[cchLen])
#endif
                fMatch = TRUE;
        }
        else
        {
            const TCHAR* pSource = pstrText;
            const TCHAR* pMatch  = pszPattern;

            while( *pSource )
            {
                if( *pMatch == AUTOURL_WILDCARD_CHAR )
                {
                    // N.B. (johnv) Never detect a slash at the
                    //  start of a wildcard (so \\\ won't autodetect).
                    if (*pSource == _T('\\') || *pSource == _T('/'))
                        break;

                    if( pMatch[1] == 0 )
                        // simple optimization: wildcard at end we just need to
                        //  match one character
                        fMatch = TRUE;
                    else
                    {
                        while( *pSource && *(++pSource) != pMatch[1] )
                            ;
                        if( *pSource )
                            pMatch++;       // we skipped wildcard here
                        else
                            continue;   // no match
                    }
                }
                else if( *pSource != *pMatch )
                    break;

                if( *(++pMatch) == 0 )
                    fMatch = TRUE;

                pSource++;
            }
        }
        
        if( fMatch )
        {
            *ppTag = &s_urlTags[i];
            return TRUE;
        }
    }        

    *ppTag = NULL;
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAutoUrlDetector::ApplyPattern
//
//  Synopsis:   Helper function for URL Autodetection.
//              This function creates a destination string corresponding to
//              the 'pattern' of a source string.  For example, given the
//              ptag {_T("\b@"),_T("mailto:\b@")}, and the source string
//              x@y.com, this function can generate mailto:x@y.com.  Similarly,
//              given mailto:x@y.com, it can generate x@y.com.
//
//
//  Arguments:  pstrDest            where we should allocate memory to hold the
//                                  destination string.
//
//              iIndexDest          the ptag pattern index for the destination
//
//              pszSourceText       the source string (which must have been matched
//                                  via the CAutoUrlDetector::IsAutodetectable function).
//
//              iIndexSrc           the ptag pattern index for the source
//
//              ptag                the ptag (returned via the CAutoUrlDetector::IsAutodetectable
//                                  function).
//
//----------------------------------------------------------------------------
void
CAutoUrlDetector::ApplyPattern( 
    LPTSTR          pstrDest, 
    int             iIndexDest,
    LPTSTR          pstrSource,
    int             iIndexSrc,
    const AUTOURL_TAG * ptag )
{
    if( ptag->fWildcard )
    {
        const TCHAR *   pszPrefixEndSrc;
        const TCHAR *   pszPrefixEndDest;
        int             iPrefixLengthSrc, iPrefixLengthDest;

        // Note: There MUST be a wildcard in both the source and destination
        //  patterns, or we will overflow into infinity.
        pszPrefixEndSrc = ptag->pszPattern[iIndexSrc];
        while( *pszPrefixEndSrc != AUTOURL_WILDCARD_CHAR )
            ++pszPrefixEndSrc;

        pszPrefixEndDest = ptag->pszPattern[iIndexDest];
        while( *pszPrefixEndDest != AUTOURL_WILDCARD_CHAR )
            ++pszPrefixEndDest;

        iPrefixLengthDest= pszPrefixEndDest - ptag->pszPattern[iIndexDest];
        iPrefixLengthSrc=  pszPrefixEndSrc  - ptag->pszPattern[iIndexSrc];

        memcpy( pstrDest, ptag->pszPattern[iIndexDest], iPrefixLengthDest*sizeof(TCHAR) );
        _tcsncpy( pstrDest + iPrefixLengthDest, pstrSource + iPrefixLengthSrc,
        			MAX_URL_LENGTH - iPrefixLengthDest);
    }
    else
    {
#if DBG==1
        int iTotalLength = _tcslen(ptag->pszPattern[iIndexDest]) +
                           _tcslen(pstrSource + _tcslen(ptag->pszPattern[iIndexSrc]));
        Assert( iTotalLength <= 1024 );
#endif
        _tcscpy( pstrDest, ptag->pszPattern[iIndexDest]);
        _tcsncat( pstrDest, pstrSource + _tcslen(ptag->pszPattern[iIndexSrc]), 
        			MAX_URL_LENGTH - _tcslen(ptag->pszPattern[iIndexDest]));
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::RemoveQuotes
//
//  Synopsis:   Helper function for URL Autodetection.
//      When a user closes a quoted URL, we remove the opening and
//      closing quotes.
//              We only consider the URL quoted if there is on opening quote
//      character (quote or less-than) just in front of the range, and a
//      matching close quote character (quote or greater-than) just inside the
//      end of the range.
//  
//
//  Arguments:
//      IMarkupServices * pMS         - Markup Services
//      IMarkupPointer  * pOpenQuote  - Points to open quote
//      IMarkupPointer  * pCloseQuote - Points to close quote
//
//  Returns:    HRESULT     S_OK if all is well, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::RemoveQuotes( 
    IMarkupPointer  *   pOpenQuote,
    IMarkupPointer  *   pCloseQuote)
{
    HRESULT             hr;
    IMarkupPointer  *   pQuoteKiller    = NULL;
    LONG                cch;
    OLECHAR             chOpen;
    OLECHAR             chClose;
    MARKUP_CONTEXT_TYPE context;

    // Create a pointer to look at the left side
    IFC( GetEditor()->CreateMarkupPointer( &pQuoteKiller ) );

    // Position it
    IFC( pQuoteKiller->MoveToPointer( pOpenQuote ) );

    // And read the open quote char
    cch = 1;
    IFC( pQuoteKiller->Right(TRUE, &context, NULL, &cch, &chOpen) );
    
    // If it wasn't text, or we got more than one char or a non-quote char, bail
    if (context != CONTEXT_TYPE_Text || cch != 1 || (chOpen != _T('"') && chOpen != _T('<')))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Rip out the open quote.
    IFC( GetMarkupServices()->Move( pOpenQuote, pQuoteKiller, NULL ) );   

    // Now do the same for the right side
    IFC( pQuoteKiller->MoveToPointer( pCloseQuote ) );

    cch = 1;
    IFC( pQuoteKiller->Right( TRUE, &context, NULL, &cch, &chClose ) );

    // Same deal for bailing
    if (context != CONTEXT_TYPE_Text || cch != 1 || (chClose != _T('"') && chClose != _T('>')))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Rip out the close quote.
    IFC( GetMarkupServices()->Move( pCloseQuote, pQuoteKiller, NULL ) );

    AssertSz( ( chOpen == _T('"') && chClose == _T('"') ) || ( chOpen == _T('<') && chClose == _T('>') ),
              "CAutoUrlDetector::RemoveQuotes called when it shouldn't have been" );
    
Cleanup:
    ReleaseInterface( pQuoteKiller );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::SetUrl
//
//  Synopsis:   Helper function for URL Autodetection.
//      Given a range of text that is known to be a URL, will create
//      and wire up an anchor element around it, as well as take all
//      appropriate actions (cleaning up quotes, figuring out the caret
//      position, etc.)
//      May also constrain the boundaries if detection was typing-triggered
//      and not in an existing link.  In this case, detection should
//      terminate at the position of the typed character.
//
//  Arguments:  [pEd]       Editor
//              [pUrlStart] Begin of range
//              [pUrlEnd]   End of range
//              [pOldCaret] Position of the caret prior to detection
//              [pChar]     Character that triggered detection or NULL
//              [fHandleQuotes] TRUE if caller wants us to handle quotes.
//              [pfRepos]   Enumeration stating how to reposition the caret, if at all
//
//  Returns:    HRESULT     S_OK if successful, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::SetUrl(
    IMarkupPointer          * pUrlStart,
    IMarkupPointer          * pUrlEnd,
    IMarkupPointer          * pOldCaretPos,
    OLECHAR                 * pChar,
    BOOL                      fUIAutoDetect,
    AUTOURL_REPOSITION      * pfRepos )
{
    HRESULT                 hr;
    TCHAR                   achText[MAX_URL_LENGTH + 1];
    TCHAR                   achHref[MAX_URL_LENGTH + 1];
    TCHAR                   chBeforeBegin = 0;          // For quote checking
    TCHAR                   chAfterEnd;                 // For quote checking
    const AUTOURL_TAG   *   pTag;
    BSTR                    bstrHref        = NULL;
    IHTMLElement        *   pElement        = NULL;
    IHTMLAnchorElement  *   pAnchorElement  = NULL;
    CEditPointer            epOpenQuote( GetEditor() );         // For checking quotes
    CEditPointer            epCloseQuote( GetEditor() );        // For checking quotes
    IMarkupPointer      *   pAfterAnchorEnd = NULL;     // For adjusting anchor
    BOOL                    fCreatedAnchor  = FALSE;    // Did we create an anchor?
    BOOL                    fOpenQuote      = FALSE;    // Was there an open quote?
    BOOL                    fFullyQuoted    = FALSE;    // Are there matching open/close quotes?
    SP_IHTMLElement         spAnchorElement;
    SP_IHTMLElement3        spElement3;
    VARIANT_BOOL            fAcceptsHtml;
    CEdUndoHelper               undoUnit(GetEditor());
    CSelectionManager       *pManager = GetEditor()->GetSelectionManager();
    BOOL                    &fHandleQuotes = fUIAutoDetect;
    BOOL                    fCanUpdateText;
    SP_IMarkupContainer2    spMarkup2;

    Assert( GetMarkupServices() && pUrlStart && pUrlEnd );

    //
    // Make sure our container is editable
    //

    IFC( pUrlStart->CurrentScope(&spAnchorElement) );
    if (spAnchorElement == NULL)
    {
        hr = S_OK; // nothing to do if we can't get to scope
        goto Cleanup;
    }
        
    // TODO: with the check in ShouldAutoDetect, we shouldn't need this [ashrafm]

    //
    // TODO - marka - convert this into an assert if it's redundant, or remove the above comment
    //
    IFC(spAnchorElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHtml));
    if (!fAcceptsHtml)
    {
        hr = S_OK; // nothing to do if container can't accept html
        goto Cleanup;
    }
    
    //
    // If our caller cares about quoting, we'll determine the information
    // they [and we] need.
    //
    if( fHandleQuotes )
    {
        DWORD eBreakConditionOut;

        // Check the character before the beginning of the URL
        IFC( epOpenQuote.MoveToPointer( pUrlStart ) );
        IFC( epOpenQuote.Scan( LEFT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &eBreakConditionOut, NULL, NULL, &chBeforeBegin ) );

        if( eBreakConditionOut & BREAK_CONDITION_Text &&
            chBeforeBegin == _T('"') || chBeforeBegin == _T('<') )
            fOpenQuote = TRUE;
    }

    //
    // The only anchor we would care about is one IMMEDIATELY surrounding us,
    // as that's what we'll get from FindUrl.
    //
    
    // Check the context at the beginning of the URL
    hr = THR( pUrlStart->CurrentScope( &pElement ) );
    if( hr )
        goto Cleanup;

    // See if it's an anchor
    if (pElement)
        THR_NOTRACE( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **) &pAnchorElement ) );

    // If no anchor, then check the end.
    if( NULL == pAnchorElement )
    {
        ReleaseInterface( pElement );

        hr = THR( pUrlEnd->CurrentScope( &pElement ) );
        if( hr )
            goto Cleanup;

        if( pElement )
            THR_NOTRACE( pElement->QueryInterface( IID_IHTMLAnchorElement, (void **) &pAnchorElement ) );
    }

    // Nope - we'll have to make one.    
    if( NULL == pAnchorElement )
    {
        // Check if there is another anchor above as an indirect parent.  If so, don't create a new one.
        IFC( FindTagAbove(GetMarkupServices(), pElement, TAGID_A, &spAnchorElement) );
        if (spAnchorElement != NULL)
            goto Cleanup; // done;

        // If there was an open quote and we're making a new anchor,
        // check to see if we're closing the quotes at the same time.
        if( fHandleQuotes && fOpenQuote ) 
        {
            DWORD eBreakConditionOut;

            IFC( epCloseQuote.SetGravity( POINTER_GRAVITY_Right ) );
            IFC( epCloseQuote.MoveToPointer( pUrlEnd ) );

            IFC( epCloseQuote.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE, &eBreakConditionOut, NULL, NULL, &chAfterEnd ) );

            fFullyQuoted = ( eBreakConditionOut & BREAK_CONDITION_Text ) &&
                           ( chBeforeBegin == _T('"') && chAfterEnd == _T('"') ) ||
                           ( chBeforeBegin == _T('<') && chAfterEnd == _T('>') );

            // If we're fully quoted, go back and remember where the close quote was.
            if( fFullyQuoted )
            {
                IFC( epCloseQuote.Scan( LEFT, BREAK_CONDITION_Text ) );
            }
        }

        
        // If typing-triggered and quoted, but not completed with the typed char,
        // include the typed character in the quoted link
        //
        // TODO (JHarding): This isn't always correct if we trimmed characters
        // off the end of the URL.  This should be more intelligent about including
        // up to and including the typed character.
        // 
        //  This seems to be bogus: if not fully quoted, we will not honor this 
        //  as URL. In fact, Trident seems to return NOT IsInsideURL if this is
        //  the case. So the code below seems to be superfluous. 
        //  [zhenbinx]
        //
        if( pChar && fHandleQuotes && fOpenQuote && !fFullyQuoted )
        {
            MARKUP_CONTEXT_TYPE *   pContext = NULL;
            long                    cch = 1;

            AssertSz(FALSE, "Harmless assertion! If this happens, the code below is not redudant");
            
            WHEN_DBG(MARKUP_CONTEXT_TYPE     context);
            WHEN_DBG(pContext = &context);

            hr = pUrlEnd->Right(TRUE, pContext, NULL, &cch, NULL);
            if (hr)
                goto Cleanup;

            Assert(CONTEXT_TYPE_Text == *pContext);
            Assert(1 == cch);
        }

        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );

        // Wire up the anchor around the appropriate text
        hr = THR( CreateAnchorElement( pUrlStart, pUrlEnd, &pAnchorElement ) );
        if( hr )
            goto Cleanup;
            
        fCreatedAnchor = TRUE;

        // Update seleciton version
        _dwLastSelectionVersion = GetEditor()->GetSelectionVersion();

        // Update markup
        ClearInterface(&_pLastMarkup);
        IFC( pUrlStart->GetContainer(&_pLastMarkup) );
        IFC( _pLastMarkup->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spMarkup2) );

        // Update content version
        _lLastContentVersion = spMarkup2->GetVersionNumber();
    }
    else
    {
        //
        // If we are updating an existing anchor, add the undo unit
        // to the current typing batch
        //
        if (pManager->GetTrackerType() == TRACKER_TYPE_Caret && pManager->GetActiveTracker())
        {
            CCaretTracker *pCaretTracker = DYNCAST(CCaretTracker, pManager->GetActiveTracker());

            IFC( pCaretTracker->BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) )
        }
        else
        {
            IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );
        }
        
        //
        // We found an existing anchor
        //
        BOOL fEndLeftOf;

        if( fHandleQuotes )
        {
            DWORD eBreakConditionOut;

            IFC( epCloseQuote.SetGravity( POINTER_GRAVITY_Right ) );
            IFC( epCloseQuote.MoveToPointer( pUrlEnd ) );

            IFC( epCloseQuote.Scan( LEFT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &eBreakConditionOut, NULL, NULL, &chAfterEnd ) );

            fFullyQuoted = (eBreakConditionOut & BREAK_CONDITION_Text) &&
                           ( chBeforeBegin == _T('"') && chAfterEnd == _T('"') ) ||
                           ( chBeforeBegin == _T('<') && chAfterEnd == _T('>') );
        }

        //
        // If the anchor doesn't match the new anchor text, we may have to adjust it.
        //
        IFC( GetEditor()->CreateMarkupPointer( &pAfterAnchorEnd ) );

        IFC( pAfterAnchorEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd ) );

        // Check if the anchor ends before the new url text
        IFC( pAfterAnchorEnd->IsLeftOf( pUrlEnd, &fEndLeftOf ) );

        if( fEndLeftOf )
        {
            // Pull the anchor out and re-insert over the appropriate range
            IFC( GetMarkupServices()->RemoveElement( pElement ) );
            IFC( GetMarkupServices()->InsertElement( pElement, pUrlStart, pUrlEnd ) );
        }
    }

    // If typing-triggered, quoted, and the quote chars match, we go outside    
    if( fFullyQuoted && fHandleQuotes )
    {
        hr = THR( RemoveQuotes( epOpenQuote, epCloseQuote ) );
        if( hr )
            goto Cleanup;

        if( pfRepos )
            *pfRepos = AUTOURL_REPOSITION_Outside;
    }
    else if( fCreatedAnchor && fOpenQuote && fHandleQuotes )
    {
        if( pfRepos )
            *pfRepos = AUTOURL_REPOSITION_Inside;
    }
        

    //
    // Translate from plain text to href string:
    // 1) Get the plain text
    // 2) Figure out what pattern it is
    // 3) Apply the translation pattern
    //
    hr = THR( GetPlainText( pUrlStart, pUrlEnd, achText ) );
    if( hr )
        goto Cleanup;

    if (!FindPattern( achText, &pTag))
        goto Cleanup;

    ApplyPattern( achHref, AUTOURL_HREF_PREFIX,
                          achText, AUTOURL_TEXT_PREFIX,
                          pTag );

    // Allocate the href string
    bstrHref = SysAllocString( achHref );
    if( !bstrHref )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // HACKHACK: put_href causes the text contained in the URL to be
    // updated.  This behavior is done for ie401 compat.  So, force
    // no update here.

    fCanUpdateText = _fCanUpdateText;
    _fCanUpdateText = FALSE;

    hr = THR( pAnchorElement->put_href( bstrHref ) );
    if( hr )
        goto Cleanup;

    _fCanUpdateText = fCanUpdateText;

Cleanup:
    ReleaseInterface( pElement );
    ReleaseInterface( pAnchorElement );
    ReleaseInterface( pAfterAnchorEnd );
    SysFreeString( bstrHref );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::DetectRange
//
//  Synopsis:   Performs URL autodetection on the given range.  Note that URLs
//      that are autodetected may need be wholly contained within the range, as
//      URLs can straddle the boundaries of the range.
//
//  Arguments:  [pEd]           The Editor in which to work.
//              [pRangeStart]   Begin of range to autodetect
//              [pRangeEnd]     End of range to autodetect
//
//  Returns:    HRESULT         S_OK if no problems, otherwise error.
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::DetectRange(
    IMarkupPointer  *   pRangeStart,
    IMarkupPointer  *   pRangeEnd,
    BOOL                fValidate /* = TRUE */,
    IMarkupPointer  *   pLimit /* = NULL */)
{
    IMarkupPointer  *   pUrlStart   = NULL;
    IMarkupPointer  *   pUrlEnd     = NULL;
    IMarkupPointer  *   pCurr       = NULL;
    IMarkupPointer2 *   pmp2        = NULL;
    BOOL                fDetect     = FALSE;
    HRESULT             hr          = S_OK;
    BOOL                fFound      = FALSE;
    BOOL                fLeftOf;

    if (!_fEnabled)
        return S_OK;

    // Check validity of everything
    #if DBG==1
    INT iComparison;
    Assert( pRangeStart && pRangeEnd );
    Assert( !OldCompare( pRangeStart, pRangeEnd, &iComparison ) && iComparison != LEFT );
    WHEN_DBG( if( IsTagEnabled( tagDisableAutodetector ) ) goto Cleanup );
    #endif

    // See if we should even bother
    if ( fValidate )
    {
        hr = THR( ShouldPerformAutoDetection( pRangeStart, &fDetect ) );
        if( hr || !fDetect )
            goto Cleanup;
    }

    //
    // Create pointers for us to play with.
    //
    hr = THR( GetEditor()->CreateMarkupPointer( &pUrlStart ) );    
    if( hr )
        goto Cleanup;

    hr = THR( pUrlStart->SetGravity(POINTER_GRAVITY_Left) );
    if( hr )
        goto Cleanup;        

    hr = THR( GetEditor()->CreateMarkupPointer( &pUrlEnd ) );
    if( hr )
        goto Cleanup;

    hr = THR( pUrlEnd->SetGravity(POINTER_GRAVITY_Right) );
    if( hr )
        goto Cleanup;        

    hr = THR( GetEditor()->CreateMarkupPointer( &pCurr ) );
    if( hr )
        goto Cleanup;

    IFC( pCurr->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 ) );

    hr = THR( pmp2->MoveToPointer( pRangeStart ) );
    if( hr )
        goto Cleanup;

    // Check for a URL at start
    hr = THR( pmp2->IsInsideURL( pUrlEnd, &fFound ) );
    if( hr )
        goto Cleanup;

    if (fFound)
    {
        // Link it up
        fLeftOf = FALSE;
        if (pLimit)
            IFC( pLimit->IsLeftOf(pUrlEnd, &fLeftOf) );
                
        hr = THR( SetUrl( pmp2, fLeftOf ? pLimit : pUrlEnd, NULL, NULL, FALSE, NULL ) );
        if( hr )
            goto Cleanup;

        hr = THR( pmp2->MoveToPointer( pUrlEnd ) );
        if( hr )
            goto Cleanup;
    }

    for (;;)
    {
        // hr = THR(GetViewServices()->FindUrl(pCurr, pRangeEnd, pUrlStart, pUrlEnd));
        hr = THR(pmp2->MoveUnitBounded( MOVEUNIT_NEXTURLBEGIN, pRangeEnd ) );
        if (hr != S_OK)
        {
            hr = (hr == S_FALSE) ? S_OK : hr;
            goto Cleanup;
        }
        IFC( pUrlStart->MoveToPointer( pmp2 ) );
        IFC( pUrlEnd->MoveToPointer( pUrlStart ) );
        IFC( pUrlEnd->MoveUnit( MOVEUNIT_NEXTURLEND ) );
        
        // Link it up
        fLeftOf = FALSE;
        if (pLimit)
            IFC( pLimit->IsLeftOf(pUrlEnd, &fLeftOf) );
        
        hr = THR( SetUrl( pUrlStart, fLeftOf ? pLimit : pUrlEnd, NULL, NULL, FALSE, NULL ) );
        if( hr )
            goto Cleanup;

        // Start from the end of this one for the next earch
        hr = THR( pmp2->MoveToPointer( pUrlEnd ) );
        if( hr )
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface( pUrlStart );
    ReleaseInterface( pUrlEnd );
    ReleaseInterface( pCurr );
    ReleaseInterface( pmp2 );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::DetectCurrentWord
//
//  Synopsis:   Performs URL autodetection just on the current/previous word.
//      This is mainly to be used during editing where the only way that
//      there is a new URL is at the word currently being edited.
//
//  Arguments:  [pWord]     Pointer to the current word to detect
//              [pChar]     The character entered which triggered autodetection
//              [pfInside]  Filled with TRUE if caller should go left into link
//              [pLimit]    Right limit on detection
//              [pLeft]     If given, will be set to left end of URL if there is one
//
//  Returns:    HRESULT     S_OK if no problems, otherwise an error
//
//-----------------------------------------------------------------------------
HRESULT
CAutoUrlDetector::DetectCurrentWord( 
    IMarkupPointer      *   pWord,
    OLECHAR             *   pChar,
    AUTOURL_REPOSITION  *   pfRepos,
    IMarkupPointer      *   pLimit /* = NULL */,
    IMarkupPointer      *   pLeft /* = NULL */,
    BOOL                *   pfFound /* = NULL */ )
{
    IMarkupPointer  *   pStart      = NULL;
    IMarkupPointer  *   pEnd        = NULL;
    IMarkupPointer2 *   pmp2        = NULL;
    BOOL                fDetect;
    BOOL                fFound;
    HRESULT             hr          = S_OK;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    if( pfRepos )
    {
        *pfRepos = AUTOURL_REPOSITION_No;
    }

    if (!_fEnabled)
    {
        goto Cleanup;
    }

    // Check argument validity
    Assert( GetMarkupServices() && pWord );
    WHEN_DBG( if( IsTagEnabled( tagDisableAutodetector ) ) goto Cleanup );

    // Don't waste time if we can't autodetect
    hr = THR( ShouldPerformAutoDetection( pWord, &fDetect ) );
    if( hr || !fDetect )
        goto Cleanup;

    //
    // Set everything up
    //

    hr = THR( GetEditor()->CreateMarkupPointer( &pStart ) );
    if( hr )
        goto Cleanup;

    hr = THR( pStart->SetGravity(POINTER_GRAVITY_Left) );
    if( hr )
        goto Cleanup;

    hr = THR( GetEditor()->CreateMarkupPointer( &pEnd ) );
    if( hr )
        goto Cleanup;

    hr = THR( pEnd->SetGravity(POINTER_GRAVITY_Right) );
    if( hr )
        goto Cleanup;

    hr = THR( pStart->MoveToPointer( pWord ) );
    if( hr )
        goto Cleanup;

    // Check for a URL
    IFC( pStart->QueryInterface( IID_IMarkupPointer2, (void **)&pmp2 ) );
    hr = THR( pmp2->IsInsideURL( pEnd, &fFound ) );
    if( hr )
        goto Cleanup;

    if( pfFound )
    {
        *pfFound = fFound;
    }

    if( fFound )
    {
        BOOL                fLeftOf = FALSE;

        // Check if we need to restrict the anchor
        if( pLimit )
            IFC( pLimit->IsLeftOf( pEnd, &fLeftOf ) );
            
        // Hook it up
        IFC( SetUrl( pStart, fLeftOf ? pLimit : pEnd, pWord, pChar, TRUE, pfRepos ) );

        if( pLeft )
            IFC( pLeft->MoveToPointer( pStart ) );
    }


Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    ReleaseInterface( pmp2 );

    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   CAutoUrlDetector::ShouldUpdateAnchorText
//
//  Synopsis:   Determine whether the passed in Href and Anchore Text are
//              autodetectable with the same autodetection pattern.
//
//-----------------------------------------------------------------------------

HRESULT
CAutoUrlDetector::ShouldUpdateAnchorText (
        OLECHAR * pstrHref,
        OLECHAR * pstrAnchorText,
        BOOL    * pfResult )
{
    const AUTOURL_TAG * pTagHref;
    const AUTOURL_TAG * pTagText;

    if (! pfResult)
        goto Cleanup;

    *pfResult = FALSE;

    if (!pstrHref || !pstrAnchorText || !_fCanUpdateText)
        goto Cleanup;

    if ( !FindPattern( pstrAnchorText, &pTagText ) )      
        goto Cleanup;

    if ( !FindPattern( pstrHref, &pTagHref ) )       
        goto Cleanup;

    //
    // If the href and the text don't match using the same pattern, don't update
    //
    if ( pTagText != pTagHref && pTagText->uiProtocolId == pTagHref->uiProtocolId)
    {
        const TCHAR *szText = pTagText->pszPattern[AUTOURL_HREF_PREFIX];
        const TCHAR *szHref = pTagHref->pszPattern[AUTOURL_HREF_PREFIX];        

        // Chcek if the prefix is the same for both patterns
        if (StrNCmpI(szText, szHref, max(pTagText->iSignificantLength, pTagHref->iSignificantLength)))
            goto Cleanup;            

        // If the strings are the same, nothing to do
        if (!StrCmpI(pstrAnchorText, pstrHref + _tcslen(pTagHref->pszPattern[AUTOURL_TEXT_PREFIX])))
            goto Cleanup;
    }

    *pfResult = TRUE;

Cleanup:
    return S_OK;
}

//+====================================================================================
//
// Method: UserActionSinceLastDetection
//
// Synopsis: Has selection changed or the document changed since we lasted inserted
//           an anchor.
//
//------------------------------------------------------------------------------------
BOOL 
CAutoUrlDetector::UserActionSinceLastDetection()
{
    HRESULT                 hr;
    SP_IMarkupContainer     spMarkup;
    SP_IMarkupContainer2    spMarkup2;
    IMarkupPointer          *pStartEditContext;

    //
    // Check selection version
    //
    
    if (GetEditor()->GetSelectionVersion() != _dwLastSelectionVersion)
        goto Cleanup;

    //
    // Check markup containers
    //

    pStartEditContext = GetEditor()->GetSelectionManager()->GetStartEditContext();
    if (!pStartEditContext)
        goto Cleanup;

    IFC( pStartEditContext->GetContainer(&spMarkup) );

    if (!_pLastMarkup
        || spMarkup == NULL
        || !IsEqual(_pLastMarkup, spMarkup))
    {
        goto Cleanup;
    }


    //
    // Check document versions
    //

    IFC( spMarkup->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spMarkup2) );
    
    if (spMarkup2->GetVersionNumber() != _lLastContentVersion)
        goto Cleanup;

    //
    // Everything equal, so no user interaction
    //
    
    return FALSE;
    
Cleanup:
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\copycmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_COPYCMD_HXX_
#define _X_COPYCMD_HXX_
#include "copycmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

using namespace EdUtil;

#define CREATE_FLAGS_NoIE4SelCompat 1

//
// Externs
//

MtDefine(CCopyCommand, EditCommand, "CCopyCommand");

HRESULT
CCopyCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT         hr = S_OK;
    ISegmentList    *pSegmentList = NULL;
    CHTMLEditor     *pEditor = GetEditor();
    IHTMLElement    *pElement = NULL;
    SP_IHTMLElement3 spElement3;
    VARIANT_BOOL    fRet;
    BOOL            fEmpty = FALSE;
    SELECTION_TYPE  eSelectionType;
    DWORD           dwOptions = 0;

    //
    // Do the prep work
    //
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    IFC( GetSegmentList( &pSegmentList ));

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    // 
    // If there is no segments we're done, it's a nogo
    //
    if( fEmpty == TRUE )
        goto Cleanup;

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(pSegmentList))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }


    IFC( GetEditor()->FindCommonParentElement( pSegmentList, &pElement));

    if (! pElement)
        goto Cleanup;
        
    IFC(pElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("oncopy"), NULL, &fRet));

    if (!fRet)
        goto Cleanup;

    //
    // Do the actual copy
    //

    IFC( pSegmentList->GetType(&eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Control)
    {
        dwOptions |= CREATE_FLAGS_NoIE4SelCompat;
    }

#ifndef UNIX
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( pSegmentList, dwOptions ) );
#else
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( pSegmentList, dwOptions, pvarargOut ) );
#endif

Cleanup:
    ReleaseInterface( pElement );
    ReleaseInterface((IHTMLEditor *) pEditor);
    ReleaseInterface(pSegmentList);

    RRETURN(hr);
}


HRESULT 
CCopyCommand::PrivateQueryStatus( OLECMD * pCmd,
                     OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement3        spElement3;
    VARIANT_BOOL            fRet = VB_TRUE;
    BOOL                    fEmpty = FALSE;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );
    IHTMLEditor             *pEditor = GetEditor();
    SELECTION_TYPE          eSelectionType;
    
    pEditor->AddRef();
    
    //
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    // 
    // Get the segment list and selection type, and empty status
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    // 
    // If there is no segments we're done, it's a nogo
    //
    if( fEmpty )
        goto Cleanup;

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
        goto Cleanup;

    // No copying allowed while in the middle of an IME composition
    if( GetEditor()->GetSelectionManager()->IsIMEComposition() )
        goto Cleanup;

    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
   
    if (spElement)
    {
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->fireEvent(_T("onbeforecopy"), NULL, &fRet));
    }

    if (!fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP; 
        goto Cleanup;
    }

    //
    // If there is a selection, copy is enabled
    //
    if (SELECTION_TYPE_Caret != eSelectionType) 
    {
        if (GetCommandTarget()->IsRange())
        {
            IFC( spSegmentList->CreateIterator(&spIter) );
            Assert(S_FALSE == spIter->IsDone());

            BOOL  fEqual;
            IFC( spIter->Current(&spSegment) );
            IFC( spSegment->GetPointers(edStart, edEnd) );
            IFC( edStart->IsEqualTo(edEnd, &fEqual) );
            if (fEqual)
                goto Cleanup;
        }

        pCmd->cmdf = MSOCMDSTATE_UP;
    }

Cleanup:
    ReleaseInterface( pEditor );
    
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\cartrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif


#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 


#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#define OEM_SCAN_RIGHTSHIFT 0x36
#define ISC_BUFLENGTH  10


MtDefine( CCaretTracker, Utilities , "CCaretTracker" )

ExternTag(tagSelectionTrackerState)
ExternTag(tagEdKeyNav)

using namespace EdUtil;

//
//
// Constructors & Initialization
// 
//

CCaretTracker::CCaretTracker( CSelectionManager* pManager ) :
    CEditTracker( pManager )
{
    _pBatchPUU = NULL;
    Init();
}

VOID
CCaretTracker::Init()
{
    _eType = TRACKER_TYPE_Caret;
    _fValidPosition = TRUE;
    _fCaretShouldBeVisible = TRUE;
    _fHaveTypedSinceLastUrlDetect = FALSE;
    _fCheckedCaretForAtomic = FALSE;
    _ptVirtualCaret.InitPosition();
    SetState(CR_DORMANT);
}


CCaretTracker::~CCaretTracker()
{
    Destroy();
}

HRESULT
CCaretTracker::Init2()
{
    HRESULT hr = S_OK;
    Assert( CR_DORMANT );

    SetCaretVisible( _pManager->GetDoc(), FALSE );

    // Set the selection type to none
    if( GetSelectionServices() && WeOwnSelectionServices() == S_OK )
        IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ) );

    _state = CR_PASSIVE;

Cleanup:
    return S_OK; // do nothting. We should be in the CR_PASSIVE State.
}

HRESULT
CCaretTracker::Init2(
                        IDisplayPointer*        pDispStart, 
                        IDisplayPointer*        pDispEnd, 
                        DWORD                   dwTCFlags,
                        CARET_MOVE_UNIT inLastCaretMove )
{
    HRESULT hr              = S_OK;

    SetState( CR_ACTIVE );    

    BOOL fStartPositioned = FALSE;
    BOOL fEndPositioned = FALSE;

    hr = THR( pDispStart->IsPositioned( & fStartPositioned ));
    if (!hr) hr = THR( pDispEnd->IsPositioned( & fEndPositioned) );

    if ( ! fStartPositioned || ! fEndPositioned )
    {
        _fValidPosition = FALSE;
    }

    if ( _fValidPosition )
    {
        hr = PositionCaretAt( pDispStart, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None );
        if (FAILED(hr))
            _fValidPosition = FALSE;
    }
    
    SetCaretShouldBeVisible( ShouldCaretBeVisible() );

    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Caret, (ISelectionServicesListener*) _pManager ) );   

Cleanup:
#if DBG == 1
    int caretStart = GetCp( pDispStart) ;
    BOOL fVisible = FALSE;
    TraceTag(( tagSelectionTrackerState, "\n---Start Caret Tracker--- Cp: %d Visible:%d\n",caretStart, fVisible ));
#endif    

    return hr;
}

HRESULT
CCaretTracker::Init2( 
                        ISegmentList*           pSegmentList, 
                        DWORD                   dwTCFlags,
                        CARET_MOVE_UNIT         inLastCaretMove )
{
    HRESULT hr = S_OK;

    //  We need to properly tear down the current tracker and make ourself
    //  passive.  We get called here when restoring the selection (selection
    //  none) during a drag leave.
    
    IFC( _pManager->EnsureDefaultTrackerPassive());

Cleanup:
    return hr;
}

HRESULT
CCaretTracker::Init2( 
                        CEditEvent* pEvent,
                        DWORD                   dwTCFlags,
                        IHTMLElement* pIElement )
{    
    HRESULT hr = S_OK;

    SetState( CR_ACTIVE );

    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Caret, (ISelectionServicesListener*) _pManager ) );

    if ( pEvent )
    {
        hr = PositionCaretFromEvent( pEvent );
    }

    SetCaretShouldBeVisible( ShouldCaretBeVisible() );

Cleanup:

#if DBG == 1
    BOOL fVisible = FALSE;
    TraceTag(( tagSelectionTrackerState, "\n---Start Caret Tracker--- Visible:%d\n",fVisible ));
#endif   

    return hr;
}



//
//
// Virtuals from all trackers
// (excluding) event handling
//

//+====================================================================================
//
// Method: ShouldBeginSelection
//
// Synopsis: We don't want to start selection in Anchors, Images etc.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::ShouldStartTracker(
        CEditEvent* pEvent ,
        ELEMENT_TAG_ID eTag,
        IHTMLElement* pIElement,
        SST_RESULT * peResult )
{
    if ( _pManager->IsEditContextNoScope())
    {
        *peResult = SST_NO_CHANGE;
    }
    else if ( ! pEvent->IsShiftKeyDown())
        *peResult = SST_CHANGE;

    RRETURN( S_OK);
}

//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT 
CCaretTracker::BecomeDormant(   CEditEvent      *pEvent, 
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI /*= TRUE*/ )
{
    CSpringLoader       *psl = GetSpringLoader();
    HRESULT hr = S_OK;
    
    // If we're ending the tracker, then autodetect, but only
    // if the reason for ending the tracker was NOT an IME composition.
    //
    if (_pManager->HaveTypedSinceLastUrlDetect() && 
        ( !pEvent || 
           ( pEvent->GetType() != EVT_IME_STARTCOMPOSITION &&
             pEvent->GetType() != EVT_IME_ENDCOMPOSITION &&
             pEvent->GetType() != EVT_IME_COMPOSITION ) ) )
    {
        UrlAutodetectCurrentWord(NULL);
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }    

    // This is a 'click away' situation, in which we need to fire the 
    // tracker on the current line.  Fire the spring loader settings
    // if the line is empty
    if( psl && pEvent && pEvent->GetType() == EVT_LMOUSEDOWN )
    {
        psl->FireOnEmptyLine();
    }                   
    
    if ( pEvent && _fValidPosition && ( typeNewTracker != TRACKER_TYPE_Control) )
        hr = PositionCaretFromEvent( pEvent );

    TraceTag(( tagSelectionTrackerState, "\n---Caret Tracker: Become Dormant--- "));

    Destroy();                    
    SetState( CR_DORMANT);

    RRETURN( hr );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------


HRESULT 
CCaretTracker::Awaken() 
{
    Assert( IsDormant());

    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CCaretTracker::Destroy()
{
    ClearInterface( & _pBatchPUU);
}

BOOL
CCaretTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    BOOL fShiftKeyDown;

    fShiftKeyDown= pEvent->IsShiftKeyDown();

#ifndef NO_IME
    return _pManager->IsIMEComposition() ||
           ( fShiftKeyDown && ! GetCommandTarget()->IsMultipleSelection() ) ;
#endif // NO_IME
}

//+====================================================================================
//
// Method: OnSetEditContext
//
// Synopsis: A set edit context has happened. Ensure our visibility is correct.
//
//------------------------------------------------------------------------------------


HRESULT 
CCaretTracker::OnSetEditContext( BOOL fContextChange )
{
    if ( ! fContextChange )
    {
        SetCaretShouldBeVisible( ShouldCaretBeVisible() );
    }

    RRETURN( S_OK );
}


HRESULT 
CCaretTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    HRESULT hr;
    
    SP_IHTMLCaret spCaret;

    IFR( GetDisplayServices()->GetCaret(&spCaret) );
    IFR( spCaret->GetLocation(pPoint, fTranslate) );

    return S_OK;    
}



HRESULT
CCaretTracker::Position(
                IDisplayPointer* pDispPointer ,
                IDisplayPointer* pDispEnd)
{
    // Since we don't know where we are coming from, assume that we are at the EOL
    HRESULT hr = THR( PositionCaretAt( pDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None )); 
    
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: AdjustForDeletion
//
// Synopsis: The World has been destroyed around us. Reposition ourselves.
//
//------------------------------------------------------------------------------------


BOOL
CCaretTracker::AdjustForDeletion( IDisplayPointer* pDispPointer )
{
    PositionCaretAt( pDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_None, ADJPTROPT_None );
                    
    return FALSE;
}


//+====================================================================================
//
// Method: OnEditFocusChanged
//
// Synopsis: Change the Visibility of the caret - based on the Edit Focus
//
//------------------------------------------------------------------------------------


VOID
CCaretTracker::OnEditFocusChanged()
{
    SetCaretShouldBeVisible( ShouldCaretBeVisible() );
}

//
//
// Event Handling
//
//
//

//+====================================================================================
//
// Method:      Position Caret At
//
// Synopsis:    Wrapper to place the Caret at a given TreePointer.
//
// WARNING:     You should normally use PositionCaretFromMessage
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::PositionCaretAt( 
    IDisplayPointer         *pDispPointer, 
    CARET_DIRECTION         eDir             /* = CARET_DIRECTION_INDETERMINATE */,
    DWORD                   fPositionOptions /* = POSCARETOPT_None */,
    DWORD                   dwAdjustOptions  /* = ADJPTROPT_None */   )
{
    HRESULT             hr = S_OK;
    CSpringLoader *     psl;
    SP_IHTMLCaret       spCaret;
    BOOL                fResetSpringLoader = FALSE;
    BOOL                fOutsideUrl = ! CheckFlag( dwAdjustOptions , ADJPTROPT_AdjustIntoURL );
    SP_IMarkupPointer   spPointer;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(FALSE);

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    if( _pManager->HaveTypedSinceLastUrlDetect() )
    {
        IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }
    
    psl = GetSpringLoader();
    if (psl)
    {
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );        
        fResetSpringLoader = !psl->IsSpringLoadedAt(spPointer);
    }

    _ptVirtualCaret.InitPosition();
    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    
    if( ! CheckFlag( fPositionOptions, POSCARETOPT_DoNotAdjust ))
    {
        BOOL fAtBOL = FALSE;

        IGNORE_HR( pDispPointer->IsAtBOL(&fAtBOL) );
        IFC( AdjustPointerForInsert( pDispPointer, fAtBOL ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, dwAdjustOptions ));
    }

    SetCaretShouldBeVisible( ShouldCaretBeVisible() );
    IFC( spCaret->MoveCaretToPointerEx( pDispPointer, _fCaretShouldBeVisible , ! _pManager->GetDontScrollIntoView() , eDir ));
    _fCheckedCaretForAtomic = FALSE;

    // Reset the spring loader.
    if (psl)
    {
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );

        if (fOutsideUrl && !fResetSpringLoader && psl->IsSpringLoaded())
        {
            ED_PTR( epTest ); 
            DWORD        dwFound;

            IFC( pDispPointer->PositionMarkupPointer(epTest) );
            IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

            fResetSpringLoader = epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor);
        }
        else if (fResetSpringLoader)
        {
            fResetSpringLoader = !psl->IsSpringLoadedAt(spPointer);
        }

        IGNORE_HR(psl->SpringLoadComposeSettings(spPointer, fResetSpringLoader, TRUE));
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN( hr );
}

//+====================================================================================
//
// Method: CCaretTracker.HandleMessage
//
// Synopsis: Look for Keystrokes and such.
//
//------------------------------------------------------------------------------------


HRESULT
CCaretTracker::HandleEvent(
    CEditEvent* pEvent)
{

    HRESULT hr = S_FALSE;
    IHTMLElement* pIElement = NULL;
    IHTMLElement* pIEditElement = NULL;
    IObjectIdentity * pIdent = NULL;

    Assert ( !IsDormant());

    if ( IsPassive() ) // Caret Tracker is allowed to be passive. We just ignore the message.
        goto Cleanup ;
        
   
    if (_pBatchPUU && ShouldTerminateTypingUndo(pEvent))
        IFC( TerminateTypingBatch() );

    if ( _fValidPosition)
    {
        switch( pEvent->GetType() )
        {
            case EVT_KILLFOCUS:
                IGNORE_HR( _pManager->TerminateIMEComposition( TERMINATE_NORMAL ));
                break;

            case EVT_LMOUSEDOWN:
            case EVT_DBLCLICK :
            case EVT_RMOUSEUP:
            case EVT_RMOUSEDOWN:
#ifdef UNIX
            case EVT_MMOUSEDOWN:
#endif

                hr = THR ( HandleMouse( pEvent  ));

#ifdef UNIX
                if ( pEvent->GetType() == EVT_MMOUSEDOWN )
                    hr = S_FALSE;

#endif


                if (( pEvent->GetType() == EVT_RMOUSEUP ) || 
                    (!_pManager->IsContextEditable() ))
                    hr = S_FALSE;
                break;

            case EVT_KEYPRESS:
                hr = THR( HandleChar( pEvent));
                break;


            case EVT_KEYDOWN:
                hr = THR( HandleKeyDown( pEvent ));
                break;

            case EVT_KEYUP:
                hr = THR( HandleKeyUp( pEvent));
                break;

            case EVT_INPUTLANGCHANGE:
                hr = THR( HandleInputLangChange() );
                break;
        }
    }
    else
    {
        //
        // The Caret is hidden inside a No-Scope or an Element that we can't go inside 
        // ( eg. Image )
        // If we clicked on the same element as our context - don't do anything
        //
        // If we didn't process the mouse down.
        //
        if ( ( pEvent->GetType() == EVT_LMOUSEDOWN ) || 
             ( pEvent->GetType() == EVT_DBLCLICK )  )
        {             
            IFC( pEvent->GetElement( &pIElement) );
            IFC( pIElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent));        
            IFC( _pManager->GetEditableElement( & pIEditElement ));

            if (pIdent->IsEqualObject(pIEditElement) != S_OK)
            {
                hr = THR ( HandleMouse( pEvent ));
            }
            else
                hr = S_FALSE; // Not our event !
        }

    }

Cleanup:
    ReleaseInterface( pIElement );
    ReleaseInterface( pIEditElement );
    ReleaseInterface( pIdent );
    RRETURN1( hr, S_FALSE );

}

//+====================================================================================
//
// Method: HandleChar
//
// Synopsis: Delete the Selection, and cause this tracker to end ( & kill us ).
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleChar(
                    CEditEvent* pEvent)
{
    HRESULT     hr = S_FALSE;
    IHTMLElement * pIElement = NULL;
    IHTMLInputElement* pIInputElement = NULL;
    BSTR bstrType = NULL;
    LONG keyCode ;
    IGNORE_HR( pEvent->GetKeyCode( & keyCode )) ;

    
    // Char codes we DON'T handle go here
    switch( keyCode )
    {
        case VK_BACK:
        case VK_F16:
            hr = S_OK;
            goto Cleanup;
            
        case VK_ESCAPE:
        {
            hr = S_FALSE;
            goto Cleanup;
        }            
    }

    if( keyCode < ' ' && keyCode != VK_TAB && keyCode != VK_RETURN )
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the editable element
    IFC( _pManager->GetEditableElement( &pIElement ) );                                                          

#ifdef FORMSMODE
    if ( IsContextEditable()  && !_pManager->IsInFormsSelectionMode(pIElement))
#else
    if ( IsContextEditable() && ! _pManager->IsEditContextNoScope() )
#endif 
    {
        SP_IHTMLCaret pc;
        OLECHAR t ;
        BOOL fOverWrite = _pManager->GetOverwriteMode();
        IFC( GetDisplayServices()->GetCaret( &pc ));
            
        t = (OLECHAR)keyCode;
        
        if ( !_fCheckedCaretForAtomic )
        {
            SP_IDisplayPointer  spDispCaret;
            SP_IHTMLElement     spAtomicElement;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
            IFC( pc->MoveDisplayPointerToCaret( spDispCaret ));

            IFC( GetCurrentScope(spDispCaret, &spAtomicElement) );
            if ( _pManager->CheckAtomic( spAtomicElement ) == S_OK )
            {
                //  Okay, we need to adjust out of the atomic element since we don't
                //  allow the user to type into atomic elements.
                IFC( AdjustOutOfAtomicElement(spDispCaret, spAtomicElement, RIGHT) );
                IFC( pc->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
            }

            _fCheckedCaretForAtomic = TRUE;
        }

        switch (keyCode)
        {
            case VK_TAB:
            {
                
                if( IsCaretInPre( pc ))
                {
                    t = 9;
                    IFC( InsertText( &t, 1, pc, fOverWrite ));                    
                }
                else
                {
                    hr = S_FALSE;
                }

                break;
            }

            case VK_RETURN:
            {
                IFC( HandleEnter( pEvent, pc, pEvent->IsShiftKeyDown(), pEvent->IsControlKeyDown() ) );
                // Autodetect on space, return, or anyof the character in the string.
                IGNORE_HR( UrlAutodetectCurrentWord( &t ) );
                _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );

                break;
            }
            
            case VK_SPACE:
            {
                IFC( HandleSpace( (OLECHAR) keyCode ));
                break;
            }
            
            default:
            {
                BOOL fAccept = TRUE;

                if(_pManager->HasActiveISC())
                {
                    SP_IMarkupPointer   spPos;
                    MARKUP_CONTEXT_TYPE eCtxt;
                    LONG cch = ISC_BUFLENGTH;
                    OLECHAR aryISCBuffer[ISC_BUFLENGTH];
                    BOOL fPassword = FALSE;

                    IFC( _pManager->GetEditor()->CreateMarkupPointer( & spPos ));
                    IFC( pc->MoveMarkupPointerToCaret( spPos ));
                    IFC( spPos->Left( TRUE, & eCtxt , NULL , &cch , aryISCBuffer ));

                    // paulnel: if we are editing a password field we want to allow any character combination
                    if ( _pManager->GetEditableTagId() == TAGID_INPUT )
                    {
                        IFC( pIElement->QueryInterface (IID_IHTMLInputElement, 
                                                        ( void** ) &pIInputElement ));
                                
                        IFC(pIInputElement->get_type(&bstrType));
            
                        if (!StrCmpIC( bstrType, TEXT("password")))
                        {
                            fPassword = TRUE;
                        }
                    }

                    if(!fPassword)
                        fAccept = _pManager->GetISCList()->CheckInputSequence(aryISCBuffer, cch, t);
                }

                if( fAccept )
                    IFC( InsertText( &t, 1, pc, fOverWrite ));
                    
                break;
            }
        }
    }

Cleanup:

    SysFreeString( bstrType );
    ReleaseInterface( pIInputElement );
    ReleaseInterface( pIElement );

    return hr ;
}

//+====================================================================================
//
// Method: HandleMouseMessage
//
// Synopsis: When we get a mouse message, we move the Caret, and end ourselves.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleMouse(
        CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IHTMLCaret spCaret;
    BOOL fSelect;

#ifndef NO_IME
    if ( _pManager->IsIMEComposition())
    {
        hr = THR( _pManager->HandleImeEvent( pEvent ) );
    }
    else
#endif // NO_IME

    if ( ! pEvent->IsShiftKeyDown() )
    {
        BOOL fAllow = TRUE;
        
        if ( pEvent->GetType() == EVT_RMOUSEUP )
        {
            fAllow = GetEditor()->AllowSelection( GetEditableElement(), pEvent) == S_OK ;               
        }

        if ( fAllow )       
            hr = PositionCaretFromEvent( pEvent );           
    }
    else
    {
        IFC( _pManager->FireOnSelectStart( pEvent, &fSelect , this) );

       if( fSelect )
        {
            SP_IDisplayPointer spDispStart; 
            SP_IDisplayPointer spDispEnd; 
        
            IFC( GetDisplayServices()->CreateDisplayPointer( & spDispStart ));
            IFC( GetDisplayServices()->CreateDisplayPointer( & spDispEnd ));
            IFC( GetDisplayServices()->GetCaret( & spCaret ));
            
            if( ShouldCaretBeVisible() )
            {
                IFC( spCaret->Show( FALSE ) );            
            }
            
            IFC( spCaret->MoveDisplayPointerToCaret( spDispStart ));

            IFC( pEvent->MoveDisplayPointerToEvent( spDispEnd, GetEditableElement(), TRUE ));
            IFC( _pManager->SelectFromShift( spDispStart, spDispEnd ));
        }        
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CCaretTracker::HandleKeyDown(
                CEditEvent* pEvent )
{
    CSpringLoader  * psl;
    HRESULT          hr = S_FALSE;
    SP_IHTMLElement spEditElement ;
    SP_IHTMLElement3 spElement3;
    LONG             eLineDir = LINE_DIRECTION_LeftToRight;
    SP_IDisplayPointer  spDispPointer;
    SP_ILineInfo     spLineInfo;
    LONG keyCode ;
    BOOL             fVertical = FALSE;
    
    IGNORE_HR( pEvent->GetKeyCode(&keyCode ));    

    if ( IsContextEditable() )
    {
        switch(keyCode )
        {
            case VK_BACK:
            case VK_F16:
            {
                // tell the caret which way it is moving in the logical string
                SP_IHTMLCaret       spCaret;
                SP_IMarkupPointer   spPointer;
                SP_IDisplayPointer  spDispCaret;
                SP_IHTMLElement     spListItem;

                BOOL                fDelaySpringLoad = FALSE;
                CEdUndoHelper       undoUnit(_pManager->GetEditor());
                
                IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPointer ));
                
                IFC( GetDisplayServices()->GetCaret( &spCaret ));
    
                IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));

                //
                // Should backspace remove the list item?
                //

                if (ShouldBackspaceExitList(spPointer, &spListItem))
                {
                    IFC( undoUnit.Begin(_pManager->GetOverwriteMode() ? IDS_EDUNDOOVERWRITE : IDS_EDUNDOTYPING) );

                    IFC( ExitList(spListItem) );

                    // May need to scroll 
                    IGNORE_HR( spCaret->ScrollIntoView() ); // ScrollIntoView can return S_FALSE - we want to return S_OK to say we consumed the event                    
                }
                else
                {
                    IFC( BeginTypingUndo(&undoUnit,
                                        _pManager->GetOverwriteMode() ? IDS_EDUNDOOVERWRITE : IDS_EDUNDOTYPING) );

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
                    IFC( spCaret->MoveDisplayPointerToCaret( spDispCaret ));

                    IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));

                    IFC( HandleBackspaceSpecialCase(spPointer) );

                    if (hr == S_FALSE)
                    {
                        IFC( HandleBackspaceAtomicSelection(spPointer) );
                    }

                    // Not a special case, so execute default code
                    if (hr == S_FALSE)
                    {
                        psl = GetSpringLoader();        
                        if (psl)
                        {
                            IFC( MustDelayBackspaceSpringLoad(psl, spPointer, &fDelaySpringLoad) );
                            
                            if (!fDelaySpringLoad)
                                IFC( psl->SpringLoad(spPointer, SL_ADJUST_FOR_INSERT_LEFT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                        }

                        IFC( _pManager->GetEditor()->DeleteCharacter( spPointer , TRUE, pEvent->IsControlKeyDown(), _pManager->GetStartEditContext() ));

                        if (psl && fDelaySpringLoad)
                        {
                            IFC( psl->SpringLoad(spPointer, SL_ADJUST_FOR_INSERT_LEFT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
                        }
                        
                        // F16 (forward DELETE) does not move the caret, hence, we use the same flags. However,
                        // Backspace defaults the the beginning of the line.
                        
                        if( keyCode == VK_BACK )
                        {
                            CEditPointer ep(_pManager->GetEditor());
                            DWORD        dwFound;
                            BOOL         fFoundText;
                            DISPLAY_GRAVITY eDispGravity;

                            // If there is text to the left of the new caret position, we want 
                            // fNotAtBOL == TRUE instead of FALSE
                            IFC( ep->MoveToPointer(spPointer) );
                            IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );

                            fFoundText = ep.CheckFlag(dwFound, BREAK_CONDITION_TEXT);

                            eDispGravity = fFoundText ? DISPLAY_GRAVITY_PreviousLine : DISPLAY_GRAVITY_NextLine;
                            IFC( SetCaretDisplayGravity(eDispGravity) );
                            IFC( spDispCaret->SetDisplayGravity(eDispGravity) );
                        }
                        
                        // Disable auto-detect during backspace
                        _pManager->HaveTypedSinceLastUrlDetect();
                        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        IFC( spDispPointer->MoveToMarkupPointer(spPointer, spDispCaret) );
                        IFC( PositionCaretAt( spDispPointer, CARET_DIRECTION_FORWARD , POSCARETOPT_None, ADJPTROPT_None ));
    
                        if (IsInsideUrl(spPointer))
                        {
                            IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
                            _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
                        }
                        else
                        {
                            _pManager->SetHaveTypedSinceLastUrlDetect( TRUE );
                        }

                    }
                }

                break;
            }

            case VK_ESCAPE:
            {
                if ( _pManager->HasFocusAdorner() )
                {
                    IFC( HandleEscape());
                    goto Cleanup;
                }                    
            }
            break;
            
           
                
            case VK_INSERT: // we should handle this in keydown - sets the appropriate flag
            {
                BOOL newORMode = ! ( _pManager->GetOverwriteMode());
                
                if( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() || pEvent->IsAltKeyDown() )
                {
                    hr = S_FALSE;
                    break;
                }
                
                hr = S_OK;
                _pManager->SetOverwriteMode( newORMode );
                break;
            }

            case VK_TAB:
            {
                //
                // TODO: This is a hack. We have to do this because Trident never gives us
                // the VK_TAB as a WM_CHAR message.
                //
                if( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() || pEvent->IsAltKeyDown() )
                {
                    hr = S_FALSE;
                    break;
                }

                hr = THR( HandleChar( pEvent ));

                break;
            }

#ifndef NO_IME
            case VK_KANJI:
                if (   949 == GetKeyboardCodePage()
                    && _pManager->IsContextEditable())
                {
                    THR(_pManager->StartHangeulToHanja(NULL, pEvent ));
                }
                hr = S_OK;
                break;
#endif // !NO_IME

                // only get line direction if the left or right key are used 
                // this is a performance enhancement 
            case VK_LEFT:
            case VK_RIGHT:
            case VK_UP:
            case VK_DOWN:
            {
                SP_IHTMLCaret       spCaret;
                SP_IDisplayPointer  spDispPointer;
                HRESULT             hr2 = S_FALSE;
                SP_IMarkupPointer   spMarkup;
                SP_IHTMLElement     spElement;

                // alt+VK_LEFT and alt+VK_RIGHT are navigation commands and are not 
                // meant to move the caret. We should return S_FALSE and let trident
                // navigate.

                //
                // We will not deal with Alt+ combinations in any case - zhenbinx
                //
                Assert(VK_PRIOR + 1 == VK_NEXT);
                Assert(VK_NEXT  + 1 == VK_END);
                Assert(VK_END   + 1 == VK_HOME);
                Assert(VK_HOME  + 1 == VK_LEFT);
                Assert(VK_LEFT  + 1 == VK_UP);
                Assert(VK_UP    + 1 == VK_RIGHT);
                Assert(VK_RIGHT + 1 == VK_DOWN);
                if (pEvent->IsAltKeyDown() && (VK_LEFT <= keyCode && keyCode <= VK_DOWN))
                {
                    goto Cleanup;
                }

                hr2 = THR( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( GetDisplayServices()->GetCaret( &spCaret ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spDispPointer->GetLineInfo(&spLineInfo));
                if (hr2)
                    goto Cleanup;

                hr2 = THR( spLineInfo->get_lineDirection(&eLineDir));
                if (hr2)
                    goto Cleanup;

                //
                // Need to get vertical-ness
                //
                IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
                IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                IFC( spMarkup->CurrentScope(&spElement) );
                IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );
                
            }
            // we don't want a break here. Fall through to default 
            default:
            {

                CARET_MOVE_UNIT cmu = GetMoveDirectionFromEvent( pEvent,  (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);
                
                if( cmu != CARET_MOVE_NONE )
                {
                    if( pEvent->IsShiftKeyDown() )
                    {
                        VARIANT_BOOL fRet = VB_TRUE;
                        IFC( _pManager->GetEditableElement( &spEditElement ));
                        if (spEditElement)
                        {
                            hr = THR(spEditElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                            if (!hr)
                               hr = THR(spElement3->fireEvent(_T("onselectstart"), NULL, &fRet));
                        }

                        if (!!hr || fRet)
                        {
                            hr = _pManager->StartSelectionFromShift( pEvent );
                            _pManager->_fEnsureAtomicSelection = TRUE;
#ifndef NO_IME
                            if (_pManager->IsIMEComposition())
                            {
                                _pManager->TerminateIMEComposition(TERMINATE_NORMAL);
                            }
#endif // NO_IME
                        }                            
                    }
                    else
                    {
                        SP_IMarkupPointer  spOrigCaretPointer;
                        SP_IDisplayPointer spDispPointer;
                        SP_IHTMLElement    spAtomicElement;
                        SP_IHTMLCaret      spCaret;
                        BOOL               fStartIsAtomic = FALSE;
                        
                        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
                        IFC( GetDisplayServices()->GetCaret( &spCaret ));
                        IFC( GetEditor()->CreateMarkupPointer(&spOrigCaretPointer) );
                        IFC( spCaret->MoveMarkupPointerToCaret(spOrigCaretPointer) );

                        //  Check the atomic selection setting for the element we are orininally in.
                        if (cmu == CARET_MOVE_BACKWARD || cmu == CARET_MOVE_WORDBACKWARD)
                        {
                            IFC( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                            IFC( GetCurrentScope(spDispPointer, &spAtomicElement) );
                            fStartIsAtomic = ( _pManager->CheckAtomic(spAtomicElement) == S_OK );
                        }

                        //  Move the caret.
                        IFC( MoveCaret(pEvent, cmu, spDispPointer, TRUE) );
                 
                        //  See if we moved the caret into an atomic selected element.
                        //  Adjust if we need to.
                        IFC( spCaret->MoveDisplayPointerToCaret( spDispPointer ));
                        IFC( GetCurrentScope(spDispPointer, &spAtomicElement) );
                        if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
                        {
                            //  We moved into an atomic element.  So we now want to select the
                            //  atomic element rather than reposition the caret outside of it.
                            if ((cmu != CARET_MOVE_BACKWARD && cmu != CARET_MOVE_WORDBACKWARD) || fStartIsAtomic)
                            {
                                hr = THR( _pManager->StartAtomicSelectionFromCaret( spDispPointer ) );

                                //
                                // Set _ptVirtualCaret for SelectTracker
                                //
                                if (SUCCEEDED(hr))
                                {
                                    SP_IMarkupPointer   spMarkup;
                                    POINT               ptLoc;

                                    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spMarkup) );
                                    IFC( spDispPointer->PositionMarkupPointer(spMarkup) );
                                    IFC( _ptVirtualCaret.GetPosition(spMarkup, &ptLoc) );
                                    Assert( _pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Selection);                                    
                                    IFC( _pManager->GetActiveTracker()->GetVirtualCaret().UpdatePosition(spMarkup, ptLoc) ); 
                                }
                                goto Cleanup;
                            }
                            else
                            {
                                SP_IMarkupPointer   spPointer;
                                BOOL                fAtOutsideEdge = FALSE;

                                IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
                                IFC( spPointer->MoveAdjacentToElement( spAtomicElement, ELEM_ADJ_AfterEnd) );
                                IFC( spPointer->IsEqualTo(spOrigCaretPointer, &fAtOutsideEdge) );

                                if (!fAtOutsideEdge)
                                {
                                    SP_IDisplayPointer  spDispCaret;

                                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
                                    IFC( spDispCaret->MoveToMarkupPointer(spPointer, NULL) );
                                    IFC( spCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
                                }
                            }

                            _pManager->_fEnsureAtomicSelection = TRUE;
                        }
                    }
                }
                break;
            }
        }

        //
        // Direction keys
        //
        if (S_FALSE == hr)
        {
            hr = HandleDirectionalKeys(pEvent);
        }
    }
    //
    // Not editable case
    // this is possible for a viewlink/iframe with contents not editable
    // but we have the focus adorner
    //
    else if ( keyCode == VK_ESCAPE &&
              _pManager->HasFocusAdorner())
    {
        IFC( HandleEscape());
    }

Cleanup:


    return( hr );
}

HRESULT
CCaretTracker::HandleEscape()
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spEditElement ;
    SP_IMarkupPointer spStartCaret;
    SP_IMarkupPointer spEndCaret;
    CSelectionChangeCounter selCounter(_pManager);
    
    //
    // If we're in a UI Active control - we site select it.
    //
    SP_IDisplayPointer spDispStartCaret;
    SP_IDisplayPointer spDispEndCaret;
    
    //
    // We create 2 pointers, move them around the control, Position the Temp Markup Pointers
    // and then Site Select the Control
    //
    IFC( GetEditor()->CreateMarkupPointer( & spStartCaret ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndCaret ));
    IFC( _pManager->GetAdornedElement( & spEditElement ));
   
    IFC( spStartCaret->MoveAdjacentToElement( spEditElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEndCaret->MoveAdjacentToElement( spEditElement, ELEM_ADJ_AfterEnd ));

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStartCaret) );
    IFC( spDispStartCaret->MoveToMarkupPointer(spStartCaret, NULL) );
    IFC( spDispStartCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndCaret) );
    IFC( spDispEndCaret->MoveToMarkupPointer(spEndCaret, NULL) );
    IFC( spDispEndCaret->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    

    IFC( GetEditor()->MakeParentCurrent( spEditElement ));

    selCounter.BeginSelectionChange();
    IFC( _pManager->PositionControl( spDispStartCaret, spDispEndCaret )); 
    selCounter.EndSelectionChange();
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CCaretTracker::HandleKeyUp(
                CEditEvent* pEvent )
{
    return HandleDirectionalKeys(pEvent);
}

//+====================================================================================
//
// Method: HandleInputLangChange
//
// Synopsis: Update the screen caret to reflect change in keyboard language
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleInputLangChange()
{
    HRESULT hr = S_FALSE;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    

    if ( IsContextEditable() )
    {
        BOOL fVisible;

        IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPointer  ));                        
        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->IsVisible(&fVisible) );
        if (fVisible)        
        {
            //
            // force an update caret to handle shape change
            //
            IGNORE_HR( spCaret->Show(FALSE /* fScrollIntoView */) );
        }
        hr = S_OK;
    }

    // Something seems to be missing here...
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: HandleEnter
//
// Synopsis: Handle the enter key
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::HandleEnter( CEditEvent* pEvent, IHTMLCaret * pCaret, BOOL fShift, BOOL fCtrl )
{
    HRESULT             hr = S_FALSE;
    IMarkupServices *   pMarkupServices = _pManager->GetMarkupServices();
    SP_IMarkupPointer   spPos;
    SP_IMarkupPointer   spNewPos;
    SP_IHTMLElement     spFlowElement;
    VARIANT_BOOL        bHTML;
    VARIANT_BOOL        bMultiLine = VARIANT_FALSE;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement3    spElement3;
    CSpringLoader       *pSpringLoader = NULL;
    CEdUndoHelper       undoUnit(_pManager->GetEditor());
    SP_IDisplayPointer  spDispNewPos;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    //
    // Position a worker pointer at the current caret location. Then
    // check to see if we are in a multi-line flow element.
    //
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spPos ));
    IFC( pCaret->MoveMarkupPointerToCaret( spPos ));
    IFC( GetEditor()->GetFlowElement( spPos, &spFlowElement ));
    if ( ! spFlowElement )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC(spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->get_isMultiLine(&bMultiLine));
    if (!bMultiLine)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the spring loader
    pSpringLoader = GetSpringLoader();

#ifndef NO_IME
    if (_pManager->IsIMEComposition())
    {
        _pManager->TerminateIMEComposition( TERMINATE_NORMAL, pEvent );
    }
#endif // NO_IME

    //
    // Check to see if we can contain HTML. If not, just insert a \r.
    //

    IFC(spElement3->get_canHaveHTML(&bHTML));


    if (bHTML && !fShift && ShouldEnterExitList(spPos, &spElement))
    {
        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );

        IFC( ExitList(spElement) );

        // May need to scroll 
        IGNORE_HR( pCaret->ScrollIntoView() ); // ScrollIntoView can return S_FALSE - we want to return S_OK to say we consumed the event                    
        goto Cleanup;            
    }
    else
    {
        IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

        if (!bHTML)
        {
            IFC( spPos->SetGravity( POINTER_GRAVITY_Right ));
            IFC( pCaret->InsertText(_T("\r"),1));

            spNewPos = spPos;
        }
        else
        {
            if( fShift )
            {                  
                CEditPointer    ep(GetEditor());
                DWORD           dwFound;
                
                // Fire the spring loader before inserting the <BR>
                if( pSpringLoader != NULL )
                {
                    pSpringLoader->Fire(spPos);
                }
        
                IFC( pMarkupServices->CreateElement( TAGID_BR, NULL, &spElement ));
                IFC( InsertElement(pMarkupServices, spElement, spPos, spPos ));
                IFC( _pManager->GetEditor()->CreateMarkupPointer( &spNewPos ));
                IFC( spNewPos->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ));                    

                // TODO: use inflate block 

                //
                // Check for </BlockElement>.  If found, make sure breakonempty is set.
                //

                IFC( ep->MoveToPointer(spNewPos) );
                IFC( ep.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement, NULL, NULL, SCAN_OPTION_SkipWhitespace) );

                if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock) && !ep.CheckFlag(dwFound, BREAK_CONDITION_Site))
                {
                    ELEMENT_TAG_ID tagId;

                    IFC( pMarkupServices->GetElementTagId(spElement, &tagId) );
                    if (!IsListContainer(tagId) && tagId != TAGID_LI)
                    {
                        SP_IHTMLElement3 spElement3;
                        
                        IFC( spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                        IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                    }                
                }
            }
            else
            {
                CEditPointer epTest(GetEditor());
                DWORD        dwSearch, dwFound;
                
                // Fire the spring loader on empty lines
                if( pSpringLoader != NULL )
                {
                    pSpringLoader->FireOnEmptyLine( spPos, TRUE );
                }

                //
                // If we have glyphs turned on, we can get inbetween block elements.  So
                // to be compat with fontpage, we check for this case and adjust into the
                // block element on the left.
                //
                // For example, we could end up with </P>{caret}<P>.
                //
                // In this case, we want to adjust into blocks so that we have {caret}</P><P>
                //
                
                IFC( epTest->MoveToPointer(spPos) );

                dwSearch = BREAK_CONDITION_Content | BREAK_CONDITION_Glyph;
                
                IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
                if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_Glyph) 
                    || !epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {
                    IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
                }

                if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Glyph) 
                    && epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
                {       
                    SP_IDisplayPointer spDispPos;

                    //
                    // We are between blocks due to glyphs, so adjust for insert.
                    //

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
                    IFC( pCaret->MoveDisplayPointerToCaret(spDispPos) );

                    // Frontpage compat
                    IFC( spDispPos->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

                    // Adjust pointer
                    IFC( GetEditor()->AdjustPointer(
                        spDispPos, LEFT, LEFT, _pManager->GetStartEditContext(), _pManager->GetEndEditContext(), 0));

                    IFC( spDispPos->PositionMarkupPointer(spPos) );
                }
                
                //
                // Handle enter
                //
                
                IFC( _pManager->GetEditor()->HandleEnter( spPos, &spNewPos, pSpringLoader ));
            }    
        }

    }
    //
    // Move the caret to the new location.
    // We know we are going right and are visible, if ambiguious, 
    // we are at the beginning of the inserted line
    //

    IFC( SetCaretDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    
    IFC( ConstrainPointer( spNewPos ));
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispNewPos) );
    IFC( spDispNewPos->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispNewPos->MoveToMarkupPointer(spNewPos, NULL) );
    
    IFC( pCaret->MoveCaretToPointer( spDispNewPos, TRUE, CARET_DIRECTION_FORWARD));
    _fCheckedCaretForAtomic = FALSE;

    if(pSpringLoader && spNewPos)
        pSpringLoader->Reposition(spNewPos);

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN1(hr, S_FALSE);
}


HRESULT
CCaretTracker::PositionCaretFromEvent(
                CEditEvent* pEvent )
{
    IDisplayPointer * pDispPointer = NULL;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    SP_IHTMLElement spEditElement;
    SP_IHTMLElement spHitTestElement;
    
    HRESULT hr = S_OK;

    if ( pEvent )
    {
        //
        // We may require the caret to become visible again, but we should only
        // move on button down
        //
        if ( ( pEvent->GetType() == EVT_LMOUSEDOWN ) || 
             ( pEvent->GetType() == EVT_LMOUSEUP ) ||
             ( pEvent->GetType() == EVT_RMOUSEUP ) 
#ifdef UNIX
                || ( pEvent->GetType() == EVT_MMOUSEDOWN )
#endif
            )
        {
#ifdef FORMSMODE
            if (_pManager->IsInFormsSelectionMode())
                goto Cleanup;
#endif             
            hr = THR( GetDisplayServices()->CreateDisplayPointer( & pDispPointer));
            if ( hr )
                goto Cleanup;
            
            IFC( pEvent->GetElement( & spEditElement ));
            IFC( GetLayoutElement( GetMarkupServices(), spEditElement, & spHitTestElement ));

            //
            // Just in case move the mouse into a different edit context between
            // and rbutton-down and rbutton-up
            // 
            IFC( _pManager->EnsureEditContextClick( spEditElement ) );
            
            hr = THR( pEvent->MoveDisplayPointerToEvent( pDispPointer, spHitTestElement ));
            if( hr ) 
            {
                _fValidPosition = FALSE;
                goto Cleanup;
            }

            //
            // IEV6-14696-zhenbinx-10/17/2000
            // The element might not be editable. This could happen if 
            // a noneditable element is inside edit context.  RMOUSEDOWN 
            // setup the edit context and RMOUSEUP will try to position the caret.
            //
            if (EdUtil::IsEditable(spEditElement) == S_FALSE)
            {
                _fValidPosition = FALSE;
                goto Cleanup;
            }
                
            hr = PositionCaretAt( pDispPointer, CARET_DIRECTION_FORWARD, POSCARETOPT_None, ADJPTROPT_None );
            if ( hr )
                goto Cleanup;
        }
        else
        {
            SetCaretShouldBeVisible ( ShouldCaretBeVisible() );
        }
        
        IFC( pEvent->GetTagId( &eTag));
    }    

Cleanup:
    ReleaseInterface( pDispPointer );
    RRETURN ( hr );
}

//
//
// Typing & Undo
//
//
//
//+====================================================================================
//
// Method: HandleSpace
//
// Synopsis: Handle conversion of spaces to NBSP.
//
//------------------------------------------------------------------------------------



HRESULT
CCaretTracker::HandleSpace( OLECHAR t )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer   spPos;
    SP_IHTMLCaret pc;
    CEdUndoHelper undoUnit(_pManager->GetEditor()); 

    BOOL fOverWrite = _pManager->GetOverwriteMode();
    IFC( GetDisplayServices()->GetCaret( &pc ));

    //
    // Only insert nbsp if the container can accept html and isn't in a PRE tag
    //
    if( _pManager->CanContextAcceptHTML() && ! IsCaretInPre( pc ) )
    {
        ED_PTR( spPos ) ;
        DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
        DWORD dwFound = BREAK_CONDITION_None;                    
        OLECHAR chTest;

        IFC( pc->MoveMarkupPointerToCaret( spPos ));
        IFC( spPos.Scan( LEFT , dwSearch , &dwFound , NULL , NULL , & chTest , NULL ));
        
        if( spPos.CheckFlag( dwFound, BREAK_CONDITION_Text ) && chTest == 32 )
        {    
            IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

            //
            // there is a space to the left of us, delete it and insert
            // "&nbsp "
            //
            
            SP_IMarkupPointer spCaret;
            OLECHAR t2[2];
            t2[0] = 160;
            t2[1] = 32;
            
            IFC( _pManager->GetEditor()->CreateMarkupPointer( & spCaret ));
            IFC( pc->MoveMarkupPointerToCaret( spCaret ));
            IFC( _pManager->GetMarkupServices()->Remove( spCaret, spPos ));
            IFC( InsertText( t2, 2, pc ));                    

            goto Cleanup;
            
        }
        else if( spPos.CheckFlag( dwFound, BREAK_CONDITION_TEXT - BREAK_CONDITION_Text ) ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_Site )                        ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_Block )                       ||
                 spPos.CheckFlag( dwFound, BREAK_CONDITION_NoScopeBlock ) )

        {
            //
            // There is an image, control, block or site to the left of us
            // so we should insert an &nbsp
            //

            t = 160;
        }
        else
        {
            //
            // plain text or nbsp to my left, look right. If there is a space to my right,
            // insert an nbsp.
            //
            
            IFC( pc->MoveMarkupPointerToCaret( spPos ));
            dwFound = BREAK_CONDITION_None;
            IFC( spPos.Scan( RIGHT , dwSearch , &dwFound , NULL , NULL , & chTest , NULL ));

            if( spPos.CheckFlag( dwFound, BREAK_CONDITION_Text ) && chTest == 32 )
            {
                OLECHAR chNBSP = 160;

                IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );
    
                CEditPointer epStart(_pManager->GetEditor());
                
                // there is a space to our right, we should replace it with an nbsp

                IFC( GetMarkupServices()->InsertText(&chNBSP, 1, spPos) );
                IFC( epStart->MoveToPointer(spPos) );
                IFC( epStart.Scan( LEFT, dwSearch , &dwFound , NULL , NULL , NULL , NULL ));
                Assert(epStart.CheckFlag(dwFound, BREAK_CONDITION_Text));
                IFC( GetMarkupServices()->Remove(epStart, spPos) );
            }
            
        }

    }

    IFC( InsertText( &t, 1, pc, fOverWrite ));

Cleanup:
    RRETURN( hr );
}
          

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ShouldTerminateTypingUndo, private
//
//  Synopsis:   Decides when to terminate the current typing batch undo unit.
//              Tries to emulate word insert loop behavior.
//
//  Arguments:  [pMessage] - current selection message
//
//  Returns:    BOOL - whether or not to terminate
//
//----------------------------------------------------------------------------

BOOL
CCaretTracker::ShouldTerminateTypingUndo(CEditEvent* pEvent )
{
    CARET_MOVE_UNIT cmu;
    LONG keyCode;
    
    //
    // We try to emulate the word model of undo batching by terminating
    // undo on the following messages.
    //

    switch (pEvent->GetType() )
    {
        case EVT_KEYDOWN:
            // Terminate for special chars
            IGNORE_HR( pEvent->GetKeyCode( & keyCode ));
            switch ( keyCode )
            {
                case VK_ESCAPE:
                case VK_INSERT:
                case VK_TAB:                
                    return TRUE;
            }

            // Terminate undo for keynav case
            cmu = GetMoveDirectionFromEvent( pEvent, FALSE /* fRightToLeft */, FALSE /*fVertical*/);
            return (cmu != CARET_MOVE_NONE);
       
        case EVT_KEYPRESS:

            IGNORE_HR( pEvent->GetKeyCode(& keyCode));
            if (keyCode < ' ' && keyCode != VK_RETURN && keyCode != VK_BACK)
                return TRUE;

            return FALSE;
       
        case EVT_MOUSEMOVE:
        case EVT_TIMER:
        case EVT_KEYUP:
            return FALSE;
    }

    return TRUE;    
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::BeginUndoUnit, private
//
//  Synopsis:   Ensures we have a typing batch undo unit on the
//              top of the undo stack and then begins the undo unit.
//
//  Arguments:  [pUndoUnit]  - undo unit manager
//              [uiStringID] - resource id for the undo unit
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CCaretTracker::BeginTypingUndo(CEdUndoHelper *pUndoUnit, UINT uiStringID)
{
    HRESULT hr = S_OK;
    SP_IOleUndoManager spUndoMgr;;
    
    Assert( pUndoUnit );

    //
    // If the current batch parent undo unit is not on the top of the
    // stack, we can't batch.
    //

    if (_pBatchPUU && !_pBatchPUU->IsTopUnit())
    {
        _pBatchPUU->Release();
        _pBatchPUU = NULL;
    }

    //
    // Create a new parent undo unit if there isn't one we can reuse
    //

    if (!_pBatchPUU)
    {
        _pBatchPUU = new CBatchParentUndoUnit(_pManager->GetEditor(), uiStringID);
        if (!_pBatchPUU)
            RRETURN(E_OUTOFMEMORY);

        //
        // Create and commit an empty batch undo unit.  The begin call below
        // will cause the proxy to add to this undo unit.
        //
        IFC( _pManager->GetEditor()->GetUndoManager( & spUndoMgr ));        
        IFC( spUndoMgr->Open(_pBatchPUU) );
        IFC( spUndoMgr->Close(_pBatchPUU, TRUE) );
    }        

    IFC( pUndoUnit->Begin(uiStringID, _pBatchPUU) );
    
Cleanup:
    RRETURN(hr);    
}


HRESULT
CCaretTracker::InsertText( 
    OLECHAR    *    pText,
    LONG            lLen,
    IHTMLCaret *    pc,
    BOOL            fOverWrite)
{
    HRESULT             hr = S_OK;
    CSpringLoader       * psl = NULL;
    SP_IMarkupPointer   spStartPosition;
    SP_IMarkupPointer   spCaretPosition;

    Assert(pText && pc);

    CEdUndoHelper undoUnit(_pManager->GetEditor()); 

    IFC( BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) );

    IFC( GetEditor()->CreateMarkupPointer( & spCaretPosition ));
    IFC( pc->MoveMarkupPointerToCaret( spCaretPosition ));

    if (fOverWrite)
    {
        IFC( DeleteNextChars(spCaretPosition, lLen) );
    }

    // Get the spring loaded state
    psl = GetSpringLoader();

    // If whitespace, make sure we fall out of the current URL (if any)
    if (pText && (lLen >= 1 || lLen == -1) && IsWhiteSpace(*pText) && pc)
    {
        ED_PTR( ep); 
        DWORD        dwFound;

        // A failure here should not abort the text insertion
        hr = THR( pc->MoveMarkupPointerToCaret(ep) );            
        if (SUCCEEDED(hr))
        {
            SP_IHTMLElement spElement; 
        
            hr = THR( ep.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );
            if (SUCCEEDED(hr) 
                && ep.CheckFlag(dwFound, BREAK_CONDITION_ExitAnchor)
                && IsQuotedURL(spElement) == S_FALSE)
            {
                SP_IDisplayPointer spDispPointer;
                
                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                IFC( spDispPointer->MoveToMarkupPointer(ep, NULL) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                
                hr = THR( pc->MoveCaretToPointer(spDispPointer, FALSE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE) );
                _fCheckedCaretForAtomic = FALSE;

                // Can't trust spring loaded space from inside the anchor,
                // so reset
                if (SUCCEEDED(hr) && psl)
                    psl->Reset();
            }
        }
    }

    // Fire the spring loader at the caret position.
    if (psl && psl->IsSpringLoaded())
    {
        IFC( GetEditor()->CreateMarkupPointer( & spStartPosition ));
        IFC( pc->MoveMarkupPointerToCaret( spStartPosition) );        

        IFC( pc->InsertText( pText , lLen ) );

        IFC( pc->MoveMarkupPointerToCaret( spCaretPosition ));
        IGNORE_HR(psl->Fire( spStartPosition, spCaretPosition, FALSE ));
    }
    else
    {
        IFC( pc->InsertText( pText , lLen ) );
    }

    IFC( SetCaretDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    // Update the IME Position if a composition is in progress
    if( _pManager->IsIMEComposition() )
    {
        _pManager->UpdateIMEPosition();
    }
           
    // Autodetect on space, return, or anyof the character in the string.
    if( VK_TAB == (DWORD) pText[0]
        || VK_SPACE == (DWORD) pText[0] 
        || IsInsideUrl(spCaretPosition))
    {
        IGNORE_HR( UrlAutodetectCurrentWord( pText ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }
// t-amolke (06/01/99) - The following piece of code was commented out: Now URL autodetection will not occur
// on quote, but only on white space. Also, quotes around URLs seems to work properly without this code.
#if 0
else if (_T('"') == pText[0]
             || _T('>') == pText[0])
    {
        ED_PTR( ep );         
        DWORD        dwFound;
        
        // Before we autodetect again on a quote, make sure we don't have an url to the left of us.
        // This behavior will allow the user to add quotes around a url without them being deleted.

        IFC( pc->MoveMarkupPointerToCaret(ep) );
        IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // skip quote
        Assert(ep.CheckFlag(dwFound, BREAK_CONDITION_Text)); 

        IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // find out what is left of the quote

        if (!ep.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IGNORE_HR( UrlAutodetectCurrentWord( pText ) );
            _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
        }        
    }
#endif
    else
    {
        _pManager->SetHaveTypedSinceLastUrlDetect( TRUE );
    }

    if (pc)
    {
        pc->SetCaretDirection(CARET_DIRECTION_FORWARD);
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CCaretTracker::HandleBackspaceSpecialCase(IMarkupPointer *pPointer)
{
    HRESULT         hr;
    ED_PTR( epTest );     
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    DWORD           dwOptions = SCAN_OPTION_None;
    
    Assert(pPointer);

    //
    // If we backspace at the edge of an anchor, remove the anchor
    //
    
    IFR( epTest->MoveToPointer(pPointer) );

    //
    // If backspace is hit right after url autodetection, then we will 
    // allow whitespace
    //

    Assert(GetEditor()->GetAutoUrlDetector());
    
    if (!GetEditor()->GetAutoUrlDetector()->UserActionSinceLastDetection())
    {
        dwOptions |= SCAN_OPTION_SkipWhitespace;
    }

    //
    // Look for the anchor to remove
    //

    IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement, NULL, NULL, dwOptions) ); 
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
    {
        CEdUndoHelper undoUnit( _pManager->GetEditor() );

        undoUnit.Begin( IDS_EDUNDOTEXTDELETE );
        IFR( GetMarkupServices()->RemoveElement(spElement) );
        _pManager->SetHaveTypedSinceLastUrlDetect(TRUE);
        
        return S_OK;
    }

    return S_FALSE; // not a special case
    
}

HRESULT
CCaretTracker::TerminateTypingBatch()
{
    if (_pBatchPUU)
    {
        _pBatchPUU->Release();
        _pBatchPUU = NULL;
    }

    return S_OK;
}  

//+----------------------------------------------------------------------------
//
//  Function:   UrlAutoDetectCurrentWord
//
//  Synopsis:   Performs URL autodetection on the current word (ie, around
//      or just prior to the caret). 
//      Note: Autodetection is not always triggered by a character (can
//      be by caret movement, etc.).  In this case, pChar should be NULL,
//      and some rules are different.
//
//  Arguments:  [pChar]     The character entered that triggered autodetction.
//
//  Returns:    HRESULT     S_OK if everything's cool, otherwise error
//
//-----------------------------------------------------------------------------
HRESULT
CCaretTracker::UrlAutodetectCurrentWord( OLECHAR *pChar )
{
    HRESULT                 hr              = S_OK;
    IHTMLCaret          *   pc              = NULL;
    IHTMLElement        *   pElement        = NULL;
    IHTMLElement        *   pAnchor         = NULL;
    IMarkupServices     *   pms             = _pManager->GetMarkupServices();
    IMarkupPointer      *   pmp             = NULL;
    IMarkupPointer      *   pLeft           = NULL;
    BOOL                    fFound          = FALSE;
    BOOL                    fLimit          = FALSE;
    AUTOURL_REPOSITION      aur;

    if( IsContextEditable() )
    {
        hr = THR( GetDisplayServices()->GetCaret( &pc ) );
        if( hr )
            goto Cleanup;

        hr = THR( GetEditor()->CreateMarkupPointer( &pmp ) );
        if( hr )
            goto Cleanup;

        hr = THR( GetEditor()->CreateMarkupPointer( &pLeft ) );
        if( hr )
            goto Cleanup;

        hr = THR( pc->MoveMarkupPointerToCaret( pmp ) );
        if( hr )
            goto Cleanup;

        if( pChar )
        {    
            hr = THR( pmp->MoveUnit( MOVEUNIT_PREVCHAR ) );
            if( hr )
                goto Cleanup;

            if( VK_RETURN == *pChar )
            {
                pChar = NULL;
            }
            else 
            {
                fLimit = ( _T('"') == *pChar ||
                           _T('>') == *pChar );

                if( fLimit )
                {
                    // If we're in an anchor, don't limit because of a quote.
                    IFC( pmp->CurrentScope( &pElement ) );

                    IFC( FindTagAbove( pms, pElement, TAGID_A, &pAnchor ) );
                    fLimit = !pAnchor;
                }
            }
        }

        // Position left to our current position
        hr = THR( pLeft->MoveToPointer( pmp ) );
        if( hr ) 
            goto Cleanup;

        // Fire off the autodetection
        hr = THR( _pManager->GetEditor()->GetAutoUrlDetector()->DetectCurrentWord( pmp, pChar, &aur, fLimit ? pmp : NULL, pLeft, &fFound ) );
        if( hr )
            goto Cleanup;

        if ( aur != AUTOURL_REPOSITION_No )
        {
            ED_PTR( epAdjust ); 
            DWORD        dwSearch = BREAK_CONDITION_OMIT_PHRASE;
            DWORD        dwFound;
            Direction    eTextDir;
            SP_IDisplayPointer spDispAdjust;
            SP_IDisplayPointer spDispLine;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispLine) );
            IFC( pc->MoveDisplayPointerToCaret( spDispLine ) );            
            IFC( pc->MoveMarkupPointerToCaret( epAdjust ) );
            
            eTextDir = ( aur == AUTOURL_REPOSITION_Inside ) ? LEFT : RIGHT;

            IFC( epAdjust.Scan(eTextDir, dwSearch - BREAK_CONDITION_Anchor, &dwFound) );
            if (epAdjust.CheckFlag(dwFound, dwSearch))
            {
                IFC( epAdjust.Scan(Reverse(eTextDir), dwSearch, &dwFound) );
            }

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjust) );
            IFC( spDispAdjust->MoveToMarkupPointer(epAdjust, spDispLine) );

            if (hr == S_FALSE)
            {
                IFC( spDispAdjust->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
            }
            
            IFC( pc->MoveCaretToPointer( spDispAdjust, TRUE, CARET_DIRECTION_INDETERMINATE ));
            _fCheckedCaretForAtomic = FALSE;
        }
    } 
Cleanup:

    ReleaseInterface( pc );
    ReleaseInterface( pmp );
    ReleaseInterface( pElement );
    ReleaseInterface( pAnchor );
    ReleaseInterface( pLeft );

    RRETURN( hr );
}


HRESULT
CCaretTracker::DeleteNextChars(
    IMarkupPointer *    pPos,
    LONG                lLen)
{
    HRESULT hr = S_OK;
    LONG cch;
    OLECHAR chTest = 0;
    MARKUP_CONTEXT_TYPE eCtxt;
    SP_IMarkupPointer spEnd;
    SP_IHTMLElement spElement;
    BOOL fDone = FALSE;
    
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    if( pPos )
    {
        IFC( spEnd->MoveToPointer( pPos ));
    }
    else
    {
        SP_IHTMLCaret pc;
        IFC( GetDisplayServices()->GetCaret( & pc ));
        IFC( pc->MoveMarkupPointerToCaret( spEnd ));
    }

    while( ! fDone)
    {
        cch = lLen;
        IFC( spEnd->Right( TRUE, & eCtxt , & spElement , & cch , & chTest ));

        switch( eCtxt )
        {
            case CONTEXT_TYPE_Text:
                if( cch >= 1 )
                {
                    //
                    // If we hit a \r, we essentially hit a block break - we are done
                    //
                    
                    if( chTest != '\r' )
                    {                    
                        //
                        // Passed over a character, back up, move a markup pointer to 
                        // the start, and jump the end to the next cluster end point.
                        //
                        SP_IMarkupPointer spStart;
                        
                        
                        IFC( spEnd->Left( TRUE, & eCtxt , NULL , & cch , & chTest ));
                        Assert( eCtxt == CONTEXT_TYPE_Text );
                        IFC( _pManager->GetEditor()->CreateMarkupPointer( & spStart ));
                        IFC( spStart->MoveToPointer( spEnd ));
                        IFC( spEnd->MoveUnit( MOVEUNIT_NEXTCLUSTEREND )); 
                        IFC( _pManager->GetMarkupServices()->Remove( spStart, spEnd ));
                        lLen -= cch;
                        Assert(lLen >= 0);
                        fDone = (lLen <= 0);
                    }
                    else
                    {
                        fDone = TRUE;
                    }
                }
                break;
                
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            {
                BOOL fLayout, fBlock;
                IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout));

                fDone = fLayout || fBlock;    // we are done if we hit a layout...
                break;
            }

            default:
                break;
        }
    }

Cleanup:
    RRETURN( hr );
}

//
//
// Utilities & Privates 
//
//

BOOL
CCaretTracker::IsContextEditable()
{

#if 0 // BUBBUG: This breaks HTMLDialogs due to their wacky select code
    BOOL fOut = FALSE;
    HRESULT hr = S_OK;
    SP_IHTMLCaret spCaret;
    
    IFC( GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->IsVisible( & fOut ));
    fOut = fOut && _pManager->IsContextEditable();
Cleanup:
    return fOut;
#else
    return _pManager->IsContextEditable() && (_fCaretShouldBeVisible || _pManager->HasFocusAdorner());
#endif
}

BOOL CCaretTracker::IsCaretInPre( IHTMLCaret * pCaret )
{
    HRESULT             hr = S_OK;
    BOOL                fPre;
    SP_IMarkupPointer   spPointer;
    
    IFC( _pManager->GetEditor()->CreateMarkupPointer( & spPointer ));
    IFC( pCaret->MoveMarkupPointerToCaret( spPointer ));
    IFC( GetEditor()->IsPointerInPre(spPointer, &fPre) );
    
    return fPre;

Cleanup:
    return FALSE;
}

HRESULT 
CCaretTracker::IsQuotedURL(IHTMLElement *pAnchorElement)
{
    HRESULT         hr;
    ED_PTR( ep); 
    TCHAR           ch = 0;
    DWORD           dwFound;

    IFC( ep->MoveAdjacentToElement(pAnchorElement, ELEM_ADJ_BeforeBegin) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, NULL, NULL, &ch) );

    hr = S_FALSE; // not quoted
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Text) && (ch == '"' || ch == '<'))
    {
        hr = S_OK;
    }    

Cleanup:
    RRETURN1(hr, S_FALSE);
}




//+---------------------------------------------------------------------------+
//
//
//  Synopsis: Get the caret moving direction based on 
//                  Key Event
//                  Control State
//                  Vertical
//                  RightToLeft     //  Reading Order of current paragraph
//          
//+---------------------------------------------------------------------------+
/*
    Remark:
            Caret Positioning in Mixed Latin and Bidi environment
            -- based on paper by AlexMo  (zhenbinx)
  
            CP  denotes the character position of the character after the caret
            fBeforeCP is 
                TRUE when the caret is located "before" the current character
                FALSE when the caret is located "after" the preceding character
  
  
            Hit Testing

            Reading order   Horizontal Half of Char.    CP Selected     fBeforeCP
            LTR             Left                        CP              TRUE
            LTR             Right                       CP+1            FALSE
            RTL             Left                        CP+1            FALSE
            RTL             Right                       CP              TRUE


            Cursor Movement
            
            Reading order       Arrow Direction     CP Selection    fBeforeCP
            LTR                 Left - backward     CP - 1          TRUE
            LTR                 Right - forward     CP + 1          FALSE
            RTL                 Left - forward      CP + 1          FALSE
            RTL                 Right - backward    CP - 1          TRUE


            The basic idea of cursor movement is that when the cursor is advanced
            over certain character using the arrow keys, we want to keep the
            caret closer to that character. 

            Note that with arrow movement, the reading order of the current run  
            is not relevant. The reading order of the current paragraph decides 
            whether left arrow moves forward or backward. 
  
            The same logic can be extended to other cursor movement using arrow
            key. A CTRL_ARROW would move the CP to the beginning of the next or
            previous word. The CP would be the one of the characters beginning 
            the word. Since we want the caret to show next to that character,
            we will set fBeforeCP = TRUE. In word movement, we set the flag to
            TRUE in both forward and backward movements since we want the caret
            to be attached to the beginning of the current word. 

            UP/DOWN/PgUp/PgDn

            Apply the hit selection rules after UP, DOWN, PGUP, PGDN

            HOME/END

            Home -  Logical start of current line
            End  -  Logical end of current line
              
                  fBeforeCP = FALSE   after HOME
                  fBeforeCP = TRUE    after END
            
*/

CARET_MOVE_UNIT
CCaretTracker::GetMoveDirectionFromEvent(CEditEvent *pEvent,   
                                         BOOL   fRightToLeft,
                                         BOOL   fVertical
                                         )
{
    //
    //  Variables that affects arrow key movement
    //
    //                   0    = 1 state(s)
    //  fRightToLeft *1  0/1  = 1 state(s)
    //  fVertical    *2  0/1  = 2 states
    //  fControl     *4  0/1  = 4 states
    //
    //  e.g.
    //      000     means !fControl, !fVertical, !fRightToLeft
    //      011     means !fControl, fVertical, fRightToLeft
    //      111     means fControl, fVertical, fRightToLeft
    //
    //
    Assert (VK_UP     == VK_LEFT + 1);
    Assert (VK_RIGHT  == VK_UP + 1);
    Assert (VK_DOWN   == VK_RIGHT + 1);
    const int NUM_ARROWKEYMOVESTATES  = 8;
    const int NUM_ARROWKEYS = 4;
    static const CARET_MOVE_UNIT arrowkeyMoveStates[NUM_ARROWKEYS][NUM_ARROWKEYMOVESTATES] =
    {
        {
            CARET_MOVE_BACKWARD,                    // 000
            CARET_MOVE_FORWARD,                   // 001
            CARET_MOVE_NEXTLINE, CARET_MOVE_NEXTLINE,   // 010, 011
            CARET_MOVE_WORDBACKWARD, CARET_MOVE_WORDFORWARD, CARET_MOVE_NEXTBLOCK, CARET_MOVE_NEXTBLOCK // 100, 101, 110, 111
        },  // VK_LEFT  0x25
        { 
            CARET_MOVE_PREVIOUSLINE,
            CARET_MOVE_PREVIOUSLINE,
            CARET_MOVE_BACKWARD, CARET_MOVE_FORWARD,
            CARET_MOVE_BLOCKSTART, CARET_MOVE_BLOCKSTART, CARET_MOVE_WORDBACKWARD, CARET_MOVE_WORDFORWARD
        },  // VK_UP 0x26
        { 
            CARET_MOVE_FORWARD,
            CARET_MOVE_BACKWARD,
            CARET_MOVE_PREVIOUSLINE, CARET_MOVE_PREVIOUSLINE, 
            CARET_MOVE_WORDFORWARD, CARET_MOVE_WORDBACKWARD, CARET_MOVE_BLOCKSTART, CARET_MOVE_NEXTBLOCK
        },  // VK_RIGHT 0x27
        { 
            CARET_MOVE_NEXTLINE,
            CARET_MOVE_NEXTLINE,
            CARET_MOVE_FORWARD, CARET_MOVE_BACKWARD,
            CARET_MOVE_NEXTBLOCK, CARET_MOVE_NEXTBLOCK, CARET_MOVE_WORDFORWARD, CARET_MOVE_WORDBACKWARD
        },  // VK_DOWN 0x28
    };

    //
    //  Variable(s) that affects block key moment
    //
    //                      0   =  1 state
    //      fControl * 1    0/1 =  1 state
    //
    //
    Assert (VK_NEXT == VK_PRIOR + 1);  
    Assert (VK_END  == VK_NEXT  + 1);
    Assert (VK_HOME == VK_END   + 1);
    const int NUM_BLOCKKEYMOVESTATES = 2;
    const int NUM_BLOCKKEYS = 4;
    static const CARET_MOVE_UNIT blockkeyMoveStates[NUM_BLOCKKEYS][NUM_BLOCKKEYMOVESTATES] =
    {
        {
            CARET_MOVE_PAGEUP,          // 0
            CARET_MOVE_VIEWSTART        // 1
        },  // VK_PRIOR     0x21
        {
            CARET_MOVE_PAGEDOWN,
            CARET_MOVE_VIEWEND
        },  // VK_NEXT      0x22
        {
            CARET_MOVE_LINEEND,
            CARET_MOVE_DOCEND
        },  // VK_END       0x23
        {
            CARET_MOVE_LINESTART,
            CARET_MOVE_DOCSTART
        },  // VK_HOME      0x24
    };


    BOOL        fControl;
    LONG        keyCode;
    UINT        uState = 0;

    fControl = pEvent->IsControlKeyDown();
    IGNORE_HR( pEvent->GetKeyCode(&keyCode) );

    //  If the alt key is down, we shouldn't do anything here. (bug 94675)
    if (pEvent->IsAltKeyDown())
        return CARET_MOVE_NONE;

    switch (keyCode)
    {
        case  VK_LEFT:
        case  VK_UP:
        case  VK_RIGHT:
        case  VK_DOWN:
            {
            uState += ((fRightToLeft ? 1:0) +
                       (fVertical ? 2 : 0) +
                       (fControl ? 4 : 0));

            TraceTag((tagSelectionTrackerState, "Arrow Keycode State %u", uState));
            Assert( uState < NUM_ARROWKEYMOVESTATES );
            Assert( keyCode - VK_LEFT >= 0);
            Assert( keyCode - VK_LEFT < NUM_ARROWKEYS );
            
            return arrowkeyMoveStates[keyCode - VK_LEFT][uState];
            }
            
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
            {
            uState += (fControl ? 1: 0);

            TraceTag((tagSelectionTrackerState, "Block Keycode State %u", uState));
            Assert( keyCode - VK_PRIOR >= 0 );
            Assert( keyCode - VK_PRIOR < NUM_BLOCKKEYS );
            
            return blockkeyMoveStates[keyCode - VK_PRIOR][uState];
            }
    }
    
    return CARET_MOVE_NONE;
}



//+---------------------------------------------------------------------------+
//
//
//  Synopsis: Get the caret direction 
//              
//            Character RTL attributes affects the caret direction
//            Push mode where (parent RTL != character RTL)
//
//+---------------------------------------------------------------------------+

CARET_DIRECTION
CCaretTracker::GetCaretDirFromMove(
                        CARET_MOVE_UNIT unMove,
                        BOOL            fPushMode
                        )
{
    Assert (CARET_MOVE_BACKWARD     == CARET_MOVE_NONE		  + 1 );
    Assert (CARET_MOVE_FORWARD      == CARET_MOVE_BACKWARD	  + 1 );
    Assert (CARET_MOVE_WORDBACKWARD == CARET_MOVE_FORWARD      + 1 );
    Assert (CARET_MOVE_WORDFORWARD  == CARET_MOVE_WORDBACKWARD + 1 );
    Assert (CARET_MOVE_PREVIOUSLINE == CARET_MOVE_WORDFORWARD  + 1 );
    Assert (CARET_MOVE_NEXTLINE     == CARET_MOVE_PREVIOUSLINE + 1 );
    Assert (CARET_MOVE_PAGEUP       == CARET_MOVE_NEXTLINE     + 1 );
    Assert (CARET_MOVE_PAGEDOWN     == CARET_MOVE_PAGEUP       + 1 );
    Assert (CARET_MOVE_VIEWSTART    == CARET_MOVE_PAGEDOWN     + 1 );
    Assert (CARET_MOVE_VIEWEND      == CARET_MOVE_VIEWSTART    + 1 );
    Assert (CARET_MOVE_LINESTART    == CARET_MOVE_VIEWEND      + 1 );  
    Assert (CARET_MOVE_LINEEND      == CARET_MOVE_LINESTART    + 1 ); 
    Assert (CARET_MOVE_DOCSTART     == CARET_MOVE_LINEEND      + 1 );       
    Assert (CARET_MOVE_DOCEND       == CARET_MOVE_DOCSTART     + 1 ); 
    Assert (CARET_MOVE_BLOCKSTART   == CARET_MOVE_DOCEND       + 1 ); 
    Assert (CARET_MOVE_NEXTBLOCK    == CARET_MOVE_BLOCKSTART   + 1 ); 
    Assert (CARET_MOVE_ATOMICSTART  == CARET_MOVE_NEXTBLOCK    + 1 );
    Assert (CARET_MOVE_ATOMICEND    == CARET_MOVE_ATOMICSTART  + 1 );     
    //
    // 
    //
    static const CARET_DIRECTION arCaretDir[][2] = 
    {
        //
        // _fMoveForward  ==  fAfterPrevCP == !fBeforeCP	
        //
        //
        //   0                              1 -- push mode
        //
        { CARET_DIRECTION_SAME          , CARET_DIRECTION_SAME          },   //CARET_MOVE_NONE         = 0,
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_BACKWARD     = 1,
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_FORWARD      = 2,
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_WORDBACKWARD = 3,  always attach to beginning of current word
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_WORDFORWARD  = 4,  always attach to beginning of current word
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PREVIOUSLINE = 5,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_NEXTLINE     = 6,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PAGEUP       = 7,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_PAGEDOWN     = 8,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_VIEWSTART    = 9,  hit testing rule
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_VIEWEND      = 10, hit testing rule
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_LINESTART    = 11, logical start      
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_LINEEND      = 12, logical end
        { CARET_DIRECTION_FORWARD       , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_DOCSTART     = 13, logical start           
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_FORWARD       },   //CARET_MOVE_DOCEND       = 14, logical end
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_BLOCKSTART   = 15, always attach to beginning of current block
        { CARET_DIRECTION_BACKWARD      , CARET_DIRECTION_BACKWARD      },   //CARET_MOVE_NEXTBLOCK    = 16, always attach to beginning of current block
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_ATOMICSTART  = 17,
        { CARET_DIRECTION_INDETERMINATE , CARET_DIRECTION_INDETERMINATE },   //CARET_MOVE_ATOMICEND    = 18        
    };

    UINT            uState=0;
    CARET_DIRECTION caretDir;

    Assert (unMove >= CARET_MOVE_NONE && unMove <= CARET_MOVE_ATOMICEND);
    uState  += (fPushMode ? 1 : 0);  
    caretDir = arCaretDir[unMove - CARET_MOVE_NONE][uState];
    TraceTag((tagEdKeyNav,"Move %d Caret Dir is %d", unMove, caretDir));
    
    return caretDir;
}

//+====================================================================================
//
// Method: ShouldEnterExitList
//
// Synopsis: What does this do ?
//
//------------------------------------------------------------------------------------
BOOL    
CCaretTracker::ShouldEnterExitList(IMarkupPointer *pPosition, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement         spListItem;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    CBlockPointer           bpChild(_pManager->GetEditor());

    *ppElement = NULL;
    
    //
    // Are we in a list item scope?
    //

    IFC( pPosition->CurrentScope(&spElement) );
    if (spElement == NULL)
        goto Cleanup;

    IFC( EdUtil::FindListItem(GetMarkupServices(), spElement, &spListItem) );
    if (spListItem == NULL)
        goto Cleanup;

    //
    // Is the list item empty?  For the list item to be empty, the block tree must have
    // branching factor exactly equal to one from the list item to an empty text node below.
    //

    IFC( bpChild.MoveTo(spElement) );

    for (;;)
    {        
        IFC( bpChild.MoveToFirstChild() );

        IFC( bpChild.MoveToSibling(RIGHT) );
        if (hr != S_FALSE)
            return FALSE; // has siblings so not empty
            
        if (bpChild.GetType() == NT_Text)
            break; // we have our text node
        
        if (bpChild.GetType() != NT_Block)
            return FALSE; // if not a block, then not empty            
    }

    //
    // Is the scope empty?
    //
    
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( bpChild.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd) );
    
    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( bpChild.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );

    if (!GetEditor()->DoesSegmentContainText(spStart, spEnd, FALSE /* fSkipNBSP */))
    {
        *ppElement = spListItem;
        (*ppElement)->AddRef();

        return TRUE;
    }

Cleanup:
    return FALSE;
}

HRESULT
CCaretTracker::MoveCaret(
    CEditEvent*         pEvent,
    CARET_MOVE_UNIT     inMove, 
    IDisplayPointer*    pDispPointer,
    BOOL                fMoveCaret
    )
{
    HRESULT             hr;    
    SP_IHTMLCaret       spCaret;
    Direction           eMvDir;
    CSpringLoader       * psl = NULL;
    SP_IMarkupPointer   spPointer;

    POINT               ptXYPos;
    ptXYPos.x = 0;
    ptXYPos.y = 0;
    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispPointer ));
    
    if( _pManager->HaveTypedSinceLastUrlDetect() )
    {
        IGNORE_HR( UrlAutodetectCurrentWord( NULL ) );
        _pManager->SetHaveTypedSinceLastUrlDetect( FALSE );
    }

    //
    // Get the previous X/Y position for move
    //
    
    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );
    IFC( _ptVirtualCaret.GetPosition(spPointer, &ptXYPos) );

    //
    // Actually move the display pointer
    //
    
    // reset suggesetd XY if necessary. 
    if (!_ptVirtualCaret.IsFrozen() && (inMove != CARET_MOVE_PREVIOUSLINE && inMove != CARET_MOVE_NEXTLINE) )
    {
        ptXYPos.y = CARET_XPOS_UNDEFINED;
        ptXYPos.x = CARET_XPOS_UNDEFINED;
    }
    
    IFC( MovePointer(inMove, pDispPointer,&ptXYPos, &eMvDir) );

    if ( fMoveCaret )
    {
        BOOL fShouldIScroll = TRUE;
        
        //Assert( _pManager->IsInEditContext( pDispPointer ));
        if( ! _pManager->IsInEditContext( pDispPointer ))
            goto Cleanup;

        //
        // Check for non-multiline case.  If not multiline, we'll move
        // elsewhere on the same line, so force a scroll.
        //
        if (inMove == CARET_MOVE_PAGEUP || inMove == CARET_MOVE_PAGEDOWN)
        {
            VARIANT_BOOL     bMultiLine;
            SP_IHTMLElement  spFlowElement;
            SP_IHTMLElement3 spElement3;

            fShouldIScroll = FALSE;

            IFC( pDispPointer->GetFlowElement(&spFlowElement) );
            IFC( spFlowElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );

            IFC( spElement3->get_isMultiLine(&bMultiLine) );

            fShouldIScroll = (bMultiLine == VARIANT_FALSE);
   
        }

#ifndef NO_IME
        if (_pManager->IsIMEComposition())
        {
            _pManager->TerminateIMEComposition(TERMINATE_NORMAL, pEvent );
        }
#endif // NO_IME

        psl = GetSpringLoader();

        // Before we perform a move, see if we need to fire to preserve formatting
        // on the empty line
        if( psl )
        {
            psl->FireOnEmptyLine();
        }
        
        // Actually move the caret
        {
            CARET_DIRECTION dirCaret;
            BOOL            fPushMode;

            // HACKHACK: 
            // Now we just return fPushMode since it is the only case where 
            // ambiguious position is of more critical issue. 
            //
            // IFC( MshtmledUtil::IsDisplayPointerInPushBlock(GetEditor(), pDispPointer, &fPushMode) );
            fPushMode= TRUE;
            dirCaret = CCaretTracker::GetCaretDirFromMove(inMove, fPushMode);
            IFC( spCaret->MoveCaretToPointer( pDispPointer, fShouldIScroll, dirCaret));
        }
        _fCheckedCaretForAtomic = FALSE;

        // Reset the spring loader with the compose font
        if (psl)
        {
            SP_IMarkupPointer spDispPointer;

            IFC( GetEditor()->CreateMarkupPointer(&spDispPointer) );
            IFC( pDispPointer->PositionMarkupPointer(spDispPointer) );
            
            IGNORE_HR(psl->SpringLoadComposeSettings(spDispPointer, TRUE));
        }
    }

    // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(_pManager);
        selCounter.SelectionChanged();
    }
    
    //
    // Update the XPosition
    //
    // We have to update the pointer in any case...
    // 
    {
        BOOL fFreeze = _ptVirtualCaret.FreezePosition(FALSE);
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        IFC( _ptVirtualCaret.UpdatePosition(spPointer, ptXYPos) );
        _ptVirtualCaret.FreezePosition(fFreeze);
    }
  

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: SetCaretVisible.
//
// Synopsis: Set's the Caret's visiblity.
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::SetCaretVisible( IHTMLDocument2* pIDoc, BOOL fVisible )
{
    HRESULT hr = S_OK ;
    SP_IHTMLCaret spc;
    IDisplayServices * pds = NULL;

    IFC( pIDoc->QueryInterface( IID_IDisplayServices, (void **) & pds ));
    IFC( pds->GetCaret( &spc ));

    if( fVisible )
        hr = spc->Show( FALSE );
    else
        hr = spc->Hide();

Cleanup:
    ReleaseInterface( pds );
    RRETURN( hr );
}




//+====================================================================================
//
// Method:GetCaretPointer
//
// Synopsis: Utility Routine to get the IDisplayPointer at the Caret
//
//------------------------------------------------------------------------------------

HRESULT
CCaretTracker::GetCaretPointer( IDisplayPointer ** ppDispPointer )
{
    HRESULT hr = S_OK;
    SP_IHTMLCaret  spCaret;
    
    IFC( GetDisplayServices()->CreateDisplayPointer( ppDispPointer));
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( *ppDispPointer ));

Cleanup:
    RRETURN( hr );
}

VOID 
CCaretTracker::SetCaretShouldBeVisible( BOOL fVisible )
{
    _fCaretShouldBeVisible = fVisible;
    SetCaretVisible( _pManager->GetDoc(), _fCaretShouldBeVisible );
}



BOOL
CCaretTracker::ShouldCaretBeVisible()
{
    IHTMLElement* pIElement = NULL;
    IHTMLInputElement* pIInputElement = NULL;
    HRESULT hr = S_OK;
    BSTR bstrType = NULL;
    BOOL fShouldBeVisible = FALSE;

    ELEMENT_TAG_ID eTag = _pManager->GetEditableTagId();

    if ( _pManager->IsContextEditable() )
    {

    #ifdef FORMSMODE
        if (_pManager->IsInFormsSelectionMode() )
             fShouldBeVisible = FALSE;
        else
    #endif 
        if (!_pManager->IsEnabled())
             fShouldBeVisible = FALSE;
        else
        {
            switch( eTag )
            {
                case TAGID_IMG:
                case TAGID_OBJECT:
                case TAGID_APPLET:
                case TAGID_SELECT:
                    fShouldBeVisible = FALSE;
                    break;

                case TAGID_INPUT:
                {
                    //
                    // for input's of type= image, or type=button - we don't want to make the caret visible.
                    //
                    IFC( _pManager->GetEditableElement( &pIElement ) );
               
                    if ( S_OK == THR( pIElement->QueryInterface ( IID_IHTMLInputElement, 
                                                                 ( void** ) & pIInputElement ))
                        && S_OK == THR(pIInputElement->get_type(&bstrType)))
                    {                    
                        if (   !StrCmpIC(bstrType, TEXT("image"))
                            || !StrCmpIC(bstrType, TEXT("radio"))
                            || !StrCmpIC(bstrType, TEXT("checkbox")))
                        {
                            fShouldBeVisible = FALSE;
                        }                
                        else
                            fShouldBeVisible = TRUE;
                    }
                    else
                        fShouldBeVisible = TRUE;
                }
                break;

                default:
                    fShouldBeVisible = TRUE;
            }
        }
    }
    //
    // See if we can have a visible caret - via the FireOnBeforeEditFocus event.
    //
    if ( fShouldBeVisible )
    {
        fShouldBeVisible = _pManager->CanHaveEditFocus();
    }
    
Cleanup:
    SysFreeString(bstrType);
    ReleaseInterface( pIInputElement);
    ReleaseInterface( pIElement );

    return ( fShouldBeVisible);
}

//+====================================================================================
//
// Method: DontBackspace
//
// Synopsis: Dont Backspace when you're at the start of these
//
// Typical example is - don't backspace from inside an input.
//
//------------------------------------------------------------------------------------


BOOL
DontBackspace( ELEMENT_TAG_ID eTagId )
{
    switch( eTagId )
    {
        case TAGID_INPUT:
        case TAGID_BODY:
        case TAGID_TD:
        case TAGID_TR:
        case TAGID_TABLE:

            return TRUE;

        default:
            return FALSE;

    }
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   An element is leaving the tree.  We may have to nix our caret
//              if the caret is in bound by the element
//
//----------------------------------------------------------------------------
HRESULT 
CCaretTracker::OnExitTree(
                            IMarkupPointer* pIStart, 
                            IMarkupPointer* pIEnd  ,
                            IMarkupPointer* pIContentStart,
                            IMarkupPointer* pIContentEnd )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    CEditPointer            startPointer( GetEditor() );
    CEditPointer            endPointer( GetEditor());
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL fPositioned, fPositionedEnd;
    SELECTION_TYPE          eType = SELECTION_TYPE_None;
    BOOL                    fCaretPositioned;
    BOOL                    fSameMarkup;
    
    //
    // A layout is leaving the tree. Does this completely contain selection ?
    //
    if( !IsPassive() )
    { 
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer2 )); 


        // Retrieve the segment list
        IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spSegmentList ) );


        //
        // Verify that we are really tracking a caret
        //
        IFC( spSegmentList->GetType(&eType) );
        Assert( eType == SELECTION_TYPE_Caret || eType == SELECTION_TYPE_None );        

        if ( eType == SELECTION_TYPE_Caret )
        {            
            // Position pointers around the current selection.
            IFC( spSegmentList->CreateIterator( &spIter ) );
            IFC( spIter->Current(&spSegment) );
            IFC( spSegment->GetPointers( startPointer, endPointer ));

            IFC( startPointer->IsPositioned( &fCaretPositioned ) );
            IFC( pIContentStart->IsPositioned( & fPositioned ));
            IFC( pIContentEnd->IsPositioned( & fPositionedEnd ));

            if ( fPositioned &&
                 fPositionedEnd )
            {
                IFC( spPointer->MoveToPointer( pIContentStart ));
                IFC( spPointer2->MoveToPointer( pIContentEnd ));
            }
            else
            {
                IFC( spPointer->MoveToPointer( pIStart ));
                IFC( spPointer2->MoveToPointer( pIEnd ));
            }
            
            if( (startPointer.Between( spPointer, spPointer2) && endPointer.Between( spPointer, spPointer2)) ||
                (!fCaretPositioned) )
            {
                SP_IDisplayPointer spDispPointer;
                
                IFC( spPointer->MoveToPointer( pIEnd ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );

                if (hr == CTL_E_INVALIDLINE)
                {
                    if (SUCCEEDED(GetEditor()->AdjustIntoTextSite(spPointer, RIGHT)))
                    {
                        hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                    }    
                    else
                    {
                        IFC( spPointer->MoveToPointer( pIStart ) );
                        if (SUCCEEDED(GetEditor()->AdjustIntoTextSite(spPointer, LEFT)))
                        {
                            hr = THR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                        }
                    }
                }
                IFC(hr);

                IFC( ArePointersInSameMarkup( spPointer, startPointer, &fSameMarkup ) )

                if( !fSameMarkup )
                {
                    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ) );
                }
                
                IFC( _pManager->EnsureEditContext( spPointer ));
                
                if ( hr == S_FALSE )
                {
                    goto Cleanup;
                }
                PositionCaretAt( spDispPointer, CARET_DIRECTION_INDETERMINATE, POSCARETOPT_DoNotAdjust, ADJPTROPT_None );
            }
        }
    }        

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on caret
//
//------------------------------------------------------------------------------------
HRESULT 
CCaretTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT                 hr = S_OK;
    SELECTION_TYPE          eType;
    SP_IMarkupPointer       spLeft;
    SP_IMarkupPointer       spRight;
    SP_IHTMLElement         spElementCaret;
    SP_IObjectIdentity      spIdent;
    MARKUP_CONTEXT_TYPE     context = CONTEXT_TYPE_None;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    
    // Retrieve the segment list
    IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spSegmentList ) );
    IFC( spSegmentList->GetType( &eType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    
    Assert( pfFindNext );
    Assert( pElement );
    
    IFC( GetEditor()->CreateMarkupPointer( &spLeft ));
    IFC( GetEditor()->CreateMarkupPointer( &spRight ));

    if( !IsPassive() && (fEmpty == FALSE) && (eType == SELECTION_TYPE_Caret) )
    {
        // Return the position of the caret
        IFC( spSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spLeft, spRight ) );
    }
    else
    {
        SP_IHTMLCaret spCaret;
        BOOL fPositioned;

        // There is no selection, try to use the physical caret
        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveMarkupPointerToCaret(spRight) );
        IFC( spRight->IsPositioned(&fPositioned) );

        if (!fPositioned)
        {
            // no caret to fall back on - go use the edit context
            if( fForward )
            {
                IFC( spRight->MoveToPointer( _pManager->GetStartEditContext()));
            }
            else
            {
                IFC( spRight->MoveToPointer( _pManager->GetEndEditContext()));
            }
        }

    }
    
    // First find the element where selection would contains caret
    IFC(spRight->CurrentScope(&spElementCaret));
    if (!spElementCaret)
        goto Cleanup;

    // Now, scan upto the first scope boundary
    for(;;)
    {
        if (fForward)
        {
            IFC( spRight->Right(TRUE, &context, pElement, NULL, NULL));
        }
        else
        {
            IFC( spRight->Left(TRUE, &context, pElement, NULL, NULL));
        }

        Assert( context != CONTEXT_TYPE_None );
        
        if(     (context == CONTEXT_TYPE_EnterScope)    || 
                (context == CONTEXT_TYPE_ExitScope)     ||
                (context == CONTEXT_TYPE_NoScope) )
        {
            break;
        }

        ClearInterface(pElement);
    }

    IFC( spElementCaret->QueryInterface( IID_IObjectIdentity, (void **)&spIdent ) );

    if( spIdent->IsEqualObject(*pElement) == S_FALSE )
    {
        *pfFindNext = FALSE;
    }
    //
    // We always want to say yes to findNext - if we have a focus adorner
    //
    if ( _pManager->HasFocusAdorner() )
    {
        *pfFindNext = TRUE;
    }
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ExitList
//
//  Synopsis:   This method causes the list item to exit the list.  Used
//              by backspace and enter.
//
//----------------------------------------------------------------------------

HRESULT 
CCaretTracker::ExitList(IHTMLElement* pIElement)
{
    HRESULT hr;
    
    CBlockPointer   bpListItem(_pManager->GetEditor());
    CBlockPointer   bpParent(_pManager->GetEditor());

    IFC( TerminateTypingBatch() );
    
    IFC( bpListItem.MoveTo(pIElement) );
    Assert(bpListItem.GetType() == NT_ListItem);

    IFC( bpParent.MoveTo(&bpListItem) );
    IFC( bpParent.MoveToParent() );

    if (hr == S_FALSE
        || bpParent.GetType() == NT_Container
        || bpParent.GetType() == NT_BlockLayout
        || bpParent.GetType() == NT_FlowLayout)
    {
        ELEMENT_TAG_ID tagId = TAGID_DIV;

        // Can't float through a container or a block layout
        // so just morph to the default block element
        IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );
        IFC( bpListItem.Morph(&bpListItem, tagId) );
    }
    else
    {
        CBlockPointer   bpListItemParent(_pManager->GetEditor());
                        
        // If should outdent on an empty list item, wait for
        // </li></li>...</ol> case which is often is created
        // by the parser.
        for (;;)
        {
            IFC( bpListItem.FloatUp(&bpListItem, TRUE) );

            IFC( bpListItemParent.MoveTo(&bpListItem) );
            IFC( bpListItemParent.MoveToParent() );

            if (bpListItemParent.GetType() == NT_ListItem)
            {
                SP_IMarkupPointer spInner, spOuter;
                BOOL              fEqual;
                
                IFC( GetEditor()->CreateMarkupPointer(&spInner) );
                IFC( bpListItem.MovePointerTo(spInner, ELEM_ADJ_AfterEnd) );
                
                IFC( GetEditor()->CreateMarkupPointer(&spOuter) );
                IFC( bpListItemParent.MovePointerTo(spOuter, ELEM_ADJ_BeforeEnd) );

                IFC( spInner->IsEqualTo(spOuter, &fEqual) );
                if (!fEqual)
                    break; // done                        
            }
            else
            {
                break; // done
            }
        }
    }

    if (bpListItem.GetType() == NT_Block)
    {            
        IGNORE_HR( bpListItem.FlattenNode() );
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCaretTracker::ShouldBackspaceExitList
//
//  Synopsis:   Is the user trying to remove the list item?
//
//----------------------------------------------------------------------------
BOOL    
CCaretTracker::ShouldBackspaceExitList(IMarkupPointer *pPointer, IHTMLElement **ppListItem)
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spEditElement;
    SP_IObjectIdentity  spIdent;
    BOOL                fResult = FALSE;

    IFC( ep->MoveToPointer(pPointer) );

    //
    // Look for exit scope of a list item.  If we find one, we should
    // exit the list to be like Word 2k.
    //
    
    IFC( ep.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );
    
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock) && spElement != NULL)
    {
        ELEMENT_TAG_ID tagId;
    
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

        fResult = IsListItem(tagId);
        if (fResult)
        {
            // If the list item is the editable element, we don't want to delete it.
            // (Bug 103246)
            IFC( _pManager->GetEditableElement(&spEditElement) );
            IFC( spElement->QueryInterface(IID_IObjectIdentity, (void **) &spIdent));        

            if (spEditElement != NULL && spIdent->IsEqualObject(spEditElement) != S_OK)
            {
                *ppListItem = spElement;
                spElement->AddRef();
            }
            else
            {
                fResult = FALSE;
            }
        }
    }

Cleanup:
    return fResult;
}

HRESULT 
CCaretTracker::SetCaretDisplayGravity(DISPLAY_GRAVITY eGravity)
{
    HRESULT             hr;   
    SP_IHTMLCaret       spCaret;
    DISPLAY_GRAVITY     eCurGravity;
    
    IFR( GetDisplayServices()->GetCaret(&spCaret) );

    if (spCaret != NULL)
    {
        SP_IDisplayPointer  spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCaret) );

        IFC( spDispCaret->GetDisplayGravity( &eCurGravity ) );

        if( eCurGravity != eGravity )
        {
            IFC( spDispCaret->SetDisplayGravity(eGravity) );
            IFC( spCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_SAME) );
        }
    }
    
Cleanup:
    RRETURN(hr);
}

HRESULT
CCaretTracker::HandleBackspaceAtomicSelection(IMarkupPointer *pPointer)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spAtomicElement;

    IFC( pPointer->CurrentScope(&spAtomicElement) );
    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spStart) );
        IFC( spStart->MoveToPointer(pPointer) );

        IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
        IFC( spEnd->MoveToPointer(pPointer) );

        //  Delete will take care of adjusting for atomic
        IFC( GetEditor()->Delete( spStart, spEnd, FALSE ));
        goto Cleanup;
    }

    hr = S_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}

BOOL 
CCaretTracker::IsInsideUrl(IMarkupPointer *pPointer)
{
    HRESULT          hr;
    BOOL             fInsideUrl = FALSE;
    SP_IHTMLElement  spElement, spParentElement;
    ELEMENT_TAG_ID   tagId;


    IFC( pPointer->CurrentScope(&spElement) );

    while (spElement != NULL)
    {
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) ); 
        if (tagId == TAGID_A)
        {
            fInsideUrl = TRUE;
            goto Cleanup;
        }
        else if (tagId == TAGID_BODY)
        {
            break; // perf optimization
        }

        IFC( spElement->get_parentElement(&spParentElement) );
        spElement = spParentElement;
    }

Cleanup:
    return fInsideUrl;    
}

HRESULT
CCaretTracker::EnsureAtomicSelection(CEditEvent* pEvent)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;
    SP_IHTMLCaret       spCaret;
    SP_IHTMLElement     spAtomicElement;

    //  Get the scope at the caret position
    IFC( GetDisplayServices()->GetCaret(&spCaret) );
    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( spCaret->MoveMarkupPointerToCaret(spPointer) );
    IFC( spPointer->CurrentScope(&spAtomicElement) );

    //  If the caret scope is atomic, go to atomic selection
    if ( _pManager->CheckAtomic(spAtomicElement) == S_OK )
    {
        SP_IDisplayPointer  spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCaret) );
        IFC( _pManager->StartAtomicSelectionFromCaret(spDispCaret) );
    }

Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\charcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       CHARCMD.CXX
//
//  Contents:   Implementation of character command classes.
//
//  History:    07-14-98 - ashrafm - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef _X_ANCHOR_H_
#define _X_ANCHOR_H_
#include "anchor.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELTRACK_HXX_
#define X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

using namespace EdUtil;

MtDefine(CCharCommand, EditCommand, "CCharCommand");
MtDefine(CTriStateCommand, EditCommand, "CTriStateCommand");
MtDefine(CFontCommand, EditCommand, "CFontCommand");
MtDefine(CForeColorCommand, EditCommand, "CForeColorCommand");
MtDefine(CBackColorCommand, EditCommand, "CBackColorCommand");
MtDefine(CFontNameCommand, EditCommand, "CFontNameCommand");
MtDefine(CFontSizeCommand, EditCommand, "CFontSizeCommand");
MtDefine(CAnchorCommand, EditCommand, "CAnchorCommand");
MtDefine(CRemoveFormatBaseCommand, EditCommand, "CRemoveFormatBaseCommand");
MtDefine(CRemoveFormatCommand, EditCommand, "CRemoveFormatCommand");
MtDefine(CUnlinkCommand, EditCommand, "CUnlinkCommand");

DefineSmartPointer(IHTMLAnchorElement);

//=========================================================================
//
// CBaseCharCommand: constructor
//
//-------------------------------------------------------------------------
CBaseCharCommand::CBaseCharCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor * pEd )
: CCommand(cmdId, pEd)
{
    _tagId = tagId;
}

//=========================================================================
//
// CBaseCharCommand: Apply
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::Apply( 
    CMshtmlEd       *pCmdTarget,
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd,
    VARIANT         *pvarargIn,
    BOOL            fGenerateEmptyTags)
{
    HRESULT            hr;
    SP_IMarkupPointer  spStartCopy;
    SP_IMarkupPointer  spEndCopy;

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFC( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );

    IFC( GetEditor()->PushCommandTarget(pCmdTarget) );

    IGNORE_HR( PrivateApply(spStartCopy, spEndCopy, pvarargIn, fGenerateEmptyTags) );

    IFC( GetEditor()->PopCommandTarget(WHEN_DBG(pCmdTarget)) );

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: GetNormalizedTagId
//
// Synopsis: Converts any synomyms to a normal form
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::GetNormalizedTagId(IHTMLElement *pElement, ELEMENT_TAG_ID *ptagId)
{
    HRESULT hr;

    IFR( GetMarkupServices()->GetElementTagId(pElement, ptagId) );

    switch (*ptagId)
    {
        case TAGID_B:
            *ptagId = TAGID_STRONG;
            break;

        case TAGID_I:
            *ptagId = TAGID_EM;
            break;
    }

    return S_OK;    
}

//=========================================================================
//
// CBaseCharCommand: RemoveSimilarTags
//
// Synopsis: Removes all similar tags contained within
//
//-------------------------------------------------------------------------
HRESULT
CBaseCharCommand::RemoveSimilarTags(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrent;
    SP_IMarkupPointer   spLimit;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    MARKUP_CONTEXT_TYPE context;
    INT                 iPosition;
    BOOL                fBlock, fLayout;
        
    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrent) );
    IFC( GetEditor()->CreateMarkupPointer(&spLimit) );

    do
    {
        IFC( Move(spCurrent, RIGHT, TRUE, &context, &spElement) );

        if (spElement)
        {
            IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout, NULL) );
        
            if (!fBlock && !fLayout)
            {
                switch (context)
                {
                    case CONTEXT_TYPE_EnterScope:
                    case CONTEXT_TYPE_ExitScope:
                        IFC( GetNormalizedTagId(spElement, &tagId) );
                        if (tagId == _tagId)
                        {   
                            if (context == CONTEXT_TYPE_EnterScope)
                            {
                                IFC( spLimit->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );
                                IFC( OldCompare( spLimit, pEnd, &iPosition) );                    
                            }
                            else
                            {
                                IFC( spLimit->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterBegin) );
                                IFC( OldCompare( pStart, spLimit, &iPosition) );
                            }

                            if (iPosition == RIGHT)
                            {
                                IFC( RemoveTag(spElement, pvarargIn) );
                            }
                        }
                }
            }
        }

        IFC( OldCompare( spCurrent, pEnd, &iPosition) );
    } 
    while (iPosition == RIGHT);

Cleanup:
    RRETURN(hr);
}

BOOL
CBaseCharCommand::IsBlockOrLayout(IHTMLElement *pElement)
{
    HRESULT hr;
    BOOL fLayout, fBlock;

    Assert(pElement);
    
    IFC(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    
    if (!fBlock && !fLayout)
    {
        ELEMENT_TAG_ID  tagId;

        IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
        return (tagId == TAGID_RT);
    }

Cleanup:    
    return (fBlock || fLayout);
}

//=========================================================================
//
// CBaseCharCommand: ExpandCommandSegment
//
// Synopsis: Expands the segment to contain the maximum bolded segment
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::ExpandCommandSegment(IMarkupPointer *pStart, Direction direction, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrent;
    SP_IHTMLElement     spElement;
    MARKUP_CONTEXT_TYPE context;
    ELEMENT_ADJACENCY   elemAdj;
    ELEMENT_TAG_ID      tagId;
    BOOL                fMustCheckEachPosition = FALSE;
    BOOL                fExitSite = FALSE;
    
    Assert(direction == LEFT || direction == RIGHT);

    // TODO: maybe we can be smarter with character influence that is not from
    // formatting tags [ashrafm]

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spCurrent) );

    for (;;)
    {
        IFR( Move(spCurrent, direction, TRUE, &context, &spElement) );
        
        switch (context)
        {
            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                    goto Cleanup;

                break;

            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
                if (context == CONTEXT_TYPE_ExitScope && spElement != NULL)
                {                    
                    // Make sure we can't expand out of an instrinsic control
                    if (IsIntrinsic(GetMarkupServices(), spElement))
                    {
                        // We just exited an instrinsic, we don't continue
                        goto Cleanup;
                    }                    
                }
                
                if (fMustCheckEachPosition)
                {                     
                    IFC( pStart->MoveToPointer(spCurrent) );
                    
                    if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                        goto Cleanup;
                }
                else
                {
                    IFC(GetNormalizedTagId(spElement, &tagId));

                    if (tagId == _tagId)
                    {
                        if (context == CONTEXT_TYPE_EnterScope)
                        {
                            // Check to see if the font tags match
                            if (tagId == TAGID_FONT)
                            {
                                if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                                    goto Cleanup;
                            }

                            // There is no point of terminating our new tag here, since the
                            // element we just located is under the same influence.  Extend the
                            // end of our new tag to the end of the current element.
                            elemAdj = (direction == LEFT) ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd;
                            IFC( spCurrent->MoveAdjacentToElement(spElement, elemAdj) );
                        }

                        IFC( pStart->MoveToPointer(spCurrent) );
                    }
                    else if (IsBlockOrLayout(spElement))
                    {
                        if (!IsCmdInFormatCache(spCurrent, pvarargIn))
                           goto Cleanup;

                        fMustCheckEachPosition = TRUE;
                    }
                }

                if( fExitSite == FALSE )
                {
                    IFC( pStart->MoveToPointer(spCurrent) );
                    fExitSite = TRUE;
                }

                break;
                
            case CONTEXT_TYPE_None:
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);    
}

//=========================================================================
//
// CBaseCharCommand: CreateAndInsert
//
// Synopsis: Creates and inserts the specified element
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::CreateAndInsert(ELEMENT_TAG_ID tagId, IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;

    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
    IFR( GetEditor()->InsertElement(spElement, pStart, pEnd) );

    if (ppElement)
    {
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }

    RRETURN(hr);    
}

//=========================================================================
//
// CBaseCharCommand: InsertTags
//
// Synopsis: Inserts the commands tags
//
//-------------------------------------------------------------------------

HRESULT
CBaseCharCommand::InsertTags(IMarkupPointer *pStart, IMarkupPointer *pEnd, IMarkupPointer *pLimit, VARIANT *pvarargIn, BOOL fGenerateEmptyTags)
{
    HRESULT             hr;
    SP_IMarkupPointer   spCurrentStart;
    SP_IMarkupPointer   spCurrentEnd;
    SP_IMarkupPointer   spCurrentSearch;
    INT                 iPosition;
    BOOL                bEqual;

    //
    // Optimize for springloader case
    //
    
    IFC( pStart->IsEqualTo(pEnd, &bEqual) );
    if (bEqual)
    {
        if (fGenerateEmptyTags)
            IFC( InsertTag(pStart, pStart, pvarargIn) );

        return S_OK; // done
    }

    //
    // General case
    //
    
    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentStart) );
    IFC( spCurrentStart->SetGravity(POINTER_GRAVITY_Right) );

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentSearch) );
    IFC( spCurrentSearch->SetGravity(POINTER_GRAVITY_Left) );

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spCurrentEnd) );
    IFC( spCurrentEnd->SetGravity(POINTER_GRAVITY_Left) );
    
    for (;;)
    {
        //
        // Find start of command
        //

        IFC( FindTagStart(spCurrentStart, pvarargIn, pEnd) );
        if (hr == S_FALSE)  
        {
            hr = S_OK;
            goto Cleanup; // we're done
        }
 
        //
        // Find end of command
        //

        IFC( spCurrentEnd->MoveToPointer(spCurrentStart) );
        IFC( FindTagEnd(spCurrentStart, spCurrentEnd, spCurrentSearch, pLimit) );
        
        //
        // Check for empty tags
        //

        IFC( OldCompare( spCurrentStart, spCurrentEnd, &iPosition) );

        if (iPosition != RIGHT)
        {
            if (iPosition == SAME && fGenerateEmptyTags)
            {
                IFC( InsertTag(spCurrentStart, spCurrentEnd, pvarargIn) );
            }
            continue; // done
        }

        //
        // Insert the tag
        //
        IFC( InsertTag(spCurrentStart, spCurrentEnd, pvarargIn) );
        IFC( spCurrentStart->MoveToPointer(spCurrentSearch) );
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: FindTagStart
//
// Synopsis: finds the start of the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::FindTagStart(IMarkupPointer *pCurrent, VARIANT *pvarargIn, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    DWORD               dwSearch;
    
    IFR( ep->MoveToPointer(pCurrent) );
    IFR( ep.SetBoundary(NULL, pEnd) );

    dwSearch =  BREAK_CONDITION_Text        |
                BREAK_CONDITION_NoScopeSite |
                BREAK_CONDITION_EnterSite   |
                BREAK_CONDITION_EnterBlock;

    for (;;)
    {
        IFR( ep.Scan(RIGHT, dwSearch, &dwFound, NULL, NULL, NULL, 
                        SCAN_OPTION_SkipControls | SCAN_OPTION_TablesNotBlocks) );

        if( ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary) ||
            ep.CheckFlag(dwFound, BREAK_CONDITION_Error) )
        {
            // Done
            return S_FALSE;
        }
        else if(    (ep.CheckFlag( dwFound, BREAK_CONDITION_EnterBlock )) || 
                    (ep.CheckFlag( dwFound, BREAK_CONDITION_EnterSite ) ) )
        {                           
            DWORD dwCond = ( ep.CheckFlag( dwFound, BREAK_CONDITION_EnterBlock ) ) ? 
                                BREAK_CONDITION_ExitBlock : BREAK_CONDITION_ExitSite;

            DWORD dwFind =  dwSearch | dwCond;
                                                              
            CEditPointer epTest(GetEditor());

            // We found a begin block, search to determine if this block is truly
            // empty
            IFR( epTest.SetBoundary(NULL, pEnd) );
            IFR( epTest->MoveToPointer(ep) );

            IFR( epTest.Scan( RIGHT, dwFind, &dwFound, NULL, NULL, NULL, 
                                SCAN_OPTION_SkipControls | SCAN_OPTION_TablesNotBlocks) );

            // If we find an exit block, we have an empty block.
            if( !epTest.CheckFlag( dwFound, BREAK_CONDITION_Boundary ) &&
                epTest.CheckFlag( dwFound, dwCond ) && 
                !IsCmdInFormatCache( ep, pvarargIn ) )
            {
                // Find the innermost phrase element, insert the new tag start there
                dwFind |= BREAK_CONDITION_ExitPhrase;

                IFR( epTest->MoveToPointer(ep) );
                IFR( epTest.Scan( RIGHT, dwFind, &dwFound, NULL, NULL, NULL, SCAN_OPTION_SkipControls ) );

                if( epTest.CheckFlag( dwFound, BREAK_CONDITION_ExitPhrase ) )
                {
                    IFR( epTest.Scan( LEFT, BREAK_CONDITION_EnterPhrase, &dwFound, NULL, NULL, NULL, 
                                        SCAN_OPTION_None ) );
                                        
                    IFR( pCurrent->MoveToPointer( epTest ) );
                }
                else
                {
                    IFR( pCurrent->MoveToPointer( ep ) );
                }

                break;
            }
        }
        // If we found text or a noscope site, then check the cache
        else if (!IsCmdInFormatCache(ep, pvarargIn))
        {
            IFR( ep.Scan(LEFT, dwSearch, &dwFound, NULL, NULL, NULL, SCAN_OPTION_SkipControls) );
            IFR( pCurrent->MoveToPointer(ep) );
            break;
        }        
    }

    return S_OK;
}
    
//=========================================================================
//
// CBaseCharCommand: FindTagEnd
//
// Synopsis: finds the end of the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::FindTagEnd(   IMarkupPointer *pStart, 
                                IMarkupPointer *pCurrent, 
                                IMarkupPointer *pSearch,
                                IMarkupPointer *pEnd)
{
    HRESULT             hr;                     // Result code
    SP_IHTMLElement     spElement;              // Element coming into scope on right
    SP_IMarkupPointer   spPointer;      
    SP_IMarkupPointer   spTemp;
    SP_IObjectIdentity  spIdent;
    INT                 iPosition;
    MARKUP_CONTEXT_TYPE context;
    CEditPointer        epTest(GetEditor());
    DWORD               dwFound;
    BOOL                fCommit = TRUE;         // Should we commit our changes
    SP_IMarkupPointer   spStartSave;            // Candidate start position
    SP_IMarkupPointer   spCurrentSave;          // Candidate end of tag position    

    IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFR( GetEditor()->CreateMarkupPointer(&spTemp) );

    IFR( GetEditor()->CreateMarkupPointer(&spStartSave) );
    IFR( GetEditor()->CreateMarkupPointer(&spCurrentSave) );

    for(;;)
    {
        //
        // Check for termination (have we gone past the end)
        //
        
        IFR( OldCompare( pCurrent, pEnd, &iPosition) );
        if( iPosition != RIGHT )
        {
            if (iPosition == LEFT)
            {
                // Somehow we ended up to the right of our end markup.  If we skipped over
                // text, fixup the mistake
                IFR( pCurrent->Left( FALSE, &context, NULL, NULL, NULL) );
                
                if (context == CONTEXT_TYPE_Text)
                {
                    IFR( pCurrent->MoveToPointer(pEnd) );
                }
            }
            
            IFR( pSearch->MoveToPointer(pCurrent) );

            goto Cleanup;
        }
        
        //
        // Try extending the tag some more to the right
        // The search pointer is the output parameter which tells
        // the calling function where to begin the next search.  Normally,
        // this is wherever pCurrent is terminated.
        //
        IFR( Move(pCurrent, RIGHT, TRUE, &context, &spElement) );
        
        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
                if (IsBlockOrLayout(spElement))
                {
                    // We are entering a block or layout.  We must
                    // terminate the tag before the block or layout begins.
                    // In addition, we must begin searching for any new tags
                    // after the block or layout
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );

                    goto Cleanup;
                }
                else
                {
                    ELEMENT_TAG_ID tagId;

                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (tagId == TAGID_A)
                    {
                        // Must end on anchors
                        IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                        IFR( pSearch->MoveToPointer( pCurrent ) );
                        goto Cleanup;
                    }
                }

                //
                // For font tags, try pushing the tag end back
                //

                if( CanPushFontTagBack(spElement) )
                {                   
                    BOOL fEqual;

                    IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    IFR( GetMarkupServices()->RemoveElement(spElement) );

                    //
                    // Reinsert only if not empty
                    //

                    IFR( pEnd->IsEqualTo(spTemp, &fEqual) );
                    if (!fEqual)
                    {
                        IFR( GetEditor()->InsertElement(spElement, pEnd, spTemp) );
                        fCommit = TRUE;
                    }

                    continue;
                }

                //
                // Jump over the element and cling to any text encompassed
                // by the element
                
                IFR( spPointer->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                IFR( ClingToText(spPointer, LEFT, NULL) );

                // If we jumped past the end of our limit, we must terminate the current
                // tag before the start of the element we jumped over
                IFR( OldCompare( spPointer, pEnd, &iPosition) );
                if (iPosition == LEFT)
                {
                    // We have to end the tag
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    goto Cleanup;
                }

                // 
                // Before we jump over an element, make sure that it contains no block/layout
                //

                IFR( epTest->MoveToPointer(pCurrent) );
                IFR( epTest.SetBoundary(pCurrent, spPointer) );
                IFR( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_TEXT, &dwFound, 
                                 NULL, NULL, NULL, SCAN_OPTION_SkipControls) );

                if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
                {
                    // Terminate the current tag
                    IFR( pCurrent->Left(TRUE, NULL, NULL, NULL, NULL) );
                    IFR( pSearch->MoveToPointer( pCurrent ) );
                    goto Cleanup;
                }

                
                // We can jump over this tag.  We haven't reached the end of our
                // limit, and the new tag doesn't contain any block or layout           
                IFR( pCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                fCommit = TRUE;
                break;
                
            case CONTEXT_TYPE_ExitScope:
                if (IsBlockOrLayout(spElement))
                {
                    // Exiting scope or layout.  We must terminate the current
                    // tag before the exit tag, and resume our search OUTSIDE
                    // of this scope / layout
                    IFR( pSearch->MoveToPointer( pCurrent ) );                   
                    IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                    goto Cleanup;
                }
                else
                {
                    ELEMENT_TAG_ID tagId;

                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (tagId == TAGID_A)
                    {
                        // Terminate the tag before the end of the anchor
                        IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                        IFR( pSearch->MoveToPointer( pCurrent ) );
                        goto Cleanup;
                    }
                }

                //
                // For font tags, try pushing the tag end back
                //
                if( CanPushFontTagBack(spElement) )
                {
                    BOOL fEqual;

                    IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    IFR( GetMarkupServices()->RemoveElement(spElement) );

                    //
                    // Reinsert only if not empty
                    //

                    IFR( pStart->IsEqualTo(spTemp, &fEqual) );
                    if (!fEqual)
                    {
                        IFR( GetEditor()->InsertElement(spElement, spTemp, pStart) );
                        fCommit = TRUE;

                        //
                        // Make sure we make some progress after push back.
                        // For example {pCurrent}{spTemp}</X>
                        //
                        IFR( spTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );
                        IFR( spTemp->IsEqualTo(pCurrent, &fEqual) );
                        if (fEqual)
                        {
                            IFR( pCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                        }

                    }
                    continue;
                }

                //
                // Try to extend the left of the command segment to avoid overlap
                //
                
                IFR( spPointer->MoveToPointer(pStart) );
                IFR( spPointer->Left( TRUE, &context, NULL, NULL, NULL) );
                
                if (context == CONTEXT_TYPE_ExitScope)
                {                   
                    // We have a begin TAG right before our current 'start' tag position.  Instead
                    // of creating an overlapped tag, see if it will be possible to 'encompass' the
                    // other tag with the tag we are creating.
                    
                    IFR( pCurrent->CurrentScope(&spElement) );

                    if (spElement != NULL)
                    {                   
                        // Get the type of the element at the start, and compare to the element
                        // we want to move past.  Make sure they are the same or we might 
                        // make overlapping tags
                        
                        IFR( spElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
                        IFR( spPointer->CurrentScope(&spElement) );
                        
                        IFR( spIdent->IsEqualObject(spElement) );
                        if( hr == S_OK )
                        {
                            // We want to save the current position.  We are about
                            // to move the current tag around another tag set. We 
                            // may not want to commit this action if it doesn't bring
                            // about a savings in the number of tags we generate.
                            if( fCommit == TRUE )
                            {
                                IFR( spStartSave->MoveToPointer( pStart ) );
                                IFR( spCurrentSave->MoveToPointer( pCurrent ) );
                                IFR( Move( spCurrentSave, LEFT, TRUE, NULL, NULL ) );
                            }
                            
                            IFR( pStart->MoveToPointer( spPointer ) );

                            fCommit = FALSE;
                            continue;
                        }
                    }
                }

                IFR( Move(pCurrent, LEFT, TRUE, NULL, NULL) );
                IFR( pSearch->MoveToPointer( pCurrent ) );                   
                goto Cleanup;
                                   
            case CONTEXT_TYPE_NoScope:
            case CONTEXT_TYPE_Text:

                fCommit = TRUE;
                continue;
        }
    }

Cleanup:

    if( fCommit == FALSE )
    {
        IFR( pStart->MoveToPointer( spStartSave ) );
        IFR( pCurrent->MoveToPointer( spCurrentSave ) );
    }
    
    return S_OK;
}

BOOL 
CBaseCharCommand::CanPushFontTagBack(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    UINT            iCount;
    CVariant        var;
    
    if (_tagId != TAGID_FONT)
        goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    if (tagId != TAGID_FONT)
        goto Cleanup;

    IFC( GetEditor()->GetElementAttributeCount(pElement, &iCount) );
    if (iCount > 1)
        goto Cleanup;

    switch (_cmdId)
    {
        case IDM_FORECOLOR:
            IFR( pElement->getAttribute(_T("color"), 0, &var) )
            break;

        case IDM_BACKCOLOR:
            {
                SP_IHTMLStyle spStyle;

                IFR( pElement->get_style(&spStyle) );
                IFR( spStyle->getAttribute(_T("backgroundColor"), 0, &var) )
            }
            break;
            
        case IDM_FONTSIZE:
            IFR( pElement->getAttribute(_T("size"), 0, &var) )
            break;
            
        case IDM_FONTNAME:
            IFR( pElement->getAttribute(_T("face"), 0, &var) )
            break;
    }
    if (!var.IsEmpty() && !(V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL))
        return TRUE;
    

Cleanup:
    return FALSE;
}


HRESULT
CBaseCharCommand::ApplyCommandToWord(VARIANT      * pvarargIn,
                                     VARIANT      * pvarargOut,
                                     ISegmentList * pSegmentList,
                                     BOOL           fApply)
{
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pmpStart = NULL;
    IMarkupPointer    * pmpEnd = NULL;
    CSegmentListIter    iter;
    BOOL                fInWord = FALSE;
    HRESULT             hr = S_FALSE;
    BOOL                fEmpty = FALSE;

    Assert(pSegmentList);

    if (pvarargOut)
        goto Cleanup;

    IFC( pSegmentList->IsEmpty( &fEmpty ) );
    if (fEmpty)
        goto Cleanup;

    IFC( iter.Init(GetEditor(), pSegmentList) );

    IFC( iter.Next(&pmpStart, &pmpEnd) );
    Assert(pmpStart && pmpEnd);

    // Check to see if we are inside a word, and if so expand markup pointers.
    hr = THR(ExpandToWord(pMarkupServices, pmpStart, pmpEnd));
    if (hr)
        goto Cleanup;

    // We now know we are inside a word.
    if (fApply)
        hr = THR(Apply(GetCommandTarget(), pmpStart, pmpEnd, pvarargIn));
    else
    {
        Assert(_tagId != TAGID_FONT);
        hr = THR(((CCharCommand *)this)->Remove(GetCommandTarget(), pmpStart, pmpEnd));
    }

    fInWord = TRUE;

Cleanup:

    if (!hr && !fInWord)
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}


//=========================================================================
//
// CBaseCharCommand: AdjustEndPointer
//
// Synopsis: Adjusts the segment end pointer
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::AdjustEndPointer(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT hr = S_OK;

    //
    // If word selection mode, trim off trailing space
    //

    if (!GetCommandTarget()->IsRange())
    {
        SP_ISegmentList     spSegmentList;
        SELECTION_TYPE      eSelectionType;

        IFC( GetSegmentList(&spSegmentList) );
        IFC( spSegmentList->GetType(&eSelectionType) );
        
        if (eSelectionType == SELECTION_TYPE_Text)
        {
            CSelectionManager *pSelMan = GetEditor()->GetSelectionManager();        
            
            if (pSelMan->GetActiveTracker() && pSelMan->GetSelectionType() == SELECTION_TYPE_Text)
            {
                CSelectTracker *pSelectTracker = DYNCAST(CSelectTracker, pSelMan->GetActiveTracker());

                if (pSelectTracker->IsWordSelectionMode())
                {
                    CEditPointer epEnd(GetEditor());
                    DWORD        dwBreak = BREAK_CONDITION_OMIT_PHRASE;
                    DWORD        dwFound;
                    BOOL         fEqual;

                    //
                    // Trim trailing whitespace
                    //
                    
                    IFC( epEnd->MoveToPointer(pEnd) );
                    IFC( epEnd.Scan(LEFT, dwBreak, &dwFound, NULL, NULL, NULL, 
                                    SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP) );
                                    
                    IFC( epEnd.Scan(RIGHT, dwBreak, &dwFound) );

                    //
                    // If there is no trailing whitespace, don't adjust the selection
                    //
                    
                    IFC( epEnd.IsEqualTo(pEnd, BREAK_CONDITION_ANYTHING - dwBreak, &fEqual) );

                    if (!fEqual)
                    {
                        //
                        // Make sure we have not generated an empty segment
                        //
                        
                        IFC( epEnd.IsEqualTo(pStart, BREAK_CONDITION_ANYTHING - dwBreak, &fEqual) );

                        if (!fEqual)
                        {
                            IFC( pEnd->MoveToPointer(epEnd) );
                        }
                    }                                        
                }
            }                       
        }
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBaseCharCommand: PrivateApply
//
// Synopsis: Applies the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::PrivateApply( 
    IMarkupPointer    *pStart, 
    IMarkupPointer    *pEnd,
    VARIANT           *pvarargIn,
    BOOL              fGenerateEmptyTags)
{
    HRESULT             hr;
    BOOL                bEqual;
    SP_IHTMLElement     spElement;

    if (fGenerateEmptyTags)
    {
        IFC( pStart->IsEqualTo(pEnd, &bEqual) );

        if (bEqual)
        {
            IFC( InsertTag(pStart, pStart, pvarargIn) );

            hr = S_OK; // done
            goto Cleanup;
        }
        else
        {
            //
            // HACKHACK:
            // If there is no text in between we should simply generate an
            // empty tag here. This is workaround for #112374
            // In the future, we should consider a more intelligent way to
            // apply format to caret/empty line. 
            //
            IFC( EdUtil::EqualPointers(GetMarkupServices(), pStart, pEnd, &bEqual, TRUE) );
            if (bEqual)
            {
                IFC( InsertTag(pStart, pEnd, pvarargIn) );

                hr = S_OK; // done
                goto Cleanup;
            }
        }
    }

    //
    // Adjust the end pointer.  For example, if we're in word selection mode, we want to 
    // trim trailing whitespace.
    //
    
    IGNORE_HR( AdjustEndPointer(pStart, pEnd) );
    
    //
    // First expand to the find the maximum segment that will be under the influence of
    // this type of command.  
    //

    IFC( ExpandCommandSegment(pStart, LEFT, pvarargIn) );
    IFC( ExpandCommandSegment(pEnd, RIGHT, pvarargIn) );

    //
    // Remove all similar tags contained within the segment
    //


    IFC( RemoveSimilarTags(pStart, pEnd, pvarargIn) );
    
    //
    // Insert tags in current segment
    //

    IFC( InsertTags(pStart, pEnd, pEnd, pvarargIn, fGenerateEmptyTags) );


Cleanup:    
    RRETURN(hr);
}
                          

//=========================================================================
//
// CCharCommand: constructor
//
//-------------------------------------------------------------------------
CCharCommand::CCharCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor * pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
//
// CCharCommand: PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CCharCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr;
    OLECMD              cmd;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    IMarkupPointer      *pStart;
    IMarkupPointer      *pEnd;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmptyTags;                 // Do we generate empty tags?
    BOOL                fEmpty = FALSE;
    
    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
    {
        hr = S_OK;
        goto Cleanup;
    }


    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                           
    IFC( PrivateQueryStatus(&cmd, NULL ));
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    // Give the current word a chance to intercept the command.
    hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, cmd.cmdf == MSOCMDSTATE_UP));
    if (hr != S_FALSE)
        goto Cleanup;

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;

    // We don't allow empty hyperlinks.  For all other formatting commands,
    // we allow empty tags to be inserted.  This allows empty blocks to 
    // have tags inserted correctly.
    fEmptyTags = (_cmdId == IDM_HYPERLINK) ? FALSE : TRUE;
    
    hr = S_OK;
    
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (cmd.cmdf == MSOCMDSTATE_UP)
            IFC( PrivateApply(pStart, pEnd, NULL, fEmptyTags) )
        else
            IFC( PrivateRemove(pStart, pEnd) );
    }
    

Cleanup:

    RRETURN(hr);
}

//=========================================================================
// CCharCommand: PrivateQueryStatus
//
//  Synopsis: Returns the format data for the first character in the segment
//            list.  NOTE: this is the same behavior as Word97 and IE401.
//
//-------------------------------------------------------------------------
HRESULT
CCharCommand::PrivateQueryStatus( 
                    OLECMD * pCmd,
                    OLECMDTEXT * pcmdtext )

{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_ISegmentList     spSegmentList;
    CSpringLoader       *psl = GetSpringLoader();
    SELECTION_TYPE      eSelectionType;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( GetSegmentList( &spSegmentList ));

    // Give the spring loader a chance to intercept the query.
    hr = THR(psl->PrivateQueryStatus(_cmdId, pCmd));
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;
        
    //
    // Retrieve the first segment's pointers.  We have at least
    // one segment because CommonQuerySTatus was successful.
    //
    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    IFC( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        DWORD           dwFound;
        CEditPointer    ep( GetEditor() );

        IFC( ep.MoveToPointer( spStart ) );

        // We don't want to break if we enter or exit an anchor. (bug 89089)
        IFC( ep.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE & ~BREAK_CONDITION_Anchor, &dwFound ) );

        if( !ep.CheckFlag( dwFound, BREAK_CONDITION_TEXT) )
        {
            SP_IDisplayPointer spDispPointer;
            
            // $TODO - For now, we just hard code the fNotAtBol parameter to FALSE,
            // In the future, this needs to use a display pointer to get the BOLness

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( spDispPointer->MoveToMarkupPointer(spStart, NULL) )

            IFC( GetEditor()->AdjustPointerForInsert( spDispPointer, TRUE, NULL, NULL ) );
            IFC( spDispPointer->PositionMarkupPointer(spStart) );
        }
        else
        {
            IFC( spStart->MoveToPointer( ep ) );
        }
    }

    if (IsCmdInFormatCache(spStart, NULL))
        pCmd->cmdf = MSOCMDSTATE_DOWN;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CCharCommand: Remove
//
//-------------------------------------------------------------------------
HRESULT 
CCharCommand::Remove( 
    CMshtmlEd       *pCmdTarget,
    IMarkupPointer  *pStart, 
    IMarkupPointer  *pEnd)
{
    HRESULT             hr, hrResult;
    SP_IMarkupPointer   spStartCopy;
    SP_IMarkupPointer   spEndCopy;

    IFC( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFC( spStartCopy->SetGravity(POINTER_GRAVITY_Right) );

    IFC( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );     
    IFC( spEndCopy->SetGravity(POINTER_GRAVITY_Left) );

    IFC( GetEditor()->PushCommandTarget(pCmdTarget) );

    hrResult = THR( PrivateRemove(spStartCopy, spEndCopy) );
    
    IFC( GetEditor()->PopCommandTarget(WHEN_DBG(pCmdTarget)) );

    hr = hrResult;

Cleanup:
    RRETURN(hr);
}


//=========================================================================
//
// CBaseCharCommand: PrivateRemove
//
// Synopsis: Removes the command
//
//-------------------------------------------------------------------------
HRESULT 
CBaseCharCommand::PrivateRemove( 
    IMarkupPointer    *pStart, 
    IMarkupPointer    *pEnd,
    VARIANT           *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartCopy;
    SP_IMarkupPointer   spEndCopy;
    BOOL                bEqual;

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spStartCopy) );
    IFR( CopyMarkupPointer(GetEditor(), pEnd, &spEndCopy) );
    
    //
    // First expand to the find the maximum segment that will be under the influence of
    // this type of command.  
    //
    
    IFR( ExpandCommandSegment(spStartCopy, LEFT, pvarargIn) );
    IFR( ExpandCommandSegment(spEndCopy, RIGHT, pvarargIn) );

    //
    // Remove all similar tags contained within the segment
    //

    IFR( RemoveSimilarTags(spStartCopy, spEndCopy, pvarargIn) );

    //
    // Next, re-insert segments outside selection   
    //

    IFR(pStart->IsEqualTo(spStartCopy, &bEqual) );
    if (!bEqual)
        IFR( PrivateApply(spStartCopy, pStart, pvarargIn, FALSE) );
 
    IFR(pEnd->IsEqualTo(spEndCopy, &bEqual) );
    if (!bEqual)
        IFR( PrivateApply(pEnd, spEndCopy, pvarargIn, FALSE) );
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       AreAttributesEqual
//
//  Synopsis:     Returns true if attributes of both tags are equal
//
//----------------------------------------------------------------------------
BOOL 
CCharCommand::AreAttributesEqual(IHTMLElement *pElementLeft, IHTMLElement *pElementRight)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagIdLeft, tagIdRight;

    // TODO: check attributes as well
    IFC( GetMarkupServices()->GetElementTagId(pElementLeft, &tagIdLeft) );
    IFC( GetMarkupServices()->GetElementTagId(pElementRight, &tagIdRight) );

    return (tagIdLeft == tagIdRight && tagIdLeft != TAGID_FONT);
    
Cleanup:
    return FALSE;
}

//=========================================================================
//
// CBaseCharCommand: TryTagMerge
//
//-------------------------------------------------------------------------

HRESULT 
CBaseCharCommand::TryTagMerge(
    IMarkupPointer *pCurrent)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElementLeft;
    SP_IHTMLElement         spElementRight;
    MARKUP_CONTEXT_TYPE     context;
    ELEMENT_TAG_ID          tagId;
    
    IFR( pCurrent->Right( FALSE, &context, &spElementRight, NULL, NULL) );
    if (context == CONTEXT_TYPE_EnterScope)
    {
        IFR( pCurrent->Left( FALSE, &context, &spElementLeft, NULL, NULL ) );
        if (context == CONTEXT_TYPE_EnterScope) 
        {
            // TODO: check attributes as well. [ashrafm]            
            
            if (AreAttributesEqual(spElementLeft, spElementRight))
            {
                SP_IMarkupPointer spStart, spEnd;

                // Merge tags
    
                IFR( GetEditor()->CreateMarkupPointer(&spStart) );
                IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

                IFR( spStart->MoveAdjacentToElement(spElementLeft, ELEM_ADJ_BeforeBegin) );
                IFR( spEnd->MoveAdjacentToElement(spElementRight, ELEM_ADJ_AfterEnd) );

                // TODO: this call needs to change when font tag merging is added
                IFR( GetMarkupServices()->GetElementTagId(spElementLeft, &tagId) );
                IFR( CreateAndInsert(tagId, spStart, spEnd, NULL) );

                IFR( GetMarkupServices()->RemoveElement(spElementLeft) );
                IFR( GetMarkupServices()->RemoveElement(spElementRight) );
            }
        }
        
    }
    

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       IsCmdInFormatChache
//
//  Synopsis:     Returns S_OK if the command is in the format cache
//                data.  Otherwise, S_FALSE is returned.
//
//----------------------------------------------------------------------------

BOOL
CCharCommand::IsCmdInFormatCache(IMarkupPointer  *pMarkupPointer,
                                 VARIANT         *pvarargIn)
{
    HRESULT               hr;
    VARIANT_BOOL          bResult = VB_FALSE;
    SP_IHTMLComputedStyle spComputedStyle;

    IFC(GetDisplayServices()->GetComputedStyle(pMarkupPointer, &spComputedStyle));

    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFC(spComputedStyle->get_bold(&bResult));
            break;

        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            IFC(spComputedStyle->get_italic(&bResult));
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFC(spComputedStyle->get_underline(&bResult));
            break;

        case IDM_STRIKETHROUGH:
            IFC(spComputedStyle->get_strikeOut(&bResult));
            break;

        case IDM_SUBSCRIPT:
            IFC(spComputedStyle->get_subScript(&bResult));
            break;

        case IDM_SUPERSCRIPT:
            IFC(spComputedStyle->get_superScript(&bResult));
            break;

        default:
            Assert(0); // unsupported cmdId
    }

Cleanup:
    return !!bResult;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: ConvertFormatDataToVariant
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle      *pComputedStyle,
    VARIANT                 *pvarargOut )
{
    AssertSz(0, "CCharCommand::ConvertFormatDataToVariant not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: IsFormatDataEqual
//
//----------------------------------------------------------------------------

BOOL
CCharCommand::IsFormatDataEqual(IHTMLComputedStyle *, IHTMLComputedStyle *)
{
    AssertSz(0, "CCharCommand::IsFormatDataEqual not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL 
CCharCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    AssertSz(0, "CCharCommand::IsVariantEqual not implemented");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    RRETURN( CreateAndInsert(_tagId, pStart, pEnd, NULL) );
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: RemoveTag
//
//----------------------------------------------------------------------------

HRESULT 
CCharCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT           hr;
    SP_IMarkupPointer spLeft, spRight;

    // TODO: check if it has attributes and convert to span if it does not

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( GetMarkupServices()->RemoveElement(pElement) );

    IFR( TryTagMerge(spLeft) );
    IFR( TryTagMerge(spRight) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CCharCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT 
CCharCommand::InsertStyleAttribute(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLStyle   spStyle;

    IFR( pElement->get_style(&spStyle) );
    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFR( spStyle->put_fontWeight(_T("bold")) );
            break;
            
        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            VARIANT var;

            V_VT(&var) = VT_BSTR;
            V_BSTR(&var) = _T("italic");
            
            IFR( spStyle->setAttribute(_T("fontStyle"), var, 0) );
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFR( spStyle->put_textDecorationUnderline(VB_TRUE) );
            break;
    }

    return S_OK;
}

HRESULT 
CCharCommand::RemoveStyleAttribute(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLStyle   spStyle;

    IFR( pElement->get_style(&spStyle) );
    switch (_cmdId)
    {
        case IDM_BOLD:
        case IDM_TRISTATEBOLD:
            IFR( spStyle->put_fontWeight(_T("normal")) );
            break;
            
        case IDM_ITALIC:
        case IDM_TRISTATEITALIC:
            IFR( spStyle->removeAttribute(_T("fontStyle"), 0, NULL) );
            break;

        case IDM_UNDERLINE:
        case IDM_TRISTATEUNDERLINE:
            IFR( spStyle->put_textDecorationUnderline(VB_FALSE) );
            break;
    }

    return S_OK;
}

//=========================================================================
//
// CTriStateCommand: constructor
//
//=========================================================================
CTriStateCommand::CTriStateCommand ( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor *pEd )
: CCharCommand(cmdId, tagId, pEd)
{
    // do nothing
}

//=========================================================================
//
// CTriStateCommand: PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CTriStateCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr;
    OLECMD              cmd;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    IMarkupPointer      *pStart;
    IMarkupPointer      *pEnd;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                           
    IFR( CCharCommand::PrivateQueryStatus(&cmd, NULL ));
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    // Give the current word a chance to intercept the command.
    hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, cmd.cmdf == MSOCMDSTATE_UP));
    if (hr != S_FALSE)
        goto Cleanup;

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;

    hr = S_OK;
    
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (cmd.cmdf == MSOCMDSTATE_UP)
            IFC( PrivateApply(pStart, pEnd, NULL, TRUE) )
        else
            IFC( PrivateRemove(pStart, pEnd) );
    }
    
Cleanup:

    RRETURN(hr);
}

//=========================================================================
// CTriStateCommand: PrivateQueryStatus
//
//  Synopsis: Similar to CCharCommand::PrivateQueryStatus, but 
//  searches the markup to check for tristatedness. 
//  NOTE: This is the same behavior as Word 2000.
//
//-------------------------------------------------------------------------
HRESULT
CTriStateCommand::PrivateQueryStatus( 
        OLECMD     * pCmd,
        OLECMDTEXT * pcmdtext )

{
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pStart;
    IMarkupPointer          *pEnd;
    SP_ISegmentList         spSegmentList;
    CSegmentListIter        iter;
    CSpringLoader           *psl = GetSpringLoader();
    DWORD                   dwFound;
    CEditPointer            ep( GetEditor() );
    SELECTION_TYPE          eSelectionType;
    BOOL                    fInitialState;
    BOOL                    fCurrentState;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( GetSegmentList( &spSegmentList ));

    // Give the spring loader a chance to intercept the query.
    hr = THR(psl->PrivateQueryStatus(_cmdId, pCmd));
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    IFC( iter.Init(GetEditor(), spSegmentList) );
    IFC( iter.Next(&pStart, &pEnd) ); // We should have at least one segment, since CommonQueryStatus was successful

    IFC( ep.MoveToPointer( pStart ) );
    IFC( ep.SetBoundaryForDirection(RIGHT, pEnd) );

    IFR( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        IFC( ep.Scan( RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound ) );

        if( !ep.CheckFlag( dwFound, BREAK_CONDITION_TEXT) )
        {
            SP_IDisplayPointer spDispPointer;
        
            // $TODO - For now, we just hard code the fNotAtBol parameter to FALSE,
            // In the future, this needs to use a display pointer to get the BOLness

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            IFC( spDispPointer->MoveToMarkupPointer(pStart, NULL) )

            IFC( GetEditor()->AdjustPointerForInsert( spDispPointer, TRUE, NULL, NULL ) );
            IFC( spDispPointer->PositionMarkupPointer(pStart) );
        }
        else
        {
            IFC( pStart->MoveToPointer( ep ) );
        }
    }

    //
    // Now check to see if there are different formats exist 
    // inside the first segment
    //
    fInitialState = IsCmdInFormatCache(pStart, NULL);
    do 
    {
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Text, &dwFound) );
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;
            
        fCurrentState = IsCmdInFormatCache(ep, NULL);
        if (fCurrentState != fInitialState)
        {
            pCmd->cmdf = MSOCMDSTATE_NINCHED;
            goto Cleanup;
        }
        
    } while (TRUE);
    
    if (fInitialState)
        pCmd->cmdf = MSOCMDSTATE_DOWN;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CFontCommand: constructor
//
//-------------------------------------------------------------------------
CFontCommand::CFontCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, CHTMLEditor *pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//+---------------------------------------------------------------------------
//
//  Method:       IsCmdInFormatChache
//
//  Synopsis:     Returns S_OK if the command is in the format cache
//                data.  Otherwise, S_FALSE is returned.
//
//----------------------------------------------------------------------------

BOOL 
CFontCommand::IsCmdInFormatCache(IMarkupPointer  *pCurrent,
                                 VARIANT         *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLComputedStyle   spComputedStyle;
    BOOL                    bResult = FALSE;
    VARIANT                 var;

    VariantInit(&var);

    IFC( GetDisplayServices()->GetComputedStyle(pCurrent, &spComputedStyle) );
    IFC( ConvertFormatDataToVariant(spComputedStyle, &var) );

    bResult = IsVariantEqual(&var, pvarargIn);
    VariantClear(&var);

Cleanup:
    return bResult;
}

//=========================================================================
// CFontCommand: GetCommandRange
//
// Synopsis: Get the range of the font command (usually for dropdowns)
//
//-------------------------------------------------------------------------
HRESULT 
CFontCommand::GetCommandRange(VARIANTARG *pvarargOut)
{
    HRESULT hr = S_OK;

    Assert(pvarargOut && V_VT(pvarargOut) == VT_ARRAY);

    switch (_cmdId)
    {
    case IDM_FONTSIZE:
    {
        // IDM_FONTSIZE command is from form toolbar (font size combobox)
        // * V_VT(pvarargIn)  = VT_I4/VT_BSTR   : set font size
        // * V_VT(pvarargOut) = VT_I4           : request current font size setting
        // * V_VT(pvarargOut) = VT_ARRAY        : request all possible font sizes

        SAFEARRAYBOUND sabound;
        SAFEARRAY * psa;
        long l, lZoom;

        sabound.cElements = FONTMAX - FONTMIN + 1;
        sabound.lLbound = 0;
        psa = SafeArrayCreate(VT_I4, 1, &sabound);

        for (l = 0, hr = S_OK, lZoom = FONTMIN;
             l < (FONTMAX - FONTMIN + 1) && SUCCEEDED(hr);
             l++, lZoom++)
        {
            hr = THR_NOTRACE(SafeArrayPutElement(psa, &l, &lZoom));
        }

        V_ARRAY(pvarargOut) = psa;
    }
        break;

    default:
        Assert(!"CFontCommand::Exec VT_ARRAY-out mode only supported for IDM_FONTSIZE");
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//=========================================================================
// CFontCommand: GetFirstSegmentFontValue
//
// Synopsis: Returns the font value for the first segment in a segment list
//
//-------------------------------------------------------------------------
HRESULT
CFontCommand::GetFirstSegmentFontValue(
    ISegmentList    *pSegmentList,
    VARIANT         *pvarargOut
    )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLComputedStyle   spComputedStyle;
    SP_IHTMLComputedStyle   spComputedStyle2;
    SELECTION_TYPE          eSelType;
    BOOL                    fEmpty = FALSE;
    MARKUP_CONTEXT_TYPE     context;
    INT                     iPosition;
    BOOL                    fEqual;
    
    Assert(pSegmentList);
    Assert(pvarargOut);

    if (pvarargOut)
    {
        V_VT(pvarargOut)    = VT_NULL;
        V_BSTR(pvarargOut)  = NULL;
    }

    IFC( pSegmentList->GetType(&eSelType) );
    IFC( pSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty) 
    {
        return S_OK;
    }

    //
    // Get Initial FontValue
    //
    IFC( GetFirstSegmentPointers(pSegmentList, &spStart, &spEnd) );
    
    //
    // HACKHACK: we often get an empty selection when the user clicks, so check for this
    // case and assume we have a caret
    //
    if (eSelType == SELECTION_TYPE_Text)
    {
        IFC( spStart->IsEqualTo(spEnd, &fEqual) );
        if (fEqual)
        {
            eSelType = SELECTION_TYPE_Caret;
        }
    }

    //
    // Get the computed style
    //

    if (SELECTION_TYPE_Text == eSelType || GetCommandTarget()->IsRange() )
    {
        CEditPointer epStart(GetEditor());
        CEditPointer ep(GetEditor());
        DWORD        dwFound;

        IFC( epStart->MoveToPointer(spStart) );
        IFC( ClingToText(epStart, RIGHT, NULL) );

        //
        // If we're not adjacent to text, check if we're at EOP.  In this case, 
        // formatting is taken from the text to the left.       
        //

        IFC( ep->MoveToPointer(epStart) );
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

        if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Block))
        {
            IFC( spStart->MoveToPointer(epStart) );
        }

    }
    IFC( GetDisplayServices()->GetComputedStyle(spStart, &spComputedStyle) );

    //
    // Check to see if there are inconsistent FontValues
    //
    if (eSelType == SELECTION_TYPE_Text ||
        GetCommandTarget()->IsRange() )
    {
        IFC( ClingToText(spStart, RIGHT, NULL, FALSE, TRUE) );
        IFC( ClingToText(spEnd, LEFT, NULL, FALSE, TRUE) );
    }
    
    do 
    {
        IFC( OldCompare(spStart, spEnd, &iPosition) );
        if (RIGHT != iPosition) 
            break;
        

        IFC( Move(spStart, RIGHT, TRUE, &context, NULL) );
        if (CONTEXT_TYPE_Text == context)
        {
            IFC( GetDisplayServices()->GetComputedStyle(spStart, &spComputedStyle2) );
            if (!IsFormatDataEqual(spComputedStyle, spComputedStyle2))
            {
                V_VT(pvarargOut)    = VT_NULL;
                V_BSTR(pvarargOut)  = NULL;
                goto Cleanup;
            }
            
        }
    } while (TRUE);
    
    IFC( ConvertFormatDataToVariant(spComputedStyle, pvarargOut) );
    
Cleanup:
    RRETURN(hr);
}





//=========================================================================
// CFontCommand: PrivateExec
//
// Synopsis: Exec for font commands
//
//-------------------------------------------------------------------------

HRESULT
CFontCommand::PrivateExec( 
        DWORD             nCmdexecopt,
    VARIANTARG *      pvarargIn,
    VARIANTARG *      pvarargOut )
{
    HRESULT             hr;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    CSegmentListIter    iter;
    SP_IMarkupPointer   spSegmentLimit;
    CSpringLoader       * psl = GetSpringLoader();
    SP_ISegmentList     spSegmentList;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spPointer;
    CEdUndoHelper       undoUnit(GetEditor());
    BOOL                fEmpty = FALSE;
    SP_IHTMLComputedStyle spComputedStyle;
    
    // Handle VT_ARRAY range requests first.
    if (pvarargOut && V_VT(pvarargOut) == VT_ARRAY)
    {
        hr = THR(GetCommandRange(pvarargOut));
        if (!hr)
        {
            // Out part successfully handled.
            pvarargOut = NULL;

            // Done?
            if (!pvarargIn)
                goto Cleanup;
        }
    }

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if (fEmpty) /// nothing to do
    {
        hr = S_OK;
        if (pvarargOut)
        {
            VariantInit(pvarargOut);
            
            if (SUCCEEDED(GetActiveElemSegment(GetMarkupServices(), &spPointer, NULL)))
            {
                if (SUCCEEDED(GetDisplayServices()->GetComputedStyle(spPointer, &spComputedStyle)))
                {
                    IGNORE_HR(ConvertFormatDataToVariant(spComputedStyle, pvarargOut));
                }
            }
        }

        goto Cleanup;
    }

    if (pvarargIn)
    {
        IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

        // Give the current word a chance to intercept the command.
        hr = THR(ApplyCommandToWord(pvarargIn, pvarargOut, spSegmentList, TRUE));
        if (hr != S_FALSE)
            goto Cleanup;
    }

    // Give the spring loader a chance to intercept the command.
    hr = THR(psl->PrivateExec(_cmdId, pvarargIn, pvarargOut, spSegmentList));
    if (hr != S_FALSE)
        goto Cleanup;
        
    hr = S_OK;
    
    if (pvarargIn)
    {
        // Set the font property
        IFC( iter.Init(GetEditor(), spSegmentList) );

        for (;;)
        {
            IFC( iter.Next(&pStart, &pEnd) );
            if (hr ==  S_FALSE)
                break;

            //
            // For site selected controls that are color commands, apply the attribute directly.
            //
            if (_cmdId == IDM_FORECOLOR )
            {
                SELECTION_TYPE      eSelectionType;
                MARKUP_CONTEXT_TYPE context;
                
                IFC( spSegmentList->GetType(&eSelectionType) );

                if (eSelectionType == SELECTION_TYPE_Control)
                {                
                    IFC( pStart->Right( FALSE, & context, & spElement, NULL, NULL ));
                    Assert( (context == CONTEXT_TYPE_EnterScope) || (context == CONTEXT_TYPE_NoScope));
                    IFC( DYNCAST( CForeColorCommand, this )->InsertTagAttribute(spElement, pvarargIn));
                }
                else
                {
                    IFC( PrivateApply(pStart, pEnd, pvarargIn, TRUE) );
                }
            }
            else
            {
                IFC( PrivateApply(pStart, pEnd, pvarargIn, TRUE) );
            }
        }
        hr = S_OK;
    }

    // Get the font property
    if (pvarargOut)
    {
        IFC( GetFirstSegmentFontValue(spSegmentList, pvarargOut) );
    }

Cleanup:        
    RRETURN(hr);
}
//=========================================================================
//
// CFontCommand: PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CFontCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )

{
    HRESULT             hr = S_OK;
    CSpringLoader       *psl = GetSpringLoader();
    SP_ISegmentList     spSegmentList;
    CVariant            var;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }

#endif

    if (!GetEditor()->GetCssEditingLevel() && _cmdId == IDM_BACKCOLOR)
    {
        // We can't do background color without css editing level of 1

        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;        
    }

    //
    // This is where the spring loader gets to intercept a command.
    //

    IFC( GetSegmentList(&spSegmentList) );
    
    IFC( psl->PrivateQueryStatus(_cmdId, pCmd) );
    if (hr != S_FALSE)
        goto Cleanup;

    //
    // Return the character format
    //

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;
    

    IFC( GetFirstSegmentFontValue(spSegmentList, &var) );
    if (var.IsEmpty())
        pCmd->cmdf = MSOCMDSTATE_NINCHED;
    else
        pCmd->cmdf = MSOCMDSTATE_UP;

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: InsertTag
//
//----------------------------------------------------------------------------
HRESULT CFontCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT         hr;
    SP_IHTMLElement spElement;

    IFR( FindReuseableTag(pStart, pEnd, &spElement) );
    if (!spElement)
    {
        IFR( GetMarkupServices()->CreateElement(_tagId, NULL, &spElement) );            
        IFR( InsertTagAttribute(spElement, pvarargIn) );
        IFR( GetEditor()->InsertElement(spElement, pStart, pEnd) );
    }
    else
    {
        IFR( InsertTagAttribute(spElement, pvarargIn) );
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: FindReuseableTag
//
//----------------------------------------------------------------------------
HRESULT 
CFontCommand::FindReuseableTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd, spTemp;
    SP_IHTMLElement     spScope, spParentScope;
    MARKUP_CONTEXT_TYPE context;
    BOOL                bEqual;
    ELEMENT_TAG_ID      tagId;

    *ppElement = NULL;

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( GetEditor()->CreateMarkupPointer(&spTemp) );
    
    IFR( spStart->MoveToPointer(pStart) );
    IFR( ClingToText(spStart, RIGHT, pEnd) );    
    IFR( spEnd->MoveToPointer(pEnd) );
    IFR( ClingToText(spEnd, LEFT, pStart) );    
    
    IFR( spStart->CurrentScope(&spScope) );

    while (spScope != NULL)
    {
        IFR( spTemp->MoveAdjacentToElement(spScope, ELEM_ADJ_AfterBegin) );
        IFR( spStart->IsEqualTo(spTemp, &bEqual) );
        if (!bEqual)
            return S_OK;
        
        IFR( spTemp->MoveAdjacentToElement(spScope, ELEM_ADJ_BeforeEnd) );
        IFR( spEnd->IsEqualTo(spTemp, &bEqual) );
        if (!bEqual)
            return S_OK;

        IFR( GetMarkupServices()->GetElementTagId(spScope, &tagId) );
        if (tagId == TAGID_FONT)
        {
            *ppElement = spScope;
            (*ppElement)->AddRef();
            return S_OK;
        }
        
        IFR( Move(spStart, LEFT, TRUE, &context, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            return S_OK;
            
        IFR( Move(spEnd, RIGHT, TRUE, &context, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            return S_OK;

        IFR( GetEditor()->GetParentElement( spScope, &spParentScope) );
        spScope = spParentScope;
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT CFontCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft, spRight;
    CVariant            var;
    UINT                iCount;

    if (!pvarargIn)
        return S_OK;

    switch (_cmdId)
    {
        case IDM_FORECOLOR:
            IFR( pElement->removeAttribute(_T("color"), 0, NULL) )
            break;

        case IDM_BACKCOLOR:
            {
                SP_IHTMLStyle spStyle;

                IFR( pElement->get_style(&spStyle) );
                IFR( spStyle->removeAttribute(_T("backgroundColor"), 0, NULL) )
            }
            break;
            
        case IDM_FONTSIZE:
            IFR( pElement->removeAttribute(_T("size"), 0, NULL) )
            break;
            
        case IDM_FONTNAME:
            IFR( pElement->removeAttribute(_T("face"), 0, NULL) )
            break;
    }

    IFR( GetEditor()->GetElementAttributeCount(pElement, &iCount) );
    if (iCount > 0)
        return S_OK; 

    // TODO: check if it has attributes and convert to span if it does not

    //
    // Remove the tag
    //

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( GetMarkupServices()->RemoveElement(pElement) );

    IFR( TryTagMerge(spLeft) );
    IFR( TryTagMerge(spRight) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CFontCommand: IsValidOnControl
//
//----------------------------------------------------------------------------
BOOL 
CFontCommand::IsValidOnControl()
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_IHTMLElement         spElement;
    ELEMENT_TAG_ID          tagId;
    BOOL                    fValid = FALSE;
    BOOL                    fEmpty = FALSE;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty)
        goto Cleanup;

    IFC( spSegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( GetSegmentElement(spSegment, &spElement ) );
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

        fValid = (tagId == TAGID_HR && _cmdId == IDM_FORECOLOR);
        if ( ! fValid )
            goto Cleanup;

        ClearInterface( & spElement );

        IFC( spIter->Advance() );
    }
    
Cleanup:    
    return fValid;
}
    

//=========================================================================
//
// CFontNameCommand: constructor
//
//-------------------------------------------------------------------------
CFontNameCommand::CFontNameCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CFontNameCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CFontNameCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;
    TCHAR   szFont[LF_FACESIZE+1];

    IFC( pComputedStyle->get_fontName((TCHAR *)&szFont) );

    V_VT(pvar) = VT_BSTR;
    V_BSTR(pvar) = SysAllocString(szFont);
    if (V_BSTR(pvar) == NULL)
        hr = E_OUTOFMEMORY;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CFontNameCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CFontNameCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT hr;
    TCHAR   szFontA[LF_FACESIZE+1];
    TCHAR   szFontB[LF_FACESIZE+1];

    IFC( pComputedStyleA->get_fontName((TCHAR *)&szFontA) );
    IFC( pComputedStyleB->get_fontName((TCHAR *)&szFontB) );
    
    return (StrCmp(szFontA, szFontB) == 0);

Cleanup:
    return FALSE;
}

//=========================================================================
// CFontNameCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CFontNameCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareFontName(pvarA, pvarB);
}

//=========================================================================
// CFontNameCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CFontNameCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT hr = S_OK;

    // Set the property
    if (pvarargIn)
        hr = THR(pElement->setAttribute(_T("FACE"), *pvarargIn, 0));

    RRETURN(hr);
}

//=========================================================================
//
// CFontSizeCommand: constructor
//
//-------------------------------------------------------------------------
CFontSizeCommand::CFontSizeCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CFontSizeCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CFontSizeCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;    
    LONG    lTwips;
    int     htmlSize;

    IFC( pComputedStyle->get_fontSize(&lTwips) );
    htmlSize = EdUtil::ConvertTwipsToHtmlSize(lTwips);

    if (EdUtil::ConvertHtmlSizeToTwips(htmlSize) == lTwips)
    {
        V_VT(pvar) = VT_I4;
        V_I4(pvar) = htmlSize;
    }
    else
        V_VT(pvar) = VT_NULL;

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CFontSizeCommand::IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CFontSizeCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT hr;
    LONG    lFontSizeA, lFontSizeB;

    IFC( pComputedStyleA->get_fontSize(&lFontSizeA) );
    IFC( pComputedStyleB->get_fontSize(&lFontSizeB) );
    
    return (lFontSizeA == lFontSizeB);

Cleanup:
    return FALSE;
}

//=========================================================================
// CFontSizeCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CFontSizeCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareFontSize(pvarA, pvarB);
}

//=========================================================================
// CFontSizeCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

#define FONT_INDEX_SHIFT 3  // Font sizes on the toolbar are from -2 to 4, internally they are 1 to 7

HRESULT 
CFontSizeCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    CVariant        var;
 
    if (V_VT(pvarargIn) == VT_EMPTY)
    {
        // remove all attributes
        IFC( pElement->setAttribute(_T("SIZE"), *pvarargIn, 0) );
    }
    else
    {
        long offset = 0;

        Assert(pvarargIn);
        if (((CVariant *)pvarargIn)->IsEmpty())
            goto Cleanup;

        if (V_VT(pvarargIn) == VT_BSTR)
        {
            BSTR bstrIn = V_BSTR(pvarargIn);
            if (!bstrIn)
                goto Cleanup;

            if (*bstrIn == _T('+') || *bstrIn == _T('-'))
            {
                offset = FONT_INDEX_SHIFT;
            }
        }

        IFC(VariantChangeTypeSpecial(&var, pvarargIn, VT_I4));

        V_VT(&var) = VT_I4;
        V_I4(&var) += offset;

        if (V_I4(&var) < 1)
            V_I4(&var) = 1;
        else if (V_I4(&var) > 7)
            V_I4(&var) = 7;

        // use attribute on the element
        hr = THR(pElement->setAttribute(_T("SIZE"), var, 0));
    }

Cleanup:
    RRETURN(hr);
}

//=========================================================================
//
// CBackColorCommand: constructor
//
//-------------------------------------------------------------------------
CBackColorCommand::CBackColorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CBackColorCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CBackColorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT     hr;
    DWORD       dwBackColor;
    
    IFC( pComputedStyle->get_backgroundColor(&dwBackColor) );
    
    V_VT(pvar) = VT_I4;
    V_I4(pvar) = dwBackColor;

    IFC( ConvertRGBToOLEColor(pvar) );

Cleanup:
    RRETURN(hr);    
}

//=========================================================================
// CBackColorCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CBackColorCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{
    HRESULT      hr;
    VARIANT_BOOL fHasBgColorA, fHasBgColorB;
    BOOL         bResult;

    IFC( pComputedStyleA->get_hasBgColor(&fHasBgColorA) );
    IFC( pComputedStyleB->get_hasBgColor(&fHasBgColorB) );
    
    if (!fHasBgColorA)
    {
        bResult = !fHasBgColorB;
    }
    else
    {
        DWORD dwBackColorA, dwBackColorB;
        
        IFC( pComputedStyleA->get_backgroundColor(&dwBackColorA) );
        IFC( pComputedStyleB->get_backgroundColor(&dwBackColorB) );

        bResult = (dwBackColorA == dwBackColorB);
    }

    return bResult;

Cleanup:
    return FALSE;
}

//=========================================================================
// CBackColorCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CBackColorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareColor(pvarA, pvarB);
}

//=========================================================================
// CBackColorCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CBackColorCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    VARIANT             var;
    SP_IHTMLStyle       spStyle;

    IFC( pElement->get_style(&spStyle) );

    VariantInit(&var);
    if (V_VT(pvarargIn) != VT_EMPTY)
    {
        IFC( VariantCopy(&var, pvarargIn) );
        IFC( ConvertOLEColorToRGB(&var) );
        IFC( spStyle->put_backgroundColor(var) );
    }
    else
    {
        IFC( spStyle->removeAttribute(_T("backgroundColor"), 0, NULL) );
    }

Cleanup:
    VariantClear(&var);
    RRETURN(hr);
}

//=========================================================================
//
// CForeColorCommand: constructor
//
//-------------------------------------------------------------------------
CForeColorCommand::CForeColorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CFontCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//=========================================================================
// CForeColorCommand: ConvertFormatDataToVariant
//
// Synopsis: returns a variant from the given format data
//-------------------------------------------------------------------------

HRESULT
CForeColorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle *pComputedStyle,
    VARIANT            *pvar)
{
    HRESULT hr;
    DWORD   dwColor;

    IFC( pComputedStyle->get_textColor(&dwColor) );

    V_VT(pvar) = VT_I4;
    V_I4(pvar) = dwColor;

    IFC( ConvertRGBToOLEColor(pvar) );

Cleanup:
    RRETURN(hr);
}

//=========================================================================
// CForeColorCommand: IsFormatDataEqual
//
// Synopsis: Compares format data based on command type
//-------------------------------------------------------------------------

BOOL
CForeColorCommand::IsFormatDataEqual(IHTMLComputedStyle *pComputedStyleA, IHTMLComputedStyle *pComputedStyleB)
{   
    HRESULT hr;
    DWORD   dwColorA, dwColorB;
    
    IFC( pComputedStyleA->get_textColor(&dwColorA) );
    IFC( pComputedStyleB->get_textColor(&dwColorB) );
    
    return (dwColorA == dwColorB);

Cleanup:
    return FALSE;
}


//=========================================================================
// CForeColorCommand: IsVariantEqual
//
// Synopsis: Compares variants based on command type
//-------------------------------------------------------------------------

BOOL
CForeColorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    return VariantCompareColor(pvarA, pvarB);
}

//=========================================================================
// CForeColorCommand: InsertTagAttribute
//
// Synopsis: Inserts the font tag attribute
//-------------------------------------------------------------------------

HRESULT 
CForeColorCommand::InsertTagAttribute(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT             hr;
    VARIANT             var;

    VariantInit(&var);
    if (V_VT(pvarargIn) != VT_EMPTY)
    {
        IFC( VariantCopy(&var, pvarargIn) );
        IFC( ConvertOLEColorToRGB(&var) );
    }

    // use attribute on the element
    IFC( pElement->setAttribute(_T("COLOR"), var, 0) );

Cleanup:
    VariantClear(&var);
    RRETURN(hr);
}


//=========================================================================
//
// CAnchorCommand: constructor
//
//-------------------------------------------------------------------------
CAnchorCommand::CAnchorCommand( DWORD cmdId, ELEMENT_TAG_ID tagId, 
CHTMLEditor * pEd )
: CBaseCharCommand(cmdId, tagId, pEd)
{
    // do nothing 
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: ConvertFormatDataToVariant
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::ConvertFormatDataToVariant(
    IHTMLComputedStyle      *pComputedStyle,
    VARIANT                 *pvarargOut )
{
    AssertSz(0, "CCharCommand::ConvertFormatDataToVariant not implemented");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL 
CAnchorCommand::IsVariantEqual(VARIANT *pvarA, VARIANT *pvarB)
{
    AssertSz(0, "CCharCommand::IsVariantEqual not implemented");
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: IsVariantEqual
//
//----------------------------------------------------------------------------
BOOL
CAnchorCommand::IsFormatDataEqual(IHTMLComputedStyle *, IHTMLComputedStyle *)
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::RemoveTag(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    RRETURN(GetMarkupServices()->RemoveElement(pElement));
}

//+---------------------------------------------------------------------------
//
//  CAnchorCommand: RemoveTag
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::InsertTag(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLAnchorElement   spAnchor;
    
    if (!pvarargIn || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;

    switch (_cmdId)
    {
        case IDM_BOOKMARK:
            IFR( InsertNamedAnchor(V_BSTR(pvarargIn), pStart, pEnd) ); 
            break;

        case IDM_HYPERLINK:
            IFR( CreateAndInsert(_tagId, pStart, pEnd, &spElement) );
            IFR( spElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&spAnchor) );
            IFR( spAnchor->put_href(V_BSTR(pvarargIn)) );
            break;

        default:
            AssertSz(0, "Unsupported anchor command");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::IsCmdInFormatCache
//
//----------------------------------------------------------------------------
BOOL
CAnchorCommand::IsCmdInFormatCache(IMarkupPointer  *pMarkupPointer,
                                 VARIANT         *pvarargIn)
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::InsertNamedAnchor
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::InsertNamedAnchor(BSTR bstrName, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CStr                strAttr;
    SP_IHTMLElement     spElement;

    //
    // HACKHACK: If we try to set the name of an element in browse mode, the OM ignores the
    // request and sets the submit name instead.  So, we need to create another element with
    // the name set.
    //

    // Build the attribute string
    if (bstrName)
    {
        IFR( strAttr.Set(_T("name=\"")) );
        IFR( strAttr.Append(bstrName) );
        IFR( strAttr.Append(_T("\"")) );
    }

    // Insert the new anchor
    IFR( GetMarkupServices()->CreateElement(TAGID_A, strAttr, &spElement) );
    IFR( GetMarkupServices()->InsertElement(spElement, pStart, pEnd) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::UpdateContainedAnchors
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::UpdateContainedAnchors(IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    CEditPointer            epTest(GetEditor());
    DWORD                   dwSearch = BREAK_CONDITION_EnterAnchor;
    DWORD                   dwFound;
    BOOL                    fFoundAnchor = FALSE;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;

    //
    // Scan for anchors and change attributes to pvarargIn
    //

    IFR( epTest->MoveToPointer(pStart) );
    IFR( epTest.SetBoundary(NULL, pEnd) );

    for (;;)
    {
        IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) );
        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;

        Assert(epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor));

        //
        // Update anchor
        //
        IFR( epTest->Left(FALSE, &context, &spElement, NULL, NULL) );

        Assert(context == CONTEXT_TYPE_ExitScope);
        if (context == CONTEXT_TYPE_ExitScope && spElement != NULL)
        {
            IFR( UpdateAnchor(spElement, pvarargIn) );            
            fFoundAnchor = TRUE;
        }
            
    }

    return (fFoundAnchor ? S_OK : S_FALSE);
}

HRESULT
CAnchorCommand::UpdateAnchor(IHTMLElement *pElement, VARIANT *pvarargIn)
{
    HRESULT                 hr;
    SP_IHTMLAnchorElement   spAnchor;

    if (!pvarargIn || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;
    
    switch (_cmdId)
    {
        case IDM_BOOKMARK:
            {
                SP_IMarkupPointer spLeft, spRight;

                IFR( GetEditor()->CreateMarkupPointer(&spLeft) )
                IFR( spLeft->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
                
                IFR( GetEditor()->CreateMarkupPointer(&spRight) );
                IFR( spRight->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
                
                IFR( InsertNamedAnchor(V_BSTR(pvarargIn), spLeft, spRight) );

                IFR( GetMarkupServices()->RemoveElement(pElement) );
            }
            break;

        case IDM_HYPERLINK:
            IFR( pElement->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&spAnchor) );
            IFR( spAnchor->put_href(V_BSTR(pvarargIn)) );
            break;

        default:
            AssertSz(0, "Unsupported anchor command");
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::PrivateExec
//
//----------------------------------------------------------------------------
HRESULT
CAnchorCommand::PrivateExec( 
        DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLElement         spElement;
    CTagBitField            tagBitField;
    SP_ISegmentList         spSegmentList;
    BOOL                    fEqual;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
        
    IFR( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    // Make sure the edit context isn't a button
    if (!GetCommandTarget()->IsRange() && GetEditor())
    {
        CSelectionManager *pSelMan;

        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            ELEMENT_TAG_ID tagId;

            IFC( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );
            if (tagId == TAGID_BUTTON)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }

    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
                            
    IFC( GetSegmentList( &spSegmentList ));
    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BSTR)
        return E_INVALIDARG;

    IFC( spSegmentList->GetType( &eSelectionType ) );
        
    tagBitField.Set(TAGID_A);
    if (IsCmdAbove(GetMarkupServices(), spStart, spEnd, &spElement, NULL, &tagBitField))
    {
        IFC( UpdateAnchor(spElement, pvarargIn) );

        if (eSelectionType != SELECTION_TYPE_Caret)
        {
            IGNORE_HR( UpdateContainedAnchors(spStart, spEnd, pvarargIn) );
        }
    }
    else
    {
        if (eSelectionType == SELECTION_TYPE_Caret)
            return E_FAIL;

        // First try to update any anchors contained in the selection.  If there are no anchors,
        // we create one below
        IFC( UpdateContainedAnchors(spStart, spEnd, pvarargIn) );
        if (hr != S_FALSE)
            goto Cleanup;

        // Create the anchor
        IFC( spStart->IsEqualTo(spEnd, &fEqual) );        

        if (fEqual)
        {
            CSpringLoader * psl = GetSpringLoader();

            IGNORE_HR(psl->SpringLoadComposeSettings(spStart));
            IGNORE_HR(psl->Fire(spStart, spEnd));
        }

        IFC( PrivateApply(spStart, spEnd, pvarargIn, fEqual) );
    }
        
Cleanup:
   RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:       CAnchorCommand::PrivateQueryStatus
//
//----------------------------------------------------------------------------
HRESULT 
CAnchorCommand::PrivateQueryStatus( 
    OLECMD *pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart, spEnd;
    CTagBitField        tagBitField;
    SELECTION_TYPE      eSelectionType;
    ELEMENT_TAG_ID      tagId;
    CSelectionManager   *pSelMan;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    // Make sure the edit context isn't a button
    if (GetEditor())
    {
        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            IFC( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );
            if (tagId == TAGID_BUTTON)
            {
                pCmd->cmdf = MSOCMDSTATE_DISABLED;                
                hr = S_OK;
                goto Cleanup;
            }
        }
    }

    // Check if we are under an anchor
    pCmd->cmdf = MSOCMDSTATE_UP; // up by default

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType( &eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Caret)
    {
        IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );
            
        tagBitField.Set(TAGID_A);
        if (!IsCmdAbove(GetMarkupServices(), spStart, spEnd, NULL, NULL, &tagBitField))
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;    
        }
    }

    hr = S_OK;
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:       CRemoveFormatBaseCommand::CRemoveFormatBaseCommand
//
//----------------------------------------------------------------------------
CRemoveFormatBaseCommand::CRemoveFormatBaseCommand(DWORD cmdId, CHTMLEditor *
ped)
: CCommand(cmdId, ped)
{
}

//+---------------------------------------------------------------------------
//
//  Method:       CRemoveFormatBaseCommand::Exec
//
//----------------------------------------------------------------------------
HRESULT 
CRemoveFormatBaseCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    SP_ISegmentList     spSegmentList;
    CSegmentListIter    iter;
    CSpringLoader       *psl = GetSpringLoader();
    CEdUndoHelper       undoUnit(GetEditor());
    int                 iSegmentCount;

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    
    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );
    IFC( iter.Init(GetEditor(), spSegmentList) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );

        if (hr == S_FALSE)
        {
            hr = S_OK; // proper termination
            break;
        }

        if (iSegmentCount == 1 && _cmdId == IDM_REMOVEFORMAT)
            IGNORE_HR(ExpandToWord(GetMarkupServices(), pStart, pEnd));

        IFC( Apply(pStart, pEnd) );

        // Apply compose font.
        if (psl && _cmdId == IDM_REMOVEFORMAT)
        {
            IFC( psl->SpringLoadComposeSettings(NULL, TRUE) );
            IFC( psl->Fire(pStart, pEnd) );
        }
    }

Cleanup:

    RRETURN(hr);
}


HRESULT
CRemoveFormatBaseCommand::Apply(
    IMarkupPointer  *pStart,
    IMarkupPointer  *pEnd,
    BOOL            fQueryMode)
{
    HRESULT             hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    INT                 iPosition;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spNewElement;
    SP_IMarkupPointer   spCurrent;
    ELEMENT_TAG_ID      tagId;
            
    //
    // Walk pStart/pEnd out so we can avoid overlapping tags
    //

    // TODO: can make this faster but be careful about pointer placement [ashrafm]
    for(;;)
    {
        IFR( pStart->Left(FALSE, &context, NULL, NULL, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            break;
        IFR( pStart->Left(TRUE, NULL, NULL, NULL, NULL) );
    }

    for(;;)
    {
        IFR( pEnd->Right(FALSE, &context, NULL, NULL, NULL) );
        if (context != CONTEXT_TYPE_ExitScope)
            break;
        IFR( pEnd->Right(TRUE, NULL, NULL, NULL, NULL) );
    }

    //
    // Set gravity
    //
    IFR( pStart->SetGravity(POINTER_GRAVITY_Right) );
    IFR( pEnd->SetGravity(POINTER_GRAVITY_Left) );

    //
    // Walk from left to right removing any tags we see
    //

    IFR( GetEditor()->CreateMarkupPointer(&spCurrent) );
    IFR( spCurrent->MoveToPointer(pStart) );
    for (;;)
    {
        // Move right
        IFR( spCurrent->Right( TRUE, &context, &spElement, NULL, NULL) );        
        IFR( OldCompare( spCurrent, pEnd, &iPosition) );
        if (iPosition != RIGHT)
            break;

        // Check tagId
        if (context == CONTEXT_TYPE_EnterScope)
        {
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if (_tagsRemove.Test(tagId))
            {
                if (fQueryMode)
                    return S_OK; // found tag
                    
                IFR( RemoveElement(spElement, pStart, pEnd) );
            }
        }        
    }

    //
    // Walk up remove tags we see
    //

    IFR( pStart->CurrentScope(&spElement) );
    for (;;)
    {
        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (_tagsRemove.Test(tagId))
        {
            if (fQueryMode)
                return S_OK; // found tag

            // Move up the tree
            IFR( GetEditor()->GetParentElement( spElement, &spNewElement) );
        
            // Remove the element
            IFR( RemoveElement(spElement, pStart, pEnd) );
        }
        else
        {
            // Move up the tree
            IFR( GetEditor()->GetParentElement( spElement, &spNewElement) );
        
        }

        if (!spNewElement)
            break;            
        spElement = spNewElement;
    }

    if (fQueryMode)
        hr = S_FALSE; // not found
        
    RRETURN1(hr, S_FALSE);
}
    

//+---------------------------------------------------------------------------
//
//  CRemoveFormatCommand Class
//
//----------------------------------------------------------------------------

CRemoveFormatCommand::CRemoveFormatCommand(DWORD cmdId, CHTMLEditor *ped)
: CRemoveFormatBaseCommand(cmdId, ped)
{
    _tagsRemove.Set(TAGID_FONT);
    _tagsRemove.Set(TAGID_B);
    _tagsRemove.Set(TAGID_U);
    _tagsRemove.Set(TAGID_I);
    _tagsRemove.Set(TAGID_STRONG);
    _tagsRemove.Set(TAGID_EM);
    _tagsRemove.Set(TAGID_SUB);
    _tagsRemove.Set(TAGID_SUP);
    _tagsRemove.Set(TAGID_STRIKE);
    _tagsRemove.Set(TAGID_S);
    _tagsRemove.Set(TAGID_ACRONYM);
    _tagsRemove.Set(TAGID_BDO);    
    _tagsRemove.Set(TAGID_BIG);
    _tagsRemove.Set(TAGID_BLINK);
    _tagsRemove.Set(TAGID_CITE);
    _tagsRemove.Set(TAGID_SAMP);
    _tagsRemove.Set(TAGID_SMALL);
    _tagsRemove.Set(TAGID_CITE);
    _tagsRemove.Set(TAGID_TT);
    _tagsRemove.Set(TAGID_VAR);
    _tagsRemove.Set(TAGID_Q);
    _tagsRemove.Set(TAGID_NOBR);
    _tagsRemove.Set(TAGID_KBD);
    _tagsRemove.Set(TAGID_INS);
    _tagsRemove.Set(TAGID_DFN);
    _tagsRemove.Set(TAGID_CODE);
}

HRESULT 
CRemoveFormatCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT         hr = S_OK ;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;

    hr = S_OK;
Cleanup:
    
    return hr;
}

HRESULT
CRemoveFormatCommand::RemoveElement(IHTMLElement *pElement, IMarkupPointer  *
pStart, IMarkupPointer  *pEnd)
{
    HRESULT         hr;
    elemInfluence   theInfluence;
    BOOL            fBlock, fLayout;

    //
    // Don't remove layout or block
    //
    IFC( IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout, NULL) );

    if (!fBlock && !fLayout)
    {
        // Check influence and split        
        theInfluence = GetElementInfluenceOverPointers(GetMarkupServices(), pStart, pEnd, pElement);
        hr = THR( SplitInfluenceElement(GetMarkupServices(), pStart, pEnd, pElement, theInfluence, NULL) ); 
    }

Cleanup:
    RRETURN(hr);
}   

//+---------------------------------------------------------------------------
//
//  CUnlinkCommand Class
//
//----------------------------------------------------------------------------

CUnlinkCommand::CUnlinkCommand(DWORD cmdId, CHTMLEditor *ped)
: CRemoveFormatBaseCommand(cmdId, ped)
{
    _tagsRemove.Set(TAGID_A);
}

HRESULT
CUnlinkCommand::RemoveElement(IHTMLElement *pElement, IMarkupPointer  *pStart
, IMarkupPointer  *pEnd)
{
    RRETURN( GetMarkupServices()->RemoveElement(pElement) );
}

HRESULT 
CUnlinkCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentList         spSegmentList;
    CSegmentListIter        iter;
    IMarkupPointer          *pStart;
    IMarkupPointer          *pEnd;
    
#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
             
    IFC( GetSegmentList(&spSegmentList) );

    IFC( iter.Init(GetEditor(), spSegmentList) );
    pCmd->cmdf = MSOCMDSTATE_DISABLED;
    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );
        if (hr ==  S_FALSE)
            break; // end of list
   
        IFC(Apply(pStart, pEnd, TRUE)); // query mode
        if (hr == S_OK)
        {
            pCmd->cmdf = MSOCMDSTATE_UP; // found link
            goto Cleanup;
        }
    }
    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

BOOL 
CUnlinkCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount ) );

    bResult = (iSegmentCount == 1);

Cleanup:
    return bResult;
}

BOOL
CAnchorCommand::IsCmdAbove(   IMarkupServices *pMarkupServices ,
                                IMarkupPointer* pStart,
                                IMarkupPointer* pEnd,
                                IHTMLElement**  ppFirstMatchElement,
                                elemInfluence * pInfluence ,
                                CTagBitField *  inSynonyms )
{
    BOOL match = FALSE;
    IHTMLElement *pCurrentElement = NULL ;
    IHTMLElement *pNextElement = NULL ;
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID currentTag = TAGID_NULL ;

    Assert ( pStart && pEnd );

    //
    // First look to the left of the Start pointer - to see if that "leads up to" the tag
    //
    hr = pStart->CurrentScope( & pCurrentElement );
    if (  hr ) goto CleanUp;
    Assert( pCurrentElement );
     
    while ( ! match && pCurrentElement )
    {
        hr = pMarkupServices->GetElementTagId( pCurrentElement, &currentTag);
        if ( hr ) goto CleanUp;

        match = inSynonyms->Test( (USHORT) currentTag );
        if ( match ) break;

        GetEditor()->GetParentElement( pCurrentElement, & pNextElement );
        ReplaceInterface( &pCurrentElement, pNextElement );
        ClearInterface( & pNextElement );
    }

    if (match )
    {
        if( ppFirstMatchElement )
            *ppFirstMatchElement = pCurrentElement;
        if ( pInfluence )
            *pInfluence = GetElementInfluenceOverPointers( pMarkupServices, pStart, pEnd, pCurrentElement );
    }

CleanUp:

    if ( ( ! ppFirstMatchElement )  || ( ! match ) )
        ReleaseInterface( pCurrentElement );

    return match;
}


BOOL 
CAnchorCommand::IsValidOnControl()
{
    HRESULT                 hr;
    BOOL                    bResult = FALSE;
    SP_ISegmentList         spSegmentList;
    INT                     iSegmentCount;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    
    IFC( GetSegmentList(&spSegmentList) );
#if DBG==1
    SELECTION_TYPE  eSelectionType;
    IFC( spSegmentList->GetType(&eSelectionType) );
    Assert(eSelectionType == SELECTION_TYPE_Control);
#endif

    IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );    

    bResult = (iSegmentCount == 1);

    if (bResult && _cmdId == IDM_HYPERLINK)
    {
        SP_IHTMLElement spElement;
        ELEMENT_TAG_ID  tagId;
        
        bResult = FALSE; // just in case we fail below

        // Create an iterator for our segment list
        IFC( spSegmentList->CreateIterator( &spIter ) );

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current( &spSegment ) );
            
            // Check that the element in the control range is an image
            IFC( GetSegmentElement(spSegment, &spElement) );
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

            bResult = (tagId == TAGID_IMG);
            if ( ! bResult )
            {
                goto Cleanup;
            }

            ClearInterface( & spElement );
            IFC( spIter->Advance() );
        }
    }

Cleanup:
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\blockcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef _X_CAPTION_H_
#define _X_CAPTION_H_
#include "caption.h"
#endif

#ifndef _X_DIV_H_
#define _X_DIV_H_
#include "div.h"
#endif

#ifndef _X_HEADER_H_
#define _X_HEADER_H_FC
#include "header.h"
#endif

#ifndef _X_HR_H_
#define _X_HR_H_
#include "hr.h"
#endif

#ifndef _X_IMG_H_
#define _X_IMG_H_
#include "img.h"
#endif

#ifndef _X_OBJECT_H_
#define _X_OBJECT_H_
#include "object.h"
#endif

#ifndef _X_PARA_H_
#define _X_PARA_H_
#include "para.h"
#endif

#ifndef _X_TABLE_H_
#define _X_TABLE_H_
#include "table.h"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

using namespace EdUtil;

MtDefine(CIndentCommand, EditCommand, "CIndentCommand");
MtDefine(COutdentCommand, EditCommand, "COutdentCommand");
MtDefine(CAlignCommand, EditCommand, "CAlignCommand");
MtDefine(CGetBlockFmtCommand, EditCommand, "CGetBlockFmtCommand");
MtDefine(CBlockFmtCommand, EditCommand, "CBlockFmtCommand");
MtDefine(CListCommand, EditCommand, "CListCommand");
MtDefine(CBlockFmtListCommand, EditCommand, "CBlockFmtListCommand");
MtDefine(CBlockDirCommand, EditCommand, "CBlockDirCommand");
MtDefine(CBlockCommand, EditCommand, "CBlockCommand");

#define MAX_BLOCKFMT_DISPLAYNAME_LENGTH 256

// ***** start CBlockDirCommand *****

//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::AdjustElementMargin
//
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::AdjustElementMargin(IHTMLElement* pCurElement)
{
    HRESULT         hr = S_OK;
    SP_IHTMLStyle   spStyle;
    ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
    THR(GetMarkupServices()->GetElementTagId(pCurElement, &tagId));

    switch(tagId)
    {
    case TAGID_BLOCKQUOTE:
        {
            // (paulnel) Here we need to make sure the margin of 0 is set to the trailing
            //           edge of the line
            if(_cmdId == IDM_BLOCKDIRLTR)
            {
                IFC( pCurElement->get_style(&spStyle) );
                
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
                }
                
                IFC( spStyle->removeAttribute(_T("marginLeft"), 0, NULL) );
            }
            else if (_cmdId == IDM_BLOCKDIRRTL)
            {
                IFC( pCurElement->get_style(&spStyle) );

                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
                }
                
                IFC( spStyle->removeAttribute(_T("marginRight"), 0, NULL) );
            }

        }
                hr = S_FALSE; // need to recurse in an change margins of all other elements
        break;
    }


Cleanup:

    RRETURN1(hr, S_FALSE);    
}

//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::GetElementAlignment
//
//  Synopsis: Given an element, get the direction string
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::GetElementAlignment(
    IHTMLElement *pElement, 
    BSTR *pszDir)
{
    HRESULT                 hr = S_OK;
    SP_IHTMLComputedStyle   spComputedStyle;
    VARIANT_BOOL            fRtl;

    IFC( GetEditor()->GetComputedStyle(pElement, &spComputedStyle) );
    IFC( spComputedStyle->get_blockDirection(&fRtl) );

    *pszDir = fRtl ? SysAllocString(L"rtl") : SysAllocString(L"ltr");

Cleanup:
    RRETURN(hr);
}
    
//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::SetElementAlignment
//
//----------------------------------------------------------------------------

HRESULT 
CBlockDirCommand::SetElementAlignment(IHTMLElement *pElement, BSTR szAlign, BOOL)
{
    HRESULT         hr;
    IHTMLElement*   pParent = NULL;
    IHTMLElement2*  pElem2 = NULL;
    BSTR            szDir = NULL;
    ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
    // We will only add the dir tag if the element's parent is not in the
    // same direction. This gives us cleaner code.
    hr = THR(GetEditor()->GetParentElement( pElement, &pParent) );
    if (FAILED(hr))
        goto Cleanup;        

    hr = THR(FindAlignment(pParent, &szDir));
    if (FAILED(hr))
        goto Cleanup;        
    
    THR(GetMarkupServices()->GetElementTagId(pParent, &tagId));

    switch(tagId)
    {
        // If we have a list container parent we want to put the direction on 
        // that container
    case TAGID_OL:
    case TAGID_UL:
        hr = pParent->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pElem2);
        break;
 
    default:
        hr = pElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pElem2);
        break;
    }

    if(!pElem2) 
        goto Cleanup;
    
    hr = pElem2->put_dir(_szAlign);

    if (FAILED(hr))
        goto Cleanup;

        hr = THR(AdjustElementMargin(pElement));

Cleanup:
    if (pParent) pParent->Release();
    if (pElem2) pElem2->Release();
    SysFreeString(szDir);

    return hr;
}
        
//+---------------------------------------------------------------------------
//
//  CBlockDirCommand::FindAlignment
//
//  Synopsis: Walk up the tree until we find the direction
//
//----------------------------------------------------------------------------
HRESULT CBlockDirCommand::FindAlignment( 
    IHTMLElement     *pElement, 
    BSTR             *pszDir)
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pOldElement = NULL;
    IHTMLElement        *pCurrent = NULL;

    *pszDir = NULL;

    ReplaceInterface(&pCurrent, pElement);
    do
    {
        hr = THR(GetElementAlignment(pCurrent, pszDir));
        if (SUCCEEDED(hr))
            break; // done
    
        ReplaceInterface(&pOldElement, pCurrent);
        ClearInterface(&pCurrent);
        hr = THR(GetEditor()->GetParentElement(pOldElement, &pCurrent) );
        if (FAILED(hr))
            goto Cleanup;        
    }
    while (pCurrent);

Cleanup:    
    ReleaseInterface(pCurrent);
    ReleaseInterface(pOldElement);
    RRETURN(hr);        
}


HRESULT 
CBlockDirCommand::ApplySiteAlignCommand(IHTMLElement *pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd;    

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( spStart->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( spEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFR( ApplyAlignCommand(spStart, spEnd) );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  CGetBlockFmtCommand Class
//
//----------------------------------------------------------------------------

CRITICAL_SECTION CGetBlockFmtCommand::_csLoadTable;
BOOL             CGetBlockFmtCommand::_fLoaded = FALSE;
BOOL             CGetBlockFmtCommand::_fCSInited = FALSE;

// TODO: use a hash table here [ashrafm]
    
CGetBlockFmtCommand::BlockFmtRec 
       CGetBlockFmtCommand::_blockFmts[] = 
{
    // **** NOTE: TAGID_NULL MUST BE FIRST HERE!!! ****
    { TAGID_NULL,    IDS_BLOCKFMT_NORMAL }, // depends on the current default tag 
    { TAGID_PRE,     IDS_BLOCKFMT_PRE },
    { TAGID_ADDRESS, IDS_BLOCKFMT_ADDRESS },
    { TAGID_H1,      IDS_BLOCKFMT_H1 },
    { TAGID_H2,      IDS_BLOCKFMT_H2 },
    { TAGID_H3,      IDS_BLOCKFMT_H3 },
    { TAGID_H4,      IDS_BLOCKFMT_H4 },
    { TAGID_H5,      IDS_BLOCKFMT_H5 },
    { TAGID_H6,      IDS_BLOCKFMT_H6 },
    { TAGID_OL,      IDS_BLOCKFMT_OL },
    { TAGID_UL,      IDS_BLOCKFMT_UL },
    { TAGID_DIR,     IDS_BLOCKFMT_DIR },
    { TAGID_MENU,    IDS_BLOCKFMT_MENU },
    { TAGID_DT,      IDS_BLOCKFMT_DT },
    { TAGID_DD,      IDS_BLOCKFMT_DD },
    { TAGID_P,       IDS_BLOCKFMT_P }
};

CGetBlockFmtCommand::BlockFmtRec 
       CGetBlockFmtCommand::_tagBlockFmts[] = 
{
    { TAGID_PRE,     IDS_BLOCKFMT_PRE_TAG },
    { TAGID_ADDRESS, IDS_BLOCKFMT_ADDRESS_TAG },
    { TAGID_H1,      IDS_BLOCKFMT_H1_TAG },
    { TAGID_H2,      IDS_BLOCKFMT_H2_TAG },
    { TAGID_H3,      IDS_BLOCKFMT_H3_TAG },
    { TAGID_H4,      IDS_BLOCKFMT_H4_TAG },
    { TAGID_H5,      IDS_BLOCKFMT_H5_TAG },
    { TAGID_H6,      IDS_BLOCKFMT_H6_TAG },
    { TAGID_OL,      IDS_BLOCKFMT_OL_TAG },
    { TAGID_UL,      IDS_BLOCKFMT_UL_TAG },
    { TAGID_DIR,     IDS_BLOCKFMT_DIR_TAG },
    { TAGID_MENU,    IDS_BLOCKFMT_MENU_TAG },
    { TAGID_DT,      IDS_BLOCKFMT_DT_TAG },
    { TAGID_DD,      IDS_BLOCKFMT_DD_TAG },
    { TAGID_P,       IDS_BLOCKFMT_P_TAG },
    { TAGID_DIV,     IDS_BLOCKFMT_DIV_TAG }
};

HRESULT 
CGetBlockFmtCommand::PrivateQueryStatus(   OLECMD * pCmd,
                                    OLECMDTEXT * pcmdtext )
{
#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
    }
    else
#endif
    pCmd->cmdf = MSOCMDSTATE_UP; 
    return S_OK;
}

    
HRESULT 
CGetBlockFmtCommand::GetDefaultBlockTag( IMarkupServices *pMarkupServices, ELEMENT_TAG_ID *ptagId)
{
    HRESULT             hr;
    IOleCommandTarget   *pCommandTarget = NULL;
    VARIANT             var;

    *ptagId = TAGID_P; // default for most cases

    hr = THR(pMarkupServices->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCommandTarget));
    if (FAILED(hr))
        goto Cleanup;

    VariantInit(&var);        
    hr = THR(pCommandTarget->Exec((GUID *)&CGID_MSHTML,
                                  IDM_DEFAULTBLOCK,
                                  MSOCMDEXECOPT_DONTPROMPTUSER,
                                  NULL,
                                  &var));
    if (FAILED(hr))
        goto Cleanup;
                                  
    if (V_VT(&var) == VT_BSTR
        && (V_BSTR(&var) != NULL)
        && (StrCmpW(_T("DIV"), V_BSTR(&var)) == 0))
    {
        *ptagId = TAGID_DIV;
    }
    VariantClear(&var);
    
Cleanup:
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::LookupTagId(   IMarkupServices     *pMarkupServices,
                                    BSTR                bstrName,
                                    ELEMENT_TAG_ID      *ptagId )
{
    HRESULT             hr;
    INT                 i;

    hr = E_INVALIDARG; // if not found, this is the return value

    if (bstrName == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    // Check standard case
    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (StrCmpIW(_blockFmts[i]._bstrName, bstrName) == 0)
        {
            // found element
            *ptagId = _blockFmts[i]._tagId;
            hr = S_OK;
            goto Cleanup;            
        }
    }

    // Check <tagId> case
    for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
    {
        if (StrCmpIW(_tagBlockFmts[i]._bstrName, bstrName) == 0)
        {
            *ptagId = _tagBlockFmts[i]._tagId;
            hr = S_OK;
            goto Cleanup;            
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::PrivateExec(
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT        hr = S_OK;
    SAFEARRAYBOUND sabound;
    SAFEARRAY *    psa;
    LONG           i;

    Assert(pvarargIn == NULL || V_VT(pvarargIn) == VT_EMPTY || V_VT(pvarargIn) == VT_NULL);
      
    if (pvarargOut)
    {
        sabound.cElements = ARRAY_SIZE(_blockFmts);
        sabound.lLbound = 0;

        psa = SafeArrayCreate(VT_BSTR, 1, &sabound);

        for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
            IFC(SafeArrayPutElement(psa, &i, _blockFmts[i]._bstrName));

        V_ARRAY(pvarargOut) = psa;
        V_VT(pvarargOut) = VT_ARRAY;
    }    

Cleanup:
    RRETURN(hr);
}

HRESULT 
CGetBlockFmtCommand::Init()
{
    HRESULT hr;
    int     i;

    hr = HrInitializeCriticalSection(&_csLoadTable);
    if (hr)
        goto Cleanup;

    _fCSInited = TRUE;

    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
        _blockFmts[i]._bstrName = NULL;

Cleanup:
    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadDisplayNames(HINSTANCE hinst)
{
    HRESULT hr;
    
    EnterCriticalSection(&_csLoadTable);

    Assert(_fLoaded);
    hr = THR(LoadDisplayNamesHelper(hinst));
    
    LeaveCriticalSection(&_csLoadTable);

    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadDisplayNamesHelper(HINSTANCE hinst)
{
    HRESULT hr = S_OK;
    INT     i, j;
    TCHAR   szBuffer[MAX_BLOCKFMT_DISPLAYNAME_LENGTH];    
    
    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (!LoadString(hinst, _blockFmts[i]._idsName, szBuffer, ARRAY_SIZE(szBuffer)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        
        if (_blockFmts[i]._bstrName)
            SysFreeString(_blockFmts[i]._bstrName);

        _blockFmts[i]._bstrName = SysAllocString(szBuffer);
        if (!_blockFmts[i]._bstrName)
        {
            hr = E_OUTOFMEMORY;
            for (j = 0; j < i; j++)
            {
                SysFreeString(_blockFmts[j]._bstrName); // free all this stuff we allocated
                _blockFmts[j]._bstrName = NULL;
            }
            goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CGetBlockFmtCommand::LoadStringTable(HINSTANCE hinst)
{
    HRESULT     hr = S_OK;
    INT         i, j;
    TCHAR       szBuffer[MAX_BLOCKFMT_DISPLAYNAME_LENGTH];    

    if (_fLoaded)
        return S_OK; // we're done

    EnterCriticalSection(&_csLoadTable);
    if (_fLoaded)
        goto Cleanup; // we're done
    
    //
    // Load English version of display names
    //

    IFC( LoadDisplayNamesHelper(hinst) );
    
    // 
    // Load blockfmt tag names
    //
    for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
    {
        if (!LoadString(g_hInstance, _tagBlockFmts[i]._idsName, szBuffer, ARRAY_SIZE(szBuffer)))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        _tagBlockFmts[i]._bstrName = SysAllocString(szBuffer);
        if (!_tagBlockFmts[i]._bstrName)
        {
            hr = E_OUTOFMEMORY;
            for (j = 0; j < i; j++)
                SysFreeString(_tagBlockFmts[j]._bstrName); // free all this stuff we allocated
            goto Cleanup;
        }
    }

    _fLoaded = TRUE;

Cleanup:
    LeaveCriticalSection(&_csLoadTable);
    AssertSz(hr == S_OK, "Can't load string table");

    RRETURN(hr);
}

VOID CGetBlockFmtCommand::Deinit()
{
    INT i;

    // doesn't need to be protected because called from process detach
    if (_fLoaded)
    {
        for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
            SysFreeString(_blockFmts[i]._bstrName); // free all this stuff we allocated                        

        for (i = 0; i < ARRAY_SIZE(_tagBlockFmts); i++)
            SysFreeString(_tagBlockFmts[i]._bstrName); // free all this stuff we allocated                        
    }

    if (_fCSInited)
    {
        DeleteCriticalSection(&_csLoadTable);
        _fCSInited = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  CGetBlockFmtCommand::LookupFormatName
//
//----------------------------------------------------------------------------
BSTR CGetBlockFmtCommand::LookupFormatName(IMarkupServices *pMarkupServices, ELEMENT_TAG_ID tagId)
{
    HRESULT         hr;
    INT             i;
    BSTR            bstrResult;
    ELEMENT_TAG_ID  tagIdDefault;

    if (tagId == TAGID_UNKNOWN)
        return NULL;

    bstrResult = _blockFmts[0]._bstrName;     // Unknown tags default to "Normal"

    if (tagId == TAGID_DIV)
        return bstrResult;
        
    if (tagId == TAGID_P)
    {        
        IFC( GetDefaultBlockTag(pMarkupServices, &tagIdDefault) );
        if (tagIdDefault == TAGID_P)
            return bstrResult;

        // Otherwise, fall through to lookup below
    }

    for (i = 0; i < ARRAY_SIZE(_blockFmts); i++)
    {
        if (_blockFmts[i]._tagId == tagId)
        {
            bstrResult = _blockFmts[i]._bstrName;
            break;
        }
    }

Cleanup:
    return bstrResult;
}

//
// CBlockPointer implementation
//

#define  BREAK_CONDITION_BLOCKPOINTER   (BREAK_CONDITION_Text           |  \
                                         BREAK_CONDITION_NoScopeSite    |  \
                                         BREAK_CONDITION_NoScopeBlock   |  \
                                         BREAK_CONDITION_Site           |  \
                                         BREAK_CONDITION_Block          |  \
                                         BREAK_CONDITION_Control)

CBlockPointer::CBlockPointer(CHTMLEditor *pEd)
{
    _pEd = pEd;
    _type = NT_Undefined;
    _pElement = NULL;
    _pLeft = NULL;
    _pRight = NULL;
}

CBlockPointer::~CBlockPointer()
{
    ClearPointers();
}


NodeType 
CBlockPointer::GetType()
{
    Assert(_type != NT_Undefined);
    
    return _type;
}

HRESULT 
CBlockPointer::GetElement(IHTMLElement **ppElement)
{
    if (!IsElementType())
    {
        *ppElement = NULL;
        return S_OK;
    }
    
    Assert(_pElement);

    *ppElement = _pElement;
    _pElement->AddRef();

    return S_OK;        
}
    
IMarkupServices2* 
CBlockPointer::GetMarkupServices()
{
    return _pEd->GetMarkupServices();
}

HRESULT 
CBlockPointer::MoveTo(IMarkupPointer *pPointer, Direction dir)
{
    HRESULT hr;

    // The direction is just a hint.  If we don't find a node in one direction,
    // we check the other direction.
    
    IFR( PrivateMoveTo(pPointer, dir, MOVE_ALLOWEMPTYTEXTNODE) );
    if (hr == S_FALSE)
    {
        IFR( PrivateMoveTo(pPointer, Reverse(dir), MOVE_ALLOWEMPTYTEXTNODE) );
    }

    return S_OK;
}

HRESULT 
CBlockPointer::PrivateMoveTo(IMarkupPointer *pPointer, Direction dir, DWORD dwMoveOptions)
{
    HRESULT         hr = S_FALSE;
    CEditPointer    epPosition(_pEd);
    CEditPointer    epStart(_pEd), epEnd(_pEd);
    DWORD           eSearchCondition = BREAK_CONDITION_BLOCKPOINTER;
    DWORD           eFoundCondition;
    SP_IHTMLElement spElement;
    BOOL            fIgnoreGlyphs = FALSE;

    Assert(dir != SAME);

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( epPosition->MoveToPointer(pPointer) );
    IFC( epPosition.Scan(dir, eSearchCondition, &eFoundCondition, &spElement) );

    if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_Text))
    {
        // Expand to maximal text region
        
        if (dir == LEFT)
        {
            IFC( epStart->MoveToPointer(epPosition) );
            IFC( epEnd->MoveToPointer(pPointer) );
        }
        else
        {
            IFC( epStart->MoveToPointer(pPointer) );
            IFC( epEnd->MoveToPointer(epPosition) );
        }

        // Expand left
        IFC( epStart.Scan(LEFT, eSearchCondition - BREAK_CONDITION_Text, &eFoundCondition) );
        IFC( epStart.Scan(RIGHT, eSearchCondition, NULL) );

        // Expand right
        IFC( epEnd.Scan(RIGHT, eSearchCondition - BREAK_CONDITION_Text, &eFoundCondition) );
        IFC( epEnd.Scan(LEFT, eSearchCondition, NULL) );

        // Create text node
        ClearPointers();
        IFC( CopyMarkupPointer(GetEditor(), epStart, &_pLeft) );
        IFC( _pLeft->SetGravity(POINTER_GRAVITY_Right) );
        
        IFC( CopyMarkupPointer(GetEditor(), epEnd, &_pRight) );
        IFC( _pRight->SetGravity(POINTER_GRAVITY_Left) );
        _type = NT_Text;

        hr = S_OK;
        goto Cleanup;
    }
    else if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitSite))
    {
        NodeType type = NT_Undefined;

        if (spElement != NULL)
            IFC( GetElementNodeType(spElement, &type) );

        if (dwMoveOptions & MOVE_ALLOWEMPTYTEXTNODE && type != NT_TextBreak)
        {
            // No node found - check for empty text node
            IFC( epPosition.MoveToPointer(pPointer) );
            IFC( epPosition.Scan(Reverse(dir), eSearchCondition, &eFoundCondition) );

            if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeBlock)
                || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitBlock)
                || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_ExitSite))
            {
                DWORD dwFound;
                
                // Create text node
                ClearPointers();
                IFC( CopyMarkupPointer(GetEditor(), pPointer, &_pLeft) );
                IFC( _pLeft->SetGravity(POINTER_GRAVITY_Right) );    
                
                IFC( CopyMarkupPointer(GetEditor(), pPointer, &_pRight) );
                IFC( _pRight->SetGravity(POINTER_GRAVITY_Left) );

                _type = NT_Text;
                
                // Position phrase elements
                CEditPointer epRight(_pEd, _pRight);
                CEditPointer epLeft(_pEd, _pLeft);

                IFC( epRight.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                IFC( epRight.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );

                IFC( epLeft.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                IFC( epLeft.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
                
                hr = S_OK;
                goto Cleanup;
            }
        }
        else if (type == NT_TextBreak)
        {
            ClearPointers();
            _pElement = spElement;
            _pElement->AddRef();
            _type = type;

            hr = S_OK;
            goto Cleanup;
        }

        hr = S_FALSE;
        goto Cleanup;
    }
    else if (epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_Control)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_NoScopeSite)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_EnterBlock)
             || epPosition.CheckFlag(eFoundCondition, BREAK_CONDITION_EnterSite))
    {
        Assert(spElement != NULL);
        ClearPointers();
        _pElement = spElement;
        _pElement->AddRef();
        IFC( GetElementNodeType(_pElement, &_type) );

        // If the current element is a colgroup, we want to skip over it.
        // (bug 91352)
        if (hr == S_FALSE && IsColgroup())
        {
            SP_IMarkupPointer   spTemp;

            IFC( GetEditor()->CreateMarkupPointer(&spTemp) );    
            if ( dir == LEFT)
            {
                IFC( spTemp->MoveAdjacentToElement(_pElement, ELEM_ADJ_BeforeBegin) );
            }
            else
            {
                IFC( spTemp->MoveAdjacentToElement(_pElement, ELEM_ADJ_AfterEnd) );
            }
            IFC( PrivateMoveTo(spTemp, dir, MOVE_ALLOWEMPTYTEXTNODE) );
        }
        goto Cleanup;
    }

    hr = S_FALSE;

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN1(hr, S_FALSE);
}

HRESULT 
CBlockPointer::MoveTo(IHTMLElement *pElement)
{
    HRESULT                         hr;
    SP_IHTMLElement                 spNewElement;
    SP_IHTMLElement                 spCurrentElement;
    NodeType                        nodeType;


    Assert(pElement);
    
    ClearPointers();
    
    spCurrentElement = pElement;
    do
    {
        IFR( GetElementNodeType(spCurrentElement, &nodeType));

        if (nodeType != NT_Undefined)
        {
            Assert(!IsColgroup(spCurrentElement));
            _pElement = spCurrentElement;
            _pElement->AddRef();
            _type = nodeType;
            break;
        }
                
        IFR( GetEditor()->GetParentElement( spCurrentElement, &spNewElement) );
        spCurrentElement = spNewElement;
    }
    while (spCurrentElement != NULL);

    AssertSz(_pElement, "Can't find block element");

    RRETURN(hr);            
}

HRESULT
CBlockPointer::MoveTo(CBlockPointer *pNode)
{
    HRESULT hr;
    
    Assert(_pEd == pNode->_pEd);
    Assert(pNode->GetType() != NT_Undefined);

    ClearPointers();
    
    if (pNode->IsElementType())
    {
        IFR( pNode->GetElement(&_pElement) );
    }
    else
    {
        Assert(pNode->_pLeft && pNode->_pRight);
        
        IFR( CopyMarkupPointer(GetEditor(), pNode->_pLeft, &_pLeft) );
        IFR( _pLeft->SetGravity(POINTER_GRAVITY_Right) );
        
        IFR( CopyMarkupPointer(GetEditor(), pNode->_pRight, &_pRight) );
        IFR( _pRight->SetGravity(POINTER_GRAVITY_Left) );
    }

    _type = pNode->GetType();    
    
    return S_OK;
}


HRESULT 
CBlockPointer::MoveToParent()
{
    HRESULT         hr;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;
    
    Assert(_type != NT_Undefined);

    if (IsElementType())
    {
        IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
        if (tagId == TAGID_BODY)
            return S_FALSE;
            
        IFR( GetEditor()->GetParentElement( _pElement, &spElement) )
        if (spElement == NULL)
            return S_FALSE;
    }
    else
    {
        IFR( _pLeft->CurrentScope( &spElement) );

        if( !spElement )
            return S_FALSE;
        
#if DBG==1
        //
        // Check that the parent of the left and right ends of the node are the same
        //
        SP_IHTMLElement     spDebugElement;
        CBlockPointer       bpDebugLeft(_pEd);
        CBlockPointer       bpDebugRight(_pEd);
    
        Assert( _pRight->CurrentScope(&spDebugElement) == S_OK );
        Assert( bpDebugRight.MoveTo(spDebugElement) == S_OK );
        Assert( bpDebugLeft.MoveTo(spElement) == S_OK );
        Assert( bpDebugLeft.IsEqual(&bpDebugRight) == S_OK );
#endif
    }
    IFR( MoveTo(spElement) );
            
    return S_OK;
}

HRESULT 
CBlockPointer::MoveToScope(CBlockPointer *pScope)
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);

    // 
    // Move up the tree until we find a node that is in the specified scope
    //

    IFR( bpParent.MoveTo(this) );
    for (;;)
    {        
        IFR( bpParent.MoveToParent() );
        
        Assert(hr != S_FALSE);        
        if (hr == S_FALSE)
            return S_FALSE;

        IFR( bpParent.IsEqual(pScope) );
        if (hr == S_OK)
            break;

        IFR( MoveToParent() );
    } 
    
    return S_OK;
}

HRESULT 
CBlockPointer::MoveToFirstChild()
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft;
    
    Assert(_type != NT_Undefined);
    
    switch (_type)
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return S_FALSE; // done        
    }

    Assert(IsElementType());

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );    
    IFR( spLeft->MoveAdjacentToElement(_pElement, ELEM_ADJ_AfterBegin) );
    IFR( PrivateMoveTo(spLeft, RIGHT, MOVE_ALLOWEMPTYTEXTNODE) );

    return S_OK;
}

HRESULT 
CBlockPointer::MoveToLastChild()
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft;
    
    Assert(_type != NT_Undefined);
    
    switch (_type)
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return S_FALSE; // done        
    }

    Assert(IsElementType());

    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );    
    IFR( spLeft->MoveAdjacentToElement(_pElement, ELEM_ADJ_BeforeEnd) );
    IFR( PrivateMoveTo(spLeft, LEFT, MOVE_ALLOWEMPTYTEXTNODE) );

    return S_OK;
}

HRESULT 
CBlockPointer::MoveToSibling(Direction dir)
{
    HRESULT         hr;
    CEditPointer    epPointer(_pEd);
    BOOL            fIgnoreGlyphs = FALSE;

    Assert(dir != SAME);

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( MovePointerTo(epPointer, (dir==LEFT)?ELEM_ADJ_BeforeBegin:ELEM_ADJ_AfterEnd) );
    IFC( PrivateMoveTo(epPointer, dir, 0) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    return hr;
}

BOOL 
CBlockPointer::IsLeafNode()
{
    HRESULT hr;

    switch (GetType())
    {
        case NT_Text:
        case NT_Control:
        case NT_TextBreak:
            return TRUE;

        case NT_BlockLayout:
        {
            ELEMENT_TAG_ID tagId;

            IFC( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
            return (tagId == TAGID_HR);
        }
    }

Cleanup:
    return FALSE;
}

HRESULT 
CBlockPointer::MoveToNextLeafNode()
{
    HRESULT hr;
    long i;
    
    //
    // It is common to do a MoveToLastNodeInBlock followed by
    // a MoveToNextLeafNode.  So, we can get NT_FlowLayout as well
    // as a leaf node.
    //
    Assert(IsLeafNode() || GetType() == NT_FlowLayout);

    for (i=0;;i++)
    {
        IFR( MoveToSibling(RIGHT) );
        if (hr == S_OK)
        {
            while (!IsLeafNode())
            {
                IFR( MoveToFirstChild() );
                Assert(hr != S_FALSE);
            }
            break; // done;
        }
        else
        {
            IFR( MoveToParent() );
            if (hr == S_FALSE)
                return S_FALSE; // can't find next leaf node                   
        }
    }

    return S_OK;
}

HRESULT
CBlockPointer::IsPointerInBlock(IMarkupPointer *pPointer)
{
    HRESULT             hr;
    SP_IMarkupPointer   spTest;
    BOOL                bOutside;

    IFR( GetEditor()->CreateMarkupPointer(&spTest) );
    
    IFR( MovePointerTo(spTest, ELEM_ADJ_BeforeEnd) );
    IFR( pPointer->IsRightOf(spTest, &bOutside) );
    if (bOutside)
        return S_FALSE; // not in block
        
    IFR( MovePointerTo(spTest, ELEM_ADJ_AfterBegin) );
    IFR( pPointer->IsLeftOf(spTest, &bOutside) );
    if (bOutside)
        return S_FALSE; // not in block

    return S_OK; // in block    
}

HRESULT 
CBlockPointer::MoveToNextLogicalBlock(IMarkupPointer *pControl, BOOL fFlatten)
{
    HRESULT             hr;
    SP_IMarkupPointer   spTest;
    BOOL                bLeftOf;
    CBlockPointer       bpParent(_pEd);
    
    IFR( GetEditor()->CreateMarkupPointer(&spTest) );
    
    for (;;)
    {
        IFR( MoveToSibling(RIGHT) );
        if (hr == S_FALSE && fFlatten)
        {
            // We might be able to flatten the parent and collapse the scope.
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );
            if (hr == S_OK && bpParent.GetType() == NT_Block)
            {
                IFR( bpParent.FlattenNode() );
                IFR( MoveToSibling(RIGHT) ); // try again                
            }
            else
            {
                hr = S_FALSE;
            }
        }
        
        if (hr == S_OK)
        {
            do 
            {
                if (fFlatten && GetType() == NT_Block)
                    IFR( FlattenNode() );
                        
                if (GetType() != NT_Container)
                {
                    //
                    // If block is entirely to the left of pControl, we return
                    // this block as the next logical block
                    //
                    IFR( MovePointerTo(spTest, ELEM_ADJ_AfterEnd) );
                    IFR( spTest->IsLeftOfOrEqualTo(pControl, &bLeftOf) );
                    if (bLeftOf)            
                        return S_OK; // done
                }

                //
                // Otherwise, check the first child
                //
                // NOTE: failure of MoveToFirstChild means no children in
                // which case we should return S_FALSE.
            
                hr = THR( MoveToFirstChild() );
            } while (hr == S_OK);

            return S_FALSE; // can't find next logical block
        }

        IFR( MoveToParent() );
        if (hr == S_FALSE)
            return S_FALSE; // can't find next logical block                                
    }
}

HRESULT 
CBlockPointer::MoveToLastNodeInBlock()
{
    HRESULT         hr;
    CBlockPointer   bpTest(_pEd);
    BOOL            fBlockBoundary;

    IFR( bpTest.MoveTo(this) );
    for (;;)
    {
        IFR(bpTest.MoveToSibling(RIGHT));
        if (hr == S_FALSE)
            break;
            
        fBlockBoundary = TRUE;

        switch (bpTest.GetType())
        {
            case NT_FlowLayout:
            case NT_Text:
            case NT_Control:
            case NT_TextBreak:
                fBlockBoundary = FALSE;
        }
        
        if (fBlockBoundary)
            break;

        IFR( MoveTo(&bpTest) );                
    }

    return S_OK;    
}

HRESULT 
CBlockPointer::MoveToFirstNodeInBlock()
{
    HRESULT         hr;
    CBlockPointer   bpTest(_pEd);
    BOOL            fBlockBoundary;

    IFR( bpTest.MoveTo(this) );

    for (;;)
    {
        IFR(bpTest.MoveToSibling(LEFT));
        if (hr == S_FALSE)
            break;

        fBlockBoundary = TRUE;

        switch (bpTest.GetType())
        {
            case NT_FlowLayout:
            case NT_Text:
            case NT_Control:
            case NT_TextBreak:
                fBlockBoundary = FALSE;
        }
        
        if (fBlockBoundary)
            break;

        IFR( MoveTo(&bpTest) );                
    }

    return S_OK;    
}

HRESULT 
CBlockPointer::MoveToBlockScope(CBlockPointer *pEnd)
{
    HRESULT             hr;
    CEditPointer        epInner(_pEd), epOuter(_pEd);
    BOOL                fEqual;
    CBlockPointer       bpParent(_pEd);
    DWORD               dwIgnore = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_BLOCKPOINTER;

    if (!IsLeafNode() && GetType() != NT_FlowLayout)
        return S_OK; // done

    //
    // First check if there is a block directly above
    //

    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );

    if (hr == S_FALSE || bpParent.GetType() != NT_Block && bpParent.GetType() != NT_ListItem)
        return S_FALSE;
    
    IFR( MovePointerTo(epInner, ELEM_ADJ_BeforeBegin) );
    IFR( bpParent.MovePointerTo(epOuter, ELEM_ADJ_AfterBegin) );

    IFR( epInner.IsEqualTo(epOuter, dwIgnore, &fEqual) );
    if (fEqual)
    {
        IFR( pEnd->MovePointerTo(epInner, ELEM_ADJ_AfterEnd) );
        IFR( bpParent.MovePointerTo(epOuter, ELEM_ADJ_BeforeEnd) );

        IFR( epInner.IsEqualTo(epOuter, dwIgnore, &fEqual) );
        if (fEqual)
        {
            IFR( MoveTo(&bpParent) );
            return S_OK; // found block
        }        
    }

    //
    // No block above, so flatten parent and go up if we can
    //

    if (bpParent.GetType() == NT_Block)
    {
        SP_IHTMLElement spElement;
        ELEMENT_TAG_ID  tagId;

        IFR( bpParent.GetElement(&spElement) );
        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (tagId == TAGID_BLOCKQUOTE)
            return S_FALSE; // can't get scope through flatten

        // TODO: flatten node needs to fail instead of return S_FALSE for blockquote's [ashrafm]
        IFR( bpParent.FlattenNode() );
        IFR( MoveToParent() );
        return S_OK;
    }

    return S_FALSE;
}

HRESULT
CBlockPointer::EnsureNoChildOverlap(CBlockPointer *pbpChild)
{
    HRESULT             hr;
    SP_IMarkupPointer   spChildRight;
    SP_IMarkupPointer   spNodeRight;
    CBlockPointer       &bpChild = *pbpChild; // just for convenience
    BOOL                fOverlap;
    BOOL                fEqual;

    if (GetType() != NT_Block || bpChild.GetType() != NT_Block)
        return S_FALSE;
    
    IFR( GetEditor()->CreateMarkupPointer(&spChildRight) );
    IFR( GetEditor()->CreateMarkupPointer(&spNodeRight) );

    IFR( bpChild.MovePointerTo(spChildRight, ELEM_ADJ_AfterEnd) );    
    IFR( MovePointerTo(spNodeRight, ELEM_ADJ_BeforeEnd) );

    IFR( spNodeRight->IsLeftOf(spChildRight, &fOverlap) );
    if (!fOverlap)
        return S_OK; // nothing to do

    if (fOverlap)
    {
        SP_IHTMLElement     spNewElement;
        SP_IHTMLElement     spElement;
        SP_IMarkupPointer   spLeft;

        //
        // Split the child tag
        //

        // Insert left side
        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( bpChild.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
        IFR( bpChild.GetElement(&spElement) )
        IFR( GetMarkupServices()->RemoveElement(spElement) );
        IFR( GetMarkupServices()->InsertElement(spElement, spLeft, spNodeRight) );

        // Insert right side
        IFR( MovePointerTo(spLeft, ELEM_ADJ_AfterEnd) );
        IFR( spLeft->IsEqualTo(spChildRight, &fEqual) );
        if (!fEqual)
        {
            IFR( GetMarkupServices()->CloneElement(spElement, &spNewElement) );
            IFR( GetMarkupServices()->InsertElement(spNewElement, spLeft, spChildRight) );
        }
        
    }       
    
    return S_OK;
}

HRESULT 
CBlockPointer::MergeAttributes(IHTMLElement *pElementSource, IHTMLElement *pElementDest)
{
    HRESULT             hr;    
    SP_IHTMLElement     spElementClone;

    //
    // HACKHACK: we need to do this dance because CopyAttributes overwrites
    // properties in the destination that are in the source.  We want the destination
    // properties to be preserved so we merge in the other order 
    //
    // TODO: fix this hack when the OM supports this type of merge [ashrafm]
    //
    IFR( GetMarkupServices()->CloneElement(pElementSource, &spElementClone) );
    IFR( CopyAttributes(pElementDest, spElementClone, FALSE) );
    IFR( CopyAttributes(spElementClone, pElementDest, FALSE) );

    return S_OK;
}

HRESULT
CBlockPointer::PushToChild(CBlockPointer *pbpChild)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagIdParent, tagIdChild;
    CBlockPointer   &bpChild = *pbpChild; // just for convenience
    SP_IHTMLElement spElement;
    SP_IHTMLElement spChildElement;
    BOOL            fNeedToInsertAbove = FALSE;
        
    Assert(GetType() == NT_Block && bpChild.GetType() == NT_Block);

    // Get tagId's
    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdParent) );
    IFR( bpChild.GetElement(&spChildElement) );
    IFR( GetMarkupServices()->GetElementTagId(spChildElement, &tagIdChild) );

    if (tagIdParent == tagIdChild)
    {
        //
        // We are done - just copy attributes 
        //
        IFR( MergeAttributes(_pElement, spChildElement) );
        return S_OK;
    }

    switch (tagIdParent)
    {
        case TAGID_P:
        case TAGID_DIV:
            switch (tagIdChild)
            {
                case TAGID_ADDRESS:
                case TAGID_PRE:
                    fNeedToInsertAbove = HasAttributes();
                    break;

                case TAGID_DIV:
                    // If either the child or parent is a P, we make sure the flattened node is a 
                    // P so we can keep the same spacing
                    if (tagIdParent == TAGID_P)
                        IFR( bpChild.Morph(&bpChild, TAGID_P) );

                    // fall through

                default:
                    // Copy attributes to child
                    IFR( MergeAttributes(_pElement, spChildElement) );
            }
            break;

        case TAGID_BLOCKQUOTE:
            AssertSz(0, "Shouldn't flatten blockquotes");
            break;
            
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_ADDRESS:
        case TAGID_PRE:
            switch (tagIdChild)
            {
                case TAGID_P:
                case TAGID_DIV:
                    IFR( bpChild.Morph(&bpChild, tagIdParent) );
                    break;

                case TAGID_ADDRESS:
                case TAGID_PRE:
                case TAGID_H1:
                case TAGID_H2:
                case TAGID_H3:
                case TAGID_H4:
                case TAGID_H5:
                case TAGID_H6:
                    IFR( MergeAttributes(_pElement, spChildElement) );
                    break; 

                default:
                    fNeedToInsertAbove = TRUE;
                
            }
            break;
            
        case TAGID_CENTER:
        {
            BSTR szAlign = NULL;
            
            switch (tagIdChild)
            {
                case TAGID_P:
                case TAGID_DIV:
                    if (tagIdChild == TAGID_DIV)
                        IFR( CAlignment<IHTMLDivElement>().Get(IID_IHTMLDivElement, spChildElement, &szAlign) )
                    else
                        IFR( CAlignment<IHTMLParaElement>().Get(IID_IHTMLParaElement, spChildElement, &szAlign) );        

                    if (szAlign == NULL || StrCmpIW(szAlign, _T("center")) == 0)
                        hr = THR( bpChild.Morph(&bpChild, tagIdParent) );
                    else
                        hr = THR( MergeAttributes(_pElement, spChildElement) );

                    SysFreeString(szAlign);
                    IFR(hr);
                        
                    break;
                    
                default:
                    fNeedToInsertAbove = TRUE;
            }        
            break;
        }
            
        default:
            AssertSz(0, "unexpected block type");
            fNeedToInsertAbove = TRUE;
    }

    if (fNeedToInsertAbove)
    {
        IFR( GetMarkupServices()->CreateElement(tagIdParent, NULL, &spElement) );
        IFR( bpChild.InsertAbove(spElement, &bpChild) );
        IFR( MergeAttributes(_pElement, spElement) );
        IFR( bpChild.MoveToParent() );
    }
    
    return S_OK;
}

HRESULT 
CBlockPointer::FlattenNode()
{
    HRESULT             hr;
    CBlockPointer       bpChild(_pEd);
    CBlockPointer       bpTest(_pEd);
    CBlockPointer       bpLastChild(_pEd);
    CBlockPointer       bpParent(_pEd);
    ELEMENT_TAG_ID      tagIdNode;
    SP_IHTMLElement     spElement;
    
    Assert(GetType() == NT_Block && _pElement);

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdNode) );
    if (tagIdNode == TAGID_BLOCKQUOTE)
        return S_FALSE; // don't flatten a blockquote    

    // Make sure parent doesn't overlap current node
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );
    IFR( bpParent.EnsureNoChildOverlap(this) );

    // Move to first child
    IFR( bpChild.MoveTo(this) );
    IFR( bpChild.MoveToFirstChild() );

    // For make sure we don't have a single text node (for perf reasons)
    if (bpChild.GetType() == NT_Text)
    {
        IFR( bpTest.MoveTo(&bpChild) );
        IFR( bpTest.MoveToSibling(RIGHT) );
        if (hr == S_FALSE)
            return S_FALSE; // nothing to do
    }
    
    if (hr == S_FALSE)
    {
        // no children, so we're done
        return S_FALSE;
    }

    do
    {
        switch (bpChild.GetType())
        {
            case NT_ListContainer:
            case NT_ListItem:
            case NT_Container:
                if (tagIdNode == TAGID_CENTER || HasAttributes())
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdNode, NULL, &spElement) );
                    IFR( CopyAttributes(_pElement, spElement, FALSE) );
                    IFR( bpChild.InsertAbove(spElement, &bpChild, TAGID_NULL, NULL, FALSE) );
                }
                break;

            case NT_BlockLayout:
            case NT_Text:
            case NT_Control:                
            case NT_FlowLayout:
            case NT_TextBreak:
                // Insert element above all text nodes                
                IFR( GetMarkupServices()->CreateElement(tagIdNode, NULL, &spElement) );
                IFR( CopyAttributes(_pElement, spElement, FALSE) );

                // Expand to all leaf nodes
                IFR( bpLastChild.MoveTo(&bpChild) );
                if (bpChild.GetType() != NT_BlockLayout)
                {
                    IFR( bpLastChild.MoveToLastNodeInBlock() );
                }
                IFR( bpChild.InsertAbove(spElement, &bpLastChild, TAGID_NULL, NULL, FALSE) );
                IFR( bpChild.MoveTo(spElement) );

                // Current node could have changed above
                IFR( MoveTo(&bpChild) );
                IFR( MoveToParent() );
                break;
            
            case NT_Block:
                IFR( EnsureNoChildOverlap(&bpChild) );
                IFR( PushToChild(&bpChild) );
                break;

            default:
                AssertSz(0, "Unexpected block type");
        }
        IFR( bpChild.MoveToSibling(RIGHT) );
    } 
    while (hr == S_OK);

    spElement = _pElement;
    IFR( MoveToFirstChild() );    
    IFR( GetMarkupServices()->RemoveElement(spElement) );
    
    return S_OK;    
}

HRESULT 
CBlockPointer::FloatUp(CBlockPointer *pEnd, BOOL fCanChangeType)
{
    HRESULT             hr;
    CBlockPointer       bpParent(_pEd);
    CBlockPointer       bpPointer(_pEd);
    CEditPointer        epLeft(_pEd);
    SP_IMarkupPointer   spRight;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagId;
    BOOL                bEqual;

#ifndef _PREFIX_
    Assert(IsSameScope(pEnd));
#endif
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    // Move block pointer to parent
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );

    Assert(bpParent.GetType() != NT_BlockLayout
           && bpParent.GetType() != NT_FlowLayout
           && bpParent.GetType() != NT_Container
           && !bpParent.IsLeafNode());
    Assert(IsElementType());

    // Split the element influence

    IFR( GetMarkupServices()->GetElementTagId(bpParent._pElement, &tagId) );

    // Add left side
    
    IFR( bpParent.MovePointerTo(epLeft, ELEM_ADJ_AfterBegin) );
    IFR( MovePointerTo(spRight, ELEM_ADJ_BeforeBegin) );     
    IFR( epLeft.IsEqualTo(spRight, BREAK_CONDITION_Phrase, &bEqual) );
    if (!bEqual)
    {
        IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
        IFR( CopyAttributes(bpParent._pElement, spElement, TRUE) );
        IFR( InsertElement(GetMarkupServices(), spElement, epLeft, spRight) );
    }
    
    // Add right side
    IFR( pEnd->MovePointerTo(epLeft, ELEM_ADJ_AfterEnd) );
    IFR( bpParent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );     
    IFR( epLeft.IsEqualTo(spRight, BREAK_CONDITION_Phrase, &bEqual) );
    if (!bEqual)
    {
        IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
        IFR( CopyAttributes(bpParent._pElement, spElement, FALSE) );
        IFR( InsertElement(GetMarkupServices(), spElement, epLeft, spRight) );
    }    

    // Copy the DIR=LTR/RTL from the parent to the current element
    IFR( CopyRTLAttr(bpParent._pElement, _pElement));

    // Move bpParent up to true parent    
    spElement = bpParent._pElement;
 
    // Remove element
    IFR( GetMarkupServices()->RemoveElement(spElement) );

    if (fCanChangeType)
    {
        BOOL fFirstMorph = TRUE;
        
        // Make sure containership is ok
        IFR( bpPointer.MoveTo(this) );
        do
        {
            IFR( bpPointer.IsEqual(pEnd) );
            bEqual = (hr == S_OK);
            
            IFR( bpPointer.EnsureCorrectTypeForContainer() );
            if (fFirstMorph)
            {
                IFR( MoveTo(&bpPointer) );
                fFirstMorph = FALSE;
            }
            
            if (bEqual)
                break;

            IFR( bpPointer.MoveToSibling(RIGHT) );
            Assert(hr != S_FALSE);            
        }
        while (hr == S_OK); // just in case (this, bpPointer) are not siblings
    }

    // Flatten parent scope
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );
    if (bpParent.GetType() == NT_Block)
        IFR( bpParent.FlattenNode() );

    return S_OK;   
}

HRESULT
CBlockPointer::EnsureCorrectTypeForContainer()
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);
    ELEMENT_TAG_ID  tagId, tagIdParent, tagIdGoal;
        
    IFR( bpParent.MoveTo(this) );
    IFR( bpParent.MoveToParent() );    

    // Make sure list containership is still ok
    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
    IFR( GetMarkupServices()->GetElementTagId(bpParent._pElement, &tagIdParent) );

    if (IsListItem(tagId))
    {
        if (IsListContainer(tagIdParent))
        {
            if (!IsListCompatible(tagId, tagIdParent))
            {
                tagIdGoal = GetListItemType(tagIdParent);
                IFR( Morph(this, tagIdGoal) );
            }
        }
        else
        {
            // Not a list container, so convert to the default block tag 
            IFR( CGetBlockFmtCommand::GetDefaultBlockTag( GetMarkupServices(), &tagIdGoal) );
            IFR( Morph(this, tagIdGoal) );
        }
    }    
    else if (IsListContainer(tagIdParent) && !IsListContainer(tagId))
    {
        // Not a list container, so convert to the default block tag 
        tagIdGoal = GetListItemType(tagIdParent);
        IFR( Morph(this, tagIdGoal, tagIdParent) );
    }

    return S_OK;
 }

HRESULT
CBlockPointer::PrivateMorph(
    ELEMENT_TAG_ID  tagId)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdCurrent;

    Assert(IsElementType());

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagIdCurrent) );
    if (tagIdCurrent == tagId)
        return S_OK;
    
    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );    
    IFR( ReplaceElement(_pEd, _pElement, spElement) );
    ClearInterface(&_pElement);
    _pElement = spElement;
    _pElement->AddRef();

    IFR( GetElementNodeType(spElement, &_type) );

    Assert(IsElementType());

    return S_OK;
}

HRESULT 
CBlockPointer::Morph(
    CBlockPointer   *pEnd,
    ELEMENT_TAG_ID  tagIdDestination,
    ELEMENT_TAG_ID  tagIdContainer)
{
    HRESULT             hr;
    CBlockPointer       bpPointer(_pEd);

#ifndef _PREFIX_
    Assert(IsSameScope(pEnd));
#endif
    Assert(!IsListItem(tagIdDestination) || IsListCompatible(tagIdDestination, tagIdContainer));
    Assert(IsListItem(tagIdDestination) || tagIdContainer == TAGID_NULL);
    Assert(IsElementType());

    //
    // Replace the elements
    //

    IFR( PrivateMorph(tagIdDestination) );
    if (pEnd != this)
    {
        IFR( bpPointer.MoveTo(this) );
        while (!bpPointer.IsEqual(pEnd))
        {
            IFR( bpPointer.MoveToSibling(RIGHT) );
            Assert(hr != S_FALSE);

            IFR( bpPointer.PrivateMorph(tagIdDestination) );
        }
    }
    
    //
    // Check that the container matches the element type
    //

    IFR( EnsureContainer(pEnd, tagIdContainer) );

    if (IsListContainer(tagIdDestination))
    {
        IFR( MergeListContainers(LEFT) );
        IFR( MergeListContainers(RIGHT) );
    }
        
    return S_OK;
}

HRESULT
CBlockPointer::EnsureContainer(
    CBlockPointer *pEnd,
    ELEMENT_TAG_ID tagIdContainer)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId, tagIdParent;
    CBlockPointer       bpParent(_pEd);
    SP_IMarkupPointer   spLeft, spRight;
    SP_IHTMLElement     spElement;

    Assert(IsElementType() && _pElement);

    IFR( GetMarkupServices()->GetElementTagId(_pElement, &tagId) );
    
    if (IsListItem(tagId))
    {
        BOOL fNeedContainer = TRUE;
        
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );

        if (bpParent.GetType() == NT_ListContainer)
        {
            IFR( bpParent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdParent) );

            if (!IsListCompatible(tagId, tagIdContainer) || tagIdParent != tagIdContainer)
            {   
                IFR( FloatUp(pEnd, FALSE) );
                IFR( bpParent.MoveTo(this) );
                IFR( bpParent.MoveToParent() );
            }
            else
            {
                fNeedContainer = FALSE;
            }
        }

        if (fNeedContainer)
        {
            // Add the list container
            IFR( GetMarkupServices()->CreateElement(tagIdContainer, NULL, &spElement) );
            IFR( InsertAbove(spElement, pEnd, TAGID_NULL, NULL, FALSE) );

            // Try list merging
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );
            IFR( bpParent.MergeListContainers(RIGHT) );
            IFR( bpParent.MergeListContainers(LEFT) );
        }
        
    }
    else if (!IsListContainer(tagId))
    {
        for (;;)
        {
            IFR( bpParent.MoveTo(this) );
            IFR( bpParent.MoveToParent() );

            if (bpParent.GetType() != NT_ListContainer)
                break;

            IFR( FloatUp(this, TRUE) );
        }
    }
    
    return S_OK;
}    

HRESULT
CBlockPointer::FindInsertPosition(IMarkupPointer *pStart, Direction dir)
{
    HRESULT             hr;
    CEditPointer        epLimit(_pEd);
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    BOOL                fEqual, fLeftOf, fRightOf;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spElementParent;
    NodeType            nodeType;
    SP_IMarkupPointer   spTest;
    BOOL                fIgnoreGlyphs = FALSE;

    Assert(IsElementType() && (dir == LEFT || dir == RIGHT));

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( GetEditor()->CreateMarkupPointer(&spTest) );
    IFC( epLimit->MoveToPointer(pStart) );

    // Find limit of node
    IFC( epLimit.Scan(dir, dwSearch, &dwFound) );
    IFC( epLimit.Scan(Reverse(dir), dwSearch, &dwFound) );

    // Check for quick out
    IFC( epLimit->IsEqualTo(pStart, &fEqual) );
    if (fEqual)
    {
        hr = S_OK; // done;
        goto Cleanup;
    }

    // Walk up looking for containing elements
    Assert(_pElement);
    spElement = _pElement;        
    for (;;)
    {
        // Get Parent element
        IFC( GetEditor()->GetParentElement( spElement, &spElementParent) );
        if (spElementParent == NULL)
            break;
        spElement = spElementParent;

        // Make sure we didn't get the parent block tree node
        IFC( GetElementNodeType(spElement, &nodeType) );
        if (nodeType != NT_Undefined)
            break; // done

        // Check if we are within the limit
        if (dir == LEFT)
        {
            IFC( spTest->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
            IFC( spTest->IsLeftOf(epLimit, &fLeftOf) );
            if (fLeftOf)
                break;
        }
        else
        {
            IFC( spTest->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
            IFC( spTest->IsRightOf(epLimit, &fRightOf) );
            if (fRightOf)
                break;
        }

        // Adjust to current test point
        IFC( pStart->MoveToPointer(spTest) );               
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    return S_OK;
}

HRESULT 
CBlockPointer::InsertAbove(IHTMLElement *pElement, CBlockPointer *pEnd, ELEMENT_TAG_ID tagIdListContainer, CCommand *pCmd,  BOOL fValidate)
{
    HRESULT             hr;
    SP_IMarkupPointer   spLeft, spRight;
    CBlockPointer       bpParent(_pEd);
    ELEMENT_TAG_ID      tagId;

    //
    // Make sure parent isn't a <P> tag
    //
    if (fValidate) 
    {
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );
        if (bpParent.GetType() == NT_Block)
        {
            SP_IHTMLElement spElement;
            ELEMENT_TAG_ID  tagIdParent;

            IFR( bpParent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdParent) );
            if (tagIdParent == TAGID_P)
                IFR( bpParent.Morph(&bpParent, TAGID_DIV) );
        }
    }

    //
    // Insert above
    //
    IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );

    IFR( MovePointerTo(spLeft, ELEM_ADJ_BeforeBegin) );
    if (GetType() == NT_Control)
        IFR( FindInsertPosition(spLeft, LEFT) );
    
    IFR( pEnd->MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
    if (pEnd->GetType() == NT_Control)
        IFR( pEnd->FindInsertPosition(spRight, RIGHT) );

    if (pCmd)
        IFR( pCmd->InsertBlockElement(pElement, spLeft, spRight) )
    else
        IFR( GetMarkupServices()->InsertElement(pElement, spLeft, spRight) );

    //
    // Ensure containership is of the right type
    //

    if (tagIdListContainer != TAGID_NULL)
    {
        IFR( bpParent.MoveTo(this) );
        IFR( bpParent.MoveToParent() );
        IFR( bpParent.EnsureContainer(&bpParent, tagIdListContainer) );
    }

    //
    // Check for list merge case
    //

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    if (IsListContainer(tagId))
    {
        IFR( bpParent.MoveTo(pElement) );
        IFR( bpParent.MergeListContainers(LEFT) );
        IFR( bpParent.MergeListContainers(RIGHT) );
    }    

    return S_OK;
}

BOOL 
CBlockPointer::HasAttributes()
{
    HRESULT hr;
    UINT    uCount;
    
    Assert(IsElementType() && _pElement);

    IFC( _pEd->GetElementAttributeCount(_pElement, &uCount) );

    return (uCount != 0);

Cleanup:
    return TRUE;
}

HRESULT 
CBlockPointer::IsEqual(CBlockPointer *pOtherNode)
{
    HRESULT             hr;
    SP_IMarkupPointer   spThis;
    SP_IMarkupPointer   spOther;
    BOOL                bEqual;

    IFR( GetEditor()->CreateMarkupPointer(&spThis) );
    IFR( GetEditor()->CreateMarkupPointer(&spOther) );

    // Check left
    IFR( MovePointerTo(spThis, ELEM_ADJ_BeforeBegin) );
    IFR( pOtherNode->MovePointerTo(spOther, ELEM_ADJ_BeforeBegin) );

    IFR( spThis->IsEqualTo(spOther, &bEqual) );
    if (!bEqual)   
        return S_FALSE;

    // Check right        
    IFR( MovePointerTo(spThis, ELEM_ADJ_AfterEnd) );
    IFR( pOtherNode->MovePointerTo(spOther, ELEM_ADJ_AfterEnd) );

    IFR( spThis->IsEqualTo(spOther, &bEqual) );
    if (!bEqual)   
        return S_FALSE;
    
    return S_OK;
}

HRESULT     
CBlockPointer::GetElementNodeType(IHTMLElement *pElement, NodeType *pNodeType)
{
    HRESULT         hr;
    BOOL            fLayout;
    BOOL            fBlock;
    ELEMENT_TAG_ID  tagId;

    *pNodeType = NT_Undefined;

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
        
    if (IsListContainer(tagId))
    {
        *pNodeType = NT_ListContainer;
        return S_OK;        
    }

    // TODO: clean this up and verify correctness [ashrafm]
    switch (tagId)
    {
            // For BRs, we use this special node type (bug 77466)
        case TAGID_BR:
            *pNodeType = NT_TextBreak;
            break;

        case TAGID_BUTTON:
        case TAGID_TEXTAREA:
//        case TAGID_HTMLAREA:
        case TAGID_FIELDSET:
        case TAGID_LEGEND:
        case TAGID_SELECT:
        case TAGID_APPLET:
        case TAGID_IMG:
        case TAGID_INPUT:
        case TAGID_OBJECT:
            // IFRAME should be treated as a control
        case TAGID_IFRAME:
            *pNodeType = NT_Control;
            break;

        case TAGID_ADDRESS:
        case TAGID_BLOCKQUOTE:
        case TAGID_CENTER:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_P:
        case TAGID_PRE:
        case TAGID_DIV:
            *pNodeType = NT_Block;
            break;

        case TAGID_CAPTION:
        case TAGID_FRAME:
        case TAGID_FRAMESET:
            // MARQUEE should be treated as a block layout
        case TAGID_MARQUEE:
        case TAGID_TABLE:
        case TAGID_FORM:
        case TAGID_HR:
            *pNodeType = NT_BlockLayout;
            break;

        case TAGID_TD:
        case TAGID_HTML:
        case TAGID_BODY:
        case TAGID_TR:
        case TAGID_TBODY:
            *pNodeType = NT_Container;
            break;

        case TAGID_LI:
        case TAGID_DD:
        case TAGID_DT:
            *pNodeType = NT_ListItem;
            break;

            //For colgroup, we want to return S_FALSE so we don't use it as a 
            //node.
        case TAGID_COLGROUP:
            *pNodeType = NT_Block;
            return S_FALSE;
    }

    // Check for layout in block case
    if (*pNodeType == NT_Block || *pNodeType == NT_Undefined)
    {
        IFR(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));

        if (fBlock && *pNodeType == NT_Undefined)
        {
            *pNodeType = NT_Block;
        }
        if (fLayout)
        {
            *pNodeType = (*pNodeType == NT_Block) ? NT_BlockLayout : NT_FlowLayout;
        }
        if (!fBlock && *pNodeType == NT_Block)
        {
            // We have an element that is normally block but 
            // has been set to inline (see bug 102219)
            *pNodeType = NT_Undefined;
        }
    }

    // TODO: we need to check for list items here [ashrafm]

    return S_OK;
}

void
CBlockPointer::ClearPointers()
{
    if (_type == NT_Undefined)
        return;
        
    if (IsElementType())
    {
        ClearInterface(&_pElement);
    }
    else
    {
        ClearInterface(&_pLeft);
        ClearInterface(&_pRight);
    }

    _type = NT_Undefined;
}

BOOL 
CBlockPointer::IsElementType()
{
    switch(_type)
    {
        case NT_Block:
        case NT_Control:
        case NT_ListContainer:
        case NT_BlockLayout:
        case NT_FlowLayout:
        case NT_ListItem:
        case NT_Container:
        case NT_TextBreak:
            return TRUE;
            
        case NT_Text:
            return FALSE;
    }

    AssertSz(0, "Invalid CBlockPointer type");
    return FALSE;
}

BOOL
CBlockPointer::IsColgroup()
{
    ELEMENT_TAG_ID  tagId;

    if (_type != NT_Block)
        return FALSE;

    GetMarkupServices()->GetElementTagId(_pElement, &tagId);
    
    return tagId == TAGID_COLGROUP;
}

BOOL
CBlockPointer::IsColgroup(IHTMLElement * pElement)
{
    ELEMENT_TAG_ID  tagId;

    GetMarkupServices()->GetElementTagId(pElement, &tagId);

    return tagId == TAGID_COLGROUP;
}

HRESULT     
CBlockPointer::MovePointerTo(IMarkupPointer *pPointer, ELEMENT_ADJACENCY elemAdj )
{
    HRESULT hr;
    
    if (IsElementType())
    {
        if (IsLeafNode())
        {
            switch (elemAdj)
            {   
                case ELEM_ADJ_AfterBegin:
                    elemAdj = ELEM_ADJ_BeforeBegin;
                    break;
                    
                case ELEM_ADJ_BeforeEnd:
                    elemAdj = ELEM_ADJ_AfterEnd;
                    break;
            }
        }
        IFR( pPointer->MoveAdjacentToElement(_pElement, elemAdj) );
    }
    else
    {
        switch (elemAdj)
        {   
            case ELEM_ADJ_BeforeBegin:
            case ELEM_ADJ_AfterBegin:
                IFR( pPointer->MoveToPointer(_pLeft) );
                break;
                
            case ELEM_ADJ_BeforeEnd:
            case ELEM_ADJ_AfterEnd:
                IFR( pPointer->MoveToPointer(_pRight) );
                break;

            default:
                AssertSz(0, "unexpected adjacency type");
        }
            
    }

    return S_OK;
}

BOOL 
CBlockPointer::IsListCompatible(ELEMENT_TAG_ID tagIdListItem, ELEMENT_TAG_ID tagIdListContainer)
{
    Assert(IsListItem(tagIdListItem));
    Assert(IsListContainer(tagIdListContainer));

    switch (tagIdListItem)
    {
    case TAGID_LI:
        return (tagIdListContainer == TAGID_OL || tagIdListContainer == TAGID_UL
                || tagIdListContainer == TAGID_MENU || tagIdListContainer == TAGID_DIR);
        
    case TAGID_DD:
    case TAGID_DT:
        return (tagIdListContainer == TAGID_DL);

    default:
        AssertSz(0, "Unexpected list item");
        return TRUE;
    }    
}

ELEMENT_TAG_ID 
CBlockPointer::GetListItemType(ELEMENT_TAG_ID tagIdListContainer)
{
    Assert(IsListContainer(tagIdListContainer));

    if (tagIdListContainer == TAGID_DL)
        return TAGID_DD;

#if DBG==1    
    switch (tagIdListContainer)
    {
    case TAGID_OL:
    case TAGID_UL:
    case TAGID_MENU:
    case TAGID_DIR:
        break;

    default:
        AssertSz(0, "unexpected list container");
    }
#endif 

    return TAGID_LI;
}

#if DBG==1
BOOL 
CBlockPointer::IsSameScope(CBlockPointer *pOtherNode)
{
    HRESULT         hr;
    CBlockPointer   bpParent(_pEd);
    CBlockPointer   bpParentOther(_pEd);

    IFC( bpParent.MoveTo(this) );
    IFC( bpParent.MoveToParent() );

    IFC( bpParentOther.MoveTo(this) );
    IFC( bpParentOther.MoveToParent() );

    return (bpParent.IsEqual(&bpParentOther) == S_OK);
    
Cleanup:
    return FALSE;
}
#endif

HRESULT 
CBlockPointer::MergeListContainers(Direction dir)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(_pEd);
    SP_IHTMLElement     spOtherElement;
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdMain;
    ELEMENT_TAG_ID      tagIdOther;
    CBlockPointer       bpParent(_pEd);
    
    Assert(IsElementType() && _pElement);

    //
    // Find the other element
    //

    IFC( bpCurrent.MoveTo(this) );
    Assert(bpCurrent.GetType() == NT_ListContainer);

    IFC( bpCurrent.MoveToSibling(dir) );
    if (hr == S_FALSE)
    {
        //
        // We may be a nested list container, so try merging the parent list container
        //
        IFC( bpParent.MoveTo(&bpCurrent) );
        IFC( bpParent.MoveToParent() );

        if (hr == S_FALSE)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        if (bpParent.GetType() == NT_ListItem && dir == RIGHT)
        {
            // Check for <li>....<ol>...</ol></li> + <ol=bpCurrent>...</ol> merge
            IFC( bpCurrent.MoveToSibling(dir) );
            if (hr != S_FALSE)
            {
                hr = S_FALSE;
                goto Cleanup;
            }

            IFC( bpCurrent.FloatUp(&bpCurrent, FALSE) );

            IFC( bpParent.MoveTo(&bpCurrent) );
            IFC( bpParent.MoveToParent() );
        }

        if (bpParent.GetType() != NT_ListContainer)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        IFC( bpParent.MergeListContainers(dir) );
        if (hr == S_FALSE)
            goto Cleanup;
    }

    if (bpCurrent.GetType() == NT_ListItem && dir == LEFT)
    {
        // Check for <li>....<ol>...</ol></li> + <ol=bpCurrent>...</ol> merge
        IFC( bpCurrent.MoveToLastChild() );
        if (bpCurrent.GetType() == NT_ListContainer)
            IFC( bpCurrent.FloatUp(&bpCurrent, FALSE) );
    }

    if (hr == S_FALSE || bpCurrent.GetType() != NT_ListContainer)
        return S_FALSE; // can't merge 

    //
    // Check that both elements are of the same type
    //    

    IFC( GetMarkupServices()->GetElementTagId(_pElement, &tagIdMain) );

    IFC( bpCurrent.GetElement(&spOtherElement) );
    IFC( GetMarkupServices()->GetElementTagId(spOtherElement, &tagIdOther) );

    if (tagIdMain != tagIdOther)
        return S_FALSE;

    //
    // Do the merge
    //

    IFC( GetMarkupServices()->CreateElement(tagIdMain, NULL, &spElement) );
    IFC( CopyAttributes(_pElement, spElement, TRUE) );

    if (dir == LEFT)        
        IFC( bpCurrent.InsertAbove(spElement, this) )
    else
        IFC( InsertAbove(spElement, &bpCurrent) );
    
    spElement = _pElement;
    IFC( MoveToParent() );

    IFC( GetMarkupServices()->RemoveElement(spOtherElement) );
    IFC( GetMarkupServices()->RemoveElement(spElement) ); 

Cleanup:
    RRETURN1(hr, S_FALSE);
}

// Copy the RTL Attribute from one element to another
HRESULT
CBlockPointer::CopyRTLAttr( IHTMLElement * pSrcElement, IHTMLElement * pDestElement)
{
    HRESULT hr = S_OK;
    IHTMLElement2 *pSrcElem2 = NULL;
    IHTMLElement2 *pDestElem2 = NULL;
    BSTR bstrSrc = NULL;
    BSTR bstrDest = NULL;

    IFC( pSrcElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pSrcElem2) );
    if(!pSrcElem2) 
        goto Cleanup;
    
    IFC( pSrcElem2->get_dir(&bstrSrc) );

    IFC( pDestElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&pDestElem2) );
    if(!pDestElem2) 
        goto Cleanup;
    
    IFC( pDestElem2->get_dir(&bstrDest) );

    if (StrCmpIW(bstrSrc, bstrDest) != 0)
        IFC( pDestElem2->put_dir(bstrSrc) );

Cleanup:
    ReleaseInterface(pSrcElem2);
    ReleaseInterface(pDestElem2);
    SysFreeString(bstrSrc);
    SysFreeString(bstrDest);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockPointer::IsEmpty
//
//  Synopsis:   Determines whether the current block is empty or not.
//
//  Arguments:  pfEmpty = Pointer to flag to determine if empty or not
//
//  Returns:    HRESULT indicating whether the function was successful
//
//--------------------------------------------------------------------------
HRESULT
CBlockPointer::IsEmpty(BOOL *pfEmpty, BOOL fIgnorePhraseElements /*=TRUE */)
{
    HRESULT             hr;
    CEditPointer        epLeft(_pEd);
    CEditPointer        epRight(_pEd);
    BOOL                bEmpty = FALSE;
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    BOOL                fIgnoreGlyphs = FALSE;

    Assert( pfEmpty );

    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    
    // See if we want to ignore phrase elements
    if( !fIgnorePhraseElements )
    {
        dwSearch |= BREAK_CONDITION_Phrase;
    }
    
    // Create  the markup pointers, and position them after the 
    // beginning and before the end
    IFC( MovePointerTo(epLeft, ELEM_ADJ_AfterBegin) );
    IFC( MovePointerTo(epRight, ELEM_ADJ_BeforeEnd) );

    // Scan right
    IFC( epLeft.Scan(RIGHT, dwSearch, &dwFound, NULL) );

    // Empty only if we didn't find an element before the end
    IFC( epLeft->IsRightOf( epRight, &bEmpty  ) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    *pfEmpty = bEmpty;

    return S_OK;
}

HRESULT 
CListCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT             hr = S_OK;
    OLECMD              cmd;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    //
    // Validation of command
    //
    
    IFR( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );
        IFR( ApplyListCommand(pStart, pEnd, FALSE, TRUE) );
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }
    

    if (pvarargOut)
    {
        VariantInit(pvarargOut);
        return E_NOTIMPL;
    }
    
    return S_OK;
}

HRESULT 
CBlockFmtListCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT             hr = S_OK;
    OLECMD              cmd;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    //
    // Validation of command
    //
    
    IFR( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyListCommand(pStart, pEnd, FALSE, FALSE) );
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }
    

    if (pvarargOut)
    {
        VariantInit(pvarargOut);
        return E_NOTIMPL;
    }
    
    return S_OK;
}

HRESULT
CListCommand::ApplyListCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fQueryMode, BOOL fCanRemove)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart, spEnd;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spListContainer;
    SP_IHTMLElement     spListItem;
    ELEMENT_TAG_ID      tagId;

    IFR( CopyMarkupPointer(GetEditor(), pStart, &spStart) );
    IFR( CopyMarkupPointer(GetEditor(), pEnd, &spEnd) );

    //
    // This command has 3 modes:
    //
    //   A. Create a list type
    //   B. Change list type
    //   C. Remove current list
    //
    // We now need to decide which mode we are in.  The algorithm is:
    //   1. Find the common node
    //   2. Find the list container (or list item) above.  If we find one that is not
    //      equal to the current list type, we are in case B.
    //   3. Otherwise, if we find a list container that is equal to the current list type,
    //      we are in case C.
    //   4. Otherwise, we are in case A.
    //

    //
    // Find common element
    //
    
    IFR( ClingToText(spStart, RIGHT, pEnd) );    
    IFR( ClingToText(spEnd, LEFT, spStart) );    
    IFR( GetEditor()->FindCommonElement(spStart, spEnd, &spElement, TRUE, TRUE) );

    if (spElement != NULL)
    {
        // Check for case B/C
        IFR( FindListContainer(GetMarkupServices(), spElement, &spListContainer));
        if (spListContainer != NULL)
        {
            IFR( GetMarkupServices()->GetElementTagId(spListContainer, &tagId) );

            if (GetListContainerType() != tagId || !fCanRemove)
            {
                if (fQueryMode)
                    return S_OK; // ok to apply list
                            
                IFR( ChangeListType(spListContainer, NULL, FALSE, spStart, spEnd) ); // case C

                // For DD/DT case, we need to change the actual listitem type as well as the container
                if (hr == S_FALSE && (_tagId == TAGID_DD || _tagId == TAGID_DT))
                {
                    // Check for common list item first
                    IFR( CreateList(pStart, pEnd, TRUE) );
                }
            }
            else
            {
                if (fQueryMode)
                    return S_FALSE; // ok to remove list
                    
                IFR( RemoveList(spStart, spEnd, spListContainer) ); // case B
            }
                
            return S_OK;
        }
        
    }

    // We are in case A - create the list
    
    if (fQueryMode)
        return S_OK; // ok to Apply list    
        
    IFR( CreateList(pStart, pEnd, TRUE) );
    
    return S_OK;
}

HRESULT 
CListCommand::SetCurrentTagId(ELEMENT_TAG_ID tagId, ELEMENT_TAG_ID *ptagIdOld)
{
    if (ptagIdOld)
        *ptagIdOld = _tagId;

    _tagId = tagId;

    return S_OK;
}

HRESULT 
CListCommand::PrivateQueryStatus( OLECMD * pCmd, 
                            OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP; // up by default

    IFC( GetSegmentList(&spSegmentList) );

#if DBG==1    
    BOOL fEmpty;
    IFR( spSegmentList->IsEmpty( &fEmpty ) );
    Assert(!fEmpty );
#endif    

    IFR( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );    
    IFR( ApplyListCommand(spStart, spEnd, TRUE, TRUE) );    
    if (hr == S_FALSE)
        pCmd->cmdf = MSOCMDSTATE_DOWN;

    hr = S_OK;
    
Cleanup:
    return hr;
}

ELEMENT_TAG_ID 
CListCommand::GetListContainerType()
{
    if (IsListContainer(_tagId))
        return _tagId;

    Assert(IsListItem(_tagId));
    
    switch (_tagId)   
    {
        case TAGID_DD:
        case TAGID_DT:
            return TAGID_DL;
    }

    AssertSz(0, "unexpected list command");
    return TAGID_NULL;
}

ELEMENT_TAG_ID 
CListCommand::GetListItemType()
{
    if (IsListItem(_tagId))
        return _tagId;

    Assert(IsListContainer(_tagId));
    return TAGID_LI;
}

ELEMENT_TAG_ID  
CListCommand::GetListItemType(IHTMLElement *pListContainer)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId;

    IFC( GetMarkupServices()->GetElementTagId(pListContainer, &tagId) );
    if (tagId == TAGID_DL)
        return TAGID_DD;

Cleanup:
    return TAGID_LI;
}

HRESULT         
CListCommand::CreateList(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fAdjustOut)
{   
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spLeft, spRight;
    ELEMENT_TAG_ID      tagId;

    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    if (fAdjustOut)
        IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    IFR( spLimit->MoveToPointer(pEnd) );

    if (fAdjustOut)
        IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );

    // Flatten first node if necessary
    if (bpCurrent.GetType() == NT_Block)
        IFR( bpCurrent.FlattenNode() );

    // 
    // Create list type
    //  

    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( bpCurrentStart.MoveTo(&bpCurrent) );
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
            IFR( bpCurrentStart.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
            break;
            
        case NT_BlockLayout:             
            IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
            IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
            break;
            
        case NT_Block:
        case NT_ListItem:
            tagId = TAGID_NULL;
        
            IFR( bpCurrent.GetElement(&spElement) );
            if (spElement != NULL)
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

            switch (tagId)
            {
                case TAGID_BLOCKQUOTE:
                    if (spLeft == NULL)
                    {
                        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
                        IFR( spLeft->SetGravity(POINTER_GRAVITY_Left) );
                    }

                    if (spRight == NULL)
                    {
                        IFR( GetEditor()->CreateMarkupPointer(&spRight) );
                        IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
                    }

                    IFR( bpCurrent.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
                    IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );

                    IFR( CreateList(spLeft, spRight) );
                    IFR( bpCurrent.Morph(&bpCurrent, GetListContainerType()) );
                    break;
                    
                case TAGID_P:
                case TAGID_DIV:
                case TAGID_PRE:
                    if (!bpCurrent.HasAttributes())
                    {
                        IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                        break;
                    }
                    // Otherwise, fall through
                    
                default:
                    if (IsListItem(tagId))
                    {
                        IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                    }
                    else
                    {
                        SP_IHTMLElement spCurrentElement;
                        SP_IHTMLElement spParentElement;
                        CBlockPointer   bpParent(GetEditor());
                        
                        IFR( GetMarkupServices()->CreateElement(GetListItemType(), NULL, &spElement) );            
                        IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, GetListContainerType(), this) );
                        if (tagId == TAGID_P || tagId == TAGID_DIV || tagId == TAGID_PRE)
                        {
                            if(tagId == TAGID_P)
                                IFR( bpCurrent.Morph(&bpCurrent, TAGID_DIV) );

                            IFR( bpCurrent.GetElement(&spCurrentElement) );
                            IFR( bpParent.MoveTo(&bpCurrent) );
                            IFR( bpParent.MoveToParent() );

                        }
                        else
                        {
                            IFR( bpCurrent.GetElement(&spCurrentElement) );
                            IFR( bpParent.MoveTo(&bpCurrent) );
                        }

                        IFR( bpParent.MoveToParent() );

                        // we always want to move the direction to the list container
                        // if we didn't land on it, just put it on the list item
                        if(bpParent.GetType() == NT_ListContainer)
                        {
                            IFR( bpParent.GetElement(&spParentElement) );
                            IFR( MoveRTLAttr(spCurrentElement, spParentElement) );
                        }
                        else
                            IFR( MoveRTLAttr(spCurrentElement, spElement) );
                    }
            }            
            break;
            
        case NT_ListContainer:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( ChangeListType(spElement, &spNewContainer, TRUE /* Morph list items */) );
            IFR( bpCurrent.MoveTo(spNewContainer) );
            break;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
}

HRESULT
CListCommand::MoveRTLAttr(IHTMLElement *pSourceElement, IHTMLElement *pDestElement)
{
    HRESULT             hr; 
    BSTR                bstrDir = NULL;
    SP_IHTMLElement2    spSourceElement2;
    SP_IHTMLElement2    spDestElement2;

    IFC( pSourceElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spSourceElement2) );
    IFC( spSourceElement2->get_dir(&bstrDir) );

    if (bstrDir && StrCmpIW(bstrDir, L""))
    {
        IFC( pDestElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spDestElement2) );
        IFC( spDestElement2->put_dir(bstrDir) );
        IFC( spSourceElement2->put_dir(L"") );
    }

Cleanup:
    SysFreeString(bstrDir);    
    RRETURN(hr);
}

HRESULT         
CListCommand::RemoveList(IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement *pListContainer)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    CBlockPointer       bpStart(GetEditor()), bpEnd(GetEditor());
    CBlockPointer       bpListContainer(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    CEditPointer        epLimit(GetEditor());
    DWORD               dwSearch, dwFound;
    INT                 cFloatUp;

#if DBG==1
    ELEMENT_TAG_ID tagId;
    Assert(S_OK == GetMarkupServices()->GetElementTagId(pListContainer, &tagId));
    Assert(IsListContainer(tagId));
#endif

    IFR( bpListContainer.MoveTo(pListContainer) );

    //
    // We know that pStart/pEnd are in list items that are contained in pListContainer.
    // Thus, find the list items, and float the range up to remove the list
    //

    // Find the left list item
    IFR( bpStart.MoveTo(pStart, RIGHT) );
    IFR( bpStart.MoveToScope( &bpListContainer) );

    // Find the right list item
    IFR( bpEnd.MoveTo(pEnd, LEFT) );
    IFR( bpEnd.MoveToScope( &bpListContainer) );

    // Remember limit
    IFR( bpEnd.MovePointerTo(epLimit, ELEM_ADJ_AfterEnd) );
    
    // Remove the list
    // NOTE: parser drops </LI>'s, so keep floating while at an </LI> boundary

    IFR( bpTest.MoveTo(&bpEnd) );    
    IFR( bpTest.MoveToSibling(RIGHT) );
    if (hr == S_FALSE)
    {
        IFR( bpTest.MoveToParent() );

        cFloatUp = 1; // we're going to FloatUp with morph below
        for (;;)
        {
            IFR( bpTest.MoveToSibling(RIGHT) );
            if (hr != S_FALSE)
                break;

            IFR( bpTest.MoveToParent() );
            if (hr == S_FALSE || bpTest.GetType() != NT_ListItem)
                break;

            ++cFloatUp;        
        }

        for (INT i = 0; i < cFloatUp - 1; ++i)
        {
            IFR( bpStart.FloatUp(&bpEnd, FALSE /* fFixupBlockType */) );
        }
    }

    IFR( bpStart.FloatUp(&bpEnd, TRUE /* fFixupBlockType */ ) );

    // Adjust limit out
    dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    IFR( epLimit.Scan(RIGHT, dwSearch - BREAK_CONDITION_ExitBlock, &dwFound) );
    IFR( epLimit.Scan(LEFT, dwSearch, &dwFound) );
    
    // Flatten all children
    if (bpStart.GetType() == NT_Block)
        IFR( bpStart.FlattenNode() );
        
    do
    {
        IFR( bpStart.MoveToNextLogicalBlock(epLimit, TRUE) );
    }
    while (hr != S_FALSE);

    return S_OK;
}

//
//  CListCommand::ChangeListsChildListsTypes
//
//  (The name of the function should be read as Change List's Child List's Types.)
//  We recurse through the child of bpbCurrent looking for list containers. When
//  we find one, we call ChangeListType().
//
//  Pretty simple really.
//

HRESULT
CListCommand::ChangeListsChildListsTypes(
    CBlockPointer   *pbpCurrent, 
    BOOL            fMorphListItems     /* = FALSE */,
    IMarkupPointer  *pSelectionStart    /* = NULL */,
    IMarkupPointer  *pSelectionEnd      /* = NULL */)
{
    HRESULT             hr;
    CBlockPointer       bpChild(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spElementNew;
    ELEMENT_TAG_ID      tagId;
    SP_IMarkupPointer   spTest;

    // pSelectionStart implies pSelectionEnd
    Assert(pSelectionStart == NULL || pSelectionEnd != NULL);

    // pSelectionEnd implies pSelectionStart
    Assert(pSelectionStart != NULL || pSelectionEnd == NULL);

    if (pSelectionStart)
    {
        IFC( GetEditor()->CreateMarkupPointer(&spTest) );
    }

    IFC( bpChild.MoveTo(pbpCurrent) );
    IFC( bpChild.MoveToFirstChild() );
    while (hr == S_OK)
    {
        if (bpChild.GetType() == NT_ListContainer)
        {
            BOOL fMorph = TRUE;

            // If we have a selection, only morph if the list container intersects
            // the selection.
            if (pSelectionStart)
            {
                IFC( bpChild.MovePointerTo(spTest, ELEM_ADJ_AfterBegin) );
                IFC( spTest->IsLeftOf(pSelectionEnd, &fMorph) );
                if (fMorph)
                {
                    IFC( bpChild.MovePointerTo(spTest, ELEM_ADJ_BeforeEnd) );
                    IFC( spTest->IsRightOf(pSelectionStart, &fMorph) );
                }
            }
            
            if (fMorph)
            {
                IFC( bpChild.GetElement(&spElement) );
                if (spElement != NULL)
                {
                    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                    if (GetListContainerType() != tagId)
                    {
                        // Calling ChangeListType will call ChangeListsChildListTypes
                        IFC( ChangeListType(spElement, &spElementNew, fMorphListItems, pSelectionStart, pSelectionEnd) );
                        IFC( bpChild.MoveTo(spElementNew) );
                    }
                }
            }
        }
        else
        {
            IFC( ChangeListsChildListsTypes(&bpChild, fMorphListItems, pSelectionStart, pSelectionEnd) );
        }
        IFC( bpChild.MoveToSibling(RIGHT) );
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT
CListCommand::ChangeListType(
    IHTMLElement    *pListContainer, 
    IHTMLElement    **ppNewContainer, 
    BOOL            fMorphListItems,
    IMarkupPointer  *pSelectionStart, 
    IMarkupPointer  *pSelectionEnd)
{
    HRESULT         hr;
    CBlockPointer   bpCurrent(GetEditor());
    CBlockPointer   bpParent(GetEditor());
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;

    if (ppNewContainer)
        *ppNewContainer = NULL;

    //
    // Change container type
    //
    IFR( bpCurrent.MoveTo(pListContainer) );
    IFR( bpCurrent.Morph(&bpCurrent, GetListContainerType()) );

    if (ppNewContainer)
        IFR( bpCurrent.GetElement(ppNewContainer) );

    IFR( ChangeListsChildListsTypes(&bpCurrent, fMorphListItems, pSelectionStart, pSelectionEnd) );

    //
    // Change parent list containers
    //

    IFR( bpParent.MoveTo(&bpCurrent) );
    IFR( bpParent.MoveToParent() );
    if (hr == S_OK && bpParent.GetType() == NT_ListContainer)
    {
        SP_IMarkupPointer spLeft, spRight;
        CBlockPointer     bpTest(GetEditor());
        BOOL              fEqual;

        IFR( GetEditor()->CreateMarkupPointer(&spLeft) );
        IFR( GetEditor()->CreateMarkupPointer(&spRight) );
        IFR( bpTest.MoveTo(&bpCurrent) );
        do     
        {
            // Check left boundary
            IFR( bpParent.MovePointerTo(spLeft, ELEM_ADJ_AfterBegin) );
            IFR( bpTest.MovePointerTo(spRight, ELEM_ADJ_BeforeBegin) );
            IFR( spLeft->IsEqualTo(spRight, &fEqual) );
            if (!fEqual)
                break;

            // Check right boundary
            IFR( bpTest.MovePointerTo(spLeft, ELEM_ADJ_AfterEnd) );
            IFR( bpParent.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );
            IFR( spLeft->IsEqualTo(spRight, &fEqual) );
            if (!fEqual)
                break;

            // Morph list
            IFR( bpParent.Morph(&bpParent, GetListContainerType()) );

            // Find parent
            IFR( bpTest.MoveTo(&bpParent) );
            IFR( bpParent.MoveToParent() );            
        } 
        while (hr == S_OK && bpParent.GetType() == NT_ListContainer);
    }

    //
    // Change list items if type is difference
    //
    IFR( GetMarkupServices()->GetElementTagId(pListContainer, &tagId) );
    
    if (!bpCurrent.IsListCompatible(GetListItemType(), tagId) || fMorphListItems)
    {
        IFR( bpCurrent.MoveToFirstChild() );
        while (hr == S_OK)
        {
            IFR( bpCurrent.GetElement(&spElement) );
            if (spElement != NULL)
            {
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (IsListItem(tagId))
                {   
                    // TODO: this can be made faster by collecting all children and calling
                    //       morph once [ashrafm]

                    IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );
                }
            }
            
            IFR( bpCurrent.MoveToSibling(RIGHT) );
        }
    }
    else
    {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT
CListCommand::ChangeListItemType(IHTMLElement *pListItem)
{
    HRESULT         hr;
    CBlockPointer   bpCurrent(GetEditor());

    IFR( bpCurrent.MoveTo(pListItem) );
    IFR( bpCurrent.Morph(&bpCurrent, GetListItemType(), GetListContainerType()) );

    return S_OK;    
}

//+---------------------------------------------------------------------------
//
//  CBlockFmtCommand Class
//
//----------------------------------------------------------------------------

HRESULT 
CBlockFmtCommand::PrivateQueryStatus(  
                        OLECMD          *pCmd,
                        OLECMDTEXT      *pcmdtext )
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup ;
    }
#endif

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
              
    pCmd->cmdf = MSOCMDSTATE_UP; 
    hr = S_OK;
    
Cleanup:
    return hr;
}

HRESULT 
CBlockFmtCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )                        
{  
    HRESULT             hr;
    ELEMENT_TAG_ID      tagId;
    ELEMENT_TAG_ID      tagIdOld = TAGID_NULL;            
    BSTR                bstrName;
    SP_ISegmentList     spSegmentList;
    IMarkupPointer      *pStart, *pEnd;
    CSegmentListIter    iter;
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spCaretMarker;

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFR( GetSegmentList(&spSegmentList) );

    if (pvarargIn)
    {        
        if (V_VT(pvarargIn) != VT_BSTR)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        
        IFR( CGetBlockFmtCommand::LookupTagId(GetMarkupServices(), V_BSTR(pvarargIn), &_tagId) );

        if (ShouldRemoveFormatting(_tagId))
        {
            GetSpringLoader()->Reset();
        }
        else if (!IsListItem(_tagId) && !IsListContainer(_tagId))
        {
            // reset the springloader with the compose settings
            GetSpringLoader()->SpringLoadComposeSettings(NULL, TRUE); 
        }
        
        if (IsListContainer(_tagId) || IsListItem(_tagId))
        {
            // new in constructor may fail if out of memory
            if (_pListCommand == NULL)
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            IFC( _pListCommand->SetCurrentTagId(_tagId, &tagIdOld) ) ;
            IFC( _pListCommand->Exec(nCmdexecopt, pvarargIn, pvarargOut, GetCommandTarget()) );
            IFC( _pListCommand->SetCurrentTagId(tagIdOld, NULL) );
        }    
        else
        {
            IFC( iter.Init(GetEditor(), spSegmentList) );
            IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
            for (;;)
            {
                IFC( iter.Next(&pStart, &pEnd) );
                if (hr == S_FALSE)
                    return S_OK; // done

                IFR( AdjustSegment(pStart, pEnd) );

                // NOTE: CreateCaretMarker fails when there is no caret.  This is
                // a common case when executing commands through the range

                IGNORE_HR( CreateCaretMarker(&spCaretMarker) );
                IFR( ApplyCommand(pStart, pEnd) );
                IGNORE_HR( RestoreCaret(spCaretMarker) );
            }    
        }
    }
    
    if (pvarargOut)
    {
        V_VT(pvarargOut) = VT_BSTR;

        hr = THR(GetFirstSegmentBlockFormat(spSegmentList, &tagId));
        if (hr != S_OK)
        {
            V_BSTR(pvarargOut) = NULL;
        }
        else
        {
            bstrName = CGetBlockFmtCommand::LookupFormatName(GetMarkupServices(), tagId);
            V_BSTR(pvarargOut) = (bstrName)?SysAllocString(bstrName):NULL;
        }
        hr = S_OK;
    }

Cleanup:    
    if (FAILED(hr) && pvarargOut)
        VariantInit(pvarargOut);

    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////////////////
//
//  CBlockFmtCommand::GetFirstSegmentBlockFormat
//
//  Synopsis:   Returns the block format for the first segment in a list of segments
//              
//
//////////////////////////////////////////////////////////////////////////////////////
HRESULT
CBlockFmtCommand::GetFirstSegmentBlockFormat(
    ISegmentList    *pSegmentList,
    ELEMENT_TAG_ID  *ptagIdOut
    )
{
    HRESULT                 hr     = S_OK;
    BOOL                    fEmpty = FALSE;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;

    Assert( pSegmentList );
    Assert( ptagIdOut );

    *ptagIdOut = TAGID_UNKNOWN;
    
    IFC( pSegmentList->IsEmpty(&fEmpty) );
    if (fEmpty) 
    {
        IFC( GetActiveElemSegment(GetMarkupServices(), &spStart, &spEnd) );
        IFC( GetBlockFormat(spStart, spEnd, ptagIdOut) );
        return S_OK;
    }
    
    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( pSegmentList->CreateIterator(&spIter) );

    Assert(S_FALSE == spIter->IsDone());

    IFC( spIter->Current(&spSegment) );
    IFC( spSegment->GetPointers(spStart, spEnd) );
    IFC( ClingToText(spStart, RIGHT, spEnd) );
    IFC( ClingToText(spEnd, LEFT, spStart) );
    IFC( GetBlockFormat(spStart, spEnd, ptagIdOut) );

Cleanup:
    RRETURN1(hr, S_FALSE);
}



HRESULT
CBlockFmtCommand::FindBlockFmtElement(
    IHTMLElement    *pBlockElement, 
    IHTMLElement    **ppBlockFmtElement, 
    ELEMENT_TAG_ID  *ptagIdOut)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spBlockElement;
    SP_IHTMLElement spParentElement;
    
    Assert(ptagIdOut != NULL);

    spBlockElement = pBlockElement;
    
    while (spBlockElement != NULL)
    {
        IFC( GetMarkupServices()->GetElementTagId(spBlockElement, ptagIdOut) );

        if (IsListContainer(*ptagIdOut) 
            || IsBasicBlockFmt(*ptagIdOut)
            || (*ptagIdOut) == TAGID_DD
            || (*ptagIdOut) == TAGID_DT)
          break; // found block format
            
        IFC( GetEditor()->GetParentElement( spBlockElement, &spParentElement) );
        spBlockElement = spParentElement;

        // reached top of the tree without finding the block element
        if (spBlockElement == NULL)
        {
            *ptagIdOut = TAGID_NULL;
            goto Cleanup;
        }
    }

Cleanup:
    if (ppBlockFmtElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppBlockFmtElement = spBlockElement;
            if (spBlockElement != NULL)
                (*ppBlockFmtElement)->AddRef();
        }
        else
        {
            *ppBlockFmtElement = NULL;
            *ptagIdOut = TAGID_NULL;
        }         
    }
    
    RRETURN(hr);
}

HRESULT
CBlockFmtCommand::GetBlockFormat(
    IMarkupPointer  *pStart,
    IMarkupPointer  *pEnd,
    ELEMENT_TAG_ID  *ptagIdOut)
{   
    HRESULT             hr = E_FAIL;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement     spBlockFmtElement;
    SP_IHTMLElement     spNewElement;
    SP_IMarkupPointer   spTest;
    BOOL                fInRange;
    long                i;

    *ptagIdOut = TAGID_NULL;

    hr = THR( GetEditor()->FindCommonElement(pStart, pEnd, &spElement, TRUE, TRUE));
    if (FAILED(hr) || spElement == NULL)
        return S_OK;

    //
    // Walk up to find a block format element
    //

    IFR( GetEditor()->FindBlockElement(spElement, &spBlockElement) );
    IFR( FindBlockFmtElement(spBlockElement, &spElement, ptagIdOut) );
    spBlockElement = spElement;


    if (*ptagIdOut == TAGID_NULL)
    {
        CBlockPointer   bpCurrent(GetEditor());
        ELEMENT_TAG_ID  tagId;

        IFR( GetEditor()->CreateMarkupPointer(&spTest) );    
                    
        //
        // Run through all the text
        //
        IFR( bpCurrent.MoveTo(pStart, RIGHT) );
        while (!bpCurrent.IsLeafNode())
        {
            IFR( bpCurrent.MoveToFirstChild() );
            Assert(hr != S_FALSE);
        }
        IFR( bpCurrent.MovePointerTo(spTest, ELEM_ADJ_BeforeBegin) );
        IFR( spTest->CurrentScope(&spElement) );
        IFR( FindBlockFmtElement(spElement, &spBlockFmtElement, ptagIdOut) );
        if (*ptagIdOut == TAGID_NULL)
            return S_OK; // done
        
        for (i=0;;i++)
        {
            // Move to next leaf node
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            IFR( bpCurrent.MoveToNextLeafNode() );
            if (hr == S_FALSE)
                break;
                
            IFR( bpCurrent.MovePointerTo(spTest, ELEM_ADJ_BeforeBegin) );
            IFR( spTest->IsLeftOfOrEqualTo(pEnd, &fInRange) );
            if (!fInRange)
                break;

            // Check block format type
            IFR( spTest->CurrentScope(&spElement) );
            IFR( FindBlockFmtElement(spElement, &spBlockFmtElement, &tagId) );
            if (tagId != (*ptagIdOut))
            {
                *ptagIdOut = TAGID_NULL;
                return S_FALSE;
            }
        }
    }
    else if (*ptagIdOut == TAGID_DL)
    {
        //
        // For definition list, check child types
        //

        CBlockPointer   bpCurrent(GetEditor());
        ELEMENT_TAG_ID  tagId;

        *ptagIdOut = TAGID_NULL;
        
        IFR( bpCurrent.MoveTo(spBlockElement) );
        IFR( bpCurrent.MoveToFirstChild() );
        if (bpCurrent.GetType() == NT_ListItem)
        {
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, ptagIdOut) );

            if (*ptagIdOut != TAGID_DD && *ptagIdOut != TAGID_DT)
            {
                *ptagIdOut = TAGID_UNKNOWN;
                return S_OK;
            }

            for (;;)
            {
                IFR( bpCurrent.MoveToSibling(RIGHT) );
                if (hr == S_FALSE)
                    break;

                if (bpCurrent.GetType() != NT_ListItem)
                {
                    *ptagIdOut = TAGID_UNKNOWN;
                    break;
                }

                IFR( bpCurrent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId != *ptagIdOut)
                {
                    *ptagIdOut = TAGID_UNKNOWN;
                    break;
                }
            }
        }
    }

    return S_OK;
}


BOOL
CBlockFmtCommand::IsBasicBlockFmt(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
        case TAGID_P:
        case TAGID_DIV:
        case TAGID_PRE:
        case TAGID_ADDRESS:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
            return TRUE;

        default:
            return FALSE;
    }
}

BOOL 
CBlockFmtCommand::ShouldRemoveFormatting(ELEMENT_TAG_ID tagId)
{
    switch (tagId)
    {
        case TAGID_PRE:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6: 
            return TRUE;

        default:
            return FALSE;
    }
}

HRESULT 
CBlockFmtCommand::FloatToTopLevel(CBlockPointer *pbpStart, CBlockPointer *pbpEnd)
{
    HRESULT         hr;
    CBlockPointer   bpParent(GetEditor());
    CBlockPointer   &bpStart= *pbpStart; // just for convenience
    CBlockPointer   &bpEnd = *pbpEnd; // just for convenience
    
    for (;;)
    {
        IFR( bpParent.MoveTo(&bpStart) );
        IFR( bpParent.MoveToParent() );
        if (hr == S_FALSE)
            break; // done

        if (bpParent.GetType() == NT_BlockLayout 
            || bpParent.GetType() == NT_FlowLayout
            || bpParent.GetType() == NT_Container)
            break; // done

        IFR( bpStart.FloatUp(&bpEnd, TRUE) );
    }    
    
    return S_OK;
}

HRESULT
CBlockFmtCommand::ApplyComposeSettings(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    CSpringLoader * psl = GetSpringLoader();
    BOOL fEqual = FALSE;

    if (psl)
    {
        IGNORE_HR(psl->SpringLoadComposeSettings(NULL, TRUE));

        if (pStart->IsEqualTo(pEnd, &fEqual) || !fEqual)
        {
            IGNORE_HR(psl->Fire(pStart, pEnd));
        }
    }

    return S_OK;
}
   

HRESULT 
CBlockFmtCommand::ApplyCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpStart(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    BOOL                fLeftOf = FALSE;
    ELEMENT_TAG_ID      tagIdDest = _tagId;
    ELEMENT_TAG_ID      tagId;

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

    //
    // Find first leaf node
    //

    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    
    if (bpCurrent.IsLeafNode() || bpCurrent.GetType() == NT_FlowLayout)
    {
        IFR( bpCurrent.MoveToFirstNodeInBlock() );
    }
    else
    {
        while (!bpCurrent.IsLeafNode() && bpCurrent.GetType() != NT_FlowLayout)
        {
            IFR( bpCurrent.MoveToFirstChild() );
            Assert(hr != S_FALSE);
        }
    }
    
    do
    {
        //
        // Apply command
        //

        if (bpCurrent.IsLeafNode() || bpCurrent.GetType() == NT_FlowLayout)
        {
            //
            // Group all text nodes together
            //
            
            IFR( bpStart.MoveTo(&bpCurrent) );            
            IFR( bpCurrent.MoveToLastNodeInBlock() );
            //
            // Apply block command
            //

            IFR( bpParent.MoveTo(&bpStart) );
            IFR( bpParent.MoveToBlockScope(&bpCurrent) );

            if (! (_tagId == TAGID_P && bpParent.GetType() == NT_ListItem) )
            {
                if (_tagId == TAGID_NULL) // normal command            
                {
                    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDest) );    

                    if (bpParent.IsLeafNode())
                    {
                        IFR( FloatToTopLevel(&bpStart, &bpCurrent) )
                        hr = S_FALSE;
                    }
                    else
                    {
                        IFR( FloatToTopLevel(&bpParent, &bpParent) )
                        hr = S_OK;
                    }
                }

                if (hr == S_OK && bpParent.GetType() == NT_Block)
                {   
                    IFR( bpParent.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                
                    if (IsBasicBlockFmt(tagId))
                    {
                        // Morph element
                        IFR( bpParent.Morph(&bpParent, tagIdDest, TAGID_NULL) );            
                        IFR( bpParent.GetElement(&spElement) );
                    }
                    else
                    {
                        IFR( GetMarkupServices()->CreateElement(tagIdDest, NULL, &spElement) );
                        IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                    }
                }        
                else 
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdDest, NULL, &spElement) );
                    IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                }
            
                IFR( bpStart.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );
                IFR( bpCurrent.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd) );

                if ( ShouldRemoveFormatting(_tagId))
                {
                    IFR( DYNCAST(CRemoveFormatCommand, GetEditor()->GetCommandTable()->Get(IDM_REMOVEFORMAT))->Apply(spStart, spEnd) ); 
                }
                else
                {
                    IFR( ApplyComposeSettings(spStart, spEnd) );
                }

                //
                // Flatten parent
                //

                IFR( bpParent.MoveTo(spElement) );
                IFR( bpParent.MoveToParent() );
                if (hr == S_OK && bpParent.GetType() == NT_Block)
                {
                    IFR( bpParent.FlattenNode() );
                }
            }
        }

        //
        // Find next leaf node
        //

        IFR( bpCurrent.MoveToNextLeafNode() );
        if (hr == S_OK)
        {
            // Check that the leaf node is in range                
            IFR( bpCurrent.MovePointerTo(spStart, ELEM_ADJ_BeforeBegin) );
            IFR( pEnd->IsLeftOf(spStart, &fLeftOf) );
        }
    } 
    while (hr == S_OK && !fLeftOf);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  COutdentCommand Class
//
//----------------------------------------------------------------------------
HRESULT
COutdentCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT             hr;
    IMarkupPointer      *pStart = NULL;
    IMarkupPointer      *pEnd = NULL;
    CSegmentListIter    iter;
    SP_ISegmentList     spSegmentList;
    SP_IDisplayPointer  spCaretMarker;
    
    CEdUndoHelper        undoUnit(GetEditor());

    IFC( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFC( GetSegmentList(&spSegmentList) );
    IFC( iter.Init(GetEditor(), spSegmentList) );
    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

    for (;;)
    {
        IFC( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyBlockCommand(pStart, pEnd) );    
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }

Cleanup:

    RRETURN( hr );
}

HRESULT 
COutdentCommand::PrivateQueryStatus(OLECMD * pCmd, OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;
        
    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT 
COutdentCommand::ApplyBlockCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId, tagIdDefault;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )    
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
    
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( spLimit->MoveToPointer(pEnd) );
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
    
    // 
    // Create list type
    //        
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( ForceScope(&bpCurrent) );
            IFR( OutdentBlock(&bpCurrent, spLimit) );
            break;
            
        case NT_ListItem:
            IFR( OutdentListItem(&bpCurrent) ); 
            if (bpCurrent.GetType() == NT_Block)
            {
                IFR( bpCurrent.FlattenNode() );
            }
            break;
            
        case NT_Block:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            if (tagId == TAGID_BLOCKQUOTE)
            {
                IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );    
                IFR( bpCurrent.Morph(&bpCurrent, tagId) );
                IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
                IFR( bpCurrent.FlattenNode() );
                IFR( bpCurrent.MoveTo(spRight, LEFT) );
            }
            else
            {
                IFR( OutdentBlock(&bpCurrent, spLimit) );
            }
            break;
            
        case NT_BlockLayout:             
            IFR( OutdentBlock(&bpCurrent, spLimit) );
            break;
            
        case NT_ListContainer:
            IFR( OutdentBlock(&bpCurrent, spLimit, TRUE /* fBlockquoteOnly */) );
            if (hr == S_FALSE)
            {
                IFR( bpCurrent.MoveToFirstChild() );                
                continue;
            }
            break;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
    
}


HRESULT 
COutdentCommand::FindIndentBlock(CBlockPointer *pbpBlock)
{
    HRESULT         hr;
    CBlockPointer   bpIndentBlock(GetEditor());
    CBlockPointer   &bpBlock = *pbpBlock;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagId;
    
    //
    // Walk up the tree until we find the indent block
    //
    
    IFR( bpIndentBlock.MoveTo(&bpBlock) );

    while (hr == S_OK)
    {
        switch (bpIndentBlock.GetType())
        {
            case NT_Block:
                IFR( bpIndentBlock.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_BLOCKQUOTE)
                {
                    IFR( bpBlock.MoveTo(&bpIndentBlock) );
                    return S_OK;
                }
                break;
                
            case NT_ListItem:
                IFR( bpBlock.MoveTo(&bpIndentBlock) );
                return S_OK; // found list item
                
            case NT_Container:
            case NT_BlockLayout:
            case NT_FlowLayout:
                return S_FALSE; // can't find indent block

            case NT_ListContainer:
                break; // keep looking

            default:
                AssertSz(0, "unexpected block type");
        }
        
        IFR( bpIndentBlock.MoveToParent() );
    }
    
    return S_FALSE; // not found    
}

HRESULT 
COutdentCommand::OutdentBlock(CBlockPointer *pBlock, IMarkupPointer *pRightBoundary, BOOL fBlockQuoteOnly /* = FALSE */)
{
    HRESULT             hr;
    CBlockPointer       bpIndentBlock(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId;
    BOOL                fDone;
    
    IFR( bpIndentBlock.MoveTo(pBlock) );
    IFR( FindIndentBlock(&bpIndentBlock) );
    if (hr == S_FALSE)
        return S_FALSE;
        
    if (bpIndentBlock.GetType() == NT_ListItem)
    {
	if (!fBlockQuoteOnly)
	    return OutdentListItem(&bpIndentBlock);

	return S_FALSE; // not blockquote
    }

    Assert(bpIndentBlock.GetType() == NT_Block);
    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );    
    IFR( bpIndentBlock.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
    if (bpIndentBlock.IsEqual(pBlock) == S_OK)
    {
        //
        // The indent element is entirely contained with the command segment, so just morph
        // to default block and flatten
        //
        IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );    
        IFR( bpIndentBlock.Morph(&bpIndentBlock, tagId) );
        IFR( bpIndentBlock.FlattenNode() );
        IFR( pBlock->MoveTo(spRight, LEFT) );
    }
    else
    {
        //
        // The indent element is partially in the range, so float the block up past the ident 
        // element
        //

        fDone = FALSE;
        do
        {
            IFR( bpParent.MoveTo(pBlock) );
            IFR( bpParent.MoveToParent() );
            Assert( hr != S_FALSE );
            Assert( bpParent.GetType() == NT_Block );

            fDone = (bpParent.IsEqual(&bpIndentBlock) == S_OK);
    
            IFR( pBlock->FloatUp(pBlock, TRUE) );
        } 
        while (!fDone);
    }        
    
    return S_OK;    
}

HRESULT 
COutdentCommand::OutdentListItem(CBlockPointer *pBlock)
{
    HRESULT         hr;
    CBlockPointer   bpListContainer(GetEditor());
    CBlockPointer   bpListContainerContainer(GetEditor());

    Assert(pBlock->GetType() == NT_ListItem);

    IFR( bpListContainer.MoveTo(pBlock) );
    IFR( bpListContainer.MoveToParent() );

    IFR( bpListContainerContainer.MoveTo(&bpListContainer) );
    IFR( bpListContainerContainer.MoveToParent() );

    if (bpListContainer.GetType() != NT_ListContainer)
    {
        // Stranded LI - so just leave it alone
        return S_FALSE;
    }        
    else if (bpListContainerContainer.GetType() != NT_ListContainer && 
             bpListContainerContainer.GetType() != NT_ListItem && 
             _cmdId == IDM_UI_OUTDENT)
    {
        return S_FALSE;
    }
    else
    {
        // if the container's container is a listitem, we need to float up
        // the container, then the original listitem. See bug 82995.
        
        if (bpListContainerContainer.GetType() == NT_ListItem)
        {
            IFR( bpListContainer.FloatUp(&bpListContainer, FALSE) );        
        }
        
        // It is safe to outdent the list item
        IFR( pBlock->FloatUp(pBlock, TRUE) );        
    }
    
    return S_OK;    
}

//+---------------------------------------------------------------------------
//
//  CIndentCommand Class
//
//----------------------------------------------------------------------------
HRESULT
CIndentCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut)
{
    HRESULT          hr;
    IMarkupPointer   *pStart = NULL;
    IMarkupPointer   *pEnd = NULL;
    CSegmentListIter iter;
    SP_ISegmentList  spSegmentList;
    CEdUndoHelper    undoUnit(GetEditor());
    SP_IDisplayPointer spCaretMarker;

    IFR( CommonPrivateExec(nCmdexecopt, pvarargIn, pvarargOut) );
    if (hr != S_FALSE)
        RRETURN(hr);

    IFR( GetSegmentList(&spSegmentList) );
    IFR( iter.Init(GetEditor(), spSegmentList) );
    IFR( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );
    for (;;)
    {
        IFR( iter.Next(&pStart, &pEnd) );
        if (hr == S_FALSE)
            return S_OK; // done

        IFR( AdjustSegment(pStart, pEnd) );

        // NOTE: CreateCaretMarker fails when there is no caret.  This is
        // a common case when executing commands through the range

        IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
        IFR( ApplyBlockCommand(pStart, pEnd) );    
        IGNORE_HR( RestoreCaret(spCaretMarker) );
    }

    RRETURN(hr);
}

HRESULT 
CIndentCommand::PrivateQueryStatus(OLECMD * pCmd, OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;

Cleanup:
    return hr;
}

HRESULT 
CIndentCommand::ApplyBlockCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement, spListItem, spNewContainer;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpCurrentStart(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpTest(GetEditor());
    SP_IMarkupPointer   spRight;
    ELEMENT_TAG_ID      tagId, tagIdDefault;
    BOOL                fLEQ, fOneBlock;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )    
    IFR( GetEditor()->CreateMarkupPointer(&spRight) );
    IFR( spRight->SetGravity(POINTER_GRAVITY_Right) );
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );    
    IFR( spLimit->SetGravity(POINTER_GRAVITY_Right) );
    
    // Start with first indent item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Now, do the fuzzy adjust out to get all directly enclosed scopes
    IFR( spLimit->MoveToPointer(pEnd) );    
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
        
    // 
    // Indent
    //        
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( ForceScope(&bpCurrent) );
            // fall through
            
        case NT_ListContainer:
            if (bpCurrent.GetType() == NT_ListContainer)
            {
                CBlockPointer bpCurrentParent(GetEditor());

                // If the parent is a list container, just insert a list
                // container of the same kind to increase the indent level

                IFR( bpCurrentParent.MoveTo(&bpCurrent) );
                IFR( bpCurrentParent.MoveToParent() );
                if (bpCurrentParent.GetType() == NT_ListContainer)
                {
                    IFR( bpCurrentParent.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                    IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                    break;
                }
            }
            // Otherwise, fall through
            
        case NT_Block:
        case NT_BlockLayout:             
            fOneBlock = TRUE;
            IFR( bpCurrentStart.MoveTo(&bpCurrent) )
            IFR( bpTest.MoveTo(&bpCurrent) );
            do
            {                
                IFR( bpTest.MoveToSibling(RIGHT) );
                if (hr == S_FALSE)
                    break;

                IFR( bpTest.MovePointerTo(spRight, ELEM_ADJ_BeforeEnd) );
                IFR( spRight->IsLeftOfOrEqualTo(spLimit, &fLEQ) );
                if (fLEQ)
                {
                    fOneBlock = FALSE;
                    IFR( bpCurrent.MoveTo(&bpTest) );
                }
            }
            while (fLEQ);

            if (fOneBlock && bpCurrent.GetType() == NT_ListContainer)
            {
                // Only the list was selected, so indent the list items
                IFR( bpCurrent.MoveToFirstChild() );
                continue;
            }

            // To indent first block in list item, create another list
            if (bpCurrent.GetType() == NT_Block)
            {
                IFR( bpParent.MoveTo(&bpCurrent) );
                IFR( bpParent.MoveToSibling(LEFT) );
                if (hr == S_FALSE)
                {                
                    IFR( bpParent.MoveToParent() );
                    if (hr == S_OK && bpParent.GetType() == NT_ListItem)
                    {
                        ELEMENT_TAG_ID tagIdListItem;
                        ELEMENT_TAG_ID tagIdListContainer = TAGID_UL;

                        IFR( bpParent.GetElement(&spElement) );
                        IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdListItem) );                        


                        IFR( bpParent.MoveToParent() );
                        if (hr == S_OK && bpParent.GetType() == NT_ListContainer)
                        {
                            IFR( bpParent.GetElement(&spElement) );
                            IFR( GetMarkupServices()->GetElementTagId(spElement, &tagIdListContainer) );                        
                        }

                        IFR( bpCurrent.Morph(&bpCurrent, tagIdListItem, tagIdListContainer) );
                        
                        IFR( bpParent.MoveTo(&bpCurrent) );
                        IFR( bpParent.MoveToParent() );

                        if (bpParent.GetType() == NT_ListContainer)
                            IFR( bpParent.FloatUp(&bpParent, FALSE) );
                        break;
                    }
                }
            }

            // Indent using blockquote
            IFR( CreateBlockquote(&bpCurrent, &spElement) );
            
            // Insert the blockquote
            IFR( bpCurrentStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
            IFR( bpCurrent.MoveTo(spElement) );

            // Try blockquote merging
            IFR( bpCurrent.MovePointerTo(spRight, ELEM_ADJ_AfterEnd) );
            IFR( MergeBlockquotes(&bpCurrent) );
            IFR( bpCurrent.MoveTo(spRight, LEFT) );
            break;
            
        case NT_ListItem:
            IFR( bpParent.MoveTo(&bpCurrent) );
            IFR( bpParent.MoveToParent() );
            if (bpParent.GetType() == NT_ListContainer)
            {
                IFR( bpParent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
            }
            else
            {
                // Stranded LI, so just add a list container
                IFR( bpCurrent.GetElement(&spElement) );
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                
                // Decide on a list container, and morph to get block tree validation code
                if (tagId == TAGID_DD || tagId == TAGID_DT)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, tagId, TAGID_DL) );
                }
                else if (tagId == TAGID_LI)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, tagId, TAGID_UL) );
                }
                else
                {
                    AssertSz(0, "Unexpected list item type");
                }
            }
            break;
            
        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;
    
}

HRESULT 
CIndentCommand::MergeBlockquotes(CBlockPointer *pbpBlock)
{
    HRESULT hr;

    IFR( MergeBlockquotesHelper(pbpBlock, LEFT) );
    IFR( MergeBlockquotesHelper(pbpBlock, RIGHT) );

    return S_OK;
}

HRESULT 
CIndentCommand::MergeBlockquotesHelper(CBlockPointer *pbpBlock, Direction dir)
{
    HRESULT               hr;
    CBlockPointer         &bpStart= *pbpBlock;
    CBlockPointer         bpCurrent(GetEditor());
    SP_IHTMLElement       spElement;
    SP_IHTMLElement       spElementStart;
    ELEMENT_TAG_ID        tagId;
    SP_IHTMLComputedStyle spStyleStart, spStyleCurrent;
    VARIANT_BOOL          fEqual;
  
    Assert(bpStart.GetType() == NT_Block);
    
#if DBG==1
    ELEMENT_TAG_ID  tagIdDebug;
    SP_IHTMLElement spElementDebug;

    Assert(S_OK == bpStart.GetElement(&spElementDebug) );
    Assert(S_OK == GetMarkupServices()->GetElementTagId(spElementDebug, &tagIdDebug) );
    Assert(tagIdDebug == TAGID_BLOCKQUOTE);
#endif

    //
    // Find the other element
    //
    
    IFR( bpCurrent.MoveTo(&bpStart) );
    IFR( bpCurrent.MoveToSibling(dir) );
    if (hr == S_FALSE || bpCurrent.GetType() != NT_Block)
        return S_FALSE; // can't merge 

    //
    // Check that both elements are of the same type
    //    

    IFR( bpCurrent.GetElement(&spElement) );
    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
    if (tagId != TAGID_BLOCKQUOTE)
        return S_FALSE;

    //
    // Don't merge if our computed styles don't match
    //
    IFR( bpStart.GetElement(&spElementStart) );

    IFR( GetEditor()->GetComputedStyle(spElement, &spStyleCurrent) );
    IFR( GetEditor()->GetComputedStyle(spElementStart, &spStyleStart) );

    IFR( spStyleStart->IsEqual(spStyleCurrent, &fEqual) );

    if (!fEqual)
        return S_FALSE;
            
    // 
    // Do actual merge
    //

    IFR( CreateBlockquote(&bpStart, &spElement) );
    IFR( CopyAttributes(spElementStart, spElement, TRUE) );

    if (dir == LEFT)        
        IFR( bpCurrent.InsertAbove(spElement, &bpStart, TAGID_NULL, this) )
    else
        IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
    
    IFR( bpStart.GetElement(&spElement) );
    IFR( bpStart.MoveToParent() );
    IFR( GetMarkupServices()->RemoveElement(spElement) );
    
    IFR( bpCurrent.GetElement(&spElement) );    
    IFR( GetMarkupServices()->RemoveElement(spElement) ); 

    return S_OK;
}

HRESULT 
CIndentCommand::CreateBlockquote(CBlockPointer *pbpContext, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLElement2        spNewElem2;
    SP_IHTMLDocument3       spDoc3;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLCurrentStyle    spCurrentStyle;
    CBlockPointer           &bpContext = *pbpContext;
    BSTR                    bstrDir = NULL;

    IFR( GetMarkupServices()->CreateElement(TAGID_BLOCKQUOTE, NULL, ppElement) );
    Assert(*ppElement);
    
    if (bpContext.GetType() == NT_Block)
    {
        IFC( bpContext.GetElement(&spElement) );
        IFC( (*ppElement)->get_style(&spStyle) );
        // get new element's element2 interface for applying direction
        IFC( (*ppElement)->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spNewElem2) );
        
        //
        // Use RTL info to determine margin
        //
        IFC( spElement->QueryInterface(IID_IHTMLElement2,(LPVOID*)&spElement2) );
        IFC( spElement2->get_currentStyle(&spCurrentStyle) );
        IFC( spCurrentStyle->get_direction(&bstrDir) );

        // first choice is default
        if(!bstrDir)
        {
            IFC( GetDoc()->QueryInterface(IID_IHTMLDocument3, (LPVOID *)&spDoc3) );
            IFC( spDoc3->get_dir(&bstrDir) );
            
            if(!StrCmpIW(bstrDir, L"rtl"))
            {
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
                }
                
                IFC( spNewElem2->put_dir(bstrDir) );
            }
            else
            {
                if (GetEditor()->GetCssEditingLevel())
                {
                    IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
                }
                
                IFC( spNewElem2->put_dir(bstrDir) );
            }

        }
        else if(!StrCmpIW(bstrDir, L"rtl"))
        {
            if (GetEditor()->GetCssEditingLevel())
            {
                IFC( spStyle->put_marginLeft(CVariant(VT_I4)) );
            }
            IFC( spNewElem2->put_dir(bstrDir) );
        }
        else
        {
            if (GetEditor()->GetCssEditingLevel())
            {
                IFC( spStyle->put_marginRight(CVariant(VT_I4)) );
            }                
            IFC( spNewElem2->put_dir(bstrDir) );
        }            
    }

Cleanup:
    if (bstrDir)
        SysFreeString(bstrDir);
        
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  CAlignCommand
//
//----------------------------------------------------------------------------

HRESULT 
CAlignCommand::SetElementAlignment(IHTMLElement *pElement, BSTR szAlign /* = NULL */ , BOOL fUseDefaultAlign /*=TRUE*/)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BOOL            fLayout;

    if (szAlign == NULL && fUseDefaultAlign)
        szAlign = _szAlign; // default alignment is that for the current command

    //
    // If an element has layout, setting the alignment will align the contents rather than
    // the element itself.  However, we want to align the element.  So, fail the call with 
    // S_FALSE.
    //

    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    IFR(IsBlockOrLayoutOrScrollable(pElement, NULL, &fLayout));
    if (fLayout && tagId != TAGID_TABLE)
        return S_FALSE;

    //
    // Set the alignemnt
    //
    switch (tagId)
    {
    case TAGID_CAPTION:
        hr = THR(CAlignment<IHTMLTableCaption>().Set(IID_IHTMLTableCaption, pElement, szAlign));
        break;

    case TAGID_TABLE:
        hr = THR(CAlignment<IHTMLTable>().Set(IID_IHTMLTable, pElement, szAlign));
        break;

    case TAGID_DIV:
        hr = THR(CAlignment<IHTMLDivElement>().Set(IID_IHTMLDivElement, pElement, szAlign));
        break;

    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        hr = THR(CAlignment<IHTMLHeaderElement>().Set(IID_IHTMLHeaderElement, pElement, szAlign));
        break;

    case TAGID_P:
        hr = THR(CAlignment<IHTMLParaElement>().Set(IID_IHTMLParaElement, pElement, szAlign));
        break;

    case TAGID_CENTER:
        if (_cmdId == IDM_JUSTIFYCENTER)
            hr = S_OK;
        else
            hr = S_FALSE;
        break;

    default:
        // not supported
        hr = S_FALSE;
        break;
    };

    RRETURN1(hr, S_FALSE);
}

BOOL 
CAlignCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    Assert(spSegmentList != NULL);
    
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount) );

    bResult = (iSegmentCount >= 1);

Cleanup:
    return bResult;
}
       
HRESULT    
CAlignCommand::GetElementAlignment(IHTMLElement *pElement, BSTR *pszAlign)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    *pszAlign = NULL;
    
    IFR( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

    switch (tagId)
    {
    case TAGID_CAPTION:
        IFR( CAlignment<IHTMLTableCaption>().Get(IID_IHTMLTableCaption, pElement, pszAlign) );
        break;

    case TAGID_DIV:
        IFR( CAlignment<IHTMLDivElement>().Get(IID_IHTMLDivElement, pElement, pszAlign) );
        break;

    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        IFR( CAlignment<IHTMLHeaderElement>().Get(IID_IHTMLHeaderElement, pElement, pszAlign) );
        break;

    case TAGID_P:
        IFR( CAlignment<IHTMLParaElement>().Get(IID_IHTMLParaElement, pElement, pszAlign) );
        break;

    case TAGID_CENTER:
        *pszAlign = SysAllocString(_T("center"));
        hr = S_OK;
        break;

	case TAGID_TABLE:
        IFR( CAlignment<IHTMLTable>().Get(IID_IHTMLTable, pElement, pszAlign) );
        break;

    default:
        // not supported
        hr = S_FALSE;
    };

    RRETURN1(hr, S_FALSE);
}
    
HRESULT 
CAlignCommand::FindAlignment( 
    IHTMLElement     *pElement, 
    BSTR             *pszAlign,
    BOOL              fMoveToParent /*=TRUE*/)
{
    HRESULT             hr = S_OK;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    
    *pszAlign = NULL;

    //
    // Get ready to walk up the tree looking for the alignment.
    //
    // Note that if the element is a layout, we want the alignment
    // applied above, not the alignment of the contents of the layout.
    // So, if layout, start at parent. (NOTE: (krisma) we don't want to
    // do this if the calling f'n has already moved to the parent of
    // what it wants the alignment of.)
    //
    IFR( bpCurrent.MoveTo(pElement) );

	if (bpCurrent.GetType() == NT_BlockLayout && fMoveToParent)
        IFR( bpCurrent.MoveToParent() );
        
    //
    // Walk up the tree looking for the alignment
    //

    while (hr == S_OK)
    {
        IFR( bpCurrent.GetElement(&spElement) );
        IFR( GetElementAlignment(spElement, pszAlign) );
        if (hr == S_OK)
            return S_OK; // done

        //
        // Stop at layout or container boundaries
        //
        switch (bpCurrent.GetType())
        {
            case NT_BlockLayout:
            case NT_Container:
                return S_FALSE;
        }
            
        IFR( bpCurrent.MoveToParent() );
    }

    return S_FALSE;
}

HRESULT
CAlignCommand::PrivateQueryStatus( OLECMD * pCmd,
                            OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK; 
    BSTR                szAlign = NULL;
    SP_ISegmentList     spSegmentList;
    SP_IMarkupPointer   spStart, spEnd;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    BOOL                fMovedToParent = FALSE;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED; 
        goto Cleanup;
    }
#endif 

    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE)
        goto Cleanup;

    pCmd->cmdf = MSOCMDSTATE_UP;

    IFC( GetSegmentList(&spSegmentList) );

#if DBG==1    
    //
    // NOTE: iSegmentCount < 1 is handled by CommonQueryStatus above
    //
    BOOL fEmpty;

    Assert( spSegmentList->IsEmpty(&fEmpty) == S_OK );
    Assert( fEmpty == FALSE );
#endif    

    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );

    //
    // Now, use the block tree to cling to a leaf node.  For the text case,
    // we know the node can not have alignment, so move to the parent.
    //
    // However, don't cross layout boundaries
    //

    IFC( bpCurrent.MoveTo(spStart, RIGHT) );
    for(;;)
    {
        switch (bpCurrent.GetType())
        {
            case NT_Text:
                IFC( bpCurrent.MoveToParent() ); // move back up to parent to get alignment
                fMovedToParent = TRUE;
                // fall through
                
            case NT_BlockLayout: // can't cross layout
            case NT_FlowLayout:
            case NT_Control:
            case NT_TextBreak:
                goto Done; // stop
        }
        IFC( bpCurrent.MoveToFirstChild() );
        Assert(hr != S_FALSE);
    }
        
Done:
    //
    // Now, walk up to get the alignment
    //

    IFC( bpCurrent.GetElement(&spElement) );
    Assert(spElement != NULL);

    // If we've already moved to our parent, we don't want FindAlignment to 
    // do it again. (bug 81723).
    IFC( FindAlignment(spElement, &szAlign, !fMovedToParent) );

    if (!szAlign)
    {
        if (_cmdId == IDM_JUSTIFYNONE)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
    }
    else
    {
        if (StrCmpIW(szAlign, _szAlign) == 0)
            pCmd->cmdf = MSOCMDSTATE_DOWN;
    }

    hr = S_OK;

Cleanup:
    SysFreeString(szAlign);        
    RRETURN(hr);
}

HRESULT 
CAlignCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{  
    HRESULT                 hr = S_OK;
    OLECMD                  cmd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd) ;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
    SP_IDisplayPointer      spCaretMarker;
    BSTR                    bstrAlignBefore = NULL ;
    
    //
    // Validation of command
    //
    
    IFC( CommonQueryStatus(&cmd, NULL) );
    if (hr != S_FALSE)
    {
        if (cmd.cmdf == MSOCMDSTATE_DISABLED)
            return E_FAIL;        

        RRETURN(hr);
    }

    //
    // Apply command
    //

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->CreateIterator( &spIter ) );
    
    IFC( undoUnit.Begin(IDS_EDUNDOGENERICTEXT) );

    while( spIter->IsDone() == S_FALSE )
    {   
        SP_IHTMLElement         spElement;
    
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( edStart, edEnd ));

        //
        // For site selection, alignment applies only to the selected
        // element.  Otherwise, it applies to the current block boundaries.
        //
        if (eSelectionType == SELECTION_TYPE_Control)
        {
            CBlockPointer       bp(GetEditor());
            SP_IHTMLElement3    spElement3;
            VARIANT_BOOL        fAcceptsHtml;
            ELEMENT_TAG_ID  tagId = TAGID_NULL;
    
            IFC( GetSegmentElement(spSegment, &spElement) );
            Assert(spElement != NULL);

            hr = THR( FindAlignment( spElement, & bstrAlignBefore ));
            if ( hr == S_FALSE || ! bstrAlignBefore )
            {           
                bstrAlignBefore = ::SysAllocString( _T("left"));
            }
           
            if (_cmdId == IDM_JUSTIFYNONE)
                IFR( ApplySiteAlignNone(spElement) )
            else
                IFR( ApplySiteAlignCommand(spElement) );

            THR(GetMarkupServices()->GetElementTagId(spElement, &tagId));
            
            IFC( spElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) );
            IFC( spElement3->get_canHaveHTML(&fAcceptsHtml) );

            if (fAcceptsHtml == VARIANT_TRUE && tagId != TAGID_TABLE)
            {    
                //
                // Insert a div inside the contents of the thing you're setting the alignment on
                // this makes the contents of the site not inherit the alignment you set on the text
                // 
                
                SP_IHTMLElement spInnerDiv;
                SP_IMarkupPointer spStart ;
                SP_IMarkupPointer spEnd;

                IFC( GetEditor()->CreateMarkupPointer( & spStart ));
                IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
                
                IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ));
                IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ));
                
                IFC( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spInnerDiv) );
                IFC( InsertElement( GetMarkupServices(), spInnerDiv , spStart, spEnd ) );
                IFC( SetElementAlignment( spInnerDiv, bstrAlignBefore, FALSE  ));
                //
                // Flatten new div
                //
                IFC( bp.MoveTo(spInnerDiv) );
                IFC( bp.FlattenNode() );            
            }
        }
        else
        {
            IFC( AdjustSegment(edStart, edEnd) );            
            
            // NOTE: CreateCaretMarker fails when there is no caret.  This is
            // a common case when executing commands through the range

            IGNORE_HR( CreateCaretMarker(&spCaretMarker) );        
            IFC( ApplyAlignCommand(edStart, edEnd) );    
            IGNORE_HR( RestoreCaret(spCaretMarker) );
        }

        IFC( spIter->Advance() );
    }
    
Cleanup:    
    ::SysFreeString( bstrAlignBefore );
    return S_OK;
}

HRESULT 
CAlignCommand::ApplySiteAlignNone(IHTMLElement *pElement)
{
    HRESULT             hr;
    CBlockPointer       bpCurrent(GetEditor());
    SP_IHTMLElement     spElement;
    SP_IObjectIdentity  spIdent;

    Assert(pElement);

    //
    // Remove align properties on all parent elements of site selected element
    //
    

    //
    // Only remove alignment if block is an only child
    //

    IFR( bpCurrent.MoveTo(pElement) );
    if (!IsOnlyChild(&bpCurrent))
        return S_OK;

    //
    // At this point, bpCurrent either is pElement or a parent of pElement.    
    // We need to know which one.
    //

    IFR( bpCurrent.GetElement(&spElement) );
    if (spElement == NULL)
        return E_FAIL; // nothing to do

    IFR( pElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
    if (spIdent->IsEqualObject(spElement) == S_OK)
        IFR( bpCurrent.MoveToParent() ); // start at parent

    while (hr == S_OK && bpCurrent.GetType() == NT_Block)
    {
        IFR( bpCurrent.GetElement(&spElement) );
        IFR( SetElementAlignment(spElement) );

        if (!IsOnlyChild(&bpCurrent))
            break;

        IFR( bpCurrent.MoveToParent() );
    }

    return S_OK;
}

HRESULT 
CAlignCommand::ApplySiteAlignCommand(IHTMLElement *pElement)
{
    HRESULT         hr;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  tagIdDefault;
    CBlockPointer   bpParent(GetEditor());

    // 
    // Try to set the alignment on the control.  If this fails, just insert a DIV tag
    // around the control and flatten the parent to remove excess nesting
    //
    IFR( SetElementAlignment(pElement) );
    if (hr == S_FALSE)
    {
        CBlockPointer bpCurrent(GetEditor());
        
        IFR( bpCurrent.MoveTo(pElement) );
        IFR( bpParent.MoveTo(&bpCurrent) );
        IFR( bpParent.MoveToParent() );
        
        if (bpCurrent.IsLeafNode() && bpParent.GetType() != NT_ListItem)
        {
            IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )              
            IFR( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );
        }
        else
        {
            // We don't want to create nested blocks with a P tag, so force
            // a DIV
            IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
        }
        
        IFR( SetElementAlignment(spElement) );
        Assert(hr != S_FALSE);
        IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this, FALSE /* fValidate */) );
    
        //
        // Now flatten parent to reduce nesting
        //
        IFR( bpCurrent.MoveTo(spElement) );
        IFR( bpCurrent.MoveToParent() );
        if (hr == S_OK && bpCurrent.GetType() == NT_Block)
            IFR( bpCurrent.FlattenNode() );
        
    }
    return S_OK;
}

HRESULT 
CAlignCommand::ApplyAlignCommand(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{    
    HRESULT             hr;
    SP_IMarkupPointer   spLimit;
    CBlockPointer       bpCurrent(GetEditor());
    CBlockPointer       bpParent(GetEditor());
    CBlockPointer       bpStart(GetEditor());
    SP_IHTMLElement     spElement;
    ELEMENT_TAG_ID      tagIdDefault;
    ELEMENT_TAG_ID      tagId;
    BOOL                fNeedInsertAbove;

    IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) );
    IFR( GetEditor()->CreateMarkupPointer(&spLimit) );

    // Start with first list item scope
    IFR( bpCurrent.MoveTo(pStart, RIGHT) );
    IFR( ForceScope(&bpCurrent) );

    // Do the fuzzy adjust
    IFR( spLimit->MoveToPointer(pEnd) );
    IFR( FuzzyAdjustOut(&bpCurrent, spLimit) );
    
    // 
    // Apply the alignment command
    //        

    // Just in case the first block is nested, we need to flatten
    if (bpCurrent.GetType() == NT_Block)
        IFR( bpCurrent.FlattenNode() );
        
    do
    {
        switch (bpCurrent.GetType())
        {
        case NT_Control:
        case NT_Text:
        case NT_FlowLayout:
        case NT_TextBreak:

            //
            // Group all text nodes together
            //
            
            IFR( bpStart.MoveTo(&bpCurrent) );            
            IFR( bpCurrent.MoveToLastNodeInBlock() );

            //
            // Now get the block scope
            //

            fNeedInsertAbove = TRUE;
            
            IFR( bpStart.MoveToBlockScope(&bpCurrent) ); 
            if (hr == S_OK)
            {
                if (bpStart.GetType() == NT_Block)
                {
                    IFR( bpStart.GetElement(&spElement) );
                    IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                    
                    fNeedInsertAbove = (tagId == TAGID_BLOCKQUOTE);
                }

                if (fNeedInsertAbove)
                    IFR( bpStart.MoveToFirstChild() ); // restore start pointer                
            }
            
            if (fNeedInsertAbove)
            {
                // No block scope, so just insert one
                IFR( bpParent.MoveTo(&bpStart) );
                IFR( bpParent.MoveToParent() );
                
                if (bpParent.GetType() == NT_ListItem) 
                {
                    // P's in LI's render excess space, so use DIV
                    IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) )
                }
                else
                {
                    IFR( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );                
                }
                    
                IFR( bpStart.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                IFR( bpCurrent.MoveTo(spElement) );
            }
            else
            {
                IFR( bpCurrent.MoveTo(&bpStart) );
            }
            continue;

        case NT_Block:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( SetElementAlignment(spElement) );
            if (hr == S_FALSE)
            {
                //
                // If the block is a center tag, morph to DIV and try again
                //
                IFR( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
                if (tagId == TAGID_CENTER)
                {
                    IFR( bpCurrent.Morph(&bpCurrent, TAGID_DIV, TAGID_NULL) );
                    IFR( bpCurrent.GetElement(&spElement) );
                    IFR( SetElementAlignment(spElement) );
                    Assert(hr == S_OK);
                }
                else if (tagId == TAGID_BLOCKQUOTE)
                {
                    //
                    // For blockquote, force alignment to get applied on
                    // inside.
                    //
                    IFR( bpCurrent.MoveToFirstChild() );
                    continue;
                }
                else
                {
                    hr = S_FALSE; // can't set alignment
                }
            }
            if (hr == S_FALSE)
            {
                IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
                IFR( SetElementAlignment(spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                Assert(hr == S_OK);
            }

            break;
            
        case NT_BlockLayout:             
            //
            // Need to insert div tag above
            //
            {
                SP_IHTMLElement spCurrentElem;

                IFR( bpCurrent.GetElement(&spCurrentElem) );
                IFR( GetMarkupServices()->GetElementTagId(spCurrentElem, &tagId) );
                if ( tagId == TAGID_TABLE || EdUtil::IsTablePart(tagId) )
                {
                    //
                    // need to clear the block fmt of current element
                    // otherwise it will not be merged when flattening
                    // nodes   In table case, <DIV> will be removed 
                    // when flattening node
                    // #107902
                    //
                    IGNORE_HR( SetElementAlignment(spCurrentElem) );
                }
                
                IFR( GetMarkupServices()->CreateElement(TAGID_DIV, NULL, &spElement) );
                IFR( bpCurrent.InsertAbove(spElement, &bpCurrent, TAGID_NULL, this) );
                IFR( SetElementAlignment(spElement) );
            }
            Assert(hr == S_OK);            
            break;
            
        case NT_ListItem:
            IFR( bpCurrent.GetElement(&spElement) );
            IFR( SetElementAlignment(spElement) );
            if (hr == S_OK)
                    break;
            
            // Otherwise, fall through

        case NT_Container:
        case NT_ListContainer:
            IFR( bpCurrent.MoveToFirstChild() );
            continue;

        default:
            AssertSz(0, "unexpected block type");         
        }

        //
        // Move to next logical block
        //
        IFR( bpCurrent.MoveToNextLogicalBlock(spLimit, TRUE) );        
    } 
    while (hr != S_FALSE);

    return S_OK;   
}

HRESULT 
CBlockCommand::ForceScope(CBlockPointer *pbpBlock)
{
    HRESULT         hr;
    CBlockPointer   bpStart(GetEditor());
    CBlockPointer   bpEnd(GetEditor());
    ELEMENT_TAG_ID  tagId;
    SP_IHTMLElement spElement;
    
    switch (pbpBlock->GetType())
    {
        case NT_Block:
        case NT_ListItem:
        case NT_ListContainer:
        case NT_Container:
        case NT_BlockLayout:
            break; // done

        case NT_Text:
        case NT_Control:
        case NT_FlowLayout:
        case NT_TextBreak:
            IFR( bpStart.MoveTo(pbpBlock) );
            IFR( bpStart.MoveToFirstNodeInBlock() );
            
            IFR( bpEnd.MoveTo(pbpBlock) );
            IFR( bpEnd.MoveToLastNodeInBlock() );

            IFR( bpStart.MoveToBlockScope(&bpEnd) );
            if (hr == S_OK)
            {
                IFR( pbpBlock->MoveTo(&bpStart) );
            }
            else
            {
                IFR( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) )    
                IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
                IFR( bpStart.InsertAbove(spElement, &bpEnd, TAGID_NULL, this) );
                IFR( pbpBlock->MoveTo(spElement) );
            }
            break;

        default:
            AssertSz(0, "unexpected block type");
    }

    return S_OK;
}

HRESULT 
CBlockCommand::FuzzyAdjustOut(CBlockPointer *pbpStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    DWORD               dwSearch = BREAK_CONDITION_BLOCKPOINTER;
    DWORD               dwFound;
    CBlockPointer       &bpStart = *pbpStart;
    CBlockPointer       bpTest(GetEditor());
    CBlockPointer       bpEnd(GetEditor());
    SP_IMarkupPointer   spEnd;
    BOOL                bRightOf;
    CEditPointer        epLimit(GetEditor(), pEnd);


    IFR( bpEnd.MoveTo(epLimit, LEFT) );
    
    //
    // Skip past any text/control nodes
    //
    
    if (bpEnd.IsLeafNode() || bpEnd.GetType() == NT_FlowLayout)
    {
        IFR( bpTest.MoveTo(&bpEnd) );
        for (;;)
        {
            IFR( bpTest.MoveToSibling(RIGHT) );
            if (hr == S_FALSE || (!bpTest.IsLeafNode() && bpTest.GetType() != NT_FlowLayout))
                break;

            IFR( bpEnd.MoveTo(&bpTest) );
        }
    }
    IFR( bpEnd.MovePointerTo(epLimit, ELEM_ADJ_AfterEnd) );

    //
    // Skip past exit block scopes to get right boundary
    //
    
    for (;;)
    {
        IFR( epLimit.Scan(RIGHT, dwSearch, &dwFound) );
        if (!epLimit.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock)
            || epLimit.CheckFlag(dwFound, BREAK_CONDITION_Site))
        {
            IFR( epLimit.Scan(LEFT, dwSearch, &dwFound) );
            break;
        }
    }    
    
    //
    // Now, we want to position bpStart on the outermost block that is completely contained
    //    

    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFR( bpStart.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
    IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
    if (bRightOf)
    {
        //
        // We are already outside the limit, so go down the tree        
        //
        for (;;)
        {
            IFR( bpStart.MoveToFirstChild() );
            if (hr == S_FALSE || bpStart.IsLeafNode() || bpStart.GetType() == NT_FlowLayout)
            {
                IFR( ForceScope(&bpStart) );
                return S_OK; // done, block is in range
            }

            IFR( bpStart.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
            IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
            if (!bRightOf)
                return S_OK; // done, block is in range
        }
        
    }
    else
    {       
        //
        // We are inside the limit, so go up the tree starting at a forced block scope
        //
        
        IFR( ForceScope(&bpStart) );

        IFR( bpTest.MoveTo(&bpStart) );
        for (;;)
        {
            IFR( bpTest.MoveToSibling(LEFT) );
            if (hr != S_FALSE)
                return S_OK; // it has left siblings, so we can't go up the tree                

            IFR( bpTest.MoveToParent() );
            if (hr == S_FALSE || bpTest.GetType() == NT_Container || bpTest.GetType() == NT_BlockLayout)
                return S_OK; // can't do anything here
            
            IFR( bpTest.MovePointerTo(spEnd, ELEM_ADJ_AfterEnd) );    
            IFR( spEnd->IsRightOf(epLimit, &bRightOf) );
            if (bRightOf)
                return S_OK; // done, parent scope is not contained

            IFR( bpStart.MoveTo(&bpTest) );
            IFR( bpTest.MoveTo(&bpStart) );            
        }
    }
    
    return S_OK;
}

HRESULT
CBlockCommand::CreateCaretMarker(IDisplayPointer **ppDispCaretMarker)
{
    HRESULT                 hr;
    SP_IDisplayPointer      spCaretMarker;
    SP_IHTMLCaret           spCaret;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;

    Assert(ppDispCaretMarker);
    *ppDispCaretMarker = NULL;
    
    //
    // If we have a caret, create a marker with gravity left (opposite to caret). 
    // So, when we are done, we can compare positions and adjust properly
    //

    IFR( GetSegmentList(&spSegmentList) ); 
    IFR( spSegmentList->GetType(&eSelectionType) );
    if (eSelectionType == SELECTION_TYPE_Caret)
    {    
        IFR( GetDisplayServices()->GetCaret(&spCaret) );    
        if (spCaret != NULL)
        {
            IFR( GetDisplayServices()->CreateDisplayPointer(&spCaretMarker) );
            IFR( spCaret->MoveDisplayPointerToCaret(spCaretMarker) );
            IFR( spCaretMarker->SetPointerGravity(POINTER_GRAVITY_Left) );

            *ppDispCaretMarker = spCaretMarker;
            spCaretMarker->AddRef();
        }
    }

    return S_OK;
}

HRESULT 
CBlockCommand::RestoreCaret(IDisplayPointer *pDispCaretMarker)
{
    HRESULT             hr;
    SP_IDisplayPointer  spCaretPos;
    SP_IHTMLCaret       spCaret;
    BOOL                fEqual;

    //
    // If restore position is not the same, then adjust for insert
    //
    IFR( GetDisplayServices()->GetCaret(&spCaret) );    
    if (spCaret != NULL && pDispCaretMarker != NULL)
    {
        IFR( GetDisplayServices()->CreateDisplayPointer(&spCaretPos) );
        IFR( spCaret->MoveDisplayPointerToCaret(spCaretPos) );
        IFR( spCaretPos->IsEqualTo(pDispCaretMarker, &fEqual) );
        
        if (!fEqual)
        {
            if (GetEditor())
            {
                CSelectionManager *pSelMan;
                
                pSelMan = GetEditor()->GetSelectionManager();
                if (pSelMan && pSelMan->GetActiveTracker())
                {
                    IFR( pSelMan->GetActiveTracker()->AdjustPointerForInsert( spCaretPos, LEFT, LEFT, ADJPTROPT_None ));
                    IFR( spCaret->MoveCaretToPointer(spCaretPos, TRUE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE) );
                }
            }
        }
    }
   
    return S_OK;    
}

BOOL 
CBlockCommand::IsOnlyChild(CBlockPointer *pbpCurrent)
{
    HRESULT             hr;
    CBlockPointer       bpTest(GetEditor());

    IFC( bpTest.MoveTo(pbpCurrent) );

    IFC( bpTest.MoveToSibling(LEFT) );
    if (hr != S_FALSE)
        return FALSE;

    IFC( bpTest.MoveToSibling(RIGHT) );
    if (hr != S_FALSE)
        return FALSE;

    // Is only child
    return TRUE;
    
Cleanup:
    return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::~CBlockFormats
//
//  Synopsis:   Clean up our array
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//--------------------------------------------------------------------------
CBlockFormats::~CBlockFormats()
{
    for (int i = _lCount-1; i >= 0; i--)
    {
        VariantClear(&_paryBlockFormats[i]);
    }
    if( _paryBlockFormats )
        delete [] _paryBlockFormats;
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::get__NewEnum
//
//  Synopsis:   Returns an enumerator object which can be used to enumerate
//              over the block formats.  Allows VBScript and JScript
//              clients to enumerate the contents using the for each statement
//              and the Enumerator object respectively.
//
//  Arguments:  ppEnum = OUTPUT - pointer to enumerator object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::get__NewEnum(/*[out, retval]*/ LPUNKNOWN *ppEnum)
{
    HRESULT     hr;

    if(ppEnum == NULL)
      return E_POINTER;
      
    *ppEnum = NULL;

    // Use the STL CComEnum class to implement our enumerator.  We are going 
    // to be enumerating and copying variants
    typedef CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > EnumVar;
    CComObject<EnumVar>  *pEnum;

    // Create our enumerator
    IFC( CComObject<EnumVar>::CreateInstance(&pEnum) );

    // AddRef pEnum so we can release it and free the resources if something goes wrong
    if(pEnum)pEnum->AddRef();
      
    // Initialize the enumerator with this data, AtlFlagCopy is used
    // to make a copy of the data with _Copy<VARIANT>::copy().  Note that
    // the second parameter is a pointer to the next item AFTER the last
    // item in our array.
    IFC( pEnum->Init(&_paryBlockFormats[0], &_paryBlockFormats[GetCount()], NULL, AtlFlagCopy) );

    // An IUnknown pointer is required so use QueryInterface() which also
    // calls AddRef().
    IFC( pEnum->QueryInterface(IID_IUnknown, (void **)ppEnum) );

Cleanup:
    if(pEnum)pEnum->Release();
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::get_Count
//
//  Synopsis:   Returns the number of block formats
//
//  Arguments:  plCount = OUTPUT - pointer to count
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::get_Count(/*[out, retval]*/ long *plCount)
{
    if( plCount == NULL )
        return E_POINTER;

    Assert( IsInitialized() );

    *plCount = GetCount();
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::Item
//
//  Synopsis:   Returns the specific block format requested.  We only support
//              retrieval by integer based index.
//
//  Arguments:  pvarIndex = Index to retrieve
//              pbstrlockFormat = OUTPUT - pointer to BSTR for block format
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::Item(/*[in]*/ VARIANT *pvarIndex, /*[out, retval]*/ BSTR *pbstrBlockFormat)
{
    if( (pbstrBlockFormat == NULL) || (pvarIndex == NULL) )
        return E_POINTER;
        
    Assert( IsInitialized() );

    // VB6 will pass an VT_I2, but I also allow VT_I4 too
    if( (V_VT( pvarIndex ) == VT_I2) || (V_VT(pvarIndex) == VT_I4) )
    {
        int nIndex;

        // VB Arrays are 1 based
        nIndex = (V_VT(pvarIndex) == VT_I2) ? V_I2(pvarIndex) - 1 : V_I4(pvarIndex) - 1;

        // Check that a valid index is passed 
        if( (nIndex >= GetCount()) || (nIndex < 0) )
            return E_INVALIDARG;

        *pbstrBlockFormat = SysAllocString(V_BSTR(&_paryBlockFormats[nIndex]));

        if( *pbstrBlockFormat == NULL )
            return E_OUTOFMEMORY;
    }

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CBlockFormats::Init
//
//  Synopsis:   Initializes the block formats collection.  Takes an
//              array of block formats and creates a collection.
//
//  Arguments:  psa = SAFEARRAY of block formats
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CBlockFormats::Init( SAFEARRAY *psa )
{
    HRESULT hr = S_OK;
    LONG lLBound = 0;
    LONG lUBound = 0;
    LONG lActualIndex = 0;
    LONG lCount, lIndex;
    BSTR  bstrBuf;

    Assert(psa);

    // Get the index bounds of this safe array.
    SafeArrayGetLBound(psa, 1, &lLBound);
    SafeArrayGetUBound(psa, 1, &lUBound);
    lCount = lUBound - lLBound + 1;

    // If array is not empty we'll need to create our internal array
    if (lCount > 0)
    {
        // Create our array and store this data
        _paryBlockFormats = new CComVariant[ lCount ];
        if( !_paryBlockFormats )
            goto Error;

        for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
        {
            if (SafeArrayGetElement(psa, &lIndex, &bstrBuf) == S_OK)
            {
                V_VT(&_paryBlockFormats[lActualIndex]) = VT_BSTR;
                V_BSTR(&_paryBlockFormats[lActualIndex++]) = bstrBuf;
            }
        }
        Assert(lCount == lActualIndex);
    }
    _lCount = lActualIndex;
    
    SetInitialized(TRUE);

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\ctltrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif 

#ifndef _X_TABLE_H_
#define _X_TABLE_H_
#include "table.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif 

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 

#ifndef X_EDUNITS_HXX_
#define X_EDUNITS_HXX_
#include "edunits.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif


MtDefine( CControlTracker, Utilities , "CControlTracker" )

MtDefine( CControlTracker_aryControlElements_pv, Utilities, "CControlTracker Elements" )    
MtDefine( CControlTracker_aryControlAdorners_pv, Utilities, "CControlTracker Adorners" )
MtDefine( CControlTracker_aryRects_pv, Utilities, "CControlTracker Move Rects" )

ExternTag( tagSelectionTrackerState );
DeclareTag(tagDisableMouseClip, "Edit", "DisableMouseClip");
DeclareTag(tagShowMovePosition, "Edit", "ShowMovePositions");

extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);
extern BOOL g_fInVid;

#define SCROLL_SIZE 5 

//
// Control Tracker Action Table.
//

static const CONTROL_ACTION_TABLE ControlActionTable [] = {

    {EVT_LMOUSEDOWN,    
        {   A_ERRCONTROL,                  // CT_START
            A_ERRCONTROL,                  // CT_WAIT1
            A_PASSIVE_DOWN,                // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_ERRCONTROL,                  // CT_RESIZE
            A_ERRCONTROL,                  // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_PENDINGUIACTIVATE_UIACTIVATE,  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION 
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 
            
    {EVT_LMOUSEUP,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE // from first-click + double-click
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_2DMOVE_PASSIVE,              // CT_2DMOVE
            A_PENDINGUP_PENDINGUIACTIVATE, // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_WAITCHANGEPRIMARY             
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 
            
    {EVT_MOUSEMOVE,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_MOVE,                   // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_MOVE,                 // CT_RESIZE
            A_LIVERESIZE_MOVE,             // CT_LIVERESIZE
            A_WAITMOVE_MOVE,               // CT_WAITMOVE
            A_2DMOVE_2DMOVE,               // CT_2DMOVE
            A_PENDINGUP_MOVE,              // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION 
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_WAITCHANGEPRI_DRAGMOVE,      // CT_WAITCHANGEPRIMARY             
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_RMOUSEDOWN,    
        {   A_ERRCONTROL,                  // CT_START
            A_IGNCONTROL,                  // CT_WAIT1
            A_PASSIVE_DOWN,                // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_PENDINGUIACTIVATE_UIACTIVATE, // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION             
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_RMOUSEUP,    
        {   A_ERRCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE // We could have gotten here from an RMOUSE_DOWN during resize.
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP 
            A_ERRCONTROL,                  // CT_UIACTIVATE 
            A_ERRCONTROL,                  // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION            
            A_ERRCONTROL,                  // CT_REDUCESELECTION              
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    {EVT_DBLCLICK,
        {   A_ERRCONTROL,                  // CT_START
            A_ERRCONTROL,                  // CT_WAIT1
            A_PASSIVE_PENDINGUIACTIVATE,   // CT_PASSIVE
            A_ERRCONTROL,                  // CT_DRAGMOVE
            A_ERRCONTROL,                  // CT_RESIZE
            A_ERRCONTROL,                  // CT_LIVERESIZE
            A_ERRCONTROL,                  // CT_WAITMOVE
            A_ERRCONTROL,                  // CT_2DMOVE
            A_ERRCONTROL,                  // CT_PENDINGUP
            A_ERRCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL ,                 // CT_PENDINGUIACTIVATE,            
            A_ERRCONTROL,                  // CT_EXTENDSELECTION                         
            A_ERRCONTROL,                  // CT_REDUCESELECTION              
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_ERRCONTROL,                  // CT_CHANGEPRIMARY            
            A_ERRCONTROL,                  // CT_DORMANT
            A_ERRCONTROL }},               // CT_END 

    //
    // Some OLE controls eat RButtonUp - and generate a Context Menu
    // we treat these as an RMOUSE_UP.
    //
   { EVT_CONTEXTMENU,
        {   A_IGNCONTROL,                  // CT_START
            A_WAIT_PASSIVE,                // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_IGNCONTROL,                  // CT_DRAGMOVE
            A_RESIZE_PASSIVE,              // CT_RESIZE
            A_LIVERESIZE_PASSIVE,          // CT_LIVERESIZE
            A_WAITMOVE_PASSIVE,            // CT_WAITMOVE
            A_IGNCONTROL,                  // CT_2DMOVE
            A_IGNCONTROL,                  // CT_PENDINGUP
            A_IGNCONTROL,                  // CT_UIACTIVATE
            A_ERRCONTROL,                  // CT_EXTENDSELECTION                         
            A_ERRCONTROL,                  // CT_REDUCESELECTION                        
            A_ERRCONTROL,                  // CT_WAITCHANGEPRIMARY                        
            A_WAITCHANGEPRI_CHANGEPRI,     // CT_CHANGEPRIMARY                        
            A_IGNCONTROL,                  // CT_DORMANT
            A_IGNCONTROL }} ,              // CT_END 
            
    { EVT_NONE ,
        {   A_IGNCONTROL,                  // CT_START
            A_IGNCONTROL,                  // CT_WAIT1
            A_IGNCONTROL,                  // CT_PASSIVE
            A_IGNCONTROL,                  // CT_DRAGMOVE
            A_IGNCONTROL,                  // CT_RESIZE
            A_IGNCONTROL,                  // CT_LIVERESIZE
            A_IGNCONTROL,                  // CT_WAITMOVE
            A_IGNCONTROL,                  // CT_2DMOVE
            A_IGNCONTROL,                  // CT_PENDINGUP
            A_IGNCONTROL,                  // CT_UIACTIVATE
            A_IGNCONTROL,                  // CT_EXTENDSELECTION                         
            A_IGNCONTROL,                  // CT_REDUCESELECTION                        
            A_IGNCONTROL,                  // CT_WAITCHANGEPRIMARY                                    
            A_IGNCONTROL,                  // CT_CHANGEPRIMARY                        
            A_IGNCONTROL,                  // CT_DORMANT
            A_IGNCONTROL }}                // CT_END 

};

using namespace EdUtil;

//
//
// Constructors & Initialization
//
//
                
CControlTracker::CControlTracker( CSelectionManager* pManager )
      : CEditTracker( pManager )
{
    _pUndoUnit = NULL;
    _pPrimary = NULL;
    _pDispLastClick = NULL;
    _pFirstEvent = NULL;
    _pNextEvent = NULL;
    Init();
}

VOID
CControlTracker::Init()
{
    _fActiveControl = FALSE; 
    _startMouseX = - 1;                   
    _startMouseY = - 1;
    _startLastMoveX = -1;
    _startLastMoveY = -1;
    _eType = TRACKER_TYPE_Control;
    _state = CT_DORMANT;
    _pFirstEvent = NULL;
    _pNextEvent  = NULL;
    _elemHandle  = ELEMENT_CORNER_NONE ; 

    Assert( ! _pUndoUnit );
}

HRESULT
CControlTracker::Init2( 
        IDisplayPointer*   pDispStart, 
        IDisplayPointer*   pDispEnd, 
        DWORD              dwTCFlags,
        CARET_MOVE_UNIT    inLastCaretMove )
{
    HRESULT         hr  = S_OK;
    CSpringLoader * psl = GetSpringLoader();

    IGNORE_HR( _pManager->AttachFocusHandler());

    // Reset the spring loader
    if (psl)
        psl->Reset();

    IFC( Position( pDispStart, pDispEnd ) );
    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( _pManager->RequestRemoveAdorner( GetControlElement() ));

    SetState( CT_PASSIVE );        

    _pManager->HideCaret();

Cleanup:    
    if ( FAILED( hr ))
    {
        _pManager->EnsureDefaultTrackerPassive( );
    }
    _startMouseX = 0; // Don't set to -1 - as we've been created via OM.
    _startMouseY = 0;

    return hr;
}

HRESULT
CControlTracker::Init2( 
            CEditEvent*  pEvent, 
            DWORD        dwTCFlags, 
            IHTMLElement* pIElement /*= NULL*/)
{
    HRESULT         hr            = S_OK;
    SP_IHTMLElement spElement    ;
    ELEMENT_TAG_ID  eTag          = TAGID_NULL;
    CSpringLoader   *psl          = GetSpringLoader();
    BOOL            fGoActive     = dwTCFlags & TRACKER_CREATE_GOACTIVE;
    BOOL            fActiveOnMove = dwTCFlags & TRACKER_CREATE_ACTIVEONMOVE;
    SP_IHTMLElement spElementSelect;
    HOW_SELECTED    eHow;

    IGNORE_HR( _pManager->AttachFocusHandler());
    
    // IE6-#24607 (mharper) If the control tracker is being initialized
    // as a result of a click, then it should be CT_PASSIVE, otherwise
    // mousemoves on the page will cause the tracker to transition to 
    // CT_2DMOVE.  

    if ( pEvent && (pEvent->GetType() == EVT_CLICK) )
    {
        SetState( CT_PASSIVE );
    }
    else
    {
        SetState( CT_WAIT1 );
    }

     // Reset the spring loader
    if (psl)
        psl->Reset();

    if ( ! pIElement )
    {
        IFC( pEvent->GetElementAndTagId( & spElement, &eTag ));
    }
    else
    {
        spElement = pIElement;
    }

    Assert( IsParentEditable( GetMarkupServices(), spElement) == S_OK );
    IGNORE_HR( IsElementSiteSelectable( eTag, spElement, &eHow, &spElementSelect ));       
    if( eHow == HS_NONE )
    {
        AssertSz(0,"Element is not site selectable");
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!FireOnControlSelect(spElementSelect ) ||
        _pManager->GetActiveTracker() != this)
    {
        _pManager->EnsureDefaultTrackerPassive();
        goto Cleanup;
    }
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Control, (ISelectionServicesListener*) _pManager ) );    
    IFC( AddControlElement( spElementSelect ));

#if DBG == 1
    VerifyOkToStartControlTracker( pEvent);
#endif

    POINT pt;
    IFC( pEvent->GetPoint( & pt ));

    _startMouseX = pt.x;
    _startMouseY = pt.y;            
    _pManager->HideCaret();
    IFC( _pManager->RequestRemoveAdorner( GetControlElement() ));
    
    if ( fActiveOnMove )
    {
        IFC(DoDrag());

        //
        // If the drag fails, then we are still going to be the active tracker, so in reality, the Init
        // worked fine.  Just ignore this error and bubble S_OK
        //
        if( hr == S_FALSE )
            hr = S_OK;
    }

    if ( fGoActive  && !fActiveOnMove )
    {
        _aryGrabAdorners[0]->SetNotifyManagerOnPositionSet( TRUE );
    }

    
Cleanup:
    return hr;
}

HRESULT 
CControlTracker::Init2( 
        ISegmentList*   pSegmentList, 
        DWORD           dwTCFlags ,
        CARET_MOVE_UNIT inLastCaretMove  ) 
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement ;
    ELEMENT_TAG_ID eTag;
    SELECTION_TYPE eType = SELECTION_TYPE_None;
 //   WHEN_DBG( MARKUP_CONTEXT_TYPE eContext );
    HOW_SELECTED eHow;
    ED_PTR( edTempStart );
    ED_PTR( edTempEnd );    
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    SP_IElementSegment spElemSegment;
    SP_IDisplayPointer spDispStart, spDispEnd;
    int  nPrimaryIndex = -1 ;
    BOOL fIsPrimary = FALSE;

    IFC( pSegmentList->GetType(  &eType ));

    Assert( eType == SELECTION_TYPE_Control );
    IFC( pSegmentList->CreateIterator( & spIter ));


    IFC( spIter->Current( & spSegment ));
    IFC( spSegment->GetPointers( edTempStart, edTempEnd ));
    
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispStart->MoveToMarkupPointer(edTempStart, NULL) );

    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    hr = THR( spDispEnd->MoveToMarkupPointer(edTempEnd, NULL) );

    //  BUG 14295: We could fail here in MoveToMarkupPointer if the scope of the end
    //  pointer is not in a flow layout.  This was causing us to bail out due to the
    //  error CTL_E_INVALIDLINE returned by MoveToMarkupPointer. However, if spDispEnd
    //  was positioned we won't bail even though it's not in a flow layout.
    
    if (hr == CTL_E_INVALIDLINE)
    {
        BOOL                fPositioned = FALSE;
        
        hr = THR(spDispEnd->IsPositioned(&fPositioned));
        if (hr == S_OK && fPositioned)
        {
            AssertSz(false, "Display pointer was moved somewhere, but not in a flow layout"); 
            hr = S_OK;
        }
        else
        {
            hr = CTL_E_INVALIDLINE;
            goto Cleanup;
        }
    }

    IFC( Init2( spDispStart, 
                spDispEnd, 
                dwTCFlags, 
                inLastCaretMove ));

    if (hr == S_OK && _aryControlElements.Size() > 0)
    {
        hr = spSegment->QueryInterface( IID_IElementSegment, (void**) & spElemSegment ) ;

        if ( hr == S_OK)
        {
            spElemSegment->IsPrimary(&fIsPrimary) ;
            if (fIsPrimary)
            {
                nPrimaryIndex =  0;
            }
        }
    }

    IFC( spIter->Advance());

    while( spIter->IsDone() != S_OK )
    {
        IFC( spIter->Current( & spSegment ));
        IFC( spSegment->GetPointers( edTempStart, edTempEnd ));

        IFC( spSegment->QueryInterface( IID_IElementSegment, (void**) & spElemSegment ));

        IFC( spElemSegment->GetElement( & spElement ));

        AssertSz( ! ( !spElement ), "CControlTracker - expected to find an element");
    
        IFC( GetMarkupServices()->GetElementTagId( spElement , & eTag ));
              
        //
        // Verify that this object CAN be site selected
        //
        IGNORE_HR( IsElementSiteSelectable( eTag, spElement, &eHow ));       
        if( eHow == HS_NONE )
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        if (GetCommandTarget()->IsMultipleSelection())
        {
            if (FireOnControlSelect(spElement) && 
                _pManager->GetActiveTracker() == this)
            {   
                CSelectionChangeCounter selCounter(_pManager);
                selCounter.BeginSelectionChange();
                
                hr = THR( AddControlElement( spElement ));

                selCounter.EndSelectionChange();

                if (hr == S_OK && !fIsPrimary && _aryControlElements.Size() > 0)
                {
                    spElemSegment->IsPrimary(&fIsPrimary) ;
                    if (fIsPrimary)
                    {
                        nPrimaryIndex = _aryControlElements.Size()-1;
                    }
                }
    
            }
        }
        IFC( spIter->Advance());
    }
    
    if (nPrimaryIndex > 0 )
    {
        MakePrimary(nPrimaryIndex);
    }

Cleanup:
    RRETURN( hr );
}

CControlTracker::~CControlTracker()
{
    BecomeDormant( NULL, TRACKER_TYPE_None, FALSE );
}

//
//
// Virtual Methods for all trackers
//
//

//+====================================================================================
//
// Method: BecomeDormant
//
// Synopsis: Transition to a dormant state. For the caret tracker - this involves positioning based
//           on where we got the click.
//
//------------------------------------------------------------------------------------

HRESULT 
CControlTracker::BecomeDormant( CEditEvent      *pEvent , 
                                TRACKER_TYPE    typeNewTracker,
                                BOOL            fTearDownUI /*=TRUE*/)
{
    HRESULT hr = S_OK;

    if ( _pManager->IsInTimer() )
        StopTimer();
        
    if ( fTearDownUI )
    {
        UnSelect();
    }
    Destroy();

    // Set the selection type to none
    if ( GetSelectionServices() && WeOwnSelectionServices() == S_OK )
    {    
         IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_None, NULL ));
    }
    
    SetState( CT_DORMANT);

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Awaken
//
// Synopsis: Transition from dormant to a "live" state.
//
//------------------------------------------------------------------------------------

HRESULT 
CControlTracker::Awaken() 
{
    Assert( IsDormant());
    if ( ! IsDormant() )
    {
        AssertSz(0,"Here we are");
    }
    
    //
    // Setup the selection services correctly
    //
    SetupSelectionServices();

    Init ();

    RRETURN( S_OK );    
}

//+---------------------------------------------------------------------------
//
//  Member: IsActive
//
//  Synopsis: Am I in an "active" state.
//
//----------------------------------------------------------------------------

BOOL
CControlTracker::IsActive()
{
    return( _state != CT_PASSIVE &&
            _state != CT_UIACTIVATE &&  // UI-Activate is like a 'psuedo-dormant' state - you are about to be dormant
            _state != CT_DORMANT );
}

//+====================================================================================
//
// Method: Destroy
//
// Synopsis: Release anything we currently own.
//
//------------------------------------------------------------------------------------

VOID
CControlTracker::Destroy()
{
    CONTROL_ELEMENT **pElem = NULL;
    int             i;

    for( i = NumberOfSelectedItems(), pElem = _aryControlElements;
         i > 0;
         i--, pElem++ )
    {
        (*pElem)->pIElement->Release();
        (*pElem)->pIElementStart->Release();
        delete *pElem;
    }
    
    _aryControlElements.DeleteAll();

   //
   // We don't need to Unselect anything here - if we're being deleted by a doc
   // shut down, the Selection Arrays should already be gone.
   //
   DestroyAllAdorners();
   ClearInterface( & _pPrimary );
   ClearInterface( & _pDispLastClick );
   if ( _pFirstEvent )
   {
        delete _pFirstEvent;
        _pFirstEvent = NULL;
   }
   if ( _pNextEvent )
   {
        delete _pNextEvent;
        _pNextEvent = NULL;
   }   

   IGNORE_HR( _pManager->DetachFocusHandler());

   IGNORE_HR( DeleteMoveRects() );
}

HRESULT
CControlTracker::ShouldStartTracker(
                    CEditEvent* pEvent ,
                    ELEMENT_TAG_ID eTag,
                    IHTMLElement* pIElement,
                    SST_RESULT* peResult)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    SST_RESULT      eResult = SST_NO_CHANGE;
    BOOL            fExtendSelectionAllowed;
    
    Assert( peResult );

    if ( IsPassive() )
    {
        ELEMENT_TAG_ID eControlTag;

        if ( NumberOfSelectedItems() == 1 )
        {
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement(), & eControlTag));

            if ( eControlTag == TAGID_TABLE &&
                 IsMessageOverControl(pEvent) )
            {
                SP_IHTMLElement spElement;
                IFC( GetSiteSelectableElementFromMessage(pEvent, & spElement ));                    
                
                if (IsSelected( spElement ) == S_OK )
                {
                    eResult = SST_NO_BUBBLE; // we dont want to change. But we want to not try to change other trackers
                    goto Cleanup;
                }
                else
                {
                    eResult = SST_CHANGE; // we want to change to siteselect the element in hittest
                    goto Cleanup;
                }
            }
        }    
        
        if ( IsInAdorner(pEvent))
        {
            eResult = SST_NO_BUBBLE; 
            goto Cleanup;
        }
    }

    if ( IsActive() )
    {
        eResult = SST_NO_BUBBLE;
        goto Cleanup;
    }

    //
    // Check to see if the Element we want to site select is already in a selection
    // or this is a shift selection
    // 
    
    if ( 
        //
        // Per NetDocs, ( IE 5 bug #95392) - we now want to site select if
        // something site selectable is in the selection
        // Leave old code here until we're sure we like this behavior.
        // 
        // Bug 3186.  We don't want to always site select if the event occurred
        // in a selection.  We only want to do it if a click occurred in the site
        // selectable element.  Otherwise we'll break drag drop functionality.
        _pManager->IsMessageInSelection( pEvent ) ||
        _pManager->GetTrackerType() == TRACKER_TYPE_Selection && pEvent->IsShiftKeyDown())
    {
        //
        // The element we clicked on is already in a text selection.
        // it cannot be site selected.
        //
        goto Cleanup;
    }
    
    fExtendSelectionAllowed = GetCommandTarget()->IsMultipleSelection() && 
                               NumberOfSelectedItems() > 0 && 
                               ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) ;                                            

    if ( IsElementSiteSelectable( eTag, pIElement, NULL , & spElement, fExtendSelectionAllowed ) &&
         EdUtil::IsMasterParentEditable( GetMarkupServices(), spElement) == S_OK )
    {
        if( IsPassive() && 
            IsSelected( spElement ) == S_OK )
        {
            //
            // you would site select the same element - but you aren't in the adorner
            // this only make sense for the glyph case
            //
            Assert( ! IsInAdorner(pEvent));            
            eResult = SST_NO_BUBBLE;
            goto Cleanup;
        }
        else 
        {
            //
            // If we still want to create a control tracker - ensure that it's not the same
            // as the Editable Element - IF we  are currently UI-Active
            //
            if ( _pManager->IsElementContentSameAsContext( spElement ) == S_OK )
            {
                eResult = _pManager->IsUIActive() ? SST_NO_CHANGE : SST_CHANGE;
            }              
            else if ( GetCommandTarget()->IsMultipleSelection())
            {
                if ( IsPassive()  &&
                     ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ) ) 
                {
                    //
                    // We are hitting shift or control in a multiple selection.
                    // This denotes the start of multiple selection. We return No-Bubble
                    // and handle the extending of selection in HandleAction
                    //
                    eResult = SST_NO_BUBBLE;
                }
                else
                    eResult = SST_CHANGE;
            }
            else
            {
                eResult = SST_CHANGE;
            }                

            //  Bug 104792: Don't change if the user clicked on a control in an atomic element.
            //  Bug 4023: But check the site selectable element to see if it's atomic, not the element
            //  that received the click.
            if (eResult == SST_CHANGE && _pManager->CheckAtomic(spElement) == S_OK)
            {
                eResult = SST_NO_CHANGE;
            }
        }            
    }        

Cleanup:
    *peResult = eResult;
    
    RRETURN( hr );        
}


//+====================================================================================
//
// Method: Position
//
// Synopsis: Given two markup pointers, select the element they adorn.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::Position(
        IDisplayPointer* pDispStart,
        IDisplayPointer* pDispEnd)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElementSelect;
    IHTMLElement       *pIElement = NULL;
    ELEMENT_TAG_ID      eTag = TAGID_NULL;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    SP_IMarkupPointer   spStart;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    
    
    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;    

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    
    //
    // Assumed that if we get here - it's from a control range, and the pointers are around
    // the element we want to select.
    //
    IFC( pDispStart->PositionMarkupPointer(spStart) );
    IFC( spStart->Right( FALSE, & eContext, & pIElement, NULL, NULL ));

    AssertSz( pIElement, "CControlTracker - expected to find an element");
    AssertSz( eContext != CONTEXT_TYPE_Text, "Did not expect to find text");
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement , & eTag ));
        
    //
    // Verify that this object CAN be site selected
    //
    IGNORE_HR( IsElementSiteSelectable( eTag, pIElement, &eHow, &spElementSelect ));       
    if( eHow == HS_NONE )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!FireOnControlSelect(spElementSelect ) ||
        _pManager->GetActiveTracker() != this)
    {
        _pManager->EnsureDefaultTrackerPassive();
        hr = S_FALSE;
        goto Cleanup;
    }           
    IFC( GetSelectionServices()->SetSelectionType(SELECTION_TYPE_Control, (ISelectionServicesListener*) _pManager ) );

    IFC (AddControlElement( spElementSelect ));
    
Cleanup:
    GetEditor()->IgnoreGlyphs( fIgnoreGlyphs );
    
    ReleaseInterface(pIElement);
    RRETURN1( hr, S_FALSE );
}

BOOL
CControlTracker::IsPointerInSelection(
                        IDisplayPointer   *pDispPointer,  
                        POINT             *pptGlobal, 
                        IHTMLElement      *pIElementOver )
{
    //
    // We now do this work - by seeing if the given point is in the adorner 
    //  OR it's the same element we're over ( to handle the glyph case)
    // We do this - as this routine is called to handle mouse overs. At the end of the document
    // hit testing will put the pointers at the edge of the control - making us think the mouse is 
    // inside the site selected object when it really isn't.
    // 

    BOOL fWithin =  IsInAdorner( *pptGlobal ) || 
                    ( IsSelected( pIElementOver, NULL ) == S_OK ) ;
      
    return ( fWithin );
}

//+---------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis: An adorned element is leaving the tree. Up to us to do the right thing here.
//
//----------------------------------------------------------------------------

HRESULT 
CControlTracker::OnExitTree(
            IMarkupPointer* pIStart, 
            IMarkupPointer* pIEnd, 
            IMarkupPointer* pIContentStart,
            IMarkupPointer* pIContentEnd            )
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer spDispCtlTemp;
    int i;
    //
    // An element that contained selection may have left the tree.
    //
    
    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        if ( Between( _aryControlElements[i]->pIElementStart, pIStart, pIEnd )  ||
             Between( _aryControlElements[i]->pIElementStart, pIContentStart, pIContentEnd ) )
        {
            if( _aryGrabAdorners[i]->IsPrimary() && ! _pPrimary )
            {
                //
                // We store what the primary was - so we can move the caret there.
                //
                IFC( GetEditor()->CreateMarkupPointer( & _pPrimary ));
                IFC( _pPrimary->MoveToPointer( _aryControlElements[i]->pIElementStart ));                
            }            
            
            IFC( RemoveItem( i ));
        }
    }

    if( NumberOfSelectedItems() > 0 ) // not the last item
    {
         hr = S_OK;
         goto Cleanup;
    }

    //
    // Create yet another pointer as ours gets released.
    //
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispCtlTemp) );
    IFC( spDispCtlTemp->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    if (_pPrimary)
    {
        IFC( spDispCtlTemp->MoveToMarkupPointer(_pPrimary, NULL) );       
    }
    else
    {
        SP_IHTMLCaret  spCaret;
        
        Verify( S_OK == GetDisplayServices()->GetCaret( &spCaret ) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispCtlTemp));
    }
           
    hr = THR( _pManager->SetCurrentTracker( TRACKER_TYPE_Caret, spDispCtlTemp, spDispCtlTemp ) );
    Assert( IsDormant());
    Assert( ! _pPrimary );
    
Cleanup:
    RRETURN( hr );
} 

//+---------------------------------------------------------------------
//
// Method: OnLayoutChange
//
// Synopsis: our layoutness has changed. Update control selection so only things with layout remain selected.
//
//+---------------------------------------------------------------------

HRESULT 
CControlTracker::OnLayoutChange()
{
    HRESULT hr = S_OK;
    int     i;
    BOOL    fRemoveOccured = FALSE ;

    SP_IMarkupPointer  spPointer;
    SP_IDisplayPointer spDispPointer;
    CSelectionChangeCounter selCounter(_pManager);
    
    IFC( MarkupServices_CreateMarkupPointer( GetMarkupServices(), & spPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPointer ));
    
    IFC( spPointer->MoveAdjacentToElement( 
                                           _aryControlElements[PrimaryAdorner()]->pIElement, 
                                           ELEM_ADJ_BeforeBegin));
    
    IFC( spDispPointer->MoveToMarkupPointer( spPointer, NULL) );        
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    for( i = 0 ; i < _aryControlElements.Size(); i ++ )
    {
        if ( IsLayout( _aryControlElements[i]->pIElement ) == S_FALSE )
        {
            IFC( RemoveControlElement(  _aryControlElements[i]->pIElement));
            if ( !fRemoveOccured)
                fRemoveOccured = TRUE ;
        }
    }

    
    if (fRemoveOccured || NumberOfSelectedItems() == 0 )
    {
        selCounter.BeginSelectionChange();
    }
        
    if ( NumberOfSelectedItems() == 0 )
    {        
        IFC( _pManager->PositionCaret( spDispPointer ));
    }

    if (fRemoveOccured || NumberOfSelectedItems() == 0 )
    {
        selCounter.EndSelectionChange();
    }
    
Cleanup:
    RRETURN( hr );
}

//
//
// Message Handling
//
//

HRESULT
CControlTracker::HandleEvent(
                    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    Assert( pEvent );
    
    if ( _fActiveControl )
        goto Cleanup; // Bail!!
        
    switch( pEvent->GetType())
    {
        case EVT_KEYPRESS:
        {
            hr = HandleChar( pEvent );
        }
        break;

        case EVT_KEYDOWN:
        {
            hr = HandleKeyDown( pEvent ) ; 
        }
        break;

        case EVT_SETFOCUS:
        {
            SetDrawAdorners( TRUE ) ;
            hr = S_OK;
        }
        break;

        case EVT_KILLFOCUS:
        {
            SetDrawAdorners( FALSE );
        }
        // fall thru...
        
        case EVT_LOSECAPTURE:
        {            
            //
            // A focus change/loss of capture has occured. 
            // If we have capture - this is a bad thing.
            // a sample of this is throwing up a dialog from a script.
            //
            IFC( OnLoseFocus());
        }
        break;

        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
        case EVT_MOUSEMOVE:
        case EVT_DBLCLICK:
        case EVT_LMOUSEUP:
        case EVT_RMOUSEUP:
        case EVT_CONTEXTMENU:
        {
            CONTROL_ACTION inAction = GetAction( pEvent );
            
            if ( inAction != A_IGNCONTROL ) // perf & dump sanity 
            {
                  hr = HandleAction( inAction, 
                                     pEvent );     
            }     
            else if ( pEvent->GetType() == EVT_LMOUSEUP )
            {
#if DBG == 1
                DumpTrackerState( pEvent, _state, inAction) ;
#endif                
                //
                // Consume mouse up's.
                //
                hr = S_OK;
            }
#if DBG == 1
            else
            {
                if ( IsTagEnabled( tagSelectionTrackerState ))
                    DumpTrackerState( pEvent, _state, inAction) ;
            }
#endif
        }
        break;
        
        case EVT_IME_STARTCOMPOSITION:
            hr = S_FALSE;
            break;

    }


Cleanup:
    RRETURN1 ( hr , S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member: HandleActivation
//
//  Synopsis: We are either about to become UI Active - or create a caret 
//            (ie we drilled into the control).
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::HandleActivation( 
                   CEditEvent* pEvent,  
                   CONTROL_ACTION inAction)
{                                   
    HRESULT hr = S_FALSE;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    Assert( inAction == A_PENDINGUIACTIVATE_UIACTIVATE );
    
    IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));        
    if ( eTag != TAGID_TABLE )
    {
        SetState( CT_UIACTIVATE );
        hr = S_OK ;                
        IGNORE_HR( BecomeUIActive( pEvent ) );
    }                
    else
    {
        Assert( ! _pFirstEvent && ! _pNextEvent ); // ensure we don't have events cached.
        
        //
        // Only transition to a caret if the last place we clicked on is inside the table.
        // So ignore clicks on the border, between cells etc.
        // 
        
        SP_IMarkupPointer spStart;
        SP_IMarkupPointer spEnd;
        SP_IMarkupPointer spLastClick;
        
        IFC( GetEditor()->CreateMarkupPointer( & spStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        IFC( GetEditor()->CreateMarkupPointer( & spLastClick ));
        
        IFC( spStart->MoveAdjacentToElement( GetControlElement(), ELEM_ADJ_BeforeBegin ));
        IFC( spEnd->MoveAdjacentToElement( GetControlElement(), ELEM_ADJ_AfterEnd));
        IFC( _pDispLastClick->PositionMarkupPointer( spLastClick ));
        
        if ( BetweenExclusive( spLastClick, spStart, spEnd ))
        {
            SP_IHTMLElement     spElement;

            //  Make sure we won't be positioning the caret inside of an atomic
            //  element.  If we would be we need to go and select the atomic element.
            IFC( GetCurrentScope(_pDispLastClick, &spElement) );
            if (_pManager->CheckAtomic(spElement) == S_OK)
            {
                IFC( _pManager->StartAtomicSelectionFromCaret(_pDispLastClick) );
                ClearInterface( & _pDispLastClick );            
            }
            else
            {
                Assert( _pDispLastClick );
                SetState( CT_END );
                IFC( _pManager->PositionCaret( _pDispLastClick ));
                ClearInterface( & _pDispLastClick );            
                // fire the selectionchange event
                {
                    CSelectionChangeCounter selCounter(_pManager);
                    selCounter.SelectionChanged();
                }
            }
        }
        else
        {
            if ( _pManager->IsInTimer() )
            {
                StopTimer();
            }
            
            SetState( CT_PASSIVE );	
        }
    }

Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member: TransitionToPreviousCaret
//
//  Synopsis: We're leaving site selection mode - transition to the previous caret
//            if possible.
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::TransitionToPreviousCaret( )
{
    HRESULT hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        
    if ( _pManager->IsCaretAlreadyWithinContext() )
    {
        SP_IHTMLCaret spCaret;

        IFC( GetDisplayServices()->GetCaret(&spCaret) );
        IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer));

        _pManager->PositionCaret( spDispPointer );
    }
    else
    {
        IFC( spDispPointer->MoveToMarkupPointer(_pManager->GetStartEditContext(), NULL) );        
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        _pManager->PositionCaret( spDispPointer );
    }
    
Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member: HandleAction
//
//  Synopsis: Given an Action - denoting a state transition - transition to the 
//            next state
//
//----------------------------------------------------------------------------

HRESULT
CControlTracker::HandleAction( 
                   CONTROL_ACTION inAction,
                   CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    POINT   pt;

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1
    CONTROL_STATE oldState = _state;
#endif 

    switch( inAction )
    {
        case A_IGNCONTROL:
            break;
            
        case A_ERRCONTROL:
            AssertSz(0,"Unexpected Event for State !");
            break;
            
        case A_START_WAIT:
            AssertSz(0,"Unexpected State Transition");
            break;
            
            
        case A_WAIT_PASSIVE:   
            hr = S_OK;
                            
            SetState( CT_PASSIVE );
            break;
            
        case A_PASSIVE_DOWN:
        {
            //
            // Based on where the mouse down was - we decide how to transition 
            //
            CONTROL_STATE newState;
            
            //
            // on any downclick - store where we started the click from 
            //
            IFC( pEvent->GetPoint( & pt ));
            _startMouseX = pt.x;
            _startMouseY = pt.y;            
           
            //
            //
            // See which state to transition to.  It may return S_FALSE if we
            // get an element which we are not expecting (101917), so we just 
            // return to the passive state, and bubble the event
            //
            IFC( GetStateForPassiveDown( pEvent , & newState ));

            //
            // We need to at least own selection services, and have elements in our array
            // to perform these operations
            //
            if( hr == S_FALSE )
                goto Cleanup;

            Assert( newState == CT_PASSIVE || NumberOfSelectedItems() );
            
            switch( newState )
            {
                case CT_PASSIVE:
                    //
                    // We used to set the caret visibility here ? Still needed ?
                    //
                    if ( pEvent->GetType() == EVT_LMOUSEDOWN )  
                    {   
                        hr = S_OK;
                    }
                    // else 
                    // return S_FALSE for RBUTTONDOWN for context menu 
                    //  
                    break;
                    
                case CT_RESIZE:                
                    if (!FireOnAllElements(FireOnResizeStart))
                    {
                       //
                       //  Start of Resize cancelled. Become passive.
                       //
                       newState = CT_PASSIVE ;
                    }
                    else
                    {
                        hr = THR( BeginResize( pEvent ));
                        if ( hr )
                        {
                          //
                          // Start of Resize failed. Become passive.
                          //
                          newState = CT_PASSIVE ;
                        }
                    }
                    hr = S_OK;
                    break;

                case CT_LIVERESIZE:                
                    if (!FireOnAllElements(FireOnResizeStart))
                    {
                       //
                       // Start of Resize cancelled. Become passive.
                       //
                       newState = CT_PASSIVE ;
                    }
                    else
                    {
                        hr = THR( BeginLiveResize( pEvent ));
                        if ( hr )
                        {
                            //
                            // Start of Live Resize failed. Become passive.
                            //
                            newState = CT_PASSIVE ;
                        }
                    }
                    hr = S_OK;
                    break;

                case CT_WAITMOVE:
                    if (  pEvent->GetType() == EVT_LMOUSEDOWN )  
                    {   
                        hr = S_OK;
                    }
                    // else 
                    // return S_FALSE for RBUTTONDOWN for context menu 
                    // 
                    POINT ptWait;
                    IFC( pEvent->GetPoint( & ptWait ));
                    _startMouseX = ptWait.x;
                    _startMouseY = ptWait.y;                 
                    break;
                    
                case CT_PENDINGUP:
                {
                    Assert( pEvent->GetType() != EVT_RMOUSEDOWN );

                    ELEMENT_TAG_ID eTag = TAGID_NULL;
                    IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));
                    if ( eTag != TAGID_TABLE )
                    {
                        SetDrillIn( TRUE, pEvent );                
                    }                        
                        
                    hr = S_OK;
                 }   
                 break;

                case CT_EXTENDSELECTION:
                {
                    SP_IHTMLElement spElement;
                    IFC( GetSiteSelectableElementFromMessage( 
                                                    pEvent, & spElement ));
                    
                    if (FireOnControlSelect(spElement) && _pManager->GetActiveTracker() == this)
                    {   
                        IFC ( AddControlElement( spElement ));
                        IFC ( MakePrimary(_aryControlElements.Size() - 1 ));

                        // fire the selectionchange event
                        {
                            CSelectionChangeCounter selCounter(_pManager);
                            selCounter.SelectionChanged();
                        }
                    }
                    newState = CT_PASSIVE; // return to passive state after adding the element.
                }
                break;

                case CT_REDUCESELECTION:
                {
                    if ( NumberOfSelectedItems() > 1 )
                    {
                        SP_IHTMLElement spElement;
                        IFC( GetSiteSelectableElementFromMessage( 
                                                        pEvent, & spElement ));
                        IFC( RemoveControlElement( spElement ));

                        // fire the selectionchange event
                        {
                            CSelectionChangeCounter selCounter(_pManager);
                            selCounter.SelectionChanged();
                        }
                        
                        newState = CT_PASSIVE; // return to passive state after adding the element.
                        
                    }
                    else
                    {
                        SP_IHTMLElement spControlElement;
                        
                        spControlElement = GetControlElement();

                        //
                        // about to terminate ourselves. Transition to a caret.
                        //   
                        SetDrillIn( TRUE );
                        IFC( BecomeCurrent( _pManager->GetDoc(), spControlElement));
                        IFC( _pManager->PositionCaret( pEvent ));
                        newState = CT_DORMANT;
                        Assert( IsDormant());
                        
                    }
                }
                break;

                case CT_WAITCHANGEPRIMARY :
                {
                    // nothing to do - just go to this state.
                    break;
                }
                default:
                {
                    AssertSz(0,"Unexpected State");
                }                    
            }

            if ( newState != _state )
                SetState( newState );
        }            
        break;
            
        case A_PENDINGUIACTIVATE_UIACTIVATE:   
        {
#ifdef FORMSMODE
            if (IsAnyElementInFormsMode())
            {   
                break;
            }
#endif
            SetDrillIn( TRUE  );                            
            hr = HandleActivation( pEvent, inAction );
        }
        break;

        case A_RESIZE_MOVE:
        {
            //
            // No state transition - do the work of doing the resize
            //
            DoResize( pEvent );
            hr = S_OK;
        }            
        break;
            
        case A_LIVERESIZE_MOVE:
        {
            //
            // No state transition - do the work of doing the live resize
            //
            DoLiveResize( pEvent );
            hr = S_OK;
        }            
        break;
            
        case A_RESIZE_PASSIVE:
        {
            //
            // Commit the Resize Operation - and transfer to passive
            //
            CommitResize( pEvent );
            if ( pEvent->GetType() == EVT_LMOUSEUP )
                hr = S_OK;
            
            SetState( CT_PASSIVE );
        }            
        break;
        
        case A_LIVERESIZE_PASSIVE:
        {
            //
            // Commit the Live Resize Operation - and transfer to passive
            //

            CommitLiveResize( pEvent );
            if ( pEvent->GetType() == EVT_LMOUSEUP )
                hr = S_OK;
            
            SetState( CT_PASSIVE );
        }            
        break;
        
        case A_WAITMOVE_PASSIVE:
        {
            SetState( CT_PASSIVE);
        }            
        break;

        case A_2DMOVE_PASSIVE:
        {
            End2DMove();
            SetState(CT_PASSIVE);
            hr = S_OK;
        }
        break;

        case A_2DMOVE_2DMOVE :
        {
            if ( pEvent->GetType() == EVT_LMOUSEDOWN )
                hr = S_OK;
        
            Do2DMove( pEvent);
            SetState(CT_2DMOVE);
            hr = S_OK;
        }
        break;

        case A_WAITMOVE_MOVE:
        case A_PENDINGUP_MOVE:
        case A_WAIT_MOVE:
        case A_WAITCHANGEPRI_DRAGMOVE:                   
        {
            IFC( pEvent->GetPoint( & pt ));
            if ( !IsValidMove( & pt) )            
            {
                break;
            }

            if ( _state == CT_PENDINGUP )
            {
                SetDrillIn( FALSE );
            }

            BOOL f2DMove = FALSE;
            if (GetCommandTarget()->Is2DPositioned())
            {
                f2DMove = TRUE;

                //
                // Check if all elements positioned. If so then go into 2DMove Mode.
                //
                for ( int i = 0 ; i < NumberOfSelectedItems(); i ++ )
                {
                    if ( ! IsElementPositioned( GetControlElement(i)))
                    {
                        f2DMove = FALSE;
                        break;
                    }
                }
            }

            if ( f2DMove )
            {
                if (FireOnAllElements(FireOnMoveStart))
                {
                    Assert( ! _pUndoUnit );
                    _pUndoUnit = new CEdUndoHelper (_pManager->GetEditor());
                    if(NULL == _pUndoUnit)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }
                    _pUndoUnit->Begin(IDS_EDUNDOMOVE);

                    if (TakeCapture() != S_OK)
                    {
                        SetState(CT_PASSIVE);
                    }
                    else
                    {
                        SetState(CT_2DMOVE);
                        Begin2DMove(pEvent);
                    }
                }
                else
                {
                    SetState(CT_PASSIVE);
                }
            }
            else
            {
               SetState( CT_DRAGMOVE);
               DoDrag(); 
            }
        }            
        break;

        case A_PASSIVE_PENDINGUIACTIVATE:        
        {
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));

            //
            // Don't UI-Activate if we shouldn't go UI-Active, (and we're not a a table)
            // or the magic event told us not to
            // 
            if( IsInResizeHandle( pEvent )                                                      ||
                IsInMoveArea( pEvent )                                                          ||
                NumberOfSelectedItems() > 1                                                     ||
                ( !ShouldClickInsideGoActive( GetControlElement(0)) && eTag != TAGID_TABLE )    ||
                  !FireOnBeforeEditFocus( eTag != TAGID_TABLE ? 
                                            GetControlElement(0) : 
                                            _pManager->GetEditableElement(),
                                            _pManager->IsContextEditable() ) ||
                   _pManager->GetActiveTracker() != this )                                                                    
            {
                break;
            }
            //
            // else fallthru
            //            
        }
            
        case A_PENDINGUP_PENDINGUIACTIVATE:
        {       
            IFC( MoveLastClickToEvent( pEvent ));
            IFC( StartTimer());
            SetState( CT_PENDINGUIACTIVATE );

            if ( _pFirstEvent )
            {
                StoreNextEvent( DYNCAST( CHTMLEditEvent, pEvent ));
            }                                
        }    
        break;

        case A_PENDINGUP_END:
        {
            AssertSz(0,"Unexpected Transition");
        }    
        break;

        case A_WAITCHANGEPRI_CHANGEPRI:
        {
            SP_IHTMLElement spElement;
            int iSel;                

            IFC( GetSiteSelectableElementFromMessage( pEvent, & spElement ));
            if ( hr == S_FALSE )
            {
                AssertSz(0,"Did not find a site selectable elemnet. Why are you here ?");
                goto Cleanup;
            }    
            
            IFC( IsSelected( spElement, & iSel ));
            if ( hr != S_OK || iSel == -1 )
            {
                AssertSz(0, "Element not selected ");
                hr = E_FAIL;
                SetState( CT_PASSIVE );
                goto Cleanup;
            }
            
            if ( ! _aryGrabAdorners[ iSel ]->IsPrimary())
            {
                IFC( MakePrimary( iSel ));
            }
            
            if (  pEvent->GetType() == EVT_LMOUSEDOWN )  
            {   
                hr = S_OK;
            }

            SetState( CT_PASSIVE ) ;
        }
        break;


        default:
        {
            AssertSz( 0, "Unknown Tracker Transition");
        }            
    }

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif
        DumpTrackerState( pEvent, oldState, inAction) ;
#if DBG == 1
    }
#endif   

#endif

Cleanup:    
    RRETURN1( hr, S_FALSE);
}

HRESULT
CControlTracker::MoveLastClickToEvent( CEditEvent* pEvent )
{
    HRESULT hr;
    ClearInterface( & _pDispLastClick );
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer( & _pDispLastClick ));
    

    IFC( pEvent->MoveDisplayPointerToEvent( _pDispLastClick, GetEditableElement(), TRUE ));

Cleanup:    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member: GetStateForPassiveDown
//
//  Synopsis: A mouse down occurred. Ambiguious as to what next state is
//            We make some tests to see what the next state should be
//
//   If in Resize    - Next State is CT_RESIZE or CT_LIVERESIZE
//   If in Move Area - Next State is CT_DRAGMOVE
//   If inside && allowed to go active && Fire On Edit Focus - Next State is CT_ACTIVATE
//
//      else state is CT_PASSIVE
//
//----------------------------------------------------------------------------


HRESULT
CControlTracker::GetStateForPassiveDown( CEditEvent* pEvent, CONTROL_STATE* pNewState )
{
    CONTROL_STATE   newState = CT_PASSIVE;
    BOOL            fLocked;
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    BOOL fInResizeHandle, fInMoveArea;
    
    Assert( _state == CT_PASSIVE );
    
    if ( ! AllElementsEditable() )
    {
        newState = CT_PASSIVE;
        goto Cleanup;      
    }

    hr = THR( GetSiteSelectableElementFromMessage( pEvent, & spElement)); 

    fInResizeHandle = IsInResizeHandle(pEvent);
    fInMoveArea = IsInMoveArea(pEvent);
    
    //
    // TODO - This is related to bug 101917.  This assert occurs, and we 
    // fail out of the control tracker.  We get back to CT_PASSIVE correctly
    // and resume handling events, so I am removing this assert until we can
    // correctly fix this bug.
    //
    //
    //AssertSz( hr != S_FALSE, "No site selectable element. Why are you here ?");
    if ( hr )
        goto Cleanup;
        
    fLocked = AllElementsUnlocked() ? FALSE : TRUE;    

    if ( GetCommandTarget()->IsMultipleSelection()  &&
         ! fInResizeHandle && 
         ( pEvent->IsShiftKeyDown() || pEvent->IsControlKeyDown() ))
    {         
        if ( IsSelected( spElement, NULL ) == S_OK )
        {
            newState = CT_REDUCESELECTION;                
        }
        else
        {
            newState = CT_EXTENDSELECTION;
        }
    }         
    else if ( ! fLocked && fInResizeHandle )
    {
        newState = GetCommandTarget()->IsLiveResize() ? CT_LIVERESIZE : CT_RESIZE;
    }
    else if ( ! fLocked && fInMoveArea )
    {
        newState = CT_WAITMOVE;
    }
    else
    {
    
#if DBG == 1    
        BOOL fSameElement;
        fSameElement = IsInAdorner(pEvent, NULL ) ||
                       IsSelected( spElement, NULL ) == S_OK ;
        AssertSz( fSameElement, "Not in same element as control - why are you getting this event ?" );
#endif             
        int iSel;
        //
        // Valid to change the primary for >1 selected elements
        // otherwise we have the same IE5 drill in behavior
        //
        if ( GetCommandTarget()->IsMultipleSelection() &&
             NumberOfSelectedItems() > 1 &&
             IsSelected( spElement, & iSel ) == S_OK )
        {                  
            newState = CT_WAITCHANGEPRIMARY; 
        } 
        else if ( pEvent->GetType() == EVT_LMOUSEDOWN )
        {                
            //                        
            // Here we will go UI Active.
            // Only allow going UI Active on LBUTTONDOWN. 
            //
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            
            IFC( GetMarkupServices()->GetElementTagId( GetControlElement() , & eTag ));
            if ( ShouldClickInsideGoActive( GetControlElement(0)) || eTag == TAGID_TABLE )
            {
                //
                // For tables the editable element is getting focus. Otherwise the control
                // is getting focus.
                //
                if ( NumberOfSelectedItems() == 1)
                {
                    if (FireOnBeforeEditFocus((eTag != TAGID_TABLE) ? 
                                                       GetControlElement(0) : 
                                                      _pManager->GetEditableElement(), 
                                               _pManager->IsContextEditable()))
                    {
                        if (_pManager->GetActiveTracker() == this )
                        {
                            newState = CT_PENDINGUP;
                        }
                        else
                        {
                            newState = CT_PASSIVE;
                        }
                    }
                    else
                    {
                        newState = CT_WAITMOVE;
                    }
                }
                else
                {
                    newState = CT_PASSIVE;
                }
            }
            else
            {
                //
                // Click in something that CANNOT be active - eg. Image or HR.
                //
                newState = CT_WAITMOVE;
            }
        }
        else
        {
            newState = CT_PASSIVE;
        }
    }     


#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

#if DBG == 1
    if ( IsTagEnabled( tagSelectionTrackerState ))
    {
#endif
        DumpIntermediateState( pEvent, _state, newState) ;
#if DBG == 1
    }
#endif  

#endif

Cleanup:
    if ( pNewState )
        *pNewState = newState;
    
    RRETURN1( hr, S_FALSE );
}

              
//+====================================================================================
//
// Method: HandleKeyDown
//
// Synopsis: Trap ESC to go deactive
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::HandleKeyDown( 
                        CEditEvent* pEvent )
{
    HRESULT             hr = S_FALSE;
    IMarkupPointer     *pControlStart = NULL ;
    IMarkupPointer     *pControlEnd = NULL ;
    ELEMENT_ADJACENCY   eAdj = ELEM_ADJ_BeforeBegin;
    SP_IDisplayPointer  spDispControlStart;
    SP_IHTMLElement     spElement ;
    LONG                keyCode ;

    IGNORE_HR( pEvent->GetKeyCode(& keyCode ));

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(GetControlElement(0)))
    {
        hr = S_OK;
        goto Cleanup;
    }
#endif
        
    if ( !IsActive() )
    {
        switch( keyCode )
        {       
            //
            // at some point we may want to change this behavior - to move the thing that we site select
            // for now we just transition to a caret - and pump the message on.
            //
            case VK_HOME:
            case VK_END:
            case VK_ESCAPE:
            case VK_LEFT:
            case VK_RIGHT:            
            {
                switch( keyCode )
                {
                    case VK_NEXT:
                    case VK_END:
                    case VK_RIGHT:
                        eAdj = ELEM_ADJ_AfterEnd;
                    break;    

                    default:
                        eAdj = ELEM_ADJ_BeforeBegin;
                }

                if ( g_fInVid && ( keyCode == VK_LEFT || keyCode == VK_RIGHT ) )
                {
                    //
                    // special case VID
                    // to match AppHack in CDoc::PerformTA()
                    // 
                    goto Cleanup;
                }
                
                //
                // We are Site Selected. Hitting escape transitions to a caret before the control
                //
                IFC( GetEditor()->CreateMarkupPointer( & pControlStart ));
                IFC( GetEditor()->CreateMarkupPointer( & pControlEnd ));

                SP_IHTMLElement spPrimaryElement;
                spPrimaryElement = GetControlElement(  PrimaryAdorner() );
                IFC( pControlStart->MoveAdjacentToElement( spPrimaryElement  , eAdj ));
                IFC( pControlEnd->MoveAdjacentToElement( spPrimaryElement, eAdj ));

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispControlStart) );
                IFC( spDispControlStart->MoveToMarkupPointer(pControlStart, NULL) );
                IFC( spDispControlStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

                _pManager->PositionCaret(spDispControlStart, ( keyCode == VK_ESCAPE ||
                                                               keyCode == VK_LEFT ||
                                                               keyCode == VK_RIGHT ) ? 
                                                                NULL : pEvent );  
                // fire the selectionchange event
                {
                    CSelectionChangeCounter selCounter(_pManager);                
                    selCounter.SelectionChanged();
                }
                
                hr = S_OK;
            }
            break;

            case VK_PRIOR:
            case VK_NEXT:
            {
                CARET_MOVE_UNIT     eMoveUnit = CARET_MOVE_PAGEDOWN;
                POINT               ptPoint;

                ptPoint.x = CARET_XPOS_UNDEFINED;
                ptPoint.y = CARET_XPOS_UNDEFINED;

                //  Determine the unit of movement.
                switch (keyCode)
                {
                    case VK_PRIOR:
                        eMoveUnit = CARET_MOVE_PAGEUP;
                        break;
                        
                    case VK_NEXT:
                        eMoveUnit = CARET_MOVE_PAGEDOWN;
                        break;
                };

                //  Set a markup pointer before our element
                IFC( GetEditor()->CreateMarkupPointer( & pControlStart ) );
                IFC( pControlStart->MoveAdjacentToElement( GetControlElement(0), ELEM_ADJ_BeforeBegin ) );

                //  Position a display pointer at the markup position
                IFC( GetDisplayServices()->CreateDisplayPointer(& spDispControlStart) );
                IFC( spDispControlStart->MoveToMarkupPointer(pControlStart, NULL) );

                //  Move the display pointer by the specified unit of movement,
                //  and scroll to it.
                IFC( MovePointer(eMoveUnit, spDispControlStart, &ptPoint, NULL, TRUE) );

                hr = S_OK;
            }
            break;            
        }
    }
    
Cleanup:    
    ReleaseInterface (pControlStart);
    ReleaseInterface (pControlEnd);
    RRETURN1 ( hr, S_FALSE );
}


//+============================================================================
//
// Method: HandleChar
//
// Synopsis: Trap Enter and ESC to go active/ deactive
//
//-----------------------------------------------------------------------------


HRESULT
CControlTracker::HandleChar(
                CEditEvent* pEvent )
{
    HRESULT         hr = S_FALSE;
    LONG            keyCode;
    SP_IHTMLElement spElement;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(GetControlElement(0)))
    {
        hr = S_OK;
    }
    else
    {
#endif

    IGNORE_HR( pEvent->GetKeyCode(&keyCode));
    switch( keyCode )
    {        
        case VK_RETURN:
        {
            if ( ! IsActive())
            {
                if ( ShouldClickInsideGoActive( GetControlElement(0)))
                {
                    if ( FireOnBeforeEditFocus( GetControlElement(0)) &&
                         _pManager->GetActiveTracker() == this )
                    {
                        SetDrillIn( TRUE , NULL );
                        IGNORE_HR( BecomeUIActive( pEvent ) ) ;
                    }
                }                    
                hr = S_OK;
            }
        }
        break;
    }
#ifdef FORMSMODE
    }
#endif

    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for WM_TIMER messages.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::OnTimerTick()
{
    HRESULT                 hr = S_OK;    
    StopTimer();
    
    switch (_state)
    {
        case CT_PENDINGUIACTIVATE:
#ifdef FORMSMODE
            if (IsAnyElementInFormsMode() )
                break;
#endif
            _pManager->SetDrillIn( TRUE );
            
            hr = HandleActivation( NULL, A_PENDINGUIACTIVATE_UIACTIVATE );
            break;
            
        default:
            AssertSz(0, "Unexpected state");
            break;
    }
    RRETURN(hr);
}

//
//
// Resizing / Moving / Dragging 
//
//
HRESULT
CControlTracker::DoResize( CEditEvent* pEvent  )
{
    HRESULT hr = S_OK;
    POINT   ptSnap;
    int     i;

    IFC( pEvent->GetPoint( & ptSnap));

    if ( ::PtInRect( & _rcClipMouse, ptSnap  )  )
    {
        if (_fClipMouse)
        {
             hr = IgnoreResizeCursor(FALSE);
             _fClipMouse = FALSE ;
        }
        
        for( i = _aryGrabAdorners.Size()-1; i >= 0; i--)
        {  
            _aryGrabAdorners[i]->DuringResize(ptSnap);
            FireOnResize(GetControlElement(i),_pManager->IsContextEditable());
        }
    }
    else
    {
        _fClipMouse = TRUE;
        hr = IgnoreResizeCursor(TRUE);

    }    

Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CControlTracker::IgnoreResizeCursor(BOOL fIgnore)
{
    HRESULT hr = S_FALSE;
    LPCTSTR idc = NULL;

    if (fIgnore)
    {
        idc = IDC_NO ;
    }
    else
    {
        switch (_elemHandle)
        {
            case ELEMENT_CORNER_BOTTOMRIGHT:
            case ELEMENT_CORNER_TOPLEFT:
                idc = IDC_SIZENWSE;
                break;
            
            case ELEMENT_CORNER_BOTTOMLEFT:
            case ELEMENT_CORNER_TOPRIGHT:
                idc = IDC_SIZENESW;
                break;
            
            case ELEMENT_CORNER_TOP:
            case ELEMENT_CORNER_BOTTOM:
                idc = IDC_SIZENS;
                break;
            
            case ELEMENT_CORNER_LEFT :
            case ELEMENT_CORNER_RIGHT:
                idc = IDC_SIZEWE;
                break;
            
            default:
                AssertSz(0, "Unexpected Element Corner");
                return S_FALSE;
        }
    }

    HCURSOR hcursor = LoadCursorA(NULL, (char *)idc);

    Assert(hcursor);
    if (hcursor)
    {
        ::SetCursor(hcursor);
        return S_OK;
    }

    hr = GetLastError();
    RRETURN(hr);
}

//+====================================================================================
//
// Method: DoLiveResize
//
// Synopsis: live updation of object while resizing the object 
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::DoLiveResize( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    RECT    newRect;
    POINT   change;
    BOOL    fResize = FALSE;
    POINT   ptSnap;
    
    IFC( pEvent->GetPoint( & ptSnap ));

    if ( ::PtInRect( & _rcClipMouse, ptSnap ) )
    {
        if (_fClipMouse)
        {
             hr = IgnoreResizeCursor(FALSE);
             _fClipMouse = FALSE ;
        }
     

        fResize = ( ptSnap.x != _startLastMoveX ) || 
                  ( ptSnap.y != _startLastMoveY )   ;

        if ( fResize ) 
        {       
            change.x = ptSnap.x - _startLastMoveX;
            change.y = ptSnap.y - _startLastMoveY;

            _startLastMoveX = ptSnap.x;
            _startLastMoveY = ptSnap.y;

            for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
            {  
                _aryGrabAdorners[i]->DuringLiveResize( change, &newRect );
                IFC( ResizeElement( newRect, GetControlElement(i)));
                FireOnResize(GetControlElement(i),_pManager->IsContextEditable());
            }

            Refresh();
       }
    }       
    else
    {
        _fClipMouse = TRUE;
        hr = IgnoreResizeCursor(TRUE);
    }
     
Cleanup:
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: Begin2DMove
//
// Synopsis: Start Moving the object in 2D Fashion, continuous update of position
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::Begin2DMove( CEditEvent* pEvent )
{
    HRESULT             hr = S_OK;
    POINT               ptSnap ;                                // Point where move started
    SP_IHTMLElement     spBodyElement ;
    POINT               ptOrigin;

    IFC( pEvent->GetPoint( & ptSnap ));
    
    IFC(GetEditor()->GetBody(&spBodyElement));
    
    IFC(GetElementRect(spBodyElement, &_rcClipMouse));

    IFC( EdUtil::GetClientOrigin( GetEditor(), spBodyElement, &ptOrigin) );

    ptSnap.x -= ptOrigin.x ;
    ptSnap.y -= ptOrigin.y ;

    _startMouseX = ptSnap.x ;
    _startMouseY = ptSnap.y ;    

    
    IFC(GetMovingPlane(&_rcRange));

    FilterOffsetElements();

    //
    // Clear off, and setup move rects
    //
    IFC( DeleteMoveRects() );
    IFC( SetupMoveRects() );
  
Cleanup:
    RRETURN (hr);
}


HRESULT
CControlTracker::DeleteMoveRects()
{
    RECT    **ppRect = NULL;
    int     i;
    
    for( i = _aryMoveRects.Size(), ppRect = _aryMoveRects;
         i > 0;
         i--, ppRect++ )
    {
        delete *ppRect;
    }

    _aryMoveRects.DeleteAll();
    
    RRETURN(S_OK);
}

HRESULT
CControlTracker::SetupMoveRects()
{
    int     nCount = NumberOfSelectedItems();       // Number of items that could be moved
    HRESULT hr = S_OK;
    
    for(int i = 0; i < nCount; i++)
    {
        RECT *pRect = NULL;

        pRect = new RECT;
        if( !pRect )
            goto Error;

        //
        // Retrieve and store the original position of the rect
        //
        IFC( GetElementRect( GetControlElement(i), pRect ) );
        IFC( _aryMoveRects.Append( pRect ) );
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

// get the moving plane, the wide rectangle which contains
// all the moving rectangles
HRESULT
CControlTracker::GetMovingPlane(RECT* rcRange)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement     spBodyElement;
    SP_IHTMLElement2    spBodyElement2;
    RECT    rcPlane = { 0, 0, 0, 0 };
    int     i = 0;
    long                lTop, lLeft;
    
    Assert( NumberOfSelectedItems() );

    IFC(GetElementRect(GetControlElement(i), &rcPlane));
        
    for (i = 1 ; i < NumberOfSelectedItems(); i++)
    {
        RECT  actualRect;
        GetElementRect(GetControlElement(i), &actualRect);
                   
        if (actualRect.left < rcPlane.left)    
            rcPlane.left = actualRect.left ;
        
        if (actualRect.top < rcPlane.top )      
            rcPlane.top  = actualRect.top ;
        
        if (actualRect.right > rcPlane.right)  
            rcPlane.right  = actualRect.right ;
        
        if (actualRect.bottom > rcPlane.bottom ) 
            rcPlane.bottom = actualRect.bottom ;
    }

    //  We need to offset the rect to adjust for scrolling.

    IFC(GetEditor()->GetBody(&spBodyElement));
    IFC( spBodyElement->QueryInterface( IID_IHTMLElement2, (void **) &spBodyElement2 ));

    IGNORE_HR(spBodyElement2->get_scrollTop(&lTop));
    IGNORE_HR(spBodyElement2->get_scrollLeft(&lLeft));

    OffsetRect(&rcPlane, -lLeft, -lTop);

    *rcRange = rcPlane ;

Cleanup :
    RRETURN1 (hr , S_FALSE);
}
    
// fix for multiple container-child selections and filtering 
// the childs out from moving : 99243 : chandras
HRESULT
CControlTracker::FilterOffsetElements()
{
   HRESULT hr = S_OK;
   int i = 0;
   int nCount = NumberOfSelectedItems();
  
   for (i = 0; i < nCount; i++)
        _aryGrabAdorners[i]->SetPositionChange(TRUE);
  
   if (nCount > 1)
   {
       SP_IHTMLElement spBodyElement ;
   
       IFC(GetEditor()->GetBody((&spBodyElement)));

       for (i = 0; i < nCount ; i++)
       {
            SP_IHTMLElement spParent;
            BOOL fFound = FALSE ;
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            
            GetControlElement(i)->get_offsetParent(&spParent);
            IFC( GetMarkupServices()->GetElementTagId(spParent, & eTag ));

            while (spParent != NULL && (eTag != TAGID_BODY) && !fFound)
            {
                SP_IHTMLElement spTempParent;
        
                if (IsSelected(spParent) == S_OK)
                {
                    _aryGrabAdorners[i]->SetPositionChange(FALSE);
                    fFound = TRUE;
                }            
                spParent->get_offsetParent(&spTempParent); 
                spParent = spTempParent;
                if (spParent != NULL)
                {
                    IFC( GetMarkupServices()->GetElementTagId(spParent, & eTag ));
                }
            }        
       }
   }
  
Cleanup:
   RRETURN (hr);
}

//+====================================================================================
//
// Method: Do2DMove
//
// Synopsis: Moving the object in 2D Fashion, continuous update of position
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::Do2DMove( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    CHTMLEditEvent  *pEditEvent;
    POINT   ptOffset;
    POINT   ptSnap ;
    POINT   ptOrigin;
   
    //  Bug 2026(109652) Don't resize if the src element is a view link master element.  When
    //  moving a viewlink the capture handler will call us with the view link master as the
    //  src element.  We don't want to handle it now because we are expecting the view link
    //  body.
    pEditEvent = DYNCAST( CHTMLEditEvent, pEvent );
    if (pEditEvent)
    {
        SP_IHTMLElement     spSrcElement;

        IFC( pEditEvent->GetEventObject()->get_srcElement(&spSrcElement) );
        Assert( spSrcElement != NULL );

        //  If the src element is the viewlink master element, then don't do the move.  We'll
        //  get called again to move the viewlink body.
        if ( GetEditor()->IsMasterElement(spSrcElement) == S_OK )
        {
            ELEMENT_TAG_ID eTag = TAGID_NULL;
            IFC( GetMarkupServices()->GetElementTagId(spSrcElement, & eTag ));

            if (eTag != TAGID_INPUT)
                goto Cleanup;
        }
    }

    IFC( pEvent->GetPoint( & ptSnap ));

#if DBG == 1
           if (IsTagEnabled(tagShowMovePosition))
            {
                CHAR achBuf[100];
                wsprintfA(achBuf, "MSHTMLEd::2D-Move Event Point at Start:: ( %d , %d ) \r\n", ptSnap.x, ptSnap.y);
                OutputDebugStringA(achBuf);
            }
#endif 

    IFC( EdUtil::GetClientOrigin( GetEditor(), GetControlElement(0), &ptOrigin) );

    ptSnap.x -= ptOrigin.x ;
    ptSnap.y -= ptOrigin.y ;

    // don't let the point go out of document, 
    // position the point at the edges of the final possible rect corners
    if ( !PtInRect(&_rcClipMouse,ptSnap) )
    {   
        if (ptSnap.x < _rcClipMouse.left )
            ptSnap.x = _rcClipMouse.left;
        else if (ptSnap.x > _rcClipMouse.right)
            ptSnap.x = _rcClipMouse.right;
        
        if (ptSnap.y < _rcClipMouse.top)
            ptSnap.y = _rcClipMouse.top;
        else if (ptSnap.y > _rcClipMouse.bottom)
            ptSnap.y = _rcClipMouse.bottom;
    }
    
    if (ptSnap.x != _startMouseX || ptSnap.y != _startMouseY)
    {
        RECT rcTemp;

        ptOffset.x =  ptSnap.x - _startMouseX;
        ptOffset.y =  ptSnap.y - _startMouseY;      

        ::SetRect(&rcTemp, _rcRange.left   + ptOffset.x, 
                           _rcRange.top    + ptOffset.y, 
                           _rcRange.right  + ptOffset.x, 
                           _rcRange.bottom + ptOffset.y);

        // this is important for the plane not to get out of the document.
        if ((rcTemp.left  <= _rcClipMouse.left && ptOffset.x < 0)  || 
            (rcTemp.right >= _rcClipMouse.right && ptOffset.x > 0))
              ptOffset.x = 0 ;
        if ((rcTemp.top    <= _rcClipMouse.top  && ptOffset.y < 0) || 
            (rcTemp.bottom >= _rcClipMouse.bottom && ptOffset.y > 0))
                ptOffset.y = 0 ;

        if (ptOffset.x != 0 || ptOffset.y != 0)
        {
            ScrollPointIntoView(&ptSnap);
        
            Live2DMove(ptOffset);

            ::SetRect(&_rcRange, _rcRange.left + ptOffset.x, 
                                 _rcRange.top  + ptOffset.y, 
                                 _rcRange.right + ptOffset.x, 
                                 _rcRange.bottom + ptOffset.y);

            _startMouseX = ptSnap.x;
            _startMouseY = ptSnap.y;            

            Refresh();
        }
    }      
    
Cleanup:
    RRETURN1( hr , S_FALSE );
}

VOID
CControlTracker::ScrollPointIntoView(POINT* ptSnap)
{
    RECT rect;

    rect.left   = ptSnap->x - SCROLL_SIZE;
    rect.top    = ptSnap->y - SCROLL_SIZE;
    rect.right  = ptSnap->x + SCROLL_SIZE;
    rect.bottom = ptSnap->y + SCROLL_SIZE;
    
    IGNORE_HR( GetDisplayServices()->ScrollRectIntoView( _pManager->GetEditableElement(), rect) );
}

//+====================================================================================
//
// Method: Live2DMove
//
// Synopsis: live updation of position while moving the object in 2D Fashion
//-------------------------------------------------------------------------------------

HRESULT 
CControlTracker::Live2DMove(POINT ptDisplace)
{
    HRESULT  hr = S_OK;
     
    for (int i = 0 ; i < NumberOfSelectedItems(); i++)
    {
        Assert( IsElementPositioned( GetControlElement(i) ));

        if (_aryGrabAdorners[i]->GetPositionChange())
        {
            RECT    *pMoveRect = GetMoveRect(i);    // Where the element would be had no snapping occured
            RECT    snapRect;                       // Where the element should be snapped to
            POINT   point;
            int     nWidth = 0 , nHeight = 0;  
            
            CEdUnits edUnit(GetEditor()->GetCssEditingLevel()) ;

            //
            // Get the width and height of our element
            //
            nWidth  =  (pMoveRect->right - pMoveRect->left) ;
            nHeight =  (pMoveRect->bottom - pMoveRect->top) ;

            //
            // Construct our snapping rectangle.  This is the rectangle where the element WOULD BE
            // had no snapping occurred.  This rectangle is stored in _aryMoveRects and is updated
            // everytime a move occurs
            //
            snapRect.left   = pMoveRect->left + ptDisplace.x;
            snapRect.top    = pMoveRect->top  + ptDisplace.y;
            snapRect.right  = snapRect.left + nWidth;
            snapRect.bottom = snapRect.top  + nHeight;

            //
            // Update our moved rect. This is where the element would be had no snapping occurred
            //
            pMoveRect->left = snapRect.left;
            pMoveRect->top = snapRect.top;
            pMoveRect->right = snapRect.right;
            pMoveRect->bottom = snapRect.bottom;
            
            //
            // Snap the rect, and update our element.
            //
            SnapRect(GetControlElement(i), &snapRect, ELEMENT_CORNER_NONE);

            point.x = snapRect.left;
            point.y = snapRect.top;

            IFC (edUnit.SetLeft(GetControlElement(i), point.x));
            IFC (edUnit.SetTop (GetControlElement(i), point.y));
        }
        FireOnMove(GetControlElement(i),_pManager->IsContextEditable());   
   }
  
Cleanup:
    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: End2DMove
//
// Synopsis: End Moving the object in 2D Fashion
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::End2DMove()
{
    HRESULT hr = S_OK;

    SetRect(&_rcRange, 0,0,0,0);

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();
    
    for (int i = 0; i < NumberOfSelectedItems(); i++)
        _aryGrabAdorners[i]->SetPositionChange(TRUE);
    
    if(_pUndoUnit)
    {
        delete _pUndoUnit;
        _pUndoUnit = NULL;
    } 
    FireOnAllElements(FireOnMoveEnd);

    RRETURN (hr);
}

/////////////////////////////////
// Forceful refresh of screen
/////////////////////////////////

VOID
CControlTracker::Refresh()
{
    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;

    IGNORE_HR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &myHwnd ));

    ::RedrawWindow( myHwnd ,NULL,NULL,RDW_UPDATENOW);
}

//+====================================================================================
//
// Method: DoDrag
//
// Synopsis: Let Trident do it's dragging. If we fail - set _fMouseUP so we don't begin 
//           dragging again.
//
//------------------------------------------------------------------------------------

 HRESULT
CControlTracker::DoDrag()
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement3    spElement3;
    VARIANT_BOOL        fRet;
    CSelectionManager*  pManager = _pManager;
    CControlTracker*    pTracker = this;
    CEdUndoHelper       undoDrag(GetEditor());
    
    IFC( undoDrag.Begin(IDS_EDUNDOMOVE) );
    spElement = GetControlElement(0);
    if (!spElement)
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void**)&spElement3));

    IGNORE_HR( GetSelectionManager()->FirePreDrag() );

    IFC(spElement3->dragDrop(&fRet));
    if (!fRet)
    {
        SP_IHTMLElement2    spElement2;
        SP_IOleWindow       spOleWindow;
        HWND                hwnd;
        RECT                windowRect;
        RECT                rectBlock;

        //  Drag drop failed.  We need to scroll back to the original drag element.  It has already
        //  been selected in drag code.  First check to see if we need to scroll.

        //
        // 1) Get the visible window
        //
        IFC( GetSelectionManager()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
        IFC( spOleWindow->GetWindow(&hwnd) );
        GetEditor()->GetWindowRect( hwnd, &windowRect );

        //
        // 2) See if a scrolling is necessary
        //
        IFC( spElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
        Assert(!(spElement2 == NULL));
        IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );

        if ( ShouldScrollIntoView(hwnd, &rectBlock, &windowRect) )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BOOL;
            V_BOOL(&v) = VARIANT_TRUE;

            hr = spElement->scrollIntoView(v);
            VariantClear(&v);
        }
    }

    hr = fRet ? S_OK : S_FALSE;
    
Cleanup:
    if ( ( hr == S_FALSE || 
           pManager->HasSameTracker(pTracker)) &&
         ! ( IsDormant()) )
    {
        //
        // The Drag failed. So we go back to the passive state.
        //
        SetState( CT_PASSIVE );
    }

    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: Resize Element
//
// Synopsis: Resize a given IHTMLElement - given the new Rect size 
//           Note that the Rect is the 
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::ResizeElement(RECT& newRect, IHTMLElement* pIElement)
{
    HRESULT        hr = S_OK;
    CEdUnits       edUnit(GetEditor()->GetCssEditingLevel()) ;
    LONG           lNewHeight, lNewWidth ;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    VARIANT vtLeft, vtTop;
    
    VariantInit( & vtTop );
    VariantInit( & vtLeft );
    
    // pass global coordinates only to snaprect (chandras)
    SnapRect(pIElement, &newRect, _elemHandle);

    // (chandras) : left, top makes sense only when the element is positioned,
    // try to change the values when the element is resized at top or left
    // 
    if (IsElementPositioned( pIElement))
    {
        SP_IHTMLStyle spStyle;
        BOOL fAbsolute = FALSE;

        IFC( EdUtil::Is2DElement(pIElement, &fAbsolute)) ;
        IFC( pIElement->get_style( &spStyle ));
        IFC( spStyle->get_left( & vtLeft ));
        IFC( spStyle->get_top( & vtTop ));

        Assert ( V_VT( & vtTop ) == VT_BSTR && V_VT( & vtLeft ) == VT_BSTR );

        //
        // Per Access PM we are going to set Left and Top on resize
        // only if the Left *and* the Top attributes are set
        //    
        if (( V_BSTR( & vtLeft ) != NULL &&  V_BSTR( & vtTop )  != NULL ))
        {
            POINT point;
            point.x = newRect.left ;
            point.y = newRect.top;

            //  point needs to be in global coordinates because we need to compare
            //  it to the offset we obtain from EdUtil::GetOffsetTopLeft() in
            //  CEdUnits::AdjustLeftDimensions() and CEdUnits::AdjustTopDimensions().
            //  We'll take this difference and add it to the current left and/or top
            //  position of the element.

            if ( _elemHandle == ELEMENT_CORNER_LEFT       ||
                 _elemHandle == ELEMENT_CORNER_TOPLEFT    ||
                 _elemHandle == ELEMENT_CORNER_BOTTOMLEFT  )
            {            
                edUnit.Clear(); // we intend to use this again, so clear it.
                IFC (edUnit.SetLeft(pIElement,point.x));
            }
    
            if ( _elemHandle == ELEMENT_CORNER_TOP     ||
                 _elemHandle == ELEMENT_CORNER_TOPLEFT ||
                 _elemHandle == ELEMENT_CORNER_TOPRIGHT )  
            {
                edUnit.Clear(); // we intend to use this again, so clear it.
                IFC (edUnit.SetTop (pIElement, point.y)); 
            }
        }
    }

    IFC( GetMarkupServices()->GetElementTagId(pIElement, & eTag ));   

    // set the new width preserving units
    lNewWidth = abs(newRect.right - newRect.left);
    edUnit.Clear(); // we intend to use this again, so clear it. 
    IFC(edUnit.SetWidth(pIElement, lNewWidth, eTag)); 

    // 
    // set the new height preserving units, but Don't attempt to resize drop down lists
    //
    if( IsDropDownList( pIElement ) )
        goto Cleanup;
    
    lNewHeight = abs(newRect.bottom - newRect.top) ;
    edUnit.Clear(); // we intend to use this again, so clear it. 
    IFC( edUnit.SetHeight(pIElement,lNewHeight, eTag)); 

Cleanup:
    VariantClear(&vtLeft);
    VariantClear(&vtTop);
    RRETURN ( hr );
}

//-----------------------------------------------------------------------------
//
// Method: EndResize
//
// Synopsis: End the Resize Change to the element : can get fired to terminate the resize
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::EndResize( POINT point )
{
    HRESULT hr = S_OK;
    RECT    newRect;
    BOOL    fResize = FALSE;

    _fInEndResize = TRUE;
    
    //
    // marka - per brettt - dont have a threshold - just don't resize if the point didn't move.
    //
    fResize = ( point.x != _startLastMoveX ) || 
              ( point.y != _startLastMoveY) ;
          
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        _aryGrabAdorners[i]->EndResize( point, & newRect );
        if ( fResize && !_fClipMouse )
        {
            IFC( ResizeElement( newRect, GetControlElement(i)));
        }
        FireOnResizeEnd(GetControlElement(i),_pManager->IsContextEditable());
    }

    _elemHandle = ELEMENT_CORNER_NONE;

Cleanup:
    _fInEndResize = FALSE;
    _fClipMouse = FALSE;
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: CommitResize
//
// Synopsis: Commit the Resize Change to the element
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::CommitResize( CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    CEdUndoHelper  undoUnit(_pManager->GetEditor());
    POINT          ptSnap;
    
    IFC( pEvent->GetPoint( & ptSnap ));

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();

    IGNORE_HR( undoUnit.Begin(IDS_EDUNDORESIZE) );

    IFC(EndResize(ptSnap));
    
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: CommitLiveResize
//
// Synopsis: Commit the Live Resize Change to the element
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::CommitLiveResize( CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    POINT          ptSnap;

    IFC( pEvent->GetPoint( & ptSnap ));

    Assert ( _pManager->IsInCapture() );
    ReleaseCapture();

    IFC(EndResize(ptSnap));
    
Cleanup:
    if(_pUndoUnit)
    {
        delete _pUndoUnit;
        _pUndoUnit = NULL;
    } 
    RRETURN ( hr );
}

// 
//
// Privates & Utils
//
//

//+====================================================================================
//
// Method: ShouldGoUIActiveOnFirstClick
//
// Synopsis: See if the element we clicked on should go UI Active Immediately. This happens
//          
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::ShouldGoUIActiveOnFirstClick(
                        IHTMLElement*  pIElement, 
                        ELEMENT_TAG_ID eTag)
{
    ELEMENT_TAG_ID eControlTag = TAGID_NULL;
    BOOL   fActivate = FALSE ;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode( pIElement))
    {
        return FALSE;
    }
#endif

    IGNORE_HR( GetMarkupServices()->GetElementTagId( GetControlElement(), & eControlTag));
    if (( eControlTag == TAGID_TABLE ) && ( eTag != TAGID_TABLE ))
            fActivate = TRUE;

    return fActivate;
}

VOID
CControlTracker::BecomeActiveOnFirstMove( CEditEvent* pEvent )
{
    SP_IHTMLElement spElement ;
    IGNORE_HR( pEvent->GetElement( &spElement));

    if (FireOnResizeStart(spElement ,_pManager->IsContextEditable()))
    {
         HRESULT hr = S_OK;

         if (GetCommandTarget()->IsLiveResize())
         {
            hr = THR( BeginLiveResize( pEvent ));
            if ( hr )
            {
                  //
                  // Start of Resize failed. Become passive.
                  //
                  SetState (CT_PASSIVE);
            }
            else
            {
                SetState( CT_LIVERESIZE  );
            }
         }
         else
         {
            hr = THR( BeginResize( pEvent ));
            if ( hr )
            {
                  //
                  // Start of Resize failed. Become passive.
                  //
                  SetState( CT_PASSIVE );
            }
            else
            {   
                  SetState( CT_RESIZE );
            }
         }
    }
}

HRESULT
CControlTracker::CreateAdorner(IHTMLElement* pIControlElement)
{
    HRESULT hr = S_OK;
    BOOL fLocked = IsElementLocked();
    //
    // For Control Selection - it is possible to select something at browse time
    // but not show any grab handles.
    //
    IHTMLDocument2* pDoc = _pManager->GetDoc();
    CGrabHandleAdorner* pNewAdorner;

    if ( EdUtil::IsParentEditable( GetMarkupServices(), pIControlElement) == S_OK )
    {
        ELEMENT_TAG_ID eTag = TAGID_NULL;

        _pManager->GetMarkupServices()->GetElementTagId(pIControlElement, &eTag);

        pNewAdorner = new CGrabHandleAdorner( pIControlElement , pDoc, fLocked);
    }
    else
    {
        pNewAdorner = new CSelectedControlAdorner( pIControlElement , pDoc, fLocked );
    }
    if (pNewAdorner == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    pNewAdorner->SetManager( _pManager );

    IFC( pNewAdorner->CreateAdorner() );
    IFC( _aryGrabAdorners.Append(pNewAdorner) );

    pNewAdorner->AddRef();

Cleanup:
    RRETURN ( hr );
}

VOID
CControlTracker::DestroyAllAdorners()
{
    CGrabHandleAdorner* pAdorner;

    for(int i = _aryGrabAdorners.Size()-1; i >=0 ; i--)
    {
        pAdorner =  _aryGrabAdorners.Item(i);
        pAdorner->DestroyAdorner();
        pAdorner->Release();
    }

    _aryGrabAdorners.DeleteAll();
}

//+====================================================================================
//
// Method: DestroyAdorner
//
// Synopsis: Destroy the adorner at the given index
//
//------------------------------------------------------------------------------------

VOID
CControlTracker::DestroyAdorner( int iIndex , BOOL* pfPrimary )
{
    CGrabHandleAdorner* pAdorner;

    pAdorner = _aryGrabAdorners.Item(iIndex);
    *pfPrimary = pAdorner->IsPrimary();

    pAdorner->DestroyAdorner();
    pAdorner->Release();

    _aryGrabAdorners.Delete(iIndex);
}

//+====================================================================================
//
// Method: IsElementLocked
//
// Synopsis: Is the Control Element Locked ?
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::IsElementLocked()
{
    HRESULT hr = S_OK;
    BOOL    fLocked = FALSE;

    hr = THR( GetEditor()->IsElementLocked( GetControlElement(0) , &fLocked ));

    return fLocked;
}

//+====================================================================================
//
// Method: BecomeActive
//
// Synopsis: We are actively dragging a control handle, we are in an "Active State".
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::BeginResize( CEditEvent* pEvent )
{
    int i;
    USHORT adj;
    HRESULT hr = S_OK;
    int     iSel = 0;
    POINT   pt;
    SP_IHTMLElement spElementClicked;
    
    IFC( pEvent->GetPoint( & pt ));

    IFC (TakeCapture());
    
    _startLastMoveX = pt.x;
    _startLastMoveY = pt.y;

    Assert(NULL == _pUndoUnit);

    //
    // Adjust what the primary is
    //
    IFC( GetSiteSelectableElementFromMessage( pEvent , & spElementClicked));    
    hr = IsSelected( spElementClicked, & iSel );
    AssertSz( hr == S_OK , "Element is not selected. How are you resizing it ?");
    if ( hr )
        goto Cleanup;

    if ( iSel != PrimaryAdorner() )
    {
        IFC( MakePrimary( iSel ));
    }
    
    // Start from the primary element
    i = PrimaryAdorner() ;
    Assert( _aryGrabAdorners[i]->IsPrimary());

   _aryGrabAdorners[iSel]->BeginResize(pt, CT_ADJ_NONE ) ;

    _elemHandle = GetElementCorner(pEvent) ;

    ClipMouseForElementCorner(  _aryControlElements[iSel]->pIElement , _elemHandle );

    // Get its adjustment mask
    adj = _aryGrabAdorners[iSel]->GetAdjustmentMask();

    for(i = 0; i < _aryGrabAdorners.Size() ; i++ )
    {    // Resize the remaining elements using primary's adjustment mask
        if ( i != iSel )
        {
            _aryGrabAdorners[i]->BeginResize(pt, adj ) ;
        }            
    }

Cleanup:
    RRETURN( hr );    
}

HRESULT
CControlTracker::ClipMouseForElementCorner( IHTMLElement* pIElement,ELEMENT_CORNER eCorner )
{
    HRESULT hr = S_OK;
    RECT  rect, screenRect ;
    SP_IHTMLElement2 spElement2, spBodyElement2;
    SP_IHTMLElement spBodyElement ;

    IFC( pIElement->QueryInterface( IID_IHTMLElement2, (void**) & spElement2 ));
    
    IFC( GetEditor()->GetBoundingClientRect( spElement2, & rect ));

    IFC (GetEditor()->GetBody(&spBodyElement));
    Assert (spBodyElement != NULL) ;

    IFC( spBodyElement->QueryInterface( IID_IHTMLElement2, (void**) & spBodyElement2 ));
    IFC( GetEditor()->GetBoundingClientRect( spBodyElement2, & screenRect ));

    switch( eCorner )
    {
        case ELEMENT_CORNER_TOP: 
            screenRect.bottom = rect.bottom ;
            break;
            
        case ELEMENT_CORNER_TOPRIGHT:
            screenRect.bottom = rect.bottom ;        
            screenRect.left = rect.left;
            break;
            
        case ELEMENT_CORNER_LEFT:
            screenRect.right = rect.right ;
            break;
            
        case ELEMENT_CORNER_TOPLEFT:
            screenRect.right = rect.right ;
            screenRect.bottom = rect.bottom ;
            break;

        case ELEMENT_CORNER_RIGHT:
            screenRect.left = rect.left;
            break;
            
        case ELEMENT_CORNER_BOTTOM:
            screenRect.top = rect.top;
            break;
                    
        case ELEMENT_CORNER_BOTTOMLEFT:
            screenRect.top = rect.top ;
            screenRect.right = rect.right ;
            break;
            
        case ELEMENT_CORNER_BOTTOMRIGHT :
            screenRect.top = rect.top ;
            screenRect.left = rect.left ;
            break;

        default:
            AssertSz(0,"unexpected corner");
    }
    
    _rcClipMouse = screenRect;

    _fClipMouse = FALSE;
        
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: BeginLiveResize
//
// Synopsis: Begin the process of doing a live resize.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::BeginLiveResize(CEditEvent* pEvent)
{
    int i;
    USHORT adj;
    HRESULT hr = S_OK;
    int     iSel = 0;
    SP_IHTMLElement spElementClicked;
    POINT   pt;

    IFC( pEvent->GetPoint( & pt ));
    
    IFC(TakeCapture());

    _startLastMoveX = pt.x;
    _startLastMoveY = pt.y;
     
    Assert(NULL == _pUndoUnit);

    _pUndoUnit = new CEdUndoHelper(_pManager->GetEditor());
    if(NULL == _pUndoUnit)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _pUndoUnit->Begin(IDS_EDUNDORESIZE);

    //
    // Adjust what the primary is
    //
    IFC( GetSiteSelectableElementFromMessage( pEvent, & spElementClicked ));    
    hr = IsSelected( spElementClicked, & iSel );
    AssertSz( hr == S_OK , "Element is not selected. How are you resizing it ?");
    if ( hr )
        goto Cleanup;

    if ( iSel != PrimaryAdorner() )
    {
        IFC( MakePrimary( iSel ));
    }
    
    // Start from the primary element
    i = PrimaryAdorner() ;
    Assert( _aryGrabAdorners[i]->IsPrimary());

    _aryGrabAdorners[iSel]->BeginResize(pt, CT_ADJ_NONE ) ;
    _elemHandle = GetElementCorner(pEvent);

    IFC( ClipMouseForElementCorner( _aryControlElements[iSel]->pIElement, _elemHandle ));

    // Get its adjustment mask
    adj = _aryGrabAdorners[iSel]->GetAdjustmentMask();

    for(i = 0; i < _aryGrabAdorners.Size() ; i++ )
    {    // Resize the remaining elements using primary's adjustment mask
        if ( i != iSel )
        {
            _aryGrabAdorners[i]->BeginResize(pt, adj ) ;
        }            
    }

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Unselect
//
// Synopsis: Remove our element from being selected. ASSUME ONLY ONE ELEMENT (not true in VS7)
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::UnSelect()
{
    HRESULT           hr = S_OK;
    CONTROL_ELEMENT **pceElem = NULL;
    int             i;
    
    // Iterate thru all of our elements, and unselect each one
    for( i = NumberOfSelectedItems(), pceElem = _aryControlElements;
         i > 0;
         i--, pceElem++ )
    {
        IFC( GetSelectionServices()->RemoveSegment( (*pceElem)->pISegment ) );
        ReleaseInterface( (*pceElem)->pISegment );

        (*pceElem)->pIElementStart->Release();
        (*pceElem)->pIElement->Release();

        delete *pceElem;
        
    }

    _aryControlElements.DeleteAll();

    DestroyAllAdorners();   

Cleanup:
    RRETURN ( hr );
}

HRESULT
CControlTracker::BecomeUIActive(  CEditEvent* pEvent )
{
    HRESULT        hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL           fOldActiveControl = _fActiveControl;
    CHTMLEditEvent* pFirstEvent = NULL;
    CHTMLEditEvent* pNextEvent = NULL;
    SP_IHTMLElement spControlElement;
    CSelectionChangeCounter selCounter(_pManager);
    BOOL fSucceed = TRUE ;
    
    //
    // BecomeDormant destroys these cached messages - so we copy construct new ones
    // and bubble if necessary
    //
    BOOL fBubbleFirstEvent = _pFirstEvent != NULL ;
    BOOL fBubbleNextEvent  = _pNextEvent != NULL ;

    // Make sure to stop the timer if it's been started.  We may switch CDoc here and
    // we won't be able to stop the timer after that and we'll continue to get timer
    // events.
    if (_pManager->IsInTimer())
        StopTimer();

    if ( fBubbleFirstEvent )
    {
        pFirstEvent = new CHTMLEditEvent ( DYNCAST( CHTMLEditEvent, _pFirstEvent ));
    }

    if ( fBubbleNextEvent )
    {
        pNextEvent = new CHTMLEditEvent ( DYNCAST( CHTMLEditEvent, _pNextEvent ));
    }        

    _pManager->SetDontFireEditFocus(TRUE);

    spControlElement = GetControlElement();

    if ( GetEditor()->IsMasterElement( spControlElement) == S_OK )
    {
        SP_IMarkupPointer spStart, spEnd;

        IFC( GetEditor()->CreateMarkupPointer( & spStart ));
        IFC( GetEditor()->CreateMarkupPointer( & spEnd ));
        
        IFC( PositionPointersInMaster( spControlElement, spStart, spEnd  ));

        IFC( spStart->CurrentScope( & spControlElement ));
    }

    IFC( GetMarkupServices()->GetElementTagId( spControlElement , & eTag ));
    _fActiveControl = ( eTag == TAGID_OBJECT );

    selCounter.BeginSelectionChange();
    
    if (S_OK != BecomeCurrent(  _pManager->GetDoc(), spControlElement ))
    {
        fSucceed = FALSE;
        SetState( CT_PASSIVE );
        _fActiveControl = fOldActiveControl;
        delete _pFirstEvent;
        _pFirstEvent = NULL;
        delete _pNextEvent;
        _pNextEvent = NULL;
    }
    else if ( IsDormant() )
    {
        if ( fBubbleFirstEvent )
        {
            IFC( _pManager->HandleEvent( pFirstEvent ));    
        }
        if ( fBubbleNextEvent )
        {
            IFC( _pManager->HandleEvent( pNextEvent ));    
        }
    }
    else
    {
        fSucceed = FALSE;
        SetState( CT_PASSIVE );
        delete _pFirstEvent;
        _pFirstEvent = NULL;
        delete _pNextEvent;
        _pNextEvent = NULL;
    }

    selCounter.EndSelectionChange( fSucceed );
    
Cleanup:     
    _pManager->SetDontFireEditFocus(FALSE);
    
    delete pFirstEvent;
    delete pNextEvent;
    RRETURN1 ( hr, S_FALSE );
}


VOID 
CControlTracker::SetDrawAdorners( BOOL fDrawAdorner )
{
    CGrabHandleAdorner* pAdorner = NULL;
    
    for(int i = _aryGrabAdorners.Size()-1; i >=0 ; i--)
    {
        pAdorner =  _aryGrabAdorners.Item(i);
        pAdorner->SetDrawAdorner( fDrawAdorner );
    }
}

//+====================================================================================
//
// Method: IsThisElementSiteSelectable
//
// Synopsis: Check to see if this particular element is SiteSelectable or not.
//
//------------------------------------------------------------------------------------


BOOL
CControlTracker::IsThisElementSiteSelectable( 
                        CSelectionManager * pManager,
                        ELEMENT_TAG_ID eTag, 
                        IHTMLElement* pIElement)
{
    BOOL  fSiteSelectable = FALSE;
#if 0
    if ( IsParentEditable( pManager->GetMarkupServices(), pIElement) == S_FALSE )
        return FALSE;
#endif

    fSiteSelectable = IsSiteSelectable( eTag ) ;
                      
    if ( ! fSiteSelectable && ! IsTablePart( eTag ) && eTag != TAGID_BODY && eTag != TAGID_FRAMESET )
    {
        //
        // If the element has layout - then 
        //
        fSiteSelectable = (IsLayout( pIElement ) == S_OK ) ;  // removed the elementpositioned check : 82961 (chandras)
    }           

    return fSiteSelectable;
}

//+====================================================================================
//
// Method:ShouldClickInsideGoActive
//
// Synopsis: Certain elements allow grab handles - but don't go UI Active, and handles
//           don't go away when you click inside. eg. Image.
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::ShouldClickInsideGoActive(IHTMLElement* pIElement )
{
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fActivate = TRUE ;

#ifdef FORMSMODE
    if (_pManager->IsInFormsSelectionMode(pIElement))
    {
        fActivate = FALSE;
    }
    else 
#endif
    if (SUCCEEDED( GetMarkupServices()->GetElementTagId( pIElement, & eTag )))
    {
        switch( eTag )
        {
            case TAGID_IMG:
            case TAGID_TABLE:
            case TAGID_HR:
                fActivate = FALSE;
                break;
            
            case TAGID_INPUT:
                {
                    SP_IHTMLInputElement spInputElement ;
                    BSTR bstrType = NULL;
    
                    //
                    // for input's of type= image, or type=button - we don't want to make UI activable
                    //               
                    if ( S_OK == THR(pIElement->QueryInterface( IID_IHTMLInputElement,(void**)&spInputElement )) && 
                         S_OK == THR(spInputElement->get_type(&bstrType)))
                    {                    
                        if (!StrCmpIC(bstrType, TEXT("image")))
                        {
                            fActivate = FALSE;
                        }                
                    }
                }
                break;
        }
    }   
    
    return fActivate;
}

//+====================================================================================
//
// Method: IsSiteSelectable
//
// Synopsis: Is this element site selectable or not.
//
//------------------------------------------------------------------------------------

BOOL 
CControlTracker::IsSiteSelectable( ELEMENT_TAG_ID eTag )
{
    switch ( eTag )
    {
        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_OBJECT:
        case TAGID_MARQUEE:
//      case TAGID_HTMLAREA:
        case TAGID_TEXTAREA:
        case TAGID_IMG:
        case TAGID_APPLET:
        case TAGID_TABLE:
        case TAGID_SELECT:
        case TAGID_HR:
        case TAGID_OPTION:    
        case TAGID_IFRAME:
        case TAGID_LEGEND:
        
            return TRUE;

        default:

            return FALSE;
    }    
}

//+====================================================================================
//
// Method: GetSiteSelectableElementFromMessage
//
// Synopsis: Get the Site Selectable Element from the message I have.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::GetSiteSelectableElementFromMessage( 
                        CEditEvent*    pEvent,
                        IHTMLElement** ppISiteSelectable  )
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;

    IFC( pEvent->GetElementAndTagId( & spElement, & eTag ));
    
    hr = IsElementSiteSelectable( eTag ,
                                  spElement,
                                  NULL,
                                  ppISiteSelectable ,
                                  TRUE ) ? S_OK : S_FALSE;
                                  
Cleanup:    
    RRETURN1( hr, S_FALSE );
}


//+====================================================================================
//
// Method: GetSiteSelectableElementFromMessage
//
// Synopsis: Get the Site Selectable Element from the message I have.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::GetSiteSelectableElementFromElement( 
                        IHTMLElement* pIElement,
                        IHTMLElement** ppISiteSelectable  )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    
    hr = IsElementSiteSelectable( eTag ,
                                  pIElement,
                                  NULL,
                                  ppISiteSelectable ,
                                  TRUE ) ? S_OK : S_FALSE;
                                  
Cleanup:    
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: IsElementSiteSelectable
//
// Synopsis: Do the work of figuring out whether we should have a control tracker,
//           and why we're doing it.
//
// Split up from ShouldStartTracker, as FindSelectedElement requires this routine as well
//
//------------------------------------------------------------------------------------

BOOL
CControlTracker::IsElementSiteSelectable( 
                        ELEMENT_TAG_ID eTag, 
                        IHTMLElement*  pIElement,
                        CControlTracker::HOW_SELECTED *peHowSelected,
                        IHTMLElement** ppIWeWouldSelectThisElement /* = NULL */,
                        BOOL           fSelectTablesFromTableParts /* = FALSE*/)
{
    HRESULT hr = S_OK;
    
    BOOL                    fShouldStart = FALSE;
    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;
    SP_IHTMLElement         spSelectThisElement;
    SP_IHTMLElement         spMasterElement;
    IHTMLElement           *pIOuterElement = NULL ;
    ELEMENT_TAG_ID          eOuterTag = TAGID_NULL;    
    IMarkupPointer         *pTempPointer = NULL;


    fShouldStart = IsThisElementSiteSelectable( _pManager, eTag, pIElement );    
    if ( ! fShouldStart )
    {          
        IFC( _pManager->GetEditor()->CreateMarkupPointer( &pTempPointer ));
        hr = THR( pTempPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin));
        if ( hr )
        {
            hr = THR( pTempPointer->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        }            
        IFC( GetEditor()->GetFlowElement( pTempPointer, & pIOuterElement ));
        if ( pIOuterElement )
        {                    
            IFC( GetMarkupServices()->GetElementTagId( pIOuterElement, & eOuterTag));
            fShouldStart = IsThisElementSiteSelectable( _pManager, eOuterTag, pIOuterElement );
            if ( fShouldStart )
            {
                spSelectThisElement = pIOuterElement ;            
                eHow =  CControlTracker::HS_OUTER_ELEMENT;
            }                
        }

        if ( ! fShouldStart && 
               fSelectTablesFromTableParts &&
               IsTablePart( eOuterTag ) )
        {
            SP_IHTMLElement spTableElement;
            IFC( GetEditor()->GetTableFromTablePart( pIOuterElement, & spTableElement ));

            spSelectThisElement = (IHTMLElement*) spTableElement ;            
            eHow =  CControlTracker::HS_OUTER_ELEMENT;

            fShouldStart = TRUE;
        }
    }   
    else
    {
        spSelectThisElement = pIElement ;
        eHow =  CControlTracker::HS_FROM_ELEMENT;
    }        


Cleanup:
    if ( ppIWeWouldSelectThisElement )
    {
        ReplaceInterface( ppIWeWouldSelectThisElement, (IHTMLElement*) spSelectThisElement );
    }

    ReleaseInterface (pTempPointer);
    ReleaseInterface (pIOuterElement);
    
    if ( peHowSelected )
        *peHowSelected = eHow;
    
    return fShouldStart;    
}

//+==========================================================================================
//
// Method: SnapRect
//
// Synopsis: Snap the Rectangle with host 
//
//----------------------------------------------------------------------------------------------------

void
CControlTracker::SnapRect(IHTMLElement* pIElement, RECT* rcSnap, ELEMENT_CORNER eHandle)
{
    if (GetEditor()->GetEditHost())
    {
        SP_IHTMLElement spBodyElement ;
        IGNORE_HR (GetEditor()->GetBody(&spBodyElement));
        Assert (spBodyElement != NULL) ;

        TransformRect(spBodyElement, rcSnap, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT); 
        GetEditor()->GetEditHost()->SnapRect(pIElement, rcSnap, eHandle);
        TransformRect(spBodyElement, rcSnap, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL); 

    }
}

//+==========================================================================================
//
//  Method: IsValidMove
//
// Synopsis: Check the Mouse has moved by at least _sizeDragMin - to be considered a "valid move"
//
//----------------------------------------------------------------------------------------------------

BOOL
CControlTracker::IsValidMove ( const POINT*  ppt)
{
    return ((abs(ppt->x - _startMouseX ) > GetMinDragSizeX()) ||
        (abs( ppt->y - _startMouseY) > GetMinDragSizeY() )) ;
}

//+====================================================================================
//
// Method: IsMessageOverControl
//
// Synopsis: Is the given message over the control ?
//
//------------------------------------------------------------------------------------

BOOL 
CControlTracker::IsMessageOverControl( CEditEvent* pEvent )
{
    Assert( _aryGrabAdorners[0] && pEvent );
    
    return IsInAdorner(pEvent);    
}

#if DBG == 1

VOID
CControlTracker::VerifyOkToStartControlTracker( CEditEvent* pEvent )
{
    HRESULT hr = S_OK;

    ELEMENT_TAG_ID   eTag = TAGID_NULL;
    IHTMLElement    *pElement = NULL;
    SST_RESULT       eResult = SST_NO_CHANGE;
    
    //
    // Examine the Context of the thing we started dragging in.
    //
    IFC( pEvent->GetElementAndTagId(  & pElement, & eTag ));
    ShouldStartTracker( pEvent, eTag, pElement, & eResult );
    
    Assert( eResult == SST_NO_BUBBLE || eResult == SST_NO_CHANGE ); // the control element is set. We should be saying we don't want to change or bubble.

Cleanup:
    AssertSz( ! hr , "Unexpected ResultCode in VerifyOkToStartControlTracker");
    ReleaseInterface(pElement);
}

#endif


//+====================================================================================
//
// Method: AddControlElement
//
// Synopsis:Add the element to the selection, growing the array and creating an
//          adorner as needed. The new element will be flagged and rendered
//          as the primary selection, and the element which previously was
//          flagged and rendered as such will be flagged and rendered as
//          a secondary selection.
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::AddControlElement( IHTMLElement* pIElement )
{
    HRESULT         hr = S_FALSE;
    CONTROL_ELEMENT *pceElement = NULL;
    SP_IMarkupPointer spPointer;

    Assert( pIElement );
    Assert( _aryGrabAdorners.Size() >= 0);

    hr = IsSelected(pIElement);
    if ( FAILED(hr) || S_OK == hr)
    {
        hr = S_FALSE; // the item is already selected
        goto Cleanup;
    }

    pceElement = new CONTROL_ELEMENT;
    if( !pceElement )
        goto Error;

    // Store the element for selection services    
    IFC( GetSelectionServices()->AddElementSegment(pIElement, &pceElement->pISegment));

    // Fill out the structure used to keep track of this control
    pceElement->pIElement = pIElement;

    // Reference count the element
    pIElement->AddRef();

    //
    // Create a ptr at start of element
    //
    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));
    pceElement->pIElementStart = spPointer;
    pceElement->pIElementStart->AddRef();
    
    IFC( pceElement->pIElementStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
    IFC( pceElement->pIElementStart->SetGravity(POINTER_GRAVITY_Right));

    IFC(_aryControlElements.Append( pceElement ));

    
    // Create the adorner and flag it as the primary
    IFC( CreateAdorner( pIElement ));

    //
    // First Element is primary. 
    //
    SetPrimary( _aryGrabAdorners.Size()-1 , _aryGrabAdorners.Size() == 1 ? TRUE : FALSE );
        
    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());

    // We are initiating a site selection.  We need to call notify begin selection
    // so that other trident instances can tear down their selection.
    
    if (NumberOfSelectedItems() == 1)
    {
        IFC( _pManager->NotifyBeginSelection( START_SITE_SELECTION ) );
    }    

Cleanup:  
    return hr;

Error:
    return E_OUTOFMEMORY;
}

HRESULT
CControlTracker::RemoveItem( int nIndex )
{
    HRESULT          hr = S_OK;
    BOOL             fPrimary = FALSE;
    CONTROL_ELEMENT *pceElement = NULL;

    Assert( nIndex >= 0 && nIndex < NumberOfSelectedItems() );
    
    // Delete our copy of the control
    pceElement = _aryControlElements.Item(nIndex);
    
    // Delete segment
    GetSelectionServices()->RemoveSegment( pceElement->pISegment );
    ReleaseInterface( pceElement->pISegment );

    Assert( pceElement != NULL );
    
    pceElement->pIElement->Release();

    pceElement->pIElementStart->Release();
    
    delete pceElement;
    
    _aryControlElements.Delete(nIndex);

    // Delete the adorner
    DestroyAdorner( nIndex , &fPrimary );

    // See if the item flagged as the primary is being deleted

    if (fPrimary && _aryGrabAdorners.Size() > 0)
    {
        SetPrimary( _aryGrabAdorners.Size() - 1 ,TRUE);
    }

    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());

    RRETURN( hr );
}

//+====================================================================================
//
// Method: RemoveControlElement
//
// Synopsis:Remove the element from the selection, along with its adorner. If
//          the adorner is flagged for primary selection rendering, pick and
//          flag another element to be the primary.
//
//------------------------------------------------------------------------------------
HRESULT
CControlTracker::RemoveControlElement( IHTMLElement* pIElementToRemove )
{
    HRESULT          hr = S_OK;
    int              nIndex   = -1 ;

    IFC( IsSelected(pIElementToRemove, &nIndex));

    if(nIndex < 0)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    IFC( RemoveItem( nIndex ));
    
Cleanup:
    return hr;
}    

BOOL
CControlTracker::AllElementsEditable()
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if(! _aryGrabAdorners[i]->IsEditable())
            return FALSE;
    }
    return TRUE;
}

BOOL
CControlTracker::AllElementsUnlocked()
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if( _aryGrabAdorners[i]->IsLocked())
            return FALSE;
    }
    return TRUE;
}

BOOL
CControlTracker::IsInMoveArea(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInMoveArea(pEvent))
            return TRUE;
    }
    return FALSE;
}

BOOL
CControlTracker::IsInResizeHandle(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInResizeHandle(pEvent))
            return TRUE;
    }
    return FALSE;
}

BOOL
CControlTracker::IsInAdorner(CEditEvent *pEvent, int *pnClickedElement /* = NULL */)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInAdorner(ptGlobal, pnClickedElement);
}

BOOL
CControlTracker::IsInAdorner(POINT ptGlobal, int* pnClickedElement /* = NULL */)
{
    int cItems = NumberOfSelectedItems();

    for(int i = 0; i < cItems; i++)
    {
        if( _aryGrabAdorners[i]->IsInAdornerGlobal(ptGlobal))
        {
            if(pnClickedElement)
                *pnClickedElement = i;
            return TRUE;
        }
    }

    return FALSE;
}

//+====================================================================================
//
// Method: IsSelected
//
// Synopsis: Is this element selected ? 
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::IsSelected(IHTMLElement* pIElement, int* pnIndex /* = NULL */)
{
    IObjectIdentity *pIdent = NULL ;
    int i ;
    HRESULT  hr ;
    if (pnIndex)
        *pnIndex = -1;

    hr = S_FALSE ;
    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        IFC(GetControlElement(i)->QueryInterface(IID_IObjectIdentity, (void**)&pIdent ));

        if ( pIdent->IsEqualObject ( pIElement ) == S_OK )
        {
            if(pnIndex)
                *pnIndex = i;
            
            hr = S_OK;
            goto Cleanup;

        }
        ClearInterface(&pIdent);
    }
    hr = S_FALSE ;

Cleanup:
    ReleaseInterface(pIdent);
    return hr;
}

HRESULT
CControlTracker::IsSelected(IMarkupPointer * pIPointer, int* pnIndex /* = NULL */)
{
    int i ;
    HRESULT  hr ;
    BOOL fEqual;
    if (pnIndex)
        *pnIndex = -1;

    for(i = NumberOfSelectedItems()-1; i >= 0; i--)
    {
        IFC( _aryControlElements[i]->pIElementStart->IsEqualTo( pIPointer, & fEqual ));
        if ( fEqual )
        {
            if(pnIndex)
                *pnIndex = i;
            
            hr = S_OK;
            goto Cleanup;
        }
    }
    hr = S_FALSE ;

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method: PrimaryAdorner
//
// Synopsis: Return the element that is the primary adorner
//
//------------------------------------------------------------------------------------

int 
CControlTracker::PrimaryAdorner()
{
    for ( int i = 0; i < _aryGrabAdorners.Size(); i ++ )
    {
        if ( _aryGrabAdorners[i]->IsPrimary())
        {
            return i;
        }
    }
    
    AssertSz(0, "No Primary Found");
    return - 1;
}


//+====================================================================================
//
// Method: MakePrimary.
//
// Synopsis: Make the Element at position iIndex the Primary. Note that the index of this
// element then changes.
//
//------------------------------------------------------------------------------------

HRESULT
CControlTracker::MakePrimary(int iIndex)
{
    HRESULT hr = S_OK;
    Assert( iIndex <= _aryGrabAdorners.Size() - 1);
    Assert( iIndex >= 0 );

    SetPrimary( PrimaryAdorner(), FALSE );
    SetPrimary( iIndex, TRUE );
    
    Assert( NumberOfSelectedItems() == _aryGrabAdorners.Size());
    if ( _pPrimary )
    {
        ClearInterface( & _pPrimary );
    }

    return hr;
}

VOID
CControlTracker::SetPrimary( int iIndex, BOOL fPrimary )
{
    _aryGrabAdorners[ iIndex ]->SetPrimary( fPrimary );                
    _aryControlElements[ iIndex ]->pISegment->SetPrimary( fPrimary );
}



//+---------------------------------------------------------------------------
//
//  Member:     GetAction
//
//  Synopsis: Get the Action associated with the current state for the given message
//
//----------------------------------------------------------------------------


CONTROL_ACTION 
CControlTracker::GetAction( CEditEvent* pEvent)
{
    unsigned int LastEntry = sizeof (ControlActionTable) / sizeof (ControlActionTable[0]);
    unsigned int i;
    CONTROL_ACTION Action = A_ERRCONTROL;

    Assert ( !IsDormant() );

    // Discard any spurious mouse move messages

    for (i = 0; i <= LastEntry; i++)
    {
        if ( (ControlActionTable[i]._iJMessage == pEvent->GetType() ) || ( i == LastEntry ) )
        {
            Action = ControlActionTable[i]._aAction[_state];
            break;
        }
    }
    return (Action);    
}

//+===================================================================================
// Method:      GetElementToTabFrom
//
// Synopsis:    Gets the element where we should tab from based on selection
//
//------------------------------------------------------------------------------------
HRESULT 
CControlTracker::GetElementToTabFrom(BOOL fForward, IHTMLElement **pElement, BOOL *pfFindNext)
{
    HRESULT             hr = S_OK;

#if DBG==1
    SELECTION_TYPE      eType;
    SP_ISegmentList     spList;
    BOOL                fEmpty;
    
    IFC( GetSelectionServices()->QueryInterface(IID_ISegmentList, (void **)&spList ) );
    IFC( spList->IsEmpty( &fEmpty ) );
    IFC( spList->GetType( &eType ) );

    Assert( !fEmpty && (eType == SELECTION_TYPE_Control) );
    Assert( pfFindNext );
    Assert( pElement );

#endif // DBG

    // Retrieve the primary control element
    *pElement = GetControlElement(PrimaryAdorner());
    ((IUnknown *)*pElement)->AddRef();

#if DBG==1
Cleanup:
#endif

    RRETURN( hr );
}

HRESULT
CControlTracker::StartTimer()
{
    HRESULT hr = S_OK;

    Assert( _pManager->GetActiveTracker() == this );
    Assert( ! _pManager->IsInTimer() );

    IFC(GetEditor()->StartDblClickTimer( /*GetDoubleClickTime() * 1.2 */ ));
    _pManager->SetInTimer( TRUE);

Cleanup:
    RRETURN( hr );
}

HRESULT
CControlTracker::StopTimer()
{
    HRESULT hr = S_OK;
    Assert( _pManager->GetActiveTracker() == this );
    Assert( _pManager->IsInTimer() );

    IFC(GetEditor()->StopDblClickTimer());
    _pManager->SetInTimer( FALSE );               

Cleanup:
    RRETURN( hr );
}

#if DBG == 1 || TRACKER_RETAIL_DUMP == 1

void 
CControlTracker::DumpTrackerState(
                        CEditEvent* pEvent,
                        CONTROL_STATE inOldState,
                        CONTROL_ACTION inAction )
{
    TCHAR sControlState[30];
    TCHAR sOldControlState[30];    
    CHAR  sMessageType[50];
    TCHAR sAction[32];
    CHAR  achBuf[4096];
    
    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //   
    
    StateToString( sControlState, _state );
    StateToString( sOldControlState, inOldState );
    
    if ( pEvent)
    {
        pEvent->toString( sMessageType );
    }

    ActionToString( sAction, inAction);

    wsprintfA(
        achBuf,
        "Old State: %ls State: %ls Action:%ls Message:%s ",
        sOldControlState, sControlState,sAction, sMessageType );

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");    

}

void 
CControlTracker::DumpIntermediateState(
                CEditEvent* pEvent,
                CONTROL_STATE inOldState,
                CONTROL_STATE newState )
{
    TCHAR sControlState[30];
    TCHAR sOldControlState[30];    
    CHAR sMessageType[50];
    CHAR achBuf[4096];
    
    //
    // We use OutputDebugString here directly - instead of just a good ol' trace tag
    // as we want to enable logging of Tracker State in Retail as well ( if DEBUG_RETAIL_DUMP is defined )
    //   
    
    StateToString( sControlState, newState );
    StateToString( sOldControlState, inOldState );
    
    if ( pEvent )
    {
        pEvent->toString( sMessageType );
    }

    wsprintfA(
        achBuf,
        "IntermediateState - Old State: %ls Intermediate State:%ls  Message:%s ",
        sOldControlState, sControlState,  sMessageType );

    OutputDebugStringA("MSHTML trace: ");
    OutputDebugStringA(achBuf);
    OutputDebugStringA("\n");    
}

void 
CControlTracker::StateToString(TCHAR* pAryMsg, CONTROL_STATE inState )
{
    switch ( inState )
    {
        case CT_START:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_START"));
            break;

        case CT_WAIT1:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAIT1"));
            break;
        
        case CT_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PASSIVE"));
            break;

        case CT_DRAGMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_DRAGMOVE"));
            break;

        case CT_RESIZE: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_RESIZE"));
            break;
        
        case CT_LIVERESIZE: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_LIVERESIZE"));
            break;
        
        case CT_WAITMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAITMOVE"));
            break;

        case CT_2DMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_2DMOVE"));
            break;

        case CT_PENDINGUP:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PENDINGUP"));
            break;
        
        case CT_UIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_UIACTIVATE"));
            break;
        
        case CT_DORMANT: 
            edWsprintf( pAryMsg , _T("%s"), _T("CT_DORMANT"));
            break;
        
        case CT_END:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_END"));
            break;

        case CT_WAITCHANGEPRIMARY:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_WAITCHANGEPRIMARY"));
            break;
        
        case CT_CHANGEPRIMARY:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_CHANGEPRIMARY"));
            break;

        case CT_EXTENDSELECTION:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_EXTENDSELECTION"));
            break;

        case CT_REDUCESELECTION:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_REDUCESELECTION"));
            break;

        case CT_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("CT_PENDINGUIACTIVATE"));
            break;
            
        default:
            AssertSz(0,"Unknown State");
    }
    
}

void 
CControlTracker::ActionToString(TCHAR* pAryMsg, CONTROL_ACTION inState )
{
    switch ( inState )
    {         
        case A_IGNCONTROL:
            edWsprintf( pAryMsg , _T("%s"), _T("A_IGNCONTROL"));
            break;
        
        case A_ERRCONTROL:
            edWsprintf( pAryMsg , _T("%s"), _T("A_ERRCONTROL"));
            break;
            
        case A_START_WAIT:
            edWsprintf( pAryMsg , _T("%s"), _T("A_START_WAIT"));
            break;
            
        case A_WAIT_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAIT_MOVE"));
            break;
            
        case A_WAIT_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAIT_PASSIVE"));
            break;
            
        case A_PASSIVE_DOWN:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_DOWN"));
            break;
            
        case A_PASSIVE_DOUBLECLICK:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_DOUBLECLICK"));
            break;
                       
        case A_RESIZE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_RESIZE_MOVE"));
            break;

        case A_RESIZE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_RESIZE_PASSIVE"));
            break;
            
        case A_LIVERESIZE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_LIVERESIZE_MOVE"));
            break;

        case A_LIVERESIZE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_LIVERESIZE_PASSIVE"));
            break;
            
        case A_WAITMOVE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITMOVE_PASSIVE"));
            break;
            
        case A_WAITMOVE_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITMOVE_MOVE"));
            break;

        case A_2DMOVE_2DMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_2DMOVE_2DMOVE"));
            break;
            
        case A_2DMOVE_PASSIVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_2DMOVE_PASSIVE"));
            break;
        case A_PENDINGUP_MOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_MOVE"));
            break;
            
        case A_PENDINGUIACTIVATE_UIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUIACTIVATE_UIACTIVATE"));
            break;            

        case A_PENDINGUP_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_PENDINGUIACTIVATE"));
            break;
            
        case A_PENDINGUP_END:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PENDINGUP_END"));
            break;

        case A_WAITCHANGEPRI_CHANGEPRI:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITCHANGEPRI_CHANGEPRI"));
            break;
    
        case A_WAITCHANGEPRI_DRAGMOVE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_WAITCHANGEPRI_DRAGMOVE"));
            break;
                  

        case A_PASSIVE_PENDINGUIACTIVATE:
            edWsprintf( pAryMsg , _T("%s"), _T("A_PASSIVE_PENDINGUIACTIVATE"));
            break;
    
        default:
            AssertSz(0,"Unknown Action");
     }
}

#endif

VOID 
CControlTracker::SetDrillIn( BOOL fDrillIn, CEditEvent* pEvent )
{
    _pManager->SetDrillIn( fDrillIn );
    if ( pEvent )
    {
        StoreFirstEvent( DYNCAST( CHTMLEditEvent, pEvent ));
    }
    else if ( _pFirstEvent )
    {
        delete _pFirstEvent;
        _pFirstEvent = NULL;
    }
}

VOID
CControlTracker::StoreFirstEvent( CHTMLEditEvent* pEvent )
{
    Assert( !_pFirstEvent );
    _pFirstEvent = new CHTMLEditEvent( pEvent );
}

VOID
CControlTracker::StoreNextEvent( CHTMLEditEvent* pEvent )
{
    Assert( !_pNextEvent );
    _pNextEvent = new CHTMLEditEvent( pEvent );
}

#ifdef FORMSMODE
BOOL
CControlTracker::IsAnyElementInFormsMode( )
{
    for (int i = 0 ; i < _aryControlElements.Size() ; i++)
    {
        if ( _pManager->IsInFormsSelectionMode( GetControlElement(i)))
            return TRUE;
    }
   
    return FALSE;
}
#endif

VOID 
CControlTracker::SetState( CONTROL_STATE inState )
{
    Assert( ( _state == CT_DORMANT  && ( inState == CT_WAIT1 || inState == CT_PASSIVE || inState == CT_DORMANT )) 
            ||
            _state != CT_DORMANT );

    if ( inState == CT_PASSIVE && _pManager->GetActiveTracker() != this )
    {
        AssertSz(0,"Here we are");
    }
    
    _state = inState ; 
}

BOOL 
CControlTracker::FireOnAllElements(PFNCTRLWALKCALLBACK pfnCtrlWalk)
{
    for (int iCtrl = 0 ; iCtrl < _aryControlElements.Size() ; iCtrl++)
    {
        if (!pfnCtrlWalk(GetControlElement(iCtrl),_pManager->IsContextEditable()))
            break;
    }
    return (iCtrl == _aryControlElements.Size());
}

void 
CControlTracker::TransformRect(
                    IHTMLElement*  pIElement,
                    RECT *         prc,
                    COORD_SYSTEM   srcCoord,
                    COORD_SYSTEM   destCoord)
{
    POINT ptTopLeft , ptBottomRight ;
    ptTopLeft.x     = prc->left   ;
    ptTopLeft.y     = prc->top    ;
    ptBottomRight.x = prc->right  ;
    ptBottomRight.y = prc->bottom ;
    
    IGNORE_HR( GetDisplayServices()->TransformPoint( & ptTopLeft, 
                                                       srcCoord, 
                                                       destCoord, 
                                                       pIElement));

    IGNORE_HR( GetDisplayServices()->TransformPoint( & ptBottomRight, 
                                                       srcCoord, 
                                                       destCoord, 
                                                       pIElement));
    prc->left   = ptTopLeft.x     ;
    prc->top    = ptTopLeft.y     ;
    prc->right  = ptBottomRight.x ;
    prc->bottom = ptBottomRight.y ;
}

ELEMENT_CORNER
CControlTracker::GetElementCorner(CEditEvent *pEvent)
{
    for(int i = _aryGrabAdorners.Size()-1; i >= 0; i--)
    {
        if( _aryGrabAdorners[i]->IsInResizeHandle(pEvent))
            return _aryGrabAdorners[i]->GetElementCorner();
    }
    return ELEMENT_CORNER_NONE;
}

HRESULT 
CControlTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    HRESULT             hr = S_OK ;

    IFC( GetLocation(pPoint, ELEM_ADJ_BeforeBegin, fTranslate) );
    
Cleanup:
    RRETURN( hr );
}

HRESULT 
CControlTracker::GetLocation(POINT *pPoint,
    ELEMENT_ADJACENCY eAdj,
    BOOL fTranslate /* = TRUE */)
{
    HRESULT             hr = S_OK ;
    SP_IMarkupPointer   spMarkupPointer;
    SP_IDisplayPointer  spDisplayPointer;
    SP_ILineInfo        spLineInfo;

    //  Set a markup pointer next to our element
    IFC( GetEditor()->CreateMarkupPointer( & spMarkupPointer ) );
    IFC( spMarkupPointer->MoveAdjacentToElement( GetControlElement(0), eAdj ) );

    //  Position a display pointer at the markup position
    IFC( GetDisplayServices()->CreateDisplayPointer(& spDisplayPointer) );
    IFC( spDisplayPointer->MoveToMarkupPointer(spMarkupPointer, NULL) );

    //  Get line info for our display pointer.
    IFR( spDisplayPointer->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_baseLine(&pPoint->y) );
    IFC( spLineInfo->get_x(&pPoint->x) );

    if (fTranslate)
    {
        SP_IHTMLElement     spIFlowElement;
        
        //  Get the flow element so that we can transform our point to global coordinates
        IFC( spDisplayPointer->GetFlowElement( & spIFlowElement ));
        if ( ! spIFlowElement )
        {
            IFC( _pManager->GetEditableElement( & spIFlowElement));
        }

        //  Transform our point to global coordinates
        IFC( GetDisplayServices()->TransformPoint( pPoint, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spIFlowElement ));
    }
    
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//  Method:     CControlTracker::EmptySelection
//
//  Synopsis:   Unselect and remove the adorners for any selected controls, 
//              while keeping the tracker active.
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CControlTracker::EmptySelection( BOOL fChangeTrackerAndSetRange /*=TRUE*/)
{
    if ( fChangeTrackerAndSetRange )
    {
        RRETURN( UnSelect() );
    }
    else
        return S_OK;
}

HRESULT
CControlTracker::EnableModeless( BOOL fEnable )
{
    HRESULT hr = S_OK;

    if ( ! fEnable ) // dialog is coming up. we better shut ourselves down.
    {
        hr = THR( OnLoseFocus()) ;
    }

    RRETURN( hr );
}


HRESULT 
CControlTracker::OnLoseFocus()
{
    if ( !IsPassive() )
    {            
        if ( _pManager->IsInTimer() )
            StopTimer();
        
        if ( _pManager->IsInCapture()  )
            ReleaseCapture(FALSE); // the capture change handles this for us.

        EndCurrentEvents();
        
        SetState( CT_PASSIVE );
    }

    return S_OK;
}

VOID
CControlTracker::EndCurrentEvents()
{
    switch (_state)
    {
        case CT_RESIZE:
        case CT_LIVERESIZE :
        {
            POINT ptLast ;

            if( !_fInEndResize )
            {
                ptLast.x = _startLastMoveX ;
                ptLast.y = _startLastMoveY ;

                SetState( CT_PASSIVE );
                
                EndResize(ptLast);

                if(_pUndoUnit)
                {
                    delete _pUndoUnit;
                    _pUndoUnit = NULL;
                } 
            }
        }
        break;
        
        case CT_2DMOVE:
        {     
            if(_pUndoUnit)
            {
                delete _pUndoUnit;
                _pUndoUnit = NULL;
            } 
            SetState( CT_PASSIVE );
        }    
        break;
       
        case CT_PENDINGUP:
        {
            SetDrillIn( FALSE );
            SetState( CT_PASSIVE );
        }
        break;

        case CT_PENDINGUIACTIVATE:
        {
            SetDrillIn( FALSE );
            if ( _pNextEvent )
            {
                delete _pNextEvent;
                _pNextEvent = NULL;
            }
            SetState( CT_PASSIVE );
        }
        break;
        
        default:
            SetState( CT_PASSIVE );
    }
}

BOOL
CControlTracker::FireOnControlSelect( IHTMLElement* pIElement )
{
    BOOL fReturnVal = TRUE ;

    if ( IsParentEditable( GetMarkupServices(), pIElement) == S_OK )
    {
        fReturnVal = EdUtil::FireOnControlSelect( pIElement, TRUE ) ;

        if ( ! _pManager->IsContextEditable() )
        {
            fReturnVal = FALSE;
            _pManager->EnsureDefaultTrackerPassive() ;
        }
    }

    return fReturnVal;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\cutcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       CUTCMD.CXX
//
//  Contents:   Implementation of Cut command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_CUTCMD_HXX_
#define _X_CUTCMD_HXX_
#include "cutcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

using namespace EdUtil;

//
// Externs
//

MtDefine(CCutCommand, EditCommand, "CCutCommand");


//+---------------------------------------------------------------------------
//
//  CCutCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CCutCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement         spElement = NULL;
    SP_IHTMLElement3        spElement3;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList = NULL;
    SP_ISegment             spSegment = NULL;
    SP_ISegmentListIterator spIter = NULL;
    BOOL                    fEmpty = FALSE;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    BOOL                    fNotRange = TRUE;
    CEdUndoHelper           undoUnit(GetEditor());
    CHTMLEditor             *pEditor = GetEditor();
    ED_PTR( edStart);
    ED_PTR( edEnd );    
    
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    //
    // Do the prep work
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );           
    IFC( spSegmentList->IsEmpty( &fEmpty ) );           

    //
    // Cut is allowed iff we have a non-empty segment
    //    
    if ( eSelectionType == SELECTION_TYPE_Caret || fEmpty )
    {
        goto Cleanup;
    }

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

    //
    // Now Handle the cut 
    //
    IFC( undoUnit.Begin(IDS_EDUNDOCUT) );

    //
    // Fire on-cut event on element common to all segmetns.
    //
    
    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));

    if (! spElement)
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("oncut"), NULL, &fRetVal));
    fRet = !!fRetVal;

    if (! fRet)
    {
        goto Cleanup;
    }

    //
    // TODO - call Query Status here.
    //

    IFC( spSegmentList->CreateIterator(&spIter) );
    
    //
    // Do verfication for all segments. Any invalid - we fail.
    //
    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment) );        
        IFC( spSegment->GetPointers( edStart, edEnd ));
        
        IFC( edStart->IsEqualTo( edEnd, & fRet ) );
        if ( fRet )
        {
            goto Cleanup;
        }

        //
        // Cannot delete or cut unless the range is in the same flow layout
        //
        if( !GetEditor()->PointersInSameFlowLayout( edStart, edEnd, NULL ) )
        {
            goto Cleanup;
        }

        IFC( spIter->Advance() );
    }
    
    //
    // Save to clipboard.
    //
    
#ifndef UNIX
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( spSegmentList, 0 ) );
#else
    IFC( GetMarkupServices()->SaveSegmentsToClipboard( spSegmentList, 0, NULL ) );
#endif

    //
    // Delete segments.
    //
    if (eSelectionType == SELECTION_TYPE_Control)
    {
        IFC (GetEditor()->RemoveElementSegments(spSegmentList));
    }
    else
    {
        fNotRange =  !GetCommandTarget()->IsRange();
    
        IFC( spIter->First() );

        while( spIter->IsDone() == S_FALSE )
        {
            // Get our current segment, and advance the iterator
            // to the next segment.  This is because we might
            // blow away our segment in the call to Delete.  We should
            // probably fix this if this becomes a public interface.
            IFC( spIter->Current(&spSegment) );        
            IFC( spIter->Advance() );

            IFC( spSegment->GetPointers( edStart, edEnd ));
            IFC( pEditor->Delete( edStart, edEnd, fNotRange ) );
        }
    
        if ( eSelectionType == SELECTION_TYPE_Text) 
        {
            pEditor->GetSelectionManager()->EmptySelection();
        }
    }

Cleanup:   
    ReleaseInterface( (IHTMLEditor *) pEditor );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  CCutCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CCutCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    VARIANT_BOOL            fEditable;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    IHTMLEditor             *pEditor = GetEditor();
    SP_IHTMLElement         spElement = NULL;
    SP_ISegmentList         spSegmentList = NULL;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    SP_IHTMLElement3        spElement3;
    
    pEditor->AddRef();    // FireOnCancelableEvent can remove the whole doc

    ED_PTR (edStart);
    ED_PTR (edEnd);
    
    // 
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    //
    // Get Segment list and selection type
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType(& eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    //
    // Cut is allowed iff we have a non-empty segment
    //
    if( eSelectionType == SELECTION_TYPE_Caret  ||
        fEmpty == TRUE                          ||    
        GetEditor()->GetSelectionManager()->IsIMEComposition() )
    {
        goto Cleanup;
    }

    //  See if the segment list contains a password element
    if (SegmentListContainsPassword(spSegmentList))
        goto Cleanup;

    //
    // Fire cancelable event
    //
    IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
    if (! spElement) 
        goto Cleanup;

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("onbeforecut"), NULL, &fRetVal));
    fRet = !!fRetVal;
    
    if (! fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP; 
        goto Cleanup;
    }

    if ( ! GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC(spElement3->get_isContentEditable(&fEditable));

        if ( ! fEditable) 
            goto Cleanup;
    }

    if (!GetCommandTarget()->IsRange())
    {
        VARIANT_BOOL fDisabled;

        spElement = GetEditor()->GetSelectionManager()->GetEditableElement();
        
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isDisabled(&fDisabled));

        if (fDisabled)
            goto Cleanup;
    }

    //
    // Do verfication for the first segment - fail if invalid
    //

    IFC( spSegmentList->CreateIterator( &spIter ) );
    if (S_FALSE == spIter->IsDone() )
    {
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers(edStart, edEnd) );
        IFC( edStart->IsEqualTo(edEnd, &fRet) );
        if (fRet)
        {
            goto Cleanup;
        }

        if (!(GetEditor()->PointersInSameFlowLayout(edStart, edEnd, NULL)) )
        {
            goto Cleanup;
        }

        pCmd->cmdf = MSOCMDSTATE_UP;
    }

    
Cleanup:
    ReleaseInterface(pEditor);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\delcmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       DELCMD.CXX
//
//  Contents:   Implementation of Delete command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include <wchdefs.h>
#endif

using namespace EdUtil;

//
// Externs
//

MtDefine(CDeleteCommand, EditCommand, "CDeleteCommand");


//+---------------------------------------------------------------------------
//
//  CDeleteCommand private method: IsLaunderChar( ch )
//  Is the ch a character we launder when we launder spaces?
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsLaunderChar ( TCHAR ch )
{
    return    _T(' ')  == ch
           || _T('\t') == ch
           || WCH_NBSP == ch;
}

BOOL
CDeleteCommand::IsInPre( IMarkupPointer  * pStart, IHTMLElement ** ppPreElement )
{
    BOOL                fMatch = FALSE;
    IHTMLElement    *   pNextElement = NULL ;
    HRESULT             hr   = S_OK;
    ELEMENT_TAG_ID      eTag = TAGID_NULL ;
    IMarkupServices   * pMarkupServices = GetMarkupServices();

    IFC( pStart->CurrentScope( ppPreElement ) );
    if (! *ppPreElement)
    {
        // Scope is NULL, must be a TXTSLAVE
        return TRUE;
    }

    while ( ! fMatch && *ppPreElement )
    {
        IFC( pMarkupServices->GetElementTagId( *ppPreElement, & eTag) );

        switch ( eTag )
        {
        case TAGID_PRE :
        case TAGID_PLAINTEXT :
        case TAGID_LISTING :
        case TAGID_XMP :
        case TAGID_TEXTAREA:
        case TAGID_INPUT: 
            fMatch = TRUE;
            break;
        }

        GetEditor()->GetParentElement( (*ppPreElement), &pNextElement );
        ReplaceInterface( ppPreElement, pNextElement );
        ClearInterface( & pNextElement );
    }

Cleanup:
    if (! fMatch)
        ClearInterface( ppPreElement );
    return fMatch;
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::HasLayoutOrIsBlock()
//
// Synopsis:    Determine whether pIElement is a block element or has a layout
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::HasLayoutOrIsBlock( IHTMLElement * pIElement )
{
    BOOL    fIsBlockElement;
    BOOL    fHasLayout;

    IGNORE_HR(IsBlockOrLayoutOrScrollable(pIElement, &fIsBlockElement, &fHasLayout));

    return( fIsBlockElement || fHasLayout );
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::IsIntrinsicControl()
//
// Synopsis:    Determine whether pIElement is an intrinsic control (including INPUT)
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsIntrinsicControl( IHTMLElement * pHTMLElement )
{
    ELEMENT_TAG_ID  eTag;

    IGNORE_HR( GetMarkupServices()->GetElementTagId( pHTMLElement, & eTag) );

    switch (eTag)
    {
    case TAGID_BUTTON:
    case TAGID_TEXTAREA:
#ifdef  NEVER
    case TAGID_HTMLAREA:
#endif
    case TAGID_FIELDSET:
    case TAGID_LEGEND:
    case TAGID_MARQUEE:
    case TAGID_SELECT:
    case TAGID_INPUT:
        return TRUE;

    default:
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
// CDeleteCommand::SkipBlanks()
//
// Synopsis: Walks pPointerToMove in the appropriate direction until a block/layout
//           tag or a non-blank character is encountered. Returns the number of
//           characters crossed.
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::SkipBlanks( IMarkupPointer * pPointerToMove,
                            Direction        eDir,
                            long           * pcch )
{
    HRESULT             hr = S_OK;
    IHTMLElement      * pHTMLElement = NULL;
    long                cch;
    TCHAR               pch[ TEXTCHUNK_SIZE + 1 ]; 
    MARKUP_CONTEXT_TYPE context;
    SP_IMarkupPointer   spPointer;

    Assert( pcch );
    *pcch = 0;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ) );
    IFC( spPointer->MoveToPointer( pPointerToMove ) );

    for ( ; ; )
    {
        //
        // Move in the appropriate direction
        //
        cch = TEXTCHUNK_SIZE;
        ClearInterface( & pHTMLElement );
        if (eDir == LEFT)
        {
            IFC( spPointer->Left( TRUE, & context, & pHTMLElement, & cch, pch ) );
        }
        else
        {
            IFC( spPointer->Right( TRUE, & context, & pHTMLElement, & cch, pch ) );
        }

        switch( context )
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_NoScope:
                if ( HasLayoutOrIsBlock( pHTMLElement ) || IsIntrinsicControl( pHTMLElement ) )
                {
                    // we're done
                    goto Cleanup;
                }
                break;

            case CONTEXT_TYPE_Text:
            {
                //
                // Got some fresh text, look for white space pch using
                // the appropriate direction.
                //
                TCHAR * pchStart;
                long    iOffset;

                if ( eDir == RIGHT )
                {
                    // Left to right we go from beginning of pch to the end
                    for( pchStart = pch; pchStart < ( pch + cch ); pchStart++ )
                    {
                        if (! IsLaunderChar( * pchStart ) )
                        {
                            break;
                        }
                    }
                    iOffset = (pch + cch) - pchStart;
                }
                else
                {
                    // Right to left we go the other way around
                    for( pchStart = pch + (cch - 1); pchStart >= pch; pchStart-- )
                    {
                        if (! IsLaunderChar( * pchStart ) )
                        {
                            break;
                        }
                    }
                    iOffset = (pchStart + 1) - pch;
                }

                //
                // Check the offset of blanks
                //
                if (iOffset == cch)
                {
                    // First character was non-blank, we're done
                    goto Cleanup;
                }
                else if (iOffset == 0)
                {
                    // We got text which was all white space, update pPointerToMove
                    // and continue on...
                    IFC( pPointerToMove->MoveToPointer( spPointer ) );
                    *pcch += cch;
                }
                else
                {
                    // Position the pointer back to where the white space ends
                    if (eDir == LEFT)
                    {
                        IFC( spPointer->Right( TRUE, NULL, NULL, & iOffset, NULL ) );
                    }
                    else
                    {
                        IFC( spPointer->Left( TRUE, NULL, NULL, & iOffset, NULL ) );
                    }
                    //
                    // Update pPointerToMove  and we're done
                    //
                    IFC( pPointerToMove->MoveToPointer( spPointer ) );
                    *pcch += (cch - iOffset);
                    goto Cleanup;
                }
                break;
            }

            case CONTEXT_TYPE_None:
                goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CDeleteCommand::LaunderSpaces()
//
//  Synopsis:   Replace consecutive blanks resulted from delete or paste
//              operations into a blank and &NBSP's such that the blank 
//              sequence is properly preserved.
//
//----------------------------------------------------------------------------
HRESULT
CDeleteCommand::LaunderSpaces ( IMarkupPointer    * pStart,
                                IMarkupPointer    * pEnd )
{
    const TCHAR chNBSP  = WCH_NBSP;

    HRESULT     hr = S_OK;
    long        cch;
    long        cchCurrent;
    long        cchBlanks = 0;
    DWORD       dwBreak;
    TCHAR       pch[ TEXTCHUNK_SIZE + 1];
    BOOL        fFirstInBlock;
    BOOL        fResult;

    IMarkupServices   * pMarkupServices = GetMarkupServices();
    IMarkupPointer    * pLeft = NULL;
    IMarkupPointer    * pRight = NULL;
    IMarkupPointer    * pDeletionPoint = NULL;
    MARKUP_CONTEXT_TYPE context;
    CEditPointer        ePointer( GetEditor() );
    IHTMLElement      * pPreElement = NULL;

    if (! (pStart && pEnd) ) 
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( GetEditor()->CreateMarkupPointer( & pLeft ) );
    IFC( GetEditor()->CreateMarkupPointer( & pRight ) );

    IFC ( pStart->IsRightOf( pEnd, & fResult ) );
    if ( fResult )
    {
        IFC( pLeft->MoveToPointer(  pEnd ) );
        IFC( pRight->MoveToPointer( pStart ) );
    }
    else
    {
        IFC( pLeft->MoveToPointer(  pStart ) );
        IFC( pRight->MoveToPointer( pEnd ) );
    }

    IFC( pLeft->SetGravity( POINTER_GRAVITY_Right ) );

    //
    // If either end of the segment is in a pre formatted element, we're done
    //
    if ( IsInPre( pLeft, & pPreElement ) )
    {       
        goto Cleanup;
    }
    ClearInterface( & pPreElement );
    if ( IsInPre( pRight, & pPreElement ) )
    {       
        goto Cleanup;
    }

    //
    // Move pLeft left and pRight right while next to blanks
    //
    IFC( SkipBlanks( pLeft, LEFT, & cch ) );
    cchBlanks += cch;

    IFC( SkipBlanks( pRight, RIGHT, & cch ) );
    cchBlanks += cch;

    if (! cchBlanks)
    {
        // No blanks found, we're done
        goto Cleanup;
    }    

    //
    // Check whether pLeft is at the first blank of a block or layout element
    //
    IFC( ePointer.MoveToPointer( pLeft ) );
    IGNORE_HR( ePointer.Scan(  LEFT,
                    BREAK_CONDITION_Block |
                    BREAK_CONDITION_Site |
                    BREAK_CONDITION_Control |
                    BREAK_CONDITION_NoScopeBlock |
                    BREAK_CONDITION_Text ,
                    &dwBreak ) );

    fFirstInBlock = ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock  ) ||
                    ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitSite )   ||
                    ePointer.CheckFlag( dwBreak, BREAK_CONDITION_NoScopeBlock );
       
    if ( cchBlanks == 1 && !fFirstInBlock )
    {
        // We only have one blank and it's not at the beginning of a block
        goto Cleanup;
    }

    //
    // pLeft and pRight span consecutive blanks at this point, 
    // let's preserve the blanks now
    //
    
    IFC( GetEditor()->CreateMarkupPointer( & pDeletionPoint ) );
    IFC( pDeletionPoint->MoveToPointer( pLeft ) );    
  
    cchCurrent = 0;

    while ( cchBlanks )
    {       
        cch = 1;
        IFC( pDeletionPoint->Right( TRUE, & context, NULL, & cch, pch ) );
        switch ( context )
        {
        case CONTEXT_TYPE_Text:
            Assert ( cch == 1 );
            Assert ( IsLaunderChar( *pch ) );
            cchBlanks -= cch;
            cchCurrent++;
            
            if (*pch != chNBSP)
            {                
                if ( cchBlanks == 0                             // We're on the last white character
                     && !(cchCurrent == 1 && fFirstInBlock) )   // And it is not the first char in a block
                {
                    // Leave it alone, we're done
                    break;
                }

                *pch = chNBSP;
                IFC( GetEditor()->InsertMaximumText( pch, 1, pLeft ) );
                IFC( pMarkupServices->Remove( pLeft, pDeletionPoint ) );
            }
            break;

        case CONTEXT_TYPE_None:
            goto Cleanup;

        }

        // Catch up to the moving pointer
        IFC( pLeft->MoveToPointer( pDeletionPoint ) );
        
    }

Cleanup:
    ReleaseInterface( pLeft );
    ReleaseInterface( pRight );
    ReleaseInterface( pDeletionPoint );
    ReleaseInterface( pPreElement );
    RRETURN ( hr );
}

BOOL    
CDeleteCommand::IsMergeNeeded( IMarkupPointer * pStart, IMarkupPointer * pEnd )
{
    SP_IMarkupPointer   spPointer;
    CEditPointer        epAdjustedStart(GetEditor());
    CEditPointer        epAdjustedEnd(GetEditor());
    BOOL                fRightOrEqual = FALSE;
    BOOL                fMerger = FALSE;
    int                 iWherePointer;
    HRESULT             hr;
    DWORD               dwBreaks;
    DWORD               dwFound;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( spPointer->MoveToPointer( pStart ) );
    IFC( OldCompare( spPointer, pEnd, & iWherePointer ) );

    switch (iWherePointer)
    {
    case LEFT:
        //
        // We should not have pEnd to the left of pStart
        // otherwise we'll go to a loopus infinitus later
        //
        Assert( iWherePointer == RIGHT );
        goto Cleanup;

    case SAME:
        goto Cleanup;

    }

    //
    // Include phrase elements on the start so we don't miss block breaks
    //
    IFC( epAdjustedStart->MoveToPointer(spPointer) );
    IFC( epAdjustedStart.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( epAdjustedStart.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( spPointer->MoveToPointer(epAdjustedStart) );
 
    //
    // Omit phrase elements so we don't pick up block break characters between them.
    // For example: {epPointer}<<Block Break>></SPAN></B>{pEnd}.  We only want to 
    // pick up block breaks that span block elements
    //
    IFC( epAdjustedEnd->MoveToPointer(pEnd) );
    IFC( epAdjustedEnd.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );
    IFC( epAdjustedEnd.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );

    //
    // Walk pStart towards pEnd looking for block breaks. If a block break is 
    // crossed, merge is necessary.
    //

    for ( ; ; )
    {
        IFC( spPointer->IsRightOfOrEqualTo( epAdjustedEnd, & fRightOrEqual ) );
        if ( fRightOrEqual )
        {
            // We're done, no merger here
            break;            
        }       

        IFC( QueryBreaks(spPointer, & dwBreaks) ); 
        if ( dwBreaks & DISPLAY_BREAK_Block )
        {
            // We have a merger
            fMerger = TRUE;
            break;
        }        

        IFC( spPointer->Right( TRUE , NULL, NULL, NULL, NULL ) );
    }

Cleanup:
    return fMerger;
}


HRESULT 
CDeleteCommand::MergeDeletion( IMarkupPointer * pStart, IMarkupPointer * pEnd, BOOL fAdjustPointers )
{
    HRESULT             hr = S_OK;
    CEditPointer        ePointerStart( GetEditor() );
    CEditPointer        ePointerEnd  ( GetEditor() );
    IObjectIdentity * pIObj1 = NULL;
    IObjectIdentity * pIObj2 = NULL;
    IHTMLElement    * pHTMLElement1 = NULL;
    IHTMLElement    * pHTMLElement2 = NULL;
    DWORD             dwBreak;
    CBlockPointer       bp(GetEditor());
    
    if (! IsMergeNeeded( pStart, pEnd ) )
    {
        goto Cleanup;
    }

    // 
    // Before merging check whether we should delete an empty block,
    // rather than doing the full blown merge.
    //

    if ( fAdjustPointers )
    {
        IFC( ePointerStart.MoveToPointer( pStart ) );
        IGNORE_HR( ePointerStart.Scan(  LEFT,
                        BREAK_CONDITION_Block |
                        BREAK_CONDITION_Site |
                        BREAK_CONDITION_Control |
                        BREAK_CONDITION_Text |
                        BREAK_CONDITION_NoScopeSite |
                        BREAK_CONDITION_NoScopeBlock |
                        BREAK_CONDITION_BlockPhrase,
                        &dwBreak, & pHTMLElement1 ) );
    
        if ( ePointerStart.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) )
        {
            BOOL fEqual;

            IFC( ePointerEnd.MoveToPointer(pEnd) );

            IFC( ePointerStart.IsEqualTo(ePointerEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEqual) );

            if (fEqual)
            {
                IGNORE_HR( ePointerEnd.Scan(  RIGHT,
                                BREAK_CONDITION_Block |
                                BREAK_CONDITION_Site |
                                BREAK_CONDITION_Control |
                                BREAK_CONDITION_Text |
                                BREAK_CONDITION_NoScopeSite |
                                BREAK_CONDITION_NoScopeBlock |
                                BREAK_CONDITION_BlockPhrase,
                                &dwBreak, & pHTMLElement2 ) );

                if ( ePointerEnd.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) )
                {
                    IFC( pHTMLElement1->QueryInterface( IID_IObjectIdentity, (void **) & pIObj1 ));
                    IFC( pHTMLElement2->QueryInterface(IID_IObjectIdentity,  (void **) & pIObj2 ));
                    if ( pIObj1->IsEqualObject( pIObj2 ) == S_OK )
                    {
                        // Remove the block
                        IFC( 
                            GetMarkupServices()->Remove( (IMarkupPointer *) ePointerStart, 
                                                         (IMarkupPointer *) ePointerEnd ) );
                        goto Cleanup;
                    }   
                }
            }
        }
    }

    //
    // We may need to merge list containers.  Check for this case here.
    //

    IFC( bp.MoveTo(pStart, RIGHT) );
    if (bp.IsLeafNode())
    {
        IFC( bp.MoveToParent() );
    }

    if (bp.GetType() == NT_ListItem)
    {
        IFC( bp.MoveToParent() );
    }

    //
    // Do the merge
    //
    IFC( MergeBlock( pStart ) );

    //
    // Merge list containers.
    //

    if (bp.GetType() == NT_ListContainer)
    {
        IFC( bp.MergeListContainers(RIGHT) );
    }

Cleanup:
    ReleaseInterface( pHTMLElement1 );
    ReleaseInterface( pHTMLElement2 );
    ReleaseInterface( pIObj1 );
    ReleaseInterface( pIObj2 );
    return ( hr );
}


//+====================================================================================
//
// Method: AdjustOutOfBlock
//
// Synopsis: Move the given pointer out of a block while skipping any empty phrase elements.
//           This helper function is called by Delete when it is determined that a entire
//           block was selected for deletion. 
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::AdjustOutOfBlock ( IMarkupPointer * pStart, BOOL * pfDidAdjust )
{
    HRESULT             hr = S_OK;
    DWORD               dwBreakCondition;
    long                cch;
    CEditPointer        pointerStart ( GetEditor() );
    DWORD               dwBreakFor = BREAK_CONDITION_Block       | BREAK_CONDITION_EnterAnchor  | 
                                     BREAK_CONDITION_Text        | BREAK_CONDITION_Control      | 
                                     BREAK_CONDITION_NoScopeSite | BREAK_CONDITION_NoScopeBlock |
                                     BREAK_CONDITION_Site ;

    IFC( pointerStart->MoveToPointer( pStart ) );
    
    *pfDidAdjust = FALSE;

    IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, & dwBreakCondition  ) );

    if ( pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock ) )
    {
        *pfDidAdjust = TRUE;
        //
        // Here we also skip any phrase elements around the block we just exited
        //
        IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, & dwBreakCondition  ) );
        if (! pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
        {
            cch = 1;
            IFC( pointerStart.Move( RIGHT, TRUE, NULL, NULL, &cch, NULL ) );
        }
        //
        // Set pStart to pointerStart and we're done
        //
        IFC( pStart->MoveToPointer( pointerStart ) );
    }

Cleanup:
    RRETURN( hr );
}


//+====================================================================================
//
// Method: AdjustPointersForDeletion
//
// Synopsis: Move the given pointers out for a delete operation. This adjust stops at
//           blocks, and layouts, but will skip over "other" tags (ie character formatting).
//           This function also detects when an entire block is selected and adjusts the
//           left edge out of the block element to fully delete the block. 
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::AdjustPointersForDeletion ( IMarkupPointer* pStart, 
                                            IMarkupPointer* pEnd )
{
    HRESULT         hr = S_OK;
    DWORD           dwBreakCondition;
    long            cch;
    CEditPointer    pointerStart ( GetEditor() );
    CEditPointer    pointerEnd( GetEditor() );
    BOOL            fLeftFoundBlock;
    DWORD           dwBreakFor =    BREAK_CONDITION_EnterAnchor | BREAK_CONDITION_NoScopeBlock  |
                                    BREAK_CONDITION_Text        | BREAK_CONDITION_Control       |
                                    BREAK_CONDITION_Block       | BREAK_CONDITION_NoScopeSite   |
                                    BREAK_CONDITION_Site        | BREAK_CONDITION_Glyph         |
                                    BREAK_CONDITION_NoScope;
    // Position our edit pointers
    IFC( pointerStart.MoveToPointer( pStart ) );
    IFC( pointerEnd.MoveToPointer( pEnd ) );

    //
    // Scan left to skip phrase elements
    //
    IGNORE_HR( pointerStart.Scan( LEFT, dwBreakFor, &dwBreakCondition ) );

    fLeftFoundBlock = pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock );
    
    if (! pointerStart.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
    {
        // We went too far, move back once
        cch = 1;
        IFC( pointerStart.Move( RIGHT, TRUE, NULL, NULL, &cch, NULL ) );
    }

    // Update our start position
    IFC( pStart->MoveToPointer( pointerStart ) );
    
    //
    // Scan right.  If we hit exit a block, and our start pointer exited a block,
    // then we want to preserve the formatting of the end block being deleted.
    //
    IGNORE_HR( pointerEnd.Scan( RIGHT, dwBreakFor, &dwBreakCondition ) );

    if( pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitBlock ) && fLeftFoundBlock )
    {
        //
        // Save off this position, in case of failure
        //
        IFC( pointerStart.MoveToPointer( pointerEnd ) );

        // 
        // Reposition our end pointer at our original point, and look
        // for an exit phrase to indicate block level formatting
        //
        IFC( pointerEnd.MoveToPointer( pEnd ) );
        IFC( pointerEnd.Scan( RIGHT, dwBreakFor | BREAK_CONDITION_ExitPhrase, &dwBreakCondition ) );

        if( pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_ExitPhrase ) )
        {
            // Reposition just inside the phrase element
            IFC( pointerEnd.Scan(LEFT, BREAK_CONDITION_EnterPhrase, &dwBreakCondition) );
        }
        else
        {
            // We didn't find an exit phrase, we will return to our position
            // we saved before we looked for a phrase element.
            IFC( pointerEnd->MoveToPointer( pointerStart ) );

            // We went too far, move back once
            cch = 1;
            IFC( pointerEnd.Move( LEFT, TRUE, NULL, NULL, &cch, NULL ) );
        }
    }
    else if (! pointerEnd.CheckFlag( dwBreakCondition, BREAK_CONDITION_Boundary ) )
    {
        // We went too far, move back once
        cch = 1;
        IFC( pointerEnd.Move( LEFT, TRUE, NULL, NULL, &cch, NULL ) );
    }
    

    // Position our end pointer
    IFC( pEnd->MoveToPointer( pointerEnd ) );

Cleanup:
    RRETURN( hr );
}


//+====================================================================================
//
// Method: RemoveBlockIfNecessary
//
// When the left pointer is positioned at the beginning of a block and the right pointer 
// is after the end of the block, the entire block is to be deleted. Here we are detecting
// this case by walking left to right: if we enter a block before hitting the right
// pointer we bail, since this routine is being called after a call to Remove. 
// Otherwise we remove the block if we exit the scope of a block and hit the righthand pointer.
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::RemoveBlockIfNecessary( IMarkupPointer * pStart, IMarkupPointer * pEnd )
{
    IMarkupServices   * pMarkupServices  = GetMarkupServices();
    SP_IMarkupPointer   spPointer;
    MARKUP_CONTEXT_TYPE context;
    IHTMLElement *      pHTMLElement = NULL;            
    BOOL                fResult;
    HRESULT             hr = S_OK;
    BOOL                fExitedBlock = FALSE;
    BOOL                fDone = FALSE;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ) );    
    IFC( spPointer->MoveToPointer( pStart ) );

    while (! fDone)
    {
        ClearInterface( & pHTMLElement );
        IFC( spPointer->Right( TRUE, & context, & pHTMLElement, NULL, NULL ) );
        
        switch( context )        
        {
        case CONTEXT_TYPE_EnterScope:
            // If we entered a block, we're done
            IGNORE_HR(IsBlockOrLayoutOrScrollable(pHTMLElement, &fDone));
            break;

        case  CONTEXT_TYPE_ExitScope:
            // Track whether we have exited a block 
            if (! fExitedBlock)
            {
                IGNORE_HR(IsBlockOrLayoutOrScrollable(pHTMLElement, &fExitedBlock));
            }
            break;

        case CONTEXT_TYPE_None:
            fDone = TRUE;
            break;

        }

        if ( fDone )
            break;

        IFC( spPointer->IsRightOfOrEqualTo( pEnd, & fResult ) );
        if ( fResult )
        {
            if ( fExitedBlock )
            {
                //
                // We've reached the right end and have already exited a block
                // so move pStart out of the block
                //
                IFC( AdjustOutOfBlock( pStart, & fResult ) );
                if (! fResult)
                {
                    // Done
                    break;
                }
            
                //
                // Ask MarkupServices to remove the segment
                //
                IFC( pMarkupServices->Remove( pStart, pEnd ) );      
            }
            // We're done
            break;
        }       
    }

Cleanup:
    ReleaseInterface( pHTMLElement );
    RRETURN( hr );
}


HRESULT 
CDeleteCommand::RemoveEmptyListContainers(IMarkupPointer * pPointer)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    CBlockPointer       bpCurrent(GetEditor());

    IFR( pPointer->CurrentScope( &spElement ) );

    if( spElement )
    {
        IFR( bpCurrent.MoveTo(spElement) );

        if (bpCurrent.GetType() == NT_ListContainer)
        {
            SP_IMarkupPointer   spStart;
            SP_IMarkupPointer   spEnd;
            BOOL                fDone = FALSE;
            BOOL                fEqual;
            
            IFR( GetEditor()->CreateMarkupPointer(&spStart) );
            IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

            do
            {
                // If the list container is not empty, we're done
                IFR( bpCurrent.MovePointerTo(spStart, ELEM_ADJ_AfterBegin) );    
                IFR( bpCurrent.MovePointerTo(spEnd, ELEM_ADJ_BeforeEnd ) );    

                IFR( spStart->IsEqualTo(spEnd, &fEqual) );
                if (!fEqual)
                    break;
           
                // Remove list container and move to parent
                IFR( bpCurrent.GetElement(&spElement) );
            
                IFR( bpCurrent.MoveToParent() );
                fDone = (hr == S_FALSE); // done if no parent

                IFR( GetMarkupServices()->RemoveElement(spElement) );        
            }
            while (bpCurrent.GetType() == NT_ListContainer && !fDone);
        }
    }
    
    return S_OK;
}


//+====================================================================================
//
// Method: InflateBlock
//
// Synopsis: Sets the break on empty flag for a block element
//
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::InflateBlock( IMarkupPointer * pPointer )
{
    HRESULT         hr = S_OK;
    BOOL            fLayout;
    ELEMENT_TAG_ID  etagId;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spBlockElement;
    IMarkupServices * pMarkupServices = GetMarkupServices();

    IFR( pPointer->CurrentScope(&spElement) );

    if ( spElement )
    {
        IFR( GetEditor()->FindBlockElement( spElement, & spBlockElement ) );

        IFR( IsBlockOrLayoutOrScrollable(spElement, NULL, &fLayout) );
        if ( !fLayout )
        {
            IFR( pMarkupServices->GetElementTagId( spElement, &etagId ) );
            if ( !IsListContainer( etagId ) && etagId != TAGID_LI )
            {
                SP_IHTMLElement3 spElement3;
                IFR( spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFR( spElement3->put_inflateBlock( VARIANT_TRUE ) );
            }
        }
    }

    RRETURN( hr );
}


//+====================================================================================
//
// Method: Delete
//
// Synopsis: Given two MarkupPointers - delete everything between them
//
//------------------------------------------------------------------------------------

HRESULT 
CDeleteCommand::Delete ( IMarkupPointer* pStart, 
                         IMarkupPointer* pEnd,
                         BOOL fAdjustPointers /* = FALSE */ )
{
    HRESULT             hr = S_OK;
    int                 wherePointer = SAME;
    IMarkupServices   * pMarkupServices = GetMarkupServices();
    BOOL                fResult;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    CEditPointer        epStart(GetEditor());
    CEditPointer        epEnd(GetEditor());
    DWORD               dwFound;
    ELEMENT_TAG_ID      tagId;
    BOOL                fEqual;
    BOOL                fOkayForDeletion = TRUE;
    SP_IHTMLElement     spElement;

    //  Check for atomic deletions
    IFC( AdjustPointersForAtomicDeletion(pStart, pEnd, &fOkayForDeletion) );
    if (!fOkayForDeletion)
        goto Cleanup;

    //
    // First adjust the pointers out to skip phrase elements
    //
    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    if ( wherePointer == SAME )
        goto Cleanup;

    if ( fAdjustPointers )
    {
        if ( wherePointer == RIGHT )
        {
            IFC( AdjustPointersForDeletion( pStart, pEnd ) );
        }
        else
        {
            IFC( AdjustPointersForDeletion( pEnd, pStart ) );
        }
    }

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );
    
    if ( wherePointer == SAME )
        goto Cleanup;

    //
    // Ask MarkupServices to remove the segment
    //
    if ( wherePointer == RIGHT )
    {
        BOOL fCanRemove;

        //
        // Markup services will generate empty undo units, so make sure
        // we actually have something to remove.
        //
        IFC( CanRemove(pStart, pEnd, &fCanRemove) ); 
        if (fCanRemove)
        {
            IFC( pMarkupServices->Remove( pStart, pEnd ) );      
        }
    }
    else
    {
        BOOL fCanRemove;

        //
        // Markup services will generate empty undo units, so make sure
        // we actually have something to remove.
        //
        IFC( CanRemove(pEnd, pStart, &fCanRemove) ); 
        if (fCanRemove)
        {
            IFC( pMarkupServices->Remove( pEnd, pStart ) );
        }
    }

    //
    // Any elements left after the remove that have glyphs should be removed
    //
    IFC( DeleteGlyphElements(pStart, pEnd) );

    if (fAdjustPointers)
    {
        //
        // Detect if the entire block should be deleted, and if so delete the block
        //
        IFC( pStart->IsEqualTo( pEnd, & fResult ) ); // If equal we have nothing to do...
        if (! fResult)
        {
            if ( wherePointer == RIGHT )
            {
                IFC( RemoveBlockIfNecessary( pStart, pEnd ) );
            }
            else
            {
                IFC( RemoveBlockIfNecessary( pEnd, pStart ) );
            }
        }
    }

    //
    // Find the block elements for pStart and pEnd and set the
    // break on empty flag on them. 
    //
    IFC( InflateBlock( pStart ) );
    IFC( InflateBlock( pEnd ) );

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );
    switch ( wherePointer )
    {
        case RIGHT:
            IFC( MergeDeletion( pStart, pEnd, fAdjustPointers ));  
            break;
        case LEFT:
            IFC( MergeDeletion( pEnd, pStart, fAdjustPointers ));
            break;
    }

    //
    // If pStart or pEnd are within empty list containers, remove the list containers as well
    //
    IFC( RemoveEmptyListContainers( pStart ) );
    IFC( RemoveEmptyListContainers( pEnd ) );

    //
    // Remove double bullets if present
    //

    IFC( pStart->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }
    
    //
    // We don't want to delete all block elements in the body if we can avoid it.  Note, we only handle the
    // case where all content was deleted, i.e., pStart is equal to pEnd.
    //

    IFC( epStart->MoveToPointer(pStart) );
    IFC( epEnd->MoveToPointer(pEnd) );

    IFC( epStart.IsEqualTo(epEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEqual) );

    if (fEqual)
    {
        //
        // Check for exit body on the left
        //

        IFC( epStart.Scan(LEFT, BREAK_CONDITION_Content, &dwFound, NULL, &tagId) );
        if (epStart.CheckFlag(dwFound, BREAK_CONDITION_ExitSite) && tagId == TAGID_BODY)
        {
            //
            // Check for exit body on the right
            //

            IFC( epEnd.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound, NULL, &tagId) );
            if (epEnd.CheckFlag(dwFound, BREAK_CONDITION_ExitSite) && tagId == TAGID_BODY)
            {
                ELEMENT_TAG_ID  tagIdDefault;            
                SP_IHTMLElement spElement;

                //
                // Adjust for insertion
                //
                IFC( epStart.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
                IFC( epEnd.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

                //
                // Insert element
                //

                IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefault) )              
                IFC( GetMarkupServices()->CreateElement(tagIdDefault, NULL, &spElement) );

                IFC( InsertElement(GetMarkupServices(), spElement, epStart, epEnd) );
            }
        }
    }


    // Finally, launder spaces
    IFC( LaunderSpaces( pStart, pEnd ) );

    // fire the selectionchange event
    {
        CSelectionChangeCounter selCounter(GetEditor()->GetSelectionManager());
        selCounter.SelectionChanged();
    }
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  CDeleteCommand::IsValidOnControl
//
//----------------------------------------------------------------------------

BOOL CDeleteCommand::IsValidOnControl()
{
    HRESULT         hr;
    BOOL            bResult = FALSE;
    SP_ISegmentList spSegmentList;
    INT             iSegmentCount;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( GetSegmentCount(spSegmentList, &iSegmentCount ) );

    //
    // For compat we only allow multiple selection if the bit is set.
    //
    if(GetCommandTarget() == NULL) return FALSE;
    bResult = (iSegmentCount == 1) || 
              ( GetCommandTarget()->IsMultipleSelection() 
#ifdef FORMSMODE
                || GetEditor()->GetSelectionManager()->IsInFormsSelectionMode()
#endif
              ) ;

Cleanup:
    return bResult;
}

//+---------------------------------------------------------------------------
//
//  CDeleteCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::PrivateExec( 
                    DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn,
                    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IDisplayPointer      spDispCaret;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    IHTMLCaret             *pCaret = NULL;
    SELECTION_TYPE          eSelectionType;
    CEdUndoHelper           undoUnit(GetEditor());
    BOOL                    fEmpty = FALSE;
    
    //
    // Do the prep work
    //
    IFC( GetSegmentList( &spSegmentList ));   
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    
    // Create some markup pointers
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );
            
    if ( eSelectionType != SELECTION_TYPE_Caret )
    {
        //
        // Delete the segments
        //        
        if (fEmpty == FALSE)
        {       
            //
            // Begin the undo unit
            //
            IFC( undoUnit.Begin(IDS_EDUNDOTEXTDELETE) );        

            if (eSelectionType == SELECTION_TYPE_Control)
            {
                IFC (GetEditor()->RemoveElementSegments(spSegmentList));
            }
            else 
            {
                // Create an iterator
                IFC( spSegmentList->CreateIterator( &spIter ) );
            
                while( spIter->IsDone() == S_FALSE)
                {
                    // Get the current segment, and advance the iterator right away, 
                    // since we might blow away our segment in the delete call.
                    IFC( spIter->Current(&spSegment) );
                    IFC( spIter->Advance() );

                    IFC( spSegment->GetPointers( spStart, spEnd ) );

                    //
                    // This is an icky place to handle control-delete. I can't really think of
                    // another - short of having the delete command talk to the tracker.
                    //
                    if ( _cmdId == IDM_DELETEWORD && 
                         eSelectionType == SELECTION_TYPE_Text  )
                    {
                        // they're performing a control delete.
                        // Instead of using the start and end - the end is the word end from the start.
                        //
                        DWORD dwBreak = 0;
                    
                        CEditPointer blockScan( GetEditor());
                        blockScan.MoveToPointer( spEnd );
                        blockScan.Scan( RIGHT,
                                        BREAK_CONDITION_Block |
                                        BREAK_CONDITION_Site |
                                        BREAK_CONDITION_Control |
                                        BREAK_CONDITION_Text ,
                                        &dwBreak );

                        if ( blockScan.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                        {
                            //
                            // We use moveUnit instead of MoveWord - as MoveWord is only good to move
                            // to word beginnings. We want to do just like Word does - and really move
                            // to the word end.
                            //
                            IFC( spEnd->MoveToPointer( spStart ));
                            IFC( spEnd->MoveUnit(MOVEUNIT_NEXTWORDEND ));
                        }
                    }
                
                    //
                    // Cannot delete or cut unless the range is in the same flow layout
                    //
                    if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
                    {                 
                        IFC( Delete( spStart, spEnd, TRUE ) );
                    }
                }

                // ExitTree clears for siteselected elements, other cases handle here
                if ( !GetCommandTarget()->IsRange())
                {
                    GetEditor()->GetSelectionManager()->EmptySelection();
                }
            }
            {
                //
                // We want to set caret direction in any case
                //
                SP_IHTMLCaret   spCaret;
                IFC( GetDisplayServices()->GetCaret(&spCaret) );
                IFC( spCaret->SetCaretDirection(CARET_DIRECTION_BACKWARD) );
            }
        }
    }
    else
    {
        CSpringLoader     * psl = GetSpringLoader();
        MARKUP_CONTEXT_TYPE mctContext;
        long                cch = 2;
        BOOL                fCacheFontForLastChar = TRUE;
        SP_IDisplayPointer  spDispPointer;

        Assert(eSelectionType == SELECTION_TYPE_Caret);

        //
        // Handle delete at caret
        //
        IFC( undoUnit.Begin(IDS_EDUNDOTEXTDELETE) );        

        IFC( GetDisplayServices()->GetCaret( & pCaret ));
        IFC( pCaret->MoveMarkupPointerToCaret( spStart));

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( pCaret->MoveDisplayPointerToCaret(spDispCaret) );
        
        // Reset springloader.
        Assert(psl);
        psl->Reset();

        // Decide if springloader needs to preserve formatting of last character in block.
        fCacheFontForLastChar = _cmdId != IDM_DELETE
                             || S_OK != THR(spStart->Right(FALSE, &mctContext, NULL, &cch, NULL))
                             || mctContext != CONTEXT_TYPE_Text
                             || cch != 2;
        if (fCacheFontForLastChar)
        {
            IFC( psl->SpringLoad(spStart, SL_TRY_COMPOSE_SETTINGS) );
        }

        IFC( DeleteCharacter( spStart, FALSE, _cmdId == IDM_DELETEWORD,
                              GetEditor()->GetSelectionManager()->GetStartEditContext() ) );

        //
        // Set the caret to pStart
        // Note that this is the code path for forward delete only, backspace
        // is handled in HandleKeyDown()       
        CCaretTracker * pCaretTracker = (CCaretTracker *)GetEditor()->GetSelectionManager()->GetActiveTracker();
        Assert( pCaretTracker );       
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        IFC( spDispPointer->MoveToMarkupPointer(spStart, spDispCaret) );

        IFC( pCaretTracker->PositionCaretAt( spDispPointer, CARET_DIRECTION_BACKWARD, POSCARETOPT_None, ADJPTROPT_None ) );

        // If we didn't delete last character, we need to forget formatting by resetting springloader.
        if (   fCacheFontForLastChar
            && S_OK != psl->CanSpringLoadComposeSettings(spStart, NULL, FALSE, TRUE))
        {
            psl->Reset();
        }
    }

    GetEditor()->GetSelectionManager()->SetHaveTypedSinceLastUrlDetect(TRUE);

Cleanup:   
    ReleaseInterface( pCaret );
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CDeleteCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CDeleteCommand::PrivateQueryStatus( 
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr = S_OK;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );   
    VARIANT_BOOL            fEditable;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    SP_IHTMLElement3        spElement3;

    // 
    // Status is disabled by default
    //
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    //
    // Get Segment list and selection type
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ));

    //
    // If no segments found we're done
    //
    if( fEmpty )
    {
        goto Cleanup;
    }

    //
    // Get the segments and check to see if we're editable
    //

    if ( !GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC( GetEditor()->FindCommonParentElement( spSegmentList, &spElement));
        if (!spElement) 
            goto Cleanup;

        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isContentEditable(&fEditable));

        if (! fEditable)
            goto Cleanup;
    } 
    else if (eSelectionType == SELECTION_TYPE_Control)
    {
        if (!IsValidOnControl())
            goto Cleanup; // disable
    }   

    //
    // Cannot delete or cut unless the range is in the same flow layout
    //
    IFC( spSegmentList->CreateIterator(&spIter) );
    Assert(S_FALSE == spIter->IsDone());

    IFC( spIter->Current(&spSegment) );
    IFC( spSegment->GetPointers(edStart, edEnd) );
    if (!(GetEditor()->PointersInSameFlowLayout(edStart, edEnd, NULL)) )
    {
        goto Cleanup;
    }

    pCmd->cmdf = MSOCMDSTATE_UP;
 
Cleanup:
    RRETURN(hr);
}





//+------------------------------------------------------------------------------------
//
// Method: DeleteCharacter
//
// Synopsis: Delete one character or a NOSCOPE element in fLeftBound direction
//           used by backspace and delete.
//
// General Algorithm:
//      Peek fLeftBound, if context is:
//      - TEXT: call MoveUnit() if we have not crossed a block element
//      - NOSCOPE: move passed it and we're done
//      - NONE: we're done
//      - else move and continue to Peek fLeftBound
//------------------------------------------------------------------------------------

HRESULT
CDeleteCommand::DeleteCharacter( 
                 IMarkupPointer* pPointer, 
                 BOOL fLeftBound, 
                 BOOL fWordMode,
                 IMarkupPointer* pBoundary )
{
    HRESULT             hr;
    CEditPointer        ep(GetEditor());
    Direction           dir = fLeftBound ? LEFT : RIGHT;
    DWORD               dwOmitPhrase;
    DWORD               dwFound;
    SP_IHTMLElement     spElement;
    TCHAR               ch;
    BOOL                fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);
    CEditPointer        epLeft(GetEditor());
    CEditPointer        epRight(GetEditor());
    CEditPointer        epTest(GetEditor());
    BOOL                fContained;
    BOOL                fEmptyBlock;
    DWORD               dwPhrase;

    //
    // Look for content to delete
    //
    
    IFC( ep->MoveToPointer(pPointer) );

    dwOmitPhrase = BREAK_CONDITION_OMIT_PHRASE & (~BREAK_CONDITION_Anchor);
    dwPhrase = BREAK_CONDITION_ANYTHING - dwOmitPhrase;

    IFC( ep.Scan(dir, dwOmitPhrase | BREAK_CONDITION_Glyph, &dwFound, &spElement, NULL, &ch) );

    //
    // We only do glyph deletion if the element is not a block or layout element.
    //
    
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph))
    {
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block) || ep.CheckFlag(dwFound, BREAK_CONDITION_Site))
        {
            dwFound &= ~BREAK_CONDITION_Glyph;
        }           
    }

    //
    // Handle backspace/delete special cases
    //

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
    {        
        if (fWordMode)
        {
            CEditPointer        epNextWord(GetEditor());
            DWORD               dwScanOptions = SCAN_OPTION_None;
            BOOL                fSkipWhitespace = FALSE;
            
            //
            // Find the next word
            //
            
            IFC( epNextWord->MoveToPointer(pPointer) );
            IFC( epNextWord->MoveUnit(fLeftBound ? MOVEUNIT_PREVWORDBEGIN : MOVEUNIT_NEXTWORDEND) );

            //
            // If at a word boundary, we want to remove the whitespace
            // as well. (word 2k behavior)
            //
            // For example:
            //
            //  word0 {caret}word1 word2 --> DELETE --> word0 {caret}word2
            //  word0 w{caret}ord1 word2 --> DELETE --> word0 w{caret} word2            
            //
            //  word0 word1{caret} word2 --> BKSP   --> word0{caret} word2
            //  word0 word{caret}1 word2 --> BKSP   --> word0  {caret}1 word2
            //  

            IFC( epTest->MoveToPointer(pPointer) );

            if (fLeftBound)
            {
                IFC( epTest->MoveUnit(MOVEUNIT_PREVWORDEND) );
                IFC( epTest->MoveUnit(MOVEUNIT_NEXTWORDEND) );
            }
            else
            {
                IFC( epTest->MoveUnit(MOVEUNIT_NEXTWORDBEGIN) );
                IFC( epTest->MoveUnit(MOVEUNIT_PREVWORDBEGIN) );
            }

            IFC( epTest.IsEqualTo(pPointer, dwPhrase, &fSkipWhitespace) )

            if (fSkipWhitespace)
            {
                //
                //  #110445
                //  word0 word1{caret}<Boundary> -->BKSP --> word0 {caret}
                //
                //
                if (fLeftBound)
                {
                    Assert(LEFT == dir);
                    epTest.Scan(RIGHT, dwOmitPhrase, &dwFound);
                    if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
                    {
                        fSkipWhitespace = FALSE;
                    }
                }
                
                if (fSkipWhitespace)
                {
                    dwScanOptions |= SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP;

                    IFC( epNextWord.Scan(dir, dwOmitPhrase, &dwFound, NULL, NULL, NULL, dwScanOptions) );
                    IFC( epNextWord.Scan(Reverse(dir), dwOmitPhrase, &dwFound, NULL, NULL, NULL, dwScanOptions) );
                }
            }
            
            //
            // Clip to interesting content
            //

            IFC( ep.SetBoundaryForDirection(dir, epNextWord) );
            IFC( ep.Scan(dir, dwOmitPhrase - BREAK_CONDITION_Text, &dwFound) );
            if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            {
                IFC( ep.Scan(Reverse(dir), dwOmitPhrase - BREAK_CONDITION_Text, &dwFound) );
            }
        }
        else
        {
            //
            // NOTE (cthrash) For IE5.1, we've elected to leave the symantic of
            // MOVEUNIT_PREVCHAR/MOVEUNIT_NEXTCHAR unchanged, i.e. the method will
            // continue to move the markup pointer by one TCHAR.  This means that we
            // have the possibility of splitting a high/low surrogate pair.  It is up
            // to the consumer of these methods to prevent an improper splitting of
            // surrogates.
            //

            if (fLeftBound)
            {
                if (IsLowSurrogateChar(ch))
                {
                    LONG                cch = 1;
                    MARKUP_CONTEXT_TYPE context;
                    
                    IFC( ep->Left(FALSE, &context, NULL, &cch, &ch) );

                    Assert(context != CONTEXT_TYPE_Text || cch == 1);
                    
                    if (context == CONTEXT_TYPE_Text && IsHighSurrogateChar(ch))
                    {
                        Assert( cch==1 );
                        IFC( ep->Left(TRUE, NULL, NULL, &cch, NULL) );
                    }
                }
            }
            else
            {
                IFC( ep->MoveToPointer(pPointer) );
                IFC( ep->MoveUnit(MOVEUNIT_NEXTCLUSTEREND) );

                //
                // Cling to text since moveunit leaves us in some random location
                //
                IFC( ep.Scan(LEFT, dwOmitPhrase, &dwFound) );
                IFC( ep.Scan(RIGHT, dwOmitPhrase, &dwFound) );
            }
        }
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterSite))
    {
        Assert(spElement != NULL);

        //
        // Remove the entire site
        //
        
        IFC( ep->MoveAdjacentToElement(spElement, fLeftBound ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_ExitSite))
    {
        goto Cleanup; // Nothing to delete        
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block))
    {
        //
        // Group all block elements up to the next block break
        //

        IFC( FindContentAfterBlock(dir, ep) );

        //
        // Reset the spring loader since crossing block boundaries can but us in a different
        // kind of block element.
        //
        // For example: <P>foo<P><H1>{caret}bar</H1>
        //
        {
            CSpringLoader *psl = GetSpringLoader();

            if (psl)
                psl->Reset();
        }
    }
    else if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph))
    {
        Assert(spElement != NULL);

        //
        // Just remove the glyph element
        //
        IFC( GetMarkupServices()->RemoveElement(spElement) );
        goto Cleanup;        
    }
    
    //
    // Omit phrase on the left so that we handle empty line formatting properly
    // 

    IFC( epLeft->MoveToPointer((dir == LEFT) ? ep : pPointer) );
    IFC( epLeft.Scan(LEFT, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Phrase) );
    IFC( epLeft.Scan(RIGHT, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Phrase) );    

    //
    // Do the delete
    //

    if (dir == LEFT)
    {
        IFC( Delete(epLeft, pPointer, FALSE /* fAdjust */) );
    }
    else
    {
        IFC( Delete(epLeft, ep, FALSE /* fAdjust */) );
    }

    //
    // Clean up phrase elements 
    //

    IFC( epRight->MoveToPointer(fLeftBound ? pPointer : ep) );
    if (dir == RIGHT)
    {
        IFC( ep->MoveToPointer(pPointer) );    
    }

    IFC( ep.SetBoundaryForDirection(RIGHT, epRight) );

    //
    // Expand right and left boundaries to include all phrase elements
    //

    dwOmitPhrase |= BREAK_CONDITION_Glyph;

    IFC( epRight.Scan(RIGHT, dwOmitPhrase, &dwFound) );
    fEmptyBlock = epRight.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site);

    IFC( epRight.Scan(LEFT, dwOmitPhrase, &dwFound) );

    IFC( ep.Scan(LEFT, dwOmitPhrase, &dwFound) );
    Assert(!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));
    fEmptyBlock = fEmptyBlock && ep.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site);

    IFC( ep.Scan(RIGHT, dwOmitPhrase, &dwFound) );
    Assert(!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));

    //
    // Remove phrase elements
    //

    IFC( epLeft->MoveToPointer(ep) );

    //
    // We shouldn't remove empty line formatting
    //
    if (!fEmptyBlock)
    {
        do
        {
            IFC( ep.Scan(RIGHT, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor, &dwFound, &spElement) );

            if (ep.CheckFlag(dwFound, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor))
            {
                if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterPhrase | BREAK_CONDITION_EnterAnchor))
                {
                    IFC( epTest->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                    IFC( epTest->IsLeftOfOrEqualTo(epRight, &fContained) );
                }
                else
                {
                    IFC( epTest->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                    IFC( epTest->IsRightOfOrEqualTo(epLeft, &fContained) );
                }

                if (fContained)
                {
                    IFC( GetMarkupServices()->RemoveElement(spElement) );
                }
            }
            
        }
        while (!ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary));
    }

    //
    // Update the passed in pointer
    //

    IFC( pPointer->MoveToPointer(fLeftBound ? epLeft : epRight) );


Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   MergeBlock
//
//  Synopsis:   Does a block merge.  The content after the give block element
//              is merged with that block elements content.
//
//-----------------------------------------------------------------------------

HRESULT
CDeleteCommand::MergeBlock(IMarkupPointer *pPointerMerge)
{
    HRESULT             hr = S_OK;
    IMarkupContainer    *pMarkup = NULL;
    IHTMLElement        *pElementContainer = NULL;
    IHTMLElement        *pElementFlow = NULL;
    IMarkupPointer      *pPointer = NULL;
    IMarkupPointer      *p = NULL;
    IMarkupPointer      *p2 = NULL;
    IMarkupPointer      *pPointerStart = NULL;
    IMarkupPointer      *pPointerFinish = NULL;
    IMarkupPointer      *pPointerEnd = NULL;
    IHTMLElement        *pElementBlockMerge = NULL;
    IHTMLElement        *pElement = NULL;
    IHTMLElement        *pElement2 = NULL;
    BOOL                fFoundContent;
    IHTMLElement        *pElementBlockContent = NULL;
    int                 i;
    CStackPtrAry < IHTMLElement *, 4 > aryMergeLeftElems ( Mt( Mem ) );
    CStackPtrAry < IHTMLElement *, 4 > aryMergeRightElems ( Mt( Mem ) );
    CStackPtrAry < INT_PTR, 4 > aryMergeRightElemsRemove ( Mt( Mem ) );
    IObjectIdentity     *pElementContainerIdent = NULL;
    IObjectIdentity     *pIdent = NULL;
    CEditPointer        ep(GetEditor());
    DWORD               dwFound;
    
    IFC( GetEditor()->CreateMarkupPointer(&p) );
    IFC( GetEditor()->CreateMarkupPointer(&p2) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerEnd) );

#if DBG==1
    BOOL fDbgIsPositioned;
    
    Assert( pPointerMerge->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
#endif    

    IFC( pPointerMerge->GetContainer(&pMarkup) );

    //
    // The merge must be contained to certain elements.  For example, a TD
    // cannot be merged with stuff after it.
    //
    // Text sites are the limiting factor here.  Locate the element which
    // will contain the merge.  
    //

    IFC( pPointerMerge->CurrentScope(&pElement) );
    if (!pElement)
        goto Cleanup;
    
    IFC( GetFlowLayoutElement(pElement, &pElementContainer) );    
    if (!pElementContainer)
        goto Cleanup;

    IFC( pElementContainer->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pElementContainerIdent) );

    //
    // Locate the block element the merge pointer is currently in.  This
    // is the block element which will subsume the content to its right.
    //

    IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElementBlockMerge) );
    if (!pElementBlockMerge)
        goto Cleanup;

    //
    // Check that we have meaningful context to merge into.  For example, if we have
    // <P>foo</P>{Merge Block}<P>bar</P>, the merge will basically result in removing
    // the <P> and no visual difference.
    //

    IFC( ep->MoveToPointer(pPointerMerge) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( ep->MoveToPointer(pPointerMerge) );
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

        if (ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
        {
            // Merge won't do anything useful
            goto Cleanup;
        }
    }

    //
    // Search right looking for real content.  The result of this will
    // be the element under which this content exists.
    //

    IFC( pPointer->MoveToPointer(pPointerMerge) );
    fFoundContent = FALSE;    

    //
    // For exit glyph, the block break is positioned differently, so the standard
    // algorithm will not work.  So we special case it.
    //
    // no glyph: <P>{block break}</P><P>{block break}</P>
    //    glyph: <P></P>{block break}<P></P>
    //

    IFC( ep->MoveToPointer(pPointer) )
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content | BREAK_CONDITION_Glyph, &dwFound) );

    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Glyph)
        && ep.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock))
    {
        IFC( FindContentAfterBlock(RIGHT, ep) );
        IFC( pPointer->MoveToPointer(ep) );

        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
        
        fFoundContent = !ep.CheckFlag(dwFound, BREAK_CONDITION_ExitSite | BREAK_CONDITION_Error | BREAK_CONDITION_Boundary);
     
        if (fFoundContent)
        {
            SP_IHTMLElement spElement;

            //
            // Initialize vars needed below
            //

            IFC( pPointer->CurrentScope(&spElement) );
            Assert(spElement != NULL);

            IFC( SearchBranchForBlockElement(pMarkup, spElement, pElementContainer, &pElementBlockContent) );
            Assert(pElementBlockContent);
        }
    }
    else
    {
        for (;;)
        {
            DWORD dwBreaks;
            MARKUP_CONTEXT_TYPE ct;

            //
            // Make sure we are still under the influence of the container
            //

            ClearInterface(&pElement);        
            IFC( pPointer->CurrentScope(&pElement) );
            if (!pElement)
                break;

            ClearInterface(&pElementFlow);
            IFC( GetFlowLayoutElement(pElement, &pElementFlow) );    

            if (!pElementFlow)
                break;

            if (pElementContainerIdent->IsEqualObject(pElementFlow) != S_OK)
                break;

            //
            // Get the current block element
            //

            ClearInterface(&pElementBlockContent);
            IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElementBlockContent) );
            if (!pElementBlockContent)
                break;

            //
            // Get the current break
            //

            IFC( QueryBreaks(pPointer, &dwBreaks) );

            if (dwBreaks)
            {
                ClearInterface(&pIdent);
                IFC( pElementBlockContent->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
                
                if (pIdent->IsEqualObject(pElementBlockMerge) != S_OK)
                {
                    fFoundContent = TRUE;
                    break;
                }
            }
            //
            // See if there is content to the right
            //

            ClearInterface(&pElement);
            IFC( pPointer->Right(TRUE, & ct, &pElement, NULL, NULL) );

            if (ct == CONTEXT_TYPE_None)
                break;

            //
            //
            //

            if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
            {
                fFoundContent = TRUE;
                break;
            }
            else if (ct == CONTEXT_TYPE_EnterScope)
            {
                BOOL fBlock, fLayout;

                if (IsAccessDivHack(pElement))
                    break;
                
                //
                // If we find layout+block element, we can't merge anyway, so just
                // break and treat it as no content.
                //

                IFC( IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout) );
                
                if (fBlock && fLayout)
                    break;

                //
                // Embedded elements are considered as content
                //

                if (IsEmbeddedElement(pElement))
                {
                    fFoundContent = TRUE;
                
                    IFC( pPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

                    break;
                }

            }
        }
    }


    if (!fFoundContent)
        goto Cleanup;

    //
    // Now, locate the extent of this content under this element
    //

    IFC( pPointerEnd->MoveToPointer(pPointer) );

    for (;;)
    {
        DWORD dwBreaks;
        MARKUP_CONTEXT_TYPE ct;

        //
        // Make sure we are still under the influence of the container
        //

        ClearInterface(&pElement);        
        IFC( pPointer->CurrentScope(&pElement) );
        if (!pElement)
            break;

        ClearInterface(&pElementFlow);
        IFC( GetFlowLayoutElement(pElement, &pElementFlow) );    

        if (!pElementFlow)
            break;

        if (pElementContainerIdent->IsEqualObject(pElementFlow) != S_OK)
            break;

        //
        // Get the current block element
        //
        
        ClearInterface(&pElement2);        
        IFC( SearchBranchForBlockElement(pMarkup, pElement, pElementContainer, &pElement2) );
        if (!pElement2)
            break;
        ReplaceInterface(&pElement, pElement2);        
            
        ClearInterface(&pIdent);
        IFC( pElementBlockContent->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
        
        if (pIdent->IsEqualObject(pElement) != S_OK)
            break;

        //
        // Get the current break
        //

        IFC( QueryBreaks(pPointer, &dwBreaks) );

        if (dwBreaks)
        {
            IFC( pPointerEnd->MoveToPointer(pPointer) );
        }

        //
        // See if there is content to the right
        //

        ClearInterface(&pElement);
        IFC( pPointer->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        //
        //
        //

        if (ct == CONTEXT_TYPE_NoScope || ct == CONTEXT_TYPE_Text)
        {
            IFC( pPointerEnd->MoveToPointer(pPointer) );
        }
        else if (ct == CONTEXT_TYPE_EnterScope)
        {
            if (IsAccessDivHack(pElement))
                break;

            if (IsEmbeddedElement(pElement))
            {
                IFC( pPointerEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
                IFC( pPointer->MoveToPointer(pPointerEnd) );
            }
        }
        else if (ct == CONTEXT_TYPE_ExitScope)
        {
            if (!IsBlockElement(pElement) && !IsLayoutElement(pElement))
            {
                IFC( pPointerEnd->MoveToPointer(pPointer) );
            }
        }
    }

    //
    // Locate all the elements which will subsume content
    //

    ClearInterface(&pElement);
    IFC( pPointerMerge->CurrentScope(&pElement) );
    
    while (pElement)
    {        
        if (pElementContainerIdent->IsEqualObject(pElement) == S_OK)
            break;

        if (IsElementBlockInContext(pElementContainer, pElement))
        {
            pElement->AddRef();
            IFC( aryMergeLeftElems.Append(pElement) );
        }
        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    //
    // Locate all the elements which will loose content
    //

    ClearInterface(&pElement);
    IFC( pPointerEnd->CurrentScope(&pElement) );

    while (pElement)
    {        
        BOOL fHasContentLeftover;
        
        if (pElementContainerIdent->IsEqualObject(pElement) == S_OK)
            break;
    
        ClearInterface(&pIdent);
        IFC( pElementBlockMerge->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
        
        if (pIdent->IsEqualObject(pElement) == S_OK)
            break;
                    
        if (!IsElementBlockInContext(pElementContainer, pElement))
        {
            IFC( ParentElement(GetMarkupServices(), &pElement) );
            continue;
        }

        fHasContentLeftover = FALSE;
        
        IFC( p->MoveToPointer(pPointerEnd) );

        ClearInterface(&pIdent);
        IFC( pElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
            
        for ( ; ; )
        {
            MARKUP_CONTEXT_TYPE ct;
            
            ClearInterface(&pElement2);
            IFC( p->Right(TRUE, & ct, & pElement2, NULL, NULL) );

            if (ct == CONTEXT_TYPE_ExitScope && pIdent->IsEqualObject(pElement2) == S_OK)
                break;

            if (ct == CONTEXT_TYPE_Text)
            {
                fHasContentLeftover = TRUE;
                break;
            }
        }
        
        IFC( aryMergeRightElemsRemove.Append(!fHasContentLeftover) );
        pElement->AddRef();
        IFC( aryMergeRightElems.Append(pElement) );

        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    //
    // Now, move the end of the left elements to subsume the content
    //

    IFC( pPointerEnd->SetGravity(POINTER_GRAVITY_Right) );

    for ( i = 0 ; i < aryMergeLeftElems.Size() ; i++ )
    {
        BOOL            fRightOfOrEqualTo;
        IHTMLElement    *pElem = aryMergeLeftElems[i];

        //
        // Make sure we don't move an end tag to the left.
        //

        IFC( p2->MoveAdjacentToElement(pElem, ELEM_ADJ_BeforeEnd) );
        IFC( p2->IsRightOfOrEqualTo(pPointerEnd, &fRightOfOrEqualTo) );

        if (fRightOfOrEqualTo)
            continue;
        
        IFC( pPointerStart->MoveAdjacentToElement(pElem, ELEM_ADJ_BeforeBegin) );

        IFC( GetMarkupServices()->RemoveElement(pElem) );
        IFC( GetMarkupServices()->InsertElement(pElem, pPointerStart, pPointerEnd) );
    }

    // Release Elements
    for (i = 0; i < aryMergeLeftElems.Size(); i++ )
    {
        aryMergeLeftElems[i]->Release();
        aryMergeLeftElems[i] = NULL;        
    }

    //
    // Move the begin of the right elements to loose the content
    //

    IFC( pPointerEnd->SetGravity(POINTER_GRAVITY_Left) );

    for ( i = 0 ; i < aryMergeRightElems.Size() ; i++ )
    {
        IHTMLElement    *pElem = aryMergeRightElems[i];
        BOOL            fLeftOf;
            
        IFC( p2->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterBegin) );
        IFC( p2->IsLeftOfOrEqualTo(pPointerMerge, &fLeftOf) );
        if (fLeftOf)
            continue;
        
        IFC( pPointerFinish->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterEnd) );
        IFC( GetMarkupServices()->RemoveElement(pElem) );

        if (!aryMergeRightElemsRemove[i])
        {
            IMarkupPointer *p0 = pPointerEnd, *p1 = pPointerFinish;

            IFC( EnsureLogicalOrder(p0, p1) );
            IFC( GetMarkupServices()->InsertElement(pElem, p0, p1) );
        };
    }

    // Release elements
    for (i = 0; i < aryMergeRightElems.Size(); i++)
    {
        aryMergeRightElems[i]->Release();
        aryMergeRightElems[i] = NULL;
    }
    
    //
    // THe content which was "moved" may have \r or multiple spaces which are
    // not legal under the new context.  Sanitize this range.
    //
    
    IFC( SanitizeRange(pPointerMerge, pPointerEnd ) );

Cleanup:
    ReleaseInterface(pMarkup);
    ReleaseInterface(pElementContainer);
    ReleaseInterface(pElementFlow);
    ReleaseInterface(pPointer);
    ReleaseInterface(pPointerEnd);
    ReleaseInterface(pElementBlockMerge);
    ReleaseInterface(pElement);
    ReleaseInterface(pElement2);
    ReleaseInterface(pElementBlockContent);
    ReleaseInterface(pElementContainerIdent);
    ReleaseInterface(p);
    ReleaseInterface(p2);
    ReleaseInterface(pPointerStart);
    ReleaseInterface(pPointerFinish);
    ReleaseInterface(pIdent);
    
    RRETURN( hr );
}



//+----------------------------------------------------------------------------
//
//  Member:     GetFlowLayoutElement
//
//  Synopsis:   Searches the given branch for the first flow layout element,
//
//-----------------------------------------------------------------------------
HRESULT
CDeleteCommand::GetFlowLayoutElement(IHTMLElement *pElement, IHTMLElement **ppElementFlow)
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = pElement;

    Assert(pElement && ppElementFlow);

    pElemCurrent->AddRef();
    
    *ppElementFlow = NULL;
    do
    {
        if (IsLayoutElement(pElemCurrent))
        {
            *ppElementFlow = pElemCurrent;
            pElemCurrent->AddRef();
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );        
    }
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchForBlockElement
//
//  Synopsis:   Searches the given branch for the first block element,
//              starting from a given element.
//
//     Notes:   Stops searching after the CTxtSite goes out of scope.
//
//-----------------------------------------------------------------------------

HRESULT 
CDeleteCommand::SearchBranchForBlockElement 
(
    IMarkupContainer    *pMarkupContainer,
    IHTMLElement        *pElemStartHere,
    IHTMLElement        *pElemContext,
    IHTMLElement        **ppBlockElement)
{
    HRESULT         hr;
    IHTMLElement    *pElement = NULL;
    IHTMLElement    *pElemCurrent = NULL;
    IObjectIdentity *pIdent = NULL;

    Assert(pMarkupContainer && pElemStartHere && ppBlockElement);

    *ppBlockElement = NULL;
    
    if (!pElemContext)
    {
        IFC( GetElementClient(pMarkupContainer, &pElement) );
        if (pElement == NULL)
            goto Cleanup;

        pElemContext = pElement; // weak ref
    }

    IFC( pElemContext->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );

    ReplaceInterface(&pElemCurrent, pElemStartHere);
    do
    {        
        if (IsElementBlockInContext(pElemContext, pElemCurrent))
        {
            *ppBlockElement = pElemCurrent;
            pElemCurrent->AddRef();
            goto Cleanup;
        }

        if (pIdent->IsEqualObject(pElemCurrent) == S_OK)
            break;

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    while (pElemCurrent);
    
Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pIdent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsEmbeddedElement
//
//  Synopsis:   Intrinsic control and tables are special elements that we must
//              "jump over" while doing a block merge.
//
//-----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsEmbeddedElement(IHTMLElement *pElement)
{
    HRESULT           hr = S_OK;
    BOOL              fResult = FALSE;
    ELEMENT_TAG_ID    tagId;

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    switch (tagId)
    {
    case TAGID_BUTTON:
    case TAGID_TEXTAREA:
    case TAGID_INPUT:
    case TAGID_FIELDSET:
    case TAGID_LEGEND:
    case TAGID_MARQUEE:
    case TAGID_SELECT:
    case TAGID_TABLE:        
        fResult = TRUE;
        break;

    default:
        fResult = IsLayoutElement(pElement);
    }

Cleanup:
    return fResult;
}

//+----------------------------------------------------------------------------
//
//  Member:     ConvertShouldCrLf
//
//-----------------------------------------------------------------------------

HRESULT 
CDeleteCommand::ConvertShouldCrLf ( 
    IMarkupPointer *pmp, 
    BOOL &fShouldConvert )
{
    HRESULT         hr;
    IHTMLElement    *pElemCurrent = NULL;
    IHTMLElement3   *pElement3 = NULL;
    IObjectIdentity *pIdent = NULL;
    ELEMENT_TAG_ID  tagId;
    VARIANT_BOOL    fHTML;
    
    fShouldConvert = FALSE;

    Assert(pmp);

    IFC( pmp->CurrentScope(&pElemCurrent) );

    while (pElemCurrent)
    {        
        if (GetEditor()->IsContainer(pElemCurrent))
        {
            ClearInterface(&pElement3);
            IFC( pElemCurrent->QueryInterface(IID_IHTMLElement3, (LPVOID*)&pElement3) );
            IFC( pElement3->get_canHaveHTML(&fHTML) );
            fShouldConvert = BOOL_FROM_VARIANT_BOOL(fHTML);
            
            goto Cleanup;            
        }

        if (IsLiteral(pElemCurrent))
        {
            fShouldConvert = FALSE;
            goto Cleanup;
        }

        //
        // Special case for PRE because it is not marked as literal
        //

        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );
        if (tagId == TAGID_PRE)
        {
            fShouldConvert = FALSE;
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    
Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pElement3);
    ReleaseInterface(pIdent);
    RRETURN(hr);
}

HRESULT
CDeleteCommand::LaunderEdge (IMarkupPointer *pmp)
{
    HRESULT                hr = S_OK;
    IMarkupPointer         *pmpOther = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pmpOther) );

    IFC( pmpOther->MoveToPointer(pmp) );
    IFC( GetEditor()->LaunderSpaces(pmp, pmpOther) );

Cleanup:
    ReleaseInterface(pmpOther);
    
    RRETURN( hr );
}

HRESULT
CDeleteCommand::SanitizeCrLf (IMarkupPointer* pmp, long &cchAfter)
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *mp2 = NULL;
    IHTMLElement        *pElementNew = NULL;
    TCHAR               ch1, ch2;
    MARKUP_CONTEXT_TYPE ct;
    BOOL                fShouldConvert;
    long                cch;

    //
    // cchAfter is the numner of characters this member deals with after the
    // passed in pointer.
    //

    cchAfter = 0;

    //
    // First, determine the combination of CR/LF chars here
    //

    IFC( GetEditor()->CreateMarkupPointer(&mp2) );
    IFC( mp2->MoveToPointer(pmp) );

    IFC( mp2->Left(TRUE, &ct, NULL, &(cch=1), &ch1) );

    Assert( ct == CONTEXT_TYPE_Text && cch == 1 );
    Assert( ch1 == _T('\r') || ch1 == _T('\n') );

    IFC( pmp->Right(FALSE, &ct, NULL, &(cch=1), &ch2) );

    if (ct != CONTEXT_TYPE_Text || cch != 1)
        ch2 = 0;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
    {
        IFC( pmp->Right(TRUE, NULL, NULL, &(cch=1), NULL) );

        cchAfter++;
    }

    //
    // Now, the text between mp2 and pmp comprises a single line break.
    // Replace it with some marup if needed.
    //

    IFC( ConvertShouldCrLf(pmp, fShouldConvert) );

    if (fShouldConvert)
    {
        //
        // Remove the Cr/LF and insert a BR
        //

        IFC( GetMarkupServices()->Remove(mp2, pmp) );
        IFC( GetMarkupServices()->CreateElement(TAGID_BR, NULL, &pElementNew) );
        IFC( GetMarkupServices()->InsertElement(pElementNew, pmp, NULL) );
    }
    
Cleanup:

    ReleaseInterface(pElementNew);
    ReleaseInterface(mp2);

    RRETURN( hr );
}

HRESULT
CDeleteCommand::SanitizeRange (IMarkupPointer *pmpStart, IMarkupPointer *pmpFinish)
{
    HRESULT        hr = S_OK;
    IMarkupPointer *pmp = NULL;
    IMarkupPointer *pmpCRLF = NULL;
    IMarkupPointer *pmpBeforeSpace = NULL;
    IMarkupPointer *pmpAfterSpace = NULL;
    TCHAR *        pchBuff = NULL;
    long           cchBuff = 0;
    BOOL           fLeftOf;
    BOOL           fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    IFC( GetEditor()->CreateMarkupPointer(&pmp) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpCRLF) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpBeforeSpace) );
    IFC( GetEditor()->CreateMarkupPointer(&pmpAfterSpace) );

    IFC( pmp->MoveToPointer(pmpStart) );

    IGNORE_HR( pmp->SetGravity(POINTER_GRAVITY_Right) );

// move the start and finish out to catch adjacent space...
// --> instead, use launder spaces to deal with spaces at the edges of block element

    for (;;)
    {
        MARKUP_CONTEXT_TYPE ct;
        long                cch = cchBuff;
        long                ich;
        TCHAR *             pch;

        IFC( pmp->IsLeftOf(pmpFinish, &fLeftOf) );
        if (!fLeftOf)
            break;

        //
        // It is quite possible to process text AFTER pmpFinish.  This
        // should not be a problem, but if it is, I should add a feature
        // to the There member to stop at a give pointer.  THis may be difficult
        // in that unembedded pointers will have to be searched!
        //

        IFC( pmp->Right(TRUE, &ct, NULL, &cch, pchBuff) );

        if (ct != CONTEXT_TYPE_Text)
            continue;

        //
        // See if we were not able to get the entire run of text into the buffer
        //

        if (cch == cchBuff)
        {
            long cchMore = -1;
            
            IFC( pmp->Right(TRUE, &ct, NULL, &cchMore, NULL) );

            //
            // In order to know if we got all the text, we try to get one more
            // char than we know is there.
            //

            Assert( cchBuff <= cch + cchMore );

            delete pchBuff;

            pchBuff = new TCHAR [ cch + cchMore + 1 ];

            if (!pchBuff)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchBuff = cch + cchMore + 1;

            //
            // Now, move the pointer back and attempt to get the text again.
            //

            cchMore += cch;

            IFC( pmp->Left(TRUE, NULL, NULL, & cchMore, NULL) );

            continue;
        }

        //
        // Now, examine the buffer for CR/LF or adjacent spaces
        //

        for ( ich = 0, pch = pchBuff ; ich < cch ; ich++, pch++ )
        {
            TCHAR ch = *pch;
            
            if (ch == _T('\r') || ch == _T('\n'))
            {
                long cchMoveBack, cchAfter;

                IFC( pmpCRLF->MoveToPointer(pmp) );

                cchMoveBack = cch - ich - 1;

                IFC( pmpCRLF->Left(TRUE, NULL, NULL, & cchMoveBack, NULL) );                
                IFC( SanitizeCrLf(pmpCRLF, cchAfter) );

                ich += cchAfter;
                pch += cchAfter;
            }
            else if (ch == _T(' ') && ich + 1 < cch && *(pch + 1) == _T(' '))
            {
                BOOL fShouldConvert;
                
                IFC( ConvertShouldCrLf(pmp, fShouldConvert) );
                if (fShouldConvert)
                {
                    long           cchMoveBack;
                    TCHAR          cpSpace;

                    IFC( pmpAfterSpace->MoveToPointer(pmp) );

                    cchMoveBack = cch - ich - 1;

                    IFC( pmpAfterSpace->Left(TRUE, NULL, NULL, &cchMoveBack, NULL) );
                    IFC( pmpBeforeSpace->MoveToPointer(pmpAfterSpace) );

                    cchMoveBack = 1;

                    IFC( pmpBeforeSpace->Left(TRUE, NULL, NULL, & cchMoveBack, NULL) );

                    IFC( GetMarkupServices()->Remove(pmpBeforeSpace, pmpAfterSpace) );

                    cpSpace = WCH_NBSP;

                    IFC( GetMarkupServices()->InsertText(&cpSpace, 1, pmpBeforeSpace) );
                }
            }
        }
    }

    IFC( LaunderEdge(pmpStart) );
    IFC( LaunderEdge(pmpFinish) );

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    ReleaseInterface(pmp);
    ReleaseInterface(pmpCRLF);
    ReleaseInterface(pmpBeforeSpace);
    ReleaseInterface(pmpAfterSpace);
    delete[] pchBuff;

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   IsAccessDivHack
//
//  Synopsis:   Avoid merging the access magic div
//
//-----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsAccessDivHack(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;
    BSTR            bstrClass = NULL;
    BOOL            fResult = FALSE;

    if (!pElement)
        return FALSE;
    
    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    
    if (tagId != TAGID_DIV)
        return FALSE;

    IFC( pElement->get_className(&bstrClass) );
    if (!bstrClass)
        return FALSE;

    if (!StrCmpC(bstrClass, _T("MicrosoftAccessBanner")))
    {
        fResult = TRUE;
        goto Cleanup;
    }
    
    if (!StrCmpC(bstrClass, _T("MSOShowDesignGrid")))
    {
        fResult = TRUE;
        goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrClass);
    return fResult;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsLiteral
//
//    Synopsis:   Return whether the element is literal.
//
//    TODO: replace with public object model [ashrafm]
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsLiteral(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    Assert(pElement);

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    switch (tagId)
    {
        case TAGID_COMMENT:
        case TAGID_PLAINTEXT:
        case TAGID_SCRIPT:
        case TAGID_STYLE:
        case TAGID_TEXTAREA:
	case TAGID_INPUT:
        case TAGID_TITLE:
        case TAGID_XMP:
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsBlockElement
//
//    Synopsis:   Return whether the element is a block element.
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsBlockElement(IHTMLElement *pElement)
{
    HRESULT             hr;
    BOOL                fResult = FALSE;
    IHTMLCurrentStyle   *pCurStyle = NULL;
    IHTMLElement2       *pElement2 = NULL;
    BSTR                bstrDisplay = NULL;

    Assert(pElement);

    IFC( pElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElement2) );

    IFC( pElement2->get_currentStyle(&pCurStyle) );
    if (!pCurStyle)
        goto Cleanup;

    IFC(pCurStyle->get_display(&bstrDisplay));

    fResult = !_tcscmp(bstrDisplay, _T("block"));

Cleanup:
    ReleaseInterface(pCurStyle);
    ReleaseInterface(pElement2);
    SysFreeString(bstrDisplay);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsLayoutElement
//
//    Synopsis:   Return whether the element should have layout.
//
//----------------------------------------------------------------------------
BOOL
CDeleteCommand::IsLayoutElement(IHTMLElement *pElement)
{
    HRESULT             hr;
    VARIANT_BOOL        fResult = VB_FALSE;
    IHTMLCurrentStyle   *pCurStyle = NULL;
    IHTMLCurrentStyle2  *pCurStyle2 = NULL;
    IHTMLElement2       *pElement2 = NULL;

    IFC( pElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElement2) );

    IFC( pElement2->get_currentStyle(&pCurStyle) );
    if (!pCurStyle)
        goto Cleanup;

    IFC( pCurStyle->QueryInterface(IID_IHTMLCurrentStyle2, (void **)&pCurStyle2) );
    IFC( pCurStyle2->get_hasLayout(&fResult) );

Cleanup:
    ReleaseInterface(pCurStyle);
    ReleaseInterface(pCurStyle2);
    ReleaseInterface(pElement2);

    return fResult ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//    Member:     IsElementBlockInContext
//
//    Synopsis:    Return whether the element is a block in the current context
//                In general: Elements, if marked, are blocks and sites are not.
//                The exception is CFlowLayouts which are blocks when considered
//                from within themselves and are not when considered
//                from within their parent
//
//    Arguments:
//                [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//----------------------------------------------------------------------------

BOOL
CDeleteCommand::IsElementBlockInContext(IHTMLElement *pElemContext, IHTMLElement *pElement)
{
    HRESULT             hr;
    BOOL                fRet = FALSE;
    IObjectIdentity     *pIdent = NULL;
    BOOL                fContainer;
    BOOL                fBlockElement;

    IFC( pElemContext->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent) );
    if (pIdent->IsEqualObject(pElement) == S_OK)
    {
        fRet = TRUE;
        goto Cleanup;
    }

    fContainer = GetEditor()->IsContainer(pElement);
    fBlockElement = IsBlockElement(pElement);
    if (!fContainer && !fBlockElement)
    {
        fRet = FALSE;
        goto Cleanup;
    }

    if (!IsLayoutElement(pElement))
    {
        fRet = TRUE;
        goto Cleanup;
    }

    fRet = !fContainer;

    // TODO: talk to OM team about this method. [ashrafm]
    
Cleanup:
    ReleaseInterface(pIdent);
    
    return fRet;
}

HRESULT
CDeleteCommand::GetElementClient(
    IMarkupContainer    *pMarkupContainer,
    IHTMLElement        **ppElement)
{
    HRESULT             hr;
    IHTMLDocument2      *pDoc = NULL;
    IHTMLElement        *pElementClient = NULL;
    IMarkupContainer2   *pMarkupContainer2 = NULL;
    ELEMENT_TAG_ID      tagId;

    Assert(pMarkupContainer && ppElement);
    *ppElement = NULL;

    IFC( pMarkupContainer->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc) );

    IFC( pDoc->get_body(&pElementClient) );
    if (!pElementClient)
        goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId(pElementClient, &tagId) );   
    if (tagId == TAGID_BODY || tagId == TAGID_FRAMESET)
    {
        *ppElement = pElementClient;
        (*ppElement)->AddRef();
        goto Cleanup;
    }

    IFC( pMarkupContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&pMarkupContainer2) );    
    IFC( pMarkupContainer2->GetMasterElement(ppElement) );    

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pElementClient);
    ReleaseInterface(pMarkupContainer2);
    
    RRETURN(hr);   
}


//+----------------------------------------------------------------------------
//
//  Functions:  EnsureLogicalOrder 
//
//  Synopsis:   Ensure logical order
//
//-----------------------------------------------------------------------------
HRESULT
CDeleteCommand::EnsureLogicalOrder(IMarkupPointer* & pStart, IMarkupPointer* & pFinish )
{
    HRESULT     hr;
    BOOL        fRightOf;
    
    Assert( pStart && pFinish );

    IFC( pStart->IsRightOf(pFinish, &fRightOf) );

    if (fRightOf)
    {
        IMarkupPointer * pTemp = pStart;
        pStart = pFinish;
        pFinish = pTemp;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::QueryBreaks
//
//  Synopsis:   Ensure logical order
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::QueryBreaks(IMarkupPointer *pStart, DWORD *pdwBreaks)
{
    HRESULT            hr;
    SP_IDisplayPointer spDispPointer;

    Assert(pdwBreaks);

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispPointer->QueryBreaks(pdwBreaks) );

    if (!(*pdwBreaks))
    {
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        IFC( spDispPointer->QueryBreaks(pdwBreaks) );
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::DeleteGlyphElements
//
//  Synopsis:   Remove all elements with glyphs between pStart and pEnd
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::DeleteGlyphElements(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT         hr;
    CEditPointer    ep(GetEditor());
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    
    IFC( ep->MoveToPointer(pStart) );
    IFC( ep.SetBoundaryForDirection(RIGHT, pEnd) );

    for (;;)
    {
        IFC( ep.Scan(RIGHT, BREAK_CONDITION_Glyph, &dwFound, &spElement) );
        if (ep.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            break;

        if (!IsBlockElement(spElement) && !IsLayoutElement(spElement))
        {
            IFC( GetMarkupServices()->RemoveElement(spElement) );
        }
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::CanRemove
//
//  Synopsis:   Will markup services do anything here?  This
//              method is primarily used to avoid generating empty
//              undo units.
//
//-----------------------------------------------------------------------------
HRESULT 
CDeleteCommand::CanRemove(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL *pfCanRemove)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer, spEdge;
    MARKUP_CONTEXT_TYPE context;
    SP_IHTMLElement     spElement;
    BOOL                fDone;

    Assert(pfCanRemove);

    *pfCanRemove = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spEdge) );

    IFC( spPointer->MoveToPointer(pStart) );

    //
    // Markup services will fail to remove any content iff the range is
    // empty and contains only scoped elements that are not entirely contained.
    //

    for (;;)
    {
        IFC( spPointer->IsRightOfOrEqualTo(pEnd, &fDone) );
        if (fDone)
            goto Cleanup;

        IFC( spPointer->Right(TRUE, &context, &spElement, NULL, NULL) );

        switch (context)
        {
            case CONTEXT_TYPE_None:
                goto Cleanup; // done

            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_NoScope:
                *pfCanRemove = TRUE;
                goto Cleanup;
                
            case CONTEXT_TYPE_EnterScope:
                IFC( spEdge->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );
                IFC( spEdge->IsLeftOfOrEqualTo(pEnd, pfCanRemove) );
                if (*pfCanRemove)
                    goto Cleanup;
                break;

            case CONTEXT_TYPE_ExitScope:
                break; // don't need to check this, enterscope will get it

            default:
                AssertSz(0, "missing case");
        }
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CDeleteCommand::AdjustPointersForAtomicDeletion(IMarkupPointer *pStart,
                                                IMarkupPointer *pEnd,
                                                BOOL *pfOkayForDeletion)
{
    HRESULT             hr;
    int                 wherePointer = SAME;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spAtomicElement;
    BOOL                fStartAdjustedForAtomic = FALSE;
    BOOL                fEndAdjustedForAtomic = FALSE;

    Assert(pStart);
    Assert(pEnd);
    Assert(pfOkayForDeletion);
    *pfOkayForDeletion = TRUE;

    IFC( GetEditor()->CreateMarkupPointer(&spStart) );
    IFC( spStart->MoveToPointer(pStart) );

    IFC( GetEditor()->CreateMarkupPointer(&spEnd) );
    IFC( spEnd->MoveToPointer(pEnd) );

    //  Adjust for atomic objects.

    IFC( OldCompare( pStart, pEnd , & wherePointer ) );

    if (wherePointer == SAME)
    {
        IFC( pStart->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            IFC( spStart->MoveAdjacentToElement(spAtomicElement, ELEM_ADJ_BeforeBegin) );
            fStartAdjustedForAtomic = TRUE;

            IFC( spEnd->MoveAdjacentToElement(spAtomicElement, ELEM_ADJ_AfterEnd) );
            fEndAdjustedForAtomic = TRUE;
        }
    }
    else
    {
        IFC( pStart->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtBeforeEndOrAfterBegin = FALSE;
            BOOL                fStartPositioned = FALSE;

            //  Bug 101996: Two atomic elements are positioned next to each other.  If the cursor is positioned
            //  in between them and delete is pressed or we do a DeleteCharacter, both atomic elements will be
            //  deleted.  So, we need to see if the start pointer is at either the BeforeEnd or AfterBegin
            //  positions, depending on direction, of an atomic element.  If so, we need to position it at either
            //  the AfterEnd or BeforeBegin position depending on direction.  Otherwise the start pointer will
            //  be positioned at the beginning of the first atomic element.

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spAtomicElement ,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_BeforeEnd : ELEM_ADJ_AfterBegin ) );
            
            IFC( spTestPointer->IsEqualTo(spStart, &fAtBeforeEndOrAfterBegin) );
            if (fAtBeforeEndOrAfterBegin)
            {
                IFC( spStart->MoveAdjacentToElement( spAtomicElement,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ) );
                fStartPositioned = TRUE;
            }

            if (!fStartPositioned)
            {
                IFC( spStart->MoveAdjacentToElement( spAtomicElement ,
                                                    wherePointer ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
            }

            fStartAdjustedForAtomic = TRUE;
        }
        
        IFC( pEnd->CurrentScope(&spAtomicElement) );
        if ( GetEditor()->GetSelectionManager()->CheckAtomic( spAtomicElement ) == S_OK )
        {
            SP_IMarkupPointer   spTestPointer;
            BOOL                fAtAfterBeginOrBeforeEnd = FALSE;
            BOOL                fEndPositioned = FALSE;

            //  Bug 102000: Two atomic elements are positioned next to each other.  If the first atomic element
            //  is selected and a user types something, both atomic elements will be deleted.  So, we need to
            //  do a similar check as above to see if the end pointer is at the AfterBegin or BeforeEnd position.

            IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
            IFC( spTestPointer->MoveAdjacentToElement( spAtomicElement ,
                                                    (wherePointer == RIGHT) ? ELEM_ADJ_AfterBegin : ELEM_ADJ_BeforeEnd ) );
            
            IFC( spTestPointer->IsEqualTo(spEnd, &fAtAfterBeginOrBeforeEnd) );
            if (fAtAfterBeginOrBeforeEnd)
            {
                IFC( spEnd->MoveAdjacentToElement( spAtomicElement ,
                                                  wherePointer ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
                fEndPositioned = TRUE;
            }

            if (!fEndPositioned)
            {
                IFC( spEnd->MoveAdjacentToElement( spAtomicElement ,
                                                  wherePointer ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));
            }

            fEndAdjustedForAtomic = TRUE;
        }
    }

    if ( fStartAdjustedForAtomic || fEndAdjustedForAtomic )
    {
        if ( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            if (fStartAdjustedForAtomic)
            {
                IFC( pStart->MoveToPointer(spStart) );
            }
            if (fEndAdjustedForAtomic)
            {
                IFC( pEnd->MoveToPointer(spEnd) );
            }
        }
        else
        {
            *pfOkayForDeletion = FALSE;
        }
    }

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Functions:  CDeleteCommand::FindContentAfterBlock
//
//  Synopsis:   Move a markup pointer to the first content after the block
// 
//-----------------------------------------------------------------------------


HRESULT
CDeleteCommand::FindContentAfterBlock(Direction dir, IMarkupPointer *pPointer)
{
    HRESULT         hr;
    DWORD           dwBreaks;
    DWORD           dwFound;
    DWORD           dwPhrase;
    CEditPointer    epNext(GetEditor());
    
    dwPhrase = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content - BREAK_CONDITION_Glyph;

    IFC( epNext->MoveToPointer(pPointer) );

    for (;;)
    {
        IFC( epNext.Scan(dir, BREAK_CONDITION_ANYTHING, &dwFound) );

        //
        // Check for site or non-block
        //
        
        if (epNext.CheckFlag(dwFound, BREAK_CONDITION_Site)
            || epNext.CheckFlag(dwFound, BREAK_CONDITION_NoScopeSite)
            || !epNext.CheckFlag(dwFound, BREAK_CONDITION_Block | dwPhrase) )
        {
            break; // we're done
        }

        //
        // Commit
        //

        IFC( pPointer->MoveToPointer(epNext) );

        //
        // Check for block break
        //

        IFC( QueryBreaks(pPointer, &dwBreaks) ); 
        if ( dwBreaks & DISPLAY_BREAK_Block || dwBreaks & DISPLAY_BREAK_Break)
        {
            // 
            // Cling to the block element on the left so merge deletion works
            //
            if (epNext.CheckFlag(dwFound, dwPhrase))
            {
                IFC( epNext.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
                IFC( epNext.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

                IFC( pPointer->MoveToPointer(epNext) );
            }
            break;                             
        }
    }        

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\dlghelpr.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       DLGHELPR.CXX
//
//  Contents:   DlgHelpr OC which gets embedded in design time dialogs
//
//  Classes:    CHtmlDlgHelper
//
//  History:    12-Mar-98   raminh  Created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_DLGHELPR_H_
#define X_DLGHELPR_H_
#include "dlghelpr.h"
#endif

#ifndef X_EDCOM_HXX_
#define X_EDCOM_HXX_
#include "edcom.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

MtDefine(CHtmlDlgHelper, Utilities, "CHtmlDlgHelper")
MtDefine(CHtmlDlgSafeHelper, Utilities, "CHtmlDlgSafeHelper")

// Global variable used for retaining the save path
TCHAR       g_achSavePath[MAX_PATH + 1];

MtDefine(CFontNameOptions, Utilities, "CFontNameOptions")
MtDefine(CFontNameOptions_aryFontNames_pv, CFontNameOptions, "CFontNameOptions::_aryFontNames::_pv")


//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::length
//
//  Sysnopsis : IHtmlFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryFontNames.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}

//+---------------------------------------------------------------
//
//  Member  : CFontNameOptions::item
//
//  Sysnopsis : IHtmlFontNameCollection interface method
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::item(long lIndex, BSTR * pstrName)
{
    HRESULT   hr   = S_OK;

    if (!pstrName)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryFontNames.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = _aryFontNames[lIndex].AllocBSTR(pstrName);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Function:   get_document   
//
//  Synopsis:   Fetches the dialogs' document object, corresponds to document
//              property on the OC
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::get_document(LPDISPATCH * pVal)
{
    HRESULT hr;
    IHTMLDocument2 * pDoc = NULL;

    if (m_spClientSite)
    {
        hr = m_spClientSite->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc);
        *pVal = pDoc;
    }
    else
        *pVal = NULL;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   openfiledlg   
//
//  Synopsis:   Brings up the file open dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::openfiledlg(VARIANT initFile, VARIANT initDir, VARIANT filter, VARIANT title, BSTR * pathName)
{
    HWND            hwndDlg = NULL;
    HRESULT         hr = S_FALSE;

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hwndDlg );
    hr = THR(OpenSaveFileDlg( initFile, initDir, filter, title, pathName, FALSE, hwndDlg));
Cleanup:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Function:   savefiledlg   
//
//  Synopsis:   Brings up the file save dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::savefiledlg(VARIANT initFile, VARIANT initDir, VARIANT filter, VARIANT title, BSTR * pathName)
{
    HWND            hwndDlg = NULL;
    HRESULT         hr = S_FALSE;

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hwndDlg );
    hr = THR(OpenSaveFileDlg( initFile, initDir, filter, title, pathName, FALSE, hwndDlg));
Cleanup:
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   choosecolordlg   
//
//  Synopsis:   Brings up the color picker dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::choosecolordlg(VARIANT initColor, long * rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    VARIANT *       pvarRGBColor;
    DWORD           dwResult = 0; 
    VARIANTARG      varArgTmp;

    hr = THR ( VariantChangeTypeSpecial(&varArgTmp, &initColor, VT_I4));
    if (hr)
    {
        pvarRGBColor = NULL;
    }
    else
    {
        if (V_VT(&initColor) & VT_BYREF)
        {
            pvarRGBColor = V_VARIANTREF(&varArgTmp);
        }
        else
        {
            pvarRGBColor = &varArgTmp;
        }
    }

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hWndInPlace );

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = hWndInPlace;
    structCC.lpCustColors    = aCColors;
    
    if (pvarRGBColor)
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = V_I4(pvarRGBColor);
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    EnsureWrappersLoaded();
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:

    *rgbColor = dwResult;

    //RRETURN(SetErrorInfo( hr ));
    RRETURN( hr );
#endif // WINCE}
}


//+------------------------------------------------------------------------
//
//  Function:   InterfaceSupportsErrorInfo   
//
//  Synopsis:   Rich error support per ATL
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgHelper::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IHtmlDlgHelper,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//+----------------------------------------------------------------
//
//  Function : OpenSaveFileDlg
//
//  Synopsis : IHTMLOptionsHolder method. bring up open or save file dialog and 
//             returns the selected filename
//
//+----------------------------------------------------------------
#define VERIFY_VARARG_4BSTR(arg, var)           \
    switch(V_VT(&arg))                          \
    {                                           \
    case    VT_BSTR:                            \
        var = &arg;                             \
        break;                                  \
    case    VT_BYREF|VT_BSTR:                   \
        var = V_VARIANTREF(&arg);               \
        break;                                  \
    default:                                    \
        var = NULL;                             \
    }

HRESULT
CHtmlDlgHelper::OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, VARIANTARG filter, VARIANTARG title, BSTR *pathName, BOOL fSaveFile, HWND hwndInPlace)
{
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    VARIANT *       pvarInitFile;
    VARIANT *       pvarInitDir;
    VARIANT *       pvarFilter;
    VARIANT *       pvarTitle;
    OPENFILENAME    ofn;
    HRESULT         hr = E_INVALIDARG;
    BSTR            bstrFile = 0;
    TCHAR           *pstrExt;
    TCHAR           achPath[MAX_PATH + 1];

    VERIFY_VARARG_4BSTR(initFile, pvarInitFile);
    VERIFY_VARARG_4BSTR(initDir, pvarInitDir);
    VERIFY_VARARG_4BSTR(filter, pvarFilter);
    VERIFY_VARARG_4BSTR(title, pvarTitle);

    bstrFile = SysAllocStringLen(NULL, MAX_PATH);
    if (bstrFile == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    else
    {
        hr = S_OK;
    }

    if (pvarInitFile)
    {
        _tcsncpy(bstrFile, V_BSTR(pvarInitFile), MAX_PATH);
        bstrFile[MAX_PATH + 1] = _T('\0');
    }
    else
    {
        *bstrFile = _T('\0');
    }

    Assert(hwndInPlace);
    // Initialize ofn struct
    memset(&ofn, 0, sizeof(ofn));
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hwndInPlace;
    ofn.Flags           =   OFN_FILEMUSTEXIST   |
                            OFN_PATHMUSTEXIST   |
                            OFN_OVERWRITEPROMPT |
                            OFN_HIDEREADONLY    |
                            OFN_NOCHANGEDIR     |
                            OFN_EXPLORER;
                            // no readonly checkbox, per request

    ofn.lpfnHook        = NULL;
    ofn.lpstrFile       = bstrFile;      // file name buffer
    ofn.nMaxFile        = MAX_PATH + 1;  // file name buffer size
    
    if (pvarInitDir)
    {
        ofn.lpstrInitialDir = V_BSTR(pvarInitDir);
    }

    if (pvarFilter)
    {
        BSTR    bstrFilter = V_BSTR(pvarFilter);
        TCHAR   *cp;

        for ( cp = bstrFilter; *cp; cp++ )
        {
            if ( *cp == _T('|') )
            {
                *cp = _T('\0');
            }
        }
        ofn.lpstrFilter = bstrFilter;
    }

    if (pvarTitle)
    {
        ofn.lpstrTitle = V_BSTR(pvarTitle);
    }

    //
    // Find the extension and set the filter index based on what the
    // extension is.  After these loops pstrExt will either be NULL if
    // we didn't find an extension, or will point to the extension starting
    // at the '.'

    pstrExt = bstrFile;
    
    while (*pstrExt)
        pstrExt++;

    while ( pstrExt > bstrFile )
    {
        if( *pstrExt == _T('.') )
            break;
        pstrExt--;
    }

    if( pstrExt > bstrFile )
    {
        int    iIndex = 0;
        const TCHAR* pSearch = ofn.lpstrFilter;

        while( pSearch )
        {
            if( wcsstr ( pSearch, pstrExt ) )
            {
                ofn.nFilterIndex = (iIndex / 2) + 1;
                ofn.lpstrDefExt = pstrExt + 1;

                // Remove the extension from the file name we pass in
                *pstrExt = _T('\0');

                break;
            }

            pSearch += _tcslen(pSearch);
            
            if( pSearch[1] == 0 )
                break;

            pSearch++;
            iIndex++;
        }
    }

    _tcscpy(achPath, g_achSavePath);
    ofn.lpstrInitialDir = *achPath ? achPath : NULL;

    DbgMemoryTrackDisable(TRUE);

    // Call function
    fOK = (fSaveFile ? GetSaveFileName : GetOpenFileName)(&ofn);

    DbgMemoryTrackDisable(FALSE);

    if (!fOK)
    {
        SysFreeString(bstrFile);
        bstrFile = NULL;
#ifndef WINCE
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
#else //WINCE
        hr = E_FAIL;
#endif //WINCE
    }
    else
    {
        _tcscpy(g_achSavePath, ofn.lpstrFile);
        
        TCHAR * pchShortName =_tcsrchr(g_achSavePath, _T('\\'));

        if (pchShortName)
        {
            *(pchShortName + 1) = 0;
        }
        else
        {
            *g_achSavePath = 0;
        }
        hr = S_OK;
    }

Cleanup:
    *pathName = bstrFile;

    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   GetCharacterSet
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
GetCharacterSet(BSTR fontName, long * charset)
{
    HRESULT         hr = S_OK;
    LOGFONT         lf;
    UINT            uintResult = 0;
    HDC             hdc = NULL;
    HFONT           hfont = NULL, hfontOld = NULL;

    if (!charset)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *charset = 0;

    hdc = ::GetDC(NULL);
    if (!hdc)
        goto Cleanup;

    memset(&lf, 0, sizeof(lf));

    lf.lfCharSet = DEFAULT_CHARSET;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality  = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
    
    // If fontName is too long, we have to shorten it.
    _tcsncpy(lf.lfFaceName, fontName, LF_FACESIZE - 1);
    
    hfont = CreateFontIndirect(&lf);
    if (!hfont)
        goto Cleanup;

    hfontOld = (HFONT) SelectObject(hdc, hfont);
    if (!hfontOld)
        goto Cleanup;

    uintResult = GetTextCharset(hdc);

    *charset = uintResult;

Cleanup:

    if (hfontOld)
    {
        SelectObject(hdc, hfontOld);
    }

    if (hfont)
    {
        DeleteObject(hfont);
    }
    
    if (hdc)
    {
        ::ReleaseDC(NULL, hdc);
    }
    RRETURN( SetErrorInfo( hr ) );
}


//+------------------------------------------------------------------------
//
//  Function:   getCharset
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
CHtmlDlgHelper::getCharset(BSTR fontName, long * charset)
{
    RRETURN( GetCharacterSet(fontName, charset) );
}

//+-------------------------------------------------------------------
//
//  Callbacks:   GetFont*Proc
//
//  These procedures are called by the EnumFontFamilies and EnumFont calls.
//  It fills the combobox with the font facename and the size
//
//--------------------------------------------------------------------

int CALLBACK
GetFontNameProc(LOGFONT FAR    * lplf,
                TEXTMETRIC FAR * lptm,
                int              iFontType,
                LPARAM           lParam)
{
    // Do not show vertical fonts
    if (lParam && lplf->lfFaceName[0] != _T('@'))
        ((CFontNameOptions *)lParam)->AddName(lplf->lfFaceName);

    return TRUE;
}

//+----------------------------------------------------------------
//
//  member : DTOR
//
//+----------------------------------------------------------------

CFontNameOptions::~CFontNameOptions()
{
    CStr *  pcstr;
    long    i;

    for (i = _aryFontNames.Size(), pcstr = _aryFontNames;
         i > 0;
         i--, pcstr++)
    {
        pcstr->Free();
    }

    _aryFontNames.DeleteAll();
}

//+---------------------------------------------------------------
//
//  Member  : AddName
//
//  Sysnopsis : Helper function that takes a font name from the font
//      callback and adds it to the cdataary.
//
//----------------------------------------------------------------

HRESULT
CFontNameOptions::AddName(TCHAR * strFontName)
{
    HRESULT hr = S_OK;
    long    lIndex;
    long    lSizeAry = _aryFontNames.Size();

    // does this name already exist in the list
    for (lIndex = 0; lIndex < lSizeAry ; lIndex++)
    {
        if (_tcsiequal(strFontName, _aryFontNames[lIndex]))
            break;
    }

    // Not found, so add element to array.
    if (lIndex == lSizeAry)
    {
        CStr *pcstr;

        hr = THR(_aryFontNames.AppendIndirect(NULL, &pcstr));
        if (hr)
            goto Cleanup;

        hr = pcstr->Set(strFontName);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
CHtmlDlgHelper::get_fonts(IHtmlFontNamesCollection ** ppFontCollection)
{
    HRESULT hr = S_OK;
    HWND    hWndInPlace;
    HDC     hdc;
    LOGFONT lf;

    if (!ppFontCollection)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFontCollection = NULL;

    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CComObject<CFontNameOptions>;
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pFontNameObj->AddRef();
        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        m_spInPlaceSite->GetWindow(&hWndInPlace);

        hdc = ::GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ::ReleaseDC(hWndInPlace, hdc);
        }
    }

    // QI for an interface to return
    hr = THR_NOTRACE(_pFontNameObj->QueryInterface(
                                    IID_IHtmlFontNamesCollection,
                                    (void**)ppFontCollection));

    // We keep an additional ref because we cache the name collection obj

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

VOID            
CHtmlDlgHelper::EnsureWrappersLoaded()
{
    static fLoaded = FALSE;

    if (!fLoaded)
    {
        InitUnicodeWrappers();
        fLoaded = TRUE;
    }
}


CHtmlDlgSafeHelper::~CHtmlDlgSafeHelper()
{
    //  Destroy our internal font object
    ReleaseInterface(_pFontNameObj);

    //  Destroy our internal block formats object
    if (V_VT(&_varBlockFormats) != VT_NULL)
    {
        // This better be a safearray
        Assert(V_VT(&_varBlockFormats) == VT_ARRAY);
        SafeArrayDestroy(V_ARRAY(&_varBlockFormats));
    }
    VariantClear(&_varBlockFormats);
}

//+------------------------------------------------------------------------
//
//  Function:   choosecolordlg   
//
//  Synopsis:   Brings up the color picker dialog
//
//-------------------------------------------------------------------------
STDMETHODIMP 
CHtmlDlgSafeHelper::choosecolordlg(VARIANT initColor, VARIANT* rgbColor)
{
#ifdef WINCE
    return S_OK;
#else
    int             i;
    BOOL            fOK;
    DWORD           dwCommDlgErr;
    CHOOSECOLOR     structCC;
    HRESULT         hr = E_INVALIDARG;
    HWND            hWndInPlace;
    COLORREF        aCColors[16];
    DWORD           dwResult = 0; 
    IOleWindow      *pWindow = NULL;
    CColorValue     ccolor(&initColor);

    Assert(m_spInPlaceSite != NULL);
    if (!m_spInPlaceSite)
        goto Cleanup;

    m_spInPlaceSite->GetWindow( &hWndInPlace );

    for (i = ARRAY_SIZE(aCColors) - 1; i >= 0; i--)
    {
        aCColors[i] = RGB(255, 255, 255);
    }

    // Initialize ofn struct
    memset(&structCC, 0, sizeof(structCC));
    structCC.lStructSize     = sizeof(structCC);
    structCC.hwndOwner       = hWndInPlace;
    structCC.lpCustColors    = aCColors;
    
    if (ccolor.IsDefined())
    {
        structCC.Flags          = CC_RGBINIT;
        structCC.rgbResult      = ccolor.GetOleColor();
        dwResult                = structCC.rgbResult;
    }
    else
    {
        dwResult = RGB(0,0,0);
    }

    // Call function
    EnsureWrappersLoaded();
    fOK = ChooseColor(&structCC);

    if (fOK)
    {
        hr = S_OK;
        dwResult = structCC.rgbResult;
    }
    else
    {
        dwCommDlgErr = CommDlgExtendedError();
        if (dwCommDlgErr)
        {
            hr = HRESULT_FROM_WIN32(dwCommDlgErr);
            goto Cleanup;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:
    if (hr == S_OK)
    {
        V_VT(rgbColor) = VT_I4;
        V_I4(rgbColor) = dwResult;
        EdUtil::ConvertOLEColorToRGB(rgbColor);
    }

    ReleaseInterface(pWindow);

    RRETURN( hr );
#endif // WINCE}
}

//+------------------------------------------------------------------------
//
//  Function:   getCharset
//
//  Synopsis:   Obtains a character-set identifier for the font that 
//              is currently selected 
//
//-------------------------------------------------------------------------

HRESULT
CHtmlDlgSafeHelper::getCharset(BSTR fontName, VARIANT* charset)
{
    HRESULT     hr = S_OK;
    long        lCharset;

    hr = GetCharacterSet(fontName, &lCharset);

    if (hr == S_OK)
    {
        V_VT(charset) = VT_I4;
        V_I4(charset) = lCharset;
    }

    RRETURN( hr );
}

//+----------------------------------------------------------------
//
//  member : fonts
//
//  Synopsis : IHTMLOptionsHolder Property. returns an Ole collection of
//      BSTR of the available fonts
//
//+----------------------------------------------------------------

HRESULT
CHtmlDlgSafeHelper::get_Fonts(LPDISPATCH *pcol)
{
    HRESULT             hr = S_OK;
    HWND                hWndInPlace;
    HDC                 hdc;
    LOGFONT             lf;

    CComObject<CFontNames> *pIFontNames;

    Assert(pcol);

    memset(&lf, 0, sizeof(LOGFONT));
    lf.lfCharSet = DEFAULT_CHARSET;

    // make sure we've got a font options collection
    if (!_pFontNameObj)
    {
        _pFontNameObj = new CComObject<CFontNameOptions>;
        if (!_pFontNameObj)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pFontNameObj->AddRef();
        _pFontNameObj->SetSize(0);

        // load it with the current system fonts
        m_spInPlaceSite->GetWindow(&hWndInPlace);

        hdc = ::GetDC(hWndInPlace);
        if (hdc)
        {
            EnumFontFamiliesEx(hdc,
                               &lf,
                               (FONTENUMPROC) GetFontNameProc,
                               (LPARAM)_pFontNameObj,
                               NULL);
            ::ReleaseDC(hWndInPlace, hdc);
        }
    }

    // Create an instance of our class
    IFC( CComObject<CFontNames>::CreateInstance(&pIFontNames) );

    // Initialize the class with the font names
    IFC( pIFontNames->Init( _pFontNameObj ) );

    // Retrieve the correct interface, and return it
    IFC( pIFontNames->QueryInterface(IID_IDispatch, (void **)pcol) );

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

VOID            
CHtmlDlgSafeHelper::EnsureWrappersLoaded()
{
    static fLoaded = FALSE;

    // TODO: protect with a critical section

    if (!fLoaded)
    {
        InitUnicodeWrappers();
        fLoaded = TRUE;
    }
}

HRESULT
CHtmlDlgSafeHelper::get_BlockFormats(LPDISPATCH *pcol)
{
    HRESULT             hr = S_OK;
    IOleCommandTarget   *pCommandTarget = NULL;
    IOleClientSite      *pClientSite = NULL;
    IOleContainer       *pContainer = NULL;

    CComObject<CBlockFormats> *pIBlockFormats = NULL;

    Assert(pcol);

    if (V_VT(&_varBlockFormats) == VT_NULL)
    {
        // Find our IOleCommandTarget so that we can call the GetBlockFormats command
        // on the editor
        hr = m_spInPlaceSite->QueryInterface(IID_IOleClientSite, (void **)&pClientSite);
        if (hr == S_OK && pClientSite)
            hr = pClientSite->GetContainer(&pContainer);
        if (hr == S_OK && pContainer)
            hr = pContainer->QueryInterface(IID_IOleCommandTarget, (void **)&pCommandTarget);

        if ( hr == S_OK && pCommandTarget)
        {
            // Get the block formats
            hr = THR( pCommandTarget->Exec(
                    (GUID *)&CGID_MSHTML,
                    IDM_GETBLOCKFMTS,
                    MSOCMDEXECOPT_DONTPROMPTUSER,
                    NULL,
                    &_varBlockFormats));
        }
    }
    
    if (OK(hr) && V_ARRAY(&_varBlockFormats) != NULL)
    {
        // Create an instance of our class
        IFC( CComObject<CBlockFormats>::CreateInstance(&pIBlockFormats) );

        // Initialize the class with the block formats
        IFC( pIBlockFormats->Init( V_ARRAY(&_varBlockFormats) ) );

        // Retrieve the correct interface, and return it
        IFC( pIBlockFormats->QueryInterface(IID_IDispatch, (void **)pcol) );
    }

Cleanup:
    ReleaseInterface(pCommandTarget);
    ReleaseInterface(pContainer);
    ReleaseInterface(pClientSite);

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::~CFontNames
//
//  Synopsis:   Clean up our array
//
//  Arguments:  NONE
//
//  Returns:    NONE
//
//--------------------------------------------------------------------------
CFontNames::~CFontNames()
{
    for (int i = _lCount-1; i >= 0; i--)
    {
        VariantClear(&_paryFontNames[i]);
    }
    if( _paryFontNames )
        delete [] _paryFontNames;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::get__NewEnum
//
//  Synopsis:   Returns an enumerator object which can be used to enumerate
//              over the font names.  Allows VBScript and JScript
//              clients to enumerate the contents using the for each statement
//              and the Enumerator object respectively.
//
//  Arguments:  ppEnum = OUTPUT - pointer to enumerator object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::get__NewEnum(/*[out, retval]*/ LPUNKNOWN *ppEnum)
{
    HRESULT     hr;

    if(ppEnum == NULL)
      return E_POINTER;
      
    *ppEnum = NULL;

    // Use the STL CComEnum class to implement our enumerator.  We are going 
    // to be enumerating and copying variants
    typedef CComEnum<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, _Copy<VARIANT> > EnumVar;
    CComObject<EnumVar>  *pEnum;

    // Create our enumerator
    IFC( CComObject<EnumVar>::CreateInstance(&pEnum) );

    // AddRef pEnum so we can release it and free the resources if something goes wrong
    if(pEnum)pEnum->AddRef();

    // Initialize the enumerator with this data, AtlFlagCopy is used
    // to make a copy of the data with _Copy<VARIANT>::copy().  Note that
    // the second parameter is a pointer to the next item AFTER the last
    // item in our array.
    IFC( pEnum->Init(&_paryFontNames[0], &_paryFontNames[GetCount()], NULL, AtlFlagCopy) );

    // An IUnknown pointer is required so use QueryInterface() which also
    // calls AddRef().
    IFC( pEnum->QueryInterface(IID_IUnknown, (void **)ppEnum) );

Cleanup:
    if(pEnum)pEnum->Release();
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::get_Count
//
//  Synopsis:   Returns the number of font names
//
//  Arguments:  plCount = OUTPUT - pointer to count
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::get_Count(/*[out, retval]*/ long *plCount)
{
    if( plCount == NULL )
        return E_POINTER;

    Assert( IsInitialized() );

    *plCount = GetCount();
    
    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::Item
//
//  Synopsis:   Returns the specific font name requested.  We only support
//              retrieval by integer based index.
//
//  Arguments:  pvarIndex = Index to retrieve
//              pbstrFontName = OUTPUT - pointer to BSTR for font name
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::Item(/*[in]*/ VARIANT *pvarIndex, /*[out, retval]*/ BSTR *pbstrFontName)
{
    if( (pbstrFontName == NULL) || (pvarIndex == NULL) )
        return E_POINTER;
        
    Assert( IsInitialized() );

    // VB6 will pass an VT_I2, but I also allow VT_I4 too
    if( (V_VT( pvarIndex ) == VT_I2) || (V_VT(pvarIndex) == VT_I4) )
    {
        int nIndex;

        // VB Arrays are 1 based
        nIndex = (V_VT(pvarIndex) == VT_I2) ? V_I2(pvarIndex) - 1 : V_I4(pvarIndex) - 1;

        // Check that a valid index is passed 
        if( (nIndex >= GetCount()) || (nIndex < 0) )
            return E_INVALIDARG;

        *pbstrFontName = SysAllocString(V_BSTR(&_paryFontNames[nIndex]));
    }

    RRETURN(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFontNames::Init
//
//  Synopsis:   Initializes the block formats collection.  Takes an
//              array of font names and creates a collection.
//
//  Arguments:  pFontNameObj = our font names
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CFontNames::Init( CFontNameOptions *pFontNameObj )
{
    HRESULT hr = S_OK;
    LONG    lCount = 0;
    LONG    lIndex = 0;
    LONG    lActualIndex = 0;
    BSTR    bstrFontName;
    

    Assert(pFontNameObj);

    // Find out how many fonts we have in the array
    IFC( pFontNameObj->get_length(&lCount) );
    Assert(lCount);
    
    // If array is not empty we'll need to create our internal array
    if (lCount)
    {
        // Create our array and store this data
        _paryFontNames = new CComVariant[ lCount ];
        if( !_paryFontNames )
            goto Error;

        for( lIndex = 0; lIndex < lCount; lIndex++ )
        {
            if (pFontNameObj->item(lIndex, &bstrFontName) == S_OK)
            {
                V_VT(&_paryFontNames[lActualIndex]) = VT_BSTR;
                V_BSTR(&_paryFontNames[lActualIndex++]) = bstrFontName;
            }
        }
        Assert(lCount == lActualIndex);
    }
    _lCount = lActualIndex;
    
    SetInitialized(TRUE);

Cleanup:
    RRETURN(hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\dlghelpr.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  Class:      CHtmlDlgHelper
//
//  Contents:   DlgHelpr OC which gets embedded in design time dialogs
//
//  History:    12-Mar-98   raminh  Created
//----------------------------------------------------------------------------
#ifndef _DLGHELPR_H_
#define _DLGHELPR_H_

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H
#include "resource.h"    
#endif

MtExtern(CHtmlDlgHelper)
MtExtern(CHtmlDlgSafeHelper)

#define SetErrorInfo( x )   x

MtExtern(CFontNameOptions)
MtExtern(CFontNameOptions_aryFontNames_pv)

#define _hxx_
#include "mshtmext.hdl"

EXTERN_C const IID LIBID_MSHTML;

class ATL_NO_VTABLE CFontNameOptions : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CFontNameOptions, &IID_IHtmlFontNamesCollection>,
    public IDispatchImpl<IHtmlFontNamesCollection, &IID_IHtmlFontNamesCollection, &LIBID_OPTSHOLDLib>
{
public:
    CFontNameOptions()  { }
    ~CFontNameOptions();
    
    DECLARE_REGISTRY_RESOURCEID(IDR_FONTSOPTION)
    DECLARE_NOT_AGGREGATABLE(CFontNameOptions)

    BEGIN_COM_MAP(CFontNameOptions) 
        COM_INTERFACE_ENTRY(IHtmlFontNamesCollection)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    // IHtmlFontNamesCollection
	STDMETHOD(get_length)(/*[retval, out]*/ long * p);
	STDMETHOD(item)(/*[in]*/ long index, /*[retval, out]*/ BSTR* pBstr);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CFontNameOptions));

    // helper and builder functions
    HRESULT   AddName (TCHAR * strFontNamee);
    void      SetSize(long lSize) { _aryFontNames.SetSize(lSize); };

private:
    DECLARE_CDataAry(CAryFontNames, CStr, Mt(Mem), Mt(CFontNameOptions_aryFontNames_pv))
    CAryFontNames _aryFontNames;
};


class ATL_NO_VTABLE CHtmlDlgHelper :
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHtmlDlgHelper,&CLSID_HtmlDlgHelper>,
    public CComControl<CHtmlDlgHelper>,
    public IDispatchImpl<IHtmlDlgHelper, &IID_IHtmlDlgHelper, &LIBID_OPTSHOLDLib>,
    public IOleControlImpl<CHtmlDlgHelper>,
    public IOleObjectImpl<CHtmlDlgHelper>,
    public IOleInPlaceActiveObjectImpl<CHtmlDlgHelper>,
    public IOleInPlaceObjectWindowlessImpl<CHtmlDlgHelper>,
    public ISupportErrorInfo
{
public:
    CHtmlDlgHelper()
    {
    	Assert(_pFontNameObj == NULL); // zero based allocator
    }

    ~CHtmlDlgHelper()
    {
    	ReleaseInterface(_pFontNameObj);
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_HTMLDLGHELPER)

    BEGIN_COM_MAP(CHtmlDlgHelper) 
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHtmlDlgHelper)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP()

    BEGIN_MSG_MAP(CHtmlDlgHelper)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    END_MSG_MAP()

    // ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IHtmlDlgHelper
    STDMETHOD(get_fonts)(/*[retval, out]*/ IHtmlFontNamesCollection* * p);
    STDMETHOD(getCharset)(/*[in]*/ BSTR fontName,/*[retval, out]*/ long* charset);
    STDMETHOD(choosecolordlg)(/*[optional, in]*/ VARIANT initColor,/*[retval, out]*/ long* rgbColor);
    STDMETHOD(savefiledlg)(/*[optional, in]*/ VARIANT initFile,/*[optional, in]*/ VARIANT initDir,/*[optional, in]*/ VARIANT filter,/*[optional, in]*/ VARIANT title,/*[retval, out]*/ BSTR* pathName);
    STDMETHOD(openfiledlg)(/*[optional, in]*/ VARIANT initFile,/*[optional, in]*/ VARIANT initDir,/*[optional, in]*/ VARIANT filter,/*[optional, in]*/ VARIANT title,/*[retval, out]*/ BSTR* pathName);
    STDMETHOD(get_document)(/*[out, retval]*/ LPDISPATCH *pVal);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmlDlgHelper));

private:
    VOID        EnsureWrappersLoaded();	

    HRESULT     OpenSaveFileDlg( VARIANTARG initFile, VARIANTARG initDir, 
                                 VARIANTARG filter, VARIANTARG title, 
                                 BSTR *pathName, BOOL fSaveFile, HWND hwndInPlace);

    CComObject<CFontNameOptions> * _pFontNameObj;   // pointer to font name object
};


//+---------------------------------------------------------------------------
//
//  CFontNames Class -- A collection of font names
//
//----------------------------------------------------------------------------

class ATL_NO_VTABLE CFontNames : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public IDispatchImpl<IFontNames, &IID_IFontNames, &LIBID_MSHTML, 4, 0>
{
public:

    CFontNames()
    {
    	_bInitialized = FALSE;
    	_lCount = 0;
    	_paryFontNames = NULL;
    }

    ~CFontNames();
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CFontNames)
        COM_INTERFACE_ENTRY(IFontNames)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

public:
    //
    // IFontNames Interface
    //
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppEnum);
    STDMETHOD(get_Count)(long *plCount);
    STDMETHOD(Item)(VARIANT *pvarIndex, BSTR *pbstrFontNames);

    //
    // Initialization
    //
    HRESULT Init( CFontNameOptions *pFontNameObj );

    //
    // Accessors
    //
    long        GetCount(void)                  { Assert(IsInitialized()); return _lCount; }
    void        SetCount(long lCount)           { _lCount = lCount; }

    BOOL        IsInitialized(void)             { return _bInitialized; }
    void        SetInitialized(BOOL bInit)      { _bInitialized = bInit; }
    
private:

    BOOL        _bInitialized;              // Have we been successfully initialized?
    long        _lCount;                    // Number of font names
    CComVariant *_paryFontNames;         	// Array of font names
};


class ATL_NO_VTABLE CHtmlDlgSafeHelper : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CHtmlDlgSafeHelper, &CLSID_HtmlDlgSafeHelper>,
    public CComControl<CHtmlDlgSafeHelper>,
    public IDispatchImpl<IHtmlDlgSafeHelper, &IID_IHtmlDlgSafeHelper, &LIBID_MSHTML, 4, 0>,
    public IOleControlImpl<CHtmlDlgSafeHelper>,
    public IOleObjectImpl<CHtmlDlgSafeHelper>,
    public IOleInPlaceActiveObjectImpl<CHtmlDlgSafeHelper>,
    public IOleInPlaceObjectWindowlessImpl<CHtmlDlgSafeHelper>,
    public IObjectSafetyImpl<CHtmlDlgSafeHelper>
{
public:
    CHtmlDlgSafeHelper()
    {
    	Assert(_pFontNameObj == NULL); // zero based allocator
        VariantInit(&_varBlockFormats);
        V_VT(&_varBlockFormats) = VT_NULL;
    }

    ~CHtmlDlgSafeHelper();

    DECLARE_REGISTRY_RESOURCEID(IDR_HTMLDLGSAFEHELPER)
    DECLARE_NOT_AGGREGATABLE(CHtmlDlgSafeHelper)

    BEGIN_COM_MAP(CHtmlDlgSafeHelper) 
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IHtmlDlgSafeHelper)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
        COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
        COM_INTERFACE_ENTRY_IMPL(IOleControl)
        COM_INTERFACE_ENTRY_IMPL(IOleObject)
        COM_INTERFACE_ENTRY_IMPL(IObjectSafety)
    END_COM_MAP()

    BEGIN_MSG_MAP(CHtmlDlgSafeHelper)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
        MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    END_MSG_MAP()

    // IHtmlDlgSafeHelper
    STDMETHOD(get_Fonts)(/*[retval, out]*/ LPDISPATCH *pcol);
    STDMETHOD(getCharset)(/*[in]*/ BSTR fontName,/*[retval, out]*/ VARIANT* charset);
    STDMETHOD(choosecolordlg)(/*[optional, in]*/ VARIANT initColor,/*[retval, out]*/ VARIANT* rgbColor);
    STDMETHOD(get_BlockFormats)(/*[retval, out]*/ LPDISPATCH *pcol);

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmlDlgSafeHelper));

private:
    VOID        EnsureWrappersLoaded();	

    CComObject<CFontNameOptions> * _pFontNameObj;   // pointer to font name object
    VARIANT                        _varBlockFormats;    // contains a safearray of block formats
};

#endif //_DLGHELPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\dlgcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CDialogCommand, EditCommand, "CDialogCommand")

//
// s_dlgInfo[] table provides the required mapping between IDM's for supported dialogs
// and their corresponding resource id as well as undo text.
//

static const struct DialogInfo
{
    UINT    idm;
    UINT    idsUndoText;
    TCHAR * szidr;
}
s_dlgInfo[] =
{
    {IDM_REPLACE,       IDS_EDUNDOGENERICTEXT,   IDR_REPLACEDIALOG},
    {IDM_PARAGRAPH,     IDS_EDUNDOGENERICTEXT,   IDR_FORPARDIALOG},
    {IDM_FONT,          IDS_EDUNDOGENERICTEXT,   IDR_FORCHARDIALOG},
    {IDM_IMAGE,         IDS_EDUNDONEWCTRL,       IDR_INSIMAGEDIALOG},
    {IDM_HYPERLINK,     IDS_EDUNDOGENERICTEXT,   IDR_EDLINKDIALOG}
    // Not implemented in IE40
    //{IDM_GOTO,          0,                     IDR_GOBOOKDIALOG},
    //{IDM_BOOKMARK,      IDS_UNDOGENERICTEXT,   IDR_EDBOOKDIALOG},
};

//
// Forward references
//

HRESULT LoadProcedure(DYNPROC *pdynproc);

void DeinitDynamicLibraries();

//+---------------------------------------------------------------------------
//
//  CDialogCommand Constructor
//
//----------------------------------------------------------------------------

CDialogCommand::CDialogCommand(DWORD cmdId, CHTMLEditor * ped ) : CCommand( cmdId, ped )
{
}


//+---------------------------------------------------------------------------
//
//  CDialogCommand Destructor
//
//----------------------------------------------------------------------------

CDialogCommand::~CDialogCommand()
{
}

//+---------------------------------------------------------------------------
//
//  CDialogCommand Exec
//
//----------------------------------------------------------------------------

HRESULT 
CDialogCommand::PrivateExec( DWORD nCmdexecopt,
                  VARIANTARG * pvarargIn,
                  VARIANTARG * pvarargOut )
{
    HRESULT         hr = OLECMDERR_E_NOTSUPPORTED;
    HWND            myHWND;
    IDispatch  *    pDisp = NULL;
    VARIANT         varDoc; 
    VARIANT         varReturn;
    OLECMD          cmd;
    SP_IOleWindow   spOleWindow;

    Assert( nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER || pvarargIn == NULL);

    hr = THR( PrivateQueryStatus(&cmd, NULL) );
    if (hr)
        goto Cleanup;

    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    hr = GetEditor()->GetDoc()->QueryInterface( IID_IDispatch, (void**) &pDisp );
    if (hr)                                                       
        goto Cleanup;

    VariantInit(&varDoc);
    V_VT(&varDoc) = VT_DISPATCH;
    V_DISPATCH(&varDoc) = pDisp;

    hr = THR(GetEditor()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if( hr )
        goto Cleanup;
    hr = THR(spOleWindow->GetWindow(&myHWND));
    if( hr )
        goto Cleanup;

    //
    // Note that cmdId's for dialogs have been negated.
    // Here we're un-negating them so that ShowEditDialog can find the proper resource.
    //
    hr = THR( ShowEditDialog( ~_cmdId, &varDoc, myHWND, &varReturn, GetEditor()->GetMarkupServices() ));
    
Cleanup:
    ReleaseInterface(pDisp);
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CDialogCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT 
CDialogCommand::PrivateQueryStatus( 
	OLECMD rgCmds[],
    OLECMDTEXT * pcmdtext )
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    BOOL                    fEmpty = FALSE;
    SELECTION_TYPE          eSelectionType;

    rgCmds->cmdf = MSOCMDSTATE_UP; // up by default
    
    //
    // If hyperlink, allow on a control.  Otherwise, return disabled for a control.
    //
    
    if ((~_cmdId) == IDM_HYPERLINK)
        return S_OK;

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType(&eSelectionType) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if (eSelectionType == SELECTION_TYPE_Control)    
    {
        if ( (~_cmdId) != IDM_IMAGE )
        {
            rgCmds->cmdf = MSOCMDSTATE_DISABLED;
        }
        else if( !fEmpty )
        {
            ELEMENT_TAG_ID  eTag;
            SP_IHTMLElement spElement;

            IFC( spSegmentList->CreateIterator( &spIter ) );
            IFC( spIter->Current(&spSegment) );

            IFC( GetSegmentElement( spSegment, &spElement) );

            if (! spElement)
                goto Cleanup;

            IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
            if ( eTag != TAGID_IMG )
            {
                rgCmds->cmdf = MSOCMDSTATE_DISABLED;
            }
        }
    }

    if (((~_cmdId) == IDM_FONT) && !CanAcceptHTML(spSegmentList))
    {
        rgCmds->cmdf = MSOCMDSTATE_DISABLED;      
    }

Cleanup:    
    RRETURN( hr );
}


//+------------------------------------------------------------------------
//
//  Function:   CreateResourceMoniker
//
//  Synopsis:   Creates a new moniker based off a resource file & rid
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDialogCommand::CreateResourceMoniker(
    HINSTANCE hInst,
    TCHAR *pchRID,
    IMoniker **ppmk)
{
    HRESULT         hr = S_OK;
    TCHAR           ach[pdlUrlLen];
    HINSTANCE       hinstDll;	//DLL containing the Pluggable UI html for dialog boxes

    IFC( GetEditResourceLibrary (&hinstDll) );

    _tcscpy(ach, _T("res://"));

    if (!GetModuleFileName(
            hinstDll,
            ach + _tcslen(ach),
            pdlUrlLen - (_tcslen(ach) + _tcslen(pchRID) + 2)))  //2: one is for the null terminator, one is for '/'
    {
        hr = GetLastWin32Error();
        goto Cleanup;
    }

#ifdef UNIX
    {
        TCHAR* p = _tcsrchr(ach, _T('/'));
        if (p)
    {
            int iLen = _tcslen(++p);
            memmove(ach + 6, p, sizeof(TCHAR) * iLen);
            ach[6 + iLen] = _T('\0');
    }
    }
#endif

    _tcscat(ach, _T("/"));
    _tcscat(ach, pchRID);

    hr = THR(CreateURLMoniker(NULL, ach, ppmk));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ShowEditDialog
//
//  Synopsis:   Given an IDM, brings up the corresponding dialog using
//              the C API ShowHTMLDialog()
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

DYNLIB g_dynlibMSHTML = { NULL, NULL, "MSHTML.DLL" };

DYNPROC s_dynprocShowHTMLDialog = { NULL, &g_dynlibMSHTML, "ShowHTMLDialog" };

HRESULT
CDialogCommand::ShowEditDialog(UINT idm, VARIANT * pvarExecArgIn, 
                               HWND hwndParent, VARIANT * pvarArgReturn, 
                               IMarkupServices * pMarkupServices)
{
    HRESULT             hr = S_OK;
    int                 i;
    HINSTANCE           hinst = NULL;
    IMoniker *          pMoniker = NULL;
    SHOWHTMLDIALOGFN *  pfnShowHTMLDialog;
    CEdUndoHelper           undoUnit( GetEditor() );

    // find resource id string
    for (i = 0; i < ARRAY_SIZE(s_dlgInfo); ++i)
    {
        if (idm == s_dlgInfo[i].idm)
            break;
    }
    Assert(i < ARRAY_SIZE(s_dlgInfo));

    // Load the C API procedure from Mshtml.dll
    hr = THR(LoadProcedure(&s_dynprocShowHTMLDialog));
    if (!OK(hr))
        goto Cleanup;

    hinst = s_dynprocShowHTMLDialog.pdynlib->hinst;
    if (!hinst)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Make the resource moniker
    hr = THR(CreateResourceMoniker(
            hinst,
            s_dlgInfo[i].szidr,
            &pMoniker));
    if (hr)
        goto Cleanup;

    // Begin the undo unit
    hr = THR( undoUnit.Begin( s_dlgInfo[i].idsUndoText ) );
    if (hr)
        goto Cleanup;

    // bring up the dialog
    pfnShowHTMLDialog = (SHOWHTMLDIALOGFN*)(s_dynprocShowHTMLDialog.pfn);
    hr = (*pfnShowHTMLDialog)(hwndParent, pMoniker, pvarExecArgIn, NULL, pvarArgReturn);
    if (hr)
        goto Cleanup;

Cleanup:
    DeinitDynamicLibraries();
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\edadorn.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H
#include "resource.h"    
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef _X_PAINTER_H_
#define _X_PAINTER_H_
#include "painter.h"
#endif


DeclareTag(tagAdornerHitTest, "Adorner", "Adorner Hit Test")
DeclareTag(tagAdornerShowResize, "Adorner", "Display Adorner Resize Info ")
DeclareTag(tagAdornerShowAdjustment, "Adorner", "Display Adorner Adjust Info ")
DeclareTag(tagAdornerResizeRed, "Adorner", "Draw Resize Feedback in Red")
using namespace EdUtil;

extern HINSTANCE           g_hInstance ;

template < class T > void swap ( T & a, T & b ) { T t = a; a = b; b = t; }

MtDefine( CGrabHandleAdorner, Utilities , "CGrabHandleAdorner" )
MtDefine( CActiveControlAdorner, Utilities , "CGrabHandleAdorner" )
MtDefine( CCursor, Utilities , "CCursor" )

//
// Constants
//

const int FEEDBACK_SIZE = 1;
    
int g_iGrabHandleWidth = 7;
int g_iGrabHandleHeight = 7;
BOOL g_fCalculatedGrabHandleSize = FALSE;

static const ADORNER_HTI seHitHandles[] =
{
    ADORNER_HTI_TOPLEFTHANDLE ,
    ADORNER_HTI_TOPHANDLE ,
    ADORNER_HTI_TOPRIGHTHANDLE,    
    ADORNER_HTI_LEFTHANDLE,  
    ADORNER_HTI_RIGHTHANDLE,  
    ADORNER_HTI_BOTTOMLEFTHANDLE, 
    ADORNER_HTI_BOTTOMHANDLE,      
    ADORNER_HTI_BOTTOMRIGHTHANDLE 
};


static const USHORT sHandleAdjust[] =
{
    CT_ADJ_TOP | CT_ADJ_LEFT,       //  GRAB_TOPLEFTHANDLE
    CT_ADJ_TOP,                     //  GRAB_TOPHANDLE
    CT_ADJ_TOP | CT_ADJ_RIGHT,      //  GRAB_TOPRIGHTHANDLE    
    CT_ADJ_LEFT,                    //  GRAB_LEFTHANDLE
    CT_ADJ_RIGHT,                   //  GRAB_RIGHTHANDLE    
    CT_ADJ_BOTTOM | CT_ADJ_LEFT,    //  GRAB_BOTTOMLEFTHANDLE
    CT_ADJ_BOTTOM,                  //  GRAB_BOTTOMHANDLE
    CT_ADJ_BOTTOM | CT_ADJ_RIGHT   //  GRAB_BOTTOMRIGHTHANDLE
};

static const LPCTSTR sHandleCursor[] =
{
    IDC_SIZENWSE,
    IDC_SIZENS,
    IDC_SIZENESW,
    IDC_SIZEWE,
    IDC_SIZEWE,
    IDC_SIZENESW,
    IDC_SIZENS,
    IDC_SIZENWSE,
    IDC_ARROW,
    IDC_SIZEALL,
    IDC_CROSS
};

CEditAdorner::CEditAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc )
{
    ReplaceInterface( &_pIDoc ,  pIDoc );
    IGNORE_HR( pIElement->QueryInterface( IID_IHTMLElement, (void**) & _pIElement ));
    
    _lCookie = 0 ;
    _cRef = 0;
    _ctOnPositionSet = 0;
    _pBehaviorSite = NULL;
    _pPaintSite = NULL;
}  

VOID 
CEditAdorner::SetManager( CSelectionManager * pManager )
{
    _pManager = pManager;

    if (!g_fCalculatedGrabHandleSize)
    {
        POINT	pt = {g_iGrabHandleWidth, g_iGrabHandleHeight};

        _pManager->GetEditor()->DeviceFromDocPixels(&pt);
        g_iGrabHandleWidth = pt.x;
        g_iGrabHandleHeight = pt.y;

        g_fCalculatedGrabHandleSize = TRUE;
    }
}

VOID
CEditAdorner::NotifyManager()
{
    if ( _fNotifyManagerOnPositionSet && _pManager )
    {
        _pManager->AdornerPositionSet(); 
        _fNotifyManagerOnPositionSet = FALSE; // only notify once
    }
}

CEditAdorner::~CEditAdorner()
{
    ReleaseInterface(_pPaintSite);
    ReleaseInterface(_pBehaviorSite);
    ReleaseInterface( _pIElement );
    ReleaseInterface( _pIDoc );
}

BOOL
CEditAdorner::IsAdornedElementPositioned()
{
    return ( IsElementPositioned( _pIElement ) );
}

// --------------------------------------------------
// IUnknown Interface
// --------------------------------------------------

STDMETHODIMP_(ULONG)
CEditAdorner::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CEditAdorner::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CEditAdorner::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    switch(iid.Data1)
    {
        QI_INHERITS( (IElementBehavior *)this , IUnknown )
        QI_INHERITS( this, IElementBehavior)
        QI_INHERITS( this, IHTMLPainter)
        QI_INHERITS( this, IHTMLPainterEventInfo)
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

CMshtmlEd* 
CEditAdorner::GetCommandTarget()
{ 
    Assert (_pManager); 
    return _pManager->GetCommandTarget(); 
}

//
// IElementBehavior::Init
//
STDMETHODIMP
CEditAdorner::Init(IElementBehaviorSite *pBehaviorSite)
{
    HRESULT hr = S_OK;
    ClearInterface(&_pBehaviorSite);
    _pBehaviorSite = pBehaviorSite;

    if (_pBehaviorSite)
    {
        _pBehaviorSite->AddRef();

        IFC(_pBehaviorSite->QueryInterface(IID_IHTMLPaintSite, (LPVOID *)&_pPaintSite))
    }

Cleanup:
    if (hr)
    {
        ClearInterface(&_pBehaviorSite);
        ClearInterface(&_pPaintSite);
    }
    RRETURN(hr);
}

STDMETHODIMP
CEditAdorner::Detach()
{
    Assert(_pBehaviorSite);

    ClearInterface(&_pBehaviorSite);
    ClearInterface(&_pPaintSite);

    return S_OK;
}

STDMETHODIMP
CEditAdorner::Notify(long lEvent, VARIANT *pVar)
{
    return S_OK;
}

//+====================================================================================
//
// Method: AttachToElement
//
// Synopsis: Add this Adorner inside of Trident.
//
//------------------------------------------------------------------------------------


HRESULT
CEditAdorner::CreateAdorner()
{
    HRESULT hr = S_OK;

    Assert(_pIElement);

    IHTMLElement2 *pIElement2 = 0;

    IFC(_pIElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pIElement2));

    Assert(pIElement2);
    VARIANT v;

    V_VT(&v) = VT_UNKNOWN;
    V_UNKNOWN(&v) = (IUnknown *)(IElementBehavior *)this;

    IFC(pIElement2->addBehavior(L"", &v, &_lCookie));

Cleanup:
    ReleaseInterface(pIElement2);
    RRETURN( hr );
}

//+====================================================================================
//
// Method:DestroyAdorner
//
// Synopsis: Destroy's the Adorner inside of trident that we are attached to.
//
//------------------------------------------------------------------------------------

HRESULT
CEditAdorner::DestroyAdorner()
{
    HRESULT hr = S_OK;
    IHTMLElement2 *pIElement2 = NULL;    

    if ( _lCookie )
    {
        Assert(_pIElement);
        IFC (_pIElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pIElement2));

        Assert(pIElement2);

        VARIANT_BOOL fResultDontCare;
        pIElement2->removeBehavior(_lCookie, &fResultDontCare);
        _lCookie = 0;
    }
    
Cleanup:
    ReleaseInterface(pIElement2);
    RRETURN ( hr );

}

//+====================================================================================
//
// Method:InvalidateAdorner
//
// Synopsis: Call Invalidate Adorner on the Adorner inside of Trident.
//
//------------------------------------------------------------------------------------

HRESULT
CEditAdorner::InvalidateAdorner()
{
    HRESULT hr = S_OK;
    
    if ( _lCookie )
    {
        Assert(_pPaintSite);

        hr = _pPaintSite->InvalidateRect(NULL);
    }

    RRETURN(hr);
}

//--------------------------------------------------------------------------------
//
// CBorderAdorner
//
//--------------------------------------------------------------------------------
CBorderAdorner::CBorderAdorner( IHTMLElement* pIElement, IHTMLDocument2 * pIDoc )
    : CEditAdorner( pIElement, pIDoc )
{

}

CBorderAdorner::~CBorderAdorner()
{

}

STDMETHODIMP
CBorderAdorner::OnResize(SIZE sizeIn)
{
    SIZE    size = sizeIn;

    _pManager->GetEditor()->DocPixelsFromDevice(&size);
    SetRect(&_rcBounds, 0, 0, size.cx, size.cy);

    _rcControl = _rcBounds;

    InflateRect(&_rcControl, -g_iGrabHandleWidth, -g_iGrabHandleHeight);

    return S_OK;
}

STDMETHODIMP
CBorderAdorner::GetPainterInfo(HTML_PAINTER_INFO *pInfo)
{
    ZeroMemory(pInfo, sizeof(pInfo));
    pInfo->lFlags = HTMLPAINTER_NOPHYSICALCLIP | HTMLPAINTER_TRANSPARENT | HTMLPAINTER_HITTEST | HTMLPAINTER_NOSAVEDC | HTMLPAINTER_SUPPORTS_XFORM ;
    pInfo->lZOrder = HTMLPAINT_ZORDER_WINDOW_TOP;

    // (michaelw) (chandras keeps changing things here)
    // Even though grab handles might be disabled by the command target,
    // we inflat our rect.  This is because we don't get notification
    // of changes to the flag so we can't invalidate our state on the
    // display tree.
    //
    // The fix (if you care) is to make the code changing the flag
    // notify the interested parties (ie this code) but it probably
    // isn't worth the effort.

    //
    // marka - not worth the effort to make the above changes - leave for now !
    //
    SetRect(&pInfo->rcExpand, g_iGrabHandleWidth, g_iGrabHandleHeight, g_iGrabHandleWidth, g_iGrabHandleHeight);

    return S_OK;
}

//--------------------------------------------------------------------------------
//
// CGrabHandleAdorner
//
//--------------------------------------------------------------------------------

STDMETHODIMP
CGrabHandleAdorner::HitTestPoint(POINT ptLocalIn, BOOL *pbHit, LONG *plPartID)
{
    POINT   ptLocal = ptLocalIn;

    _pManager->GetEditor()->DocPixelsFromDevice(&ptLocal);

    *pbHit = FALSE;
    *plPartID = ADORNER_HTI_NONE;

    TraceTag((tagAdornerHitTest, "HitTestPoint: ptLocal: %d %d  _rcBounds: %d %d %d %d  _rcControl: %d %d %d %d", 
                                 ptLocal.x, ptLocal.y, _rcBounds.left, _rcBounds.top, _rcBounds.right, _rcBounds.bottom, 
                                _rcControl.left, _rcControl.top, _rcControl.right, _rcControl.bottom));
    
    if (PtInRect(&_rcBounds, ptLocal))
    {
        if (!PtInRect(&_rcControl, ptLocal))
        {
            SetLocked();
            if (!_fLocked)
            {                
                *pbHit = TRUE;
                if ( ! IsInResizeHandle(ptLocal, (ADORNER_HTI *)plPartID))
                {
                    Verify( IsInMoveArea( ptLocal, (ADORNER_HTI *)plPartID ));
                }
            }
        }
    }
    return S_OK;
}


CGrabHandleAdorner::CGrabHandleAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked )
    : CBorderAdorner( pIElement , pIDoc )
{
    _resizeAdorner = -1;
    _hbrFeedback = NULL;
    _hbrHatch = NULL;

    _currentCursor = ADORNER_HTI_NONE;
    _fIsPositioned = IsAdornedElementPositioned();
    _fLocked = fLocked;
    _fDrawAdorner = TRUE;    
    _fPositionChange = FALSE;
}

CGrabHandleAdorner::~CGrabHandleAdorner()
{
    if ( _hbrFeedback )
        ::DeleteObject( _hbrFeedback );
    
    if ( _hbrHatch )
        ::DeleteObject( _hbrHatch );
}

STDMETHODIMP
CGrabHandleAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    SetLocked();

    CEditXform edXForm;
    
    if ( (lDrawFlags & HTMLPAINT_DRAW_USE_XFORM ) != 0 )
    { 
        HTML_PAINT_DRAW_INFO drawInfo;
        
        IGNORE_HR( _pPaintSite->GetDrawInfo( HTMLPAINT_DRAWINFO_XFORM , & drawInfo ) );
        
        edXForm.InitXform( & ( drawInfo.xform ));
    }
    
    DrawGrabBorders( & edXForm , hdc, &rcBounds, FALSE);
    DrawGrabHandles( & edXForm , hdc, &rcBounds);
    
    return S_OK;
}

//+====================================================================================
//
// Method: SetDrawAdorner
//
// Synopsis: Set the _fDrawAdorner bit - to control whether the adorner should be drawn or not
//
//------------------------------------------------------------------------------------

VOID
CGrabHandleAdorner::SetDrawAdorner( BOOL fDrawAdorner )
{
    BOOL fCurrentDrawAdorner = ENSURE_BOOL( _fDrawAdorner);

    _fDrawAdorner = fDrawAdorner;
    
    if ( fCurrentDrawAdorner != ENSURE_BOOL( _fDrawAdorner))
    {
        InvalidateAdorner();
    }
}

HRESULT
CGrabHandleAdorner::SetLocked()
{
    HRESULT hr = S_OK;
    BOOL fLocked = FALSE;
    
    hr = THR( _pManager->GetEditor()->IsElementLocked( _pIElement, & fLocked ));

    _fLocked = fLocked;
    
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetGrabRect
//
//  Synopsis:   Compute grab rect for a given area.
//
//  Notes:      These diagrams show the output grab rect for handles and
//              borders.
//
//              -----   -----   -----               -------------
//              |   |   |   |   |   |               |           |
//              | TL|   | T |   |TR |               |     T     |
//              ----|-----------|----           ----|-----------|----
//                  |           |               |   |           |   |
//              ----| Input     |----           |   | Input     |   |
//              |   |           |   |           |   |           |   |
//              |  L|   RECT    |R  |           |  L|   RECT    |R  |
//              ----|           |----           |   |           |   |
//                  |           |               |   |           |   |
//              ----|-----------|----           ----|-----------|----
//              | BL|   | B |   |BR |               |     B     |
//              |   |   |   |   |   |               |           |
//              -----   -----   -----               -------------
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::GetGrabRect(ADORNER_HTI htc, RECT * prcOut, RECT * prcIn /* = NULL */)
{
    if (prcIn == NULL)
        prcIn = &_rcBounds;

    switch (htc)
    {
        case ADORNER_HTI_TOPLEFTHANDLE:
        case ADORNER_HTI_LEFTHANDLE:
        case ADORNER_HTI_BOTTOMLEFTHANDLE:

            prcOut->left = prcIn->left ;
            prcOut->right = prcIn->left + g_iGrabHandleWidth ;
            break;

        case ADORNER_HTI_TOPHANDLE:
        case ADORNER_HTI_BOTTOMHANDLE:

            prcOut->left = ((prcIn->left + prcIn->right) - g_iGrabHandleWidth ) / 2;
            prcOut->right = prcOut->left + g_iGrabHandleWidth  ;
            break;

        case ADORNER_HTI_TOPRIGHTHANDLE:
        case ADORNER_HTI_RIGHTHANDLE:
        case ADORNER_HTI_BOTTOMRIGHTHANDLE:

            prcOut->left = prcIn->right - g_iGrabHandleWidth  ;
            prcOut->right = prcIn->right ;
            break;

        default:
            Assert(FALSE && "Unsupported GRAB_ value in GetGrabRect");
            return;
    }

    switch (htc)
    {
        case ADORNER_HTI_TOPLEFTHANDLE:
        case ADORNER_HTI_TOPHANDLE:
        case ADORNER_HTI_TOPRIGHTHANDLE:

            prcOut->top = prcIn->top ;
            prcOut->bottom = prcIn->top + g_iGrabHandleHeight   ;
            break;

        case ADORNER_HTI_LEFTHANDLE:
        case ADORNER_HTI_RIGHTHANDLE:

            prcOut->top = ((prcIn->top + prcIn->bottom) - g_iGrabHandleHeight ) / 2;
            prcOut->bottom = prcOut->top + g_iGrabHandleHeight ;
            break;

        case ADORNER_HTI_BOTTOMLEFTHANDLE:
        case ADORNER_HTI_BOTTOMHANDLE:
        case ADORNER_HTI_BOTTOMRIGHTHANDLE:

            prcOut->top = prcIn->bottom - g_iGrabHandleHeight ;
            prcOut->bottom = prcIn->bottom;
            break;

        default:
            Assert(FALSE && "Unsupported ADORNER_HTI_ value in GetHandleRegion");
            return;
    }

    if (prcOut->left > prcOut->right)
    {
        swap(prcOut->left, prcOut->right);
    }

    if (prcOut->top > prcOut->bottom)
    {
        swap(prcOut->top, prcOut->bottom);
    }
}

//+------------------------------------------------------------------------
//
//  Function:   PatBltRectH & PatBltRectV
//
//  Synopsis:   PatBlts the top/bottom and left/right.
//
//-------------------------------------------------------------------------
void
CGrabHandleAdorner::PatBltRectH(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    int trueLeft = 0 ;
    int trueWidth = 0 ;
    
    //
    // Don't do general clipping. Assume that Oneside of pExcludeRect is equivalent
    // This is true once you're resizing with a grab handle.
    //
    if ( pExcludeRect && 
         pExcludeRect->top == prc->top && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->right < prc->right )
        {
            trueLeft = pExcludeRect->right;
            trueWidth = abs( prc->right - trueLeft );
        }
        else
            trueWidth = 0; // Nothing to draw - we are completely contained
    }
    else if ( pExcludeRect &&
              pExcludeRect->top == prc->top  &&
              pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->left > prc->left )
        {    
            trueLeft = prc->left;
            trueWidth = abs( pExcludeRect->right - trueLeft );
        }
        else
            trueWidth = 0;
    }
    else 
    {
        trueLeft = prc->left;
        trueWidth = prc->right - prc->left;
    }

    if ( trueWidth > 0 )
    {
        PatBlt(
                hdc,
                trueLeft,
                prc->top,
                trueWidth ,
                cThick,
                dwRop);
    }

    if ( pExcludeRect && 
         pExcludeRect->bottom == prc->bottom && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->right < prc->right )
        {
            trueLeft = pExcludeRect->right;
            trueWidth = abs ( prc->right - trueLeft );
        }
        else
            trueWidth = 0;
    }
    else if ( 
        pExcludeRect &&
        pExcludeRect->bottom == prc->bottom &&
        pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->left > prc->left )
        {    
            trueLeft = prc->left;
            trueWidth = pExcludeRect->left - trueLeft;
        }
        else
            trueWidth = 0;
    }
    else 
    {
        trueLeft = prc->left;
        trueWidth = prc->right - prc->left;
    }

    if ( trueWidth > 0 )
    {
        PatBlt(
                hdc,
                trueLeft,
                prc->bottom - cThick,
                trueWidth ,
                cThick,
                dwRop);
    }            
}

void
CGrabHandleAdorner::PatBltRectV(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    int trueTop = 0 ;
    int trueHeight = 0 ;
    
    //
    // Don't do general clipping. Assume that Oneside of pExcludeRect is equivalent
    // This is true once you're resizing with a grab handle.
    //
    if ( pExcludeRect &&
         pExcludeRect->top == prc->top && 
         pExcludeRect->left == prc->left )
    {
        if ( pExcludeRect->bottom < prc->bottom )
        {
            trueTop = pExcludeRect->bottom;
            trueHeight = prc->bottom - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else if ( pExcludeRect && 
              pExcludeRect->bottom == prc->bottom && 
              pExcludeRect->left == prc->left )
    {        
        if ( pExcludeRect->top > prc->top )
        {
            trueTop = prc->top;
            trueHeight = pExcludeRect->top - prc->top ;
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else 
    {
        trueTop = prc->top;
        trueHeight = prc->bottom - prc->top;
    }
   
    if ( trueHeight > 0 )
    {
        PatBlt(
                hdc,
                prc->left,
                trueTop + cThick,
                cThick,
                trueHeight - (2 * cThick),
                dwRop);
    }

    if ( pExcludeRect && 
         pExcludeRect->top == prc->top && 
         pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->bottom < prc->bottom )
        {
            trueTop = pExcludeRect->bottom;
            trueHeight = prc->bottom - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }
    }
    else if ( pExcludeRect && 
              pExcludeRect->bottom == prc->bottom && 
              pExcludeRect->right == prc->right )
    {
        if ( pExcludeRect->top > prc->top )
        {
            trueTop = prc->top;
            trueHeight = pExcludeRect->top - trueTop ; 
        }
        else
        {
            trueHeight = 0; // We have nothing to draw on this side - as we're inside the rect on this edge
        }

    }
    else 
    {
        trueTop = prc->top;
        trueHeight = prc->bottom - prc->top;
    }

    if ( trueHeight > 0 )
    {
        PatBlt(
                hdc,
                prc->right - cThick,
                trueTop + cThick,
                cThick,
                trueHeight - (2 * cThick),
                dwRop);
    }            
}

void
CGrabHandleAdorner::PatBltRect(HDC hdc, RECT * prc, RECT* pExcludeRect, int cThick, DWORD dwRop)
{
    PatBltRectH(hdc, prc, pExcludeRect, cThick, dwRop);

    PatBltRectV(hdc, prc, pExcludeRect, cThick, dwRop);
}

LPCTSTR
CGrabHandleAdorner::GetResizeHandleCursorId(ADORNER_HTI inAdorner)
{
    return sHandleCursor[ inAdorner ];
}

BOOL 
CGrabHandleAdorner::IsInResizeHandle(CEditEvent *pEvent)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInResizeHandle(LocalFromGlobal(ptGlobal));
}

BOOL 
CGrabHandleAdorner::IsInResizeHandle(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    int     i;
    RECT    rc;

    // Reject trivial miss
    if (!PtInRect(&_rcBounds, ptLocal))
        return FALSE;

    SetLocked();
    if ( _fLocked)
        return FALSE;

    rc.left = rc.top = rc.bottom = rc.right = 0;    // to appease LINT

    for (i = 0; i < ARRAY_SIZE(seHitHandles); ++i)
    {
        GetGrabRect( seHitHandles[i], &rc);
        if (PtInRect(&rc, ptLocal))
        {
            _resizeAdorner = (char)i;
            if ( pGrabAdorner )
                *pGrabAdorner = seHitHandles[i]; // make use of ordering of ENUM

            TraceTag(( tagAdornerHitTest , "IsInResizeHandle: Point:%d,%d Hit:%d rc: left:%d top:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
                    TRUE , rc.left, rc.top, rc.bottom, rc.right )); 
                    
            return TRUE;
        }            
    }
    TraceTag(( tagAdornerHitTest , "Did Not Hit Resizehandle: Point:%d,%d Hit:%d rc: left:%d top:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
            FALSE , rc.left, rc.top, rc.bottom, rc.right )); 
    return FALSE ;
}

BOOL 
CGrabHandleAdorner::IsInMoveArea(CEditEvent *pEvent)
{
    POINT ptGlobal;

    pEvent->GetPoint(&ptGlobal);

    return IsInMoveArea(LocalFromGlobal(ptGlobal));
}

BOOL 
CGrabHandleAdorner::IsInMoveArea(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    BOOL fInBounds = FALSE;

    SetLocked();
    
    if ( _fLocked )
        return FALSE;
        
    if ( ( PtInRect(&_rcBounds , ptLocal)) && 
         (!PtInRect(&_rcControl, ptLocal) ) )
    {
        fInBounds = TRUE;
        if ( pGrabAdorner )
        {
            //
            // Find out what part of the border we are in.
            //
            if ( ptLocal.y >= _rcBounds.top && 
                 ptLocal.y <= _rcBounds.top + g_iGrabHandleHeight )
            {
                *pGrabAdorner = ADORNER_HTI_TOPBORDER;
            }
            else  if ( ptLocal.y >= _rcBounds.bottom - g_iGrabHandleHeight &&
                       ptLocal.y <= _rcBounds.bottom )
            {
                *pGrabAdorner = ADORNER_HTI_BOTTOMBORDER;
            }
            else if ( ptLocal.x >= _rcBounds.left &&
                      ptLocal.x <= _rcBounds.left + g_iGrabHandleWidth )
            {
                *pGrabAdorner = ADORNER_HTI_LEFTBORDER;
            }
            else
            {
                Assert( ptLocal.x <= _rcBounds.right &&
                       ptLocal.x >= _rcBounds.right - g_iGrabHandleWidth );

                *pGrabAdorner = ADORNER_HTI_RIGHTBORDER;                
            }
        }        
    }
    
    TraceTag(( tagAdornerHitTest , "Point:%d,%d InMoveArea:%d _rcBounds: top:%d left:%d, bottom:%d, right:%d _rcControl: top:%d left:%d, bottom:%d, right:%d ",ptLocal.x, ptLocal.y, 
            fInBounds, _rcBounds.top, _rcBounds.left, _rcBounds.bottom, _rcBounds.right, 
            _rcControl.left, _rcControl.top, _rcControl.bottom, _rcControl.right ));
            
    return fInBounds;        
}

BOOL 
CGrabHandleAdorner::IsInAdornerGlobal( POINT ptGlobal )
{
    POINT ptContainer = LocalFromGlobal(ptGlobal);

    return ( PtInRect(&_rcBounds, ptContainer) );
}

VOID 
CGrabHandleAdorner::BeginResize(POINT ptGlobal, USHORT adj )
{
    //
    // Check to see if the point is within the last call to IsInResizeHandle
    // if it isn't update IsInResizeHandle.
    //

    POINT ptLocal = LocalFromGlobal(ptGlobal);
    _resizeAdorner = -1;

    _ptRectOffset.x = 0;
    _ptRectOffset.y = 0;
    
    IsInResizeHandle(ptLocal);
    
    if ( _resizeAdorner != - 1)
    {
        RECT    rc;
        GetGrabRect( seHitHandles[_resizeAdorner], &rc, & _rcBounds );
        if (! PtInRect(&rc, ptLocal))
            IsInResizeHandle( ptLocal);

         _adj = sHandleAdjust[ _resizeAdorner ];
    }
    else if ( adj != CT_ADJ_NONE )
    {
        _adj = adj;
    }

    Assert( _resizeAdorner != -1 || adj != CT_ADJ_NONE );
    
    //
    // Do the stuff to set up a drag.
    //

    _fFeedbackVis = FALSE;   
    _fDrawNew = TRUE;

    TransformRectLocal2Global(&_rcControl, &_rcFirst);
    
    POINT   ptBeginPosition;
    Assert(_pIElement);
    EdUtil::GetOffsetTopLeft(_pIElement, &ptBeginPosition);
    _ptRectOffset.x = ptBeginPosition.x - _rcFirst.left;
    _ptRectOffset.y = ptBeginPosition.y - _rcFirst.top;
    OffsetRect(&_rcFirst, _ptRectOffset.x, _ptRectOffset.y);

    _ptFirst = ptGlobal;
    
    TraceTag((tagAdornerShowResize,"BeginResize. _rcFirst: left:%ld, top:%ld, right:%ld, bottom:%ld", 
                                    _rcFirst.left,
                                    _rcFirst.top,
                                    _rcFirst.right,
                                    _rcFirst.bottom ));     
    
    TraceTag((tagAdornerShowResize,"BeginResize. _ptFirst: x:%ld, y:%ld\n", 
                                    _ptFirst.x,
                                    _ptFirst.y ));                                     
}

VOID 
CGrabHandleAdorner::EndResize(POINT ptGlobal, RECT * pNewSize )
{    
    RECT rcLocal ;

    _fDrawNew = FALSE;
    DuringResize(ptGlobal, TRUE );

    TransformRectGlobal2Local(&_rc, &rcLocal);

    _ptRectOffset.x = 0;
    _ptRectOffset.y = 0;
    
    pNewSize->left   = _rc.left ;
    pNewSize->top    = _rc.top  ;
    pNewSize->right  = pNewSize->left + (rcLocal.right  - rcLocal.left);
    pNewSize->bottom = pNewSize->top  + (rcLocal.bottom - rcLocal.top);
}

VOID 
CGrabHandleAdorner::DuringResize(POINT ptGlobal, BOOL fForceRedraw )
{
    RECT    newRC ;
    POINT   ptChange;

    RectFromPoint(&newRC, ptGlobal);

    ptChange.x = ptGlobal.x - _ptFirst.x;
    ptChange.y = ptGlobal.y - _ptFirst.y;
    AdjustForCenterAlignment(_pIElement, &newRC, ptChange);

    TraceTag((tagAdornerShowResize, "DuringResize: ptLocal: %d, %d  _ptFirst: %d %d  _rcFirst (global): %d %d %d %d  pNewSize (global): %d %d %d %d",
                                    ptGlobal.x, ptGlobal.y, _ptFirst.x, _ptFirst.y,
                                    _rcFirst.left, _rcFirst.top, _rcFirst.right, _rcFirst.bottom,
                                    newRC.left, newRC.top, newRC.right, newRC.bottom));

    if (   ( newRC.left   != _rc.left   ||
             newRC.top    != _rc.top    ||
             newRC.right  != _rc.right  ||
             newRC.bottom != _rc.bottom ) 
           ||
            fForceRedraw )
    {
        if ( _fFeedbackVis )
        {
            DrawFeedbackRect( & _rc);
        }
        if ( _fDrawNew )
        {
            DrawFeedbackRect( & newRC);
            _fFeedbackVis = TRUE;
        }            
        _rc = newRC;
    }
}


HRESULT
CGrabHandleAdorner::AdjustForCenterAlignment( IHTMLElement *pElement, RECT *rcSize, const POINT ptChange )
{
    HRESULT         hr = S_OK;
    ELEMENT_TAG_ID  eTag = TAGID_NULL;
    BSTR            bstrAlign;
    BOOL            fNeedToAdjust = TRUE;
    BOOL            fVertical = FALSE;

    Assert(rcSize);
    Assert(_pIElement);

    if (!rcSize || !pElement)
    {
        goto Cleanup;
    }

    IFC( _pManager->GetMarkupServices()->GetElementTagId(pElement, & eTag ));

    if (eTag == TAGID_HR)
    {
        SP_IHTMLHRElement   spHRElement;

        if ( pElement->QueryInterface(IID_IHTMLHRElement, (void **)&spHRElement) == S_OK &&
             spHRElement && spHRElement->get_align(&bstrAlign) == S_OK &&
             bstrAlign)
        {
            //  HRs are center aligned by default.
            if ( StrCmpIC(bstrAlign, _T("center")) == 0 )
            {
                IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
                if (fVertical)
                    goto Cleanup;
    
                if (_adj & CT_ADJ_LEFT)
                {
                    rcSize->right -= ptChange.x;
                }
                else if (_adj & CT_ADJ_RIGHT)
                {
                    rcSize->left -= ptChange.x;
                }
            }
            fNeedToAdjust = FALSE;
        }
    }
    else if (eTag == TAGID_TABLE)
    {
        SP_IHTMLTable       spTableElement;

        if ( pElement->QueryInterface(IID_IHTMLTable, (void **)&spTableElement) == S_OK &&
             spTableElement && spTableElement->get_align(&bstrAlign) == S_OK &&
             bstrAlign)
        {
            if ( StrCmpIC(bstrAlign, _T("center")) == 0 )
            {
                IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
                if (fVertical)
                    goto Cleanup;
    
                //  We have a centered table.  We will adjust the rect for
                //  center alignment.
                if (_adj & CT_ADJ_LEFT)
                {
                    rcSize->right -= ptChange.x;
                }
                else if (_adj & CT_ADJ_RIGHT)
                {
                    rcSize->left -= ptChange.x;
                }
            }
            fNeedToAdjust = FALSE;
        }
    }
    
    if (fNeedToAdjust)
    {
        IFC( GetBlockContainerAlignment( _pManager->GetMarkupServices(), pElement, &bstrAlign) );

        if ( (eTag == TAGID_HR && !bstrAlign) || bstrAlign && StrCmpIC(bstrAlign, _T("center")) == 0 )
        {
            IFC( MshtmledUtil::IsElementInVerticalLayout(pElement, &fVertical) );
            if (fVertical)
                goto Cleanup;

            //  We have a centered DIV or P.  We will adjust the rect for
            //  center alignment.
            if (_adj & CT_ADJ_LEFT)
            {
                rcSize->right -= ptChange.x;
            }
            else if (_adj & CT_ADJ_RIGHT)
            {
                rcSize->left -= ptChange.x;
            }
            fNeedToAdjust = FALSE;
        }
    }

Cleanup:
    RRETURN( hr );
}

VOID 
CGrabHandleAdorner::DuringLiveResize( POINT dPt, RECT* pNewSize)
{
    POINT pt;
    RECT  rcLocal ;

    pt.x = dPt.x + _ptFirst.x;
    pt.y = dPt.y + _ptFirst.y;

    RectFromPoint(&_rcFirst, pt);
    AdjustForCenterAlignment(_pIElement, &_rcFirst, dPt);

    _ptFirst = pt;

    TransformRectGlobal2Local(&_rcFirst, &rcLocal);
    
    _rc = _rcFirst ;

    pNewSize->left   = _rcFirst.left ;
    pNewSize->top    = _rcFirst.top  ;
    pNewSize->right  = pNewSize->left + (rcLocal.right  - rcLocal.left);
    pNewSize->bottom = pNewSize->top  + (rcLocal.bottom - rcLocal.top);

        
    TraceTag((tagAdornerShowResize, "DuringLiveResize: dPt: %d %d  pt: %d, %d  _ptFirst: %d %d  _rcFirst (local): %d %d %d %d  pNewSize (global): %d %d %d %d",
                                    dPt.x, dPt.y, pt.x, pt.y, _ptFirst.x, _ptFirst.y,
                                    _rcFirst.left, _rcFirst.top, _rcFirst.right, _rcFirst.bottom,
                                    pNewSize->left, pNewSize->top, pNewSize->right, pNewSize->bottom));
}

VOID
CGrabHandleAdorner::DrawFeedbackRect( RECT* prcLocal)
{
    //
    // Get and release the DC every time. The office assistants like to blow it away.
    //
    HWND          hwnd = NULL;
    HDC           hdc;
    SP_IOleWindow spOleWindow;

    RECT rcGlobal;
    RECT rcControlGlobal;
    
    TransformRectLocal2Global(&_rcControl, &rcControlGlobal);
#if 0
    TransformRectLocal2Global(prcLocal, &rcGlobal);
#else
    rcGlobal = *prcLocal;
#endif

    OffsetRect(&rcGlobal, -_ptRectOffset.x, -_ptRectOffset.y);

    TraceTag((tagAdornerShowResize,"Adorner:%ld DrawFeedbackRect: left:%ld, top:%ld, right:%ld, bottom:%ld", 
                                this,
                                rcGlobal.left,
                                rcGlobal.top,
                                rcGlobal.right,
                                rcGlobal.bottom ));
                                
    IGNORE_HR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &hwnd ));
    hdc = GetDCEx( hwnd, 0 , DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE);
    
    HBRUSH hbr = GetFeedbackBrush();
    SelectObject( hdc, hbr);

    _pManager->GetEditor()->DeviceFromDocPixels(&rcGlobal);
    _pManager->GetEditor()->DeviceFromDocPixels(&rcControlGlobal);

#if DBG == 1
    if ( IsTagEnabled(tagAdornerResizeRed) )
    {
        PatBltRect( hdc, &rcGlobal, & rcControlGlobal, FEEDBACKRECTSIZE, PATCOPY );
    }
    else
#endif    
    PatBltRect( hdc, &rcGlobal, & rcControlGlobal, FEEDBACKRECTSIZE, PATINVERT);

    _pManager->GetEditor()->DocPixelsFromDevice(&rcGlobal);
    _pManager->GetEditor()->DocPixelsFromDevice(&rcControlGlobal);


    if (hdc)
    {
        ReleaseDC(hwnd, hdc );
    }
}

HBRUSH 
CGrabHandleAdorner::GetFeedbackBrush()
{
    HBITMAP hbmp;
    
    if ( ! _hbrFeedback )
    {
#if DBG == 1
        COLORREF cr;
        if ( IsTagEnabled(tagAdornerResizeRed ))
        {
            cr = RGB(0xFF,0x00,0x00);
            _hbrFeedback = ::CreateSolidBrush(cr );
        }
        else
        {
#endif    
            // Load the bitmap resouce.
            hbmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDR_FEEDBACKRECTBMP));
            if (!hbmp)
                goto Cleanup;

            // Turn the bitmap into a brush.
            _hbrFeedback = CreatePatternBrush(hbmp);

            DeleteObject(hbmp);
#if DBG ==1
        }
#endif
    }

Cleanup:
    return _hbrFeedback;
}

HBRUSH 
CGrabHandleAdorner::GetHatchBrush()
{
    HBITMAP hbmp;

    if ( ! _hbrHatch )
    {
        // Load the bitmap resouce.
        hbmp = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDR_HATCHBMP));
        if (!hbmp)
            goto Cleanup;

        // Turn the bitmap into a brush.
        _hbrHatch = CreatePatternBrush(hbmp);

        DeleteObject(hbmp);
    }
Cleanup:
    return _hbrHatch;
}

//+------------------------------------------------------------------------
//
//  Member:     DrawGrabHandles
//
//  Synopsis:   Draws grab handles around the given rect.
//
//-------------------------------------------------------------------------

void
CGrabHandleAdorner::DrawGrabHandles(CEditXform* pXform , HDC hdc, RECT *prc )
{
    Assert( pXform );
    
    if (!_fLocked)
    {
        HBRUSH      hbr;
        HPEN        hpen;
        int         i;

        // Get proper brush and pen to render primary or secondary selection
        if ( _fDrawAdorner )
        {
            hbr = (HBRUSH) GetStockObject(_fPrimary ? WHITE_BRUSH : BLACK_BRUSH);
            hpen = (HPEN) GetStockObject(_fPrimary ? BLACK_PEN : WHITE_PEN);
        }
        else
        {
            hbr = (HBRUSH) GetStockObject( LTGRAY_BRUSH );
            hpen = (HPEN) GetStockObject( WHITE_PEN );
        }
        Assert(hbr && hpen);

        // Load the brush and pen into the DC.
        hbr = (HBRUSH) SelectObject(hdc, hbr);
        hpen = (HPEN) SelectObject(hdc, hpen);

        // Draw each grab handle.
        for (i = 0; i < ARRAY_SIZE(seHitHandles); ++i)
        {
            RECT    rc;

            // Get the grab rect for this handle.
            GetGrabRect( seHitHandles[i] , &rc, prc );

            // xform the rect.            
            pXform->TransformRect( & rc );
            
            // Draw it.
            Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }

        // Restore the old brush and pen.
        SelectObject(hdc, hbr);
        SelectObject(hdc, hpen);

    }
}


//+------------------------------------------------------------------------
//
//  Member:     CGrabHandleBorders::DrawGrabBorders
//
//  Synopsis:   Draws grab borders around the givin rect.
//
//
//-------------------------------------------------------------------------
void
CGrabHandleAdorner::DrawGrabBorders(CEditXform* pXform , HDC hdc, RECT *prc, BOOL fHatch)
{
    HBRUSH      hbrOld = NULL;
    HBRUSH      hbr;
    POINT       pt ;
    
    GetViewportOrgEx (hdc, &pt) ;


    SetTextColor(hdc, RGB(0, 0, 0));
    SetBkColor(hdc, RGB(255, 255, 255));
    
    //
    // Xform the rect where we really want to draw.
    //
    Assert( pXform );
    RECT borderRect;
    borderRect = *prc;
    pXform->TransformRect( & borderRect );
    
    //
    // In the code below, before each select of a brush into the dc, we do
    // an UnrealizeObject followed by a SetBrushOrgEx.  This assures that
    // the brush pattern is properly aligned in that face of scrolling,
    // resizing or dragging the form containing the "bordered" object.
    //
    if (  _fLocked )
    {
        // For a locked elemnet - we just draw a rectangle around it.


        //InflateRect(&rc, -g_iGrabHandleWidth / 2, -g_iGrabHandleHeight / 2);

        hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(WHITE_BRUSH));
        if (!hbrOld)
            goto Cleanup;

        PatBltRectH(hdc, &borderRect, NULL, g_iGrabHandleWidth / 2, PATCOPY);
        PatBltRectV(hdc, &borderRect, NULL, g_iGrabHandleHeight / 2, PATCOPY);
        HPEN hpenOld;
        hpenOld = (HPEN) SelectObject(hdc, GetStockObject(BLACK_PEN));
        if (!hpenOld)
            goto Cleanup;

        MoveToEx(hdc, borderRect.left, borderRect.top, (GDIPOINT *)NULL);
        LineTo(hdc, borderRect.left, borderRect.bottom - 1);
        LineTo(hdc, borderRect.right - 1, borderRect.bottom - 1);
        LineTo(hdc, borderRect.right - 1, borderRect.top);
        LineTo(hdc, borderRect.left, borderRect.top);
        
        if (hpenOld)
            SelectObject(hdc, hpenOld);
    }
    
    if (fHatch)
    {
        hbr = GetHatchBrush();
        if (!hbr)
            goto Cleanup;

        // Brush alignment code.
#ifndef WINCE
        // not supported on WINCE
        UnrealizeObject(hbr);
#endif
        SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(borderRect.left,8),
                           POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(borderRect.top,8), NULL);

        hbrOld = (HBRUSH) SelectObject(hdc, hbr);
        if ( ! hbrOld )
            goto Cleanup;
        //
        // Work out height of border
        //
        RECT rcBorder ;
        SetRect(&rcBorder ,0,0,g_iGrabHandleWidth,g_iGrabHandleHeight) ;
        pXform->TransformRect( &rcBorder);
        int borderSize = rcBorder.bottom -rcBorder.top ;
              
        PatBltRect(hdc, & borderRect, NULL, borderSize, PATCOPY );        
    }


//
// marka - we used to draw a border around positioned elements, access and VID
// have now said they don't want this anymore.
//
#ifdef NEVER    
    else
    {
        if (  _fIsPositioned )
        {
            // For a site with position=absolute, draw an extra rectangle around it when selected
            HPEN hpenOld;

            //InflateRect(&rc, -g_iGrabHandleWidth / 2, -g_iGrabHandleHeight / 2);

            hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(WHITE_BRUSH));
            if (!hbrOld)
                goto Cleanup;

            PatBltRectH(hdc, &rc, g_iGrabHandleWidth / 2, PATCOPY);
            PatBltRectV(hdc, &rc, g_iGrabHandleHeight / 2, PATCOPY);

            hpenOld = (HPEN) SelectObject(hdc, GetStockObject(BLACK_PEN));
            if (!hpenOld)
                goto Cleanup;

            MoveToEx(hdc, rc.left, rc.top, (GDIPOINT *)NULL);
            LineTo(hdc, rc.left, rc.bottom - 1);
            LineTo(hdc, rc.right - 1, rc.bottom - 1);
            LineTo(hdc, rc.right - 1, rc.top);
            LineTo(hdc, rc.left, rc.top);

            if (hpenOld)
                SelectObject(hdc, hpenOld);
         }
    }
#endif

Cleanup:
    if (hbrOld)
        SelectObject(hdc, hbrOld);
}

STDMETHODIMP
CGrabHandleAdorner::SetCursor(LONG lPartID)
{
    HRESULT hr = S_FALSE;
    ADORNER_HTI eAdorner = (ADORNER_HTI)lPartID;
    LPCTSTR idc;

    switch (eAdorner)
    {
    case ADORNER_HTI_TOPBORDER:
    case ADORNER_HTI_LEFTBORDER:
    case ADORNER_HTI_BOTTOMBORDER:
    case ADORNER_HTI_RIGHTBORDER:
        idc = IDC_SIZEALL;
        break;
    case ADORNER_HTI_BOTTOMRIGHTHANDLE:
    case ADORNER_HTI_TOPLEFTHANDLE:
        idc = IDC_SIZENWSE;
        break;
    case ADORNER_HTI_BOTTOMLEFTHANDLE:
    case ADORNER_HTI_TOPRIGHTHANDLE:
        idc = IDC_SIZENESW;
        break;
    case ADORNER_HTI_TOPHANDLE:
    case ADORNER_HTI_BOTTOMHANDLE:
        idc = IDC_SIZENS;
        break;
    case ADORNER_HTI_LEFTHANDLE:
    case ADORNER_HTI_RIGHTHANDLE:
        idc = IDC_SIZEWE;
        break;
    case ADORNER_HTI_NONE:
        return S_FALSE;
    default:
        AssertSz(0, "Unexpected ADORNER_HTI");
        return S_FALSE;
    }

    HCURSOR hcursor = LoadCursorA(NULL, (char *)idc);

    Assert(hcursor);
    if (hcursor)
    {
        ::SetCursor(hcursor);
        return S_OK;
    }
    
    hr = GetLastError();
    RRETURN(hr);
}


static struct
{
    ADORNER_HTI eHTI;
    TCHAR *     pszName;
}
s_GrabHandleAdornerPartTable[] = 
    {
        { ADORNER_HTI_TOPBORDER,            _T("topborder") },
        { ADORNER_HTI_RIGHTBORDER,          _T("rightborder") },
        { ADORNER_HTI_BOTTOMBORDER,         _T("bottomborder") },
        { ADORNER_HTI_LEFTBORDER,           _T("leftborder") },
        { ADORNER_HTI_TOPLEFTHANDLE,        _T("handleTopLeft") },
        { ADORNER_HTI_TOPHANDLE,            _T("handleTop") },
        { ADORNER_HTI_TOPRIGHTHANDLE,       _T("handleTopRight") },
        { ADORNER_HTI_RIGHTHANDLE,          _T("handleRight") },
        { ADORNER_HTI_BOTTOMRIGHTHANDLE,    _T("handleBottomRight") },
        { ADORNER_HTI_BOTTOMHANDLE,         _T("handleBottom") },
        { ADORNER_HTI_BOTTOMLEFTHANDLE,     _T("handleBottomLeft") },
        { ADORNER_HTI_LEFTHANDLE,           _T("handleLeft") },
    };

STDMETHODIMP
CGrabHandleAdorner::StringFromPartID(LONG lPartID, BSTR *pbstrPart)
{
    HRESULT hr = E_FAIL;
    ADORNER_HTI eAdorner = (ADORNER_HTI)lPartID;

    for (int k=0; k<ARRAY_SIZE(s_GrabHandleAdornerPartTable); ++k)
    {
        if (s_GrabHandleAdornerPartTable[k].eHTI == eAdorner)
        {
            hr = THR(EdUtil::FormsAllocString( s_GrabHandleAdornerPartTable[k].pszName, pbstrPart ));
            break;
        }
    }

    RRETURN(hr);
}

CActiveControlAdorner::CActiveControlAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked )
                        : CGrabHandleAdorner( pIElement , pIDoc, fLocked)
{
    _fPrimary = TRUE;
}

CActiveControlAdorner::~CActiveControlAdorner()
{
}

void
CActiveControlAdorner::GetGrabRect(ADORNER_HTI htc, RECT * prcOut, RECT * prcIn /* = NULL */)
{
    Assert(!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles() ) );

    CGrabHandleAdorner::GetGrabRect(htc, prcOut, prcIn);
}

BOOL 
CActiveControlAdorner::IsInMoveArea(POINT ptLocal,  ADORNER_HTI *pGrabAdorner /*=NULL*/ )
{
    if (_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()) 
        return FALSE;
    
    return (CGrabHandleAdorner::IsInMoveArea(ptLocal, pGrabAdorner ));        
}

BOOL 
CActiveControlAdorner::IsInResizeHandle(POINT ptLocal, ADORNER_HTI *pGrabAdorner)
{
    if (_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()) 
        return FALSE;

    return (CGrabHandleAdorner::IsInResizeHandle(ptLocal, pGrabAdorner));
}

void
CActiveControlAdorner::DrawGrabHandles(CEditXform* pXform , HDC hdc, RECT *prc )
{
    if ( !(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()))
    {
        CGrabHandleAdorner::DrawGrabHandles(pXform, hdc, prc );
    }
}

HRESULT
CActiveControlAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    HRESULT hr = S_OK;
    
    if (!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()))
    {
        CEditXform edXForm;
    
        if ( (lDrawFlags & HTMLPAINT_DRAW_USE_XFORM ) != 0 )
        { 
            HTML_PAINT_DRAW_INFO drawInfo;
        
            IGNORE_HR( _pPaintSite->GetDrawInfo( HTMLPAINT_DRAWINFO_XFORM , & drawInfo ) );
        
            edXForm.InitXform( & (drawInfo.xform ));
        }

        DrawGrabBorders( & edXForm, hdc, &rcBounds, TRUE );
        DrawGrabHandles( & edXForm, hdc, &rcBounds);       
    }
    
    RRETURN(hr);   
}

void
CActiveControlAdorner::CalcRect(RECT * prc, POINT pt)
{
    Assert(!(_pManager->HasFocusAdorner() && GetCommandTarget()->IsDisableEditFocusHandles()));

    CGrabHandleAdorner::CalcRect(prc, pt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGrabHandleAdorner::CalcRect
//
//  Synopsis:   Calculates the rect used for sizing or selection
//
//  Arguments:  [prc] -- Place to put new rect.
//              [pt]  -- Physical point which is the new second coordinate of
//                         the rectangle.
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::CalcRect(RECT * prc, POINT pt)
{
    RectFromPoint(prc, pt);

    //
    // Adjust the rect to be the rect of the element being resized.
    //
    InflateRect(prc, -g_iGrabHandleWidth, -g_iGrabHandleHeight);
}

//+---------------------------------------------------------------------------
//
//  Member:     CursorTracker::RectFromPoint
//
//  Synopsis:   Calculates the rect used for sizing or selection
//
//  Arguments:  [prc] -- Place to put new rect.
//              [pt]  -- Physical point which is the new second coordinate of
//                         the rectangle.
//
//----------------------------------------------------------------------------

void
CGrabHandleAdorner::RectFromPoint(RECT * prc, POINT pt)
{
    //
    // Calc how far we've moved from the point where the tracker started.
    //
    int     dx = pt.x - _ptFirst.x;
    int     dy = pt.y - _ptFirst.y;

    //
    // Return the rect we started with.
    //
    *prc = _rcFirst;

    //
    // Adjust the returned rect based on how far we've moved and which edge
    // is being adjusted.
    //
    if (_adj & CT_ADJ_LEFT)
    {   
        prc->left   += dx;
        
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Left adjusted by:%ld. left:%ld", dx, prc->left));
#endif
    }        

    if (_adj & CT_ADJ_TOP)
    {
        prc->top    += dy;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Top adjusted by:%ld. top:%ld", dy, prc->top));
#endif        
    } 
    
    if (_adj & CT_ADJ_RIGHT)
    {
        prc->right  += dx;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Right adjusted by:%ld. right:%ld", dx, prc->right));
#endif 
    }        

    if (_adj & CT_ADJ_BOTTOM)       
    {
        prc->bottom += dy;
#if DBG == 1
        TraceTag((tagAdornerShowAdjustment, "RectFromPoint. Bottom adjusted by:%ld. bototm:%ld", dy, prc->bottom));
#endif        
    }        
    //
    // Fix the left and right edges if they have become swapped.  This
    // occurs if the left edge has been moved right of the right edge,
    // or vice versa.
    //
    if (prc->right < prc->left)
    {
         if (_adj & CT_ADJ_LEFT)
             prc->left  = prc->right ;
         else
             prc->right = prc->left  ;
    }

    //
    // Same as above but with the top and bottom.
    //
    if (prc->bottom < prc->top)
    {
         if (_adj & CT_ADJ_TOP)
             prc->top    = prc->bottom ;
         else
             prc->bottom = prc->top ;
    }
}

BOOL
CGrabHandleAdorner::IsEditable()
{
    return TRUE;
}

BOOL
CSelectedControlAdorner::IsEditable()
{
    return FALSE;
}

CSelectedControlAdorner::CSelectedControlAdorner( IHTMLElement* pIElement , IHTMLDocument2 * pIDoc, BOOL fLocked)
        : CGrabHandleAdorner( pIElement , pIDoc, fLocked)
{

}

CSelectedControlAdorner::~CSelectedControlAdorner()
{

}

HRESULT
CSelectedControlAdorner::Draw(RECT rcBounds, RECT rcUpdate, LONG lDrawFlags, HDC hdc, LPVOID pvDrawObject)
{
    HRESULT hr = S_OK;

    DWORD       dwRop;
    HBRUSH      hbrOld = NULL;
    HBRUSH      hbr;
    POINT       pt ;
    VARIANT     var;

    if (GetCommandTarget()->IsDisableEditFocusHandles())
        goto Cleanup;

    //
    // Check the background color of the doc.
    //

    VariantInit(&var);
    _pIDoc->get_bgColor( & var );
    if (V_VT(&var) == VT_BSTR
        && (V_BSTR(&var) != NULL)
        && (StrCmpW(_T("#FFFFFF"), V_BSTR(&var)) == 0))
    {
        dwRop = DST_PAT_NOT_OR;
    }
    else
    {
        dwRop = DST_PAT_AND;
    }
    VariantClear(&var);
    
    GetViewportOrgEx (hdc, &pt) ;


    SetTextColor(hdc, RGB(0, 0, 0));
    SetBkColor(hdc, RGB(255, 255, 255));

    //
    // In the code below, before each select of a brush into the dc, we do
    // an UnrealizeObject followed by a SetBrushOrgEx.  This assures that
    // the brush pattern is properly aligned in that face of scrolling,
    // resizing or dragging the form containing the "bordered" object.
    //

    hbr = GetHatchBrush();
    if (!hbr)
        goto Cleanup;

    // Brush alignment code.
#ifndef WINCE
    // not supported on WINCE
    UnrealizeObject(hbr);
#endif
    SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8)+POSITIVE_MOD(rcBounds.left,8),
                       POSITIVE_MOD(pt.y,8)+POSITIVE_MOD(rcBounds.top,8), NULL);

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);
    if (!hbrOld)
        goto Cleanup;

    PatBltRect(hdc, &rcBounds, NULL, 4, dwRop);
    
Cleanup:
    if (hbrOld)
        SelectObject(hdc, hbrOld);

    RRETURN ( hr );        
}

void 
CGrabHandleAdorner::GetControlRect(RECT* prc)
{
    TransformRectLocal2Global(&_rcControl, prc);
}


VOID
CGrabHandleAdorner::SetPrimary(BOOL bIsPrimary)
{
    if (ENSURE_BOOL(_fPrimary) != bIsPrimary)
    {
        // Set the new value
        _fPrimary = bIsPrimary;

        // Redraw
        InvalidateAdorner();
    }
}

ELEMENT_CORNER
CGrabHandleAdorner::GetElementCorner()
{
    ELEMENT_CORNER eHandle = ELEMENT_CORNER_NONE;

    if (_adj & CT_ADJ_LEFT)
    {
        eHandle = (_adj & CT_ADJ_TOP)    ? ELEMENT_CORNER_TOPLEFT    : 
                  (_adj & CT_ADJ_BOTTOM) ? ELEMENT_CORNER_BOTTOMLEFT :
                                           ELEMENT_CORNER_LEFT ;
    }
    else if (_adj & CT_ADJ_RIGHT)
    {
        eHandle = (_adj & CT_ADJ_TOP)    ? ELEMENT_CORNER_TOPRIGHT :
                  (_adj & CT_ADJ_BOTTOM) ? ELEMENT_CORNER_BOTTOMRIGHT : 
                                           ELEMENT_CORNER_RIGHT;
    }
    else if (_adj & CT_ADJ_TOP)
    {
        eHandle = ELEMENT_CORNER_TOP ;
    }
    else if (_adj & CT_ADJ_BOTTOM)
    {
        eHandle = ELEMENT_CORNER_BOTTOM ;
    }
    
    return eHandle ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\edcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_SELMAN_HXX_
#define _X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

MtDefine(EditCommand, Edit, "Commands")
MtDefine(CCommand, EditCommand, "CCommand")
MtDefine(CCommandTable, EditCommand, "CCommandTable")

DeclareTag(tagEdCmd, "Edit", "Command Routing")


//
// CCommandTable
//

CCommandTable::CCommandTable(unsigned short iInitSize)
{
    _rootNode = NULL;
}

CCommandTable::~CCommandTable()
{
    // TODO - Make this non-recursive
    // We want to delete all the pointers in the command table
    _rootNode->Passivate();

}


void CCommand::Passivate()
{
    if( _leftNode )
        _leftNode->Passivate();

    if( _rightNode )
        _rightNode->Passivate();

    delete this;
}    


CCommand::CCommand( 
    DWORD                     cmdId, 
    CHTMLEditor *             pEd )
{
    _pEd = pEd;
    _cmdId = cmdId;
    _leftNode = NULL;
    _rightNode = NULL;

}

CHTMLEditor * 
CCommand::GetEditor()
{ 
    return _pEd;
}

IHTMLDocument2* 
CCommand::GetDoc() 
{ 
    return _pEd->GetDoc(); 
}

IMarkupServices2* 
CCommand::GetMarkupServices() 
{ 
    return _pEd->GetMarkupServices();
}

IDisplayServices* 
CCommand::GetDisplayServices() 
{ 
    return _pEd->GetDisplayServices();
}

BOOL
CCommand::IsSelectionActive()
{
    HRESULT         hr;
    SP_ISegmentList spSegmentList;
    SELECTION_TYPE  eSelectionType;
    BOOL            fEmpty = FALSE;
    
    // If the selection is still active, do nothing for the command
    //

    IFC( GetSegmentList(&spSegmentList) );
    IFC( spSegmentList->GetType(&eSelectionType) );
    IFC( spSegmentList->IsEmpty(&fEmpty) );

    if( (eSelectionType == SELECTION_TYPE_Text) && (fEmpty == FALSE) )
    {
        CSelectionManager *pSelMan = GetEditor()->GetSelectionManager();        
        if (pSelMan->GetActiveTracker() && pSelMan->GetSelectionType() == SELECTION_TYPE_Text)
        {
            CSelectTracker *pSelectTracker = DYNCAST(CSelectTracker, pSelMan->GetActiveTracker());

            if (!pSelectTracker->IsPassive() && ! pSelectTracker->IsWaitingForMouseUp() )
                return TRUE; // done
        }
    }

Cleanup:
    return FALSE;
}    

CMshtmlEd* 
CCommand::GetCommandTarget()
{
    return GetEditor()->TopCommandTarget();
}

HRESULT 
CCommand::Exec( 
    DWORD                    nCmdexecopt,
    VARIANTARG *             pvarargIn,
    VARIANTARG *             pvarargOut,
    CMshtmlEd *              pTarget  )
{
    HRESULT           hr, hrResult;
    BOOL              fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(pvarargOut == NULL);

    IFC( GetEditor()->PushCommandTarget(pTarget) );

    hrResult = THR( PrivateExec( nCmdexecopt, pvarargIn, pvarargOut ));
    
    IFC( GetEditor()->PopCommandTarget( WHEN_DBG(pTarget) ) );

    hr = hrResult;
    
Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);
    RRETURN( hr );
}    

HRESULT 
CCommand::QueryStatus( 
    OLECMD                     rgCmds[],
    OLECMDTEXT *             pcmdtext,
    CMshtmlEd *              pTarget  )
{
    HRESULT hr = S_OK;
    HRESULT hrResult = S_OK;

    IFC( GetEditor()->PushCommandTarget(pTarget) );

    //
    // Put any command that we want to enable in 
    // IME COMPOSITION mode here. 
    // For now, simply disable most edit CMD here.      
    // [zhenbinx]
    //
    switch (rgCmds[0].cmdID)
    {
        case IDM_IME_ENABLE_RECONVERSION:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_FONTNAME:
        case IDM_FONTSIZE:
            //
            // Put the Cmds we want to enable here
            //
            break;
            
        default:
            if (GetEditor() && GetEditor()->GetSelectionManager())
            {
                if (GetEditor()->GetSelectionManager()->IsIMEComposition())
                {
                    TraceTag((tagEdCmd, "DISABLED cmd %d due to IME composition", rgCmds[0].cmdID));
                    rgCmds[0].cmdf = MSOCMDSTATE_DISABLED;
                    goto Finished;
                }
            }
            break;
    }
    hrResult = THR( PrivateQueryStatus( rgCmds, pcmdtext ));

Finished:
    IFC( GetEditor()->PopCommandTarget( WHEN_DBG(pTarget) ) );

    hr = hrResult;
    
Cleanup:
    RRETURN( hr );
}    
 

HRESULT
CCommand::GetSegmentList( ISegmentList ** ppSegmentList ) 
{ 
    HRESULT hr = E_UNEXPECTED;
    AssertSz( GetCommandTarget() != NULL , "Attempt to get the segment list without a valid command target." );
    if( GetCommandTarget() == NULL )
        goto Cleanup;
        
    hr = THR( GetCommandTarget()->GetSegmentList( ppSegmentList ));

Cleanup:
    RRETURN( hr );
}

BOOL
CCommand::SegmentListContainsPassword( ISegmentList *pISegmentList )
{
    HRESULT                 hr = S_OK;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IHTMLElement         spElement;
    ED_PTR                  ( edStart );
    ED_PTR                  ( edEnd );
    BOOL                    fPassword = FALSE;
    BOOL                    fEmpty = FALSE;

    Assert(pISegmentList);
    IFC( pISegmentList->IsEmpty( &fEmpty ) );
    
    if (!fEmpty)
    {
        IFC( pISegmentList->CreateIterator(&spIter) );
        Assert(S_FALSE == spIter->IsDone());

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current(&spSegment) );
            IFC( spIter->Advance() );
        
            IFC( spSegment->GetPointers(edStart, edEnd) );
            IFC( edStart->CurrentScope(&spElement) );

            if (spElement == NULL)
                continue;
                
            IFC( GetEditor()->IsPassword(spElement, &fPassword) );
            if (fPassword)
                break;
        }
    }

Cleanup:
    return fPassword;
}

CSpringLoader*
CCommand::GetSpringLoader() 
{ 
    AssertSz( GetCommandTarget() != NULL , "Attempt to get the spring loader without a valid command target." );
    if( GetCommandTarget() == NULL )
        return NULL;

    return GetCommandTarget()->GetSpringLoader();
}

BOOL
CCommand::CanSplitBlock( IMarkupServices *pMarkupServices , IHTMLElement* pElement )
{
    ELEMENT_TAG_ID curTag = TAGID_NULL;

    THR( pMarkupServices->GetElementTagId( pElement, &curTag  ));

    //
    // TODO: make sure this is a complete list [ashrafm]
    //
    
    switch( curTag )
    {
        case TAGID_P:
        case TAGID_DIV:
        case TAGID_LI:
        case TAGID_BLOCKQUOTE:
        case TAGID_H1:
        case TAGID_H2:
        case TAGID_H3:
        case TAGID_H4:
        case TAGID_H5:
        case TAGID_H6:
        case TAGID_HR:
        case TAGID_CENTER:
        case TAGID_PRE:
        case TAGID_ADDRESS:
            return true;

        default:
            return false;
    }
}


CCommand::~CCommand()
{
}


//+==========================================================================
//  CCommandTable::Add
//
//  Add an entry to the command table.
//
//---------------------------------------------------------------------------

VOID
CCommandTable::Add( CCommand* pCommandEntry )
{
    CCommand* pInsertNode = NULL;

    if ( _rootNode == NULL )
        _rootNode = pCommandEntry;
    else
    {
        Verify(!FindEntry( pCommandEntry->GetCommandId() , &pInsertNode));
        Assert( pInsertNode );

        if ( pInsertNode->GetCommandId() > pCommandEntry->GetCommandId() )
            pInsertNode->SetLeft( pCommandEntry );
        else
            pInsertNode->SetRight( pCommandEntry );
    }

}

//+==========================================================================
//  CCommandTable::Get
//
//  Get the Contents of a Node with the given key entry - or null if none exists
//
//---------------------------------------------------------------------------

CCommand*
CCommandTable::Get(DWORD entryKey )
{
    CCommand* pFoundNode = NULL;

    if (  FindEntry( entryKey, &pFoundNode ) )
    {
        Assert( pFoundNode );
        return pFoundNode ;
    }
    else
    {
        return NULL;
    }
}

//+==========================================================================
//  CCommandTable::FindEntry
//
//  Find a given key entry.
//
//  RESULT:
//      1  - we found an entry with the given key. pFoundNode points to it
//      0  - didn't find an entry. pFoundNode points to the last node in the tree
//           where we were. You can test pFoundNode for where to insert the next node.
//
//---------------------------------------------------------------------------

short
CCommandTable::FindEntry(DWORD entryKey, CCommand** ppFoundNode )
{
    CCommand *pCommandEntry = _rootNode;
    short result = 0;

    while ( pCommandEntry != NULL)
    {
        if ( pCommandEntry->GetCommandId() == entryKey)
        {
            result = 1;
            *ppFoundNode = pCommandEntry;
            break;
        }
        else
        {
            *ppFoundNode = pCommandEntry;

            if ( pCommandEntry->GetCommandId() > entryKey )
            {
                pCommandEntry = pCommandEntry->GetLeft();
            }
            else
                pCommandEntry = pCommandEntry->GetRight();
        }
    }

    return result;
}

#if DBG == 1
VOID
CCommand::DumpTree( IUnknown* pUnknown)
{
    IOleCommandTarget  *  pHost = NULL;
    Assert( pUnknown );
    GUID theGUID = CGID_MSHTML;
    IGNORE_HR( pUnknown->QueryInterface( IID_IOleCommandTarget,  (void**)& pHost ) ) ;
    IGNORE_HR( pHost->Exec( &theGUID , IDM_DEBUG_DUMPTREE, 0, NULL, NULL  ));

    ReleaseInterface( pHost );

}

#endif

//+---------------------------------------------------------------------------
//
//  CCommand::GetSegmentElement
//
//----------------------------------------------------------------------------
HRESULT CCommand::GetSegmentElement(IMarkupServices *pMarkupServices, 
                                    IMarkupPointer  *pStart, 
                                    IMarkupPointer  *pEnd, 
                                    IHTMLElement    **ppElement,
                                    BOOL            fOuter)
{
    HRESULT             hr = E_FAIL;
    MARKUP_CONTEXT_TYPE context, contextGoal;
    IHTMLElement        *pElementRHS = NULL;
    IObjectIdentity     *pObjectIdent = NULL;    

    *ppElement = NULL;
    
    //
    // Is there an element right at this position?  If so,
    // return it.  Otherwise, fail.
    //
    
    //
    // Find the left side element
    //

    if (fOuter)
    {
        if (FAILED(THR( pStart->Left( FALSE, &context, ppElement, NULL, NULL ))))
            goto Cleanup;
            
        contextGoal = CONTEXT_TYPE_ExitScope;
    }
    else
    {
        if (FAILED(THR(pStart->Right( FALSE, &context, ppElement, NULL, NULL ))))
            goto Cleanup;
            
        contextGoal = CONTEXT_TYPE_EnterScope;
    }
        
    if (context != contextGoal && (context != CONTEXT_TYPE_NoScope || !(*ppElement)))
        goto Cleanup; // fail

    //
    // Check to see if the right side is a div element
    //

    if (fOuter)
    {
        if (FAILED(THR(pEnd->Right( FALSE, &context, &pElementRHS, NULL, NULL ))))
            goto Cleanup;
    }
    else
    {
        if (FAILED(THR(pEnd->Left(FALSE, &context, &pElementRHS, NULL, NULL))))
            goto Cleanup;
    }

    if (context != contextGoal && (context != CONTEXT_TYPE_NoScope || !(*ppElement)))
        goto Cleanup; // fail

    //
    // Check if the elements are the same
    //

    if (FAILED(THR(pElementRHS->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pObjectIdent))))
        goto Cleanup; // fail

    hr = THR(pObjectIdent->IsEqualObject(*ppElement));

Cleanup:
    if (FAILED(hr))
        ClearInterface(ppElement);

    ReleaseInterface(pElementRHS);
    ReleaseInterface(pObjectIdent);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:       SplitInfluenceElement
//
//  Synopsis:     Given an IHTMLElement* that influences a pair of pointers - adjust the element's
//                influence - so it no longer influences the range
//
//                Various Remove and Insert Operations will be involved here.
//
//  ppElementNew - if passed in a Pointer to a New Element, and a New Element is created
//                  this returns the new element that's been created.
//----------------------------------------------------------------------------
HRESULT
CCommand::SplitInfluenceElement(
                    IMarkupServices * pMarkupServices,
                    IMarkupPointer* pStart,
                    IMarkupPointer* pEnd,
                    IHTMLElement* pElement,
                    elemInfluence inElemInfluence,
                    IHTMLElement** ppElementNew )
{
    IMarkupPointer *pStartPointer = NULL ;
    IMarkupPointer *pEndPointer = NULL ;
    IHTMLElement *pNewElement = NULL;
    HRESULT hr = S_OK;
    BOOL    bEqual = FALSE;

    switch ( inElemInfluence )
    {
        case elemInfluenceWithin:
        {
            hr = pMarkupServices->RemoveElement( pElement );
        }
        break;

        case elemInfluenceCompleteContain:
        {
            hr = GetEditor()->CreateMarkupPointer( & pStartPointer   );
            if (!hr) hr = pStartPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin );
            if (!hr) hr = pStartPointer->SetGravity(POINTER_GRAVITY_Right);
            if (!hr) hr = GetEditor()->CreateMarkupPointer( & pEndPointer );
            if (!hr) hr = pEndPointer->SetGravity(POINTER_GRAVITY_Left);
            if (!hr) hr = pEndPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd );
            if (hr) goto Cleanup;

            hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pStartPointer->IsEqualTo(pStart, &bEqual));
            if (hr) goto Cleanup;
            
            if (!bEqual)
            {
                hr = InsertElement(pMarkupServices, pElement, pStartPointer, pStart );
                if (hr) goto Cleanup;
            }

            hr = THR(pEndPointer->IsEqualTo(pEnd, &bEqual));
            if (hr) goto Cleanup;
            
            if (!bEqual)
            {
                hr = pMarkupServices->CloneElement( pElement, &pNewElement );
                if (!hr) hr = InsertElement(pMarkupServices, pNewElement, pEnd , pEndPointer );
            }

            if ( ppElementNew )
            {
                *ppElementNew = pNewElement;
            }
        }
        break;

        case elemInfluenceOverlapWithin:
        {
            hr = GetEditor()->CreateMarkupPointer( & pEndPointer   );
            if (!hr) hr = pEndPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterEnd );
            if (hr) goto Cleanup;

            if (!hr) hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pEndPointer->IsEqualTo(pEnd, &bEqual));
            if (hr) goto Cleanup;

            if (!bEqual)
            {
                hr = InsertElement(pMarkupServices, pElement, pEnd, pEndPointer );
            }

        }
        break;

        case elemInfluenceOverlapOutside:
        {
            hr = GetEditor()->CreateMarkupPointer( & pStartPointer   );
            if (!hr) hr = pStartPointer->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeBegin );
            if (hr) goto Cleanup;

            hr = pMarkupServices->RemoveElement( pElement );
            if (!hr) hr = THR(pStart->IsEqualTo(pStartPointer, &bEqual));
            if (hr) goto Cleanup;

            if (!bEqual)
            {
                if ( ! hr ) hr = InsertElement(pMarkupServices, pElement, pStartPointer, pStart );
                if (hr) goto Cleanup;
            }
        }
        break;
    }

Cleanup:
    ReleaseInterface( pStartPointer );
    ReleaseInterface( pEndPointer );
    if ( ! ppElementNew ) ReleaseInterface( pNewElement );

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Method:       GetElementInfluenceOverPointers
//
//  Synopsis:     Given an IHTMLElement* determine how that tag Influences
//                the pair of tree pointers.
//
//                See header file EdTree.hxx for description of different
//                values of tagInfluence
//
//----------------------------------------------------------------------------

// TODO: be careful about contextually equal pointers here [ashrafm]

elemInfluence
CCommand::GetElementInfluenceOverPointers( IMarkupServices* pMarkupServices, IMarkupPointer* pStart, IMarkupPointer * pEnd, IHTMLElement* pInfluenceElement )
{
    elemInfluence theInfluence = elemInfluenceNone ;
    int iStartStart, iStartEnd, iEndStart, iEndEnd;
    iStartStart = iStartEnd = iEndStart = iEndEnd = 0;
    IMarkupPointer *pStartInfluence = NULL ;
    IMarkupPointer *pEndInfluence = NULL ;

    GetEditor()->CreateMarkupPointer( & pStartInfluence );
    GetEditor()->CreateMarkupPointer( & pEndInfluence );
    Assert( pStartInfluence && pEndInfluence );
    pStartInfluence->MoveAdjacentToElement( pInfluenceElement, ELEM_ADJ_BeforeBegin );
    pEndInfluence->MoveAdjacentToElement( pInfluenceElement, ELEM_ADJ_AfterEnd );

    OldCompare( pStart, pStartInfluence, &iStartStart);
    OldCompare( pEnd, pEndInfluence, & iEndEnd);

    if ( iStartStart == RIGHT ) // Start is to Right of Start of Range
    {
        if ( iEndEnd == LEFT ) // End is to Left of End of Range
            theInfluence = elemInfluenceWithin;
        else
        {
            // End is Inside Range - where is the Start ?

            OldCompare( pEnd, pStartInfluence, & iStartEnd );
            if ( iStartEnd == LEFT ) // Start is Inside Range, End is Outside
            {
                theInfluence = elemInfluenceOverlapWithin;
            }
            else
                theInfluence = elemInfluenceNone; // completely outside range
        }
    }
    else // Start is to Left of Range.
    {
        if ( iEndEnd == RIGHT ) // End is Outside
            theInfluence = elemInfluenceCompleteContain;
        else
        {
            // Start is Outside Range - where does End Start
            OldCompare( pStart, pEndInfluence, &iEndStart );
            if ( iEndStart == RIGHT )
            {
                // End is to Right of Start
                theInfluence = elemInfluenceOverlapOutside;
            }
            else
                theInfluence = elemInfluenceNone;
        }
    }

    ReleaseInterface( pStartInfluence );
    ReleaseInterface( pEndInfluence );

    return theInfluence;
}


//=========================================================================
// CCommand: GetSegmentPointers
//
// Synopsis: Get start/end pointers for a specified segment
//-------------------------------------------------------------------------

HRESULT CCommand::GetFirstSegmentPointers(ISegmentList    *pSegmentList,
                                          IMarkupPointer  **ppStart,
                                          IMarkupPointer  **ppEnd)
{
    HRESULT                 hr;
    IMarkupPointer          *pStart = NULL;
    IMarkupPointer          *pEnd = NULL;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    
    // We need these guys so either use the users pointers or local ones
    if (ppStart == NULL)
        ppStart = &pStart;

    if (ppEnd == NULL)
        ppEnd = &pEnd;

    // Move pointers to segment
    IFC(GetEditor()->CreateMarkupPointer(ppStart));
    IFC(GetEditor()->CreateMarkupPointer(ppEnd));

    // Create the iterator, and retrieve the first segment.  This will
    // fail if no first segment exists
    IFC( pSegmentList->CreateIterator( &spIter ) );
    IFC( spIter->Current( &spSegment ) )
    
    IFC( spSegment->GetPointers( *ppStart, *ppEnd ));

Cleanup:
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    RRETURN(hr);
}

//=========================================================================
//
// CCommand: ClingToText
//
//-------------------------------------------------------------------------
HRESULT
CCommand::ClingToText(IMarkupPointer *pMarkupPointer, Direction direction, IMarkupPointer *pLimit, 
                      BOOL fSkipExitScopes /* = FALSE */, BOOL fIgnoreWhiteSpace /* = FALSE */)
{
    HRESULT             hr;
    CEditPointer        epPosition(GetEditor(), pMarkupPointer);
    DWORD               dwSearch, dwFound;
    DWORD               dwSearchReverse;
    DWORD               dwScanOptions = SCAN_OPTION_SkipControls;

    if (fIgnoreWhiteSpace)
        dwScanOptions |= SCAN_OPTION_SkipWhitespace;

    Assert(direction == LEFT || direction == RIGHT);

    // Set boundary on the edit pointer
    if (pLimit)
    {
        if (direction == LEFT)
            IFR( epPosition.SetBoundary(pLimit, NULL) )        
        else
            IFR( epPosition.SetBoundary(NULL, pLimit) );            
    }

    // Do cling to text
    dwSearch = BREAK_CONDITION_Text           |
               BREAK_CONDITION_NoScopeSite    |
               BREAK_CONDITION_NoScopeBlock   |
               BREAK_CONDITION_ExitSite       | 
               (fSkipExitScopes ? 0 : BREAK_CONDITION_ExitBlock)     |
               BREAK_CONDITION_Control;

    IFR( epPosition.Scan(direction, dwSearch, &dwFound, NULL, NULL, NULL, dwScanOptions) );
    
    if (!epPosition.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
    {
        dwSearchReverse = BREAK_CONDITION_Text           |
                          BREAK_CONDITION_NoScopeSite    |
                          BREAK_CONDITION_NoScopeBlock   |
                          BREAK_CONDITION_EnterSite      | 
                          (fSkipExitScopes ? 0: BREAK_CONDITION_EnterBlock)     |
                          BREAK_CONDITION_Control;

        // move back before break condition
        IFR( epPosition.Scan(Reverse(direction), dwSearchReverse, &dwFound, NULL, NULL, NULL, dwScanOptions) );     }

    // Return pMarkupPointer
    IFR( pMarkupPointer->MoveToPointer(epPosition) );

    return S_OK;
}

//=========================================================================
//
// CCommand: Move
//
//-------------------------------------------------------------------------

HRESULT 
CCommand::Move(
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    HRESULT                 hr;
    MARKUP_CONTEXT_TYPE     context;
    SP_IHTMLElement         spElement;
    SP_IMarkupPointer       spPointer;
    ELEMENT_TAG_ID          tagId;
    BOOL                    fSite;

    Assert(direction == LEFT || direction == RIGHT);

    if (!fMove)
    {
        IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFR( spPointer->MoveToPointer(pMarkupPointer) );
        
        pMarkupPointer = spPointer; // weak ref 
    }
    
    for (;;)
    {
        if (direction == LEFT)
            IFC( pMarkupPointer->Left( TRUE, &context, &spElement, NULL, NULL ) )
        else
            IFC( pMarkupPointer->Right( TRUE, &context, &spElement, NULL, NULL ) );

        switch (context)
        {
            case CONTEXT_TYPE_EnterScope:
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                if (IsIntrinsic(GetMarkupServices(), spElement))
                {
                    if (direction == LEFT)
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) )
                    else
                        IFC( pMarkupPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ) ); 
                }
                // fall through
                           
            case CONTEXT_TYPE_ExitScope:
            case CONTEXT_TYPE_Text:
            case CONTEXT_TYPE_None:
                goto Cleanup; // done;
                break;  

            case CONTEXT_TYPE_NoScope:                
                IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fSite));
                if (!fSite)
                {
                    // We don't want to move past BRs - bug69300.
                    ELEMENT_TAG_ID tagIdElement;

                    IFC( GetMarkupServices()->GetElementTagId(spElement, &tagIdElement) );
                    if (tagIdElement == TAGID_BR)
                        goto Cleanup;

                    continue;
                }
                    
                goto Cleanup; // done;
                break;  
                            
            default:
                AssertSz(0, "CBaseCharCommand: Unsupported context");
                hr = E_FAIL; // CONTEXT_TYPE_None
                goto Cleanup;
        }
    }
    
Cleanup:
    if (ppElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppElement = spElement;
            if (*ppElement)
                (*ppElement)->AddRef();
        }
        else
        {
            *ppElement = NULL;
        }
    }
        
    if (pContext)
    {
        *pContext = (SUCCEEDED(hr)) ? context : CONTEXT_TYPE_None;
    }    

    RRETURN(hr);
}

//=========================================================================
//
// CCommand: MoveBack
//
//-------------------------------------------------------------------------

HRESULT 
CCommand::MoveBack(
    IMarkupPointer          *pMarkupPointer, 
    Direction               direction, 
    BOOL                    fMove,
    MARKUP_CONTEXT_TYPE *   pContext,
    IHTMLElement * *        ppElement)
{
    if (direction == RIGHT)
    {
        RRETURN(Move(pMarkupPointer, LEFT, fMove, pContext, ppElement));
    }
    else
    {
        Assert(direction == LEFT);
        RRETURN(Move(pMarkupPointer, RIGHT, fMove, pContext, ppElement));
    }
}

//=========================================================================
// CCommand: GetActiveElemSegment
//
// Synopsis: Gets the segment for the active element
//-------------------------------------------------------------------------
HRESULT 
CCommand::GetActiveElemSegment( IMarkupServices *pMarkupServices,
                                IMarkupPointer  **ppStart,
                                IMarkupPointer  **ppEnd)
{
    HRESULT        hr;
    IHTMLElement   *pElement = NULL;
    IMarkupPointer *pStart = NULL;
    IMarkupPointer *pEnd = NULL;
    VARIANT_BOOL    fScoped;    
    IHTMLDocument2* pDoc = GetDoc();
    SP_IHTMLElement2 spElement2;
    
#if 0
    hr = THR(pMarkupServices->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pMarkupServices->QueryInterface(IID_IHTMLViewServices, (LPVOID *)&pVS));
    if (FAILED(hr))
        goto Cleanup;    
#endif //0
    
    hr = THR( pDoc->get_activeElement(&pElement));
    if (FAILED(hr) || !pElement)
        goto Cleanup;

    //
    // If a No-Scope is Active - don't position pointers inside.
    //
    IFC(pElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));
    IFC( spElement2->get_canHaveChildren( &fScoped ));
    if ( !fScoped )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    hr = GetEditor()->CreateMarkupPointer(&pStart);
    if (FAILED(hr))
        goto Cleanup;

    hr = GetEditor()->CreateMarkupPointer(&pEnd);
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(pStart->MoveAdjacentToElement( pElement, ELEM_ADJ_AfterBegin ));
    if (FAILED(hr))
        goto Cleanup;
        
    hr = THR(pEnd->MoveAdjacentToElement( pElement, ELEM_ADJ_BeforeEnd ));

Cleanup:
    if (SUCCEEDED(hr))
    {
        if (ppStart)
        {
            *ppStart = pStart;
            if (pStart)
                pStart->AddRef();
        }
        if (ppEnd)
        {
            *ppEnd = pEnd;
            if (pEnd)
                pEnd->AddRef();
        }
    }
#if 0
    ReleaseInterface(pDoc);
    ReleaseInterface(pVS);
#endif // 0    
    ReleaseInterface(pElement);
    ReleaseInterface(pStart);
    ReleaseInterface(pEnd);
    
    RRETURN(hr);

}

//=========================================================================
// CCommand: GetLeftAdjacentTagId
//
// Synopsis: Moves the markup pointer to an element tag with the specified
//           TAGID.  However, the pointer is not advanced past any text.
//
// Returns:  S_OK if found
//           S_FALSE if not found
//
//-------------------------------------------------------------------------
HRESULT
CCommand::GetLeftAdjacentTagId(  IMarkupServices *pMarkupServices,
                                 IMarkupPointer  *pMarkupPointer,
                                 ELEMENT_TAG_ID  tagIdTarget,
                                 IMarkupPointer  **ppLeft,
                                 IHTMLElement    **ppElement,
                                 MARKUP_CONTEXT_TYPE *pContext)
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagIdCurrent;
    IMarkupPointer      *pCurrent = NULL;
    IHTMLElement        *pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    //
    // Check to the left
    //

    hr = THR(CopyMarkupPointer(GetEditor(), pMarkupPointer, &pCurrent));
    if (FAILED(hr))
        goto Cleanup;

    for (;;) {
        hr = THR( pCurrent->Left( TRUE, &context, &pElement, NULL, NULL));
        if (FAILED(hr))
            break; // not found

        // TODO: maybe we can be more agressive and handle EnterScope as well [ashrafm]
        if (context != CONTEXT_TYPE_ExitScope)
            break; // not found

        hr = THR(pMarkupServices->GetElementTagId(pElement, &tagIdCurrent));
        if (FAILED(hr))
            goto Cleanup;

        if (tagIdCurrent == tagIdTarget)
        {
            // found tagid
            if (ppElement)
            {
                *ppElement = pElement;
                pElement->AddRef();
            }
            if (ppLeft)
            {
                 *ppLeft = pCurrent;
                 pCurrent->AddRef();
            }
            if (pContext)
                *pContext = context;

            goto Cleanup;
        }
        ClearInterface(&pElement);
    }

    hr = S_FALSE; // not found
    if (ppElement)
        *ppElement = NULL;

    if (ppLeft)
        *ppLeft = NULL;

Cleanup:
    ReleaseInterface(pCurrent);
    ReleaseInterface(pElement);

    RRETURN1(hr, S_FALSE);
}

//=========================================================================
// CCommand: GetRightAdjacentTagId
//
// Synopsis: Moves the markup pointer to an element tag with the specified
//           TAGID.  However, the pointer is not advanced past any text.
//
// Returns:  S_OK if found
//           S_FALSE if not found
//
//-------------------------------------------------------------------------
HRESULT
CCommand::GetRightAdjacentTagId( 
    IMarkupServices *pMarkupServices,
    IMarkupPointer  *pMarkupPointer,
    ELEMENT_TAG_ID  tagIdTarget,
    IMarkupPointer  **ppLeft,
    IHTMLElement    **ppElement,
    MARKUP_CONTEXT_TYPE *pContext )
{
    HRESULT             hr;
    ELEMENT_TAG_ID      tagIdCurrent;
    IMarkupPointer      *pCurrent = NULL;
    IHTMLElement        *pElement = NULL;
    MARKUP_CONTEXT_TYPE context;
    //
    // Check to the left
    //

    hr = THR(CopyMarkupPointer(GetEditor(), pMarkupPointer, &pCurrent));
    if (FAILED(hr))
        goto Cleanup;

    for (;;) {
        hr = THR( pCurrent->Right(TRUE, &context, &pElement, NULL, NULL));
        if (FAILED(hr))
            break; // not found

        // TODO: maybe we can be more agressive and handle EnterScope as well [ashrafm]
        if (context != CONTEXT_TYPE_ExitScope)
            break; // not found

        hr = THR(pMarkupServices->GetElementTagId(pElement, &tagIdCurrent));
        if (FAILED(hr))
            goto Cleanup;

        if (tagIdCurrent == tagIdTarget)
        {
            // found tagid
            if (ppElement)
            {
                *ppElement = pElement;
                pElement->AddRef();
            }
            if (ppLeft)
            {
                 *ppLeft = pCurrent;
                 pCurrent->AddRef();
            }
            if (pContext)
                *pContext = context;

            goto Cleanup;
        }
        ClearInterface(&pElement);
    }

    hr = S_FALSE; // not found
    if (ppElement)
        *ppElement = NULL;

    if (ppLeft)
        *ppLeft = NULL;

Cleanup:
    ReleaseInterface(pCurrent);
    ReleaseInterface(pElement);

    RRETURN1(hr, S_FALSE);
}

HRESULT CCommand::SplitElement(  IMarkupServices *pMarkupServices,
                                 IHTMLElement    *pElement,
                                 IMarkupPointer  *pTagStart,
                                 IMarkupPointer  *pSegmentEnd,
                                 IMarkupPointer  *pTagEnd,
                                 IHTMLElement    **ppNewElement )
{
    HRESULT      hr;
    IHTMLElement *pNewElement = NULL;
    
#if DBG==1  // make sure we don't split the body
    ELEMENT_TAG_ID tagId;
    INT            iPosition;
    
    hr = pMarkupServices->GetElementTagId(pElement, &tagId);
    Assert(hr == S_OK && tagId != TAGID_BODY);

    // Make sure the order of pTagStart, pSegmentEnd, and pTagEnd is right
    hr = OldCompare( pTagStart, pSegmentEnd, &iPosition);
    Assert(hr == S_OK && iPosition != LEFT);
    
    hr = OldCompare( pSegmentEnd, pTagEnd, &iPosition);
    Assert(hr == S_OK && iPosition != LEFT);       
#endif    

    hr = THR( pSegmentEnd->SetGravity( POINTER_GRAVITY_Right ));
    if ( FAILED(hr))
        goto Cleanup;
    hr = THR( pTagEnd->SetGravity( POINTER_GRAVITY_Right ));
    if ( FAILED(hr))
        goto Cleanup;      
    //
    // Move element to first part of range
    //
    hr = THR(pMarkupServices->RemoveElement(pElement));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(InsertElement(pMarkupServices, pElement, pTagStart, pSegmentEnd));
    if (FAILED(hr))
        goto Cleanup;

    //
    // Clone element for the rest of the range
    //

    IFC( pMarkupServices->CloneElement( pElement, &pNewElement ) );

    IFC( pSegmentEnd->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );

    IFC( InsertElement(pMarkupServices, pNewElement, pSegmentEnd, pTagEnd) );
    

Cleanup:
    if (ppNewElement)
    {
        if (SUCCEEDED(hr))
        {
            *ppNewElement = pNewElement;
            pNewElement->AddRef();
        }
        else
        {
            *ppNewElement = NULL;
        }
    }

    ReleaseInterface(pNewElement);
    RRETURN(hr);
}

HRESULT 
CCommand::InsertBlockElement(IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    SELECTION_TYPE      selectionType;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    SP_IDisplayPointer  spDispPointer;
    
    //
    // Get the selection type
    //
    
    IFR( GetSegmentList(&spSegmentList) ); 
    IFR( spSegmentList->GetType(&selectionType) );
#if DBG
    BOOL                fEmpty = FALSE;

    IFR( spSegmentList->IsEmpty(&fEmpty) );
    Assert( fEmpty == FALSE);
#endif    

    //
    // If we are a caret selection, make sure any new block elements inserted
    // at the caret position leave the caret inside
    //

    if (selectionType == SELECTION_TYPE_Caret)
    {        
        IFR( GetEditor()->CreateMarkupPointer(&spPointer) );
        IFR( GetDisplayServices()->GetCaret(&spCaret) );
        IFR( spCaret->MoveMarkupPointerToCaret(spPointer) );

        // Save display gravity to spDispPointer
        IFR( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFR( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
        
        IFR( EdUtil::InsertBlockElement(GetMarkupServices(), pElement, pStart, pEnd, spPointer) );

        IFR( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFR( spCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE ));
    }
    else
    {
        IFR( GetEditor()->InsertElement(pElement, pStart, pEnd) );
    }

    RRETURN(hr);
}

HRESULT 
CCommand::CreateAndInsert(ELEMENT_TAG_ID tagId, IMarkupPointer *pStart, IMarkupPointer *pEnd, IHTMLElement **ppElement)
{
    HRESULT         hr;
    SP_IHTMLElement  spElement;

    IFR( GetMarkupServices()->CreateElement(tagId, NULL, &spElement) );
    IFR( InsertBlockElement(spElement, pStart, pEnd) );

    if (ppElement)
    {
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }

    RRETURN(hr);    
}

HRESULT 
CCommand::CommonQueryStatus( 
        OLECMD *       pCmd,
        OLECMDTEXT *   pcmdtext )
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    SELECTION_TYPE      eSelectionType;
    BOOL                fEmpty = FALSE;
    
    pCmd->cmdf = MSOCMDSTATE_UP; // up by default
    
    IFR( GetSegmentList( &spSegmentList ));

    
    //
    // If there is no segment count, return up
    //
    IFR( spSegmentList->IsEmpty( &fEmpty ) );
    IFR( spSegmentList->GetType( &eSelectionType ) );
    
    if( fEmpty ) /// nothing to do
    {
        // enable by default
        if (eSelectionType == SELECTION_TYPE_None)        
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        
        return S_OK;
    }

    if (!CanAcceptHTML(spSegmentList))
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;
    }

    return S_FALSE; // not done
}

HRESULT 
CCommand::CommonPrivateExec( 
        DWORD                    nCmdexecopt,
        VARIANTARG *             pvarargIn,
        VARIANTARG *             pvarargOut )
{
    HRESULT             hr;
    SP_ISegmentList     spSegmentList;
    BOOL                fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( fEmpty ) /// nothing to do
        return S_OK;
    
    if (!CanAcceptHTML(spSegmentList))
    {
        if (pvarargOut)
        {
            return S_FALSE; // not handled
        }
        return E_FAIL;
    }

    return S_FALSE; // not done
}


BOOL 
CCommand::CanAcceptHTML(ISegmentList *pSegmentList)
{
    HRESULT                 hr;
    BOOL                    bResult = FALSE;
    SP_IHTMLElement         spFlowElement;
    SP_IHTMLElement3        spElement3;
    SP_IMarkupPointer       spStart;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    
    IFC( pSegmentList->GetType(&eSelectionType) );
    IFC( pSegmentList->IsEmpty( &fEmpty ) );

    switch (eSelectionType)
    {
        case SELECTION_TYPE_Control:
            bResult = IsValidOnControl();
            break;
            
        case SELECTION_TYPE_Caret:
        case SELECTION_TYPE_Text:
            // If the command target is a range, we don't want to call CanContextAcceptHTML
            // because this gives us the result for the current selection, which may not 
            // be our range. Instead, we need to ask the flow element, so we fall through.
            // (bug 95423 - krisma)
            if ( !GetCommandTarget()->IsRange() )
            {
                bResult = GetEditor()->GetSelectionManager()->CanContextAcceptHTML();    
                break;
            }
            // fall through

        default:
            if( !fEmpty )
            {
                IFC( GetFirstSegmentPointers(pSegmentList, &spStart, NULL) );
                IFC( GetEditor()->GetFlowElement(spStart, &spFlowElement) );
                if ( spFlowElement )
                {
                    VARIANT_BOOL fHTML = VARIANT_FALSE;
                    IFC(spFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
                    IFC(spElement3->get_canHaveHTML(&fHTML));
                    bResult = !!fHTML;
                }
            }                
    }

Cleanup:
    return bResult;
}

HRESULT 
CCommand::GetSegmentElement(ISegment *pISegment, IHTMLElement **ppElement)
{
    HRESULT                 hr;
    SP_IElementSegment      spElemSegment;
    SP_IMarkupPointer       spLeft, spRight;
    
    Assert( ppElement && pISegment );

    *ppElement = NULL;    

    // Create some markup pointers
    IFC( GetEditor()->CreateMarkupPointer(&spLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&spRight) );

    // Try to move to an element
    IFC( pISegment->GetPointers( spLeft, spRight ) );

    IFC( spLeft->Right( FALSE, NULL, ppElement, NULL, NULL ) );

    Assert(*ppElement);
Cleanup:
    return S_OK;
}

HRESULT 
CCommand::AdjustSegment(IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    HRESULT         hr;    
    SP_ISegmentList spSegmentList;
    SELECTION_TYPE  eSelectionType;
    BOOL            fEmpty = FALSE;
    
    IFR( GetSegmentList(&spSegmentList) );
    if (spSegmentList == NULL)
        return S_FALSE;
        
    IFR( spSegmentList->GetType( &eSelectionType ) );
    IFR( spSegmentList->IsEmpty( &fEmpty ) );

    if( !fEmpty && eSelectionType == SELECTION_TYPE_Text)
    {    
        CEditPointer epTest(GetEditor());
        DWORD        dwFound;

        //
        // If we have:              {selection start}...</p><p>{selection end} ...
        // we want to adjust to:    {selection start}...</p>{selection end}<p> ...
        // so that the edit commands don't apply to unselected lines
        //

        IFR( epTest->MoveToPointer(pEnd) );
        IFR( epTest.SetBoundary(pStart, NULL) );
        
        IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, &dwFound) );        
        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Boundary))
            return S_OK;

        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitBlock))
            IFR( pEnd->MoveToPointer(epTest) );
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:       EdUtil::ExpandToWord
//
//  Synopsis:     Expands empty selection to word if inside text.
//
//----------------------------------------------------------------------------

HRESULT
CCommand::ExpandToWord(IMarkupServices * pMarkupServices, IMarkupPointer * pmpStart, IMarkupPointer * pmpEnd)
{
    SP_IMarkupPointer spmpPosition, spmpStart, spmpEnd;
    INT               iPosition;
    BOOL              fEqual, fExpand = FALSE;
    HRESULT           hr;
    CEditPointer      ep(GetEditor());
    DWORD             dwFound;

    Assert(pMarkupServices && pmpStart && pmpEnd);

    //
    // Markup pointers have to be at the same position in order for us to expand to a word.
    //

    hr = THR(pmpStart->IsEqualTo(pmpEnd, &fEqual));
    if (hr || !fEqual)
        goto Cleanup;

    //
    // Make sure we are contained in text before trying word expansion.
    // We need to do this because MoveUnit fails at document boundaries.
    //

    IFC( ep->MoveToPointer(pmpStart) );
    IFC( ep.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
        goto Cleanup;

    IFC( ep->MoveToPointer(pmpStart) );
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Text))
        goto Cleanup;

    //
    // We have a collapsed selection (caret).  Now lets see
    // if we are inside a word of text.
    //

    IFC(CopyMarkupPointer(GetEditor(), pmpStart, &spmpStart));
    IFC(CopyMarkupPointer(GetEditor(), pmpEnd, &spmpEnd));
    IFC(CopyMarkupPointer(GetEditor(), pmpStart, &spmpPosition));
    IFC(spmpEnd->MoveUnit(MOVEUNIT_NEXTWORDEND));
    IFC(spmpStart->MoveToPointer(spmpEnd));
    IFC(spmpStart->MoveUnit(MOVEUNIT_PREVWORDBEGIN));
    IFC(OldCompare( spmpStart, spmpPosition, &iPosition));

    if (iPosition != RIGHT)
        goto Cleanup;

    IFC(OldCompare( spmpPosition, spmpEnd, &iPosition));

    if (iPosition != RIGHT)
        goto Cleanup;

    {
        MARKUP_CONTEXT_TYPE mctContext;
        // TODO: Due to a bug in MoveUnit(MOVEUNIT_NEXTWORDEND) we have to check
        // whether we ended up at the end of the markup.  Try removing this
        // once bug 37129 is fixed.
        IFC( spmpEnd->Right( FALSE, &mctContext, NULL, NULL, NULL));
        if (mctContext == CONTEXT_TYPE_None)
            goto Cleanup;
    }

    fExpand = TRUE;

Cleanup:

    if (hr || !fExpand)
        hr = S_FALSE;
    else
    {
        pmpStart->MoveToPointer(spmpStart);
        pmpEnd->MoveToPointer(spmpEnd);
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Method:       CCommand::AdjustPointersForAtomic
//
//  Synopsis:     Adjust pointers for atomic selection.
//
//----------------------------------------------------------------------------

HRESULT
CCommand::AdjustPointersForAtomic( IMarkupPointer *pStart, IMarkupPointer *pEnd )
{
    HRESULT hr = S_OK;
    
    IFC( GetEditor()->GetSelectionManager()->AdjustPointersForAtomic(pStart, pEnd) );
    
Cleanup:
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Method:       CCommand::RemoveDoubleBullets
//
//  Synopsis:     In general, if we have <LI><OL><LI>, we'll get a double
//                bullet.  We need to avoid generating these, so this method
//                will remove the double bullet.
//
//----------------------------------------------------------------------------
HRESULT 
CCommand::RemoveDoubleBullets(IHTMLElement *pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;
    CEditPointer        epLIStart(GetEditor());
    CEditPointer        epLIEnd(GetEditor());
    BOOL                fMoveLI = FALSE;
    SP_IHTMLElement     spElement;
    BOOL                fEmpty;
    DWORD               dwFound;
    ELEMENT_TAG_ID      tagId;
    CBlockPointer       bp(GetEditor());
    SP_IHTMLElement     spLIElement;

    //
    // Are we a double bullet?
    //
    
    IFC( bp.MoveTo(pElement) );
    if (bp.GetType() == NT_ListContainer)
    {
        IFC( bp.MoveToParent() );
    }    
    if( bp.GetType() != NT_ListItem )
    {
        goto Cleanup; // not a double bullet             
    }      

    //
    // Get the element
    //

    IFC( bp.GetElement(&spLIElement) );

    //
    // Remove the double bullet
    //

    IFC( epLIStart->MoveAdjacentToElement(spLIElement, ELEM_ADJ_AfterBegin) );

    for (;;)
    {
        //
        // See if we have an list container followed by the open LI
        //
    
        IFC( epLIStart.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound, &spElement, &tagId) );

        if (epLIStart.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock) && IsListContainer(tagId))
        {
            fMoveLI = TRUE;
            IFC( epLIStart->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) ); 
        }
        else
        {
            if (fMoveLI)
            {
                IFC( epLIStart.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );
            }
            break;
        }
    }

    //
    // Remove the LI and re-insert it in the correct position
    //

    if (!fMoveLI)
        goto Cleanup; // we're done

    IFC( epLIEnd->MoveAdjacentToElement(spLIElement, ELEM_ADJ_BeforeEnd) );
    IFC( GetMarkupServices()->RemoveElement(spLIElement) );

    //
    // Only re-insert if there is content
    //

    IFC( epLIStart.IsEqualTo(epLIEnd, BREAK_CONDITION_ANYTHING - BREAK_CONDITION_Content, &fEmpty) );
    if (!fEmpty)
    {
        IFC( GetMarkupServices()->InsertElement(spLIElement, epLIStart, epLIEnd) );        
    }    

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\edtrack.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCOMMAND_HXX_
#define _X_EDCOMMAND_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_IMG_H_
#define _X_IMG_H_
#include "img.h"
#endif

#ifndef _X_INPUTTXT_H_
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_SELSERV_H_
#define X_SELSERV_H_
#include "selserv.hxx"
#endif

using namespace EdUtil;

ExternTag( tagSelectionTrackerState );

MtDefine( CEditTracker, Utilities , "CEditTracker" )
DeclareTag(tagEdKeyNav, "Edit", "Key Navigation Event for Editing")

static BOOL DontBackspace( ELEMENT_TAG_ID eTagId );

static char s_achWindows[] = "windows";             //  Localization: Do not localize

static SIZE                     gSizeDragMin;                   // the Size of a Minimum Drag.
int                             g_iDragDelay;                   // The Drag Delay

//+====================================================================================
//
// Method: CEditTracker
//
// Synopsis: Base Constructor for Trackers.
//
//------------------------------------------------------------------------------------


CEditTracker::CEditTracker(
            CSelectionManager* pManager )
{
    _pManager = pManager;
    _eType = TRACKER_TYPE_None;
    _hwndDoc = NULL;
    _ulRef = 1;
    _pSelServ = NULL;
    _fDontAdjustForAtomic = FALSE;
    _fEditContextUpdatedForAtomic = FALSE;

    _fShiftCapture         = FALSE;
    _fShiftLeftCapture     = FALSE;

    _ptVirtualCaret.InitPosition();
}

//+====================================================================================
//
// Method: Release
//
// Synopsis: COM-Like release code for tracker
//
//------------------------------------------------------------------------------------

ULONG
CEditTracker::Release()
{
    if ( 0 == --_ulRef )
    {
        delete this;
        return 0;
    }
    return _ulRef;
}

BOOL
CEditTracker::IsListeningForMouseDown(CEditEvent* pEvent)
{
    return FALSE;
}

Direction 
CEditTracker::GetPointerDirection(CARET_MOVE_UNIT moveDir)
{
    switch (moveDir)
    {
        case CARET_MOVE_BACKWARD:
        case CARET_MOVE_PREVIOUSLINE:
        case CARET_MOVE_WORDBACKWARD:
        case CARET_MOVE_PAGEUP:
        case CARET_MOVE_VIEWSTART:
        case CARET_MOVE_LINESTART:
        case CARET_MOVE_DOCSTART:
        case CARET_MOVE_BLOCKSTART:
        case CARET_MOVE_ATOMICSTART:
            return LEFT;

        case CARET_MOVE_FORWARD:
        case CARET_MOVE_NEXTLINE:
        case CARET_MOVE_WORDFORWARD:
        case CARET_MOVE_PAGEDOWN:
        case CARET_MOVE_VIEWEND:
        case CARET_MOVE_LINEEND:
        case CARET_MOVE_DOCEND:
        case CARET_MOVE_NEXTBLOCK:
        case CARET_MOVE_ATOMICEND:
            return RIGHT;                
    }
    
    AssertSz(0, "CEditTracker::GetPointerDirection unhandled case");
    return LEFT;
}


BOOL
CEditTracker::IsPointerInSelection(IDisplayPointer  *pDispPointer,  
                                   POINT            *pptGlobal, 
                                   IHTMLElement     *pIElementOver)
{
    return FALSE;
}


//+====================================================================================
//
// Method: ~CEditTracker
//
// Synopsis: Destructor for Tracker
//
//------------------------------------------------------------------------------------


CEditTracker::~CEditTracker()
{
    if( _pSelServ )
    {
        _pSelServ->Release();
        _pSelServ = NULL;
    }
}


//+====================================================================================
//
// Method: CEditTracker::GetSpringLoader
//
// Synopsis: Accessor for springloader
//
//------------------------------------------------------------------------------------

CSpringLoader *
CEditTracker::GetSpringLoader()
{
    CSpringLoader * psl = NULL;
    CHTMLEditor   * pEditor;

    if (!_pManager)
        goto Cleanup;

    pEditor = _pManager->GetEditor();

    if (!pEditor)
        goto Cleanup;

    psl = pEditor->GetPrimarySpringLoader();

Cleanup:
    return psl;
}

VOID
CEditTracker::OnEditFocusChanged()
{
    // do nothing.
}

HRESULT 
CEditTracker::MustDelayBackspaceSpringLoad(
                       CSpringLoader *psl, 
                       IMarkupPointer *pPointer, 
                       BOOL *pbDelaySpringLoad)
{
    HRESULT         hr;
    ED_PTR( epTest ) ; 
    DWORD   dwFound;
    
    Assert(psl && pPointer && pbDelaySpringLoad);

    *pbDelaySpringLoad = FALSE;

    // Make sure we don't spring load near an anchor boundary.  If we are at an anchor
    // boundary, spring load after the delete.
    //
    IFR( epTest->MoveToPointer(pPointer) );

    IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // check pre-delete boundary
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Text))
        IFR( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) ); // check post-delete boundary

    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_Anchor))
        *pbDelaySpringLoad = TRUE;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CEditTracker::GetMousePoint
//
//  Synopsis:   Get the x,y of the mouse by looking at the global cursor Pos.
//
//----------------------------------------------------------------------------
void
CEditTracker::GetMousePoint(POINT *ppt, BOOL fDoScreenToClient /* = TRUE */)
{
    HRESULT hr = S_OK;
    
    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED( hr ) , "GetWindow In CSelectTracker Failed" );
    }
    
    GetCursorPos(ppt);
    if ( fDoScreenToClient )
    {
        ScreenToClient( _hwndDoc, ppt);
    }        
    GetEditor()->DocPixelsFromDevice(ppt);
}

//+====================================================================================
//
// Method: Is MessageInWindow
//
// Synopsis: See if a given message is in a window. Assumed that the messages' pt has
//           already been converted to Screen Coords.
//
//------------------------------------------------------------------------------------

BOOL 
CEditTracker::IsEventInWindow( CEditEvent* pEvent )
{
    POINT globalPt;
    HRESULT hr ;
    
    IFC( pEvent->GetPoint( & globalPt ));
    
    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED(hr) , "GetWindow In CSelectTracker Failed" );
    }

    GetEditor()->ClientToScreen( _hwndDoc , & globalPt );
Cleanup:
    return ( IsInWindow( globalPt ));
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectionManager::GetMousePoint
//
//  Synopsis:   Check to see if the GLOBAL point is in the window.
//
//----------------------------------------------------------------------------
BOOL
CEditTracker::IsInWindow(POINT pt , BOOL fClientToScreen /* = FALSE*/ )
{
    HRESULT hr = S_OK;

    if ( ! _hwndDoc )
    {
        SP_IOleWindow spOleWindow;
        hr = THR(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
        if( !hr )
            hr = THR(spOleWindow->GetWindow(&_hwndDoc));
        
        AssertSz( ! FAILED(hr) , "GetWindow In CSelectTracker Failed" );
    }

    return GetEditor()->IsInWindow(_hwndDoc, pt, fClientToScreen );

}

//+---------------------------------------------------------------------------
//
//  Member:     CEditTracker::GetLocation
//
//----------------------------------------------------------------------------
HRESULT 
CEditTracker::GetLocation(POINT *pPoint, BOOL fTranslate)
{
    AssertSz(0, "GetLocation not implemented for tracker");
    return E_NOTIMPL;
}




//+====================================================================================
//
// Method: ConstrainPointer
//
// Synopsis: Check to see that the caret is in the edit context of the manager.
//           IF it isn't position appropriately.
//          If the caret has gone before the Start, postion at start of context
//          If the caret has gone after the end, position at end of context
//
//------------------------------------------------------------------------------------


HRESULT
CEditTracker::ConstrainPointer( IMarkupPointer* pPointer, BOOL fDirection)
{
    HRESULT hr = S_OK;
    IMarkupPointer* pPointerLimit = NULL;
    BOOL fAfterStart = FALSE;
    BOOL fBeforeEnd = FALSE;
        
    Assert(pPointer);

    if ( ! _pManager->IsInEditContext( pPointer ))
    {
        hr = THR( _pManager->IsAfterStart( pPointer, &fAfterStart ));
        if ( ( hr == CTL_E_INCOMPATIBLEPOINTERS ) || !fAfterStart )
        {
            if ( hr == CTL_E_INCOMPATIBLEPOINTERS )
            {
                //
                // Assume we're in a different tree. Based on the direction - we move
                // to the appropriate limit.
                // 
                if ( !fDirection ) // earlier in story
                {
                    pPointerLimit = _pManager->GetStartEditContext();
                }
                else
                {
                    pPointerLimit = _pManager->GetEndEditContext();
                }
            }
            else
            {            
                pPointerLimit = _pManager->GetStartEditContext();
            }        
            hr = THR( pPointer->MoveToPointer( pPointerLimit));
            goto Cleanup;
        }

        hr = THR( _pManager->IsBeforeEnd( pPointer, &fBeforeEnd ));
        if (( hr == CTL_E_INCOMPATIBLEPOINTERS ) || !fBeforeEnd )
        {
            if ( hr == CTL_E_INCOMPATIBLEPOINTERS )
            {
                //
                // Assume we're in a different tree. Based on the direction - we move
                // to the appropriate limit.
                // 
                if ( ! fDirection ) // earlier in story
                {
                    pPointerLimit = _pManager->GetStartEditContext();
                }
                else
                {
                    pPointerLimit = _pManager->GetEndEditContext();
                }
            }
            else
            {            
                pPointerLimit = _pManager->GetEndEditContext(); 
            }   
            hr = THR( pPointer->MoveToPointer( pPointerLimit));             
        }            
    }
Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: AdjsutForDeletion
//
// Synopsis: The Flow Layout we're in has been deleted
//
//  Return - TRUE - if we want to EmptySelection after we've been called
//           FALSE - if we don't want the manager to do anything.
//------------------------------------------------------------------------------------

BOOL
CEditTracker::AdjustForDeletion(IDisplayPointer * pDispPointer )
{
    return TRUE;
}


//+====================================================================================
//
//  Method: MovePointer
//
//  Synopsis: Moves the pointer like it were a caret - by the amount given for Caret 
//  Navigation
//
//
//------------------------------------------------------------------------------------

//
// HACKHACK: CARET_MOVE_UINT is treated as Logical move unit in order to support
//          vertical layout.
//
//          Although we used logical (content) coordinate system, the passed in parameter
//          plXPosForMove is actually in GLOBAL coordinate system in order to keep the 
//          callers happy. The editor actually caches mouse / keyboard position in global 
//          coordinate system. 
//          
//          If we strong typing editor's coordinate system in the future, we can 
//          we can explicit type this as GLOBALCOORDPOINT
//
//
//
HRESULT
CEditTracker::MovePointer(
    CARET_MOVE_UNIT     inMove, 
    IDisplayPointer     *pDispPointer,
    POINT               *ptgXYPosForMove,
    Direction           *peMvDir,
    BOOL                fIgnoreElementBoundaries /* =FALSE */)
{
    SP_IHTMLElement spContentElement;
    SP_IHTMLElement spElement;
    SP_IMarkupPointer   spPointer;
    SP_IHTMLElement spIFlowElement;
    

    HRESULT hr = S_OK;
    Direction eMvDir = LEFT;
    Direction eBlockAdj = SAME;
    
    DISPLAY_MOVEUNIT        edispMove;
    BOOL                    fVertical = FALSE;
    SP_IDisplayPointer      spOrigDispPointer;

    DWORD	dwAdjustOptions = ADJPTROPT_None;

    //
    // Save Current Display Pointer
    //
    Assert( pDispPointer );
    IFC( GetDisplayServices()->CreateDisplayPointer(&spOrigDispPointer) );
    IFC( spOrigDispPointer->MoveToPointer(pDispPointer) );
    //
    //
    
    Assert(GetEditor()->ShouldIgnoreGlyphs() == FALSE);

    if (peMvDir)
        *peMvDir = eMvDir; // init for error case

    POINT pt;
    pt.x = 0;
    pt.y = 0;

    IFC( _pManager->GetEditableElement( &spElement ));
    IFC( _pManager->GetEditableContent( &spContentElement ));
    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );

    eMvDir = LEFT;
    
    switch( inMove )
    {
        case CARET_MOVE_FORWARD:
            eMvDir = RIGHT;
            // fall through
            
        case CARET_MOVE_BACKWARD:            
        {   
            IFC( GetEditor()->MoveCharacter(pDispPointer, eMvDir) );
            break;
        }
        
        case CARET_MOVE_WORDFORWARD:
            eMvDir = RIGHT;
            // fall through

        case CARET_MOVE_WORDBACKWARD:
        {
            IFC( _pManager->GetEditor()->MoveWord(pDispPointer, eMvDir));            
            break;
        }

        case CARET_MOVE_PREVIOUSLINE:            
        case CARET_MOVE_NEXTLINE:

            IFC( pDispPointer->GetFlowElement(&spIFlowElement) );
            Assert(spIFlowElement != NULL);
            IFC( MshtmledUtil::IsElementInVerticalLayout(spIFlowElement, &fVertical) );
            //
            //
            //
            IFC( GetLocation(&pt, TRUE) );    // initialize pt to global coordinate
            if (fVertical)                    // y position is what we need to have
            {
                if (CARET_XPOS_UNDEFINED == ptgXYPosForMove->y)
                {
                    ptgXYPosForMove->y = pt.y; // update the suggested y position 
                }
                else
                {
                    pt.y = ptgXYPosForMove->y; // use the suggested y position
                }
            }
            else                            // keep x position 
            {
                if (CARET_XPOS_UNDEFINED == ptgXYPosForMove->x)
                {
                    ptgXYPosForMove->x = pt.x; // update the suggested x position
                }
                else
                {
                    pt.x = ptgXYPosForMove->x; // use the suggested x position
                }
            }
            //
            // MoveUnit now accepts logical coordinate only
            //
            IFC( GetDisplayServices()->TransformPoint(&pt, COORD_SYSTEM_GLOBAL, COORD_SYSTEM_CONTENT, spIFlowElement) );

            if (CARET_MOVE_PREVIOUSLINE == inMove)
            {
                eMvDir    = LEFT;
                edispMove = DISPLAY_MOVEUNIT_PreviousLine;
            }
            else    // CARET_MOVE_NEXTLINE
            {
                eMvDir    = RIGHT;
                edispMove = DISPLAY_MOVEUNIT_NextLine;
            }

            IFC( pDispPointer->MoveUnit(edispMove, pt.x) );
            break;

        case CARET_MOVE_LINESTART:            
            IFC( GetLocation( &pt, FALSE ));
            IFC( pDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, pt.x) );
            eMvDir = LEFT;            
            break;

        case CARET_MOVE_LINEEND:
            IFC( GetLocation( &pt, FALSE ));
            IFC( pDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, pt.x) );
            eMvDir = RIGHT;
            break;

        case CARET_MOVE_VIEWEND:
            eMvDir = RIGHT;
            // fall through
            
        case CARET_MOVE_VIEWSTART:
        {
            // Get the bounding rect of the edit context, offset by several pixels, and do
            // a global hit test.

            POINT ptGlobal;
            RECT rcGlobalClient;

            IFC( pDispPointer->GetFlowElement(&spIFlowElement) );
            if (spIFlowElement == NULL)
            {
                Assert(FALSE);
                goto Cleanup;
            }
            IFC( MshtmledUtil::IsElementInVerticalLayout(spIFlowElement, &fVertical) );
          
            IFC( GetEditor()->GetClientRect( spElement, & rcGlobalClient ));

            if( inMove == CARET_MOVE_VIEWSTART )
            {
                dwAdjustOptions |= ADJPTROPT_EnterTables;
                if (fVertical)
                {
                    ptGlobal.x = rcGlobalClient.right - 1;
                    ptGlobal.y = rcGlobalClient.top + 1;
                }
                else
                {
                    ptGlobal.x = rcGlobalClient.left+1;
                    ptGlobal.y = rcGlobalClient.top+1;
                }
            }
            else
            {
                if (fVertical)
                {
                    ptGlobal.x = rcGlobalClient.left+1;
                    ptGlobal.y = rcGlobalClient.bottom-1;
                }
                else
                {
                    ptGlobal.x = rcGlobalClient.right-1;
                    ptGlobal.y = rcGlobalClient.bottom-1;
                }
            }

            IFC( pDispPointer->MoveToPoint(ptGlobal, COORD_SYSTEM_GLOBAL, NULL, 0, NULL));
            break;
        }

        case CARET_MOVE_PAGEUP:
        case CARET_MOVE_PAGEDOWN:
        {
            SP_IHTMLElement spScroller;
            SP_IHTMLElement2 spScroller2;
            POINT ptCaretLocation;
            POINT ptScrollDelta;
            RECT  windowRect;

            //
            // Review-2000/07/24-zhenbinx: It is okay to do lazy 
            // HWND if we are sure that hwnd will be initialized
            // before it is used. This happens if we goto CanScroll 
            // without getting hwnd -- since there is a branch under
            // CanScroll that uses hwnd. In reality, we will never 
            // be wrong since if we jump too early, ScrollDelta will
            // be 0 so we don't scroll at all, which means hwnd is 
            // not going to be used. 
            //
            // So assigning NULL to hwnd is okay in this case. 
            //
            HWND hwnd = NULL; // keep compiler happy
            POINT ptWindow;
            SP_IOleWindow spOleWindow;
            SP_IMarkupPointer spPointer;
            
            BOOL              fNoScrollerBlockLayout = FALSE;
            SP_IHTMLElement2  spElement2;
            RECT              rectBlock;
            POINT             ptTopLeft;
            POINT             ptBottomRight;
            
            LONG lScrollLeft = 0;
            LONG lScrollTop = 0;

            ptScrollDelta.x = 0;
            ptScrollDelta.y = 0;
            ptCaretLocation.x = 0;
            ptCaretLocation.y = 0;

            IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
            IFC( pDispPointer->PositionMarkupPointer(spPointer) );

            //
            // We try to get the appropriate scroller
            //
            {
                if (fIgnoreElementBoundaries)
                {
                    IFC(GetScrollingElement(GetMarkupServices(), spPointer, NULL, &spScroller));
                }
                else
                {
                    IFC(GetScrollingElement(GetMarkupServices(), spPointer, spElement, &spScroller));
                }
                    
                if( spScroller == NULL )
                {
                    Assert (!fIgnoreElementBoundaries);     // if ignore element boundary
                                                            // there must be a scroller!!!
                    // HACKHACK:
                    // If this is a block element however is not scrollable 
                    // its layout size might be bigger than current view port
                    // so we want to scroll it *as if* there is no element boundary
                    // (zhenbinx)
                    //
                    //
                    BOOL    fBlock, fLayout, fScroller;
                    IFC(IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout, &fScroller));
                    Assert (!fScroller);
                    fNoScrollerBlockLayout = (fBlock && fLayout && !fScroller);
                    if (fNoScrollerBlockLayout)
                    {
                        IFC( GetScrollingElement(GetMarkupServices(), spPointer, NULL, &spScroller) );
                    }

                    if (spScroller == NULL)     
                    {
                        //
                        // NoScroller NotBlock Layout e.g. Inline Input Field
                        //
                        //
                        goto CantScroll;    // we are done
                    }
                }
                IFC( spScroller->QueryInterface( IID_IHTMLElement2, (void **) &spScroller2 ));
                Assert (!(spScroller2 == NULL) );
            }
            //
            // We want to bound the destination point to reasonable
            // and visible position
            //
            {
                //
                // 1) Get the visible window
                //
                IFC( GetSelectionManager()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
                IFC( spOleWindow->GetWindow(&hwnd) );
                GetEditor()->GetWindowRect( hwnd, &windowRect );

                //
                // 2) See if a scrolling is necessary
                //
                IFC( spElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
                Assert(!(spElement2 == NULL));
                IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );

                if (fNoScrollerBlockLayout && !ShouldScrollIntoView(hwnd, &rectBlock, &windowRect, inMove) )
                {
                    goto CantScroll;
                }
                
                //
                // 3) Get me the caret's position in global coord's
                //
                IFC( GetLocation( &ptCaretLocation, TRUE )); 
                ptWindow = ptCaretLocation;
                GetEditor()->ClientToScreen( hwnd, &ptWindow );

                //
                // 4) Make sure target caret position is visible
                //
                if( ptWindow.x < windowRect.left )
                    ptCaretLocation.x = ptCaretLocation.x + ( windowRect.left - ptWindow.x ) + 5;

                if( ptWindow.x > windowRect.right )
                    ptCaretLocation.x = ptCaretLocation.x - ( ptWindow.x - windowRect.right ) - 5;

                if( ptWindow.y < windowRect.top )
                    ptCaretLocation.y = ptCaretLocation.y + ( windowRect.top - ptWindow.y ) + 5;

                if( ptWindow.y > windowRect.bottom )
                    ptCaretLocation.y = ptCaretLocation.y - ( ptWindow.y - windowRect.bottom ) - 5;
            }
            
            //
            // Do scrolling and compute the scrolling delta
            //
            {
                IFC( spScroller2->get_scrollLeft( & ptScrollDelta.x ));
                IFC( spScroller2->get_scrollTop( & ptScrollDelta.y ));

                CVariant var;
                V_VT( &var ) = VT_BSTR;

                if( inMove == CARET_MOVE_PAGEDOWN )
                {
                    V_BSTR( &var ) = SysAllocString(_T("pageDown"));
                }
                else
                {                
                    V_BSTR( &var ) = SysAllocString(_T("pageUp"));
                }

                hr = THR( spScroller2->doScroll( var ));
                
                if( FAILED( hr ))
                    goto Cleanup;
                
                IFC( spScroller2->get_scrollLeft( & lScrollLeft ));
                IFC( spScroller2->get_scrollTop( & lScrollTop ));
                ptScrollDelta.x -= lScrollLeft;
                ptScrollDelta.y -= lScrollTop;
            }

CantScroll:
            // Did we scroll a visible amount? If not, just move to the top or bottom of the element
            if( abs( ptScrollDelta.x ) < 7 && abs( ptScrollDelta.y ) < 7 )
            {   
                // like other keynav - default to bol if unknown

                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

                // we didn't scroll anywhere, go to the start or end of the current editable element
                if( inMove == CARET_MOVE_PAGEDOWN )
                {
                    if (fNoScrollerBlockLayout || spScroller == NULL)
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeEnd ) );
                    }
                    else
                    {
                        IFC( spPointer->MoveAdjacentToElement( spScroller, ELEM_ADJ_BeforeEnd ));
                    }
                    IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                }
                else
                {
                    if (fNoScrollerBlockLayout || spScroller == NULL)
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterBegin ) );
                    }
                    else
                    {
                        IFC( spPointer->MoveAdjacentToElement( spScroller, ELEM_ADJ_AfterBegin ));
                    }
                    IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                }
            }
            else
            {   
                // we scrolled. figure out what element we hit. if we hit an image or control that isn't
                // our edit context, we want to move adjacent to that element's start or end. if we 
                // didn't, we want to to a global hit test at our adjusted caret location to relocate
                // the pointer.
                
                SP_IHTMLElement spElementAtCaret;
                BOOL fSameElement = FALSE;
                IObjectIdentity * pIdent;
                ELEMENT_TAG_ID eTagId;

                if (fNoScrollerBlockLayout)
                {
                    //
                    // Bound the hit testing to be inside block
                    //
                    // Get the bounding client rect again since it might have been 
                    // changed due to scrolling
                    //
                    Assert (!(spElement2 == NULL));
                    IFC( GetEditor()->GetBoundingClientRect(spElement2, &rectBlock) );
                    ptTopLeft.x     = rectBlock.left;
                    ptTopLeft.y     = rectBlock.top;
                    ptBottomRight.x = rectBlock.right;
                    ptBottomRight.y = rectBlock.bottom;
                    GetEditor()->ClientToScreen(hwnd, &ptTopLeft);
                    GetEditor()->ClientToScreen(hwnd, &ptBottomRight);
                    
                    ptWindow = ptCaretLocation;
                    GetEditor()->ClientToScreen(hwnd, &ptWindow);
                    if (ptWindow.y < ptTopLeft.y)
                        ptCaretLocation.y = ptCaretLocation.y + (ptTopLeft.y - ptWindow.y) + 5;
                    if (ptWindow.y > ptBottomRight.y)
                        ptCaretLocation.y = ptCaretLocation.y - (ptWindow.y - ptBottomRight.y) - 5;
                }

                IFC(GetSelectionManager()->GetDoc()->elementFromPoint(ptCaretLocation.x, ptCaretLocation.y, &spElementAtCaret));
                BOOL fShouldHitTest = TRUE;

                if (spElementAtCaret)
                {
                    IFC( spElementAtCaret->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent));      
                    fSameElement = ( pIdent->IsEqualObject ( spScroller ) == S_OK );
                    pIdent->Release();
                    IFC( GetMarkupServices()->GetElementTagId( spElementAtCaret, &eTagId ));
                
                    if( ! fSameElement && ( IsIntrinsic( GetMarkupServices(), spElementAtCaret ) || ( eTagId == TAGID_IMG )))
                    {
                        IFC( spPointer->MoveAdjacentToElement( spElementAtCaret, inMove == CARET_MOVE_PAGEDOWN ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));
                        IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                        fShouldHitTest = FALSE;
                    }
                }

                if (fShouldHitTest)
                {
                    Assert (!(spElement == NULL)); // note: this is the edit context element
                    if (fIgnoreElementBoundaries && !fNoScrollerBlockLayout)
                    {
                        IFC( pDispPointer->MoveToPoint(ptCaretLocation, COORD_SYSTEM_GLOBAL, NULL, 0, NULL) );
                    }
                    else
                    {
                        IFC( pDispPointer->MoveToPoint(ptCaretLocation, COORD_SYSTEM_GLOBAL, spElement, 0, NULL) );
                    }
                }
            }
            
            break;
        }
        
        case CARET_MOVE_DOCSTART:
        case CARET_MOVE_DOCEND:
            {
                ELEMENT_ADJACENCY   elemAdj;
                DISPLAY_GRAVITY     dispGravity;

                if (CARET_MOVE_DOCSTART == inMove)
                {
                    elemAdj     = ELEM_ADJ_AfterBegin;
                    dispGravity = DISPLAY_GRAVITY_NextLine;
                    eMvDir      = LEFT;
                }
                else
                {
                    elemAdj     = ELEM_ADJ_BeforeEnd;
                    dispGravity = DISPLAY_GRAVITY_NextLine;
                    eMvDir      = RIGHT;
                }

                //
                // Move to target position
                //
                IFC( spPointer->MoveAdjacentToElement( spContentElement , elemAdj));
                IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
                IFC( pDispPointer->SetDisplayGravity(dispGravity) );
                dwAdjustOptions |= ADJPTROPT_EnterTables;
                break;
            }
        
        case CARET_MOVE_BLOCKSTART:            
        {
            ED_PTR(epPos);
            //
            // In case we are already on that start of a block
            // we need to move up one block. 
            // 
       		IGNORE_HR( MovePointer(CARET_MOVE_BACKWARD, pDispPointer, ptgXYPosForMove, peMvDir) );

            IFC( epPos.SetBoundary( _pManager->GetStartEditContext(), _pManager->GetEndEditContext()) );
            IFC( pDispPointer->PositionMarkupPointer(epPos) );
            IFC( MshtmledUtil::MoveMarkupPointerToBlockLimit(GetEditor(), LEFT, epPos, ELEM_ADJ_AfterBegin) );
            IFC( pDispPointer->MoveToMarkupPointer(epPos, NULL) );
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

            eMvDir = LEFT;
            break;
        }
        
        case CARET_MOVE_NEXTBLOCK:
        {
            ED_PTR(ePos);
			//
			// Always move to end of block
			//
            IFC( ePos.SetBoundary(_pManager->GetStartEditContext(), _pManager->GetEndEditContext()) );
            IFC( pDispPointer->PositionMarkupPointer(ePos) );
            IFC( MshtmledUtil::MoveMarkupPointerToBlockLimit(GetEditor(), RIGHT, ePos, ELEM_ADJ_BeforeEnd) );
            IFC( pDispPointer->MoveToMarkupPointer(ePos, NULL) );
			//
			// Try to move one character to next block
			//
            IGNORE_HR( MovePointer(CARET_MOVE_FORWARD, pDispPointer, ptgXYPosForMove, peMvDir) );
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

            eMvDir = RIGHT;
            break;
        }            

        case CARET_MOVE_ATOMICSTART:
        {
            SP_IHTMLElement spAtomicElement;

            IFC( GetCurrentScope(pDispPointer, &spAtomicElement) );
            IFC (AdjustForAtomic(pDispPointer, spAtomicElement, TRUE, ptgXYPosForMove, NULL,
                                    TRUE, SELECTION_TYPE_Caret) );
            eMvDir = LEFT;
            break;
        }

        case CARET_MOVE_ATOMICEND:
        {
            SP_IHTMLElement spAtomicElement;

            IFC( GetCurrentScope(pDispPointer, &spAtomicElement) );
            IFC (AdjustForAtomic(pDispPointer, spAtomicElement, FALSE, ptgXYPosForMove, NULL,
                                    TRUE, SELECTION_TYPE_Caret) );
            eMvDir = RIGHT;
            break;
        }
    }

    {
        //
        // check to see if the movement is valid/possible, 
        // i.e. -- if it moves to an editable element
        // otherwise reverse back to the original position
        //
        Assert( _pManager );
        if (!_pManager->IsInEditContext(pDispPointer))
        {
            IFC( pDispPointer->MoveToPointer(spOrigDispPointer) );
            goto Cleanup;
        }
    }
    
    // Properly constrain the pointer
    {
        BOOL fAtLogicalBOL = FALSE;
            
        if( eBlockAdj == SAME )
        {
            IGNORE_HR( pDispPointer->IsAtBOL(&fAtLogicalBOL) );
            eBlockAdj = fAtLogicalBOL ? RIGHT : LEFT;
        }

        //
        // Check to see if we have moved into a different site selectable object.
        // If this happens - we jump over the site
        //
        IFC( pDispPointer->PositionMarkupPointer(spPointer) );
        if (GetEditor()->IsInDifferentEditableSite(spPointer) )
        {
            SP_IHTMLElement spFlow;
            CEditPointer    epTest(GetEditor());
            DWORD           dwSearch = BREAK_CONDITION_Content|BREAK_CONDITION_Glyph;
            DWORD           dwFound;

            IFC( pDispPointer->GetFlowElement(&spFlow));
            
            if (GetPointerDirection( inMove ) == RIGHT)
            {
                IFC( spPointer->MoveAdjacentToElement( spFlow, ELEM_ADJ_AfterEnd));
                IFC( epTest->MoveToPointer(spPointer) );
                IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_Glyph) &&
                    CheckFlag(dwFound, BREAK_CONDITION_Block) &&
                    CheckFlag(dwFound, BREAK_CONDITION_EnterSite)
                    )
                {
                    //
                    // we have a glyph here - so we don't want to exit this line
                    // prematurelly
                    //
                    pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine);
                }
            }
            else
            {
                IFC( spPointer->MoveAdjacentToElement( spFlow, ELEM_ADJ_BeforeBegin));
                IFC( epTest->MoveToPointer(spPointer) );
                IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
                if (CheckFlag(dwFound, BREAK_CONDITION_Glyph) &&
                    CheckFlag(dwFound, BREAK_CONDITION_Block) &&
                    CheckFlag(dwFound, BREAK_CONDITION_EnterSite)
                    )
                {
                    //
                    // we have a glyph here - so we don't want to exit this line
                    // prematurelly
                    //
                    pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine);
                }
            }
            IFC( pDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        }

        //
        // HACKHACK (johnbed)
        // Now the pointer is in the right place. Problem: fNotAtBOL may be wrong if the line is empty.
        // Easy check: if fNotAtBOL == TRUE, make sure there isn't a block phrase to the left of us. <BR>
        // and \r are never swallowed, and being to the right of one of them with fNotAtBOL==TRUE will 
        // make us render in a bad place.
        // 
        // The right fix is to create a line-aware CEditPointer subclass that encapsulates moving in
        // a line aware way and to use these pointers instead of raw markup pointers.
        //

        IFC( ConstrainPointer(pDispPointer, 
                               ( GetPointerDirection( inMove ) == RIGHT ))); // don't rely on AdjPointer for this.

        fAtLogicalBOL = FALSE;
        IFC( pDispPointer->IsAtBOL(&fAtLogicalBOL) );

        IFC( AdjustPointerForInsert( pDispPointer , eBlockAdj, fAtLogicalBOL ? RIGHT : LEFT, dwAdjustOptions) );

        {
            //
            // HACKHACK: #108352
            // By now, we could have adjusted the pointer to an 
            // ambigious position from an unambigious poisition
            // So it is obvious that the BR check should have 
            // been here. 
            //
            IFC( pDispPointer->IsAtBOL(&fAtLogicalBOL) );
        }
        
        if( !fAtLogicalBOL)
        {
            ED_PTR( epScan ); 
            DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor; // anchors are just phrase elements to me here
            DWORD dwFound = BREAK_CONDITION_None;
            
            IFC( pDispPointer->PositionMarkupPointer(epScan) );

            IFC( epScan.Scan( LEFT, dwSearch, &dwFound ));

            if( CheckFlag( dwFound, BREAK_CONDITION_NoScopeBlock ) )
            {
                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
            }
        }
    }
            
Cleanup:
    if (peMvDir)
        *peMvDir = eMvDir; 

    RRETURN( hr );
}

HRESULT
CEditTracker::AdjustPointerForInsert( 
    IDisplayPointer  * pDispWhereIThinkIAm, 
    Direction        inBlockcDir, 
    Direction        inTextDir, 
    DWORD            dwOptions /* = NULL */ )
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spLeftEdge;
    SP_IMarkupPointer spRightEdge;    
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spLeftEdge ));
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &spRightEdge ));
    IFC( _pManager->MovePointersToContext( spLeftEdge, spRightEdge ));
    IFC( _pManager->GetEditor()->AdjustPointer( pDispWhereIThinkIAm, inBlockcDir, inTextDir, spLeftEdge, spRightEdge, dwOptions ));

Cleanup:
    RRETURN( hr );
}


HRESULT
CEditTracker::TakeCapture()
{
    TraceTag(( tagSelectionTrackerState, "TakingCapture"));    

    RRETURN( _pManager->GetEditor()->TakeCapture( this ));
}

HRESULT 
CEditTracker::ReleaseCapture(BOOL fReleaseCapture /*=TRUE*/ )
{
    TraceTag(( tagSelectionTrackerState, "ReleasingCapture"));    

    RRETURN( _pManager->GetEditor()->ReleaseCapture( this , fReleaseCapture ));
}


//+====================================================================================
//
// Method: InitMetrics
//
// Synopsis: Iniitalize any static vars for the SelectionManager
//
//------------------------------------------------------------------------------------

VOID
CEditTracker::InitMetrics()
{
#ifdef WIN16
    // (Stevepro) Isn't there an ini file setting for this in win16 that is used
    //         for ole drag-drop?
    //
    // Width and height, in pixels, of a rectangle centered on a drag point
    // to allow for limited movement of the mouse pointer before a drag operation
    // begins. This allows the user to click and release the mouse button easily
    // without unintentionally starting a drag operation
    //
    gSizeDragMin.cx = 3;
    gSizeDragMin.cy = 3;
#else
    gSizeDragMin.cx = GetSystemMetrics(SM_CXDRAG);
    gSizeDragMin.cy = GetSystemMetrics(SM_CYDRAG);
    g_iDragDelay = GetProfileIntA(s_achWindows, "DragDelay", 20);
#endif
}

int 
CEditTracker::GetMinDragSizeX()
{
    return gSizeDragMin.cx;
}

int 
CEditTracker::GetMinDragSizeY()
{
    return gSizeDragMin.cy;
}
    
int 
CEditTracker::GetDragDelay()
{
    return g_iDragDelay;
}

//+====================================================================================
//
// Method: ConstrainPointer
//
// Synopsis: Check to see that the caret is in the edit context of the manager.
//           IF it isn't position appropriately.
//          If the caret has gone before the Start, postion at start of context
//          If the caret has gone after the end, position at end of context
//
//------------------------------------------------------------------------------------


HRESULT
CEditTracker::ConstrainPointer( IDisplayPointer* pDispPointer, BOOL fDirection)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );
    
    IFC( ConstrainPointer(spPointer, fDirection) );

    IFC( pDispPointer->MoveToMarkupPointer(spPointer, pDispPointer) );

Cleanup:
    RRETURN(hr);
}    

VOID
CEditTracker::SetupSelectionServices( )
{
    if( _pSelServ )
    {
        _pSelServ->Release();
    }
    
    _pSelServ = GetEditor()->GetSelectionServices();
    _pSelServ->AddRef();
}


//////////////////////////////////////////////////////////////////////////////////////////
//
// Moved the pos tracker definition/implementation from cartracker to postracker
//
//
//////////////////////////////////////////////////////////////////////////////////////////
CPosTracker::CPosTracker()
{
    _fFrozen = FALSE;
    _cp = -1;
    _pContainer = NULL;
    _lContainerVersion = -1;    
    InitPosition();
}

VOID 
CPosTracker::InitPosition()
{
    if (!_fFrozen)
    {
        _lContainerVersion = -1; 
        _ptPos.x = CARET_XPOS_UNDEFINED;
        _ptPos.y = CARET_YPOS_UNDEFINED;
    }
}


BOOL 
CPosTracker::FreezePosition(BOOL fFrozen)
{
    BOOL  fRet = _fFrozen;
    _fFrozen = fFrozen;
    return fRet;
}


CPosTracker::~CPosTracker()
{
    ClearInterface(&_pContainer);    
}

HRESULT 
CPosTracker::UpdatePosition(IMarkupPointer *pPointer, POINT ptPos)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;
    SP_IMarkupPointer2      spPointer2;

    if (_fFrozen)
    {
        goto Cleanup;
    }
    
    _lContainerVersion = -1; 
    
    if (!pPointer || ((ptPos.x == CARET_XPOS_UNDEFINED) && (ptPos.y == CARET_YPOS_UNDEFINED)))
            goto Cleanup;

    //
    // Get IMarkupPointer2 and IMarkupContainer2
    // 
    
    IFC( pPointer->GetContainer(&spContainer) );
    if (!spContainer)
        goto Cleanup;
    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
    
    //
    // Update the caret position
    //

    IFC( spPointer2->GetMarkupPosition(&_cp) );
    ReplaceInterface(&_pContainer, (IMarkupContainer *)spContainer2);
    _lContainerVersion = spContainer2->GetVersionNumber();
    _ptPos = ptPos;

Cleanup:
    RRETURN(hr);        
}

HRESULT 
CPosTracker::GetPosition(IMarkupPointer *pPointer, POINT *ptPos)
{
    HRESULT                 hr = S_OK;
    SP_IUnknown             spUnk1, spUnk2;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;
    SP_IMarkupPointer2      spPointer2;
    LONG                    cp;

    Assert(pPointer);
    Assert(ptPos);
    
    ptPos->x = CARET_XPOS_UNDEFINED;
    ptPos->y = CARET_YPOS_UNDEFINED;

    //
    // Check for valid position
    //
    
    if (_lContainerVersion < 0 || _cp < 0 || !_pContainer)
        goto Cleanup;

    //
    // Check that the cp's are equal
    //

    IFC( pPointer->QueryInterface(IID_IMarkupPointer2, (LPVOID *)&spPointer2) );
    IFC( spPointer2->GetMarkupPosition(&cp) );
    
    if (_cp != cp)
        goto Cleanup; // cp's not equal
        
    //
    // Check that the containers are equal
    //
    
    IFC( pPointer->GetContainer(&spContainer) );
    if (!spContainer)
        goto Cleanup;
    
    IFC( spContainer->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk1) );
    IFC( _pContainer->QueryInterface(IID_IUnknown, (LPVOID *)&spUnk2) );

    if (spUnk1 != spUnk2)
        goto Cleanup; // containers not equal

    
    //
    // Check that the container versions are the same
    //

    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    if (spContainer2->GetVersionNumber() != _lContainerVersion)
        goto Cleanup;

    //
    // Ok to return real x position
    //

    *ptPos = _ptPos;

Cleanup:
    RRETURN(hr);
};

HRESULT
CEditTracker::GetCurrentScope(IDisplayPointer *pDisp, IHTMLElement **pElement)
{
    HRESULT             hr;
    SP_IMarkupPointer   spMarkup;
    
    IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
    IFC( pDisp->PositionMarkupPointer(spMarkup) );
    IFC( spMarkup->CurrentScope(pElement) );

Cleanup:

    RRETURN ( hr );
}

HRESULT
CEditTracker::AdjustForAtomic(
                IDisplayPointer* pDisp,
                IHTMLElement* pElement,
                BOOL fStartOfSelection, 
                POINT* ppt,
                BOOL* pfDidSelection,
                BOOL fDirection,
                SELECTION_TYPE eSelectionType,
                IMarkupPointer** ppStartPointer /*=NULL*/,
                IMarkupPointer** ppEndPointer /*=NULL*/)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStartPointer;
    SP_IMarkupPointer   spEndPointer;
    SP_IHTMLElement     spElement = pElement;
    SP_IHTMLElement     spAtomicElement;
    BOOL                fHasAtomicParentElement = FALSE;
    BOOL                fEditContextWasUpdated = FALSE;
    BOOL                fReentrantAdjustForAtomic = FALSE;
    
    if (pfDidSelection)
        *pfDidSelection = FALSE;

    //  If reentrency detected, back out.
    if (_fDontAdjustForAtomic)
    {
        fReentrantAdjustForAtomic = TRUE;
        goto Cleanup;
    }
    
    _fDontAdjustForAtomic = TRUE;
    
    //  Find the atomic selected element
    Assert(spElement != NULL);
    IFC( _pManager->FindAtomicElement(spElement, &spAtomicElement) );
    if (spAtomicElement)
    {
        ReplaceInterface(&spElement, (IHTMLElement *)spAtomicElement);
        fHasAtomicParentElement = TRUE;
    }

    //  Set our start and end markup pointers adjacent to our selected element
    IFC( GetEditor()->CreateMarkupPointer( & spStartPointer ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndPointer ));
    IFC( spStartPointer->MoveAdjacentToElement( spElement ,
                                              fDirection ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
    IFC( spEndPointer->MoveAdjacentToElement( spElement ,
                                              fDirection ? ELEM_ADJ_AfterEnd : ELEM_ADJ_BeforeBegin ));

    //  If we have an atomic parent element, we may need to adjust the edit context.
    if (fHasAtomicParentElement && !_fEditContextUpdatedForAtomic)
    {
        SP_IHTMLElement     spAtomicScope;
        SP_IDisplayPointer  spAtomicDispPointer;

        //  Make sure that the current edit context includes the selection.

        //  We need to get the scope of the display start pointer since our
        //  display pointers are outside of the scope of the atomic element.
        IFC( GetDisplayServices()->CreateDisplayPointer(&spAtomicDispPointer) );
        IGNORE_HR( spAtomicDispPointer->MoveToMarkupPointer(spStartPointer, NULL) );
        IFC( GetCurrentScope( spAtomicDispPointer, &spAtomicScope) );   

        //  Set the scope to the scope of our start pointer so that we can
        //  ensure that our display pointers are contained within the context.
        _pManager->UpdateEditContextFromElement(spAtomicScope,
                                                fDirection ? spStartPointer : spEndPointer,
                                                fDirection ? spEndPointer : spStartPointer,
                                                &fEditContextWasUpdated);

        //  If the edit context was updated, we need to update the selection
        //  which will create a new sel tracker.  So, if we do this we will
        //  need to make sure our calling functions don't change anything
        //  with the old sel tracker since it will be invalid.

        if (fEditContextWasUpdated)
        {
            //  Reset the selection and tracker state.
            IFC( _pManager->Select(spStartPointer, spEndPointer, eSelectionType) );
            if (pfDidSelection)
                *pfDidSelection = TRUE;
        }
        
        //  Set our flag so that we don't attempt to update the context again for this selection.
        _fEditContextUpdatedForAtomic = TRUE;        
    }

    if (!fEditContextWasUpdated)
    {
        //  Move the display pointer to the appropriate markup pointer
        if ( fStartOfSelection )
        {
            IGNORE_HR( pDisp->MoveToMarkupPointer( spStartPointer, NULL ));                                                                      
        }
        else
        {
            IGNORE_HR( pDisp->MoveToMarkupPointer( spEndPointer, NULL ));                                                                      
        }
    }
    
    if (ppStartPointer)
    {
        ReplaceInterface(ppStartPointer, (IMarkupPointer *)spStartPointer);
    }

    if (ppEndPointer)
    {
        ReplaceInterface(ppEndPointer, (IMarkupPointer *)spEndPointer);
    }

Cleanup:

    if (!fReentrantAdjustForAtomic)
        _fDontAdjustForAtomic = FALSE;

    RRETURN( hr );

}


HRESULT 
CEditTracker::HandleDirectionalKeys(
                    CEditEvent *pEvent
                    )
{
    HRESULT             hr = S_FALSE;
    IHTMLElement        *pIEditElement = NULL;
    SP_IHTMLElement2    spElement2;
    LONG                keyCode;

    Assert( pEvent );
    //
    // Bidirectional is enabled in Bidi systems
    // and Win2k+ without Bidi locale installed
    //
    IGNORE_HR( pEvent->GetKeyCode(&keyCode) );
    switch (pEvent->GetType())
    {
    case EVT_KEYDOWN:
        {
            BOOL fShiftLeft;
            if (VK_SHIFT == keyCode && pEvent->IsControlKeyDown() )
            {
                IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetShiftLeft(&fShiftLeft) ); // capture left shift state
                _fShiftLeftCapture = fShiftLeft;
                _fShiftCapture     = TRUE;
            }
            else
            {
                _fShiftCapture  = FALSE;
            } 
        }
        break;
        
    case EVT_KEYUP:
        {
            if (_fShiftCapture) 
            {
                if ( 
                    ((VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode) && pEvent->IsControlKeyDown())  ||
                    ((VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode) && pEvent->IsShiftKeyDown())
                   )
                {
                    //
                    // Just set it. We don't care if Bidi is enabled.
                    //
                    if (_pManager->IsContextEditable())
                    {
                        if (EdUtil::IsBidiEnabled())
                        {
                            long eHTMLDir = _fShiftLeftCapture ? htmlDirLeftToRight : htmlDirRightToLeft;
                            IFC( _pManager->GetEditableElement(&pIEditElement) );
                            IFC( pIEditElement->QueryInterface(IID_IHTMLElement2, (LPVOID *)&spElement2) );
                            switch (eHTMLDir)
                            {
                                case htmlDirRightToLeft:
                                    IFC( spElement2->put_dir( L"rtl" ) );
                                    break;
                                case htmlDirLeftToRight:
                                    IFC( spElement2->put_dir( L"ltr" ) );
                                    break;
                                default:
                                    AssertSz(0, "Unexpected block direction");
                            }
                            hr = S_OK;
                        }
                    }
                }
                _fShiftCapture     = FALSE;
            }
        }
    };
    
Cleanup:
    ReleaseInterface( pIEditElement );
    return hr;    
}

BOOL
CEditTracker::ShouldScrollIntoView( HWND hwnd,
                                    const RECT *rectBlock,
                                    const RECT *windowRect,
                                    CARET_MOVE_UNIT inMove/*=CARET_MOVE_NONE*/)
{
    POINT               ptTopLeft;
    POINT               ptBottomRight;
    BOOL                fShouldScroll = TRUE;
    
    //
    // Don't scroll if it is in block and the block element is already visible
    //
    //
    ptTopLeft.x     = rectBlock->left;
    ptTopLeft.y     = rectBlock->top;
    ptBottomRight.x = rectBlock->right;
    ptBottomRight.y = rectBlock->bottom;
    GetEditor()->ClientToScreen(hwnd, &ptTopLeft);
    GetEditor()->ClientToScreen(hwnd, &ptBottomRight);
    switch (inMove)
    {
    // TODO: need to consider Adorner instead of using 5 pixel here!
    case CARET_MOVE_PAGEUP:
        if (ptTopLeft.y > windowRect->top + 7)
        {
            TraceTag((tagEdKeyNav, "PgUp in block with visible top, don't scroll"));
            fShouldScroll = FALSE;
        }
        break;
    case CARET_MOVE_PAGEDOWN:
        if (ptBottomRight.y < windowRect->bottom - 7)
        {
            TraceTag((tagEdKeyNav, "PgDown in block with visible bottom, don't scroll"));
            fShouldScroll = FALSE;
        }
        break;
    case CARET_MOVE_NONE:
        fShouldScroll = ((ptTopLeft.y <= windowRect->top + 7) || (ptBottomRight.y >= windowRect->bottom - 7));
        break;
    }
     
    return fShouldScroll;
}

//+---------------------------------------------------------------------
//
// Method: WeOwnsSelectionServices
//
// Synopsis: Do we own the things in selection services ? If not it's 
//           considered bad to do things like change trackers etc.
//
//+---------------------------------------------------------------------

HRESULT
CEditTracker::WeOwnSelectionServices()
{
    HRESULT hr;
    SP_IUnknown spUnk;
    SP_ISelectionServicesListener spListener;
    
    IFC( GetSelectionServices()->GetSelectionServicesListener( & spListener ));
    if ( spListener )
    {
        IFC( spListener->QueryInterface( IID_IUnknown, (void**) & spUnk ));
       
        hr = (IUnknown*) spUnk == (IUnknown*)_pManager  ? S_OK : S_FALSE ;
    }
    else
        hr = E_FAIL ;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CEditTracker::AdjustOutOfAtomicElement(IDisplayPointer *pDispPointer, IHTMLElement *pAtomicElement, int iDirectionForAtomicAdjustment)
{
    HRESULT             hr;
    SP_IHTMLCaret       spCaret;
    SP_IMarkupPointer   spPointer;
    SP_IMarkupPointer   spTestPointer;
    BOOL                fResult = FALSE;
    int                 iEdge = 0;

    WHEN_DBG( Assert(_pManager->CheckAtomic(pAtomicElement) == S_OK) );

    //  See if the caret was positioned at the inside edge of the atomic element.  It's most
    //  likely at the beforeend position.  If it is in the inside edge, then reposition the
    //  caret outside of the element on that side.

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( GetEditor()->CreateMarkupPointer(&spTestPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( spTestPointer->MoveAdjacentToElement( pAtomicElement, ELEM_ADJ_BeforeEnd) );
    IFC( spPointer->IsEqualTo(spTestPointer, &fResult) );

    if (fResult)
    {
        iEdge = RIGHT;
    }
    else
    {
        IFC( spTestPointer->MoveAdjacentToElement( pAtomicElement, ELEM_ADJ_AfterBegin) );
        IFC( spPointer->IsEqualTo(spTestPointer, &fResult) );
        if (fResult)
            iEdge = LEFT;
    }

    if (iEdge)
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), pDispPointer, pAtomicElement, FALSE, iEdge) );
    }
    else if (iDirectionForAtomicAdjustment)
    {
        IFC( EdUtil::AdjustForAtomic(GetEditor(), pDispPointer, pAtomicElement, FALSE, iDirectionForAtomicAdjustment) );
    }

Cleanup:

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       DLLMAP.C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:      Reduced copy of dllmap.c (sharedcomponents\dload)
//              This is linked to the importing DLL, so __pfnDliFailureHook2 is included
//
//----------------------------------------------------------------------------

#ifdef DLOAD1

#ifndef X_DLOADEXCEPT_H_
#define X_DLOADEXCEPT_H_
#pragma warning( push )
#pragma warning( disable : 4201 )
#pragma warning( disable : 4100 )
#include "dloadexcept.h"
#pragma warning( pop )
#endif

#pragma warning( disable : 4514 ) // unreferenced inline function has been removed


// #ifndef X_DELAYIMP_H_
// #define X_DELAYIMP_H_
// #include "delayimp.h"
// #endif

//
// DESCRIPTION:
//
// These module declarations refer to methods and stubs in 
// dload.lib (delayload error handing, including empty stubs for all exports).
// Not to be confused with delayload.lib, which is the implementation of delayload code.
//
// On WIN2000 (and up), dload.lib is part of kernel32.dll, so for Whistler-only executables, it is much cheaper to 
// use kernel32.DelayLoadFailureHook (or specify DLOAD_ERROR_HANDLER=kernel32 in sources).
//
// **** To enable delayload for DLL: 
//      Uncomment the appropriate lines.
//
// **** To add a DLL: 
//      Add a stub to dload.lib (remember to update mergedcomponents\dload\dllmap.c, the 
//      ancestor of this file!). It will eventually find its way to kernel32.
// OR
//      create the stubs file and link to it directly (nobody else will benefit from that, but kernel32 will not grow).

//+---------------------------------------------------------------------------
//
// DEFINITIONS for DLL map (contents of dload.h)
//

typedef struct _DLOAD_DLL_ENTRY
{
    LPCSTR                      pszDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;
} DLOAD_DLL_ENTRY;

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


typedef struct _DLOAD_DLL_MAP
{
    UINT                    NumberOfEntries;
    const DLOAD_DLL_ENTRY*  pDllEntry;
} DLOAD_DLL_MAP;

extern const DLOAD_DLL_MAP g_DllMap;

//
// END OF DEFINITIONS
//
//----------------------------------------------------------------------------


//
// All of the dll's that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
// DECLARE_PROCNAME_MAP(advapi32)
// DECLARE_PROCNAME_MAP(authz)
// DECLARE_ORDINAL_MAP(browseui)
// DECLARE_ORDINAL_MAP(cabinet)
// DECLARE_ORDINAL_MAP(certcli)
// DECLARE_PROCNAME_MAP(certcli)
// DECLARE_ORDINAL_MAP(comctl32)
// DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
// DECLARE_PROCNAME_MAP(credui)
// DECLARE_PROCNAME_MAP(crypt32)
// DECLARE_ORDINAL_MAP(cscdll)
// DECLARE_PROCNAME_MAP(ddraw)
// DECLARE_ORDINAL_MAP(devmgr)
// DECLARE_PROCNAME_MAP(efsadu)
// DECLARE_ORDINAL_MAP(fusapi)
// DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
// DECLARE_PROCNAME_MAP(iphlpapi)
// DECLARE_PROCNAME_MAP(linkinfo)
// DECLARE_PROCNAME_MAP(lz32)
// DECLARE_PROCNAME_MAP(mobsync)
// DECLARE_PROCNAME_MAP(mpr)
// DECLARE_PROCNAME_MAP(mprapi)
// DECLARE_PROCNAME_MAP(mscat32)
// DECLARE_ORDINAL_MAP(msgina)
// DECLARE_ORDINAL_MAP(msi)
// DECLARE_PROCNAME_MAP(netapi32)
// DECLARE_PROCNAME_MAP(netrap)
// DECLARE_PROCNAME_MAP(ntdsapi)
// DECLARE_PROCNAME_MAP(ntlanman)
// DECLARE_PROCNAME_MAP(ocmanage)
// DECLARE_PROCNAME_MAP(ole32)
// DECLARE_PROCNAME_MAP(oleacc)
// DECLARE_ORDINAL_MAP(oleaut32)
// DECLARE_ORDINAL_MAP(pidgen)
// DECLARE_PROCNAME_MAP(powrprof)
// DECLARE_PROCNAME_MAP(query)
// DECLARE_PROCNAME_MAP(rasapi32)
// DECLARE_PROCNAME_MAP(rasdlg)
// DECLARE_PROCNAME_MAP(rasman)
// DECLARE_PROCNAME_MAP(regapi)
// DECLARE_PROCNAME_MAP(rpcrt4)
// DECLARE_PROCNAME_MAP(rtutils)
// DECLARE_PROCNAME_MAP(samlib)
// DECLARE_PROCNAME_MAP(secur32)
// DECLARE_PROCNAME_MAP(setupapi)
// DECLARE_ORDINAL_MAP(sfc)
// DECLARE_PROCNAME_MAP(sfc)
// DECLARE_ORDINAL_MAP(shdocvw)
// DECLARE_PROCNAME_MAP(shdocvw)
// DECLARE_ORDINAL_MAP(shell32)
// DECLARE_PROCNAME_MAP(shlwapi)
// DECLARE_PROCNAME_MAP(shell32)
// DECLARE_ORDINAL_MAP(themesrv)
DECLARE_PROCNAME_MAP(urlmon)
// DECLARE_ORDINAL_MAP(userenv)
// DECLARE_PROCNAME_MAP(userenv)
// DECLARE_PROCNAME_MAP(utildll)
// DECLARE_PROCNAME_MAP(uxtheme)
// DECLARE_PROCNAME_MAP(version)
// DECLARE_PROCNAME_MAP(wininet)
// DECLARE_PROCNAME_MAP(winmm)
// DECLARE_PROCNAME_MAP(winscard)
// DECLARE_PROCNAME_MAP(winspool)
// DECLARE_PROCNAME_MAP(winsta)
// DECLARE_PROCNAME_MAP(wintrust)
// DECLARE_PROCNAME_MAP(wmi)
// DECLARE_ORDINAL_MAP(ws2_32)
// DECLARE_PROCNAME_MAP(ws2_32)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
//     DLDENTRYP(advapi32)
//     DLDENTRYP(authz)
//     DLDENTRYO(browseui)
//     DLDENTRYO(cabinet)
//     DLDENTRYB(certcli)
//     DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
//     DLDENTRYP(credui)
//     DLDENTRYP(crypt32)
//     DLDENTRYO(cscdll)
//     DLDENTRYP(ddraw)
//     DLDENTRYO(devmgr)
//     DLDENTRYP(efsadu)
//     DLDENTRYO(fusapi)
//     DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
//     DLDENTRYP(iphlpapi)
//     DLDENTRYP(linkinfo)
//     DLDENTRYP(lz32)
//     DLDENTRYP(mobsync)
//     DLDENTRYP(mpr)
//     DLDENTRYP(mprapi)
//     DLDENTRYP(mscat32)
//     DLDENTRYO(msgina)
//     DLDENTRYO(msi)
//     DLDENTRYP(netapi32)
//     DLDENTRYP(netrap)
//     DLDENTRYP(ntdsapi)
//     DLDENTRYP(ntlanman)
//     DLDENTRYP(ocmanage)
//     DLDENTRYP(ole32)
//     DLDENTRYP(oleacc)
//     DLDENTRYO(oleaut32)
//     DLDENTRYO(pidgen)
//     DLDENTRYP(powrprof)
//     DLDENTRYP(query)
//     DLDENTRYP(rasapi32)
//     DLDENTRYP(rasdlg)
//     DLDENTRYP(rasman)
//     DLDENTRYP(regapi)
//     DLDENTRYP(rpcrt4)
//     DLDENTRYP(rtutils)
//     DLDENTRYP(samlib)
//     DLDENTRYP(secur32)
//     DLDENTRYP(setupapi)
//     DLDENTRYB(sfc)
//     DLDENTRYB(shdocvw)
//     DLDENTRYB(shell32)
//     DLDENTRYP(shlwapi)
//     DLDENTRYO(themesrv)
    DLDENTRYP(urlmon)
//     DLDENTRYB(userenv)
//     DLDENTRYP(utildll)
//     DLDENTRYP(uxtheme)
//     DLDENTRYP(version)
//     DLDENTRYP(wininet)
//     DLDENTRYP(winmm)
//     DLDENTRYP(winscard)
//     DLDENTRYP_DRV(winspool)
//     DLDENTRYP(winsta)
//     DLDENTRYP(wintrust)
//     DLDENTRYP(wmi)
//     DLDENTRYB(ws2_32)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};

//+------------------------------------------------------------------------
//
// Delay load hook declaration. 
//
// * This pulls in the hook implementation from dload.lib *
//
//-------------------------------------------------------------------------
extern FARPROC WINAPI DelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo);
extern PfnDliHook __pfnDliFailureHook2;
       PfnDliHook __pfnDliFailureHook2 = PrivateDelayLoadFailureHook;

FARPROC WINAPI PrivateDelayLoadFailureHook(UINT unReason, PDelayLoadInfo pDelayInfo)
{
    return DelayLoadFailureHook(unReason, pDelayInfo);
}

#else
#pragma warning( disable : 4206 )
#endif // DLOAD1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\edundo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       edundo.cxx
//
//  Contents:   Undo unit batching implementation
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef _X_SEGLIST_HXX_
#define _X_SEGLIST_HXX_
#include "slist.hxx"
#endif

#ifndef _X_SLOAD_HXX_
#define _X_SLOAD_HXX_
#include "sload.hxx"
#endif


#include <initguid.h>
DEFINE_GUID(CLSID_CSelectionUndoUnit,   0x3050f7f8, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 
0xaa, 0x00, 0xbd, 0xce, 0x0b);

MtDefine(CBatchParentUndoUnit, Undo, "CBatchParentUndoUnit")
MtDefine(CBatchParentUndoUnitProxy, Undo, "CBatchParentUndoUnitProxy")
MtDefine(CUndoUnitAry_pv, Undo, "CUndoUnitAry::_pv")
MtDefine(CParentUndo, Undo, "CParentUndo");
MtDefine(CSelectionUndoUnit, Undo, "CSelectionUndoUnit")
MtDefine(CDeferredSelectionUndoUnit, Undo, "CDeferredSelectionUndoUnit")

DeclareTag(tagUndoSelEd, "Undo", "Selection ( Mshtmled  ) Undo ");


//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::CParentUndoBase, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CParentUndoBase::CParentUndoBase()
{
   _ulRefs = 1; 
    Assert(_pPUUOpen == NULL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::~CParentUndoBase, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CParentUndoBase::~CParentUndoBase()
{
    ReleaseInterface(_pPUUOpen);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::QueryInterface, public
//
//  Synopsis:   Implements QueryInterface 
//
//----------------------------------------------------------------------------

HRESULT
CParentUndoBase::QueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown
        || iid == IID_IOleUndoUnit
        || iid == IID_IOleParentUndoUnit)
    {
        *ppv = (IOleParentUndoUnit *)this;
    }
    
    if (!*ppv)
        RRETURN_NOTRACE(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Open, public
//
//  Synopsis:   Adds a parent undo unit, and leaves it open. All further
//              calls to the parent undo methods are forwarded to the object
//              until it is closed.
//
//  Arguments:  [pPUU] -- Object to add and leave open.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Open(IOleParentUndoUnit *pPUU)
{
    if (!pPUU)
        RRETURN(E_INVALIDARG);

    if (_pPUUOpen)
        RRETURN(_pPUUOpen->Open(pPUU));

    ReplaceInterface(&_pPUUOpen, pPUU);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    HRESULT hr;
    
    if (!_pPUUOpen)
        return S_FALSE;

    IFR( _pPUUOpen->Close(pPUU, fCommit) );
    if (hr == S_OK)
        return S_OK; 
    
    Assert(hr == S_FALSE);
    
    if (_pPUUOpen != pPUU)
        RRETURN(E_INVALIDARG);
    
    //
    // TODO:  Before we nuke this interface, 
    // we should add it to our undo stack, and
    // then we can return S_OK indicating we
    // have processed this Close. For now, 
    // we return S_FALSE and the rest will be
    // finished by the derived class. 
    // 
    // HACKHACK: Derived class HAS TO override
    // this hacking and return S_OK after adding
    // the unit to undo stack. Even if the child
    // class does not want to do anything, it 
    // still has to override the return value
    // so that we return S_OK.
    //
    // [zhenbinx]
    //

    ClearInterface(&_pPUUOpen);
    
    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::FindUnit, public
//
//  Synopsis:   Not implemented
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::FindUnit(IOleUndoUnit *pUU)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetParentState, public
//
//  Synopsis:   Returns state of open parent undo unit.  If there is no parent 
//              undo unit, returns 0.  
//
//  Arguments:  [pdwState] -- Place to fill in state.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetParentState(DWORD * pdwState)
{
    if (!pdwState)
        RRETURN(E_INVALIDARG);

    *pdwState = 0;

    if (_pPUUOpen)
        return _pPUUOpen->GetParentState(pdwState);
    
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Do, public
//
//  Synopsis:   Not implemented
//
//  Arguments:  [pUndoManager] -- Undo manager
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::Do(IOleUndoManager *pUndoManager)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetDescription, public
//
//  Synopsis:   Not implemented
//
//  Arguments:  [pbstr] -- output param
//
//  Returns:    E_NOTIMPL
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetDescription(BSTR *pbstr)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::GetUnitType, public
//
//  Synopsis:   Returns a null undo unit.
//
//  Arguments:  [pclsid] -- Place to put CLSID (caller allocated).
//              [plID]   -- Place to put identifier.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::GetUnitType(CLSID *pclsid, LONG *plID)
{
    // TODO: should we have a unit type? [ashrafm]
    *pclsid = CLSID_NULL;
    *plID   = 0;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::OnNextAdd, public
//
//  Synopsis:   Called when new undo unit added.  Currently, does nothing.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CParentUndoBase::OnNextAdd(void)
{
    if (_pPUUOpen)
    {
        IGNORE_HR(_pPUUOpen->OnNextAdd());
    }
    return S_OK; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CParentUndoBase::Add, public
//
//  Synopsis:   Not implemented in CParentUndoBase
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CParentUndoBase::Add(IOleUndoUnit * pUU)
{
    RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::CBatchParentUndoUnit, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnit::CBatchParentUndoUnit(CHTMLEditor *pEd, UINT uiStringID)
{
    _uiStringID = uiStringID;
    _pEd        = pEd;
    _fTopUnit   = TRUE;   
    _fEmpty     = TRUE;
    
    Assert(_pEd);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::CBatchParentUndoUnit, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnit::~CBatchParentUndoUnit(void)
{

    for (int i = 0; i < _aryUndoUnits.Size(); ++i)
        ReleaseInterface(_aryUndoUnits[i]);

}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::FindChild, public
//
//  Synopsis:   Searches the children in a given stack for a undo unit.
//
//  Arguments:  [aryUnit] -- Array to look in
//              [pUU]     -- Unit to look for
//
//  Returns:    The index of the element in [aryUnit] that contains [pUU].
//
//----------------------------------------------------------------------------
int
CBatchParentUndoUnit::FindChild(CUndoUnitAry &aryUnit, IOleUndoUnit *pUU)
{
    IOleParentUndoUnit * pPUU;
    IOleUndoUnit **      ppUA;
    HRESULT              hr     = S_FALSE;
    int                  i;

    for (i = aryUnit.Size(), ppUA = aryUnit;
         i;
         i--, ppUA++)
    {
        if ((*ppUA)->QueryInterface(IID_IOleParentUndoUnit, (LPVOID*)&pPUU) == S_OK)
        {
            hr = pPUU->FindUnit(pUU);

            ReleaseInterface(pPUU);
        }

        if (hr == S_OK)
            break;
    }

    if (i == 0)
        i = -1;
    else
        i = ppUA - (IOleUndoUnit **)aryUnit;

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::FindUnit, public
//
//  Synopsis:   Indicates if the given unit is in our undo stack or the stack
//              of one of our children. Doesn't check the current open object.
//
//  Arguments:  [pUU] -- Unit to find
//
//  Returns:    TRUE if we found it.
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::FindUnit(IOleUndoUnit *pUU)
{
    int i;

    if (!pUU)
        RRETURN(E_INVALIDARG);

    i = _aryUndoUnits.Find(pUU);
    if (i != -1)
        return S_OK;

    i = FindChild(_aryUndoUnits, pUU);
    if (i != -1)
        return S_OK;

    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::DoTo, protected
//
//  Synopsis:   Helper method that calls do on an array of objects
//
//  Arguments:  [pUM]         -- Pointer to undo manager to pass to units
//              [paryUnit]    -- Undo or Redo stack
//              [pUU]         -- Object to undo or redo to.
//              [fDoRollback] -- If TRUE, rollback will be attempted on an
//                               error. Noone but the undo manager should
//                               pass TRUE for this.
//
//  Returns:    HRESULT
//
//  Notes:      Parent units can use the _fUnitSucceeded flag to determine
//              whether or not they should commit the unit they put on the
//              opposite stack.  If _fUnitSucceeded is TRUE after calling
//              this function, then the unit should commit itself.  If
//              FALSE, the unit does not have to commit itself.  In either
//              case any error code returned by this function should be
//              propagated to the caller.
//
//----------------------------------------------------------------------------
HRESULT
CBatchParentUndoUnit::DoTo(IOleUndoManager *            pUM,
                     CUndoUnitAry *               paryUnit,
                     IOleUndoUnit *               pUU)
{
    IOleUndoUnit **         ppUA;
    CUndoUnitAry            aryCopy;
    int                     iUnit;
    HRESULT                 hr;

    _fUnitSucceeded = FALSE;

    if (_pPUUOpen)
        RRETURN(E_UNEXPECTED);

    Assert(paryUnit);

    if (paryUnit->Size() == 0)
        return S_OK;

    hr = THR(aryCopy.Copy(*paryUnit, FALSE));
    if (hr)
        RRETURN(hr);

    if (pUU)
    {
        iUnit = aryCopy.Find(pUU);
        if (iUnit == -1)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }
    else
    {
        iUnit = aryCopy.Size() - 1;
        pUU = aryCopy[iUnit];
    }

    //
    // Delete the units from the original array before we call Do() on those
    // units in case they do something naughty like call DiscardFrom which
    // would Release them.
    //
    paryUnit->DeleteMultiple(iUnit, paryUnit->Size() - 1);

    //
    // Make sure the copy of the array has only the units in it we're
    // processing.
    //
    if (iUnit > 0)
    {
        aryCopy.DeleteMultiple(0, iUnit - 1);
    }

    for(ppUA = &aryCopy.Item(aryCopy.Size() - 1);
        ; // Infinite
        ppUA--)
    {
        hr = THR((*ppUA)->Do(pUM));
        if (hr)
            goto Cleanup;

        _fUnitSucceeded = TRUE;

        if (*ppUA == pUU)
            break;
    }

    Assert(!_pPUUOpen);

Cleanup:
    if (hr == E_ABORT)
    {
        hr = E_FAIL;
    }

    aryCopy.ReleaseAll();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Do, public
//
//  Synopsis:   Calls undo on our contained undo object.
//
//  Arguments:  [pUndoManager] -- Pointer to Undo Manager
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::Do(IOleUndoManager *pUndoManager)
{
    HRESULT        hr    = S_OK;

    if (_aryUndoUnits.Size() == 0)
        return S_OK;
        
    hr = THR( _pEd->GetSelectionManager()->DeferSelection(TRUE) );
    Assert(!hr);
    
    //
    // Disable batching
    //
    _fTopUnit = FALSE;   

    //
    // Put ourself on the undo manager's Redo stack.
    //
    if (pUndoManager)
        IFC( pUndoManager->Open(this) );

    //
    // Call Do() on all the units. This call makes a copy of the array and
    // removes the units from _aryUndoUnits before making any calls to Do().
    //

    hr = THR(DoTo(pUndoManager, &_aryUndoUnits, _aryUndoUnits[0]));

    //
    // _fUnitSucceeded will be TRUE after calling DoTo only if at least
    // one of our contained units was successful. In this case we need to
    // commit ourselves, even if an error occurred.
    //

    if (pUndoManager)
    {
        HRESULT hr2;
        BOOL    fCommit = TRUE;

        //
        // If we are empty or none of our contained units succeeded then do
        // not commit ourselves.
        //
        if (!_fUnitSucceeded || (_aryUndoUnits.Size() == 0))
        {
            fCommit = FALSE;
        }

        hr2 = THR(pUndoManager->Close(this, fCommit));
        //
        // Preserve the HRESULT from the call to DoTo() if it failed.
        //
        if (!hr && FAILED(hr2))
        {
            hr = hr2;
        }
    }

Cleanup:
    //
    // If selection fails, let the user undo.  
    //
    IGNORE_HR(_pEd->GetSelectionManager()->DeferSelection(FALSE));
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::GetDescription, public
//
//  Synopsis:   Gets the description for this undo unit.
//
//  Arguments:  [pbstr] -- Place to put description
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CBatchParentUndoUnit::GetDescription(BSTR *pbstr)
{
    TCHAR   *pchUndoTitle;

    if (!pbstr)
        RRETURN(E_INVALIDARG);

    *pbstr = NULL;        

    pchUndoTitle = _pEd->GetCachedString(_uiStringID);
    if (!pchUndoTitle)
        RRETURN(E_FAIL);

    *pbstr = SysAllocString(pchUndoTitle);
    if (*pbstr == NULL)
        RRETURN(E_OUTOFMEMORY);

    return S_OK;        
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::OnNextAdd, public
//
//  Synopsis:   Called when new undo unit is added.  Currently, sets _fTopUnit.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::OnNextAdd(void)
{
    if (_pPUUOpen)
    {
        IGNORE_HR(_pPUUOpen->OnNextAdd());
    }
    else
    {
        _fTopUnit = FALSE;    
    }
    return S_OK; 
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::GetTopUndoUnit, protected
//
//  Synopsis:   Returns the undo unit at the top of the stack.
//
//----------------------------------------------------------------------------
IOleUndoUnit *
CBatchParentUndoUnit::GetTopUndoUnit()
{
    int c = _aryUndoUnits.Size();

    if (c > 0)
        return _aryUndoUnits[c-1];

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::AddUnit, protected
//
//  Synopsis:   Adds a new unit to the appropriate stack, no questions asked.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnit::AddUnit(IOleUndoUnit *pUU)
{
    HRESULT             hr;
    CSelectionUndoUnit  *pSelectionUndoUnit;

    if (_aryUndoUnits.Size() > 0)
    {
        IOleUndoUnit *pUUTop = GetTopUndoUnit();

        if (pUUTop)
            pUUTop->OnNextAdd();
    }

    IFC( _aryUndoUnits.Append(pUU) );
    pUU->AddRef();

    //
    // CSelectionUndoUnit is a discardable undo unit
    //

    if (FAILED(pUU->QueryInterface(CLSID_CSelectionUndoUnit, (LPVOID *)&pSelectionUndoUnit)))
    {
        _fEmpty = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Add, public
//
//  Synopsis:   Adds an undo unit to the stack directly. Doesn't leave it
//              open.
//
//  Arguments:  [pUU] -- Unit to add.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::Add(IOleUndoUnit * pUU)
{
    HRESULT hr;

    if (!pUU)
        RRETURN(E_INVALIDARG);

    if (_pPUUOpen)
        RRETURN(_pPUUOpen->Add(pUU));

    hr = AddUnit(pUU);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::Close, public
//
//  Synopsis:   Closes an open undo unit, not necessarily the one we have
//              open directly.
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CBatchParentUndoUnit::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{
    HRESULT               hr;
    SP_IOleParentUndoUnit spPUU = _pPUUOpen;        

    IFR( CParentUndoBase::Close(pPUU, fCommit) );

    //
    // TODO: See comment in CParentUndoUnit::Close
    // 
    // Finish up what the parent class left.
    // We should move this functionality up
    // to the parent class. For now, just 
    // leave it here.
    //
    if (fCommit && spPUU && hr == S_FALSE)
    {
        IFR( AddUnit(spPUU) );
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnit::IsEmpty, public
//
//  Synopsis:   Is the parent undo unit empty?
//
//  Returns:    TRUE iff parent undo unit is empty
//
//----------------------------------------------------------------------------

BOOL 
CBatchParentUndoUnit::IsEmpty()
{
   return _fEmpty;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::CBatchParentUndoUnitProxy, public
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnitProxy::CBatchParentUndoUnitProxy(CBatchParentUndoUnit *pBatchPUU)
{
    Assert(pBatchPUU);
    _pBatchPUU = pBatchPUU;
    if (pBatchPUU)
        pBatchPUU->AddRef();
}
    
//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::~CBatchParentUndoUnitProxy, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CBatchParentUndoUnitProxy::~CBatchParentUndoUnitProxy()
{
    ReleaseInterface(_pBatchPUU);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::Add, protected
//
//  Synopsis:   Adds a new unit to the main batch undo unit.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnitProxy::Add(IOleUndoUnit * pUU)
{
    RRETURN(_pBatchPUU->Add(pUU));
}



//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::Close Override Parent
//
//  Synopsis:   Closes an open undo unit. We do not add anything to undo stack
//              since this is a proxy unit. Simply call CParentUndoBase::Close
//
//  Arguments:  [pPUU]    -- Pointer to currently open object.
//              [fCommit] -- If TRUE, then the closed undo unit is kept,
//                           otherwise it's discarded.
//
//  Returns:    HRESULT
//
//  Note:       There is a hacking inside CParentUndoBase::Close. We need to 
//              override that hacking. 
//      
//----------------------------------------------------------------------------

HRESULT
CBatchParentUndoUnitProxy::Close(IOleParentUndoUnit *pPUU, BOOL fCommit)
{

    HRESULT               hr;
    SP_IOleParentUndoUnit spPUU = _pPUUOpen;        

    IFR( CParentUndoBase::Close(pPUU, fCommit) );

    //
    // HACKHACK: 
    // when _pPUUOpen and hr == S_FALSE. Our child 
    // unit indeed was closed and we are done. So 
    // we need to return S_OK. However the parent 
    // class returned S_FALSE due to a hacking.So 
    // we need to override this behavior. [zhenbinx]
    //
    // 
    if (spPUU && hr == S_FALSE)
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);

}


//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::IsEmpty, public
//
//  Synopsis:   Is the parent undo unit empty?
//
//  Returns:    TRUE iff parent undo unit is empty
//
//----------------------------------------------------------------------------

BOOL 
CBatchParentUndoUnitProxy::IsEmpty()
{
    // The undo unit proxy is used for getting undo units and inserting
    // it into the active batch undo unit.  Consequently, the proxy
    // parent undo is always empty and we should never commit it to the
    // undo stack.

    return TRUE;
}



CSelectionUndo::CSelectionUndo(CEditorDoc* pEd )
    : CUndoHelper( pEd  )
{
    TraceTag((tagUndoSelEd, "CSelectionUndo::CreateAndSubmit"));

    CreateAndSubmit( );
}

HRESULT 
CSelectionUndo::CreateUnit( IOleUndoUnit** ppUU)
{
    HRESULT                 hr = S_OK;
    CSelectionUndoUnit      *pUU;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eType;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    LONG                    mpStart, mpEnd;
    SP_IHTMLElement         spActiveElement;
    SP_IMarkupContainer     spContainer;
    CHTMLEditor             *pEditor = DYNCAST( CHTMLEditor, _pEd);
    BOOL                    fEmpty = FALSE;
    int                     iSegmentCount = 0;

    pUU = new CSelectionUndoUnit( _pEd );

    if (pUU)    
    {
        IFC( GetSegmentList( & spSegmentList ));
        IFC( spSegmentList->GetType( &eType ));
        IFC( GetSegmentCount( spSegmentList, &iSegmentCount ) );

        if( !fEmpty && (eType != SELECTION_TYPE_None) )
        {
            IFC( pEditor->CreateMarkupPointer( & spStart ));
            IFC( pEditor->CreateMarkupPointer( & spEnd ));

            IFC( GetDoc()->get_activeElement( & spActiveElement ));

            IFC( spSegmentList->CreateIterator( &spIter ) );

            if ( iSegmentCount == 1 )
            {            
                IFC( spIter->Current(&spSegment ) );
                IFC( spSegment->GetPointers(spStart, spEnd ));

                IFC( spStart->GetContainer( & spContainer));
                IFC( pEditor->GetMarkupPosition( spStart, & mpStart ));
                IFC( pEditor->GetMarkupPosition( spEnd, & mpEnd ));

                pUU->SetData( spActiveElement, mpStart, mpEnd, spContainer, eType );
            }
            else
            {
                int i = 0;
                
                IFC( pUU->InitSetData( spActiveElement, iSegmentCount, eType ) );

                while( spIter->IsDone() == S_FALSE )
                {
                    IFC( spIter->Current(&spSegment) );
                    IFC( spSegment->GetPointers(spStart, spEnd ));
                
                    IFC( pEditor->GetMarkupPosition( spStart, & mpStart ));
                    IFC( pEditor->GetMarkupPosition( spEnd, & mpEnd ));
                    IFC( spStart->GetContainer( & spContainer));

                    pUU->SetDataSegment( i++, mpStart, mpEnd , spContainer );

                    IFC( spIter->Advance() );
                }               
            }
        }            
        else
        {
            pUU->SetData( NULL , -1, -1, NULL, SELECTION_TYPE_None );
        }
    
        Assert( ppUU );
        
        *ppUU = pUU;
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionUndo::GetSegmentList(ISegmentList** ppSegmentList)
{
    SP_ISelectionServices   spSelServ;
    HRESULT                 hr;

    Assert( ppSegmentList );
    
    IFC( _pEd->GetSelectionServices(&spSelServ) );
    IFC( spSelServ->QueryInterface( IID_ISegmentList, (void**)ppSegmentList) );

Cleanup:    
    RRETURN( hr );    
}

HRESULT
CSelectionUndo::GetSegmentCount(ISegmentList *pISegmentList, int *piCount )
{
    HRESULT                 hr;
    SP_ISegmentListIterator spIter;
    int                     nSize = 0;
    
    Assert( pISegmentList && piCount );

    IFC( pISegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        nSize++;
        IFC( spIter->Advance() );
    }

    *piCount = nSize;

Cleanup:
    RRETURN(hr);
}


//---------------------------------------------------------------------------
//
// CSelectionUndoUnit
//
//---------------------------------------------------------------------------


CSelectionUndoUnit::CSelectionUndoUnit(CEditorDoc* pEditor)
    : CUndoUnitBase( pEditor )
{
    TraceTag((tagUndoSelEd, "CSelectionUndoUnit:: ctor this:%ld", this ));

    _eSelType = SELECTION_TYPE_None;
}

CSelectionUndoUnit::~CSelectionUndoUnit()
{ 
    ReleaseInterface( _pIActiveElement ); 

    if ( _ctSegments == 1 )
    {
        ReleaseInterface( _pIContainer );
    }
    else
    {
        for( int i = 0; i < _ctSegments; i ++ )
        {
            ReleaseInterface( _ppIContainer[i]);
        }
    
        delete [] _pmpStart;
        delete [] _pmpEnd;
        delete [] _ppIContainer;
    }        
}

void    
CSelectionUndoUnit::SetData( 
                            IHTMLElement* pIElement ,  
                            long mpStart, 
                            long mpEnd, 
                            IMarkupContainer* pIContainer ,                            
                            SELECTION_TYPE eSelType )
{ 
    Assert( !_pIActiveElement );
    Assert( !_pIContainer );
    Assert( _pEd );

    ReplaceInterface( & _pIActiveElement, pIElement );
    ReplaceInterface( & _pIContainer, pIContainer );
    
    _mpStart = mpStart;
    _mpEnd = mpEnd;
    _eSelType = eSelType;
    _ctSegments = 1;

    TraceTag((tagUndoSelEd, "CSelectionUndoUnit. Set Data this:%ld type:%d ctSegments:%ld start:%ld end:%ld",
                this, _eSelType, _ctSegments, _mpStart, _mpEnd ));

}

HRESULT 
CSelectionUndoUnit::QueryInterface(REFIID iid, LPVOID *ppv)
{
    HRESULT hr = S_OK;

    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iid == CLSID_CSelectionUndoUnit)
    {
        *ppv = (LPVOID *)this;
    }
    else
    {
        hr = THR(CUndoUnitBase::QueryInterface(iid, ppv));
    }

Cleanup:
    RRETURN(hr);
}


//+====================================================================================
//
// Method: InitSetData
//
// Synopsis: Set the Invariant part of a CSelectionUndoUnit. Only to be used for Multiple-Selection
//
//------------------------------------------------------------------------------------



HRESULT    
CSelectionUndoUnit::InitSetData( IHTMLElement* pIActiveElement ,
                                 int ctSegments,
                                 SELECTION_TYPE eSelType)
{
    HRESULT hr = S_OK;

    Assert( !_pIActiveElement );
    Assert( ctSegments > 1 );
    
    ReplaceInterface( & _pIActiveElement, pIActiveElement );

    _eSelType = eSelType;
    _ctSegments = ctSegments;

    _pmpStart = new long[_ctSegments];
    if (_pmpStart == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _pmpEnd = new long[_ctSegments];
    if (_pmpEnd == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _ppIContainer = new IMarkupContainer* [_ctSegments];
    if (_ppIContainer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ::ZeroMemory( _ppIContainer, sizeof( IMarkupContainer* ) * _ctSegments );
    
    TraceTag((tagUndoSelEd, "CSelectionUndoUnit. Init SetData this:%ld type:%d ctSegments:%d",
                this, _eSelType, _ctSegments ));


Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: SetDataSegment
//
// Synopsis: Set Selection info for a given segment. Only to be used for multiple selection
//
//------------------------------------------------------------------------------------

void    
CSelectionUndoUnit::SetDataSegment( int iSegmentIndex,
                                    long mpStart, 
                                    long mpEnd,
                                    IMarkupContainer * pIMarkupContainer )
{
    Assert( iSegmentIndex < _ctSegments );
    Assert( _eSelType != SELECTION_TYPE_None );
    Assert( _ctSegments > 1 );
    Assert( ! _ppIContainer[iSegmentIndex]);
    
    _pmpStart[iSegmentIndex] = mpStart;
    _pmpEnd[iSegmentIndex] = mpEnd;

    _ppIContainer[iSegmentIndex] = pIMarkupContainer;
    (_ppIContainer[iSegmentIndex])->AddRef();
}
                            
HRESULT
CSelectionUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;
    SP_IMarkupPointer spStart;
    SP_IMarkupPointer spEnd;
    SP_IMarkupPointer2 spStart2;
    SP_IMarkupPointer2 spEnd2;

    TraceTag((tagUndoSelEd, "CSelectionUndoUnit::PrivateDo. this:%ld", this ));

    CHTMLEditor     *pEditor = DYNCAST( CHTMLEditor, _pEd );
    CSpringLoader   *psl     = pEditor->GetPrimarySpringLoader();

    if (psl)
        psl->Reset();    
    
    if ( _eSelType != SELECTION_TYPE_None )
    {                                
        Assert( _pIActiveElement );

        IFC( pEditor->MakeCurrent( _pIActiveElement ));

        IFC( pEditor->CreateMarkupPointer( & spStart ));
        IFC( pEditor->CreateMarkupPointer( & spEnd ));

        //
        // Do some work to position some MarkupPointers where we were
        //
        
        if ( _ctSegments == 1 )
        {    
            IFC( pEditor->MoveToMarkupPosition( spStart, _pIContainer, _mpStart ));
            IFC( pEditor->MoveToMarkupPosition( spEnd, _pIContainer, _mpEnd ));
            
            //
            // Select the MarkupPointers
            //
            hr = THR( pEditor->SelectRangeInternal( spStart, spEnd, _eSelType, TRUE ));
            
            TraceTag(( tagUndoSelEd, "Selection restored to this:%ld type:%d start:%ld end:%ld", 
                    this, _eSelType, _mpStart, _mpEnd ));
        }
        else
        {
        
            CSegmentList segmentList;

            IFC( segmentList.SetSelectionType( _eSelType ));
            SP_IHTMLElement     spElement;
            SP_IElementSegment  spSegment;
            
            for ( int i = 0; i < _ctSegments; i ++ )
            {
                IFC( pEditor->MoveToMarkupPosition( spStart, _ppIContainer[i], _pmpStart[i] ));

                IFC( spStart->Right( TRUE, NULL, & spElement, NULL, NULL ));
                
                IFC( segmentList.AddElementSegment( spElement, &spSegment ));

                TraceTag(( tagUndoSelEd, "Multiple Selection restored to this:%ld type:%d start:%ld end:%ld", 
                        this, _eSelType, _pmpStart[i], _pmpEnd[i] ));

            }                

            SP_ISegmentList spSegList;
            IFC( segmentList.QueryInterface( IID_ISegmentList, (void**) & spSegList ));

            IFC( pEditor->Select( spSegList ));            
        }
    }
    else
    {
        //
        // Whack any Selection that we may have 
        // (as we had nothing when the undo unit was created )
        //
        pEditor->DestroyAllSelection();
    }

    //
    //Create a Deferred Selection Undo
    //
    {   
        CDeferredSelectionUndo DeferUndo( _pEd );
    }
    
Cleanup:

    RRETURN( hr );
}

//---------------------------------------------------------------------------
//
// CDeferredSelectionUndo
//
//---------------------------------------------------------------------------


HRESULT
CDeferredSelectionUndo::CreateUnit(IOleUndoUnit** ppUU )
{
    HRESULT hr = S_OK;
    
    CDeferredSelectionUndoUnit * pUU;

    pUU = new CDeferredSelectionUndoUnit( _pEd );
    if ( ! pUU )
    {
        hr = E_OUTOFMEMORY;
    }

    Assert( ppUU );
    *ppUU = pUU ;
    
    return ( hr );
}


CDeferredSelectionUndo::CDeferredSelectionUndo(CEditorDoc* pEd )
    : CUndoHelper( pEd )
{
    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit::CreateAndSubmit"));

    CreateAndSubmit();    
}

//---------------------------------------------------------------------------
//
// CDeferredSelectionUndoUnit
//
//---------------------------------------------------------------------------

CDeferredSelectionUndoUnit::CDeferredSelectionUndoUnit(CEditorDoc* pEd)
    : CUndoUnitBase( pEd )
{
    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit ctor: this:%ld", this ));
}

HRESULT
CDeferredSelectionUndoUnit::PrivateDo(IOleUndoManager *pUndoManager)
{
    HRESULT hr = S_OK;

    TraceTag((tagUndoSelEd, "CDeferredSelectionUndoUnit::PrivateDo. this:%ld About to create a CSelectionUndo", this ));

    SP_ISelectionServicesListener spListener;
    
    CHTMLEditor             *pEditor = DYNCAST( CHTMLEditor, _pEd);
    
    if ( SUCCEEDED( pEditor->GetISelectionServices()->GetSelectionServicesListener( & spListener )))
    {
        IFC( spListener->BeginSelectionUndo());
    }
    
Cleanup:    
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Member:     CUndoManagerHelper::CUndoManagerHelper, public
//
//  Synopsis:   ctor 
//
//----------------------------------------------------------------------------
CUndoManagerHelper::CUndoManagerHelper(CHTMLEditor *pEd)
{
    Assert(pEd);
    
    _pEd = pEd;
    _lOpenParentUndoUnits = 0;
    _pPUU = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::BeginUndoUnit, public
//
//  Synopsis:   Starts a parent undo unit for an editing operation if we don't 
//              already have one.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CUndoManagerHelper::BeginUndoUnit(UINT uiStringId, CBatchParentUndoUnit *pBatchPUU /* = NULL */)
{
    HRESULT             hr = S_OK;
    SP_IOleUndoManager  spUndoMgr;
    
    //
    // If we already have a parent undo unit, just increment the nesting count
    //

    if (_lOpenParentUndoUnits)
    {
        Assert(_pPUU);
        _lOpenParentUndoUnits++;
        goto Cleanup;
    }
    Assert(_pPUU == NULL);

    if (pBatchPUU)
    {
        // We create a proxy undo unit to listen in on all modifications
        // to the undo stack.  The proxy will then reinsert undo units
        // into the topmost pBatchPUU

        _pPUU = new CBatchParentUndoUnitProxy(pBatchPUU);
    }
    else
    {
        //
        // Generate a default parent undo unit
        //
        _pPUU = new CBatchParentUndoUnit(_pEd, uiStringId);
    }
    
    if (!_pPUU)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Open the parent undo unit
    //
    IFC( _pEd->GetUndoManager( & spUndoMgr ));
    IFC( spUndoMgr->Open(_pPUU) )
    _lOpenParentUndoUnits++;
    
    //
    // Add the seleciton undo unit
    //
    
    if ( _pEd->GetSelectionServices()->GetUndoListener())
    {
        IGNORE_HR(_pEd->GetSelectionServices()->GetUndoListener()->BeginSelectionUndo());
    }          

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBatchParentUndoUnitProxy::EndUndoUnit, public
//
//  Synopsis:   Ends the current parent undo unit.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CUndoManagerHelper::EndUndoUnit()
{
    HRESULT hr = S_OK;

    //
    // We need to make sure that we will not get interrupted by pending tasks
    // which may try to modify undo state
    //

    IGNORE_HR( _pEd->GetSelectionManager()->DoPendingTasks() );

    //
    // Sanity check
    //

    Assert(_lOpenParentUndoUnits >= 0);
	
    //
    // If we have not opened a parent undo unit, we have nothing to close
    //
    
    if (_lOpenParentUndoUnits == 0)
        goto Cleanup;

    //
    // Decrement the number of open parent undo units.  Note that we only generate
    // a real parent undo unit for the topmost one on the stack.  The rest
    // are just counted with _lOpenParentUndoUnits.  So, we only close the undo unit
    // when our count goes to 0.
    //

    _lOpenParentUndoUnits--;

    if (_lOpenParentUndoUnits == 0) 
    {
        BOOL fCommit;

        Assert(_pPUU);

        //
        // We don't commit empty undo units
        //
        
        fCommit= !_pPUU->IsEmpty();

        //
        // Generate the end selection undo
        //

        // #111204
        // Proxy always return TRUE for IsEmpty(). This makes
        // EndSelectionUndo being skipped over in batching
        // typing case.
        //
        if ( _pEd->GetSelectionServices()->GetUndoListener() && 
                (fCommit || _pPUU->IsProxy())
             )
        {
            IGNORE_HR(_pEd->GetSelectionServices()->GetUndoListener()->EndSelectionUndo());
        }

        //
        // Close the parent undo unit
        //
        SP_IOleUndoManager spUndoMgr;        
        IGNORE_HR( _pEd->GetUndoManager( & spUndoMgr ));
        IGNORE_HR( spUndoMgr->Close(_pPUU, fCommit /* fCommit */) );
        
        //
        // If we get an undo event that does not go through the batch undo typing proxy, 
        // we need to terminate batch typing.
        //
        
        if (!_pPUU->IsProxy() && !fCommit)
        {
            IGNORE_HR( _pEd->GetSelectionManager()->TerminateTypingBatch() );
        }

        _pPUU->Release();
        _pPUU = NULL;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\formcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_FORMCMD_HXX_
#define X_FORMCMD_HXX_
#include "formcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

//
// Externs
//
MtDefine(CMultipleSelectionCommand, EditCommand, "CMultipleSelectionCommand");
MtDefine(C2DPositionModeCommand, EditCommand, "C2DPositionModeCommand");
MtDefine(C1DElementCommand, EditCommand, "C1DElementCommand");
MtDefine(C2DElementCommand, EditCommand, "C2DElementCommand");
MtDefine(CAbsolutePositionCommand, EditCommand, "CAbsolutePositionCommand");
MtDefine(CLiveResizeCommand, EditCommand, "CLiveResizeCommand");
MtDefine(CDisalbeEditFocusHandlesCommand, EditCommand, "CDisalbeEditFocusHandlesCommand");
MtDefine(CAtomicSelectionCommand, EditCommand, "CAtomicSelectionCommand");


using namespace EdUtil;

////////////////////////////////////////////////////////////////////////////////
// CMultipleSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CMultipleSelectionCommand::PrivateExec( 
                            DWORD        nCmdexecopt,
                            VARIANTARG * pvarargIn,
                            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetMultipleSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetMultipleSelection( ! GetCommandTarget()->IsMultipleSelection());
    }        
    return S_OK;
}

HRESULT 
CMultipleSelectionCommand::PrivateQueryStatus( 
     OLECMD     * pcmd,
     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsMultipleSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
// C2DPositionModeCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C2DPositionModeCommand::PrivateExec( 
                            DWORD        nCmdexecopt,
                            VARIANTARG * pvarargIn,
                            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->Set2DPositionMode( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->Set2DPositionMode( !GetCommandTarget()->Is2DPositioned());
    }        
        
    return S_OK ;
}

HRESULT 
C2DPositionModeCommand::PrivateQueryStatus( OLECMD * pcmd, OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->Is2DPositioned() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// C1DElementCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C1DElementCommand::PrivateExec(DWORD nCmdexecopt, VARIANTARG * pvarargIn,VARIANTARG * pvarargOut )
{    
    if (pvarargOut && SUCCEEDED(VariantChangeType(pvarargOut, pvarargOut, 0, VT_BOOL)))
    {
        HRESULT                 hr = S_OK ;
        SELECTION_TYPE          eSelectionType;
        SP_ISegmentList         spSegmentList;
        SP_IHTMLElement         spElement;
        SP_ISegmentListIterator spIter;
        SP_ISegment             spSegment;       
 
        IFR ( GetSegmentList(&spSegmentList) );
        IFR ( spSegmentList->GetType(&eSelectionType) );

        if( eSelectionType == SELECTION_TYPE_Control)
        {
            BOOL fNet1D = TRUE;

            IFR( spSegmentList->CreateIterator( &spIter ) );
            
            while( spIter->IsDone() == S_FALSE )
            {
                BOOL b2D = FALSE;
            
                IFR( spIter->Current(&spSegment) );
                IFR( GetSegmentElement(spSegment, &spElement) );
                IFC( Is2DElement(spElement , &b2D));
                
                if (b2D)
                    fNet1D = FALSE;

                IFR( spIter->Advance() );                    
            }
            V_VT  (pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fNet1D);
        }    
    }

Cleanup:
    return S_OK ;
}

HRESULT 
C1DElementCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;

    pCmd->cmdf = MSOCMDSTATE_DISABLED ;

    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNet1D = TRUE;

        IFR( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
        
            IFR( spIter->Current(&spSegment) );
            IFR( GetSegmentElement(spSegment, &spElement) );
            IFC( Is2DElement(spElement , &b2D));
            
            if (b2D)
                fNet1D = FALSE;

            IFR( spIter->Advance() );                    
        }

        pCmd->cmdf = (fNet1D ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP );   
    }

Cleanup:
    return (S_OK);
}


///////////////////////////////////////////////////////////////////////////////
// C2DElementCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
C2DElementCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut )
{
   if (pvarargOut && SUCCEEDED(VariantChangeType(pvarargOut, pvarargOut, 0, VT_BOOL)))
   {
        HRESULT                 hr = S_OK ;
        SELECTION_TYPE          eSelectionType;
        SP_ISegmentList         spSegmentList;
        SP_ISegmentListIterator spIter;
        SP_ISegment             spSegment;       
        SP_IHTMLElement         spElement;

        IFR ( GetSegmentList(&spSegmentList) );
        IFR ( spSegmentList->GetType(&eSelectionType) );

        if( eSelectionType == SELECTION_TYPE_Control)
        {
            BOOL fNet2D = TRUE;

            IFR( spSegmentList->CreateIterator( &spIter ) );
            
            while( spIter->IsDone() == S_FALSE )
            {
                BOOL b2D = FALSE;
            
                IFR( spIter->Current(&spSegment) );
                IFR( GetSegmentElement(spSegment, &spElement) );
                IFC( Is2DElement(spElement , &b2D));
                
                if (!b2D)
                    fNet2D = FALSE;

                IFR( spIter->Advance() );                    
            }
            V_VT  (pvarargOut) = VT_BOOL;
            V_BOOL(pvarargOut) = VARIANT_BOOL_FROM_BOOL(fNet2D);
        }    
   }

Cleanup:
   return S_OK ;
}

HRESULT 
C2DElementCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;

    pCmd->cmdf = MSOCMDSTATE_DISABLED ;

    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType(&eSelectionType) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNet2D = TRUE;

        IFR( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
       
            IFR( spIter->Current(&spSegment) );
            IFR( GetSegmentElement(spSegment, &spElement) );
            IFC( Is2DElement(spElement , &b2D));
            
            if (!b2D)
                fNet2D = FALSE;

            IFR( spIter->Advance() );                    
        }

        pCmd->cmdf = (fNet2D ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP );   
    }

Cleanup:
    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////////
// CAbsolutePositionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CAbsolutePositionCommand::PrivateExec( DWORD nCmdexecopt,VARIANTARG * pvarargIn, VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;
    CEdUndoHelper           undoPositioning(GetEditor());
    
    
    IFC (GetSegmentList(&spSegmentList));
    IFC ( spSegmentList->GetType(&eSelectionType)) ;

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        IFC( spSegmentList->CreateIterator( &spIter ) );
    
        IFC( undoPositioning.Begin(IDS_EDUNDOPROPCHANGE) );
            
        while( spIter->IsDone() == S_FALSE )
        {        
            IFC( spIter->Current(&spSegment) );
            IFC (GetSegmentElement(spSegment, &spElement));
            
            if ( pvarargIn && pvarargIn->vt == VT_BOOL )
            {
                IFC (MakeAbsolutePosition(spElement, ENSURE_BOOL(pvarargIn->bVal)));
            }
            else
            {
               BOOL b2D = FALSE;       
               IFC (Is2DElement(spElement , &b2D));
               IFC (MakeAbsolutePosition(spElement , !b2D));
            }

            IFC( spIter->Advance() );
        }
        IFC( GetEditor()->GetSelectionManager()->OnLayoutChange());
    }

Cleanup:
    return (S_OK);
}

HRESULT 
CAbsolutePositionCommand::PrivateQueryStatus( OLECMD * pCmd, OLECMDTEXT * pCmdText )
{
    HRESULT                 hr = S_OK ;
    SELECTION_TYPE          eSelectionType;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;       
    SP_IHTMLElement         spElement;
    
    pCmd->cmdf = MSOCMDSTATE_DISABLED ;
    
    IFR ( GetSegmentList(&spSegmentList) );
    IFR ( spSegmentList->GetType( &eSelectionType ) );

    if (eSelectionType == SELECTION_TYPE_Control)
    {
        BOOL fNetAbsPos = TRUE;

        IFC( spSegmentList->CreateIterator( &spIter ) );
            
        while( spIter->IsDone() == S_FALSE )
        {
            BOOL b2D = FALSE;
        
            IFC( spIter->Current(&spSegment) );
            IFR (GetSegmentElement(spSegment, &spElement) );
            IFC (Is2DElement(spElement , &b2D));
            if (!b2D)
                fNetAbsPos = FALSE;

            IFC( spIter->Advance() );
        }
        pCmd->cmdf = (fNetAbsPos ? MSOCMDSTATE_DOWN : MSOCMDSTATE_UP) ;  
    }
            
Cleanup:
    return (S_OK);
}

////////////////////////////////////////////////////////////////////////////////
// CLiveResizeCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CLiveResizeCommand::PrivateExec( 
        DWORD        nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetLiveResize( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetLiveResize( ! GetCommandTarget()->IsLiveResize());
    }        
        
    return S_OK;
}

HRESULT 
CLiveResizeCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsLiveResize() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CDisalbeEditFocusHandlesCommand
////////////////////////////////////////////////////////////////////////////////
HRESULT 
CDisalbeEditFocusHandlesCommand::PrivateExec( 
            DWORD        nCmdexecopt,
            VARIANTARG * pvarargIn,
            VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetDisableEditFocusHandles( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetDisableEditFocusHandles( ! GetCommandTarget()->IsDisableEditFocusHandles());        
    }                

    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;

    IGNORE_HR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
        IGNORE_HR(spOleWindow->GetWindow( &myHwnd ));

    ::RedrawWindow( myHwnd ,NULL,NULL,RDW_UPDATENOW);
    
    return S_OK ;
}

HRESULT 
CDisalbeEditFocusHandlesCommand::PrivateQueryStatus( OLECMD * pcmd, OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsDisableEditFocusHandles() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CAtomicSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CAtomicSelectionCommand::PrivateExec( 
    DWORD        nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetAtomicSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else
    {
        GetCommandTarget()->SetAtomicSelection( ! GetCommandTarget()->IsAtomicSelection());
    }
    
    return S_OK ;
}

HRESULT 
CAtomicSelectionCommand::PrivateQueryStatus( 
     OLECMD     * pcmd,
     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsAtomicSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\edutil.cxx ===
//+---------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       EDUTIL.CXX
//
//  Contents:   Utility functions for CMsHtmled
//
//  History:    15-Jan-98   raminh  Created
//
//  Notes:      This file contains some utility functions from Trident,
//              such as LoadLibrary, which have been modified to eliminate
//              dependencies. In addition, it provides the implementation
//              for editing commands such as InsertObject etc.
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_EDEVENT_HXX_
#define X_EDEVENT_HXX_
#include "edevent.hxx"
#endif 

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

DYNLIB      g_dynlibSHDOCVW = { NULL, NULL, "SHDOCVW.DLL" }; // This line is required for linking with wrappers.lib

LCID        g_lcidUserDefault = 0;                           // Required for linking with formsary.obj

#if DBG == 1 && !defined(WIN16)
//
// Global vars for use by the DYNCAST macro
//
char g_achDynCastMsg[200];
char *g_pszDynMsg = "Invalid Static Cast -- Attempt to cast object "
                    "of type %s to type %s.";
char *g_pszDynMsg2 = "Dynamic Cast Attempted ---  "
                     "Attempt to cast between two base classes of %s. "
                     "The cast was to class %s from some other base class "
                     "pointer. This cast will not succeed in a retail build.";
#endif

static DYNLIB * s_pdynlibHead; // List used by LoadProcedure and DeiIntDynamic libraries

//
// Forward references
//
int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);

HRESULT GetLastWin32Error();

void DeinitDynamicLibraries();

HRESULT DoInsertObjectUI (HWND hwnd, DWORD * pdwResult, LPTSTR * pstrResult);

HRESULT CreateHtmlFromIDM (UINT cmd, LPTSTR pstrParam, LPTSTR pstrHtml);

//+------------------------------------------------------------------------
//
//  Function:   ReleaseInterface
//
//  Synopsis:   Releases an interface pointer if it is non-NULL
//
//  Arguments:  [pUnk]
//
//-------------------------------------------------------------------------

void
ReleaseInterface(IUnknown * pUnk)
{
    if (pUnk)
        pUnk->Release();
}


//+------------------------------------------------------------------------
//
//  Function:   edNlstrlenW
//
//  Synopsis:   This function takes a string and count the characters (WCHAR)
//              contained in that string until either NULL termination is
//              encountered or cchLimit is reached.
//
//  Returns:    Number of characters in pstrIn
//
//-------------------------------------------------------------------------
LONG
edNlstrlenW(LPWSTR pstrIn, LONG cchLimit )
{
    Assert(pstrIn);
    Assert(cchLimit >= 0);
    
    LONG cchCount = 0;
    while (*pstrIn && cchLimit)
    {
        cchCount ++;
        cchLimit --;
        ++pstrIn;
    }
    
    return cchCount;
}


//+------------------------------------------------------------------------
//
//  Function:   edWsprintf
//
//  Synopsis:   This function is a replacement for a simple version of sprintf.
//              Since using Format() links in a lot of extra code and since
//              wsprintf does not work under Win95, this simple alternative
//              is being used.
//
//  Returns:    Number of characters written to pstrOut
//
//-------------------------------------------------------------------------

int
edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam)
{
    TCHAR   *  pstrPercentS;
    ULONG      cLength;

    if (!pstrFormat)
        goto Cleanup;

    pstrPercentS = _tcsstr( pstrFormat, _T( "%s" ) );
    if (!pstrPercentS)
    {
        _tcscpy( pstrOut, pstrFormat );
    }
    else
    {
        if (!pstrParam)
            goto Cleanup;

        cLength = PTR_DIFF( pstrPercentS, pstrFormat );
        _tcsncpy( pstrOut, pstrFormat, cLength );
        pstrOut[ cLength ] = _T( '\0' );
        ++pstrPercentS; ++pstrPercentS; // Increment pstrPercentS passed "%s"
        _tcscat( pstrOut, pstrParam );
        _tcscat( pstrOut, pstrPercentS );
    }
    return _tcslen(pstrOut);
Cleanup:
    return 0;
}
//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error from misc.cxx
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
#ifdef WIN16
    return E_FAIL;
#else
    // Win 95 can return 0, even when there's an error.
    DWORD dw = GetLastError();
    return dw ? HRESULT_FROM_WIN32(dw) : E_FAIL;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   LoadProcedure
//
//  Synopsis:   Load library and get address of procedure.
//
//              Declare DYNLIB and DYNPROC globals describing the procedure.
//              Note that several DYNPROC structures can point to a single
//              DYNLIB structure.
//
//                  DYNLIB g_dynlibOLEDLG = { NULL, "OLEDLG.DLL" };
//                  DYNPROC g_dynprocOleUIInsertObjectA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };
//                  DYNPROC g_dynprocOleUIPasteSpecialA =
//                          { NULL, &g_dynlibOLEDLG, "OleUIPasteSpecialA" };
//
//              Call LoadProcedure to load the library and get the procedure
//              address.  LoadProcedure returns immediatly if the procedure
//              has already been loaded.
//
//                  hr = LoadProcedure(&g_dynprocOLEUIInsertObjectA);
//                  if (hr)
//                      goto Error;
//
//                  uiResult = (*(UINT (__stdcall *)(LPOLEUIINSERTOBJECTA))
//                      g_dynprocOLEUIInsertObjectA.pfn)(&ouiio);
//
//              Release the library at shutdown.
//
//                  void DllProcessDetach()
//                  {
//                      DeinitDynamicLibraries();
//                  }
//
//  Arguments:  pdynproc  Descrition of library and procedure to load.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
LoadProcedure(DYNPROC *pdynproc)
{
    HINSTANCE   hinst;
    DYNLIB *    pdynlib = pdynproc->pdynlib;
    DWORD       dwError;

    if (pdynproc->pfn && pdynlib->hinst)
        return S_OK;

    if (!pdynlib->hinst)
    {
        // Try to load the library using the normal mechanism.

        hinst = LoadLibraryA(pdynlib->achName);

#ifdef WINCE
        if (!hinst)
        {
            goto Error;
        }
#endif // WINCE
#ifdef WIN16
        if ( (UINT) hinst < 32 )
        {
            // jumping to error won't work,
            // since GetLastError is currently always 0.
            //goto Error;
            // instead, return a bogus (but non-zero) error code.
            // (What should we return? I got 0x7e on one test.)
            // --mblain27feb97
            RRETURN(hinst ? (DWORD) hinst : (DWORD) ~0);
        }
#endif // WIN16
#if !defined(WIN16) && !defined(WINCE)
        // If that failed because the module was not be found,
        // then try to find the module in the directory we were
        // loaded from.

        dwError = GetLastError();
        if (!hinst)
        {
            goto Error;
        }
#endif // !defined(WIN16) && !defined(WINCE)

        // Link into list for DeinitDynamicLibraries

        {
            if (pdynlib->hinst)
                FreeLibrary(hinst);
            else
            {
                pdynlib->hinst = hinst;
                pdynlib->pdynlibNext = s_pdynlibHead;
                s_pdynlibHead = pdynlib;
            }
        }
    }

    pdynproc->pfn = GetProcAddress(pdynlib->hinst, pdynproc->achName);
    if (!pdynproc->pfn)
    {
        goto Error;
    }

    return S_OK;

Error:
    RRETURN(GetLastWin32Error());
}



//+---------------------------------------------------------------------------
//
//  Function:   DeinitDynamicLibraries
//
//  Synopsis:   Undoes the work of LoadProcedure.
//
//----------------------------------------------------------------------------
void
DeinitDynamicLibraries()
{
    DYNLIB * pdynlib;

    for (pdynlib = s_pdynlibHead; pdynlib; pdynlib = pdynlib->pdynlibNext)
    {
        if (pdynlib->hinst)
        {
            FreeLibrary(pdynlib->hinst);
            pdynlib->hinst = NULL;
        }
    }
    s_pdynlibHead = NULL;
}

//
// EnumElements() and EnumVARIANT() are methods of CImplAry class that are
// implemented in cenum.cxx. MshtmlEd does not currently use these methods
// hence the stubs below are provided to avoid linking code unnecessarily.
// If these methods are ever used, MshtmlEd shall link with cenum.cxx.
//
//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumElements
//
//----------------------------------------------------------------------------
HRESULT
CImplAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CImplAry::EnumVARIANT
//
//----------------------------------------------------------------------------

HRESULT
CImplAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    return E_NOTIMPL;
}

//+------------------------------------------------------------------------
//
//  Function:   ReplaceInterfaceFn
//
//  Synopsis:   Replaces an interface pointer with a new interface,
//              following proper ref counting rules:
//
//              = *ppUnk is set to pUnk
//              = if *ppUnk was not NULL initially, it is Release'd
//              = if pUnk is not NULL, it is AddRef'd
//
//              Effectively, this allows pointer assignment for ref-counted
//              pointers.
//
//  Arguments:  [ppUnk]
//              [pUnk]
//
//-------------------------------------------------------------------------

void
ReplaceInterfaceFn(IUnknown ** ppUnk, IUnknown * pUnk)
{
    IUnknown * pUnkOld = *ppUnk;

    *ppUnk = pUnk;

    //  Note that we do AddRef before Release; this avoids
    //    accidentally destroying an object if this function
    //    is passed two aliases to it

    if (pUnk)
        pUnk->AddRef();

    if (pUnkOld)
        pUnkOld->Release();
}


//+------------------------------------------------------------------------
//
//  Function:   ClearInterfaceFn
//
//  Synopsis:   Sets an interface pointer to NULL, after first calling
//              Release if the pointer was not NULL initially
//
//  Arguments:  [ppUnk]     *ppUnk is cleared
//
//-------------------------------------------------------------------------

void
ClearInterfaceFn(IUnknown ** ppUnk)
{
    IUnknown * pUnk;

    pUnk = *ppUnk;
    *ppUnk = NULL;
    if (pUnk)
        pUnk->Release();
}

Direction 
Reverse( Direction iDir )
{
    if( iDir == LEFT )
        return RIGHT;
    else if (iDir == RIGHT)
        return LEFT;
    else
        return iDir;
}


//+===================================================================================
// Method:      MoveWord
//
// Synopsis:    Moves the pointer to the previous or next word. This method takes into
//              account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//+===================================================================================

HRESULT 
CHTMLEditor::MoveWord(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir)
{
    HRESULT hr = S_OK;
    
    if( eDir == LEFT )
        hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVWORDBEGIN ));
    else
        hr = THR( MoveUnit( pDispPointer,eDir, MOVEUNIT_NEXTWORDBEGIN ));

    RRETURN( hr );
}


//+===================================================================================
// Method:      MoveCharacter
//
// Synopsis:    Moves the pointer to the previous or next character. This method takes
//              into account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//+===================================================================================

HRESULT 
CHTMLEditor::MoveCharacter(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir)
{
    HRESULT hr = S_OK;
    BOOL fNearText = FALSE;
    CEditPointer tLooker(this);
    DWORD dwBreak = BREAK_CONDITION_OMIT_PHRASE-BREAK_CONDITION_Anchor;
    DWORD dwFound = BREAK_CONDITION_None;
    IFC( pDispPointer->PositionMarkupPointer(tLooker) );
    IFC( tLooker.Scan( eDir, dwBreak, &dwFound ));

    fNearText =  CheckFlag( dwFound, BREAK_CONDITION_Text );
    
    if( eDir == LEFT )
    {
        if( fNearText )
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVCLUSTERBEGIN ));
        }
        else
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_PREVCLUSTEREND ));
        }
    }
    else
    {
        if( fNearText )
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_NEXTCLUSTEREND ));
        }
        else
        {
            hr = THR( MoveUnit( pDispPointer, eDir, MOVEUNIT_NEXTCLUSTERBEGIN ));
        }
    }
Cleanup:
    RRETURN( hr );
}


//+===================================================================================
// Method:      MoveUnit
//
// Synopsis:    Moves the pointer to the previous or next character. This method takes
//              into account block and site ends.
//
// Parameters:  
//              eDir            [in]    Direction to move
//              pfNotAtBOL      [out]   What line is pointer on after move? (optional)
//              pfAtLogcialBOL  [out]   Is pointer at lbol after move? (otional)
//
//
//
//+===================================================================================

HRESULT 
CHTMLEditor::MoveUnit(
    IDisplayPointer         *pDispPointer, 
    Direction               eDir,
    MOVEUNIT_ACTION         eUnit )
{
    HRESULT hr = S_OK;
    BOOL fBeyondThisLine;
    BOOL fAtEdgeOfLine;
    BOOL fThereIsAnotherLine = FALSE;
    BOOL fBeyondNextLine = FALSE;
    BOOL fLineBreakDueToTextWrapping = FALSE;
    BOOL fHackedLineBreak = FALSE;
    DWORD dwBreak = BREAK_CONDITION_Site | BREAK_CONDITION_NoScopeSite | BREAK_CONDITION_Control;
    DWORD dwFound = BREAK_CONDITION_None;
    SP_IHTMLElement spSite;
    CEditPointer epDestination(this);
    CEditPointer epBoundary(this);
    CEditPointer epNextLine(this);
    CEditPointer epWalker(this);
    SP_IDisplayPointer spDispPointer;

    IFC( pDispPointer->PositionMarkupPointer(epDestination) );
    IFC( pDispPointer->PositionMarkupPointer(epNextLine) );
    IFC( pDispPointer->PositionMarkupPointer(epWalker) );
    IFC( pDispPointer->PositionMarkupPointer(epBoundary) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

    IFC( epDestination->MoveUnit( eUnit ));

    if( eDir == LEFT )
    {
        DWORD dwIgnore = BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor | BREAK_CONDITION_NoLayoutSpan;
        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        IFC( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
        IFC( spDispPointer->PositionMarkupPointer(epBoundary) );

        fLineBreakDueToTextWrapping = TRUE;

        hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_PreviousLine, -1) );
        if (SUCCEEDED(hr))
        {
            hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
            if (SUCCEEDED(hr))
            {
                fThereIsAnotherLine = TRUE;
                IFC( spDispPointer->PositionMarkupPointer(epNextLine) );
                IFC( AdjustOut(epNextLine, RIGHT) );
                {
                    // 
                    // HACKHACK: To fix bug #98353, we need to make sure epNextLine 
                    // does not go beyond this line. AdjustOut is very buggy but 
                    // we don't want to make a big modification as of now. So we do
                    // a little hacking here.   [zhenbinx]
                    //
                    SP_IDisplayPointer  spDispAdjusted;
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                    if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epNextLine, spDispPointer))
                    {
                        CEditPointer  epScan(this);
                        DWORD         dwScanFound;

                        epScan->MoveToPointer(epNextLine);
                        epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epNextLine->MoveToPointer(epScan);
                    }
                }
                IFC( epDestination->IsLeftOf( epNextLine, &fBeyondNextLine ));
            }
        }

        //
        // HACKHACK: When glyph is turned on, we use the non-adjusted line start instead
        // of adjusted line start for epBoundary. So we need to handle it specially.
        //
        if (!_fIgnoreGlyphs)
        {
            DWORD           dwLBSearch = BREAK_CONDITION_Content;
            DWORD           dwLBFound;
            CEditPointer    epLBScan(this);
            IFC( epLBScan->MoveToPointer(epBoundary) );
            IFC( epLBScan.Scan(LEFT, dwLBSearch, &dwLBFound) );
            if (               
                (CheckFlag(dwLBFound, BREAK_CONDITION_EnterBlock) && CheckFlag(dwLBFound, BREAK_CONDITION_EnterSite))
               )
            {
                //
                // HACKHACK: 
                // since we use non-adjusted line start. We need 
                // to hack this to FALSE. 
                // 
                fLineBreakDueToTextWrapping = FALSE;
                fHackedLineBreak = TRUE;
            }
        }

        if (!fHackedLineBreak)
        {
            // If the current line start and previous line end are the same point 
            // in the markup, we are breaking the line due to wrapping
            IFC( epNextLine->IsEqualTo( epBoundary, &fLineBreakDueToTextWrapping ));
        }
        IFC( epDestination->IsLeftOf( epBoundary, &fBeyondThisLine ));
        IFC( epWalker.IsLeftOfOrEqualTo( epBoundary, dwIgnore, &fAtEdgeOfLine ));
        if (!_fIgnoreGlyphs)
        {
            //
            // IEV6-6553-2000/08/08/-zhenbinx 
            // some positions are not valid even if glyph is turned on. 
            // This is because the caret is considered to be "valid
            // for input". To maintain this assumption, Some glyphs
            // should be ingored since inserting text into such position
            // would have resulted in incorrect HTML.
            // We should have a better glyph story in the future.
            //
            SP_IHTMLElement spIElem;
            ELEMENT_TAG_ID  eTag;

            IFC( CurrentScopeOrMaster(epWalker, &spIElem) );
            IFC( GetMarkupServices()->GetElementTagId(spIElem, & eTag) );
            if (EdUtil::IsListItem(eTag))  // add more invalid positions here...
            {
                //
                // In theory, this could have skipped over too much 
                // however LI is not surround by any element in normal cases
                //
                DWORD dwAdjustedIgnore = dwIgnore|BREAK_CONDITION_Glyph|BREAK_CONDITION_Block;
                IFC( epWalker.IsLeftOfOrEqualTo(epBoundary, dwAdjustedIgnore, &fAtEdgeOfLine) );
            }
        }
    }
    else
    {
        DWORD dwIgnore = BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor | BREAK_CONDITION_NoScope | BREAK_CONDITION_NoLayoutSpan;
        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        IFC( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
        IFC( spDispPointer->PositionMarkupPointer(epBoundary) );

        fLineBreakDueToTextWrapping = TRUE;

        IFC( spDispPointer->MoveToPointer(pDispPointer) );
        hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_NextLine, -1) );
        if (SUCCEEDED(hr))
        {
            hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
            if (SUCCEEDED(hr))
            {
                fThereIsAnotherLine = TRUE;
                IFC( spDispPointer->PositionMarkupPointer(epNextLine) );
                IFC( AdjustOut(epNextLine, LEFT) );
                {
                    // 
                    // HACKHACK: To fix bug #108383, we need to make sure epNextLine 
                    // does not go beyond this line. AdjustOut is very buggy but 
                    // we don't want to make a big modification as of now. So we do
                    // a little hacking here.   [zhenbinx]
                    //
                    SP_IDisplayPointer  spDispAdjusted;
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                    if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epNextLine, spDispPointer))
                    {
                        CEditPointer  epScan(this);
                        DWORD         dwScanFound;

                        epScan->MoveToPointer(epNextLine);
                        epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                        epNextLine->MoveToPointer(epScan);
                    }
                }
                IFC( epDestination->IsRightOf( epNextLine, &fBeyondNextLine ));
            }
        }

        //
        // HACKHACK: When glyph is turned on, we use the non-adjusted line end instead
        // of adjusted line end for epBoundary. So we need to handle it specially.
        //
        if (!_fIgnoreGlyphs)
        {
            DWORD           dwLBSearch = BREAK_CONDITION_Content;
            DWORD           dwLBFound;
            CEditPointer    epLBScan(this);
            IFC( epLBScan->MoveToPointer(epBoundary) );
            IFC( epLBScan.Scan(RIGHT, dwLBSearch, &dwLBFound) );
            if (                
                (CheckFlag(dwLBFound, BREAK_CONDITION_EnterBlock) && CheckFlag(dwLBFound, BREAK_CONDITION_EnterSite))
               )
            {   
                //
                // HACKHACK: 
                // We have a block and a glyph right before it
                // since we use non-adjusted line end. We need 
                // to hack this to FALSE. 
                // 
                fLineBreakDueToTextWrapping = FALSE;
                fHackedLineBreak = TRUE;
            }
        }

        if (!fHackedLineBreak)
        {
            // If the current line END and next line START are the same point 
            // in the markup, we are breaking the line due to wrapping
            IFC( epNextLine->IsEqualTo( epBoundary, &fLineBreakDueToTextWrapping )); 
        }
        IFC( epDestination->IsRightOf( epBoundary, &fBeyondThisLine ));
        IFC( epWalker.IsRightOfOrEqualTo( epBoundary, dwIgnore, &fAtEdgeOfLine ));
    }

    //
    // If I'm not at the edge of the line, my destination is the edge of the line.
    //
    
    if( ! fAtEdgeOfLine && fBeyondThisLine )
    {
        IFC( epDestination->MoveToPointer( epBoundary ));
    }

    //
    // If I am at the edge of the line and there is another line, and my destination
    // is beyond that line - my destination is that line.
    //

    if( fAtEdgeOfLine && fBeyondThisLine && fBeyondNextLine && ! fLineBreakDueToTextWrapping )
    {
        // we are at the edge of the line and our destination is beyond the next line boundary
        // so move our destination to that line boundary.
        IFC( epDestination->MoveToPointer( epNextLine ));
    }

    //
    // Scan towards my destination. If I hit a site boundary, move to the other
    // side of it and be done. Otherwise, move to the next line.
    //
    
    IFC( epWalker.SetBoundaryForDirection( eDir, epDestination ));
    hr = THR( epWalker.Scan( eDir, dwBreak, &dwFound, &spSite ));

    if( CheckFlag( dwFound, BREAK_CONDITION_NoScopeSite ) ||
        CheckFlag( dwFound, BREAK_CONDITION_EnterControl ))
    {
        IFC( epWalker->MoveAdjacentToElement( spSite , eDir == LEFT ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd ));
        goto CalcBOL;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_ExitControl ))
    {
        // do not move at all
        goto Cleanup;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_Site ))
    {
        ELEMENT_TAG_ID tagId;

        IFC( GetMarkupServices()->GetElementTagId(spSite, &tagId) );
        if (tagId == TAGID_BODY)
            goto Cleanup; // don't exit the body

        IFC( EnterTables(epWalker, eDir) );
        // move wherever scan put us...
        if( eDir == LEFT )
        {
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );            
        }
        else
        {
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );            
        }

        goto Done;
    }
    else if( CheckFlag( dwFound, BREAK_CONDITION_Boundary ))
    {
        // No site transitions between here and our destination.

        if( fBeyondThisLine && fAtEdgeOfLine && ! fLineBreakDueToTextWrapping )
        {

            // If our destination pointer is on another line than our start pointer...
            IFC( spDispPointer->MoveToPointer(pDispPointer) );
            if( eDir == LEFT )
            {
                hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_PreviousLine, -1) );
                if (SUCCEEDED(hr))
                {
                    hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );
                    if (SUCCEEDED(hr))
                    {
                        IFC( spDispPointer->PositionMarkupPointer(epWalker) );
                        IFC( AdjustOut(epWalker, RIGHT) );
                        {
                            // 
                            // HACKHACK: To fix bug #98353, we need to make sure epNextLine 
                            // does not go beyond this line. AdjustOut is very buggy but 
                            // we don't want to make a big modification as of now. So we do
                            // a little hacking here.   [zhenbinx]
                            //
                            SP_IDisplayPointer  spDispAdjusted;
                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                            if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epWalker, spDispPointer) )
                            {
                                CEditPointer  epScan(this);
                                DWORD         dwScanFound;

                                epScan->MoveToPointer(epWalker);
                                epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epWalker->MoveToPointer(epScan);
                            }
                        }
                        IFC( EnterTables(epWalker, LEFT) );
                        IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );
                        {
                            //
                            // HACKHACK:
                            //
                            // We might just moved into an empty line!!! 
                            // Consider the case of "\r\rA" where we are moving 
                            // from between '\r' and 'A' to between two '\r's, 
                            //
                            // In this case CurrentLineEnd will be before the 2nd 
                            // 'r' !!! (this is our current design)!!!!!!!!!!
                            //
                            // We are moving into an ambigious position at an 
                            // empty line. Do not set display gravity to PreviousLine 
                            // in this case! Note in this case fLineBreakDueToTextWrapping 
                            // is set to FALSE
                            //
                            // [zhenbinx]                            
                            //
                            CEditPointer    epScan(this);
                            DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
                            DWORD dwScanFound  = BREAK_CONDITION_None;
                            WCHAR wch;
            
                            IFC( pDispPointer->PositionMarkupPointer(epScan) );
                            IFC( epScan.Scan(RIGHT, dwSearch, &dwScanFound, NULL, NULL, &wch) );

                            if (CheckFlag(dwScanFound, BREAK_CONDITION_NoScopeBlock) && wch == L'\r')
                            {
                                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                            }
                            else
                            {
                                IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                            }
                        }
                    }
                }
            }
            else
            {
                hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_NextLine, -1) );
                if (SUCCEEDED(hr))
                {
                    hr = THR( spDispPointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );
                    if (SUCCEEDED(hr))
                    {
                        IFC( spDispPointer->PositionMarkupPointer(epWalker) );
                        IFC( AdjustOut(epWalker, LEFT) );
                        {
                            // 
                            // HACKHACK: To fix bug #108383, we need to make sure epNextLine 
                            // does not go beyond this line. AdjustOut is very buggy but 
                            // we don't want to make a big modification as of now. So we do
                            // a little hacking here.   [zhenbinx]
                            //
                            SP_IDisplayPointer  spDispAdjusted;
                            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispAdjusted) );
                            if (S_FALSE == spDispAdjusted->MoveToMarkupPointer(epWalker, spDispPointer) )
                            {
                                CEditPointer  epScan(this);
                                DWORD         dwScanFound;

                                epScan->MoveToPointer(epWalker);
                                epScan.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epScan.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwScanFound);
                                epWalker->MoveToPointer(epScan);
                            }
                        }
                        IFC( EnterTables(epWalker, RIGHT) );
                        IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );
                        IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                   }
                }
            }
            goto Cleanup;
        }
        else
        {
            // We started and ended on same line with no little stops along the way - move to destination...
            
            IFC( epWalker->MoveToPointer( epDestination ));
        }
    }
    else
    {
        // we hit some sort of error, go to cleanup
        hr = E_FAIL;
        goto Cleanup;
    }

CalcBOL:

    //
    // Fix up fNotAtBOL - if the cp we are at is between lines, we should
    // always be at the beginning of the line. One exception - if we are to the 
    // left of a layout, we should render on the previous line. If we are to the
    // right of a layout, we should render on the next line.
    //

    {
        CEditPointer tPointer( this );
        BOOL fAtNextLineFuzzy = FALSE;
        DWORD dwScanBreak = BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor;
        DWORD dwScanFound = BREAK_CONDITION_None;
        IFC( tPointer.MoveToPointer( epWalker ));
        IFC( tPointer.Scan( RIGHT, dwScanBreak, &dwScanFound ));

        if( fThereIsAnotherLine )
            IFC( tPointer.IsEqualTo( epNextLine, BREAK_CONDITION_Phrase | BREAK_CONDITION_Anchor, & fAtNextLineFuzzy ));

        if( ! CheckFlag( dwScanFound, BREAK_CONDITION_Site ) &&
            ! fAtNextLineFuzzy )
        {
            // No site to the right of me and I'm not right next to the next line, 
            // render at the bol.
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        }
        else
        {
            // there was a site to my right - render at the end of the line
            IFC( pDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        }
    }

Done:
    IFC( pDispPointer->MoveToMarkupPointer(epWalker, NULL) );

Cleanup:
    
    RRETURN( hr );

}


//
// General markup services helpers
//

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::CSegmentListIter
//  Synopsis:   ctor
//-----------------------------------------------------------------------------

CSegmentListIter::CSegmentListIter()
{
    _pLeft = _pRight = NULL;
    _pSegmentList    = NULL;
    _pIter = NULL;
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::CSegmentListIter
//  Synopsis:   dtor
//-----------------------------------------------------------------------------

CSegmentListIter::~CSegmentListIter()
{
    ReleaseInterface(_pLeft);
    ReleaseInterface(_pRight);
    ReleaseInterface(_pSegmentList);
    ReleaseInterface(_pIter);
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::Init
//  Synopsis:   init method
//-----------------------------------------------------------------------------
HRESULT CSegmentListIter::Init(CEditorDoc *pEditorDoc, ISegmentList *pSegmentList)
{
    HRESULT hr;

    //
    // Set up pointers
    //
    ReleaseInterface(_pLeft);
    ReleaseInterface(_pRight);
    ReleaseInterface(_pSegmentList);
    ReleaseInterface(_pIter);
    
    IFC( pSegmentList->CreateIterator(&_pIter) );
    
    hr = THR(CreateMarkupPointer2(pEditorDoc, &_pLeft));
    if (FAILED(hr))
        goto Cleanup;

    hr = THR(CreateMarkupPointer2(pEditorDoc, &_pRight));
    if (FAILED(hr))
        goto Cleanup;

    // Cache segment list
    _pSegmentList = pSegmentList;
    _pSegmentList->AddRef();

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//  Method:     CSegmentListIter::Next
//  Synopsis:   Move pointers to next segment.
//              Returns S_FALSE if last segment
//-----------------------------------------------------------------------------

HRESULT CSegmentListIter::Next(IMarkupPointer **ppLeft, IMarkupPointer **ppRight)
{
    SP_ISegment spSegment;
    HRESULT     hr;

    //
    // Advance to next segment
    //
    if( _pIter->IsDone() == S_FALSE )
    {
        IFC( _pIter->Current(&spSegment) );

        IFC( spSegment->GetPointers( _pLeft, _pRight ) );
        *ppLeft = _pLeft;
        *ppRight = _pRight;

        IFC( _pIter->Advance() );
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Add
//  Synopsis:   Add an element to the break container
//-----------------------------------------------------------------------------
VOID CBreakContainer::Set(ELEMENT_TAG_ID tagId, Mask mask)
{
    if (mask & BreakOnStart)
        bitFieldStart.Set(tagId);
    else
        bitFieldStart.Clear(tagId);

    if (mask & BreakOnEnd)
        bitFieldEnd.Set(tagId);
    else
        bitFieldEnd.Clear(tagId);
}

//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Test
//  Synopsis:   Tests an element in the break container
//-----------------------------------------------------------------------------
VOID CBreakContainer::Clear(ELEMENT_TAG_ID tagId, Mask mask)
{
    if (mask & BreakOnStart)
        bitFieldStart.Clear(tagId);

    if (mask & BreakOnEnd)
        bitFieldEnd.Clear(tagId);
}

//+----------------------------------------------------------------------------
//  Method:     CBreakContainer::Clear
//  Synopsis:   Clears an element in the break container
//-----------------------------------------------------------------------------
BOOL CBreakContainer::Test(ELEMENT_TAG_ID tagId, Mask mask)
{
    BOOL bResult = FALSE;

    switch (mask)
    {
    case BreakOnStart:
        bResult = bitFieldStart.Test(tagId);
        break;

    case BreakOnEnd:
        bResult = bitFieldEnd.Test(tagId);
        break;

    case BreakOnBoth:
        bResult = bitFieldStart.Test(tagId) && bitFieldEnd.Test(tagId) ;
        break;
    }

    return bResult;
}

#if DBG==1
void
AssertPositioned(IMarkupPointer *pPointer)
{
    HRESULT hr;
    BOOL    fIsPositioned;

    hr = pPointer->IsPositioned(&fIsPositioned);
    Assert(hr == S_OK);
    Assert(fIsPositioned);
}
#endif


HRESULT 
MshtmledUtil::GetEditResourceLibrary(
    HINSTANCE   *hResourceLibrary)
{    
    if (!g_hEditLibInstance)
    {
        g_hEditLibInstance = MLLoadLibrary(_T("mshtmler.dll"), g_hInstance, ML_CROSSCODEPAGE);
    }
    *hResourceLibrary = g_hEditLibInstance;

    if (!g_hEditLibInstance)
        return E_FAIL; // TODO: can we convert GetLastError() to an HRESULT?

    return S_OK;
}

//+---------------------------------------------------------------------------+
//
//           
// Currently only deal with writing-mode: tb-rl
//
//  styleWritingMode
//      styleWritingModeLrtb
//      styleWritingModeTbrl
//      styleWritingModeNotSet
//
//
//+---------------------------------------------------------------------------+
HRESULT
MshtmledUtil::IsElementInVerticalLayout(IHTMLElement *pElement,
                                         BOOL *fRet
                                         )
{
    HRESULT                 hr = S_OK;
    SP_IHTMLElement2        spElem2;
    SP_IHTMLCurrentStyle    spStyle;
    SP_IHTMLCurrentStyle2   spStyle2;
    BSTR                    bstrWritingMode=NULL;

    Assert( pElement );
    Assert( fRet );
    
    IFC( pElement->QueryInterface(IID_IHTMLElement2, reinterpret_cast<LPVOID *>(&spElem2)) );
    IFC( spElem2->get_currentStyle(&spStyle) );

    if (!spStyle) 
        goto Cleanup;

    IFC( spStyle->QueryInterface(IID_IHTMLCurrentStyle2, reinterpret_cast<LPVOID *>(&spStyle2)) );
    IFC( spStyle2->get_writingMode(&bstrWritingMode) );
    //
    // TODO: Should not hard-code strings however cannot find a way around!
    //
    *fRet = bstrWritingMode && !_tcscmp(bstrWritingMode, _T("tb-rl"));


Cleanup:
    ::SysFreeString(bstrWritingMode);
    RRETURN(hr);
}


//
// Synoposis:   This function moves the markuppointer according to editing rules. 
//              It manipulates the markup pointer according to the visual box tree
//
//
HRESULT 
MshtmledUtil::MoveMarkupPointerToBlockLimit(
            CHTMLEditor        *pEditor,
            Direction          direction,       // LEFT -- START of BLOCK   RIGHT -- END of BLOCK
            IMarkupPointer     *pMarkupPointer,
            ELEMENT_ADJACENCY  elemAdj
            )
{
    Assert( pEditor );
    Assert( pMarkupPointer );

    
    HRESULT             hr = S_OK;
    CBlockPointer       bpStBlock(pEditor);
    CBlockPointer       bpEndBlock(pEditor);
    CBlockPointer       bpWkBlock(pEditor);
    BOOL                fEmpty;

    IFC( bpStBlock.MoveTo(pMarkupPointer, direction) );
    IFC( bpStBlock.IsEmpty(&fEmpty) );
    if (!fEmpty) 
    {
        IFC( bpStBlock.MoveToFirstNodeInBlock() );              
    }

    if (LEFT == direction)
    {
        IFC( bpStBlock.MovePointerTo(pMarkupPointer, elemAdj) );
        goto Cleanup;
    }

    // 
    // Fall through -- RIGHT == direction
    //
    IFC( bpWkBlock.MoveTo(&bpStBlock) );
    if (!fEmpty)
    {
        IFC( bpWkBlock.MoveToLastNodeInBlock() );
    }

    IFC( bpEndBlock.MoveTo(&bpWkBlock) );

	if (ELEM_ADJ_AfterEnd == elemAdj)
	{
	    if (S_FALSE == bpEndBlock.MoveToSibling(RIGHT))
	    {
	        if (bpEndBlock.IsLeafNode())
	        {
	            IFC( bpEndBlock.MoveToParent() );
	        }
	    }
	    IFC( bpEndBlock.MovePointerTo(pMarkupPointer, ELEM_ADJ_AfterEnd) );
    }
    else
    {
    	Assert( ELEM_ADJ_BeforeEnd == elemAdj );
        IFC( bpEndBlock.MovePointerTo(pMarkupPointer, ELEM_ADJ_BeforeEnd) );
    }

Cleanup:
    RRETURN(hr);
}


//
// CEdUndoHelper helper
//

CEdUndoHelper::CEdUndoHelper(CHTMLEditor *pEd) 
{
    _pEd= pEd; 
    _fOpen = FALSE;
}

CEdUndoHelper::~CEdUndoHelper() 
{
    if (_fOpen)
        IGNORE_HR(_pEd->GetUndoManagerHelper()->EndUndoUnit());
}

HRESULT 
CEdUndoHelper::Begin(UINT uiStringId, CBatchParentUndoUnit *pBatchPUU)
{
    HRESULT hr;

    Assert(!_fOpen);

    hr = THR(_pEd->GetUndoManagerHelper()->BeginUndoUnit(uiStringId, pBatchPUU));

    _fOpen = SUCCEEDED(hr);

    RRETURN(hr);
}

//
// CStringCache
//

CStringCache::CStringCache(UINT uiStart, UINT uiEnd)
{
    _uiStart = uiStart;
    _uiEnd = uiEnd;
    _pCache = new CacheEntry[_uiEnd - _uiStart + 1];
    
    if (_pCache)
    {
        for (UINT i = 0; i < (_uiEnd - _uiStart + 1); i++)
        {
            _pCache[i].pchString = NULL;
        }
    }
}

CStringCache::~CStringCache()
{
    for (UINT i = 0; i < (_uiEnd - _uiStart + 1); i++)
    {
        delete [] _pCache[i].pchString;
    }
    delete [] _pCache;
}

TCHAR *
CStringCache::GetString(UINT uiStringId)
{
    HRESULT     hr;
    CacheEntry  *pEntry;
    HINSTANCE   hinstEditResDLL;
    INT         iResult;
    const int   iBufferSize = 1024;
    
    Assert(_pCache);
    if (!_pCache || uiStringId < _uiStart || uiStringId > _uiEnd)
        return NULL; // error

    pEntry = &_pCache[uiStringId - _uiStart];    
    
    if (pEntry->pchString == NULL)
    {
        TCHAR pchBuffer[iBufferSize];
        
        IFC( MshtmledUtil::GetEditResourceLibrary(&hinstEditResDLL) );
        pchBuffer[iBufferSize-1] = 0;  // so we are always 0 terminated
        iResult = LoadString( hinstEditResDLL, uiStringId, pchBuffer, ARRAY_SIZE(pchBuffer)-1 );
        if (!iResult)
            goto Cleanup;

        pEntry->pchString = new TCHAR[_tcslen(pchBuffer)+1];
        if (pEntry->pchString)
            StrCpy(pEntry->pchString, pchBuffer);         
    }

    return pEntry->pchString;

Cleanup:
    return NULL;
}


        
#if DBG==1
//
// Debugging aid - this little hack lets us look at the CElement from inside the debugger.
//

#include <initguid.h>
DEFINE_GUID(CLSID_CElement,   0x3050f233, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEBUG_HELPER CElement *_(IHTMLElement *pIElement)
{
    CElement *pElement = NULL;

    pIElement->QueryInterface(CLSID_CElement, (LPVOID *)&pElement);
    
    return pElement;
}

//
// Helpers to dump the tree
//

DEBUG_HELPER VOID
dt(IUnknown* pUnknown)
{
    IOleCommandTarget *pCmdTarget = NULL;
    IMarkupPointer    *pMarkupPointer = NULL;

    if (SUCCEEDED(pUnknown->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
    {
        IGNORE_HR(pCmdTarget->Exec( &CGID_MSHTML, IDM_DEBUG_DUMPTREE, 0, NULL, NULL));
        ReleaseInterface(pCmdTarget);
    }
    else if (SUCCEEDED(pUnknown->QueryInterface(IID_IMarkupPointer, (LPVOID *)&pMarkupPointer)))
    {
        IMarkupContainer *pContainer = NULL;
        
        if (SUCCEEDED(pMarkupPointer->GetContainer(&pContainer)))
        {
            dt(pContainer);
            ReleaseInterface(pContainer);
        }
        ReleaseInterface(pMarkupPointer);
    }

}

DEBUG_HELPER VOID
dt(SP_IMarkupPointer &spPointer)
{
    dt(spPointer.p);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\htmled.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       htmled.cxx
//
//  Contents:   Implementation of IHTMLEditor interface inisde of mshtmled.dll
//
//  Classes:    CHTMLEditor
//
//  History:    07-21-98 - johnbed - created
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_PASTECMD_HXX_
#define _X_PASTECMD_HXX_
#include "pastecmd.hxx"
#endif

#ifndef _X_COPYCMD_HXX_
#define _X_COPYCMD_HXX_
#include "copycmd.hxx"
#endif

#ifndef _X_CUTCMD_HXX_
#define _X_CUTCMD_HXX_
#include "cutcmd.hxx"
#endif

#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_SELCMD_HXX_
#define _X_SELCMD_HXX_
#include "selcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef X_FORMCMD_HXX_
#define X_FORMCMD_HXX_
#include "formcmd.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_DIMM_HXX_
#define X_DIMM_HXX_
#include "dimm.h"
#endif

#ifndef _X_INPUTTXT_H_ // For IHTMLInputElement
#define _X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_IMEDESGN_HXX_
#define _X_IMEDESGN_HXX_
#include "imedesgn.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_TEXTAREA_H_
#define X_TEXTAREA_H_
#include "textarea.h"
#endif

#ifndef _X_RTFTOHTM_H_
#define _X_RTFTOHTM_H_
#include "rtftohtm.hxx"
#endif

#ifndef _X_IME_HXX_
#define _X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_FRMSITE_H_
#define _X_FRMSITE_H_
#include "frmsite.h"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#define SID_SHTMLEditHost     IID_IHTMLEditHost

DeclareTag(tagIE50Paste, "Edit", "IE50 compatible paste")

#if DBG == 1
#define HTMLED_PTR( name ) CEditPointer name( this, NULL, _T(#name) )
#else
#define HTMLED_PTR( name ) CEditPointer name( this, NULL )
#endif

using namespace EdUtil;

class CSpringLoader;

MtDefine(CHTMLEditor, Utilities, "HTML Editor")
MtDefine(CHTMLEditor_pComposeSettings, CHTMLEditor, "CHTMLEditor::_pComposeSettings")
MtDefine(CHTMLEditor_aryDesigners_pv, CHTMLEditor, "CHTMLEditor::_aryDesigners::_pv");
MtDefine(CHTMLEditor_aryActiveCmdTargets_pv, CHTMLEditor, "CHTMLEditor::_aryEditInfo::_pv");
MtDefine(CHTMLEditor_aryCmdTargetStack_pv, CHTMLEditor, "CHTMLEditor::_aryCmdTargetStack::_pv");

DeclareTag(tagEditingTrackExecFailures, "Edit", "Track exec failures")
DeclareTag(tagEditingExecRouting, "Edit", "Track Editing Exec Routing")
DeclareTag(tagEditingKeyProcessing, "Edit", "Track Key Event for Editing")
DeclareTag(tagEditingInterface, "Edit", "Track Editing Inteface calls")

extern "C" const IID IID_IHTMLEditorViewManager;
extern "C" const IID SID_SHTMLEditorViewManager;
extern BOOL g_fInVid;

#ifndef NO_IME
extern CRITICAL_SECTION g_csActiveIMM ; 
extern int g_cRefActiveIMM ;  
extern IActiveIMMApp * g_pActiveIMM;
#endif

extern BOOL g_fInPhotoSuiteIII;
extern "C" const IID IID_IHTMLDialog;

extern HRESULT
ConvertPointerToInternal(CEditorDoc* pDoc, IMarkupPointer *pPointer, IMarkupPointer **ppInternal);

extern HRESULT
OldCompare( IMarkupPointer * p1, IMarkupPointer * p2, int * pi );

HRESULT
CHTMLEditor::OldDispCompare(IDisplayPointer* pDisp1, IDisplayPointer* pDisp2, int * pi )
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pi);

    IFC( pDisp1->IsEqualTo(pDisp2, &fResult) );
    if (fResult)
    {
        *pi = 0;
        goto Cleanup;
    }
    
    IFC( pDisp1->IsLeftOf(pDisp2, &fResult)  );

    *pi = fResult ? -1 : 1;

Cleanup:
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor Constructor, Destructor and Initialization
//////////////////////////////////////////////////////////////////////////////////

CHTMLEditor::CHTMLEditor() : _aryDesigners(Mt(CHTMLEditor_aryDesigners_pv)), 
                            _aryActiveCmdTargets(Mt(CHTMLEditor_aryActiveCmdTargets_pv)),
                            _aryCmdTargetStack(Mt(CHTMLEditor_aryCmdTargetStack_pv))
{
    Assert( _pDoc == NULL );
    Assert( _pUnkDoc == NULL );
    Assert( _pUnkContainer == NULL );
    Assert( _pMarkupServices == NULL );
    Assert( _pDisplayServices == NULL );
    Assert( _pComposeSettings == NULL);
    Assert( _pSelMan == NULL );
    Assert( _fGotActiveIMM == FALSE ) ;
    Assert( _pStringCache == NULL );    
    Assert( _pISelectionServices == NULL );
    Assert( _pIHTMLEditHost == NULL );
    Assert( _pIHTMLEditHost2 == NULL );
    Assert( _pActiveCommandTarget == NULL );
    Assert( _pDispOnDblClkTimer == NULL );
    Assert( _pCaptureHandler == NULL );
    Assert( _dwEventCacheCounter == NULL );
}

CHTMLEditor::~CHTMLEditor()
{   
    Assert( _aryCmdTargetStack.Size() == 0 );
    
    DeleteCommandTable();

    //  We need to make sure our tracker is torn down first before we destroy our editor
    if (_pSelMan && _pSelMan->GetActiveTracker())
    {
        IGNORE_HR( _pSelMan->GetActiveTracker()->BecomeDormant(NULL, TRACKER_TYPE_None, NULL) );
    }
    if (_pSelMan)
    {
        _pSelMan->Passivate(TRUE /* fEditorReleased */);
        ReleaseInterface( _pSelMan );
    }

    delete _pComposeSettings;
    delete _pStringCache;
    delete _pAutoUrlDetector;
    delete _pUndoManagerHelper;

    _aryDesigners.ReleaseAll();

    ReleaseInterface( _pDoc );
    _pDoc = NULL;

    ReleaseInterface( _pTopDoc );
    _pTopDoc = NULL;

    ReleaseInterface( _pMarkupServices );
    _pMarkupServices = NULL;
 
    ClearInterface( &_pDisplayServices );

    ClearInterface( & _pISelectionServices );
    ClearInterface( & _pICaptureElement);
#if DBG == 1
    ReleaseInterface( _pEditDebugServices );
    _pEditDebugServices = NULL;
#endif
    if (g_hEditLibInstance)
    {
        FreeLibrary(g_hEditLibInstance);
        g_hEditLibInstance = NULL;
    }

#ifndef NO_IME
    if (_fGotActiveIMM)
    {
        EnterCriticalSection(&g_csActiveIMM);
        Assert(g_cRefActiveIMM > 0);
        Assert(g_pActiveIMM != NULL);
        if (--g_cRefActiveIMM == 0)
            ClearInterface(&g_pActiveIMM);

        LeaveCriticalSection(&g_csActiveIMM);
    }
#endif

    ReleaseInterface(_pIHTMLEditHost);
    ReleaseInterface(_pIHTMLEditHost2);
    ReleaseInterface(_pHighlightServices);

    IGNORE_HR( ClearCommandTargets() );

    if ( _pDispOnDblClkTimer )
    {
        _pDispOnDblClkTimer->SetEditor(NULL);
        ReleaseInterface( _pDispOnDblClkTimer );
    }
    if (_pCaptureHandler )
    {    
        _pCaptureHandler->SetEditor(NULL);
        ReleaseInterface( _pCaptureHandler );
    }
    
    Assert( ! _pICaptureElement ); // must get released by trackers/selman

}

//+========================================================================
//
// Method: Initialize
//
// Synopsis: Set the Document's interfaces for this instance of HTMLEditor
//           Called from Formkrnl when it CoCreates us.
//
//           We are actually passed a COmDocument, which uses weak ref's for
//           the interfaces we are QIing for. If we need to add an interface
//           in the future, make sure you add it to COmDocument (omdoc.cxx)
//           QueryInterface
//
//-------------------------------------------------------------------------

HRESULT
CHTMLEditor::Initialize( IUnknown * pUnkDoc, IUnknown * pUnkContainer )
{
    HRESULT             hr;
    SP_IServiceProvider spSP;
    SP_IHTMLWindow2 spWindow2;
    SP_IHTMLScreen  spScreen;
    SP_IHTMLScreen2  spScreen2;

    IServiceProvider    *pDocServiceProvider = NULL;
    CIMEManager         *pIMEMgr = NULL;
    SP_IMarkupContainer spContainer;
    IUnknown *          pIHTMLEditorViewManager = NULL ;

    Assert( pUnkDoc );
    Assert( pUnkContainer );
    _pUnkDoc = pUnkDoc;
    _pUnkContainer = pUnkContainer;

    IFC( _pUnkDoc->QueryInterface( IID_IHTMLDocument2 , (void **) &_pTopDoc ));
    IFC( _pUnkDoc->QueryInterface( IID_IHTMLDocument2 , (void **) &_pDoc ));
    IFC( _pUnkDoc->QueryInterface( IID_IMarkupServices2 , (void **) &_pMarkupServices ));
    IFC( _pUnkDoc->QueryInterface( IID_IDisplayServices, (void **) &_pDisplayServices ));
    IFC( _pUnkDoc->QueryInterface( IID_IHighlightRenderingServices, (void **) &_pHighlightServices ));
    IFC( pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainer ) );

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC( spWindow2->get_screen(&spScreen) );
    IFC( spScreen->QueryInterface(IID_IHTMLScreen2, (LPVOID *)&spScreen2) );
    IFC( spScreen2->get_logicalXDPI(&_llogicalXDPI) );
    IFC( spScreen2->get_logicalYDPI(&_llogicalYDPI) );
    IFC( spScreen2->get_deviceXDPI(&_ldeviceXDPI) );
    IFC( spScreen2->get_deviceYDPI(&_ldeviceYDPI) );

#if DBG == 1
    //
    // We don't fail here. It can happen that a Non-Debug Mshtml calls into a debug mshtmled.
    // In which case failure is bad. Instead - every debug method - just checks we have a non-null
    // _pEditDebugServices.
    //
    IGNORE_HR( _pUnkDoc->QueryInterface( IID_IEditDebugServices, ( void**) & _pEditDebugServices));
#endif

    IFC( InitCommandTable() );

    // Set css editing level
    _dwCssEditingLevel = 1;

    // Set the active command target based on our initial container
    IFC( SetActiveCommandTarget( spContainer ) );
            
    // Create the selection manager
    _pSelMan = new CSelectionManager( this );
    if( _pSelMan == NULL )
        goto Error;

    IFC( _pSelMan->Initialize());

    _pStringCache = new CStringCache(IDS_CACHE_BEGIN, IDS_CACHE_END);
    if( _pStringCache == NULL )
        goto Error;

    _pAutoUrlDetector = new CAutoUrlDetector(this);
    if( _pAutoUrlDetector == NULL )
        goto Error;

    _pUndoManagerHelper = new CUndoManagerHelper(this);
    if( _pUndoManagerHelper == NULL )
        goto Error;
        

    // Need to delay loading of the string table because we can't LoadLibrary in process attach.
    // This is not delayed to the command level because checking if the table is already loaded
    // is expensive.
    CGetBlockFmtCommand::LoadStringTable(g_hInstance);    

#ifndef NO_IME
    SetupActiveIMM();  
#endif

    //
    // Set the Edit Host - if there is one.
    //

    IFC (_pUnkDoc->QueryInterface(IID_IServiceProvider, (void**)&pDocServiceProvider));
    IGNORE_HR( pDocServiceProvider->QueryService( SID_SHTMLEditHost, IID_IHTMLEditHost, ( void** ) &_pIHTMLEditHost ));
    IGNORE_HR( pDocServiceProvider->QueryService( SID_SHTMLEditHost, IID_IHTMLEditHost2, ( void** ) &_pIHTMLEditHost2 ));

    //
    // Get the undo manager
    //

    // Add a designer
    pIMEMgr = new CIMEManager;
    if( pIMEMgr == NULL )
        goto Error;

    IFC( pIMEMgr->Init( this ) );
    IFC( AddDesigner( (IHTMLEditDesigner *)pIMEMgr ) );

    // Use the new UI paste by default for now.  If we run into problems, we'll need to 
    // change the default.
    //
    // TODO: need a mechanism for the host to set paste mode [ashrafm]
    _fIE50CompatUIPaste = FALSE;

#ifndef NO_IME
    //
    // IME reconversion if a feature not supported in IE 50 era
    //
    IFC( SetupIMEReconversion() );
#endif

    //
    // Create our IDispatch handlers
    //
    _pDispOnDblClkTimer = new CTimeoutHandler(this);
    if( !_pDispOnDblClkTimer )
        goto Error;

    _pCaptureHandler = new CCaptureHandler(this);
    if( !_pCaptureHandler )
        goto Error;

    InitAppCompatFlags();

    if (OK(THR_NOTRACE( pDocServiceProvider->QueryService(
            SID_SHTMLEditorViewManager,
            IID_IHTMLEditorViewManager,
            (void**) &pIHTMLEditorViewManager))))
    {
        g_fInVid = TRUE;
    }

Cleanup:
    AssertSz( hr == S_OK , "Editor failed to initialize");
    ReleaseInterface( pIMEMgr );    
    ReleaseInterface( pIHTMLEditorViewManager ); 
    ReleaseInterface( pDocServiceProvider );
    return hr;

Error:
    return( E_OUTOFMEMORY );
 
}


//----------------------------------------------------------
//
//  Initialize the CommandTable
//
//
//     *** NOTE: Insert frequently used commands first ***
//     This will keep them closer to the top of the tree and make lookups 
//     faster
//   
//==========================================================

// TODO (johnbed) if memory/perf overhead of having this per instance is too great,
//                  move this to a static table and call in process attach. All static
//                  tables should be moved here since these are globally accessable.
HRESULT
CHTMLEditor::InitCommandTable()
{
    CCommand * pCmd = NULL;
    COutdentCommand * pOutdentCmd = NULL;

    _pCommandTable = new CCommandTable(60);
    if( _pCommandTable == NULL )
        goto Error;

    //+----------------------------------------------------
    // CHAR FORMAT COMMANDS 
    //+----------------------------------------------------

    pCmd = new CCharCommand( IDM_BOLD, TAGID_STRONG, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CCharCommand( IDM_ITALIC, TAGID_EM, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_STRIKETHROUGH, TAGID_STRIKE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_SUBSCRIPT, TAGID_SUB, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new  CCharCommand( IDM_SUPERSCRIPT, TAGID_SUP, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CCharCommand( IDM_UNDERLINE, TAGID_U, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CFontSizeCommand( IDM_FONTSIZE, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CFontNameCommand( IDM_FONTNAME, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CForeColorCommand( IDM_FORECOLOR, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CBackColorCommand( IDM_BACKCOLOR, TAGID_FONT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAnchorCommand( IDM_HYPERLINK, TAGID_A, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAnchorCommand( IDM_BOOKMARK, TAGID_A, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CRemoveFormatCommand( IDM_REMOVEFORMAT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CUnlinkCommand( IDM_UNLINK, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CUnlinkCommand( IDM_UNBOOKMARK, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // BLOCK FORMAT COMMANDS 
    //+----------------------------------------------------

    pCmd = new  CIndentCommand( IDM_INDENT, TAGID_BLOCKQUOTE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pOutdentCmd = new  COutdentCommand( IDM_OUTDENT, TAGID_BLOCKQUOTE , this );
    if( pOutdentCmd == NULL )
        goto Error;
    _pCommandTable->Add( (CCommand*) pOutdentCmd );

    pOutdentCmd = new  COutdentCommand( IDM_UI_OUTDENT, TAGID_BLOCKQUOTE , this );
    if( pOutdentCmd == NULL )
        goto Error;
    _pCommandTable->Add( (CCommand*) pOutdentCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYCENTER, TAGID_CENTER, _T("center"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYLEFT, TAGID_NULL, _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYGENERAL, TAGID_NULL, _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYRIGHT, TAGID_NULL, _T("right"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYNONE, TAGID_NULL, _T(""), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CAlignCommand(IDM_JUSTIFYFULL, TAGID_NULL, _T("justify"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CGetBlockFmtCommand( IDM_GETBLOCKFMTS, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CLocalizeEditorCommand( IDM_LOCALIZEEDITOR, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CListCommand( IDM_ORDERLIST, TAGID_OL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CListCommand( IDM_UNORDERLIST, TAGID_UL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockFmtCommand( IDM_BLOCKFMT , TAGID_NULL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockDirCommand( IDM_BLOCKDIRLTR, TAGID_NULL, _T("ltr"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CBlockDirCommand( IDM_BLOCKDIRRTL, TAGID_NULL, _T("rtl"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // DIALOG COMMANDS 
    //+----------------------------------------------------

    pCmd = new CDialogCommand( UINT(~IDM_HYPERLINK) , this ); 
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDialogCommand( UINT(~IDM_IMAGE) , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDialogCommand( UINT(~IDM_FONT) , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // INSERT COMMANDS 
    //+----------------------------------------------------

    pCmd = new CInsertCommand( IDM_BUTTON, TAGID_BUTTON, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_TEXTBOX, TAGID_INPUT, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_TEXTAREA, TAGID_TEXTAREA, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_MARQUEE, TAGID_MARQUEE, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_HORIZONTALLINE, TAGID_HR, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_IFRAME, TAGID_IFRAME, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSFIELDSET, TAGID_FIELDSET, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertParagraphCommand( IDM_PARAGRAPH, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_IMAGE, TAGID_IMG, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_DROPDOWNBOX, TAGID_SELECT, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    pCmd = new CInsertCommand( IDM_LISTBOX, TAGID_SELECT,  _T("MULTIPLE"), _T("TRUE") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_1D, TAGID_DIV, _T("POSITION:RELATIVE"), NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_CHECKBOX, TAGID_INPUT, _T("type"), _T("checkbox") , this );   
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_RADIOBUTTON, TAGID_INPUT, _T("type"), _T("radio") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTBUTTON, TAGID_INPUT, _T("type"), _T("button") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTRESET, TAGID_INPUT, _T("type"), _T("reset") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTSUBMIT, TAGID_INPUT, _T("type"), _T("submit") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTUPLOAD, TAGID_INPUT, _T("type"), _T("file") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTHIDDEN, TAGID_INPUT, _T("type"), _T("hidden") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTPASSWORD, TAGID_INPUT, _T("type"), _T("password") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSINPUTIMAGE, TAGID_INPUT, _T("type"), _T("image") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_INSERTSPAN, TAGID_SPAN, _T("class"), _T("") , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKLEFT, TAGID_BR, _T("clear"), _T("left"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKRIGHT, TAGID_BR, _T("clear"), _T("right"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKBOTH, TAGID_BR, _T("clear"), _T("all"), this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_LINEBREAKNORMAL, TAGID_BR, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CInsertCommand( IDM_NONBREAK, TAGID_NULL, NULL, NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );
    
    //+----------------------------------------------------
    // INSERTOBJECT COMMAND
    //+----------------------------------------------------
    
    pCmd = new CInsertObjectCommand( IDM_INSERTOBJECT, TAGID_OBJECT, _T( "CLASSID" ), NULL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // SELECTION COMMANDS 
    //+----------------------------------------------------

    pCmd = new CSelectAllCommand( IDM_SELECTALL , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CClearSelectionCommand( IDM_CLEARSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CKeepSelectionCommand( IDM_KEEPSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // DELETE COMMAND
    //+----------------------------------------------------

    pCmd = new CDeleteCommand( IDM_DELETE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDeleteCommand( IDM_DELETEWORD , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // CUT COMMAND
    //+----------------------------------------------------

    pCmd = new CCutCommand( IDM_CUT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // COPY COMMAND
    //+----------------------------------------------------

    pCmd = new CCopyCommand( IDM_COPY , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    //+----------------------------------------------------
    // PASTE COMMAND
    //+----------------------------------------------------
    
    pCmd = new CPasteCommand( IDM_PASTE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // FORM EDITING COMMANDS 
    //+----------------------------------------------------

    pCmd = new CMultipleSelectionCommand( IDM_MULTIPLESELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new C2DPositionModeCommand( IDM_2D_POSITION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new C1DElementCommand( IDM_1D_ELEMENT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    pCmd = new C2DElementCommand( IDM_2D_ELEMENT , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );


    pCmd = new CAbsolutePositionCommand( IDM_ABSOLUTE_POSITION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CLiveResizeCommand( IDM_LIVERESIZE , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAtomicSelectionCommand( IDM_ATOMICSELECTION , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // TRISTATE COMMANDS
    //+----------------------------------------------------

    pCmd = new CTriStateCommand( IDM_TRISTATEBOLD, TAGID_STRONG, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CTriStateCommand( IDM_TRISTATEITALIC, TAGID_EM, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new  CTriStateCommand( IDM_TRISTATEUNDERLINE, TAGID_U, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    //+----------------------------------------------------
    // MISCELLANEOUS OTHER COMMANDS 
    //+----------------------------------------------------

    pCmd = new CAutoDetectCommand( IDM_AUTODETECT, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new COverwriteCommand( IDM_OVERWRITE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CComposeSettingsCommand( IDM_COMPOSESETTINGS, this );
    if (pCmd == NULL)
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CAutoUrlDetectModeCommand( IDM_AUTOURLDETECT_MODE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CDisalbeEditFocusHandlesCommand( IDM_DISABLE_EDITFOCUS_UI , this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CIE50PasteModeCommand( IDM_IE50_PASTE_MODE, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CCssEditingLevelCommand( IDM_CSSEDITING_LEVEL, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    pCmd = new CIMEReconversionCommand( IDM_IME_ENABLE_RECONVERSION, this );
    if( pCmd == NULL )
        goto Error;
    _pCommandTable->Add( pCmd );

    return( S_OK );
    
Error:
    return( E_OUTOFMEMORY );
}


HRESULT
CHTMLEditor::DeleteCommandTable()
{
    delete _pCommandTable;
    return(S_OK);
}


//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor IHTMLEditor Implementation
//////////////////////////////////////////////////////////////////////////////////


HRESULT
CHTMLEditor::PreHandleEvent(DISPID inEvtDispId , 
                            IHTMLEventObj* pObj )
{
    HRESULT hr;
    
    if(!_pSelMan)
        return E_FAIL;

    CHTMLEditEvent evt( this );

    IFC( _pSelMan->EnsureEditContext());

    IFC( evt.Init( pObj, inEvtDispId ));
   
    //
    // Don't pass designers our internal double click event.
    // This event is really only intended to allow us
    // to maintain compat with previous versions of IE, and we
    // shouldn't tell the designers about it
    //
    if( evt.GetType() != EVT_INTDBLCLK )
    {
        hr = THR(DesignerPreHandleEvent( inEvtDispId, pObj ));
    }
    else
    {
        hr = S_FALSE;
    }
    
    
    if( hr == S_FALSE )
    {
        if (    
                ( evt.GetType() >= EVT_LMOUSEDOWN
                  && evt.GetType() <= EVT_MOUSEMOVE
                  && !_pSelMan->IsInCapture()
                  && IsEventInSelection( & evt ) == S_OK
                  && evt.IsInScrollbar() == S_FALSE  // ignore mouse events on scrollbars.
                )
             || 
                (((  evt.GetType() >= EVT_KEYDOWN
                 &&  evt.GetType() <= EVT_KEYPRESS )
#ifdef UNIX // Handle MMB paste action
                 || evt.GetType() == EVT_MMOUSEDOWN
#endif                 
                 )
                 && ( ( _pSelMan->GetEditableElement()                          && 
                        IsEditable(_pSelMan->GetEditableElement() ) == S_OK )   ||                
                        IsCurrentElementEditable() == S_OK )
                )
            ||  ( _pSelMan->ShouldHandleEventInPre( & evt ) == S_OK ) 
           )
        {                     
            if(evt.GetType() == EVT_KEYPRESS && !CanHandleEvent(pObj))
            {
                hr = E_ACCESSDENIED;
            }
            else
            {
                hr = THR ( _pSelMan->HandleEvent( & evt ));             
            }
        }
        else
            hr = S_FALSE;
    }

    if ( hr == S_OK )
    {
        IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pObj ));
    }
    
Cleanup:
    return( hr );
    
}

BOOL
CHTMLEditor::CanHandleEvent(IHTMLEventObj* pIObj)
{
    HRESULT                 hr;
    SP_IHTMLElement         spCurElement;
    SP_IHTMLElement         spSrcElement;
    SP_IHTMLInputElement    spCurInputElement;
    IObjectIdentity       * pIdent = NULL;

    BSTR bstrType		= NULL;
    BOOL fInputFileType = FALSE;

    IFC( pIObj->get_srcElement(&spSrcElement) );
    if (!spSrcElement.IsNull())
    {
        IFC( GetDoc()->get_activeElement( & spCurElement ));
        if (!spCurElement.IsNull())
        {
            IFC( spCurElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pIdent)); 
            IFC( spCurElement->QueryInterface( IID_IHTMLInputElement, (void**) & spCurInputElement ));
            IFC( spCurInputElement->get_type(&bstrType));
            if (!StrCmpIC( bstrType, TEXT("file")) && pIdent->IsEqualObject(spSrcElement) != S_OK)
            {
                fInputFileType = TRUE;
            }
        }
    }        

Cleanup:
    SysFreeString( bstrType );
    ReleaseInterface( pIdent );
    return ((hr == E_OUTOFMEMORY) || fInputFileType) ? FALSE : TRUE;
}

HRESULT
CHTMLEditor::IsCurrentElementEditable()
{
    HRESULT hr;
    SP_IHTMLElement spCurElement;
    SP_IHTMLElement3 spCurElement3;
    VARIANT_BOOL vbEditable;
    
    IFC( GetDoc()->get_activeElement( & spCurElement ));
    if ( ! spCurElement.IsNull() )
    {
        IFC( spCurElement->QueryInterface( IID_IHTMLElement3, (void**) & spCurElement3 ));
        IFC( spCurElement3->get_isContentEditable( & vbEditable ));
        hr = ( vbEditable == VB_TRUE ) ? S_OK : S_FALSE;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr, S_FALSE);
}

HRESULT
CHTMLEditor::PostHandleEvent(DISPID inEvtDispId , 
                             IHTMLEventObj* pIEventObj )
{
    HRESULT         hr;
    CHTMLEditEvent  evt( this );
   
    if(!_pSelMan)
        return E_FAIL;
    
    IFC( evt.Init( pIEventObj, inEvtDispId ));
    IFC( _pSelMan->EnsureEditContext());

    //
    // Don't pass designers our internal double click event.
    // This event is really only intended to allow us
    // to maintain compat with previous versions of IE, and we
    // shouldn't tell the designers about it
    //    
    if( evt.GetType() != EVT_INTDBLCLK )
    {
        hr = THR(DesignerPostHandleEvent( inEvtDispId, pIEventObj ));
    }
    else
    {
        hr = S_FALSE;
    }
    
    if( hr == S_FALSE )
    {
        IFC( _pSelMan->HandleEvent( & evt ));             
    }

    IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pIEventObj));
    
Cleanup:
    return( hr );

}

HRESULT
CHTMLEditor::TranslateAccelerator(DISPID inEvtDispId, 
                                  IHTMLEventObj* pIEventObj )    
{
    HRESULT hr;
    
    if(!_pSelMan)
        return E_FAIL;

    IFC( _pSelMan->EnsureEditContext());

    hr = THR(DesignerTranslateAccelerator( inEvtDispId, pIEventObj ));
    
    if( hr == S_FALSE )
    {
        CHTMLEditEvent evt( this );
        IFC( evt.Init( pIEventObj, inEvtDispId ));
        //  Editor requires VK_TAB in <PRE> (61302), VK_BACK(58719, 58774),
        //  and the navigation keys 
        //
        //  Need to handle Ctrl-Shift (87715)  (zhenbinx)
        //
        if (  !evt.IsAltKeyDown() && (evt.GetType() == EVT_KEYDOWN || evt.GetType() == EVT_KEYUP) )
        {
            LONG keyCode;
            IGNORE_HR( evt.GetKeyCode( & keyCode ));

#if DBG==1
            if (evt.GetType() == EVT_KEYUP) 
            { 
                if ( 
                    (VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode) ||
                    (VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode)
                   ) 
                {
                    TraceTag((tagEditingKeyProcessing,"EVT_KEYUP - %x", keyCode)); 
                }
                
            } 
#endif
        
            if (  keyCode == VK_BACK
                 || (keyCode >= VK_PRIOR && keyCode <= VK_DOWN)
                 || (keyCode == VK_TAB && _pSelMan->CaretInPre())
                 || (VK_SHIFT == keyCode || VK_LSHIFT == keyCode || VK_RSHIFT == keyCode)
                 || ((VK_CONTROL == keyCode || VK_LCONTROL == keyCode || VK_RCONTROL == keyCode) && evt.GetType() == EVT_KEYUP)
               )
            {                       
                hr = THR ( _pSelMan->HandleEvent( & evt ));             
            }
            else
                hr = S_FALSE;
        }
        else
            hr = S_FALSE;
    }

    if ( hr == S_OK )
    {
        IGNORE_HR( DesignerPostEditorEventNotify( inEvtDispId, pIEventObj ));
    }
    
Cleanup:
    return( hr );

}



HRESULT
CHTMLEditor::GetSelectionType(SELECTION_TYPE *peSelectionType )
{
    Assert( peSelectionType && _pSelMan );
    if ( ! _pSelMan )
    {
        return( E_FAIL) ;
    }
    
    RRETURN( _pSelMan->GetSelectionType( peSelectionType ) );
}


        

HRESULT 
CHTMLEditor::RemoveContainer(IUnknown *pUnknown)
{
    HRESULT  hr  = S_OK;
    //
    // switch markup happened (e.g. frame navigation) or viewlinked 
    // doc design mode changed
    //
    CMshtmlEd *pCmdTarget, *pCmdActive;
    SP_IMarkupContainer2  spContainerEnded;
    BOOL    fContained = FALSE;

    IFC( pUnknown->QueryInterface( IID_IMarkupContainer2, (void **)&spContainerEnded) );
    hr = THR(FindCommandTarget( spContainerEnded, &pCmdTarget));
    if (!SUCCEEDED(hr))
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = S_OK;
    pCmdActive = GetActiveCommandTarget();
    if (pCmdActive)
    {
        if (pCmdActive == pCmdTarget)
        {
            fContained = TRUE;
        }
        else
        {
            // check to see if the active container is contained by the dying container
            IFC( EdUtil::CheckContainment(GetMarkupServices(), spContainerEnded, 
                                          pCmdActive->GetMarkupContainer(), &fContained) );
        }
    }
    
    if (fContained)
    {
#if DBG == 1
        Assert(_pSelMan);
        BOOL  fContextContained = FALSE;
        IFC( _pSelMan->IsContextWithinContainer(spContainerEnded, &fContextContained) );
        Assert(fContextContained && "edit context is not set to the active cmd target");
#endif

        //  We need to make sure our tracker is torn down first 
        if (_pSelMan && _pSelMan->GetActiveTracker())
        {
            IGNORE_HR( _pSelMan->GetActiveTracker()->BecomeDormant(NULL, TRACKER_TYPE_None, NULL) );
        }
        
        //
        // TODO: CSelectionManager should provide a way
        // to re-initialize itself when the active container
        // is removed. Now simply call Passivate and then 
        // redo Initailization();
        //
        IFC( _pSelMan->Passivate() );
        _pSelMan->Init();
        
        // Reset the active cmdTarget to the top container
        {
            SP_IMarkupContainer  spContainerNew;
            SP_IHTMLDocument2    spHtmlDoc;
            
            Assert(_pUnkContainer );
            IFC( _pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainerNew ) );
            IFC( FindCommandTarget( spContainerNew, &_pActiveCommandTarget ) );    
            Assert(_pActiveCommandTarget);
            Assert(_pActiveCommandTarget != pCmdTarget);

            IFC( spContainerNew->OwningDoc(&spHtmlDoc) );
            SetDoc(spHtmlDoc);
        }
    }

    if (pCmdTarget) 
    {
        // delete cmdTarget
        IGNORE_HR(DeleteCommandTarget(spContainerEnded) );
    }
    
Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::Notify(
    EDITOR_NOTIFICATION eSelectionNotification,
    IUnknown *pUnknown ,
    DWORD dword )
{
    HRESULT  hr = S_OK;
    
    if (eSelectionNotification == EDITOR_NOTIFY_CONTAINER_ENDED)
    {
        hr =THR(RemoveContainer(pUnknown));
        goto Cleanup;
    }
    
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (!_pSelMan->_fInitialized)
    {
        hr = THR( _pSelMan->Initialize() );
        if (hr)
            goto Cleanup;
    }
    
    hr = THR( _pSelMan->Notify( eSelectionNotification, pUnknown, dword ) );
Cleanup:
    RRETURN1(hr, S_FALSE);
}
    

HRESULT
CHTMLEditor::GetCommandTarget(
    IUnknown *  pContext,
    IUnknown ** ppUnkTarget )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer     spContainer;
    CMshtmlEd               *pCmdTarget = NULL;
    SP_IMarkupContainer     spContainerFinal;
    
    if( !pContext || !ppUnkTarget )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // See if we are being passed in a markup container as our context
    hr = pContext->QueryInterface( IID_IMarkupContainer , (void **) &spContainer );

    if( !hr )
    {
        IFC( AdjustContainerCommandTarget( spContainer, &spContainerFinal) );
        
        //
        // Find the command target for this container
        //
        IFC( FindCommandTarget( spContainerFinal, &pCmdTarget ) );

        //
        // Didn't find a command target previously created for this IMarkupContainer.
        // Create one.
        //
        if( hr == S_FALSE )
        {
            IFC( AddCommandTarget( spContainerFinal, &pCmdTarget ) );        
        }

        // Retrieve the IUnknown pointer to pass back
        IFC( pCmdTarget->QueryInterface( IID_IUnknown, (void **)ppUnkTarget) );
    }
    else
    {
        //
        // We have a range asking for a command target.  Create a command
        // target and initialize the command target for the range.
        //
        pCmdTarget = new CMshtmlEd(this, TRUE);

        if( pCmdTarget == NULL )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    
        IFC( pCmdTarget->Initialize( pContext ) );
        IFC( pCmdTarget->QueryInterface( IID_IUnknown , (void **)ppUnkTarget ) );

        pCmdTarget->Release();
    }

Cleanup:
    RRETURN(hr);
}    

HRESULT
CHTMLEditor::GetElementToTabFrom(
            BOOL            fForward,
            IHTMLElement**  ppElement,
            BOOL *          pfFindNext)
{
    HRESULT         hr = S_OK;
            
    Assert( ppElement );
    if( ppElement == NULL )
        goto Cleanup;

    Assert(pfFindNext);
    if (!pfFindNext)
        goto Cleanup;

    *ppElement = NULL;
    *pfFindNext = TRUE;
    IFC( _pSelMan->EnsureEditContext());
    IFC( _pSelMan->GetActiveTracker()->GetElementToTabFrom( fForward, ppElement, pfFindNext ) );
       
Cleanup:
    
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the ISelectionServices interface
//
//  Arguments:  ppSelSvc = OUTPUT interface pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionServices( ISelectionServices **ppSelSvc )
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( ppSelSvc );

    if( ppSelSvc )
    {
        if( _pActiveCommandTarget )
        {
            CSelectionServices *pSelServ = _pActiveCommandTarget->GetSelectionServices();
            IFC(  pSelServ->QueryInterface( IID_ISelectionServices, (void **)ppSelSvc ) );
        }
        else
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN ( hr ) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the ISelectionServices interface
//
//  Arguments:  pIDoc = INPUT - Optional parameter indicating the doc to find
//                      the selection services for.
//              ppSelSvc = OUTPUT interface pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionServices( IMarkupContainer *pIContainer, ISelectionServices **ppSelSvc )
{
    HRESULT     hr = E_INVALIDARG;
    CMshtmlEd   *pCmdTarget = NULL;
    
    Assert( ppSelSvc );

    if( ppSelSvc )
    {
        //
        // Try and locate the command target for the given container
        //
        if( pIContainer )
        {
            IFC( FindCommandTarget( pIContainer, &pCmdTarget ) );
        }

        //
        // Give them the active command target
        //
        if( !pCmdTarget && _pActiveCommandTarget )
        {
            pCmdTarget = _pActiveCommandTarget;
        }
         
        if( pCmdTarget )
        {
            CSelectionServices *pSelServ = pCmdTarget->GetSelectionServices();
            IFC(  pSelServ->QueryInterface( IID_ISelectionServices, (void **)ppSelSvc ) );
        }
        else
        {
            hr = E_FAIL;
        }
    }

Cleanup:
    RRETURN ( hr ) ;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionServices
//
//  Synopsis:   Retrieves the active CSelectionServices pointer
//
//  Arguments:  None
//
//  Returns:    Pointer to CSelectionServices
//
//--------------------------------------------------------------------------
CSelectionServices *
CHTMLEditor::GetSelectionServices( )
{
    IGNORE_HR( DoPendingTasks() );
    
    if( _pActiveCommandTarget )
        return _pActiveCommandTarget->GetSelectionServices();
    else
        return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::TerminateIMEComposition
//
//  Synopsis:   Terminates any active IME compositions
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::TerminateIMEComposition( )
{
    return GetSelectionManager()->TerminateIMEComposition(TERMINATE_NORMAL);
}

//////////////////////////////////////////////////////////////////////////////////
//    CHTMLEditor IHTMLEditingServices Implementation
//////////////////////////////////////////////////////////////////////////////////


HRESULT 
CHTMLEditor::Delete ( 
    IMarkupPointer*     pStart, 
    IMarkupPointer*     pEnd,
    BOOL fAdjustPointers)
{
    HRESULT             hr;
    CDeleteCommand      *pDeleteCommand;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pDeleteCommand->Delete( spStartInternal, spEndInternal, fAdjustPointers) );

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::DeleteCharacter (
    IMarkupPointer * pPointer, 
    BOOL fLeftBound, 
    BOOL fWordMode,
    IMarkupPointer * pBoundary )
{
    HRESULT             hr, hrResult;
    SP_IMarkupPointer   spPointerInternal;
    CDeleteCommand      *pDeleteCommand;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );
    
    IFC( ConvertPointerToInternal( this, pPointer, &spPointerInternal) );

    //
    // Set the command target, the delete character function call sometimes
    // gets executed without having gone thru the plumbing which sets the commands
    // command targets
    //
    IFC( PushCommandTarget( _pActiveCommandTarget ) );
    
    hrResult = THR( pDeleteCommand->DeleteCharacter( spPointerInternal, fLeftBound, fWordMode, pBoundary ) );

    IFC( PopCommandTarget(WHEN_DBG(_pActiveCommandTarget)) );

    hr = hrResult;

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::Paste( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd, 
    BSTR bstrText )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    CPasteCommand       *pPasteCommand;
    CSpringLoader       *psl = GetPrimarySpringLoader();

    pPasteCommand = (CPasteCommand *) GetCommandTable()->Get( IDM_PASTE );
    Assert( pPasteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    if (psl && !psl->IsSpringLoaded())
    {
        psl = NULL; // avoid empty line formatting for external paste
    }

    IFC( pPasteCommand->Paste( spStartInternal, spEndInternal, psl, bstrText ) );      

Cleanup:
    RRETURN(hr);
}       


HRESULT 
CHTMLEditor::PasteFromClipboard( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd,
    IDataObject* pDO )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    CPasteCommand  * pPasteCommand = NULL;

    pPasteCommand = (CPasteCommand *) GetCommandTable()->Get( IDM_PASTE );
    Assert( pPasteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pPasteCommand->PasteFromClipboard( spStartInternal, spEndInternal , pDO, GetPrimarySpringLoader(), FALSE /* fForceIE50Compat */) );

Cleanup:
    RRETURN(hr);
}       

///////////////////////////////////////////////////
// ISelectionObject2 Implementation
///////////////////////////////////////////////////
HRESULT 
CHTMLEditor::SelectRange( 
    IMarkupPointer* pStart, 
    IMarkupPointer* pEnd,
    SELECTION_TYPE eType)
{
    RRETURN (SelectRangeInternal(pStart,pEnd,eType,FALSE));
}     

HRESULT 
CHTMLEditor::SelectRangeInternal( 
                    IMarkupPointer* pStart, 
                    IMarkupPointer* pEnd,
                    SELECTION_TYPE  eType,
                    BOOL            fInternal)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spElement;
    SP_IDisplayPointer  spDispStart;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;
    BOOL                fDidSelection = FALSE;


    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return E_FAIL;
    }
    //
    // Stop doing a set edit context range here, assume that its been set in Trident.
    //

#ifdef FORMSMODE
    IFC( CurrentScopeOrMaster(pStart, &spElement) );
    if (spElement != NULL)
    {
        if (_pSelMan->IsInFormsSelectionMode(spElement))
        {
            if (!fInternal && eType != SELECTION_TYPE_Caret && eType != SELECTION_TYPE_Control)
            {
                hr = E_INVALIDARG;
                goto Cleanup;
            }
            else if (eType == SELECTION_TYPE_Caret)
            {
                hr = S_OK;
                goto Cleanup;
            }
     }
#endif
    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( _pSelMan->Select( spStartInternal, spEndInternal, eType, &fDidSelection ) );

    //  We need to scroll the selection into view.
    if ( fDidSelection )
    {
        //
        // We could have select a range different from spStartInternal/spEndInternal
        // due to adjustment
        //
        CEditTracker  *pTracker;
        pTracker = _pSelMan->GetActiveTracker();
        if (pTracker && pTracker->GetTrackerType() == TRACKER_TYPE_Selection)
        {
            CSelectTracker *pSelTracker = DYNCAST(CSelectTracker, pTracker);
            IFC( pSelTracker->GetStartSelection()->ScrollIntoView() );
        }
    }

Cleanup:
    RRETURN(hr);    
}     

HRESULT 
CHTMLEditor::Select( 
                ISegmentList* pISegmentList )
{
    HRESULT         hr = S_OK;
    SELECTION_TYPE  eType;
    
    Assert( _pSelMan && pISegmentList );
    if( !_pSelMan || !pISegmentList)
    {
        return E_FAIL;
    }

    //
    // If we are hosted under access, we cannot fire the onbeforeeditfocus event
    // when we are selecting items.  Because Access uses a magic div, controls that
    // are embedded in that magic div that are selected cause the magic div to become
    // current.  We didn't fire onbeforeeditfocus on select() calls in 5.0, but in
    // 5.5 we started firing this event.  Access cancels this event (they never want
    // their magic div to be editable) so we need to continue to not firing this
    // event for access.  And the magic continues!  Access also listens to when
    // their magic div becomes current.  Because CSelectionManager::Select() makes
    // their magic div current, Access panics and grabs the document.selection type 
    // to see if we are making their magic div active with a text selection on the
    // inside.  So we need to lie to them.  We ARE transitioning to a control tracker
    // in most every single case, but when BecomeCurrent() is called on the magic 
    // div, the tracker has not yet become active.  This is a nightmare, but we
    // need to keep this compat
    //
    if( IsHostedInAccess() )
    {
        IFC( pISegmentList->GetType( &eType ) );
        
        _pSelMan->SetDontFireEditFocus(TRUE);
        _fLieToAccess = TRUE;
        _eAccessLieType = eType;
    }

    //
    // Actually do the select
    //
    IFC( _pSelMan->Select( pISegmentList ) );


    if( IsHostedInAccess() )
    {
        _pSelMan->SetDontFireEditFocus(FALSE);
        _fLieToAccess = FALSE;
        _eAccessLieType = SELECTION_TYPE_None;
    }

Cleanup:
    RRETURN(hr);
}  


HRESULT 
CHTMLEditor::IsPointerInSelection(  IDisplayPointer *pDispPointer, 
                                    BOOL            *pfPointInSelection,
                                    POINT           *pptGlobal,
                                    IHTMLElement    *pIElementOver )
{
    HRESULT hr = S_OK;
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        hr = E_FAIL ;
        goto Cleanup;
    }
    IFC( _pSelMan->EnsureEditContext());    
    hr = THR( _pSelMan->IsPointerInSelection( pDispPointer, pfPointInSelection, pptGlobal, pIElementOver  ));
Cleanup:
    RRETURN( hr );
}     

HRESULT
CHTMLEditor::EmptySelection()
{
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }
    RRETURN ( _pSelMan->EmptySelection(TRUE) );

}

HRESULT
CHTMLEditor::DestroySelection()
{
    HRESULT hr = S_OK;
    
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }


    IFC( _pSelMan->DestroySelection() );

Cleanup:
    RRETURN(hr);
}

HRESULT
CHTMLEditor::DestroyAllSelection()
{
    HRESULT hr = S_OK;
    
    Assert(_pSelMan != NULL);
    
    if( ! _pSelMan )
    {
        return( E_FAIL );
    }
    IFC( _pSelMan->EnsureEditContext());
    
    if( !_pSelMan->IsInFireOnSelectStart() )
    {
        IFC( _pSelMan->EnsureDefaultTrackerPassive());
    }                    
    else
    {
        //
        // We're unloading during firing of OnSelectStart
        // We want to not kill the tracker now - but fail the OnSelectStart
        // resulting in the Tracker dieing gracefully.
        //
        _pSelMan->SetFailFireOnSelectStart( TRUE );
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::IsEventInSelection(CEditEvent* pEvent)
{
    HRESULT hr;
    SP_IMarkupPointer spPointer;
    POINT pt;
    SP_IHTMLElement spElement;
    BOOL fInSelection = FALSE;
    SP_IDisplayPointer spDispPointer;
    
    IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPointer ));
    IFC( CreateMarkupPointer( & spPointer ));
    IFC( pEvent->MoveDisplayPointerToEvent( spDispPointer ));
    IFC( spDispPointer->PositionMarkupPointer( spPointer ));
    IFC( pEvent->GetPoint( & pt ));
    IFC( pEvent->GetElement( & spElement ));


    IFC( _pSelMan->IsPointerInSelection( spDispPointer, & fInSelection, & pt, spElement  ));
    
Cleanup:

    if ( hr == S_OK )
    {
        if ( ! fInSelection )
        {
            hr = S_FALSE;
        }
    }
    
    RRETURN1( hr, S_FALSE );
}

HRESULT 
CHTMLEditor::AdjustPointerForInsert ( 
                                    IDisplayPointer * pDispWhereIThinkIAm , 
                                    BOOL fFurtherInDocument, 
                                    IMarkupPointer* pConstraintStart,
                                    IMarkupPointer* pConstraintEnd )
{
    HRESULT hr = S_OK;
    BOOL    fAtBOL;
    SP_IHTMLElement     spElement;

    IFC( pDispWhereIThinkIAm->IsAtBOL(&fAtBOL) );
    IFC( AdjustPointer( pDispWhereIThinkIAm, fFurtherInDocument ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, 
                             ( pConstraintStart == NULL ) ? _pSelMan->GetStartEditContext() : pConstraintStart,
                             ( pConstraintEnd == NULL ) ? _pSelMan->GetEndEditContext() : pConstraintEnd, POSCARETOPT_None ) );

    //  Bug 102610: If the pointer was positioned into an atomic element, reposition it
    //  back outside.

    IFC( CurrentScopeOrMaster(pDispWhereIThinkIAm, &spElement) );
    if ( _pSelMan->CheckAtomic( spElement ) == S_OK )
    {
        SP_IMarkupPointer   spPointer;

        IFC( CreateMarkupPointer(&spPointer) );
        IFC( spPointer->MoveAdjacentToElement( spElement, 
                                                fFurtherInDocument ? ELEM_ADJ_BeforeBegin : ELEM_ADJ_AfterEnd) );
        IFC( pDispWhereIThinkIAm->MoveToMarkupPointer(spPointer, NULL) );
    }

Cleanup:
    RRETURN ( hr );
}

HRESULT 
CHTMLEditor::AdjustPointerForInsert ( 
                                    IDisplayPointer* pDispWhereIThinkIAm , 
                                    BOOL fFurtherInDocument, 
                                    IMarkupPointer* pConstraintStart,
                                    IMarkupPointer* pConstraintEnd,
                                    BOOL fStayOutsideUrl)
{
    HRESULT hr = S_OK;
    BOOL    fAtBOL;
    
    IFC( pDispWhereIThinkIAm->IsAtBOL(&fAtBOL) );
    IFC( AdjustPointer( pDispWhereIThinkIAm, fFurtherInDocument ? RIGHT : LEFT, fAtBOL ? RIGHT : LEFT, 
                     ( pConstraintStart == NULL ) ? _pSelMan->GetStartEditContext() : pConstraintStart,
                     ( pConstraintEnd == NULL ) ? _pSelMan->GetEndEditContext() : pConstraintEnd, fStayOutsideUrl ? POSCARETOPT_None : ADJPTROPT_AdjustIntoURL ));

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: FindSiteSelectableElement
//
// Synopsis: Traverse through a range of pointers and find the site selectable element if any
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::FindSiteSelectableElement (
                                     IMarkupPointer* pPointerStart,
                                     IMarkupPointer* pPointerEnd, 
                                     IHTMLElement** ppIHTMLElement)  
{
    HRESULT hr = S_OK;
    IHTMLElement* pICurElement = NULL;
    IHTMLElement* pISiteSelectableElement = NULL;
    IMarkupPointer* pPointer = NULL;
    SP_IMarkupPointer   spPointerStartInternal;
    SP_IMarkupPointer   spPointerEndInternal;    
    int iWherePointer = 0;
    MARKUP_CONTEXT_TYPE eContext = CONTEXT_TYPE_None;
    BOOL fValidForSelection  = FALSE;    
    BOOL fSiteSelectable = FALSE;
    BOOL fForceInvalid = FALSE;
    BOOL fIgnoreGlyphs = IgnoreGlyphs(TRUE);

    IFC( ConvertPointerToInternal( this, pPointerStart, &spPointerStartInternal) );
    IFC( ConvertPointerToInternal( this, pPointerEnd, &spPointerEndInternal) );
    
#if DBG == 1
    IFC( OldCompare( spPointerStartInternal, spPointerEndInternal, & iWherePointer ));
    Assert( iWherePointer != LEFT );
#endif

    IFC( CreateMarkupPointer( & pPointer ));
    IFC( pPointer->MoveToPointer( spPointerStartInternal));

    for(;;)
    {
        IFC( pPointer->Right( TRUE, & eContext, & pICurElement, NULL, NULL));
        IFC( OldCompare( pPointer, spPointerEndInternal, & iWherePointer));

        if ( iWherePointer == LEFT )
        {       
            goto Cleanup;
        }                    
        switch( eContext)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
            {
                Assert( pICurElement);

                fSiteSelectable = IsElementSiteSelectable( pICurElement ) == S_OK ;
                if ( fSiteSelectable )
                {
                    if (! fValidForSelection )
                    {
                        fValidForSelection = TRUE;
                        IFC( pPointer->MoveAdjacentToElement( pICurElement, ELEM_ADJ_AfterEnd ));
                        ReplaceInterface( & pISiteSelectableElement, pICurElement);
                    }
                    else if ( ! GetActiveCommandTarget()->IsMultipleSelection())
                    {                
                        //
                        // If we find a more than one site selectable elment ( and not Multiple-Sel)
                        // assume we are a text selection 
                        //
                        
                        fValidForSelection = FALSE;
                        goto Cleanup;
                    }
                    //
                    // else we are in multiple-selection mode. fValidForSelection remains true
                    // but we just return the FIRST site selectable element.
                    // 
                }                    
            }
            break;
            
            case CONTEXT_TYPE_Text:
            {
                // Must return S_FALSE indicating more than just an element here.
                fForceInvalid = TRUE;
                break;                    
            }

            case CONTEXT_TYPE_None:
            {
                fValidForSelection = FALSE;
                goto Cleanup;
            }

        }
        ClearInterface( & pICurElement );
    }

    
Cleanup:
    IgnoreGlyphs(fIgnoreGlyphs);
    
    ReleaseInterface( pICurElement);
    ReleaseInterface( pPointer );

    if ( hr == S_OK )
    {
        if ( !fValidForSelection || fForceInvalid)
            hr = S_FALSE;

        *ppIHTMLElement = pISiteSelectableElement;
        if (pISiteSelectableElement)
            pISiteSelectableElement->AddRef();
    }        
    ReleaseInterface( pISiteSelectableElement );
    return ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteSelectable
//
// Synopsis: Tests to see if a given element is site selectable (Doesn't drill up to the Edit
//           Context. - test is just for THIS Element
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::IsElementSiteSelectable( IHTMLElement* pIElement, IHTMLElement** ppIElement  )
{
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    BOOL fSiteSelectable = FALSE;

    SP_IHTMLElement spActive;
    SP_IHTMLElement spClippedElement;
    

    IFC( GetActiveElement( this, pIElement, & spActive ));
    if ( spActive )
    {
        IFC( ClipToElement( this , spActive, pIElement, & spClippedElement ));
    }
    else
        spClippedElement = pIElement;

    IFC( GetMarkupServices()->GetElementTagId( spClippedElement , & eTag ));
        
    fSiteSelectable = CControlTracker::IsThisElementSiteSelectable(
                            _pSelMan,
                            eTag, 
                            spClippedElement );

    if ( fSiteSelectable && ppIElement )
    {
        *ppIElement = spClippedElement;
        (*ppIElement)->AddRef();
    }

Cleanup:

    if ( fSiteSelectable )
        hr = S_OK;
    else
        hr = S_FALSE;
    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: IsElementUIActivatable
//
// Synopsis: Tests to see if a given element is UI Activatable
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsElementUIActivatable( IHTMLElement* pIElement )
{
    HRESULT hr;
    
    hr =  _pSelMan->IsElementUIActivatable( pIElement ) ? S_OK : S_FALSE ; 

    RRETURN1( hr , S_FALSE );
}

//+====================================================================================
//
// Method: IsElementAtomic
//
// Synopsis: Tests to see if a given element is atomic
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsElementAtomic( IHTMLElement* pIHTMLElement )
{
    HRESULT hr;

    hr = THR( _pSelMan->CheckAtomic(pIHTMLElement));

    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: PositionPointersInMaster
//
// Synopsis: Put pointers inside element for a viewlink editing.
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::PositionPointersInMaster( 
                                        IHTMLElement* pIElement, 
                                        IMarkupPointer* pIStart, 
                                        IMarkupPointer* pIEnd )
{
    HRESULT hr;

    hr = THR( EdUtil::PositionPointersInMaster( pIElement, pIStart, pIEnd ));

    RRETURN( hr );
}


BOOL
SkipCRLF ( TCHAR ** ppch )
{
    TCHAR   ch1;
    TCHAR   ch2;
    BOOL    fSkippedCRLF = FALSE;
    //
    // this function returns TRUE if a replacement of one or two chars
    // with br spacing is possible.  
    //

    //
    // is there a CR or LF?
    //

    ch1 = **ppch;
    if (ch1 != _T('\r') && ch1 != _T('\n'))
        goto Cleanup;

    //
    // Move pch forward and see of there is another CR or LF 
    // that can be grouped with the first one.
    //
    fSkippedCRLF = TRUE;
    ++(*ppch);
    ch2 = **ppch;

    if ((ch2 == _T('\r') || ch2 == _T('\n')) && ch1 != ch2)
        (*ppch)++;

Cleanup:
    
    return fSkippedCRLF;
}


HRESULT
CHTMLEditor::InsertLineBreak( IMarkupPointer * pStart, BOOL fAcceptsHTML )
{
    IMarkupPointer  * pEnd = NULL;
    IHTMLElement    * pIElement = NULL;
    HRESULT           hr;
    
    IFC( CreateMarkupPointer( & pEnd ) );
    IFC( pEnd->MoveToPointer( pStart ) );

    //
    // If pStart is in an element that accepts the truth, then insert a BR there
    // otherwise insert a carriage return
    //
    if (fAcceptsHTML)
    {
        IFC( GetMarkupServices()->CreateElement( TAGID_BR, NULL, & pIElement) );        
        IFC( InsertElement( pIElement, pStart, pEnd ) );
    }
    else
    {
        IFC( InsertMaximumText( _T("\r"), 1, pStart ) );
    }

Cleanup:
    ReleaseInterface( pIElement );
    ReleaseInterface( pEnd );
    RRETURN( hr );
}


HRESULT
CHTMLEditor::InsertSanitizedText(
    TCHAR *             pStr,
    LONG                cChInput,
    IMarkupPointer*     pStart,
    IMarkupServices*    pMarkupServices,
    CSpringLoader *     psl,
    BOOL                fDataBinding)
{
    const TCHAR chNBSP  = WCH_NBSP;
    const TCHAR chSpace = _T(' ');
    const TCHAR chTab   = _T('\t');

    HRESULT   hr = S_OK;;
    TCHAR     pchInsert[ TEXTCHUNK_SIZE + 1 ];
    TCHAR     chNext;
    TCHAR     *pStrInput;
    int       cch = 0;
    IHTMLElement        *   pFlowElement = NULL;
    VARIANT_BOOL            fAcceptsHTML;
    IMarkupPointer      *   pmpTemp = NULL;
    VARIANT_BOOL            fMultiLine = VARIANT_TRUE;
    POINTER_GRAVITY         eGravity = POINTER_GRAVITY_Left;
    SP_IHTMLElement3        spElement3;
    SP_IMarkupPointer       spStartInternal;

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );


    // Remember the gravity so we can restore it at Cleanup
    IFC( spStartInternal->Gravity(& eGravity ) );

    // we may be passed a null pStr if, for example, we are pasting an empty clipboard.
    
    if( pStr == NULL )
        goto Cleanup;

    IFC( spStartInternal->SetGravity( POINTER_GRAVITY_Right ) );

    //
    // Determine whether we accept HTML or not
    //
    IFC( spStartInternal->CurrentScope(&pFlowElement) );

    //
    // This should NEVER happen, but if it does, just fail the insert
    //
    if (! pFlowElement)
        goto Cleanup;
        
    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    IFC(spElement3->get_isMultiLine(&fMultiLine));

    if (*pStr && psl && fAcceptsHTML)
    {
        IFC( psl->SpringLoad(spStartInternal, SL_ADJUST_FOR_INSERT_RIGHT | SL_TRY_COMPOSE_SETTINGS | SL_RESET) );
        IFC( psl->Fire(spStartInternal) );
    }

    chNext = *pStr;
    pStrInput = pStr;

    while( pStr - pStrInput < cChInput && chNext)
    {   
        //
        // If the first character is a space, 
        // it must turn into an nbsp if pStart is 
        // at the beginning of a block/layout or after a <BR>
        //    
        if ( fAcceptsHTML && chNext == chSpace )
        {
            CEditPointer    ePointer( this );
            DWORD           dwBreak;

            IFC( ePointer.MoveToPointer( spStartInternal ) );
            IGNORE_HR( ePointer.Scan(  LEFT,
                            BREAK_CONDITION_Block |
                            BREAK_CONDITION_Site |
                            BREAK_CONDITION_Control |
                            BREAK_CONDITION_NoScopeBlock |
                            BREAK_CONDITION_Text ,
                            &dwBreak ) );

            if ( ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitBlock ) ||
                 ePointer.CheckFlag( dwBreak, BREAK_CONDITION_ExitSite  ) ||
                 ePointer.CheckFlag( dwBreak, BREAK_CONDITION_NoScopeBlock ))
            {
                // Change the first character to an nbsp
                chNext = chNBSP;
            }
        }

        for ( cch = 0 ; (pStr - pStrInput < cChInput) && chNext && chNext != _T('\r') && chNext != _T('\n') ; )
        {
            if ( fAcceptsHTML )
            {
                //
                // Launder spaces if we accept html
                //
                switch ( chNext )
                {
                case chSpace:
                    if ( *(pStr + 1) == _T( ' ' ) )
                    {
                        chNext = chNBSP;
                    }
                    break;

                case chNBSP:
                    break;

                case chTab:
                    chNext = chNBSP;
                    break;
                }
            }

            pchInsert[ cch++ ] = chNext;
            
            chNext = *++pStr;
            
            if (cch == TEXTCHUNK_SIZE)
            {
                // pchInsert is full, empty the text into the tree
                pchInsert[ cch ] = 0;
                IFC( InsertMaximumText( pchInsert, TEXTCHUNK_SIZE, spStartInternal ) );
                cch = 0;
            }
        }
        
        pchInsert[ cch ] = 0;

        //
        // Check for NULL termination or exceeding cChInput.
        //
        if (pStr - pStrInput >= cChInput || (*pStr) == NULL)
        {
            if (cch)
            {
                // Insert processed text into the tree and bail
                IFC( InsertMaximumText( pchInsert, cch, spStartInternal ) );
            }
            break;
        }

        Verify( SkipCRLF( &pStr ) );        

        IFC( InsertMaximumText( pchInsert, -1, spStartInternal ) );

        if ( !fAcceptsHTML && !fMultiLine )
        {
            // 
            // We're done because this is not a multi line control and
            // the first line of text has already been inserted.
            // 
            goto Cleanup;
        }

        if ( SkipCRLF( &pStr ))
        {
            // We got two CRLFs. If we are in data binding, simply
            // insert two BRs. If we are not in databinding, insert
            // a new paragraph.
            if (fDataBinding || !fAcceptsHTML)
            {
                IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
                IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
            }
            else
            {
                ClearInterface( & pmpTemp );
                IFC( HandleEnter( spStartInternal, & pmpTemp, NULL, TRUE ) );
                if (pmpTemp)
                {
                    IFC( spStartInternal->MoveToPointer( pmpTemp ) );
                }
            }
        }
        else
        {
            IFC( InsertLineBreak( spStartInternal, fAcceptsHTML ) );
        }
        
        chNext = *pStr;
    }

Cleanup:
    ReleaseInterface( pmpTemp );
    ReleaseInterface( pFlowElement );
    IGNORE_HR( pStart->SetGravity( eGravity ) );

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsEditContextUIActive
//
// Synopsis: Is the edit context Ui active ( does it have the hatched border ?).
//           If it does - return S_OK
//                      else return S_FALSE
//
//------------------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsEditContextUIActive()
{
    HRESULT hr;

    if ( !_pSelMan )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = _pSelMan->IsEditContextUIActive() ;

Cleanup:
    RRETURN1( hr, S_FALSE );
}    

HRESULT 
CHTMLEditor::InsertSanitizedText( 
    IMarkupPointer * pIPointerInsertHere, 
    OLECHAR *        pstrText,
    LONG             cCh,
    BOOL             fDataBinding)
{
    HRESULT           hr = S_OK;
    
    if (!pIPointerInsertHere)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Now, do the insert
    //
    
    hr = THR( InsertSanitizedText( pstrText, cCh, pIPointerInsertHere, _pMarkupServices, NULL, fDataBinding ) );

    if (hr)
        goto Cleanup;

Cleanup:
    
    RRETURN( hr );
}       

HRESULT
CHTMLEditor::UrlAutoDetectCurrentWord( 
    IMarkupPointer * pWord )
{
    HRESULT             hr;
    SP_IMarkupPointer   spWordInternal;

    if( !pWord )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( ConvertPointerToInternal( this, pWord, &spWordInternal) );
    
    IFC( GetAutoUrlDetector()->DetectCurrentWord( spWordInternal, NULL, NULL ) );
    
Cleanup:

    RRETURN( hr );
}

HRESULT
CHTMLEditor::UrlAutoDetectRange(
    IMarkupPointer * pStart,
    IMarkupPointer * pEnd )
{
    HRESULT             hr;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    if( !pStart || !pEnd )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    hr = THR( GetAutoUrlDetector()->DetectRange( spStartInternal, spEndInternal ) );
    if( hr )
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

    
HRESULT
CHTMLEditor::ShouldUpdateAnchorText (
        OLECHAR * pstrHref,
        OLECHAR * pstrAnchorText,
        BOOL    * pfResult )
{
    return ( GetAutoUrlDetector()->ShouldUpdateAnchorText (pstrHref, pstrAnchorText, pfResult ) );
}


HRESULT 
CHTMLEditor::LaunderSpaces ( 
    IMarkupPointer  * pStart,
    IMarkupPointer  * pEnd  )
{
    HRESULT             hr;
    CDeleteCommand      *pDeleteCommand;
    SP_IMarkupPointer   spStartInternal;
    SP_IMarkupPointer   spEndInternal;

    pDeleteCommand = (CDeleteCommand *) GetCommandTable()->Get( IDM_DELETE );
    Assert( pDeleteCommand );

    IFC( ConvertPointerToInternal( this, pStart, &spStartInternal) );
    IFC( ConvertPointerToInternal( this, pEnd, &spEndInternal) );

    IFC( pDeleteCommand->LaunderSpaces( spStartInternal, spEndInternal ) );

Cleanup:
    RRETURN(hr);
}    

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor IHTMLEditServices Implementation
//////////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AddDesigner
//
//  Synopsis:   This method adds a designer to the editor's current list of
//              designers.  A designer is a pluggable interface which allows
//              for third party interaction with our editor.
//
//  Arguments:  pIDesigner = Designer to add
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AddDesigner (
    IHTMLEditDesigner *pIDesigner )
{
    HRESULT hr = E_INVALIDARG;

    Assert( pIDesigner != NULL );

    if( (pIDesigner != NULL) && (_aryDesigners.Find( pIDesigner ) == -1) )
    {
        hr = _aryDesigners.Append( pIDesigner );
        pIDesigner->AddRef();
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::RemoveDesigner
//
//  Synopsis:   This method removes a designer from the editor's current 
//              list of designers.  A designer is a pluggable interface which 
//              allows for third party interaction with our editor.
//
//  Arguments:  pIDesigner = Designer to remove
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::RemoveDesigner (
    IHTMLEditDesigner *pIDesigner )
{
    HRESULT             hr = E_INVALIDARG;
    SP_IUnknown         spIDelUnk;          // IUnknown interface of designer to remove
    SP_IUnknown         spIUnknown;         // IUnknown interface of designer already added
    IHTMLEditDesigner   **pElem;   
    int                 i;
    BOOL                fFound = FALSE;
    
    Assert( pIDesigner != NULL );

    if( pIDesigner )
    {
        IFC( pIDesigner->QueryInterface( IID_IUnknown, (void **)&spIDelUnk ) );

        //
        // Make sure we use the IUnknown pointer for equality.
        //
        for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
             i > 0; 
             i--, pElem++ )
        {
            IFC( (*pElem)->QueryInterface( IID_IUnknown, (void **)&spIUnknown ) );

            if( spIUnknown == spIDelUnk )
            {
                (*pElem)->Release();
                _aryDesigners.DeleteByValue(*pElem);
                fFound = TRUE;
            }               
        }
    }

    hr = (fFound == TRUE) ? S_OK : E_INVALIDARG;

Cleanup:


    RRETURN( hr );
}


HRESULT
CHTMLEditor::InternalQueryStatus(
    const GUID * pguidCmdGroup,
    ULONG cCmds,
    OLECMD rgCmds[],
    OLECMDTEXT * pcmdtext)
{
    HRESULT hr = S_FALSE;

    Assert( cCmds == 1 );
    
    // Allow designers to handle the command, 
    // if none of the designers handle it, pass it on to the editor
    IFC( DesignerQueryStatus(pguidCmdGroup, &rgCmds[0], pcmdtext ));

Cleanup:
    RRETURN1(hr, S_FALSE);   
}    

HRESULT
CHTMLEditor::InternalExec(
    const GUID * pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut)
{
    HRESULT hr = S_FALSE;
    OLECMD  cmd;

    cmd.cmdID = nCmdID;

    // Check the designer, see if it even supports this command
    IFC(DesignerQueryStatus(pguidCmdGroup, &cmd, NULL));
    if (cmd.cmdf)
    {
        IFC(DesignerExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));
    }
    else
    {
        // Not supported, therefore, not handled
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}    

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Public Utilities
//////////////////////////////////////////////////////////////////////////////////


BOOL 
CHTMLEditor::IsContextEditable()
{ 
    return _pSelMan->IsContextEditable();
}

HRESULT CHTMLEditor::FindBlockElement(  IHTMLElement    *pElement, 
                                        IHTMLElement    **ppBlockElement )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spOldElement;
    BOOL                bBlockElement;
    SP_IHTMLElement     spCurrent;

    Assert( ppBlockElement && pElement );
    
    spCurrent = pElement;

    while( spCurrent )
    {
        hr = THR(IsBlockOrLayoutOrScrollable(spCurrent, &bBlockElement));
        if (FAILED(hr) || bBlockElement)
            goto Cleanup;
            
        spOldElement = spCurrent;
        IFC( GetParentElement( spOldElement, &spCurrent) );
    }

Cleanup:
    *ppBlockElement = spCurrent;
    if( *ppBlockElement != NULL )
        (*ppBlockElement)->AddRef();

    RRETURN(hr);        
}

HRESULT CHTMLEditor::FindCommonElement( IMarkupPointer      *pStart,
                                        IMarkupPointer      *pEnd,
                                        IHTMLElement        **ppElement,
                                        BOOL                fIgnorePhrase /* = FALSE */,
                                        BOOL                fStayInMarkup /* = FALSE */)
{
    HRESULT             hr;
    IMarkupPointer      *pLeft;
    IMarkupPointer      *pRight;
    INT                 iPosition;
    SP_IMarkupPointer   spCurrent;
    SP_IHTMLElement     spElement;
    
    Assert( ppElement );
    
    // init for error case
    *ppElement = NULL;

   
    //
    // Find right/left pointers
    //

    IFC( OldCompare( pStart, pEnd, &iPosition) );

    if (iPosition == SAME)
    {
        if( fStayInMarkup )
        {
            IFC( pStart->CurrentScope( &spElement ) );
        }
        else
        {
            IFC( CurrentScopeOrMaster( pStart, &spElement ) );
        }

        goto Cleanup;
    }
    else if (iPosition == RIGHT)
    {
        pLeft = pStart;     // weak ref
        pRight = pEnd;      // weak ref
    }
    else
    {
        pLeft = pEnd;       // weak ref
        pRight = pStart;    // weak ref
    }

    //
    // Walk the left pointer up until the right end of the element
    // is to the right of pRight.  Also, keep track of the master
    // element in case the first 
    //
    IFC( pLeft->CurrentScope(&spElement) );

    IFC( CreateMarkupPointer(&spCurrent) );

    while( spElement )
    {
        IFC( spCurrent->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeEnd) );

        if (fIgnorePhrase)
        {
            if (!IsPhraseElement(spElement))
            {
                IFC( OldCompare( spCurrent, pRight, &iPosition) );

                if( iPosition != RIGHT )
                {
                    // Retrieve the master element if we are not staying in the 
                    // markup
                    if( !fStayInMarkup )
                        IFC( CurrentScopeOrMaster( spCurrent, &spElement ) );

                    break;
                }
            }
        }
        else
        {
            IFC( OldCompare( spCurrent, pRight, &iPosition) );

            if (iPosition != RIGHT)
            {
                IFC( CurrentScopeOrMaster( spCurrent, &spElement ) );
                break;
            }
        }

        IFC( ParentElement( GetMarkupServices(), &(spElement.p) ) );
    }

Cleanup:

    *ppElement = spElement;

    if( *ppElement )
        (*ppElement)->AddRef();
    
    RRETURN(hr);
}

CSpringLoader *
CHTMLEditor::GetPrimarySpringLoader()
{
    if( _pActiveCommandTarget )
        return _pActiveCommandTarget->GetSpringLoader();
    else
        return NULL;
}

HRESULT 
CHTMLEditor::InsertElement(IHTMLElement *pElement, IMarkupPointer *pStart, IMarkupPointer *pEnd)
{
    RRETURN( EdUtil::InsertElement(GetMarkupServices(), pElement, pStart, pEnd) );
}

//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Compose Settings Methods
//////////////////////////////////////////////////////////////////////////////////

struct COMPOSE_SETTINGS *
CHTMLEditor::GetComposeSettings(BOOL fDontExtract /*=FALSE*/)
{
    if (!fDontExtract)
        CComposeSettingsCommand::ExtractLastComposeSettings(this, _pComposeSettings != NULL);

    return _pComposeSettings;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::EnsureComposeSettings
//
//  Synopsis:   This function ensures the allocation of the compose font buffer
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

COMPOSE_SETTINGS *
CHTMLEditor::EnsureComposeSettings()
{
    if (!_pComposeSettings)
    {
        _pComposeSettings = (struct COMPOSE_SETTINGS *)MemAllocClear(Mt(CHTMLEditor_pComposeSettings), sizeof(struct COMPOSE_SETTINGS));

        if (_pComposeSettings)
            _pComposeSettings->_fComposeSettings = FALSE;
    }

    return _pComposeSettings;
}




HRESULT     
CHTMLEditor::GetSiteContainer(
    IHTMLElement *          pStart,
    IHTMLElement **         ppSite,
    BOOL *                  pfText,             /*=NULL*/
    BOOL *                  pfMultiLine,        /*=NULL*/
    BOOL *                  pfScrollable )      /*=NULL*/
{
    HRESULT hr = E_FAIL;
    BOOL fSite = FALSE;
    BOOL fText = FALSE;
    BOOL fMultiLine = FALSE;
    BOOL fScrollable = FALSE;

    SP_IHTMLElement spElement;

    Assert( pStart != NULL && ppSite != NULL );
    if( pStart == NULL || ppSite == NULL )
        goto Cleanup;

    *ppSite = NULL;
    spElement = pStart;

    while( ! fSite && spElement != NULL )
    {
        VARIANT_BOOL fMulti = VARIANT_FALSE;
        SP_IHTMLElement3  spElement3;

        IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fSite, &fScrollable));
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        spElement3->get_isMultiLine(&fMulti);
        fMultiLine = !!fMulti;

        IFC(_pDisplayServices->HasFlowLayout(spElement, &fText));

        if( ! fSite )
        {
            SP_IHTMLElement  spParent;
            IFC( GetParentElement( spElement, &spParent ));
            spElement = spParent;
        }
    }
    
Cleanup:

    if( fSite )
    {
        hr = S_OK;
        
        *ppSite = spElement;
        (*ppSite)->AddRef();
        
        if( pfText != NULL )
            *pfText = fText;

        if( pfMultiLine != NULL )
            *pfMultiLine = fMultiLine;

        if( pfScrollable != NULL )
            *pfScrollable = fScrollable;
    }

    RRETURN( hr );
}

HRESULT
CHTMLEditor::GetBlockContainer(
    IHTMLElement *          pStart,
    IHTMLElement **         ppElement )
{
    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;
    SP_IHTMLElement spElement;

    Assert( pStart && ppElement );
    if( pStart == NULL || ppElement == NULL )
        goto Cleanup;

    *ppElement = NULL;
    spElement = pStart;

    while( ! fFound && spElement != NULL )
    {
        IFC(IsBlockOrLayoutOrScrollable(spElement, &fFound));
        
        if( ! fFound )
        {
            SP_IHTMLElement spParent;
            IFC( GetParentElement( spElement, &spParent ));
            spElement = spParent;
        }
    }
    
Cleanup:
    if( fFound )
    {
        hr = S_OK;
        *ppElement = spElement;
        (*ppElement)->AddRef();
    }
        
    RRETURN( hr );
}


HRESULT     
CHTMLEditor::GetSiteContainer(
    IMarkupPointer *        pPointer,
    IHTMLElement **         ppSite,
    BOOL *                  pfText,             /*=NULL*/
    BOOL *                  pfMultiLine,        /*=NULL*/
    BOOL *                  pfScrollable )      /*=NULL*/
{
    HRESULT hr = E_FAIL;
    SP_IHTMLElement spElement;

    Assert( pPointer != NULL && ppSite != NULL );
    if( pPointer == NULL || ppSite == NULL )
        goto Cleanup;

    IFC( CurrentScopeOrMaster( pPointer, &spElement ));
    
    if( spElement )
        IFC( GetSiteContainer( spElement, ppSite, pfText, pfMultiLine, pfScrollable ));
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditor::GetBlockContainer(
    IMarkupPointer *        pPointer,
    IHTMLElement **         ppElement )
{
    HRESULT hr = E_FAIL;
    SP_IHTMLElement spElement;

    Assert( pPointer != NULL && ppElement != NULL );
    if( pPointer == NULL || ppElement == NULL )
        goto Cleanup;

    IFC( pPointer->CurrentScope( &spElement ));
    
    if( spElement )
        IFC( GetBlockContainer( spElement, ppElement ));
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInDifferentEditableSite
//
// Synopsis: Are we in a different site-selectable object from the edit context
//
//------------------------------------------------------------------------------------


BOOL
CHTMLEditor::IsInDifferentEditableSite(IMarkupPointer* pPointer)
{
    HRESULT hr = S_OK;
    BOOL fDifferent = FALSE;
    IHTMLElement* pIFlowElement = NULL ;

    IFC( GetFlowElement( pPointer, & pIFlowElement ));
    if ( pIFlowElement )
    {
        if ( ! SameElements( 
                             pIFlowElement, 
                             GetSelectionManager()->GetEditableElement()) && 
            IsElementSiteSelectable( pIFlowElement) == S_OK  )
        {
            fDifferent = TRUE;
        }
    }
    
Cleanup:
    ReleaseInterface( pIFlowElement);
    
    return( fDifferent );
}

HRESULT
CHTMLEditor::AdjustPointer(
    IDisplayPointer         *pDispPointer,
    Direction               eBlockDir,
    Direction               eTextDir,
    IMarkupPointer *        pLeftBoundary,
    IMarkupPointer *        pRightBoundary,
    DWORD                   dwOptions /* = ADJPTROPT_None */ )
{
    HRESULT hr = S_OK;

    ELEMENT_TAG_ID eTag = TAGID_NULL;
    CEditPointer ep( this );        // allocate a new MP
    CEditPointer epSave( this );    // allocate a place saver
    BOOL fTextSite = FALSE;
    BOOL fBlockHasLayout = FALSE;
    BOOL fValidAdjustment= FALSE;
    DWORD dwSearch = 0;
    DWORD dwFound = 0;
    BOOL fStayOutOfUrl = ! CheckFlag( dwOptions , ADJPTROPT_AdjustIntoURL );    // If the adjust into url flag is not set, we stay out of the url
    BOOL fDontExitPhrase = CheckFlag( dwOptions , ADJPTROPT_DontExitPhrase ); // If the don't exit phrase flag is set, we don't exit phrase elements while adjusting to text
    BOOL fEnterTables    = CheckFlag( dwOptions , ADJPTROPT_EnterTables );      // if we want to enter the first cell of the table
    SP_IDisplayPointer spLineStart, spLineEnd;
    SP_IMarkupPointer spLeftBoundaryInternal;
    SP_IMarkupPointer spRightBoundaryInternal;
    
    SP_IHTMLElement spIBlock;
    SP_IHTMLElement spISite;        
    
    CEditPointer epTest(this);
    CEditPointer epLB(this);
    CEditPointer epRB(this);

    IFC( pDispPointer->PositionMarkupPointer(ep) );

    IFC( ConvertPointerToInternal( this, pLeftBoundary, &spLeftBoundaryInternal) );
    IFC( ConvertPointerToInternal( this, pRightBoundary, &spRightBoundaryInternal) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineStart) );
    IFC( spLineStart->MoveToPointer(pDispPointer) );
    IFC( spLineStart->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineEnd) );
    IFC( spLineEnd->MoveToPointer(pDispPointer) );
    IFC( spLineEnd->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );

    IFC( spLineStart->PositionMarkupPointer(epLB) );
    IFC( spLineEnd->PositionMarkupPointer(epRB));

    //
    // We always enter table from left
    //
    if (fEnterTables)
    {
        EnterTables(ep, RIGHT);
    }
    //
    // We want to be sure that the pointer is located inside a valid
    // site. For instance, if we are in a site that can't contain text,
    // trying to cling to text within that site is a waste of time.
    // In that case, we have to scan entering sites until we find one
    // that can contain text. If we can't find one going in our move 
    // direction, reverse and look the other way. By constraining 
    // using Scan and only entering layouts, we prevent many problems 
    // (especially with tables)
    //

    hr = THR( GetSiteContainer( ep, &spISite, &fTextSite ));

    //
    // We dont really allow typing in a select right now - so you're in the "right" 
    // place.
    //
    IFC( GetMarkupServices()->GetElementTagId( spISite, & eTag ));
    if ( eTag == TAGID_SELECT )
        goto Cleanup;
        
    //
    // Is our pointer within a text site?
    //

    if( ! fTextSite )
    {
        hr = AdjustIntoTextSite( ep, eBlockDir );
        
        if( FAILED( hr ))
        {
            hr = AdjustIntoTextSite( ep, Reverse( eBlockDir ));
        }
        
        if( FAILED( hr ))
        {
            hr = E_FAIL;
            goto Cleanup;
        }     
        
        // Our line may have moved
        IFC( spLineStart->MoveToPointer(pDispPointer) );
        IFC( spLineStart->MoveToMarkupPointer(ep, NULL) );
        IFC( spLineStart->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

        IFC( spLineEnd->MoveToPointer(pDispPointer) );
        IFC( spLineEnd->MoveToMarkupPointer(ep, NULL) );
        IFC( spLineEnd->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineEnd, -1) );

        IFC( spLineStart->PositionMarkupPointer(epLB) );
        IFC( spLineEnd->PositionMarkupPointer(epRB) );
    }

    //
    // Constrain the pointer
    //
    
    if( spLeftBoundaryInternal )
    {
        BOOL fAdj = FALSE;
        IFC( spLeftBoundaryInternal->IsRightOf( epLB, &fAdj ));

        if( fAdj )
            IFC( epLB->MoveToPointer( spLeftBoundaryInternal ));
    }

    if( spRightBoundaryInternal )
    {
        BOOL fAdj = FALSE;
        IFC( spRightBoundaryInternal->IsLeftOf( epRB, &fAdj ));

        if( fAdj )
            IFC( epRB->MoveToPointer( spRightBoundaryInternal ));
    }        
    
    IFC( ep.SetBoundary( epLB, epRB ));
    IFC( ep.Constrain() );
    
    //
    // Now that we are assured that we are in a nice cozy text site, we would
    // like to be in a block element, if possible.
    //
    hr = THR( GetBlockContainer( ep, &spIBlock ));
    
    if( spIBlock )
    {
        IFC( _pMarkupServices->GetElementTagId( spIBlock, &eTag ));
        IFC(IsBlockOrLayoutOrScrollable(spIBlock, NULL, &fBlockHasLayout));
    }

    if( FAILED( hr ) || spIBlock == NULL || IsNonTextBlock( eTag ) || fBlockHasLayout )
    {
        BOOL fHitText = FALSE;
        
        hr = AdjustIntoBlock( ep, eBlockDir, &fHitText, TRUE, epLB, epRB );
        
        if( FAILED( hr ))
        {
            hr = AdjustIntoBlock( ep, Reverse( eBlockDir ), &fHitText, FALSE, epLB, epRB );
        }
        
        if( FAILED( hr ))
        {
            // Not so bad. Just cling to text...
            hr = S_OK;
        }
        
        if( fHitText )
        {
            goto Done;
        }
    }

    //
    // If we are block adjusting left, we can move exactly one NoscopeBlock to the left
    //
    
    if( eBlockDir == LEFT )
    {
        IFC( epSave.MoveToPointer( ep ));
        dwSearch =  BREAK_CONDITION_OMIT_PHRASE;
        dwFound = BREAK_CONDITION_None;

        hr = THR( ep.Scan( LEFT, dwSearch, &dwFound ));

        if( ! ep.CheckFlag( dwFound , BREAK_CONDITION_NoScopeBlock))
        {
            IFC( ep.MoveToPointer( epSave ));
        }

    }


Done:

    //
    // Search for text
    //
    IFC( epTest->MoveToPointer(ep) );
    IFC( AdjustIntoPhrase(epTest, eTextDir, fDontExitPhrase) );
    IFC( IsValidAdjustment(ep, epTest, &fValidAdjustment) );
    if (fValidAdjustment)
    {
        ep->MoveToPointer(epTest);
    }

    //
    // See if we need to exit from an URL boundary
    //

    IFC( epTest->MoveToPointer(ep) );
    IFC( epTest.Scan(LEFT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
    eTextDir = LEFT; // remember the direction of scan
    
    if (!epTest.CheckFlag(dwFound,  BREAK_CONDITION_ExitAnchor))
    {
        IFC( epTest->MoveToPointer(ep) );
        IFC( epTest.Scan(RIGHT, BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
        eTextDir = RIGHT ;// remember the direction of scan
    }
    
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_ExitAnchor))
    {
        if (!fStayOutOfUrl)
        {
            CEditPointer epText(this);
            
            // Make sure we are adjacent to text
            IFC( epText->MoveToPointer(ep) );
            IFC( epText.Scan(Reverse(eTextDir), BREAK_CONDITION_OMIT_PHRASE, &dwFound) );
            
            fStayOutOfUrl = !epText.CheckFlag(dwFound, BREAK_CONDITION_Text)
                            && !epText.CheckFlag(dwFound, BREAK_CONDITION_Anchor);
        }
        if (fStayOutOfUrl)
        {
            // Move into adjacent phrase elements if we can       
            IFC( AdjustIntoPhrase(epTest, eTextDir, fDontExitPhrase) );
            IFC( IsValidAdjustment(ep, epTest, &fValidAdjustment) )
            if (fValidAdjustment)
            {
                IFC( ep->MoveToPointer(epTest) );
            }
            
        }
    }

    IFC( pDispPointer->MoveToMarkupPointer(ep, NULL));
        
Cleanup:

    RRETURN( hr );
}


//
// HACKHACK: We don't want to stay out of URL/Phrase if we have adjust to a 
// different line. If we do, caret will get stuck since <A>/<B>/<I>/etc. 
// their content might be in different lines due to 
// our current line-breaking behaviours. See Bug #96038 for more details.
// In the future, if line-breaking is more intelligent, we might be 
// able to remove this hacking.  (zhenbinx)
//
//
HRESULT     
CHTMLEditor::IsValidAdjustment(
            IMarkupPointer  *pPointer,
            IMarkupPointer  *pAdjustedPointer,
            BOOL            *fValid
            )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spLinePointer, spLineAdjusted;

    //
    //       This function might not work in ambiguious position case 
    //       since the display pointer does not have gravity information.
    //       However this is not a problem since the display pointer has
    //       to adjust to that position anyway. 
    //

    //
    // Move to current line
    //
    IFC( GetDisplayServices()->CreateDisplayPointer(&spLinePointer) );
    IFC( spLinePointer->MoveToMarkupPointer(pPointer, NULL) );
    IFC( spLinePointer->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) )

    IFC( GetDisplayServices()->CreateDisplayPointer(&spLineAdjusted) );
    IFC( spLineAdjusted->MoveToMarkupPointer(pAdjustedPointer, NULL) );
    IFC( spLineAdjusted->MoveUnit(DISPLAY_MOVEUNIT_CurrentLineStart, -1) );

    //
    // We only do adjustment if they are in the same line
    //
    IFC( spLineAdjusted->IsEqualTo(spLinePointer, fValid) );

Cleanup:
    RRETURN(hr);
}



HRESULT
CHTMLEditor::AdjustIntoTextSite(
    IMarkupPointer  *pPointer,
    Direction       eDir )
{
    HRESULT hr = E_FAIL;
    BOOL fDone = FALSE;
    BOOL fFound = FALSE;
    DWORD dwSearch = BREAK_CONDITION_Site;
    DWORD dwFound = BREAK_CONDITION_None;
    
    CEditPointer ep( this );
    SP_IHTMLElement spISite;

    Assert( pPointer );
    
    IFC( ep.MoveToPointer( pPointer ));
    
    while( ! fDone && ! fFound )
    {
        dwFound = BREAK_CONDITION_None;
        hr = THR( ep.Scan( eDir, dwSearch, &dwFound ));

        if( ep.CheckFlag( dwFound, BREAK_CONDITION_Site ))
        {
            // Did we enter a text site in the desired direction?
            hr = THR( GetSiteContainer( ep, &spISite, &fFound ));
        }
        else
        {
            // some other break condition, we are done
            fDone = TRUE;
        }
    }

Cleanup:
    if( fFound )
    {
        hr = THR( pPointer->MoveToPointer( ep ));
    }
    else
    {
        hr = E_FAIL;
    }
    
    return( hr );
}    


HRESULT
CHTMLEditor::AdjustIntoBlock(
    IMarkupPointer *        pPointer,
    Direction               eDir,
    BOOL *                  pfHitText,
    BOOL                    fAdjustOutOfBody,
    IMarkupPointer *        pLeftBoundary,
    IMarkupPointer *        pRightBoundary )
{
    HRESULT hr = E_FAIL;

    // Stop if we hit text, enter or exit a site, or
    // hit an intrinsic control. If we enter or exit
    // a block, make sure we didn't "leave" the current 
    // line.

    BOOL fDone = FALSE;
    BOOL fFound = FALSE;
    BOOL fHitText = FALSE;
    
    DWORD dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD dwFound = BREAK_CONDITION_None;
    ELEMENT_TAG_ID eTag = TAGID_NULL;
    TCHAR chFound = 0;
            
    CEditPointer ep( this );
    SP_IHTMLElement spIBlock;
    
    Assert( pPointer && pfHitText );
    if( pPointer == NULL || pfHitText == NULL )
        goto Cleanup;
        
    IFC( ep.MoveToPointer( pPointer ));
    IFC( ep.SetBoundary( pLeftBoundary, pRightBoundary ));
    IFC( ep.Constrain() );

    while( ! fDone )
    {
        dwFound = BREAK_CONDITION_None;
        IFC( ep.Scan( eDir , dwSearch, &dwFound, NULL, NULL, &chFound, NULL ));

        //
        // Did we hit text or a text like object?
        //

        if( ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
        {
            LONG                lChars = 1;
            MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;

            hr = THR( ep.Move( Reverse( eDir ), TRUE, &eCtxt, NULL, &lChars, NULL ));
            
            if( hr == E_HITBOUNDARY )
            { 
                fDone = TRUE;
                goto Cleanup;
            }
            
            IFC( pPointer->MoveToPointer( ep ));

            fHitText = TRUE;
            fFound = TRUE;
            fDone = TRUE;
            
            Assert( ! FAILED( hr ));
            
            goto Cleanup;
        }

        //
        // Did we hit a site boundary?
        //
        
        else if( ep.CheckFlag( dwFound, BREAK_CONDITION_Site ))
        {
            fDone = TRUE;
        }

        //
        // Did we enter a block?
        //
        
        else if( ep.CheckFlag( dwFound , BREAK_CONDITION_EnterBlock ))
        {   
            // Entered a Block
            hr = THR( GetBlockContainer( ep, &spIBlock ));

            if(( ! FAILED( hr )) && ( spIBlock != NULL ))
            {
                IFC( _pMarkupServices->GetElementTagId( spIBlock, &eTag ));

                if(( ! IsNonTextBlock( eTag )) && ( ! ( fAdjustOutOfBody && eTag == TAGID_BODY )))
                {
                    // found a potentially better block - check to see if eitehr breakonempty is set or the block contains text
                    VARIANT_BOOL fBOESet = VARIANT_FALSE;
                    SP_IHTMLElement3 spElement3;
                    IFC( spIBlock->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                    IFC( spElement3->get_inflateBlock( &fBOESet ));

                    if( fBOESet )
                    {
                        // it really is better - move our pointer there and set the sucess flag!!!
                        IFC( pPointer->MoveToPointer( ep ));
                        fFound = TRUE; // but, keep going!
                    }

                    // if BOE is not set, we have to keep going to determine if the block has content
                }
            }
            else
            {
                // didn't find a better block and we can go no farther... we are probably in the root
                fDone = TRUE;
            }
        }

        //
        // Did we exit a block - probably not a good sign, but we should keep going for now...
        //
        
        else if( ep.CheckFlag( dwFound, BREAK_CONDITION_ExitBlock ))
        {
            // we just booked out of a block element. things may be okay
        }

        else // hit something like boundary,  or error 
        {
            fDone = TRUE;
        }
    }

Cleanup:
    
    if( pfHitText )
    {
        *pfHitText = fHitText;
    }

    if( ! fFound )
        hr = E_FAIL;
    
    return( hr );
}

HRESULT
CHTMLEditor::AdjustIntoPhrase(IMarkupPointer  *pPointer, Direction eTextDir, BOOL fDontExitPhrase )
{
    HRESULT         hr;
    DWORD           dwFound;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;        
    
    CEditPointer    epSave(this);
    CEditPointer    ep(this, pPointer);

    if( fDontExitPhrase )
    {
        dwSearch = dwSearch + BREAK_CONDITION_ExitPhrase;
    }
    
    IFC( epSave.MoveToPointer( ep ));    
    hr = THR( ep.Scan( eTextDir, dwSearch, &dwFound ));    
                        
    if( ! ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
    {
        //
        // We didn't find any text, lets look the other way
        //

        eTextDir = Reverse( eTextDir ); // Reverse our direction, keeping track of which way we are really going        
        IFC( ep.MoveToPointer( epSave )); // Go back to where we started...
        hr = THR( ep.Scan( eTextDir, dwSearch, &dwFound ));
    }

    if( ep.CheckFlag( dwFound , BREAK_CONDITION_TEXT ))
    {
        //
        // We found something, back up one space
        //
    
        LONG lChars = 1;
        MARKUP_CONTEXT_TYPE eCtxt = CONTEXT_TYPE_None;
        hr = THR( ep.Move( Reverse( eTextDir ), TRUE, &eCtxt, NULL, &lChars, NULL ));
        if( hr == E_HITBOUNDARY )
        {
            Assert( hr != E_HITBOUNDARY );
            goto Cleanup;
        }

    }
    else
    {
        IFC( ep.MoveToPointer(epSave) );
    }

Cleanup:
    RRETURN(hr);
}    

BOOL     
CHTMLEditor::IsNonTextBlock(
    ELEMENT_TAG_ID          eTag )
{
    BOOL fIsNonTextBlock = FALSE;
        
    switch( eTag )
    {
        case TAGID_NULL:
        case TAGID_UL:
        case TAGID_OL:
        case TAGID_DL:
        case TAGID_DIR:
        case TAGID_MENU:
        case TAGID_FORM:
        case TAGID_FIELDSET:
        case TAGID_TABLE:
        case TAGID_THEAD:
        case TAGID_TBODY:
        case TAGID_TFOOT:
        case TAGID_COL:
        case TAGID_COLGROUP:
        case TAGID_TC:
        case TAGID_TH:
        case TAGID_TR:
            fIsNonTextBlock = TRUE;        
            break;
       
        default:
            fIsNonTextBlock = FALSE;
    }
    
    return( fIsNonTextBlock );    
}

TCHAR *
CHTMLEditor::GetCachedString(UINT uiStringId)
{
    TCHAR *pchResult = NULL;

    if (_pStringCache)
    {
        pchResult = _pStringCache->GetString(uiStringId);
    }

    return pchResult;
}


HRESULT
CHTMLEditor::RemoveEmptyCharFormat(IMarkupServices *pMarkupServices, IHTMLElement **ppElement, BOOL fTopLevel, CSpringLoader *psl)
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spLeft;
    SP_IMarkupPointer   spRight;
    SP_IMarkupPointer   spWalk;
    ELEMENT_TAG_ID      tagId;
    BOOL                bEqual;
    BOOL                bHeading = FALSE;
    SP_IHTMLElement     spNewElement;

    IFC( pMarkupServices->GetElementTagId(*ppElement, &tagId) );
    
    switch (tagId)
    {
    case TAGID_H1:
    case TAGID_H2:
    case TAGID_H3:
    case TAGID_H4:
    case TAGID_H5:
    case TAGID_H6:
        if (!fTopLevel)
            goto Cleanup; // don't try heading reset if not in top level

        bHeading = TRUE;
        // fall through

    case TAGID_B:
    case TAGID_STRONG:
    case TAGID_U:
    case TAGID_EM:
    case TAGID_I:
    case TAGID_FONT:
    case TAGID_STRIKE:
    case TAGID_SUB:
    case TAGID_SUP:

        IFC( CreateMarkupPointer2(this, &spLeft) );
        IFC( spLeft->MoveAdjacentToElement(*ppElement, ELEM_ADJ_AfterBegin ) );

        IFC( CreateMarkupPointer2(this, &spRight) );
        IFC( spRight->MoveAdjacentToElement(*ppElement, ELEM_ADJ_BeforeEnd ) );

        IFC( spLeft->IsEqualTo(spRight, &bEqual) );

        //
        // If the pointers are not equal, allow one nbsp to be inside.
        //

        if (!bEqual)
        {
            MARKUP_CONTEXT_TYPE mctContext;
            long                cch = 1; // Walk one character at a time.
            TCHAR               ch;

            IFC( CreateMarkupPointer2(this, &spWalk) );
            IFC( spWalk->MoveToPointer(spLeft) );

            IFC( spWalk->Right(TRUE, &mctContext, NULL, &cch, &ch) );
            if (   mctContext == CONTEXT_TYPE_Text
                && cch && WCH_NBSP == ch )
            {
                IFC( spWalk->IsEqualTo(spRight, &bEqual) );
            }
        }

        if (bEqual)
        {
            if (bHeading)
            {
                IFC( CGetBlockFmtCommand::GetDefaultBlockTag(pMarkupServices, &tagId) );
                IFC( pMarkupServices->CreateElement(tagId, NULL, &spNewElement) );

                // We want the left pointer to end up inside the new element.
                // (bug 91683)
                IFC( spLeft->SetGravity(POINTER_GRAVITY_Right) );
                
                IFC( ReplaceElement(this, *ppElement, spNewElement, spLeft, spRight) );

                ReplaceInterface(ppElement, (IHTMLElement *)spNewElement);

                if (psl)
                {
                    IGNORE_HR( psl->SpringLoadComposeSettings(spLeft, TRUE) );
                }
            }   
            else
            {
                BOOL        fIsBlockElement = FALSE;

                //  Bug 25006: A formatting element, such as a <EM> could have style="display:block"
                //  making it a block element.  We don't want to remove the element if it is a block
                //  element.

                IFC( IsBlockOrLayoutOrScrollable(*ppElement, &fIsBlockElement) );
                if (!fIsBlockElement)
                {
                    IFC( pMarkupServices->RemoveElement(*ppElement) );
                    hr = S_FALSE;
                }
            }

        }
        break;

    default:
         hr = S_OK; // nothing to remove
    }    

Cleanup:    
    RRETURN1(hr, S_FALSE);
}

HRESULT
CHTMLEditor::HandleEnter(
    IMarkupPointer  *pCaret, 
    IMarkupPointer  **ppInsertPosOut,
    CSpringLoader   *psl       /* = NULL */,
    BOOL             fExtraDiv /* = FALSE */)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement     spNewElement;
    SP_IHTMLElement     spDivElement;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;
    SP_IHTMLElement     spCurElement;
    SP_IHTMLElement3    spElement3;
    ELEMENT_TAG_ID      tagId;
    ELEMENT_TAG_ID      tagIdDefaultBlock = TAGID_NULL;
    SP_IObjectIdentity  spIdent;
    BOOL                bListMode = FALSE;
    
    if (ppInsertPosOut)
        *ppInsertPosOut = NULL;

    //
    // Create helper pointers
    //

    IFC( CreateMarkupPointer(&spStart) );
    IFC( CreateMarkupPointer(&spEnd) );

    //
    // Walk up to get the block element
    //
    
    IFC( pCaret->CurrentScope(&spElement) );
    IFC( FindListItem(GetMarkupServices(), spElement, &spBlockElement) );
    if (spBlockElement)
    {
        bListMode = TRUE;

        //
        // Load the spring loader before processing the enter key to 
        // copy formats down
        //
        if (psl)
        {
            IFC( psl->SpringLoad(pCaret, SL_TRY_COMPOSE_SETTINGS) );
        }
    }
    else
    {
        CBlockPointer       bpCurrent(this);
        SP_IMarkupPointer   spTest;
        BOOL                bEqual;

        IFC( pCaret->CurrentScope(&spElement) );                       
        IFC( FindOrInsertBlockElement(spElement, &spBlockElement, pCaret, TRUE) );

        //
        // Load the spring loader before processing the enter key to 
        // copy formats down
        //
        if (psl)
        {
            IFC( psl->SpringLoad(pCaret, SL_TRY_COMPOSE_SETTINGS) );
        }

        // If we are not after begin or before end, it is safe to flatten
        IFC( CreateMarkupPointer(&spTest) );
        IFC( spTest->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_AfterBegin) );
        
        IFC( spTest->IsEqualTo(pCaret, &bEqual) );
        if (!bEqual)
        {
            IFC( spTest->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_BeforeEnd) );
            IFC( spTest->IsEqualTo(pCaret, &bEqual) );
            if (!bEqual)
            {
                // We need to flatten the block element so we don't introduce overlap
                IFC( bpCurrent.MoveTo(spBlockElement) );
                if (bpCurrent.GetType() == NT_Block)
                {
                    // we need a pointer with right gravity but we can't change the gravity of the input pointer
                    IFC( bpCurrent.FlattenNode() );
            
                    IFC( pCaret->CurrentScope(&spElement) );
                    IFC( FindOrInsertBlockElement(spElement, &spBlockElement, pCaret) );            
                }
            }
        }        
    }
   
    
    //
    //
    // Split the block element and all contained elements
    // Except Anchors
    //
    
    IFC( spBlockElement->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
    IFC( pCaret->CurrentScope(&spCurElement) );

    //
    // fExtraDiv works when the default block element is a DIV.
    // Refer to comment farther down for more information.
    //
    if ( fExtraDiv )
    {
        IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagIdDefaultBlock));
    }
    
    for (;;)
    {                    
        IFC( spStart->MoveAdjacentToElement(spCurElement, ELEM_ADJ_AfterBegin) );
        IFC( spEnd->MoveAdjacentToElement(spCurElement, ELEM_ADJ_BeforeEnd) );
        IFC( GetMarkupServices()->GetElementTagId(spCurElement, &tagId) );        
        IFC( CCommand::SplitElement(GetMarkupServices(), spCurElement, spStart, pCaret, spEnd, & spNewElement) );
        IGNORE_HR( spNewElement->removeAttribute(L"id", NULL, 0) );
        
        IFC( pCaret->MoveAdjacentToElement(spNewElement, ELEM_ADJ_BeforeBegin) );
        IFC( GetMarkupServices()->GetElementTagId(spNewElement, &tagId) );

        switch (tagId)
        {
            case TAGID_A:
                //
                // If we are splitting the anchor in the middle or end, the first element remains
                // an anchor while the second does not.  If we split the anchor at the start,
                // the second element remains an anchor while the first is deleted.
                //

                if (DoesSegmentContainText(spStart, pCaret))
                {
                    IFC( GetMarkupServices()->RemoveElement( spNewElement ));
                    spNewElement = NULL;

                    if (psl)
                    {
                        IFC( psl->SpringLoad(pCaret, SL_RESET | SL_TRY_COMPOSE_SETTINGS) );
                    }
                }
                else
                {
                    IFC( GetMarkupServices()->RemoveElement( spCurElement ));
                    spCurElement = NULL;
                }
                break;

            case TAGID_DIV:
                //
                // If the split block element was a div, and fExtraDiv
                // is TRUE, then (because naked divs have no inter-block 
                // spacing) insert am empty div to achieve the empty line effect.
                //
                if ( fExtraDiv && tagIdDefaultBlock == TAGID_DIV)
                {
                    // We correctly assume that pCaret is before the inserted element
                    IFC( GetMarkupServices()->CreateElement( TAGID_DIV, NULL, &spDivElement ));                    
                    IFC( InsertElement(spDivElement, pCaret, pCaret ));
                }
        
                IFC( spNewElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                break;                

            case TAGID_P:
            case TAGID_BLOCKQUOTE:
                IFC( spNewElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
                IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );
                break;

            case TAGID_LI:
                IFC( spNewElement->removeAttribute(_T("value"), 0, NULL) )
                break;
        }    
        
        if( spNewElement != NULL && psl )
        {
            if (spCurElement != NULL)
                hr = spIdent->IsEqualObject(spCurElement);
            else
                hr = S_FALSE; // can't be top level if we deleted it
            
            IFC( RemoveEmptyCharFormat(GetMarkupServices(), &(spNewElement.p), (hr == S_OK), psl) ); // pNewElement may morph
        }
        else
        {
            hr = S_OK;
        }
        
        if( spNewElement != NULL && S_OK == hr )
        {
            SP_IMarkupPointer spNewCaretPos;

            IFC( CreateMarkupPointer(&spNewCaretPos) );
            IFC( spNewCaretPos->MoveAdjacentToElement(spNewElement, ELEM_ADJ_AfterBegin) );
            IFC( LaunderSpaces(spNewCaretPos, spNewCaretPos) );
            
            if (ppInsertPosOut && !(*ppInsertPosOut))
            {
                IFC( CreateMarkupPointer(ppInsertPosOut) );
                IFC( (*ppInsertPosOut)->MoveToPointer(spNewCaretPos) );
            }
        }

        if (spCurElement != NULL)
        {
            hr = spIdent->IsEqualObject(spCurElement);
            if (S_OK == hr)
                break;
        }
        
        IFC( pCaret->CurrentScope(&spCurElement) );        
    } 

    Assert(spNewElement != NULL); // we must exit by hitting the block element
        
Cleanup:

    // We should have found a new position for the caret while walking up
    AssertSz(ppInsertPosOut == NULL || (*ppInsertPosOut), "Can't find new caret position");
    RRETURN(hr);    
}

IMarkupPointer* 
CHTMLEditor::GetStartEditContext()
{
    return _pSelMan->GetStartEditContext();
}

IMarkupPointer*
CHTMLEditor::GetEndEditContext()
{
    return _pSelMan->GetEndEditContext();
}

HRESULT
CHTMLEditor::IsInEditContext(   IMarkupPointer  *pPointer, 
                                BOOL            *pfInEdit,
                                BOOL            fCheckContainer /* = FALSE */)
{
    Assert(_pSelMan != NULL);
    if ( ! _pSelMan )
    {
        return( E_FAIL );
    }
    return _pSelMan->IsInEditContext( pPointer, pfInEdit, fCheckContainer );
}


HRESULT
CHTMLEditor::DesignerPreHandleEvent( DISPID inDispId, IHTMLEventObj * pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PreHandleEvent( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}


HRESULT
CHTMLEditor::DesignerPostEditorEventNotify( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 ); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PostEditorEventNotify( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}


HRESULT
CHTMLEditor::DesignerPostHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->PostHandleEvent( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}

HRESULT
CHTMLEditor::DesignerTranslateAccelerator( DISPID inDispId, IHTMLEventObj* pIObj  )
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;

    Assert( pIObj != NULL );
    
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && hr == S_FALSE); 
         i--, pElem++ )
    {
        IFC( (*pElem)->TranslateAccelerator( inDispId, pIObj ) );
    }

Cleanup:

    return hr;
}

HRESULT
CHTMLEditor::DesignerQueryStatus(
    const GUID * pguidCmdGroup,
    OLECMD *rgCmd,
    OLECMDTEXT * pcmdtext)
{
    HRESULT             hr = S_OK;
    IHTMLEditDesigner   **pElem;
    int                 i;
    IOleCommandTarget *pCmdTarget=NULL;
    BOOL bHandled = FALSE;
   
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         (i > 0 && bHandled == FALSE); 
         i--, pElem++ )
    {
        rgCmd->cmdf = 0;

        hr = THR( (*pElem)->QueryInterface(IID_IOleCommandTarget, (void **) &pCmdTarget));
        if (FAILED(hr) || pCmdTarget==NULL)
        {
            hr = S_OK;                        // This designer doesn't handle 'any' command!
            ReleaseInterface(pCmdTarget);
            continue;
        }
            
        hr = THR( pCmdTarget->QueryStatus(pguidCmdGroup, 1, rgCmd, pcmdtext) );
        if (SUCCEEDED(hr))
        {
            if (rgCmd->cmdf)                   // Supported
                bHandled = TRUE;
        }                
        ReleaseInterface(pCmdTarget);
    }
    return hr;
}
                    
HRESULT
CHTMLEditor::DesignerExec(
    const GUID * pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut)
{
    HRESULT             hr = S_FALSE;
    IHTMLEditDesigner   **pElem;
    int                 i;
    IOleCommandTarget *pCmdTarget=NULL;
    BOOL                bDone = FALSE;
    for( i = _aryDesigners.Size(), pElem = _aryDesigners; 
         i > 0 && !bDone; 
         i--, pElem++ )
    {
        hr = THR( (*pElem)->QueryInterface(IID_IOleCommandTarget, (void **) &pCmdTarget));
        if (FAILED(hr) || pCmdTarget==NULL)
        {
            ReleaseInterface(pCmdTarget);
            continue;
        }

        OLECMD oleCmd;
        oleCmd.cmdID = nCmdID;
        oleCmd.cmdf = 0;
        IFC(pCmdTarget->QueryStatus(pguidCmdGroup, 1, &oleCmd, NULL)); 
        // If this designer supports this command, then let it
        // execute the command
        if ((oleCmd.cmdf & OLECMDF_SUPPORTED) && (oleCmd.cmdf & OLECMDF_ENABLED))
        {
            bDone = TRUE;
            hr = THR( pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut) );
        }
        
        ReleaseInterface(pCmdTarget);        
    }

Cleanup:
    return hr;
}


//////////////////////////////////////////////////////////////////////////////////
// CHTMLEditor Private Methods
//////////////////////////////////////////////////////////////////////////////////



HRESULT 
CHTMLEditor::FindOrInsertBlockElement( IHTMLElement     *pElement, 
                                       IHTMLElement     **ppBlockElement,
                                       IMarkupPointer   *pCaret /* = NULL */,
                                       BOOL             fStopAtBlockquote /* = FALSE */ )
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spParentElement;
    CEditPointer        epLeft(this);
    CEditPointer        epRight(this);
    SP_IHTMLElement     spBlockElement;
    SP_IHTMLElement3    spElement3;
    BOOL                bBlockElement;
    BOOL                bLayoutElement;
    ELEMENT_TAG_ID      tagId;

    spBlockElement = pElement;

    do
    {
        IFC(IsBlockOrLayoutOrScrollable(spBlockElement, &bBlockElement, &bLayoutElement));
        if (bLayoutElement)
            break; // need to insert below
                    
        IFC( GetMarkupServices()->GetElementTagId(spBlockElement, &tagId) );
        if (tagId == TAGID_FORM || fStopAtBlockquote && tagId == TAGID_BLOCKQUOTE)
            break; // need to insert below

        if (bBlockElement)
            goto Cleanup; // done

        IFC( GetParentElement( spBlockElement, &spParentElement) );
        
        if (spParentElement != NULL)
            spBlockElement = spParentElement;
    }
    while (spParentElement != NULL);


    //
    // Need to insert a block element
    //

    if (pCaret)
    {
        DWORD           dwSearch = BREAK_CONDITION_Block | BREAK_CONDITION_Site;
        DWORD           dwFound;
        SP_IHTMLElement spElement;

        // Expand left
        IFC( epLeft->MoveToPointer(pCaret) );
        for (;;)
        {
            IFC( epLeft.Scan(LEFT, dwSearch, &dwFound, &spElement) );
            if (epLeft.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_ExitSite))
            {
                IFC( epLeft.Scan(RIGHT, dwSearch, &dwFound) );
                break; // done
            }

            // Now, we have a site which is not a block.  So, we must skip the site and continue
            // scanning

            Assert(epLeft.CheckFlag(dwFound, BREAK_CONDITION_Site));
            IFC( epLeft->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );            
        }

        // Expand right
        IFC( epRight->MoveToPointer(pCaret) );
        for (;;)
        {
            IFC( epRight.Scan(RIGHT, dwSearch, &dwFound, &spElement) );
            if (epRight.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_ExitSite))
            {
                IFC( epRight.Scan(LEFT, dwSearch, &dwFound) );
                break;
            }

            // Now, we have a site which is not a block.  So, we must skip the site and continue
            // scanning

            Assert(epRight.CheckFlag(dwFound, BREAK_CONDITION_Site));
            IFC( epRight->MoveAdjacentToElement(spElement, ELEM_ADJ_AfterEnd) );            
        }
    }
    else
    {
        // Just use the block element as the boundary
        IFC( epLeft->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_AfterBegin) );
        IFC( epRight->MoveAdjacentToElement(spBlockElement, ELEM_ADJ_BeforeEnd) );        
    }

    IFC( CGetBlockFmtCommand::GetDefaultBlockTag(GetMarkupServices(), &tagId) );
    IFC( GetMarkupServices()->CreateElement(tagId, NULL, &spBlockElement) );
    IFC( spBlockElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3) );
    IFC( spElement3->put_inflateBlock( VARIANT_TRUE ) );

    if (pCaret)
    {
        IFC( InsertBlockElement(GetMarkupServices(), spBlockElement, epLeft, epRight, pCaret) );
    }
    else
    {
        IFC( InsertElement(spBlockElement, epLeft, epRight) );
    }        

Cleanup:  
    if (ppBlockElement)
    {
        *ppBlockElement = spBlockElement;
        if (spBlockElement != NULL)
            spBlockElement->AddRef();
    }

    RRETURN(hr);
}


HRESULT
CHTMLEditor::IsPhraseElement(IHTMLElement *pElement)
{
    HRESULT hr;
    BOOL fBlock, fLayout;

    // Make sure the element is not a site or block element
    IFC(IsBlockOrLayoutOrScrollable(pElement, &fBlock, &fLayout));
    if (fLayout || fBlock)
        return FALSE;
        
    return TRUE;

Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: MovePointersToEquivalentContainers
//
// Synopsis: Move markup pointers that are in separate IMarkupContainers to the same markup containers
//           for the purposes of comparison. 
//
//           Done by drilling piInner up until you're in pIOuter (or you fail).
//
// RETURN:
//           S_OK if the inner pointer was able to be moved into the container of the OUTER
//           S_FALSE if this wasn't possible.
//------------------------------------------------------------------------------------

HRESULT CHTMLEditor::MovePointersToEqualContainers( IMarkupPointer  *pIInner,
                                                    IMarkupPointer  *pIOuter )
{
    HRESULT             hr = S_FALSE;
    SP_IMarkupContainer spIInnerMarkup;
    SP_IMarkupContainer spIOuterMarkup;
    SP_IMarkupContainer spIInnerDrill;
    SP_IHTMLElement     spIElement;
    BOOL                fDone = FALSE;    

    // Get the inner and outer containers, and a working
    // copy of the inner container (for drilling up)
    IFC( pIInner->GetContainer( &spIInnerMarkup ));
    IFC( pIOuter->GetContainer( &spIOuterMarkup ));

    spIInnerDrill = spIInnerMarkup;

    Assert( !EqualContainers( spIInnerDrill, spIOuterMarkup ));

    while( fDone == FALSE )
    {
        // See if we are in the right container
        if( !EqualContainers( spIInnerDrill, spIOuterMarkup ))
        {
            // Retrieve the current scope, or the master element, and move
            // our inner pointer before the beginning
            IFC( CurrentScopeOrMaster(pIInner, &spIElement));      
            IFC( pIInner->MoveAdjacentToElement( spIElement, ELEM_ADJ_BeforeBegin ));

            // Get our new container. and check to make sure it is 
            // different than our original container
            IFC( pIInner->GetContainer( &spIInnerDrill ));

            if( EqualContainers( spIInnerMarkup, spIInnerDrill ) )
            {
                fDone = TRUE;
            }

            spIInnerMarkup = spIInnerDrill;
        }
        else
        {
            //
            // Successfully drilled up to the same container
            //
            fDone = TRUE;
            hr = S_OK;
        }       
    }

Cleanup:
   
    RRETURN1( hr, S_FALSE );
}




//+====================================================================================
//
// Method: IsPassword
//
// Synopsis: Is the given IHTMLElement a Password element ?
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::IsPassword( IHTMLElement* pIElement, BOOL* pfIsPassword )
{
    HRESULT hr = S_OK;
    BOOL fIsPassword = FALSE;
    IHTMLElement* pIEditElement = NULL;   
    IHTMLInputElement * pIInputElement = NULL;
    BSTR bstrType = NULL;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    Assert( pIElement && pfIsPassword );
    
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
    if ( eTag == TAGID_INPUT )
    {
        //
        // Get the Master.
        //
        IFC( GetSelectionManager()->GetEditableElement( &pIEditElement ));
                                                      
        IFC( pIEditElement->QueryInterface ( 
                                        IID_IHTMLInputElement, 
                                        ( void** ) & pIInputElement ));
                            
        IFC(pIInputElement->get_type(&bstrType));
        
        if ( bstrType && !StrCmpIC( bstrType, TEXT("password") ) )
        {
            fIsPassword = TRUE;

        }
    }

Cleanup:

    *pfIsPassword = fIsPassword;

    SysFreeString( bstrType );
    ReleaseInterface( pIEditElement );        
    ReleaseInterface( pIInputElement );
    RRETURN( hr );
}

//+====================================================================================
//
// Method: FindCommonParentElement
//
// Synopsis: Find the parent common to all segments in a segment list
//
//------------------------------------------------------------------------------------


HRESULT 
CHTMLEditor::FindCommonParentElement( 
                                        ISegmentList* pSegmentList, 
                                        IHTMLElement** ppIElement)
{
    HRESULT hr;
    HTMLED_PTR( edSegmentMin );
    HTMLED_PTR( edSegmentMax);

    IFC( FindOutermostPointers( pSegmentList, edSegmentMin, edSegmentMax ));

    IFC( FindCommonElement( edSegmentMin, edSegmentMax, ppIElement ));

Cleanup:
    RRETURN( hr );
    
}

//+====================================================================================
//
// Method: FindOutermostPointers
//
// Synopsis: Find the outermost set of pointers in a given segmentlist ( ie the 
//           "total" start and end pointers.
//
//------------------------------------------------------------------------------------


HRESULT 
CHTMLEditor::FindOutermostPointers( 
                                    ISegmentList* pSegmentList, 
                                    IMarkupPointer* pOutermostStart, 
                                    IMarkupPointer* pOutermostEnd )
{
    HRESULT hr;
    HTMLED_PTR( edMinStart ) ;
    HTMLED_PTR( edMaxEnd );
    HTMLED_PTR( edTempStart );
    HTMLED_PTR( edTempEnd );
    BOOL fRightOf,fLeftOf;
    SELECTION_TYPE eType;
    SP_ISegmentListIterator spIter;
    SP_ISegment spSegment;
    
    Assert( pOutermostStart && pOutermostEnd );        
    
    IFC( pSegmentList->GetType( &eType ));
    IFC( pSegmentList->CreateIterator( &spIter ) );

    if( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current( &spSegment ) );
        IFC( spSegment->GetPointers( edMinStart, edMaxEnd ));

        IFC( spIter->Advance() );
        
#if DBG == 1
    IFC( edMinStart->IsLeftOfOrEqualTo( edMaxEnd, & fLeftOf));
    Assert( fLeftOf );
#endif

        while( spIter->IsDone() == S_FALSE )
        {
            IFC( spIter->Current( &spSegment ) );
            IFC( spSegment->GetPointers( edTempStart, edTempEnd ));

#if DBG == 1
            IFC( edTempStart->IsLeftOfOrEqualTo( edTempEnd, & fLeftOf));
            Assert( fLeftOf );
#endif

            IFC( edTempStart->IsLeftOf( edMinStart, & fLeftOf ));
            if ( fLeftOf )
            {
                IFC( edMinStart->MoveToPointer( edTempStart ));
            }

            IFC( edTempEnd->IsRightOf( edMinStart, & fRightOf ));
            if ( fRightOf )
            {
                IFC( edMaxEnd->MoveToPointer( edTempEnd ));
            }        

            IFC( spIter->Advance() );
        }

        IFC( pOutermostStart->MoveToPointer( edMinStart ));
        IFC( pOutermostEnd->MoveToPointer( edMaxEnd ));
    }        
    
Cleanup:
    
    RRETURN( hr );
    
}

HRESULT
CHTMLEditor::GetTableFromTablePart( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement curElement;
    SP_IHTMLElement nextElement;
    ELEMENT_TAG_ID eTag;

    IFC( GetMarkupServices()->GetElementTagId( pIElement,  & eTag ));
    Assert( IsTablePart( eTag ));

    ReplaceInterface( & curElement, pIElement );

    while ( eTag != TAGID_TABLE && curElement )
    {
        IFC( GetParentElement( curElement, &nextElement) );
        IFC( GetMarkupServices()->GetElementTagId( nextElement, & eTag ));

        curElement =  nextElement ;
    }

    if ( eTag == TAGID_TABLE && ppIElement )
    {
        ReplaceInterface( ppIElement, (IHTMLElement*) curElement );
    }
    
Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditor::GetOutermostTableElement( IHTMLElement* pIElement, IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spCurElement;
    SP_IHTMLElement spNextElement;
    ELEMENT_TAG_ID eTag;
    
    IFC( GetMarkupServices()->GetElementTagId( pIElement,  & eTag ));
    Assert( IsTablePart( eTag ) || eTag == TAGID_TABLE );

    spCurElement = (IHTMLElement*) pIElement ;

    while ( TRUE ) // terminate on finding a table - without it's parent being a table.
    {    
        while ( eTag != TAGID_TABLE && spCurElement )
        {
            IFC( GetParentElement( spCurElement, & spNextElement) );
            IFC( GetMarkupServices()->GetElementTagId( spNextElement, & eTag ));

            spCurElement =  spNextElement ;
        }

        if( GetParentLayoutElement( GetMarkupServices(), spCurElement, & spNextElement) == S_OK )
        {
            IFC( GetMarkupServices()->GetElementTagId( spNextElement, & eTag ));
            if ( ! IsTablePart( eTag ))
            {
                break;
            }
            else
            {
                spCurElement = spNextElement;
            }
        }
        else
        {
            //
            // means there is no parent layout for the table.
            //
            AssertSz(0,"Expected to find a layout after a table");
            hr = E_FAIL;
            goto Cleanup;
        }        
    }
    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));    
    if ( eTag == TAGID_TABLE && ppIElement )
    {
        ReplaceInterface( ppIElement, (IHTMLElement*) spCurElement );
    }
    
Cleanup:
    RRETURN( hr );
}

#include <initguid.h>
DEFINE_GUID(IID_IHTMLEditDesigner,      0x3050f662, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);
DEFINE_GUID(IID_IHTMLEditServices,  0x3050f663, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

HRESULT
CHTMLEditor::StartDblClickTimer(LONG lMsec /*=0*/ )
{
    HRESULT hr;
    SP_IHTMLWindow2 spWindow2;
    SP_IHTMLWindow3 spWindow3;
    VARIANT varLang;
    VARIANT varCallBack;

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC(spWindow2->QueryInterface(IID_IHTMLWindow3, (void **)&spWindow3));

    V_VT(&varLang) = VT_EMPTY;
    V_VT(&varCallBack) = VT_DISPATCH;
    V_DISPATCH(&varCallBack) = (IDispatch *)_pDispOnDblClkTimer;

    IFC(spWindow3->setInterval(&varCallBack, 
                               lMsec == 0 ? GetDoubleClickTime() : lMsec, 
                               &varLang, &_lTimerID));

Cleanup:
    RRETURN (hr);
}

HRESULT
CHTMLEditor::StopDblClickTimer()
{
    HRESULT hr;
    SP_IHTMLWindow2 spWindow2;

    IFC(GetDoc()->get_parentWindow(&spWindow2));
    IFC(spWindow2->clearInterval(_lTimerID));

Cleanup:
    RRETURN (hr);
}


inline HRESULT
CTimeoutHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    if( _pEd )
        return _pEd->Notify(EDITOR_NOTIFY_TIMER_TICK, NULL, NULL);
    else
        return S_OK;
}

HRESULT
CCaptureHandler::Invoke(
                DISPID dispidMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pdispparams,
                VARIANT * pvarResult,
                EXCEPINFO * pexcepinfo,
                UINT * puArgErr)
{
    HRESULT hr = S_OK;
    IHTMLEventObj *pObj=NULL;

    if( _pEd )
    {
        if (pdispparams->rgvarg[0].vt == VT_DISPATCH)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) );
            if ( pObj )
            {
                CHTMLEditEvent evt(  _pEd );
                IFC( evt.Init( pObj , dispidMember ));

                Assert( _pEd->GetSelectionManager()->IsInCapture());

                IFC( _pEd->GetSelectionManager()->DoPendingTasks());            

                if ( !_pEd->GetSelectionManager()->IsInCapture() )
                {
                    //
                    // We check that we still have capture. DoPendingTasks
                    // may have caused a tracker to become dormant
                    // so we fail & bail
                    //
                    hr = E_FAIL;
                    goto Cleanup;
                }
                
                hr = THR( _pEd->GetSelectionManager()->HandleEvent( & evt ));
                if ( hr == S_FALSE )
                {
                    //
                    // event was cancelled. We want to tell not to bubble anymore.
                    //
                    V_VT(pvarResult) = VT_BOOL;
                    V_BOOL(pvarResult) = VARIANT_FALSE;
                    hr = S_OK; // attach event needs this.
                }
            }
        }
    }
    
Cleanup:
    ReleaseInterface( pObj );
    RRETURN1( hr , S_FALSE );
}


HRESULT 
CHTMLEditor::MakeCurrent( IHTMLElement* pIElement )
{
    HRESULT hr;
    SP_IHTMLElement3 spElement3;

    IFC( pIElement->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
    IFC( spElement3->setActive());
    
Cleanup:
    RRETURN( hr );
}


HRESULT
CHTMLEditor::GetMarkupPosition( IMarkupPointer* pPointer, LONG* pMP )
{
    HRESULT hr;
    SP_IMarkupPointer2 spPointer2;
    
    IFC( pPointer->QueryInterface( IID_IMarkupPointer2, ( void**) & spPointer2 ));
    IFC( spPointer2->GetMarkupPosition( pMP ));

Cleanup:
    RRETURN( hr );
}

HRESULT
CHTMLEditor::MoveToMarkupPosition( IMarkupPointer * pPointer,
                                   IMarkupContainer * pContainer, 
                                   LONG mp )
{
    HRESULT hr ;
    SP_IMarkupPointer2 spPointer2;
      
    IFC( pPointer->QueryInterface( IID_IMarkupPointer2, ( void**) & spPointer2 ));
    IFC( spPointer2->MoveToMarkupPosition( pContainer ,  mp ));
    
Cleanup:
    RRETURN( hr );
}

ISelectionServices*
CHTMLEditor::GetISelectionServices()
{   
    HRESULT hr = S_OK;
    
    if ( ! _pISelectionServices )
    {
        hr = THR( GetSelectionServices( NULL, &_pISelectionServices ));
        if ( FAILED(hr ))
            goto Error;
    }
    return _pISelectionServices;

Error:
    ClearInterface( & _pISelectionServices );
    return NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::CurrentScopeOrMaster
//
//  Synopsis:   Retrieves the current element where the markup pointer is
//              positioned.  If the markup pointer is positioned in a slave
//              markup, returns the master element of that markup.
//
//  Arguments:  pIPointer = Pointer to markup position
//              pIDisplay = Display Pointer to position
//              ppElement = Pointer to returned root or scoped element.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::CurrentScopeOrMaster(  IDisplayPointer *pIDisplay, 
                                    IHTMLElement    **ppElement, 
                                    IMarkupPointer  *pIPointer /* = NULL */ )
{
    HRESULT             hr = S_OK;
    BOOL                fHasPointer = (pIPointer != NULL);
    
#if DBG
    SP_IMarkupPointer   spEqualTest;
    BOOL                fEqual;
#endif    

    Assert( pIDisplay && ppElement );

#if DBG

    if( fHasPointer )
    {
        IFC( CreateMarkupPointer( &spEqualTest ) );
        IFC( pIDisplay->PositionMarkupPointer( spEqualTest ) );

        IFC( spEqualTest->IsEqualTo(pIPointer, &fEqual) );

        Assert( fEqual );
    }
#endif

    if( !fHasPointer )
    {
        IFC( CreateMarkupPointer( &pIPointer ) );
        IFC( pIDisplay->PositionMarkupPointer( pIPointer ) );
    }

    IFC( pIPointer->CurrentScope( ppElement ) );

    if( !*ppElement )
    {
        IFC( pIDisplay->GetFlowElement( ppElement ) );
    }
        
Cleanup:
    if( !fHasPointer )
    {
        ReleaseInterface( pIPointer );
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::CurrentScopeOrMaster
//
//  Synopsis:   Retrieves the current element where the markup pointer is
//              positioned.  If the markup pointer is positioned in a slave
//              markup, returns the master element of that markup.
//
//  Arguments:  pIPointer = Pointer to markup position
//              ppElement = Pointer to returned root or scoped element.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::CurrentScopeOrMaster(  IMarkupPointer  *pIPointer, 
                                    IHTMLElement    **ppElement )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPtr;

    Assert( pIPointer && ppElement );

    IFC( pIPointer->CurrentScope( ppElement ) );

    if( !*ppElement )
    {
        //
        // Whoops.. the regular CurrentScope call failed.. we have
        // to get the flow element based on a display pointer that
        // we position at the markup pointer.  If this doesn't work,
        // then we are in deep, and we return failure to our caller.
        //
        IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPtr ) );
        IFC( spDispPtr->MoveToMarkupPointer( pIPointer, NULL ) );
        IFC( spDispPtr->GetFlowElement( ppElement ) );
    }
    
        
Cleanup:

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetSelectionRenderingServices
//
//  Synopsis:   Retrieves the selection rendering services off the doc
//
//  Arguments:  ppSelRen = OUT Pointer to selren interface
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetSelectionRenderingServices(IHighlightRenderingServices **ppISelRen)
{
    return E_NOTIMPL;    
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::GetFlowElement
//
//  Synopsis:   Retrieves the flow element at the specified point by creating
//              a display pointer, and calling GetFlowElement.
//
//  Arguments:  pIPointer = Pointer to use for getting flow element
//              ppElement = Flow element to return
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::GetFlowElement(IMarkupPointer *pIPointer, IHTMLElement **ppElement)
{
    SP_IDisplayPointer  spIDispPtr;
    HRESULT             hr;

    Assert( pIPointer && ppElement );

    // Create a display pointer, and position it at our markup
    // pointer
    IFC( GetDisplayServices()->CreateDisplayPointer(&spIDispPtr) );
    IFC( spIDispPtr->MoveToMarkupPointer( pIPointer, NULL ) );

    // Retrieve the flow element based on the display pointer
    IFC( spIDispPtr->GetFlowElement(ppElement) );

Cleanup:
    if( hr == CTL_E_INVALIDLINE )
    {
        hr = S_OK;
        *ppElement = NULL;
    }
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::PointersInSameFlowLayout
//
//  Synopsis:   Determines whether the two pointers passed in are contained
//              in the same flow layout.
//
//  Arguments:  pStart = Start position
//              pEnd = End position
//
//  Returns:    BOOL indicating whether or not they are in the same layout
//
//--------------------------------------------------------------------------
BOOL
CHTMLEditor::PointersInSameFlowLayout(  IMarkupPointer  *pStart, 
                                        IMarkupPointer  *pEnd,
                                        IHTMLElement    **ppFlowElement )
{
    BOOL                fInSameFlow = FALSE;
    SP_IHTMLElement     spElementFlowStart;
    SP_IHTMLElement     spElementFlowEnd;
    SP_IObjectIdentity  spIdentity;
    HRESULT             hr;

    if (ppFlowElement)
        *ppFlowElement = NULL;
    
    // Retrieve the flow elements for our pointers
    IFC( GetFlowElement( pStart, &spElementFlowStart ) );
    IFC( GetFlowElement( pEnd, &spElementFlowEnd ) );

    fInSameFlow = SameElements( spElementFlowStart, spElementFlowEnd );
    if (fInSameFlow && ppFlowElement)
    {
        *ppFlowElement = spElementFlowStart;
        spElementFlowStart->AddRef();
    }
        
Cleanup:

    return fInSameFlow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::PointersInSameFlowLayout
//
//  Synopsis:   Determines whether the two display pointers passed in 
//              are contained in the same flow layout.
//
//  Arguments:  pDispStart = Start position
//              pDispEnd = End position
//
//  Returns:    BOOL indicating whether or not they are in the same layout
//
//--------------------------------------------------------------------------
BOOL
CHTMLEditor::PointersInSameFlowLayout(  IDisplayPointer *pDispStart, 
                                        IDisplayPointer *pDispEnd, 
                                        IHTMLElement    **ppFlowElement )
{
    HRESULT             hr;
    SP_IHTMLElement     spElement1, spElement2;
    SP_IObjectIdentity  spIdent;
    BOOL                fSameFlow = FALSE;

    if (ppFlowElement)
        *ppFlowElement = NULL;
    
    IFC( pDispStart->GetFlowElement(&spElement1) );
    IFC( spElement1->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );

    IFC( pDispEnd->GetFlowElement(&spElement2) );

    fSameFlow = SameElements( spElement1, spElement2 );
    if (fSameFlow && ppFlowElement)
    {
        *ppFlowElement = spElement1;
        spElement1->AddRef();
    }

Cleanup:
    return fSameFlow;
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::IsElementLocked
//
//  Synopsis:   Determines whether the element passed in is locked or not.
//
//  Arguments:  pIElement = Element to check
//              pfLocked = Whether or not the element is locked
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::IsElementLocked(   IHTMLElement    *pIElement,
                                BOOL            *pfLocked )
{
    HRESULT         hr = S_OK;
    SP_IHTMLStyle   spCurStyle;
    CVariant        varLocked;
    BSTR            bstrLocked ; 

    Assert( pIElement && pfLocked );

    if (IsVMLElement(pIElement))
    {
        *pfLocked = TRUE ;
        goto Cleanup;
    }
         
    // Retrieve the current style, and check the design time lock
    // attribute
    IFC( pIElement->get_style( &spCurStyle ) );
    IFC( spCurStyle->getAttribute( _T("Design_Time_Lock"), 0, &varLocked ));

    // Check the result
    if (!varLocked.IsEmpty() )
    {   
        bstrLocked = V_BSTR(&varLocked);
        *pfLocked = ( StrCmpIW(_T("true"), bstrLocked ) == 0);
    }
    else
        *pfLocked = FALSE ;
        
Cleanup:
    RRETURN( hr );        
}

HRESULT
CHTMLEditor::TakeCapture(CEditTracker * pTracker )
{
    HRESULT hr;
    SP_IHTMLElement spElement;
    VARIANT_BOOL varAttach = VB_TRUE;
    SP_IDispatch spDisp;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pSelMan->GetActiveTracker() == pTracker )
    {       
        Assert( ! _pSelMan->IsInCapture() );

        Assert( ! _pICaptureElement );            

        IFC( _pSelMan->GetEditableElement( & spElement ));
        IFC( spElement->QueryInterface( IID_IHTMLElement2, ( void**) & _pICaptureElement ));

        IFC( _pICaptureElement->setCapture( VB_FALSE ));

        //
        // attach all our events
        //
        IFC( _pCaptureHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));

        IFC( _pICaptureElement->attachEvent(_T("onmousedown"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
        IFC( _pICaptureElement->attachEvent(_T("onmouseup"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
           
        IFC( _pICaptureElement->attachEvent(_T("onmousemove"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("oncontextmenu"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("ondblclick"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onkeydown"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onclick"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );

        IFC( _pICaptureElement->attachEvent(_T("onlosecapture"), spDisp, & varAttach));
        Assert( varAttach == VB_TRUE );
        
        _pSelMan->SetInCapture( TRUE );

    }  
    else
    {
        hr = E_FAIL;
    }
    
Cleanup:
    if ( hr != S_OK)
    {
        _pSelMan->SetInCapture( FALSE );   
        ClearInterface( & _pICaptureElement );
    }
    
    RRETURN( hr );
}

HRESULT
CHTMLEditor::ReleaseCapture(CEditTracker* pTracker, BOOL fReleaseCapture /*=TRUE*/)
{
    HRESULT hr = S_OK;
    SP_IDispatch spDisp;

    //
    // Now possible for the manager to have released the tracker
    // and created a new one. Instead of touching the timers when we shouldn't
    // Don't do anything if we no longer belong to the manager.
    //
    if ( _pSelMan->GetActiveTracker() == pTracker )
    {       
        Assert( _pSelMan->IsInCapture() );  
        
        Assert( _pICaptureElement);

        IFC( _pCaptureHandler->QueryInterface( IID_IDispatch, ( void**) & spDisp));

        IFC( _pICaptureElement->detachEvent(_T("onmousedown"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onmouseup"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onmousemove"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("oncontextmenu"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("ondblclick"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onkeydown"), spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onclick"),spDisp));
        IFC( _pICaptureElement->detachEvent(_T("onlosecapture"), spDisp ));

        if ( fReleaseCapture )
        {
            IFC( _pICaptureElement->releaseCapture( )); 
        }
        
        _pSelMan->SetInCapture( FALSE );   
        ClearInterface( & _pICaptureElement );

    }
#if DBG == 1
    else
    {
        AssertSz(0,"Trying to release on the wrong tracker");
    }
#endif

Cleanup:
    RRETURN( hr );
}

HRESULT 
CHTMLEditor::AllowSelection(IHTMLElement *pIElement, CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    VARIANT_BOOL fDisabled;
    SP_IHTMLElement spElement;
    SP_IHTMLElement spElementCookie;
    SP_IHTMLElement3 spElement3;
    SP_IServiceProvider spSP;
    SP_IDocHostUIHandler spHostUIHandler;
    SP_IUnknown spUnkDialog;
    
    IHTMLInputElement *pInput = NULL;
    IHTMLTextAreaElement *pTextArea = NULL;
    RECT myRect;
    BSTR bstrType = NULL;
    DOCHOSTUIINFO Info;
    BOOL    fInDialog = FALSE;

    
    memset(&Info, 0, sizeof(DOCHOSTUIINFO));
    Info.cbSize = sizeof(DOCHOSTUIINFO);

    IFC( _pUnkDoc->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP));
    spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)& spHostUIHandler);
    
    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    Assert( pEvent );

    if (spHostUIHandler)
        IFC(spHostUIHandler->GetHostInfo(&Info));

    spElement = pIElement;

    //
    // we don't respect the DOCHOSTUIFLAG_DIALOG flag for editable regions
    // unless it's disabled
    // or the element is input file, text, hidden or password ( IE4 legacy)
    // 

    //  Bug 110069: (rolandt) We can't rely on Info.dwFlags with PhotoSuite because
    //  PhotoSuite adds the dialog bit even though not in a dialog and even though
    //  selection should be possible.  AppHack: we will look for IHTMLDialog to determine
    //  whether or not we are in a dialog.  This will not work for cases where they set
    //  the dialog bit when not in a dialog, or when they really want to allow selection
    //  in a dialog, but we are working around this to accomodate their error.  Note: this
    //  used to work in IE5 because we cached the initial info flags on load.  But PhotoSuite
    //  apparently changes the flags after loading and turns on the dialog bit.

    if (g_fInPhotoSuiteIII)
    {
        hr = THR(spSP->QueryService(IID_IHTMLDialog, IID_IUnknown, (void**)&spUnkDialog));
        fInDialog = (hr == S_OK);
    }
    else
    {
        fInDialog = !!(Info.dwFlags & DOCHOSTUIFLAG_DIALOG);
    }

    if (fInDialog)
    {
        BOOL fAllow = TRUE;

        if ( IsEditable(spElement) == S_OK  )
        {
            IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
            IFC(spElement3->get_isDisabled(&fDisabled));
            if (fDisabled)
            {
                fAllow = FALSE;
            }
            else
            {
                if ( SUCCEEDED( spElement->QueryInterface(IID_IHTMLInputElement, (void **)&pInput) ))
                {
                    IFC(pInput->get_type(&bstrType));
                    if (_tcscmp(bstrType, _T("file")) &&
                        _tcscmp(bstrType, _T("text")) &&
                        _tcscmp(bstrType, _T("hidden")) && 
                        _tcscmp(bstrType, _T("password")))
                    {
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                }
            }
        }
        else
        {
            IFC(IsBlockOrLayoutOrScrollable(spElement, NULL, &fAllow));
            if (fAllow)
            {
                hr = THR(spElement->QueryInterface(IID_IHTMLTextAreaElement, (void **)&pTextArea));
                if (hr)
                {
                    hr = THR(spElement->QueryInterface(IID_IHTMLInputElement, (void **)&pInput));
                    if (hr)
                    {
                        hr = S_FALSE;
                        goto Cleanup;
                    }
                    else
                    {
                        IFC(pInput->get_type(&bstrType));
                        if (_tcscmp(bstrType, _T("file")) &&
                            _tcscmp(bstrType, _T("text")) &&
                            _tcscmp(bstrType, _T("hidden")) && 
                            _tcscmp(bstrType, _T("password")))
                        {
                            hr = S_FALSE;
                            goto Cleanup;
                        }
                    }
                }

                IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
                IFC(spElement3->get_isDisabled(&fDisabled));
                if (fDisabled)
                {
                    fAllow = FALSE;
                }
            }
        }
        
        if (!fAllow)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    IGNORE_HR( pEvent->GetElement( &spElementCookie));
    if (spElementCookie)
    {
        SP_IHTMLElement spLayoutElement;
        SP_IHTMLElement2 spElement2;
        
        if ( GetLayoutElement( GetMarkupServices(), spElementCookie, & spLayoutElement ) == S_OK )
        {
            // See if the point falls in the client rect      
            if (_pSelMan->CheckAtomic(spElementCookie) == S_OK)
            {
                // 
                // HACKHACK-IEV6-5244-2000/07/08-zhenbinx 
                //
                // For atomic element, we should allow selection tracker 
                // to be active even the hit-point is outside client area
                // (such as in scroll bar). Otherwise a carettracker would
                // be activated and caret will be placed inside atomic element.
                // A better fix should be checking atomic element whenever
                // a carettracker is positioned. However there are too
                // much to be done under current structure. Consider
                // doing it in next release.
                //
                // Get the IHTMLElement2 interface, and the bounding rect
                //
                IFC( spLayoutElement->QueryInterface(IID_IHTMLElement2, (void **)&spElement2));    
                IFC( GetBoundingClientRect(spElement2, &myRect) );
            }
            else
            {
                IFC( GetClientRect( spLayoutElement, &myRect ) );
            }

            POINT pt;
            IFC( pEvent->GetPoint( & pt ));
            hr = ::PtInRect(&myRect, pt ) ? S_OK : S_FALSE;        
        }
        else
            hr = S_FALSE;
    }

Cleanup:
    ReleaseInterface(pInput);
    ReleaseInterface(pTextArea);
    SysFreeString(bstrType);
    CoTaskMemFree(Info.pchHostNS);
    CoTaskMemFree(Info.pchHostCss);
    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CHTMLEditor::MakeParentCurrent( IHTMLElement* pIElement )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spParent;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement spMaster;

    spMaster = pIElement;
    IFC( GetParentLayoutElement( GetMarkupServices(), spMaster, & spParent ));

    if ( ! spParent.IsNull())
    {
        IFC( spParent->QueryInterface( IID_IHTMLElement3, (void**) & spElement3 ));
        IGNORE_HR( spElement3->setActive());
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN( hr );
}


HRESULT 
CHTMLEditor::AdjustOut(IMarkupPointer *pPointer, Direction eDir)
{
    HRESULT      hr;
    CEditPointer ep(this);
    DWORD        dwFound;
    DWORD        dwSearchForward = BREAK_CONDITION_OMIT_PHRASE 
                                   - BREAK_CONDITION_ExitBlock
                                   - BREAK_CONDITION_ExitSite;
    DWORD        dwSearchBack = BREAK_CONDITION_OMIT_PHRASE 
                                - BREAK_CONDITION_EnterBlock
                                - BREAK_CONDITION_EnterSite;

    //
    // Adjust out so that we end up outside of block elements and sites
    //
        
    IFC( ep->MoveToPointer(pPointer) );
    IFC( ep.Scan(eDir, dwSearchForward, &dwFound) );
    if (ep.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site))
    {   
        IFC( ep.Scan(Reverse(eDir), dwSearchBack, &dwFound) );

        //
        // Move the markup pointer
        //

        IFC( pPointer->MoveToPointer(ep) );
    }

    // 
    // TODO: 
    // What if there is no next block??? Then this code will
    // not adjust at all. This is buggy.  Besides, it could happen 
    // that there are some phrase elements in between blocks. In this
    // case we might have adjusted too much. See bug #98353
    // 
    // [zhenbinx]
    //

Cleanup:
    RRETURN(hr);
}


HRESULT
CHTMLEditor::EnterTables(IMarkupPointer *pPointer, Direction eDir)
{
    HRESULT         hr = S_OK;
    CEditPointer    ep(this);
    ELEMENT_TAG_ID  tagId;
    SP_IHTMLElement spElement;
    DWORD           dwFound;
    BOOL            fIgnoreGlyphs = _fIgnoreGlyphs;

    //
    // We don't want to stay in a position that is invalid
    // for display pointer so we always want the real text
    // instead of WCH_GLYPH. 
    //
    _fIgnoreGlyphs = TRUE;

    // Enter tables
    IFC( ep->MoveToPointer(pPointer) );
    for (;;)
    {
        IFC( ep.Scan(eDir, BREAK_CONDITION_OMIT_PHRASE, &dwFound, &spElement) );

        if (!CheckFlag(dwFound, BREAK_CONDITION_Site) 
           && !CheckFlag(dwFound, BREAK_CONDITION_Block)
           && !CheckFlag(dwFound, BREAK_CONDITION_TextSite)
           && !CheckFlag(dwFound, BREAK_CONDITION_NoScopeBlock)		// <COL> </COL> etc. 
           )
        {
            break;
        }

        if (spElement == NULL)
            break;
            
        IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
        if (!IsTablePart(tagId) && tagId != TAGID_TABLE)
            break;

        // Don't exit TD's
        if (tagId == TAGID_TD && CheckFlag(dwFound, BREAK_CONDITION_ExitSite)) 
            break;

        IFC( pPointer->MoveToPointer(ep) );
    }

Cleanup:
    _fIgnoreGlyphs = fIgnoreGlyphs;

    RRETURN(hr);
}        
                
HRESULT
CHTMLEditor::GetHwnd(HWND* pHwnd)
{
    HRESULT hr;
    HWND myHwnd = NULL;
    SP_IOleWindow spOleWindow;
    
    IFC( GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (spOleWindow)
    {
        IFC(spOleWindow->GetWindow( &myHwnd ));
    }
    
Cleanup:    

    *pHwnd = myHwnd;
    
    RRETURN( hr );
}

HRESULT
CHTMLEditor::ConvertRTFToHTML(LPOLESTR pszRtf, HGLOBAL* phglobalHTML)
{
    HRESULT  hr = THR(CRtfToHtmlConverter::StringRtfToStringHtml(NULL, (LPSTR)pszRtf, phglobalHTML));
    RRETURN(hr);
}


CCommand* 
CHTMLEditor::GetCommand(DWORD cmdID)
{
    return GetCommandTable()->Get(cmdID);
}        

HRESULT 
CHTMLEditor::DoTheDarnIE50PasteHTML(IMarkupPointer *pStart, IMarkupPointer *pEnd, HGLOBAL hGlobal)
{
    HRESULT                 hr;
    SP_IHTMLTxtRange        spRange;
    SP_IHTMLElement         spElement;
    SP_IHTMLBodyElement     spBody;
    SP_IOleCommandTarget    spCmdTarget;
    VARIANT                 varargIn;
    GUID                    guidCmdGroup = CGID_MSHTML;

    //
    // Create a text range
    //
    IFC( GetBody(&spElement) );

    IFC( spElement->QueryInterface(IID_IHTMLBodyElement, (void **)&spBody) );
    IFC( spBody->createTextRange(&spRange) );

    //
    // Do the paste
    //

    if (!pEnd)
        pEnd = pStart;
        
    IFC( GetMarkupServices()->MoveRangeToPointers( pStart, pEnd, spRange));

    IFC( spRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&spCmdTarget) );

    V_VT(&varargIn) = VT_BYREF;
    V_BYREF(&varargIn) = (VOID *)hGlobal;
    IFC( spCmdTarget->Exec(&guidCmdGroup, IDM_IE50_PASTE, 0, &varargIn, NULL) );

Cleanup:
    RRETURN(hr);
}


HRESULT 
CHTMLEditor::IsPointerInPre(IMarkupPointer *pPointer, BOOL *pfInPre)
{
    HRESULT                 hr;
    SP_IHTMLComputedStyle   spComputedStyle;
    VARIANT_BOOL            fPre;

    Assert(pfInPre);

    IFC( GetDisplayServices()->GetComputedStyle(pPointer, &spComputedStyle) );
    IFC( spComputedStyle->get_preFormatted(&fPre) );
    if (fPre)
    {
        SP_IHTMLElement spElementScope, spElementPre;
        SP_IHTMLElement spPre;

        IFC( pPointer->CurrentScope(&spElementScope) );
        IFC( FindTagAbove(GetMarkupServices(), spElementScope, TAGID_PRE, &spElementPre, TRUE /*fStopAtLayout*/) );

        *pfInPre = (spElementPre != NULL);
    }
    else
    {
        *pfInPre = FALSE; 
    }

Cleanup:
    RRETURN(hr);    
}

HRESULT 
CHTMLEditor::InsertMaximumText (OLECHAR * pstrText, 
                                LONG cch,
                                IMarkupPointer * pIMarkupPointer )
{   
    HRESULT             hr = S_OK ;
    SP_IHTMLElement     spMaster;
    IHTMLInputElement*  pInputElement = NULL;
    LONG                lActualLen = cch;
    ELEMENT_TAG_ID      eTag ;
    SP_IMarkupPointer	spCurrent, spEnd;
    SP_IMarkupContainer spMarkup;

    IFC (CurrentScopeOrMaster(pIMarkupPointer, &spMaster));
    IFC( GetMarkupServices()->GetElementTagId( spMaster, & eTag ));

    if ( eTag == TAGID_INPUT )
    {
        LONG lMaxLen     =  0 ;
        LONG lContentLen =  0;
        LONG lCharsAllowed  = 0 ;
        MARKUP_CONTEXT_TYPE context;
        BOOL fDone;

        if( lActualLen < 0 )
            lActualLen = pstrText ? _tcslen( pstrText ) : 0;

        // Walk right over text, inital pass, don't move, just get count of chars
        IFC( CreateMarkupPointer(&spCurrent) );
        IFC( CreateMarkupPointer(&spEnd) );

        IFC( pIMarkupPointer->GetContainer(&spMarkup) );

        IFC( spCurrent->MoveToContainer(spMarkup, TRUE /*fStart*/) );   
        IFC( spEnd->MoveToContainer(spMarkup, FALSE /*fStart*/) );

        do
        {
            LONG lLen = -1;     
            IFC( spCurrent->Right(TRUE, &context, NULL, &lLen, NULL) );

            if (context == CONTEXT_TYPE_Text)
                lContentLen += lLen;

            IFC( spCurrent->IsRightOfOrEqualTo(spEnd, &fDone) );
        } while (!fDone);

        IFC (spMaster->QueryInterface(IID_IHTMLInputElement, (void**)&pInputElement));
        IFC (pInputElement->get_maxLength(&lMaxLen));
        lCharsAllowed = lMaxLen - lContentLen;

        if( lActualLen > lCharsAllowed )
            lActualLen = lCharsAllowed;
    
        if( lActualLen <= 0 )
            goto Cleanup;
    }
   
    IFC( GetMarkupServices()->InsertText(pstrText, lActualLen ,pIMarkupPointer) );

Cleanup:
    ReleaseInterface (pInputElement);
    RRETURN( hr );
}  

BOOL 
CHTMLEditor::IsIE50CompatiblePasteMode()
{
    return WHEN_DBG(IsTagEnabled(tagIE50Paste) ||) _fIE50CompatUIPaste;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::IsMasterElement
//
//  Synopsis:   See's if this elmenet is a 'content element' - ie a slave
//
//  Returns:    S_FALSE, if it isn't view linked
//              S_OK, if it is view linked
//
//----------------------------------------------------------------------------

HRESULT
CHTMLEditor::IsContentElement( IHTMLElement * pIElement )
{
    return EdUtil::IsContentElement( GetMarkupServices(), pIElement );
}    

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetLayoutElement
//
//  Synopsis:   Gets the Master Element
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetMasterElement( IHTMLElement* pIElement, IHTMLElement** ppILayoutElement )
{
    return EdUtil::GetMasterElement( GetMarkupServices(), pIElement, ppILayoutElement );
}

IHTMLDocument4* 
CHTMLEditor::GetDoc4()
{
    IHTMLDocument4 *pDoc;
    Assert( _pUnkDoc );
    
    _pUnkDoc->QueryInterface( IID_IHTMLDocument4 , (void **) &pDoc );

    return pDoc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetComputedStyle, public
//
//  Synopsis:   Gets the computed style associated with a particular element
//
//  Arguments:  [pElement] -- Pointer to element
//              [ppComputedStyle] -- Output parameter for computed style
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetComputedStyle(IHTMLElement *pElement, IHTMLComputedStyle **ppComputedStyle)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;

    Assert(ppComputedStyle);
   
    *ppComputedStyle = FALSE;  
    
    IFC( CreateMarkupPointer(&spPointer) );   
    if (FAILED( spPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterBegin) ))
    {
        IFC( spPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
    }
    IFC( GetDisplayServices()->GetComputedStyle(spPointer, ppComputedStyle) );

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetElementAttributeCount, public
//
//  Synopsis:   Gets the attribute count associated with a particular element
//
//  Arguments:  [pElement] -- Pointer to element
//              [ppComputedStyle] -- Output parameter for computed style
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetElementAttributeCount(IHTMLElement *pElement, UINT *pCount)
{
    HRESULT                         hr = S_OK;
    SP_IDispatch                    spdispAttrCollection;
    SP_IHTMLAttributeCollection     spAttrCollection;
    SP_IHTMLDOMNode                 spDomNode;
    SP_IDispatch                    spdispAttr;
    SP_IHTMLDOMAttribute            spDomAttr;
    LONG                            lLength;
    VARIANT                         varIndex;
    VARIANT_BOOL                    vBool;
    LONG                            i;

    VariantInit(&varIndex);

    Assert(pElement && pCount);

    *pCount = 0;

    //
    // Get attribute collection
    //
    IFC( pElement->QueryInterface(IID_IHTMLDOMNode, (LPVOID *)&spDomNode) );
    IFC( spDomNode->get_attributes(&spdispAttrCollection) );
    if (spdispAttrCollection == NULL)
        goto Cleanup;
    IFC( spdispAttrCollection->QueryInterface(IID_IHTMLAttributeCollection, (LPVOID *)&spAttrCollection) );

    //
    // Iterate through attributes
    //
    IFC( spAttrCollection->get_length(&lLength) );
    V_VT(&varIndex) = VT_I4;

    for (i = 0; i < lLength; ++i)
    {
        V_I4(&varIndex) = i;

        IFC( spAttrCollection->item(&varIndex, &spdispAttr) );
        IFC( spdispAttr->QueryInterface(IID_IHTMLDOMAttribute, (LPVOID *)&spDomAttr) );

        IFC( spDomAttr->get_specified(&vBool) );
        if (BOOL_FROM_VARIANT_BOOL(vBool))
        {
            *pCount += 1;
        }
    }

Cleanup:
    RRETURN(hr);   
}

//+---------------------------------------------------------------------------
//
//    Member:     IsContainer
//
//    Synopsis:   Return whether the element is a container.
//
//    Arguments:  [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//    TODO: rethink the role of the container here [ashrafm]
//
//----------------------------------------------------------------------------
BOOL
CHTMLEditor::IsContainer(IHTMLElement *pElement)
{
    HRESULT         hr;
    ELEMENT_TAG_ID  tagId;

    Assert(pElement);

    IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
    switch (tagId)
    {
        case TAGID_BODY:
        case TAGID_BUTTON:
        case TAGID_INPUT:
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_TEXTAREA:
        case TAGID_ROOT:
            return TRUE;
    }

Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: GetOuterMostEditableElement
//
// Synopsis: Given an element - get the outermost elemnet that 's editable.
//           In _fDesignMode - thsi is the Body.
//
//------------------------------------------------------------------------------------


HRESULT
CHTMLEditor::GetOuterMostEditableElement( IHTMLElement* pIElement,
                                           IHTMLElement** ppIElement )
{
    HRESULT hr = S_OK;
    ELEMENT_TAG_ID eTag;    
    SP_IHTMLElement spCurElement = pIElement;
    SP_IHTMLElement spOuterElement;
    SP_IHTMLElement spParentElement;
    
    Assert( pIElement && ppIElement );

    IFC( GetMarkupServices()->GetElementTagId( spCurElement, & eTag ));    

    if ( eTag == TAGID_BODY )
    {
        spOuterElement = spCurElement;
    }
    else if ( IsContentElement( pIElement) == S_OK )
    {
        IFC( GetMasterElement( spCurElement, & spOuterElement )); 
    }    
    else 
    {       
        while( IsEditable( spCurElement ) == S_OK &&
               eTag != TAGID_BODY )
        {
            IFC( GetParentElement( spCurElement, & spParentElement ));
            if ( ! spParentElement )
                break;
            spOuterElement = spCurElement;
            spCurElement = spParentElement;            
            IFC( GetMarkupServices()->GetElementTagId( spCurElement , & eTag ));            
        }
        
        if ( eTag == TAGID_BODY || !spParentElement )
            spOuterElement = spCurElement;
        //
        // else spOuterElement was already set to the last thing that was editable.
        //
    }
    
    if ( spOuterElement )
    {
        *ppIElement = (IHTMLElement*) spOuterElement;
        (*ppIElement)->AddRef();
    }
    
Cleanup:    
    RRETURN( hr );
    
}

HRESULT 
CHTMLEditor::GetClientRect(IHTMLElement* pIElement, RECT* pRect )
{
    HRESULT             hr;
    SP_IHTMLElement2    spIHTMLElement2; 
    long                lWidth, lHeight;
    long                lLeft, lTop;
    
    //
    // Get the IHTMLElement2 interface, and the bounding rect
    //
    IFC( pIElement->QueryInterface(IID_IHTMLElement2, (void **)&spIHTMLElement2));    
    IFC( GetBoundingClientRect( spIHTMLElement2, pRect ) );

    // Get our client width and height
    IFC( spIHTMLElement2->get_clientWidth( &lWidth ));
    IFC( spIHTMLElement2->get_clientHeight( &lHeight ));
    IFC( spIHTMLElement2->get_clientLeft( &lLeft ) );
    IFC( spIHTMLElement2->get_clientTop( &lTop ) );

    //
    // Adjust our bounding rect so that only client area is represented
    //
    pRect->left += lLeft;
    pRect->top += lTop;
    pRect->right = pRect->left + lWidth;
    pRect->bottom = pRect->top + lHeight;
                                                     
Cleanup:    
    RRETURN( hr );
}

HRESULT 
CHTMLEditor::GetViewLinkMaster(IHTMLElement *pIElement, IHTMLElement **ppIMasterElement)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;
    SP_IMarkupContainer     spContainer;
    SP_IMarkupContainer2    spContainer2;

    Assert(pIElement && ppIMasterElement);

    *ppIMasterElement = NULL;
    
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pIElement, ELEM_ADJ_BeforeBegin) );
    
    IFC( spPointer->GetContainer(&spContainer) );
    IFC( spContainer->QueryInterface(IID_IMarkupContainer2, (LPVOID *)&spContainer2) );
    
    IFC( spContainer2->GetMasterElement(ppIMasterElement) );

Cleanup:
    RRETURN(hr);
}    


HRESULT 
CHTMLEditor::GetContainer(IHTMLElement *pIElement, IMarkupContainer **ppContainer)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spPointer;

    Assert(pIElement && ppContainer);

    *ppContainer = NULL;
    
    IFC( MarkupServices_CreateMarkupPointer(GetMarkupServices(), &spPointer) );
    IFC( spPointer->MoveAdjacentToElement(pIElement, ELEM_ADJ_BeforeBegin) );
    
    IFC( spPointer->GetContainer(ppContainer) );
Cleanup:
    RRETURN(hr);
}    

HRESULT
CHTMLEditor::IsMasterElement( IHTMLElement* pIElement )
{
    return EdUtil::IsMasterElement( GetMarkupServices(), pIElement ) ;
}

HRESULT
CHTMLEditor::IsPointerInMasterElementShadow( IMarkupPointer* pPointer )
{
    return EdUtil::IsPointerInMasterElementShadow( this, pPointer );
}


//
//  Remove Element Segments for Cut/Delete given SelectionRendering services SegmentList
//
HRESULT 
CHTMLEditor::RemoveElementSegments(ISegmentList *pISegmentList)
{
    HRESULT             hr = S_OK;
    CSegmentList       *pSegmentList = NULL ;
    BOOL                fEmpty = FALSE ;
    
    IFC( pISegmentList->AddRef());  
    
    IFC( pISegmentList->IsEmpty( &fEmpty ) );

    if (!fEmpty)
    {
        SP_ISegmentListIterator spIter ;
        SP_ISegmentListIterator spSegIter ;    
        SP_ISegmentList         spSegmentList ;
        SP_IMarkupPointer       spStart, spEnd;

        // Create an iterator
        IFC( pISegmentList->CreateIterator( &spIter ) );

        pSegmentList = new CSegmentList ;
        if (pSegmentList != NULL)
        {
            pSegmentList->SetSelectionType( SELECTION_TYPE_Control );

            while (spIter->IsDone() == S_FALSE)
            {
                SP_ISegment         spSegment ;
                SP_IElementSegment  spElemSegment ;
                SP_IElementSegment  spElemSegmentAdded ;
                SP_IHTMLElement     spElement;

                // Get the current segment, and advance the iterator right away, 
                // since we might blow away our segment in the delete call.
                IFC( spIter->Current(&spSegment) );
                IFC( spSegment->QueryInterface(IID_IElementSegment, (void**)&spElemSegment));
                IFC( spElemSegment->GetElement(&spElement)) ;
                IFC( pSegmentList->AddElementSegment( spElement, &spElemSegmentAdded ) );    
                IFC( spIter->Advance() );
            }

            
            IFC (pSegmentList->QueryInterface(IID_ISegmentList, (void**)&spSegmentList));

            // Create an iterator
            IFC( spSegmentList->CreateIterator( &spSegIter ) );

            // Create some markup pointers
            IFC( CreateMarkupPointer( &spStart ) );
            IFC( CreateMarkupPointer( &spEnd ) );

            while (spSegIter->IsDone() == S_FALSE)
            {
                SP_IElementSegment  spElemSegment ;
                SP_ISegment         spSegment ;
                
                // Get the current segment, and advance the iterator right away, 
                // since we might blow away our segment in the delete call.
                IFC( spSegIter->Current(&spSegment) );
                IFC( spSegIter->Advance() );
                IFC( spSegment->QueryInterface(IID_IElementSegment, (void**)&spElemSegment));
        
                hr = spElemSegment->GetPointers( spStart, spEnd ) ;

                if (hr == S_OK && spStart != NULL && spEnd != NULL)
                {
                    //
                    // Cannot delete or cut unless the range is in the same flow layout
                    //
                    if( PointersInSameFlowLayout( spStart, spEnd, NULL ) )
                    {                 
                        IFC( Delete( spStart, spEnd, FALSE /* fAdjust */ ) );
                    }
                }
                else
                {
                     // container case, where pointers are invalid as they removed from tree by ExitTree, 
                     // safe check as elements are removed already, don't crash
                    hr = S_OK;
                    continue ;
                }
            }                 
        }
    }

Cleanup:
    if (pSegmentList)
        delete pSegmentList ;

    pISegmentList->Release();
    RRETURN (hr);
}

HRESULT 
CHTMLEditor::GetBoundingClientRect(IHTMLElement2 *pElement, RECT *pRect)
{
    HRESULT         hr;
    SP_IHTMLRect    spRect;
    POINT           ptOrigin;
    SP_IHTMLElement spElement;

    IFC( pElement->getBoundingClientRect(&spRect) );
    
    IFC( spRect->get_top(&pRect->top) );
    IFC( spRect->get_bottom(&pRect->bottom) );
    IFC( spRect->get_left(&pRect->left) );
    IFC( spRect->get_right(&pRect->right) );

    IFC( pElement->QueryInterface(IID_IHTMLElement, (LPVOID *)&spElement) );    
    IFC( EdUtil::GetClientOrigin( this, spElement, &ptOrigin) );

    pRect->top += ptOrigin.y;
    pRect->bottom += ptOrigin.y;
    pRect->left += ptOrigin.x;
    pRect->right += ptOrigin.x;

Cleanup:
    RRETURN(hr);
}

HRESULT 
CHTMLEditor::GetMargins(RECT* rcMargins)
{
    HRESULT             hr = S_OK;
    SP_IHTMLElement     spBodyElement;
    SP_IHTMLBodyElement spBody;
    VARIANT             vtMargin;
    
    IFC ( GetBody(&spBodyElement));
    IFC (spBodyElement->QueryInterface(IID_IHTMLBodyElement,(void **)&spBody));

    SetRect(rcMargins, 0,0,0,0);
    
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_leftMargin(&vtMargin)))
    {
        LONG lLeftMargin = 0;

        if (V_VT(&vtMargin) == VT_BSTR)
            lLeftMargin = _wtoi(V_BSTR(&vtMargin));
        
        if (lLeftMargin > 0)
            rcMargins->left = lLeftMargin;        
    }
    VariantClear(&vtMargin);
        
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_topMargin(&vtMargin)))
    {                    
        LONG lTopMargin = 0;
        if (V_VT(&vtMargin) == VT_BSTR)
           lTopMargin = ::_wtoi(V_BSTR(&vtMargin));
        
        if (lTopMargin > 0)
            rcMargins->top = lTopMargin;        
    }
    VariantClear(&vtMargin);

    if (SUCCEEDED(spBody->get_rightMargin(&vtMargin)))
    {
        LONG lRightMargin = 0;

        if (V_VT(&vtMargin) == VT_BSTR)
            lRightMargin = _wtoi(V_BSTR(&vtMargin));
        
        if (lRightMargin > 0)
            rcMargins->right = lRightMargin;        
    }
    VariantClear(&vtMargin);
        
    VariantInit(&vtMargin);
    if (SUCCEEDED(spBody->get_topMargin(&vtMargin)))
    {                    
        LONG lBottomMargin = 0;
        if (V_VT(&vtMargin) == VT_BSTR)
           lBottomMargin = ::_wtoi(V_BSTR(&vtMargin));
        
        if (lBottomMargin > 0)
           rcMargins->bottom = lBottomMargin;        
    }
    VariantClear(&vtMargin);

Cleanup :
    RRETURN1 (hr , S_FALSE);
}
        
HRESULT
CHTMLEditor::EnableModeless ( 
            BOOL fEnable) 
{
    RRETURN( _pSelMan->EnableModeless( fEnable ));
}


BOOL 
CHTMLEditor::IgnoreGlyphs(BOOL fIgnoreGlyphs)
{
    BOOL fResult = !!_fIgnoreGlyphs;

    _fIgnoreGlyphs = fIgnoreGlyphs;

    return fResult;
}

HRESULT
CHTMLEditor::MoveToSelectionAnchor (
            IMarkupPointer * pIAnchor )
{
    if ( !_pSelMan || !pIAnchor)
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CHTMLEditor::MoveToSelectionEnd (
            IMarkupPointer* pISelectionEnd )
{
    if ( !_pSelMan || !pISelectionEnd )
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionEnd(pISelectionEnd));
}

HRESULT
CHTMLEditor::MoveToSelectionAnchorEx (
            IDisplayPointer * pIAnchor )
{
    if ( !_pSelMan || !pIAnchor)
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionAnchor(pIAnchor));
}


HRESULT
CHTMLEditor::MoveToSelectionEndEx (
            IDisplayPointer* pISelectionEnd )
{
    if ( !_pSelMan || !pISelectionEnd )
    {
        return E_FAIL;
    }

    RRETURN( _pSelMan->MoveToSelectionEnd(pISelectionEnd));
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTMLEditor::GetParentElement, public
//
//  Synopsis:   Get the parent element.  If it is NULL, then get the 
//              master element
//
//----------------------------------------------------------------------------
HRESULT 
CHTMLEditor::GetParentElement(IHTMLElement *pSrcElement, IHTMLElement **ppParentElement)
{
    RRETURN( ::GetParentElement(GetMarkupServices(), pSrcElement, ppParentElement) );    
}


BOOL 
CHTMLEditor::DoesSegmentContainText(IMarkupPointer *pStart, IMarkupPointer *pEnd, BOOL fSkipNBSP /* = TRUE */)
{
    HRESULT                 hr;
    SP_IMarkupPointer       spCurrent;
    BOOL                    bEqual;
    MARKUP_CONTEXT_TYPE     context;
    TCHAR                   ch;
    LONG                    cch;

    IFC( CopyMarkupPointer(this, pStart, &spCurrent) );
    
    do
    {
        IFC( spCurrent->IsEqualTo(pEnd, &bEqual) );
        if (bEqual)
            return FALSE; // no text 

        cch = 1;
        IFC( spCurrent->Right(TRUE, &context, NULL, &cch, &ch) );

        if (context == CONTEXT_TYPE_Text)
        {
            if (ch == WCH_NBSP && fSkipNBSP)
                continue;
                
            goto Cleanup;
        }
    } 
    while (context != CONTEXT_TYPE_NoScope);

Cleanup:
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Method:     CHTMLEditor::SetActiveCommandTarget
//
//  Synopsis:   Sets the active CMshtmlEd command target based on the
//              IHTMLDocument2 structure passed in.  The editor keeps an
//              array of CMshtmlEd structures, each one corresponds to
//              a seperate IHTMLDocument2 interface.  Since each IHTMLDocument2
//              has its own seperate selection, the tracker's need to know 
//              the active commadn target in order to add segments to the correct
//              CSelectionServices.
//
//  Arguments:  pIDoc = IHTMLDocument becoming active
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::SetActiveCommandTarget( IMarkupContainer *pIContainer )
{
    HRESULT             hr = S_OK;
    
    Assert( pIContainer );
   
    IFC( FindCommandTarget( pIContainer, &_pActiveCommandTarget ) );

    //
    // Didn't find a command target previously created for this IHTMLDocument.
    // Create one, and make it active
    //
    if( hr == S_FALSE )
    {
        IFC( AddCommandTarget( pIContainer, &_pActiveCommandTarget ) );  
    }

    //
    // Clear cached _pISelectionServices
    //
    ClearInterface( & _pISelectionServices );
    
Cleanup:    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//  Method:     CHTMLEditor::SetActiveCommandTargetFromPointer
//
//  Synopsis:   Sets the active command target based on the
//              pointer passed in.  Usually this is done when the edit context
//              is changing. 
//
//  Arguments:  pIPointer = Pointer to set active doc from
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::SetActiveCommandTargetFromPointer(IMarkupPointer *pIPointer)
{
    HRESULT             hr = S_OK;
    SP_IMarkupContainer spContainerFinal;
    SP_IMarkupContainer spContainer;

    Assert( pIPointer );

    //
    // Get the IMarkupContainer pointer
    //
    IFC( pIPointer->GetContainer( &spContainer ) );
    Assert(spContainer != NULL);

    IFC( AdjustContainerCommandTarget( spContainer, &spContainerFinal ) );

    //
    // Speedup.  Check to see if our active doc is already this one.  Only 
    // set the active doc if this is not true.
    //
    if( !_pActiveCommandTarget || !EqualContainers( spContainerFinal, _pActiveCommandTarget->GetMarkupContainer() ) )
    {
        IFC( SetActiveCommandTarget( spContainerFinal ) );
    }

    //
    // Clear cached _pISelectionServices
    //
    ClearInterface( & _pISelectionServices );
    
Cleanup:    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::ClearCommandTargets
//
//  Synopsis:   Clears the memory used by the CMshtmlEd array.
//
//  Arguments:  VOID
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::ClearCommandTargets( )
{
    HRESULT         hr = S_OK;
    
    _pActiveCommandTarget = NULL;
    // Clear all the command targets
    _aryActiveCmdTargets.ReleaseAll();

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::FindCommandTarget
//
//  Synopsis:   Finds an command target given an IHTMLDocument
//
//  Arguments:  pIContainer = IMarkupContainer to find command target for
//              ppCmdTarget = OUTPUT - Found command target
//
//  Returns:    S_OK = Found result
//              S_FALSE = Did not find CDocInfo
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::FindCommandTarget(IMarkupContainer *pIContainer, CMshtmlEd **ppCmdTarget)
{
    HRESULT     hr = S_FALSE;
    int         nCount;
    CMshtmlEd   **pTest;

    Assert( pIContainer && ppCmdTarget );

    *ppCmdTarget = NULL;
    
    //
    // Try to find an existing doc info
    //
    for( nCount = _aryActiveCmdTargets.Size(), pTest = _aryActiveCmdTargets;
         nCount > 0;
         nCount--, pTest++)
    {
        //
        // Only check the command targets if they are based off an IMarkupContainer
        // 
        if( (*pTest)->IsDocTarget() &&
            EqualContainers( (*pTest)->GetMarkupContainer(), pIContainer ) )
        {
            *ppCmdTarget = *pTest;
            hr = S_OK;
            break;
        }
    }

#if DBG == 1
    if( hr == S_OK )
    {
        TraceTag( (tagEditingExecRouting, "CHTMLEditor::FindCommandTarget: Found [%x] SelServ [%x]", *ppCmdTarget, (*ppCmdTarget)->GetSelectionServices() ) );
    }
#endif

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AddCommandTarget
//
//  Synopsis:   Adds a new CMshtmlEd for the given IHTMLDocument2 to the
//              array of command targets tracked by the editor.
//
//  Arguments:  pIDoc = IHTMLDocument to add structure for
//              ppCmdTarget = OUTPUT - Added command target
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AddCommandTarget(IMarkupContainer *pIContainer, CMshtmlEd **ppCmdTarget)
{
    HRESULT hr;
    
    Assert( pIContainer && ppCmdTarget);
    
    *ppCmdTarget = new CMshtmlEd(this, FALSE);
    
    if( *ppCmdTarget == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //
    // Initialize our command target, allowing it to create its own
    // CSelectionServices
    //
    IFC( (*ppCmdTarget)->Initialize(pIContainer) );

    //
    // Add it to our array ( already add'refed up above )
    //
    IFC( _aryActiveCmdTargets.Append( *ppCmdTarget ) );

    TraceTag( (tagEditingExecRouting, "CHTMLEditor::AddCommandTarget: Added [%x]", *ppCmdTarget ) );

Cleanup:

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::DeleteCommandTarget
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::DeleteCommandTarget(IMarkupContainer *pIContainer)
{
    HRESULT hr;
    CMshtmlEd *pCmdTarget;

    Assert( pIContainer );
    IFC( FindCommandTarget( pIContainer, &pCmdTarget ) );
    if (!SUCCEEDED(hr))
        goto Cleanup;

    if (hr == S_OK)
    {
        hr = THR(_aryActiveCmdTargets.DeleteByValue( pCmdTarget ));
        pCmdTarget->Release();
        TraceTag( (tagEditingExecRouting, "CHTMLEditor::DeleteCommandTarget: Deleted [%x]", pCmdTarget ) );
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}




//+-------------------------------------------------------------------------
//
//  Method:     CHTMLEditor::AdjutContainerCommandTarget
//
//  Synopsis:   Helper function used to adjust which markup container is 
//              actually used when dealing with swapping in and out of
//              command targets.  Inputs require that we use the
//              parent container for compat reasons.
//
//  Arguments:  pIContainer = candidate IMarkupContainer
//              ppINewContainer = OUTPUT - New container
//
//  Returns:    HRESULT indicating success
//--------------------------------------------------------------------------
HRESULT
CHTMLEditor::AdjustContainerCommandTarget(IMarkupContainer *pIContainer, IMarkupContainer **ppINewContainer)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupContainer2    spContainer2;
    SP_IHTMLElement         spElement;
    ELEMENT_TAG_ID          tagID;
    SP_IMarkupPointer       spPointer;
    
    Assert( pIContainer && ppINewContainer );

    *ppINewContainer = NULL;
    
    // We have an IMarkupContainer based context.  First, figure out if
    // this markup container is owned by an input.  If it is owned by
    // an input then (for compat reasons) we do not want to create
    // a special command target for inputs.  Instead, we want to find
    // or create the command target for the input's parent container.
    // The reason for this is because if a 
    // document.querycommandenabled("cut") is done from the parent document
    // we must return TRUE because this is what IE 5.0 did.

    IFC( pIContainer->QueryInterface( IID_IMarkupContainer2, (void **)&spContainer2 ) );
    IFC( spContainer2->GetMasterElement(&spElement) );

    if( spElement )
    {
        IFC( GetMarkupServices()->GetElementTagId( spElement, &tagID ) );

        if( tagID == TAGID_INPUT )
        {
            IFC( CreateMarkupPointer( &spPointer ) );
            IFC( spPointer->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ) );

            IFC( spPointer->GetContainer( ppINewContainer ) );
        }
        else
        {
            ReplaceInterface( ppINewContainer, pIContainer );
        }
    }
    else
    {
        ReplaceInterface( ppINewContainer, pIContainer );
    }
    

Cleanup:
    RRETURN(hr);
}

HRESULT 
CHTMLEditor::PushCommandTarget(CMshtmlEd *pCommandTarget)
{
    HRESULT hr;
    
    hr = THR( _aryCmdTargetStack.Append( pCommandTarget) );

    RRETURN(hr);
}

HRESULT 
CHTMLEditor::PopCommandTarget(WHEN_DBG(CMshtmlEd *pCommandTarget))
{
    LONG lStackTop = _aryCmdTargetStack.Size()-1;

#if DBG==1
    Assert(pCommandTarget == _aryCmdTargetStack.Item(lStackTop));
#endif

    _aryCmdTargetStack.Delete(lStackTop);

    return S_OK;    
}

CMshtmlEd *
CHTMLEditor::TopCommandTarget()
{
    LONG lStackTop = _aryCmdTargetStack.Size()-1;

    if (lStackTop < 0)
        return NULL;

    return _aryCmdTargetStack.Item(lStackTop);
}


//+====================================================================================
//
// Method: fire On Before Selection type change
//
// Synopsis:
//
//------------------------------------------------------------------------------------
BOOL 
CHTMLEditor::FireOnSelectionChange(BOOL fIsContextEditable)
{
    HRESULT hr;
    SP_IHTMLDocument4 spDocument4;
    VARIANT_BOOL fRet = VB_TRUE;
    

    if ( fIsContextEditable )
    {    
        IFC(GetDoc()->QueryInterface(IID_IHTMLDocument4, (void **)&spDocument4));       
        IFC(spDocument4->fireEvent(_T("onselectionchange"), NULL, &fRet));
    }
    
Cleanup:

    _dwSelectionVersion++;
    
    return !!fRet;
}

HRESULT
CHTMLEditor::GetUndoManager( IOleUndoManager** ppIUndoManager )
{
    HRESULT hr;
    SP_IServiceProvider spProvider;

    Assert( ppIUndoManager );
    IFC ( _pUnkDoc->QueryInterface(IID_IServiceProvider, (void**) & spProvider ));
    IFC( spProvider->QueryService(SID_SOleUndoManager, IID_IOleUndoManager, (LPVOID *) ppIUndoManager ) );  

Cleanup:
    RRETURN ( hr );
}

HRESULT
CHTMLEditor::DoPendingTasks()
{
    HRESULT hr = S_OK;

    if (!_pSelMan->_fInitialized)
    {
        _pSelMan->Initialize();
    }
    IFC( _pSelMan->DoPendingTasks());
Cleanup:
    RRETURN( hr );
}


VOID
CHTMLEditor::SetDoc( IHTMLDocument2* pIDoc )
{
    //  The Doc maintains the actual timer ids, so we need to make sure to stop the timer
    //  before we switch docs here.  This would only affect us when we try to switch docs
    //  before we receive the timer event, which should kill the timer.  If we don't kill
    //  it here we won't be able to stop the timer later during the timer event.

    Assert(_pSelMan);

    CEditTracker    *pActiveTracker = _pSelMan->GetActiveTracker();

    if (pActiveTracker && _pSelMan->IsInTimer())
    {
        pActiveTracker->StopTimer();
    }
    
    ReplaceInterface( & _pDoc, pIDoc);
}


#ifndef NO_IME
//+====================================================================================
//
// Method:      CHTMLEditor::SetupIMEReconversion
//
// Synopsis:    IME Reconversion is off by default since it is not supported by TridentV2
//              We will query host to see if it wants IME reconversion and enable as 
//              appropriate
//
//              [zhenbinx]
//
//+=====================================================================================
HRESULT
CHTMLEditor::SetupIMEReconversion()
{
    HRESULT                 hr = S_OK;
    SP_IServiceProvider     spSP;
    SP_IDocHostUIHandler    spHostUIHandler;

    //
    // disble it by default
    //
    _fIMEReconversionEnabled = FALSE;

    
    Assert (_pUnkDoc);
    IFC( _pUnkDoc->QueryInterface(IID_IServiceProvider, reinterpret_cast<VOID **>(&spSP)) );
    spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, reinterpret_cast<VOID **>(&spHostUIHandler));
    if (spHostUIHandler)
    {
        DOCHOSTUIINFO           info;

        memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
        info.cbSize = sizeof(DOCHOSTUIINFO);

        //
        // HACKHACK: Photodraw fails GetHostInfo, so we need to 
        // avoid propagating the hr.  (bug 103706)
        // 

        if (SUCCEEDED(spHostUIHandler->GetHostInfo(&info))
            && (info.dwFlags & DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION))
        {
            _fIMEReconversionEnabled = TRUE;
        }

        //
        // CoTaskMemFree can handle NULL case.
        //
        CoTaskMemFree(info.pchHostNS);
        CoTaskMemFree(info.pchHostCss);
    }
    

Cleanup:
    RRETURN(hr);
}

void
CHTMLEditor::InitAppCompatFlags()
{
    char szModule[MAX_PATH + 1];

    if (GetModuleFileNameA(NULL, szModule, MAX_PATH))
    {
        _fInAccess = NULL != StrStrIA(szModule, "msaccess.exe");
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Method:  CHTMLEditor::SetupActiveIMM
//
// Synopsis:
//          Setup local reference to ActiveIMM instance so that the IMM wrapper function works
//          as expected.  
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT
CHTMLEditor::SetupActiveIMM(IUnknown *pIUnknown)
{
    HRESULT     hr = S_OK;

    if (!_fGotActiveIMM)
    {
        EnterCriticalSection(&g_csActiveIMM);
        if (g_pActiveIMM == NULL)
        {
            Assert (!_fGotActiveIMM);
            
            IIMEServices *pimes = NULL;
            if (pIUnknown)
            {
                hr = THR( pIUnknown->QueryInterface(IID_IIMEServices, reinterpret_cast<void **>(&pimes)) );
            }
            else
            {
                hr = THR( GetDoc()->QueryInterface(IID_IIMEServices, reinterpret_cast<void **>(&pimes)) );
            }
            
            if (SUCCEEDED(hr))
            {
                Assert (pimes);
                IGNORE_HR( pimes->GetActiveIMM(&g_pActiveIMM) );
                ReleaseInterface( pimes );
            }

            if (g_pActiveIMM)
            {
                _fGotActiveIMM  = TRUE;
                g_cRefActiveIMM = 1;
            }
        } 
        else
        {
            Assert(!_fGotActiveIMM);
             _fGotActiveIMM = TRUE;
             g_cRefActiveIMM++;
        }
        LeaveCriticalSection(&g_csActiveIMM);
    }
    
    RRETURN(hr);
}
#endif

HRESULT 
CHTMLEditor::GetBody( IHTMLElement** ppIElement, IHTMLDocument2 * pIDoc /*=NULL */ )
{
    HRESULT hr;

    Assert( ppIElement );

    if ( ! pIDoc ) 
    {
        IFC( GetDoc()->get_body( ppIElement )); 
    }
    else
    {
        IFC( pIDoc->get_body( ppIElement ));
    }
    
    if ( !*ppIElement )
    {
        hr = E_FAIL;
    }
    
Cleanup:
    RRETURN ( hr );
}


//+====================================================================================
//
// See comments on CSelectionManager::FreezeVirtualCaretPos
//
//+=====================================================================================
HRESULT
CHTMLEditor::FreezeVirtualCaretPos(BOOL fReCompute)
{
    if (!_pSelMan)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(_pSelMan->FreezeVirtualCaretPos(fReCompute));
}


//+====================================================================================
//
// See comments on CSelectionManager::UnFreezeVirtualCaretPos
//
//+=====================================================================================
HRESULT
CHTMLEditor::UnFreezeVirtualCaretPos(BOOL fReset)
{
    if (!_pSelMan)
    {
        RRETURN(E_FAIL);
    }

    RRETURN(_pSelMan->UnFreezeVirtualCaretPos(fReset));
}


//+====================================================================================
//
// Make sure CHTMLEditor is in good state
//
//+=====================================================================================
HRESULT 
CHTMLEditor::EnsureEditorState()
{
    HRESULT  hr = S_OK;

    if (!(_pTopDoc && _pUnkDoc && _pUnkContainer))
    {
        TraceTag( (tagEditingInterface, "EDITOR - initialized was not called or failed however interface was called") );
        hr = E_FAIL;
        goto Cleanup;
    }
    IFC( EnsureActiveCommandTarget() );
    IFC( EnsureSelectionMan() );
    
Cleanup:
    RRETURN(hr);
}


//
// Make sure active command target is set correctly
// otherwise reset it to the top level container
//
HRESULT 
CHTMLEditor::EnsureActiveCommandTarget()
{
    HRESULT  hr = S_OK;

    if (!_pActiveCommandTarget)
    {
        SP_IMarkupContainer  spContainerNew;
        SP_IHTMLDocument2    spHtmlDoc;
        
        Assert(_pUnkContainer );
        IFC( _pUnkContainer->QueryInterface( IID_IMarkupContainer, (void **)&spContainerNew ) );
        IFC( FindCommandTarget( spContainerNew, &_pActiveCommandTarget ) );    
        Assert(_pActiveCommandTarget);

        IFC( spContainerNew->OwningDoc(&spHtmlDoc) );
        SetDoc(spHtmlDoc);
    }
Cleanup:
    RRETURN(hr);
}


//
// Make sure selection manager is initialized
//
HRESULT CHTMLEditor::EnsureSelectionMan()
{
    if (!_pSelMan)
    {
        TraceTag( (tagEditingInterface, "EDITOR - interface called while selman does not exist") );
        return E_FAIL;
    }
    
    if (!_pSelMan->_fInitialized)
    {
        TraceTag( (tagEditingInterface, "EDITOR - interface called while SelMan is not initialized - initialize SelMan") );
        return _pSelMan->Initialize();
    }
    return S_OK;
}



BOOL 
CHTMLEditor::IsInWindow( HWND hwnd, POINT pt, BOOL fConvertToScreen /*=FALSE*/ )
{
    RECT windowRect ;
    POINT myPt;

    myPt.x = pt.x;
    myPt.y = pt.y;

    DeviceFromDocPixels(&myPt);
    
    if ( fConvertToScreen )
        ::ClientToScreen( hwnd, &myPt );

    ::GetWindowRect( hwnd, & windowRect );

    return ( ::PtInRect( &windowRect, myPt ) ); 
}


void 
CHTMLEditor::DocPixelsFromDevice(POINT *pPt)
{
    pPt->x = (pPt->x * _llogicalXDPI) / _ldeviceXDPI; 
    pPt->y = (pPt->y * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(POINT *pPt)
{
    pPt->x = (pPt->x * _ldeviceXDPI) / _llogicalXDPI; 
    pPt->y = (pPt->y * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::DocPixelsFromDevice(SIZE *pSize)
{
    pSize->cx = (pSize->cx * _llogicalXDPI) / _ldeviceXDPI; 
    pSize->cy = (pSize->cy * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(SIZE *pSize)
{
    pSize->cx = (pSize->cx * _ldeviceXDPI) / _llogicalXDPI; 
    pSize->cy = (pSize->cy * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::DocPixelsFromDevice(RECT *pRect)
{
    pRect->left = (pRect->left * _llogicalXDPI) / _ldeviceXDPI; 
    pRect->right = (pRect->right * _llogicalXDPI) / _ldeviceXDPI; 
    pRect->top = (pRect->top * _llogicalYDPI) / _ldeviceYDPI; 
    pRect->bottom = (pRect->bottom * _llogicalYDPI) / _ldeviceYDPI; 
}

void 
CHTMLEditor::DeviceFromDocPixels(RECT *pRect)
{
    pRect->left = (pRect->left * _ldeviceXDPI) / _llogicalXDPI; 
    pRect->right = (pRect->right * _ldeviceXDPI) / _llogicalXDPI; 
    pRect->top = (pRect->top * _ldeviceYDPI) / _llogicalYDPI; 
    pRect->bottom = (pRect->bottom * _ldeviceYDPI) / _llogicalYDPI; 
}

void 
CHTMLEditor::ClientToScreen(HWND hwnd, POINT * pPt)
{
    // return logical coordinates
    DeviceFromDocPixels(pPt);
    ::ClientToScreen(hwnd, pPt);
    DocPixelsFromDevice(pPt);
}

void 
CHTMLEditor::GetWindowRect(HWND hwnd, RECT * pRect)
{
    // return logical coordinates
    ::GetWindowRect(hwnd, pRect);
    DocPixelsFromDevice(pRect);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\ime.cxx ===
/*
 *  @doc    INTERNAL
 *
 *  @module ime.cpp -- support for Win95 IME API |
 *
 *      Most everything to do with FE composition string editing passes
 *      through here.
 *
 *  Authors: <nl>
 *      Jon Matousek <nl>
 *      Hon Wah Chan <nl>
 *      Justin Voskuhl <nl>
 *
 *  History: <nl>
 *      10/18/1995      jonmat  Cleaned up level 2 code and converted it into
 *                              a class hierarchy supporting level 3.
 *
 *  Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef NO_IME /*{*/

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "OptsHold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMANK_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDTRACK_HXX_
#define X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_EDUNDO_HXX_
#define _X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X__IME_HXX_
#define X__IME_HXX_
#include "ime.hxx"
#endif


#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

DeclareTag(tagEdIME, "Edit", "IME execution")
DeclareTag(tagEdIMEAttr, "Edit", "IME Attributes in CompositionString")
MtDefine(CIme, Dialogs, "CIme")
MtDefine( CIme_arySegments_pv, Utilities, "CIME Attribute Segments" )    


#if DBG == 1
static const LPCTSTR strImeIP = _T( "    ** IME IP");
static const LPCTSTR strImeUncommittedStart = _T( "    ** IME Uncommitted Start");
static const LPCTSTR strImeUncommittedEnd = _T( "    ** IME Uncommitted End");
#endif


// default caret width
#define DXCARET 1

BOOL forceLevel2 = FALSE;

#if DBG==1
static const LPCTSTR strImeHighlightStart = _T( "    ** IME Highlight Start");
static const LPCTSTR strImeHighlightEnd = _T( "    ** IME Highlight End");
#endif

#define _TODO(x)

//
// LPARAM helpers
//

inline BOOL HaveCompositionString(LONG lparam) { return ( 0 != (lparam & (GCS_COMPSTR | GCS_COMPATTR))); }
inline BOOL CleanupCompositionString(LONG lparam) { return ( 0 == lparam ); }
inline BOOL HaveResultString(LONG lparam) { return (0 != (lparam & GCS_RESULTSTR)); }

//+--------------------------------------------------------------------------
//
//  method:     IsIMEComposition
//
//  returns:    BOOLEAN - Return TRUE if we have a IME object on the textsite.
//              If argument is FALSE, only return TRUE if the IME object is
//              not of class CIme_Protected.
//
//---------------------------------------------------------------------------

BOOL
CSelectionManager::IsIMEComposition( BOOL fProtectedOK /* = TRUE */ )
{
    return (_pIme != NULL && (fProtectedOK || !_pIme->IsProtected()));
};

//+--------------------------------------------------------------------------
//
//  method:     UpdateIMEPosition
//
//  purpose:    This method should be called to update the IME insertion
//              pointer as well as notifying the main IME window that the 
//              position of our caret has changed.
//
//  returns:    HRESULT - FAILED(hr) if there was a failure attempting to 
//              move the IME position
//
//---------------------------------------------------------------------------
HRESULT CSelectionManager::UpdateIMEPosition( void )
{
    HRESULT hr = S_OK;
    
    Assert( _pIme != NULL );

    if( !_pIme->_fInsertInProgress )
    {
        hr = _pIme->UpdateInsertionPoint();

        if( SUCCEEDED(hr) )
        {
            _pIme->SetCompositionForm();
        }
    }

    RRETURN(hr);
}

//+--------------------------------------------------------------------------
//
//  method:     ImmGetContext
//
//  returns:    Get the IMM context associated with the document window
//
//---------------------------------------------------------------------------

HIMC
CSelectionManager::ImmGetContext(void)
{
    HWND hwnd = NULL;
    HRESULT hr;
    SP_IOleWindow spOleWindow;
    hr = THR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (!hr)
        hr = THR(spOleWindow->GetWindow(&hwnd));

    Assert( hwnd );
    return OK(hr) ? ::ImmGetContext( hwnd ) : NULL;
}

//+--------------------------------------------------------------------------
//
//  method:     ImmReleaseContext
//
//  returns:    Release the IMM context associated with the document window
//
//---------------------------------------------------------------------------

void
CSelectionManager::ImmReleaseContext( HIMC himc )
{
    HWND hwnd = NULL;
    HRESULT hr;
    SP_IOleWindow spOleWindow;
    hr = THR(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    if (!hr)
        hr = THR(spOleWindow->GetWindow(&hwnd));

    Assert( hwnd );
    if (OK(hr))
    {
        ::ImmReleaseContext( hwnd, himc );
    }
}


//+--------------------------------------------------------------------------
//
//  method:     SetCaretVisible
//
//---------------------------------------------------------------------------

HRESULT
CIme::SetCaretVisible( BOOL fVisible )
{
    HRESULT hr;

    TraceTag((tagEdIME, "CIme::SetCaretVisible: fVisible [%d]", fVisible) );

    if (_fCaretVisible != fVisible)
    {
        hr = THR(SetCaretVisible( _pManager->GetDoc(), _fCaretVisible = fVisible ));
    }
    else
    {
        hr = S_OK;
    }

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  HRESULT StartCompositionGlue( BOOL fIsProtected, TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Initiates an IME composition string edit.
//  @comm
//      Called from the message loop to handle EVT_IME_STARTCOMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//
//  @devnote
//      We decide if we are going to do a level 2 or level 3 IME
//      composition string edit. Currently, the only reason to
//      create a level 2 IME is if the IME has a special UI, or it is
//      a "near caret" IME, such as the ones found in PRC and Taiwan.
//      Near caret simply means that a very small window opens up
//      near the caret, but not on or at the caret.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::StartCompositionGlue(
    BOOL fIsProtected,
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    CSelectTracker * pSelectTracker = NULL;
    CCaretTracker *pCaretTracker = NULL;

    // note that in some locales (PRC), we may still be in composition mode
    // when a new start composition call comes in.  Just reset our state
    // and go on.

    _codepageKeyboard = GetKeyboardCodePage();
    _fIgnoreImeCharMsg = FALSE;

    if ( !IsIMEComposition() )
    {
        if( _pActiveTracker )
        {
            switch (_pActiveTracker->GetTrackerType())
            {
                case TRACKER_TYPE_Selection:
                    pSelectTracker = DYNCAST( CSelectTracker, _pActiveTracker );

                    if (!pSelectTracker->EndPointsInSameFlowLayout())
                    {
                        fIsProtected = TRUE;
                    }

                    break;

                case TRACKER_TYPE_Control:
                    fIsProtected = TRUE;
                    break;

                case TRACKER_TYPE_Caret:
                    pCaretTracker = DYNCAST( CCaretTracker, _pActiveTracker );
                    Assert(pCaretTracker);

                    IFC( pCaretTracker->TerminateTypingBatch() );
                    break;
            }
        }            
        
        if ( fIsProtected )
        {
            // protect or read-only, need to ignore all ime input

            _pIme = new CIme_Protected(this);
        }
        else
        {
            // if a special UI, or IME is "near caret", then drop into lev. 2 mode.
            DWORD imeProperties = ImmGetProperty( GetKeyboardLayout(0), IGP_PROPERTY );

            if (    0 != ( imeProperties & IME_PROP_SPECIAL_UI )
                 || 0 == ( imeProperties & IME_PROP_AT_CARET )
                 || forceLevel2 )
            {
                _pIme = new CIme_Lev2( this );     // level 2 IME.
            }
            else
            {
                _pIme = new CIme_Lev3( this );     // level 3 IME->TrueInline.
            }
        }

        if(_pIme == NULL)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            IFC( _pIme->Init() );
        }
    }

    if ( IsIMEComposition() )                    // make the method call.
    {
        if (pEvent)
        {
            if (pSelectTracker || _pIme->_fHanjaMode)
            {
                _pIme->_fHanjaMode = FALSE;
                if (!fIsProtected)
                {
                    
                    // $- Why was this HR dropped
                    IGNORE_HR( DeleteRebubble( pEvent ) );

                    //
                    // We had a selection and deleted it. We need to 
                    // commit the undo unit created by the IME, and then re-open 
                    // another one after the selection is deleted so that the 
                    // previous selection can be restored even if the IME composition
                    // is canceled.
                    //
                    Assert( _pCaretTracker );
                    IFC( _pCaretTracker->TerminateTypingBatch() );
                    IFC( _pIme->CloseUndoUnit(TRUE) );
                    IFC( _pIme->OpenUndoUnit() );
                }
            }
            else if (!fIsProtected && (!_pActiveTracker || _pActiveTracker->GetTrackerType() != TRACKER_TYPE_Caret))
            {
                hr = THR( PositionCaret( pEvent ));
            }
        }
        //
        // Do NOT Move this line up!
        // In case of DeleteRebubble,
        // we need the hr vaule from
        // StartComposition instead
        // of from the above!
        //
        // [zhenbinx]
        //
        hr = _pIme->StartComposition(); 
    }

Cleanup:

    RRETURN1(hr,  S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT CompositionStringGlue( const LPARAM lparam, TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Handle all intermediary and final composition strings.
//
//  @comm
//      Called from the message loop to handle EVT_IME_COMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//      We may be called independently of a EVT_IME_STARTCOMPOSITION
//      message, in which case we return S_FALSE to allow the
//      DefWindowProc to return EVT_IME_CHAR messages.
//
//  @devnote
//      Side Effect: the _ime object may be deleted if composition
//      string processing is finished.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::CompositionStringGlue(
    const LPARAM lparam,
    CEditEvent* pEvent)
{
    HRESULT hr;

    _fIgnoreImeCharMsg = FALSE;

    // Retrieve the codepage for the current thread
    _codepageKeyboard = GetKeyboardCodePage();
    
    if ( IsIMEComposition() )
    {        
        _pIme->_compMessageRefCount++;            // For proper deletion.

        hr = _pIme->CompositionString(lparam, pEvent );

        _pIme->_compMessageRefCount--;            // For proper deletion.

        Assert ( _pIme->_compMessageRefCount >= 0);

        CheckDestroyIME(pEvent);         // Finished processing?
    }
    else  
    {
        //
        // Review-2000/07/24-zhenbinx:  We would need to know if IME message
        // if fired on editable element. Now that Trident disables IME if 
        // an non-editable element becomes current, we will not need to 
        // test against editability
        //
    
        //
        // Handle a 'naked' EVT_IME_COMPOSITION message.  Naked implies
        // that this IME message came *after* the EVT_IME_ENDCOMPOSITION
        // message.
        //
    
        hr = S_FALSE;

        // even when not in composition mode, we may receive a result string.

        if ( pEvent && _pActiveTracker)
        {
            if (_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection)
            {
                CSelectTracker * pSelectTracker = DYNCAST( CSelectTracker, _pActiveTracker );

                if (pSelectTracker->EndPointsInSameFlowLayout())
                {
                    IFC( DeleteRebubble( pEvent ));
                }
            }
            else if (_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret)
            {
                CImeDummy ime( this );

                IFC( ime.Init() );
                _fIgnoreImeCharMsg = TRUE; // Ignore the next EVT_IME_CHAR message
                
                hr = THR( ime.CheckInsertResultString( lparam ) );
                IFC( ime.Deinit() );
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT EndCompositionGlue( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Composition string processing is about to end.
//
//  @comm
//      Called from the message loop to handle EVT_IME_ENDCOMPOSITION.
//      This is a glue routine into the IME object hierarchy.
//
//  @devnote
//      The only time we have to handle EVT_IME_ENDCOMPOSITION is when the
//      user changes input method during typing.  For such case, we will get
//      a EVT_IME_ENDCOMPOSITION message without getting a EVT_IME_COMPOSITION
//      message with GCS_RESULTSTR later.  So, we will call CompositionStringGlue
//      with GCS_RESULTSTR to let CompositionString to get rid of the string.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::EndCompositionGlue( CEditEvent* pEvent )
{
    if ( IsIMEComposition() )
    {
        // set this flag. If we are still in composition mode, then
        // let the CompositionStringGlue() to destroy the ime object.
        _pIme->_fDestroy = TRUE;

        // remove any remaining composition string.
        CompositionStringGlue( GCS_COMPSTR, pEvent );

        // finished with IME, destroy it.
        CheckDestroyIME( pEvent );
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  void CheckDestroyIME ( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Check for IME and see detroy if it needs it..
//
//-----------------------------------------------------------------------------

void
CSelectionManager::CheckDestroyIME(CEditEvent* pEvent )
{
    if ( IsIMEComposition() && _pIme->_fDestroy )
    {
        if ( 0 == _pIme->_compMessageRefCount )
        {
            _pIme->Deinit();
            delete _pIme;
            _pIme = NULL;

            // If the Caret tracker is currently active, then 
            // reposition the caret tracker so that a caret is displayed 
            // when we go away.
            if( pEvent && _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret )
            {
                IGNORE_HR( PositionCaret( pEvent ) );
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  void PostIMECharGlue()
//
//  @func
//      Called after processing a single EVT_IME_CHAR in order to
//      update the position of the IME's composition window. This
//      is glue code to call the CIME virtual equivalent.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::PostIMECharGlue(  )
{
    if ( IsIMEComposition() )
    {
        _pIme->PostIMEChar();
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  void CompositionFullGlue( TRACKER_NOTIFY * peTrackerNotify )
//
//  @func
//      Current IME Composition window is full.
//
//  @comm
//      Called from the message loop to handle EVT_IME_COMPOSITIONFULL.
//      This message applied to Level 2 only.  We will use the default
//      IME Composition window.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::CompositionFullGlue( )
{
    if ( IsIMEComposition() )
    {
        HIMC hIMC = ImmGetContext();

        if ( hIMC )
        {
            COMPOSITIONFORM cf;

            // no room for text input in the current level 2 IME window,
            // fall back to use the default IME window for input.

            cf.dwStyle = CFS_DEFAULT;
            ImmSetCompositionWindow( hIMC, &cf );  // Set composition window.
            ImmReleaseContext( hIMC );             // Done with IME context.
        }
    }

    return S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  function:   CSelectionManager::ClearHighlightSegments()
//
//-----------------------------------------------------------------------------

HRESULT
CIme::ClearHighlightSegments()
{
    IHighlightSegment   **ppSegment;
    int                 i;
    HRESULT             hr = S_OK;

    for( i = _arySegments.Size(), ppSegment = _arySegments;
         i > 0;
         i--, ppSegment++)
    {
        IFC( _pManager->GetEditor()->GetHighlightServices()->RemoveSegment( *ppSegment ) );
    }

    _arySegments.ReleaseAll();

Cleanup:    
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  function:   CSelectionManager::AddHighlightSegment()
//
//  synopsis:   Is index even used? flast?  Documentation on this function?
//
//-----------------------------------------------------------------------------
HRESULT
CIme::AddHighlightSegment(LONG              ichMin,
                          LONG              ichMost,
                          IHTMLRenderStyle *pIRenderStyle )
{
    HRESULT             hr;
    CEditPointer        epStart(_pManager->GetEditor());
    CEditPointer        epEnd(_pManager->GetEditor());
    DWORD               dwSearch = BREAK_CONDITION_Text;
    DWORD               dwFound;
    int                 ich;
    IHighlightSegment   *pISegment = NULL;
    SP_IDisplayPointer  spDispStart;
    SP_IDisplayPointer  spDispEnd;
 
    Assert( ichMost >= ichMin );

    // Move to the start pointer
    IFC( epStart->MoveToPointer( _pmpStartUncommitted ) );

    // Scan thru the string, finding the start position
    for (ich = 0; ich < ichMin; ich++)
    {
        IFC( epStart.Scan(RIGHT, dwSearch, &dwFound) );

        if (!epStart.CheckFlag(dwFound, dwSearch))
            break;
    }

    // Find the end position
    IFC( epEnd->MoveToPointer( epStart ) );
    for (; ich < ichMost; ich++)
    {
        IFC( epStart.Scan(RIGHT, dwSearch, &dwFound) );

        if (!epStart.CheckFlag(dwFound, dwSearch))
            break;
    }        

    // Add our segment
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
    IFC( spDispStart->MoveToMarkupPointer(epStart, NULL) );
    
    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
    IFC( spDispEnd->MoveToMarkupPointer(epEnd, NULL) );
    
    IFC( _pManager->GetEditor()->GetHighlightServices()->AddSegment( spDispStart, spDispEnd, pIRenderStyle, &pISegment ) );
    IFC( _arySegments.Append(pISegment) );

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  INT CIme::GetCompositionStringInfo( CCaretTracker * pCT, DWORD dwIndex,
//            WCHAR * achCompStr, INT cchMax, BYTE * pbAttrib, INT cbAttrib
//            LONG * pcchAttrib )
//
//  @mfunc
//      For EVT_IME_COMPOSITION string processing to get the requested
//      composition string, by type, and convert it to Unicode.
//
//  @devnote
//      We must use ImmGetCompositionStringA because W is not supported
//      on Win95.
//
//  @rdesc
//      INT-cch of the Unicode composition string. In error cases, return 0
//      Out param in UniCompStr.
//
//-----------------------------------------------------------------------------

INT
CIme::GetCompositionStringInfo(
    DWORD dwIndex,      // @parm The type of composition string.
    WCHAR *pchCompStr,  // @parm Out param, unicode result string.
    INT cchMax,         // @parm The cch for the Out param.
    BYTE *pbAttrib,     // @parm Out param, If attribute info is needed.
    INT cbMax,          // @parm The cb of the attribute info.
    LONG *pichCursor,   // @parm Out param, returns the CP of cusor.
    LONG *pcchAttrib )  // @parm how many attributes returned.
{
    BYTE abCompStr[256];
    INT cbCompStr, cchCompStr;
    HIMC hIMC = ImmGetContext();

    if (hIMC)
    {
        const BOOL fIsOnNT = _pManager->IsOnNT();
        
        Assert ( pchCompStr );
        Assert(cchMax > 0);

        AssertSz(    dwIndex == GCS_COMPREADSTR
                  || dwIndex == GCS_COMPSTR
                  || dwIndex == GCS_RESULTREADSTR
                  || dwIndex == GCS_RESULTSTR,
                  "String function expected" );

        if ( pichCursor )                                 // Init cursor out param.
           *pichCursor = -1;
        if ( pcchAttrib )
           *pcchAttrib = 0;
                                                        // Get composition string.
        if (fIsOnNT)
        {
            cbCompStr = ImmGetCompositionStringW( hIMC, dwIndex, pchCompStr, ( cchMax - 1 ) * sizeof(WCHAR) );
            cchCompStr = (cbCompStr > 0) ? (cbCompStr/sizeof(TCHAR)) : 0;
            pchCompStr[(cchCompStr < cchMax) ? cchCompStr : (cchMax - 1)] = 0;
        }
        else
        {
            cbCompStr = ImmGetCompositionStringA( hIMC, dwIndex, abCompStr, sizeof(abCompStr) - 1 );

            if (cbCompStr > 0 && *abCompStr)              // If valid data.
            {
                Assert ( (cbCompStr >> 1) < (cchMax - 1) ); // Convert to Unicode.
                cchCompStr = MultiByteToWideChar( _pManager->KeyboardCodePage(), 0,
                                                  (CHAR *) abCompStr, cbCompStr,
                                                  pchCompStr, cchMax );
                pchCompStr[(cchCompStr < cchMax) ? cchCompStr : (cchMax - 1)] = 0;
            }
            else
            {
                cchCompStr = 0;
                pchCompStr[0] = 0;
            }
        }

        if ( cchCompStr > 0 && *pchCompStr )            // If valid data.
        {
            if ( pbAttrib || pichCursor )               // Need cursor or attribs?
            {
                INT ichCursor=0, cchAttrib;

                if (fIsOnNT)
                {
                    ichCursor = ImmGetCompositionStringW( hIMC, GCS_CURSORPOS, NULL, 0 );
                    cchAttrib = ImmGetCompositionStringW( hIMC, GCS_COMPATTR, pbAttrib, cbMax );
                }
                else
                {
                    INT ib, ich;
                    INT ibCursor, ibMax, cbAttrib;
                    BYTE abAttribLocal[256];
                    BYTE * pbAttribPtr = pbAttrib;

                    ibCursor = ImmGetCompositionStringA( hIMC, GCS_CURSORPOS, NULL, 0 );
                    cbAttrib = ImmGetCompositionStringA( hIMC, GCS_COMPATTR, abAttribLocal, 255 );

                                                        // MultiToWide conversion.
                    ibMax = max( ibCursor, cbAttrib );
                    if ( NULL == pbAttrib ) cbMax = cbAttrib;

                    for (ib = 0, ich = 0; ib <= ibMax && ich < cbMax; ib++, ich++ )
                    {
                        if ( ibCursor == ib )           // Cursor from DBCS.
                            ichCursor = ich;

                        if ( IsDBCSLeadByteEx( KeyboardCodePage(), abCompStr[ib] ) )
                            ib++;

                        if ( pbAttribPtr && ib < cbAttrib )  // Attrib from DBCS.
                            *pbAttribPtr++ = abAttribLocal[ib];
                    }

                    cchAttrib = ich - 1;
                }

                if ( ichCursor >= 0 && pichCursor )     // If client needs cursor
                    *pichCursor = ichCursor;            //  or cchAttrib.
                if ( cchAttrib >= 0 && pcchAttrib )
                    *pcchAttrib = cchAttrib;
            }
        }
        else
        {
            if ( pichCursor )
                *pichCursor = 0;
            cchCompStr = 0;
        }

        ImmReleaseContext(hIMC);
    }
    else
    {
        cchCompStr = 0;
        pchCompStr[0] = 0;
    }

    return cchCompStr;
}

//+----------------------------------------------------------------------------
//  void CIme::SetCompositionFont ( BOOL *pfUnderLineMode )
//
//  @mfunc
//      Important for level 2 IME so that the composition window
//      has the correct font. The lfw to lfa copy is due to the fact that
//      Win95 does not support the W)ide call.
//      It is also important for both level 2 and level 3 IME so that
//      the candidate list window has the proper. font.
//
//-----------------------------------------------------------------------------

void /* static */
CIme::SetCompositionFont (
    BOOL     *pfUnderLineMode)  // @parm the original char Underline mode
{
    // Todo: (cthrash) We don't support this currently.  Didn't in IE4 either.

    pfUnderLineMode = FALSE;
}

//+----------------------------------------------------------------------------
//
//  funtion:    CIme::GetCompositionPos( POINT * ppt, RECT * prc )
//
//  synopsis:   Determine the position for composition windows, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CIme::GetCompositionPos(
    POINT * ppt,
    RECT * prc,
    long * plLineHeight )
{
    HWND hwnd;
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IHTMLCaret spCaret;
    SP_IOleWindow spOleWindow;
    SP_IDisplayPointer spDispPos;
    SP_IMarkupPointer spInsertionPoint;
    SP_ILineInfo spLineInfo;
    LONG lTextDescent;
    
    IFC( _pManager->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
    
    Assert(ppt && prc && plLineHeight);

    //
    // We get the line dimensions at the position of the caret. I realize we could
    // get some of the data from the caret, but we have to call through this way
    // anyway to get the descent and line height.
    //

    IFC( GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( spDispPos ));
    IFC( spDispPos->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_x(&ppt->x) );
    
    IFC( spLineInfo->get_baseLine(&ppt->y) );
    IFC( spLineInfo->get_textDescent(&lTextDescent) );
    ppt->y += lTextDescent;

    IFC( spLineInfo->get_textHeight(plLineHeight) );

    IFC( _pManager->GetEditor()->CreateMarkupPointer(&spInsertionPoint) );
    IFC( _pDispInsertionPoint->PositionMarkupPointer(spInsertionPoint) );
    IFC( _pDispInsertionPoint->GetFlowElement( &spElement ));
    if ( ! spElement )
    {
        IFC( _pManager->GetEditableElement( & spElement ));
    }

    IFC( GetDisplayServices()->TransformPoint( ppt, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spElement ));
    IFC(_pManager->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    IFC(spOleWindow->GetWindow(&hwnd));

    ::GetClientRect(hwnd, prc);
    _pManager->GetEditor()->DeviceFromDocPixels(ppt);

Cleanup:
    RRETURN(hr);    
}


//+----------------------------------------------------------------------------
//  Method:     HRESULT CIme::UpdateInsertionPoint()
//
//  Purpose:    This method should be called to update the IME insertion 
//              position.
//
//  Returns:    HRESULT - FAILED(hr) if there was a failure attempting to 
//              move the IME position
//
//-----------------------------------------------------------------------------

HRESULT
CIme::UpdateInsertionPoint()
{
    HRESULT hr = S_OK;
    SP_IHTMLCaret spCaret;

    // Get the current caret position
    IFC( _pManager->GetDisplayServices()->GetCaret( &spCaret ) );

    // Adjust the IME markup pointers
    IFC( spCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );
    IFC( AdjustUncommittedRangeAroundInsertionPoint() );

Cleanup:

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  void CIme::SetCompositionForm ()
//
//  @mfunc
//      Important for level 2 IME so that the composition window
//      is positioned correctly.
//
//  @comm
//      We go through a lot of work to get the correct height. This requires
//      getting information from the font cache and the selection.
//
//-----------------------------------------------------------------------------

void
CIme::SetCompositionForm()
{
    if ( IME_LEVEL_2 == GetIMELevel() )
    {
        HIMC hIMC = ImmGetContext();                // Get host's IME context.

        if ( hIMC )
        {
            COMPOSITIONFORM cf;
            long lLineHeight;
            HRESULT hr = THR( GetCompositionPos( &cf.ptCurrentPos, &cf.rcArea, &lLineHeight ) );

            if (OK(hr))
            {

                // Bounding rect for the IME (lev 2) composition window, causing
                //  composition text to be wrapped within it.
                cf.dwStyle = CFS_POINT + CFS_FORCE_POSITION;

                // Make sure the starting point is not
                // outside the rcArea.  This happens when
                // there is no text on the current line and the user
                // has selected a large font size.

                if (cf.ptCurrentPos.y < cf.rcArea.top)
                    cf.ptCurrentPos.y = cf.rcArea.top;
                else if (cf.ptCurrentPos.y > cf.rcArea.bottom)
                    cf.ptCurrentPos.y = cf.rcArea.bottom;

                if (cf.ptCurrentPos.x < cf.rcArea.left)
                    cf.ptCurrentPos.x = cf.rcArea.left;
                else if (cf.ptCurrentPos.x > cf.rcArea.right)
                    cf.ptCurrentPos.x = cf.rcArea.right;

                ImmSetCompositionWindow( hIMC, &cf );  // Set composition window.
            }

            ImmReleaseContext( hIMC );             // Done with IME context.
        }
    }
}



//+----------------------------------------------------------------------------
//
//  CIme::TerminateIMEComposition ( TerminateMode mode )
//
//  @mfunc  Terminate the IME Composition mode using CPS_COMPLETE
//  @comm   The IME will generate EVT_IME_COMPOSITION with the result string
//
//
//-----------------------------------------------------------------------------

void
CIme::TerminateIMEComposition(
    DWORD dwMode,
    CEditEvent* pEvent)
{
    TraceTag((tagEdIME, "CIme::TerminateIMEComposition:"));

    DWORD dwTerminateMethod = CPS_COMPLETE;

    if (    IME_LEVEL_2 == GetIMELevel()                // force cancel for near-caret IME
         || dwMode == TERMINATE_FORCECANCEL             // caller wants force cancel
         || _pManager->IsImeCancelComplete() )          // Client wants force cancel
    {
        dwTerminateMethod = CPS_CANCEL;
    }

    HIMC hIMC = ImmGetContext();

    // force the IME to terminate the current session
    if (hIMC)
    {
        _compMessageRefCount++; // primitive addref

        BOOL retCode = ImmNotifyIME( hIMC, NI_COMPOSITIONSTR, dwTerminateMethod, 0 );

        if ( !retCode && !_pManager->IsImeCancelComplete() )
        {
            // CPS_COMPLETE fail, try CPS_CANCEL.  This happen with some ime which do not support
            // CPS_COMPLETE option (e.g. ABC IME version 4 with Win95 simplified Chinese)

            retCode = ImmNotifyIME( hIMC, NI_COMPOSITIONSTR, CPS_CANCEL, 0);
        }

        Assert ( retCode );

        ImmReleaseContext( hIMC );

        _compMessageRefCount--; // primitive release

        _pManager->CheckDestroyIME(pEvent);
    }
    else
    {
        // for some reason, we didn't have a context, yet we thought we were still in IME
        // compostition mode.  Just force a shutdown here.

        _pManager->EndCompositionGlue( pEvent);
    }
}


//+----------------------------------------------------------------------------
//
//  CIme::CIme
//
//-----------------------------------------------------------------------------

CIme::CIme( CSelectionManager * pManager ) :  _pManager(pManager)
{
    _pBatchPUU = NULL;
}

CIme::~CIme()
{
    TraceTag((tagEdIME, "CIme::~CIme"));
}

//+----------------------------------------------------------------------------
//
//  CIme_Lev2::CIme_Lev2()
//
//  @mfunc
//      CIme_Lev2 Constructor/Destructor.
//
//  @comm
//      Needed to make sure _iFormatSave was handled properly.
//
//-----------------------------------------------------------------------------

CIme_Lev2::CIme_Lev2( CSelectionManager * pManager ) : CIme( pManager )     // @parm the containing text edit.
{
    LONG    iFormat = 0;

    SetIMECaretWidth( DXCARET );           // setup initial caret width
    _iFormatSave = iFormat;

    // hold notification unless client has set IMF_IMEALWAYSSENDNOTIFY via EM_SETLANGOPTIONS msg
    _fHoldNotify = !pManager->IsImeAlwaysNotify();
}

CIme_Lev2::~CIme_Lev2()
{
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::StartComposition()
//
//  @mfunc
//      Begin IME Level 2 composition string processing.
//
//  @comm
//      Set the font, and location of the composition window which includes
//      a bounding rect and the start position of the cursor. Also, reset
//      the candidate window to allow the IME to set its position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------


HRESULT
CIme_Lev2::StartComposition( )
{
    TraceTag((tagEdIME, "CIme_Lev2::StartComposition:"));

    _imeLevel = IME_LEVEL_2;

    SetCompositionFont(&_fUnderLineMode);     // Set font, & comp window.
    SetCompositionForm( );

    return S_FALSE;           // Allow DefWindowProc processing.
}                                                   

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::CompositionString( LPARAM lparam )
//
//  @mfunc
//      Handle Level 2 EVT_IME_COMPOSITION messages.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing.
//
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//          The Host needs to mask out the lparam before calling DefWindowProc to
//          prevent unnessary EVT_IME_CHAR messages.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev2::CompositionString (
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    TraceTag((tagEdIME, "CIme_Lev2::CompositionString: HaveResultString [%d]", HaveResultString(lparam) ));

    _fIgnoreIMEChar = FALSE;

    if ( HaveResultString(lparam) )
    {
        CheckInsertResultString( lparam );
        SetCompositionForm( );                   // Move Composition window.

        _fHoldNotify = FALSE;                       // OK notify client for change

    #if DUNNO /*{*/
        // In case our host is not turning off the ResultString bit
        // we need to ignore EVT_IME_CHAR or else we will get the same
        // DBC again.
        if ( !ts.fInOurHost() )
            _fIgnoreIMEChar = TRUE;
    #else
        _fIgnoreIMEChar = TRUE;
    #endif /*}*/
    }

    // Always return S_FALSE so the DefWindowProc will handle the rest.
    // Host has to mask out the ResultString bit to avoid EVT_IME_CHAR coming in.
    return S_FALSE;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme::CheckInsertResultString ( const LPARAM lparam )
//
//  @mfunc
//      handle inserting of GCS_RESULTSTR text, the final composed text.
//
//  @comm
//      When the final composition string arrives we grab it and set it into the text.
//
//  @devnote
//      A GCS_RESULTSTR message can arrive and the IME will *still* be in
//      composition string mode. This occurs because the IME's internal
//      buffers overflowed and it needs to convert the beginning of the buffer
//      to clear out some room. When this happens we need to insert the
//      converted text as normal, but remain in composition processing mode.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//
//-----------------------------------------------------------------------------


HRESULT
CIme::CheckInsertResultString (
    const LPARAM lparam )
{
    HRESULT hr = S_OK;
    CCaretTracker * pCaretTracker = NULL;

    TraceTag((tagEdIME, "CIme::CheckInsertResultString: CleanupCompositionString [%d] HaveResultString [%d]", CleanupCompositionString(lparam), HaveResultString(lparam) ));

    if ( CleanupCompositionString(lparam) || HaveResultString(lparam) )      // If result string..
    {
        LONG    cch;                    // Count of final result string
        WCHAR   achCompStr[256];        // Characters for result string

        if (S_OK != GetCaretTracker( &pCaretTracker ))
            goto Cleanup;

        
        // Get result string.
        cch = (LONG)GetCompositionStringInfo( GCS_RESULTSTR,
                                              achCompStr, ARRAY_SIZE(achCompStr),
                                              NULL, 0, NULL, NULL );


        if (( achCompStr[0] == 32) && (cch == 1))
        {
            //
            // What is this?  Just a quick test with the 
            // Korean and Japanese IMEs shows this is worthless.  We
            // are in a Unicode enviroment, checking for space
            // like this is completely worthless.  Look into 
            // removing
            //
            AssertSz(FALSE, "We should never be here");
            hr = THR( pCaretTracker->HandleSpace( achCompStr[0] ));            
        }
        else
        {
            // Make sure we don't exceed the maximum allowed for edit box.
#if TODO /*{*/
            LONG cchMax = psel->GetCommonContainer()->HasFlowLayout()->GetMaxLength()    // total
                          - ts.GetContentMarkup()->GetTextLength()                       // already occupied
                          + psel->GetCch();                                              // about to be deleted
#else
            LONG cchMax = MAXLONG;
#endif /*}*/
            cch = min( cch, cchMax );

            //
            // Perform a URL auto-detection ( we have a result, which may contain
            // one or more spaces )
            //
            if( HaveResultString(lparam) )
            {
                IGNORE_HR( pCaretTracker->UrlAutodetectCurrentWord(NULL) );
            }

            IFC( ReplaceRange(achCompStr, cch, TRUE, -1, TRUE) );

#if TODO /*{*/
            // (cthrash) necessary?
            if (cch)
            {
                psel->LaunderSpaces( psel->GetCpMin(), cch );
            }
#endif /*}*/
            // If we didn't accept anything, let the caller know to
            // terminate the composition.  We can't directly terminate here
            // as we may end up in a recursive call to our caller.
            hr = (cch == cchMax) ? S_FALSE : S_OK;
        }

        // We have had a successful composition.  Set fResultOccurred to 
        // TRUE so that the caret will be repositioned on the next composition.
        _fResultOccurred = TRUE;        

        // Close out the current undo sequence (saving the undo unit only if we
        // had a result string ).  Open another undo unit for any further compositions.
        IFC( CloseUndoUnit( HaveResultString(lparam) ) );
        IFC( OpenUndoUnit() );
    }

Cleanup:

    if (pCaretTracker)
        pCaretTracker->Release();

    RRETURN1(hr,S_FALSE);
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev2::IMENotify( const WPARAM wparam, const LPARAM lparam )
//
//  @mfunc
//      Handle Level 2 EVT_IME_NOTIFY messages.
//
//  @comm
//      Currently we are only interested in knowing when to reset
//      the candidate window's position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::NotifyGlue(
    const WPARAM wparam,
    const LPARAM lparam)
{
    HRESULT hr = S_FALSE;
    
    if (IsIMEComposition())
    {
        hr = THR(_pIme->IMENotify(wparam,lparam));
    }

    RRETURN1(hr,S_FALSE);
}
                             
HRESULT
CIme_Lev2::IMENotify(
    const WPARAM wparam,
    const LPARAM lparam )
{
    TraceTag((tagEdIME, "CIme_Lev2::IMENotify: wparam [%x]", wparam));

    return S_FALSE;    // Allow DefWindowProc processing
}


//+----------------------------------------------------------------------------
//  void CIme_Lev2::PostIMEChar()
//
//  @mfunc
//      Called after processing a single EVT_IME_CHAR in order to
//      update the position of the IME's composition window.
//
//
//-----------------------------------------------------------------------------

void
CIme_Lev2::PostIMEChar()
{
    TraceTag((tagEdIME, "CIme_Lev2::PostIMEChar:"));

    SetCompositionForm();                       // Move Composition window.
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev3::StartComposition()
//
//  @mfunc
//      Begin IME Level 3 composition string processing.
//
//  @comm
//      For rudimentary processing, remember the start and
//      length of the selection. Set the font in case the
//      candidate window actually uses this information.
//
//  @rdesc
//      This is a rudimentary solution for remembering were
//      the composition is in the text. There needs to be work
//      to replace this with a composition "range".
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev3::StartComposition()
{
    TraceTag((tagEdIME, "CIme_Lev3::StartComposition:"));

    _imeLevel = IME_LEVEL_3;

    DWORD dwConversion, dwSentence;

    HIMC hIMC = ImmGetContext();

    if ( hIMC )                                     // Set _fKorean flag.
    {                                               //  for block cursor.
        if ( ImmGetConversionStatus( hIMC, &dwConversion, &dwSentence ) )
        {
            // NOTE:- the following is set for all FE system during IME input,
            // so we also need to check keyboard codepage as well.

            if ( dwConversion & IME_CMODE_HANGEUL )
            {
                _fKorean = (_KOREAN_CP == KeyboardCodePage());
            }
        }

        ImmReleaseContext( hIMC );             // Done with IME context.
    }

    SetCompositionFont( &_fUnderLineMode );

    // 
    //  If there were selections, it should have been processed by
    //  CSelectioManager::StartCompositionGlue. There is no need
    //  to remove selection here. 
    //  [zhenbinx]
    //
    
    return S_OK;                                    // No DefWindowProc
}                                                   //  processing.

//+----------------------------------------------------------------------------
//
//  HRESULT CIme_Lev3::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle Level 3 EVT_IME_COMPOSITION messages.
//
//  @comm
//      Display all of the intermediary composition text as well as the final
//      reading.
//
//  @devnote
//      This is a rudimentary solution for replacing text in the backing store.
//      Work is left to do with the undo list, underlining, and hiliting with
//      colors and the selection.
//
//  @devnote
//      A GCS_RESULTSTR message can arrive and the IME will *still* be in
//      composition string mode. This occurs because the IME's internal
//      buffers overflowed and it needs to convert the beginning of the buffer
//      to clear out some room. When this happens we need to insert the
//      converted text as normal, but remain in composition processing mode.
//
//      Another reason, GCS_RESULTSTR can occur while in composition mode
//      for Korean because there is only 1 correct choice and no additional
//      user intervention is necessary, meaning that the converted string can
//      be sent as the result before composition mode is finished.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

IHTMLRenderStyle *CIme::HighlightTypeFromAttr( BYTE a )
{
    IHTMLRenderStyle *pIRenderStyle=NULL;
    CRenderStyle *pRenderStyle = NULL;
    VARIANT vtColorValue;
    IHTMLDocument4 *pDoc=NULL;
    HRESULT hr;

    pDoc = _pManager->GetEditor()->GetDoc4();
    IFC( pDoc->createRenderStyle(NULL, &pIRenderStyle) );
    hr = pIRenderStyle->QueryInterface(CLSID_HTMLRenderStyle, (void **)&pRenderStyle);
    if (hr == S_OK)
        pRenderStyle->_fSendNotification = FALSE;

    switch( a )
    {
        case 0: // ATTR_INPUT
        case 2: // ATTR_CONVERTED
        case 4: // ATTR_ERROR
            pIRenderStyle->put_defaultTextSelection(SysAllocString(_T("false")));
            pIRenderStyle->put_textUnderlineStyle(SysAllocString(_T("dotted")));
            pIRenderStyle->put_textDecoration(SysAllocString(_T("underline")));
            VariantInit(& vtColorValue );
            V_VT( & vtColorValue ) = VT_BSTR;
            V_BSTR( & vtColorValue ) = SysAllocString(_T("transparent"));
            pIRenderStyle->put_textBackgroundColor(vtColorValue);
            VariantClear( & vtColorValue );
            VariantInit(& vtColorValue );
            V_VT( & vtColorValue ) = VT_BSTR;
            V_BSTR( & vtColorValue ) = SysAllocString(_T("transparent"));
            pIRenderStyle->put_textColor(vtColorValue);
            VariantClear( & vtColorValue );
            break;

        case 1: // ATTR_TARGET_CONVERTED
        case 3: // ATTR_TARGET_NOTCONVERTED
        case 5: // Hangul IME mode
        default: // default
            // Nothing needs to be done, default takes care of everything
            break;

    }

Cleanup:
    ReleaseInterface(pDoc);

    return pIRenderStyle;
}

HRESULT
CIme_Lev3::CompositionString(
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    BOOL        fTerminateWhenDone = FALSE;
    HRESULT     hr = S_OK;
    IHTMLRenderStyle* pIHTMLRenderStyle=NULL;
    IHTMLDocument4* pDoc=NULL;
    IHTMLRenderStyle* pIRenderStyle = NULL; 
#if DBG==1
    static BOOL fNoRecurse = FALSE;

    Assert ( !fNoRecurse );
    fNoRecurse = TRUE;
#endif

    TraceTag((tagEdIME, "CIme_Lev3::CompositionString: CleanupComposition [%d] HaveResult [%d] HaveComposition [%d]", CleanupCompositionString(lparam), HaveResultString(lparam), HaveCompositionString(lparam) ));

    // Check if we have a result string
    if (  CleanupCompositionString(lparam) || HaveResultString(lparam)  )
    {
        SetCaretVisible(FALSE);

        // $TODO - We need to hide the current selection, and then show it
        // ShowSelection(FALSE);

        IFC( CheckInsertResultString( lparam ) );
        if( hr == S_FALSE )
        {
            fTerminateWhenDone = TRUE;
        }

        // ShowSelection(TRUE);
        SetCaretVisible(TRUE);

        // We had a result, we will now take notifications
        _fHoldNotify = FALSE;
    }

    // Do we have a composition?
    if ( HaveCompositionString(lparam) )
    {
        LONG        cchCompStr = 0;     // Length of the new composition string
        WCHAR       achCompStr[256];    // String
        BYTE        abAttrib[256];      // Attributes
        LONG        ichCursor;          // Position of the cursor
        LONG        cchAttrib = 0;      // Number of attributes
        BOOL        fShowCaret;         // Should we show the caret?
        // Get new intermediate composition string, attribs, and caret.
        cchCompStr = GetCompositionStringInfo( GCS_COMPSTR,
                                               achCompStr, ARRAY_SIZE(achCompStr),
                                               abAttrib, ARRAY_SIZE(abAttrib),
                                               &ichCursor, &cchAttrib );

        // When there is no old text or new text, just show the caret
        // This is the case when client used TerminateIMEComposition with
        // CPS_CANCEL option.

        if ( /*!cchOld &&*/ !cchCompStr )
        {
            SetCaretVisible(TRUE);
            ReplaceRange(NULL, 0, TRUE, 0);
        }
        else
        {
            // Determine whether we need to hide the caret
            //   1. Never show caret for korean
            //   2. Show the caret if we are at the end of composition string (ichCursor == cchAttrib)
            //   3. Show the caret if the cursor position is at an input position in the string
            fShowCaret = !_fKorean && 
                          (ichCursor == cchAttrib || ( ( ichCursor && abAttrib[ichCursor - 1] == ATTR_INPUT ) ||
                                                         abAttrib[ichCursor] == ATTR_INPUT ) );

            if (_fKorean)
            {
                ichCursor = 1;
            }
            
            // 
            // IGNORE_HR is not good here. However we have no better failure recovery
            // scheme, use this.   [zhenbinx]
            //
            //
            IGNORE_HR( ReplaceRange( achCompStr, cchCompStr, fShowCaret, ichCursor, FALSE) );
            
            if ( ichCursor > 0 )
            {
                ichCursor = min(cchCompStr, ichCursor);
            }

            if ( cchCompStr && cchCompStr <= cchAttrib && !_fKorean )     // no Korean style needed
            {
                // NB (cthrash)
                //
                // Each character in IME string has an attribute.  They can
                // be one of the following:
                //
                // 0 - ATTR_INPUT                   dotted underline
                // 1 - ATTR_TARGET_CONVERTED        inverted text, no underline
                // 2 - ATTR_CONVERTED               dotted underline
                // 3 - ATTR_TARGET_NOTCONVERTED     solid underline
                // 4 - ATTR_ERROR                   ???
                //
                // The right column is how the text is rendered in the standard
                // Japanese Windows Edit Widget.
                //

                BYTE abCur;
                int  ichMin = 0;
                int  ichMost;

                //
                // Add the segments
                //

                IFC( (ClearHighlightSegments()) )

                abCur = abAttrib[0];

                for (ichMost = 1; ichMost < cchCompStr; ichMost++)
                {
                    if (abAttrib[ichMost] == abCur)
                        continue;
                    pIRenderStyle = HighlightTypeFromAttr(abCur); 
                    AddHighlightSegment( ichMin, ichMost, pIRenderStyle );
                    ReleaseInterface( pIRenderStyle );
                    ichMin = ichMost;

                    abCur = abAttrib[ichMost];
                }

                if (ichMin != ichMost)
                {
                    pIRenderStyle = HighlightTypeFromAttr(abCur); 
                    AddHighlightSegment( ichMin, ichMost, pIRenderStyle );
                    ReleaseInterface( pIRenderStyle );
                }

                if (IsTagEnabled(tagEdIMEAttr))
                {
                    LONG        i;
                    static BYTE hex[17] = "0123456789ABCDEF";

                    for(i = 0; i < cchCompStr; i++)
                    {
                        abAttrib[i] = hex[abAttrib[i] & 15];
                    }

                    abAttrib[min(255L,i)] = '\0';
                    TraceTag((tagEdIMEAttr, "attrib %s", abAttrib));
                }
            }

            _TODO(ichCursor += _prgUncommitted->GetCpMin();)// Set cursor and scroll.

            if ( _fKorean && cchCompStr )
            {
                // Set the cursor (although invisible) to *after* the
                // character, so as to force a scroll. (cthrash)

                /* HIGHLIGHT_TYPE_ImeHangul */
                pDoc = _pManager->GetEditor()->GetDoc4();
                IFC( pDoc->createRenderStyle(NULL, &pIHTMLRenderStyle) );
                IFC( AddHighlightSegment( 0, cchCompStr, pIHTMLRenderStyle ) );
            }

            // make sure we have set the call manager text changed flag.  This
            // flag may be cleared when calling SetCharFormat
            //ts.GetPed()->GetCallMgr()->SetChangeEvent(CN_TEXTCHANGED);

            // setup composition window for Chinese in-caret IME
            if ( !_fKorean )
            {
                IMENotify( IMN_OPENCANDIDATE, 0x01 );
            }
        }

        // don't notify client for changes only when there is composition string available
        if ( cchCompStr && !_pManager->IsImeAlwaysNotify() )
        {
            _fHoldNotify = TRUE;
        }

    }

#if DBG==1 /*{*/
    fNoRecurse = FALSE;
#endif /*}*/

    if (fTerminateWhenDone)
    {
        TerminateIMEComposition( TERMINATE_FORCECANCEL, pEvent );
    }

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pIHTMLRenderStyle);

    RRETURN(hr);                                    // No DefWindowProc
}                                                   //  processing.

//+----------------------------------------------------------------------------
//
//  BOOL CIme_Lev3::SetCompositionStyle ( CCharFormat &CF, UINT attribute )
//
//  @mfunc
//      Set up a composition clause's character formmatting.
//
//  @comm
//      If we loaded Office's IMEShare.dll, then we ask it what the formatting
//      should be, otherwise we use our own, hardwired default formatting.
//
//  @devnote
//      Note the use of pointers to functions when dealing with IMEShare funcs.
//      This is because we dynamically load the IMEShare.dll.
//
//  @rdesc
//      BOOL - This is because CFU_INVERT is treated like a selection by
//          the renderer, and we need to know the the min invertMin and
//          the max invertMost to know if the rendered line should be treated
//          as if there are selections to be drawn.
//
//-----------------------------------------------------------------------------

BOOL
CIme_Lev3::SetCompositionStyle (
    CCharFormat &CF,
    UINT attribute )
{
    BOOL            fInvertStyleUsed = FALSE;
#if 0 /*{*/

    CF._fUnderline = FALSE;
    CF._bUnderlineType = 0;

#if IMESHARE /*{*/
    const IMESTYLE  *pIMEStyle;
    UINT            ulID;

    COLORREF        color;
#endif /*}*/

#if IMESHARE /*{*/
    // load ImeShare if it has not been done
    if ( !fLoadIMEShareProcs )
    {
        InitNLSProcTable( LOAD_IMESHARE );
        fLoadIMEShareProcs = TRUE;
    }

    if ( fHaveIMEShareProcs )
    {
        pIMEStyle = pPIMEStyleFromAttr( attribute );
        if ( NULL == pIMEStyle )
            goto defaultStyle;

        CF._fBold = FALSE;
        CF._fItalic = FALSE;

        if ( pFBoldIMEStyle ( pIMEStyle ) )
            CF._fBold = TRUE;

        if ( pFItalicIMEStyle ( pIMEStyle ) )
            CF._fItalic = TRUE;

        if ( pFUlIMEStyle ( pIMEStyle ) )
        {
            CF._fUnderline = TRUE;
            CF._bUnderlineType = CFU_UNDERLINE;

            ulID = pIdUlIMEStyle ( pIMEStyle );
            if ( UINTIMEBOGUS != ulID )
            {
                if ( IMESTY_UL_DOTTED == ulID )
                    CF._bUnderlineType = CFU_UNDERLINEDOTTED;
            }
        }

        color = pRGBFromIMEColorStyle( pPColorStyleTextFromIMEStyle ( pIMEStyle ));
        if ( UINTIMEBOGUS != color )
        {
            CF._ccvTextColor.SetValue( color, FALSE );
        }

        color = pRGBFromIMEColorStyle( pPColorStyleBackFromIMEStyle ( pIMEStyle ));
        if ( UINTIMEBOGUS != color )
        {
            //CF.dwEffects &= ~CFE_AUTOBACKCOLOR;
            CF._ccvrBackColor.SetValue( color, FALSE );

            fInvertStyleUsed = TRUE;
        }
    }
    else // default styles when no IMEShare.dll exist.
#endif //IMESHARE/*}*/
    {
#if IMESHARE /*{*/
defaultStyle:
#endif /*}*/
        switch ( attribute )
        {                                       // Apply underline style.
            case ATTR_INPUT:
            case ATTR_CONVERTED:
                CF._fUnderline = TRUE;
                CF._bUnderlineType = CFU_UNDERLINEDOTTED;
                break;
            case ATTR_TARGET_NOTCONVERTED:
                CF._fUnderline = TRUE;
                CF._bUnderlineType = CFU_UNDERLINE;
                break;
            case ATTR_TARGET_CONVERTED:         // Target *is* selection.
            {
                CF._ccvTextColor.SetSysColor(COLOR_HIGHLIGHTTEXT);

                fInvertStyleUsed = TRUE;
            }
            break;
        }
    }
#endif /*}*/
    return fInvertStyleUsed;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_Lev3::IMENotify( const WPARAM wparam, const LPARAM lparam )
//
//  @mfunc
//      Handle Level 3 EVT_IME_NOTIFY messages.
//
//  @comm
//      Currently we are only interested in knowing when to update
//      the n window's position.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Lev3::IMENotify(
    const WPARAM wparam,
    const LPARAM lparam )
{
    TraceTag((tagEdIME, "CIme_Lev3::IMENotify: wparam [%x]", wparam));

    if ( IMN_OPENCANDIDATE == wparam || IMN_CLOSECANDIDATE == wparam  )
    {
        Assert ( 0 != lparam );

        HIMC hIMC = ImmGetContext();                // Get host's IME context.

        if (hIMC)
        {
            CANDIDATEFORM   cdCandForm;
            INT             index;

            // Convert bitID to INDEX because of API.

            for (index = 0; index < 32; index++ )
            {
                if ( 0 != ((1 << index) & lparam) )
                    break;
            }
            Assert ( ((1 << index) & lparam) == lparam );    // Only 1 set?
            Assert ( index < 32 );

            if ( IMN_OPENCANDIDATE == wparam && !_fKorean )  // Set candidate to caret.
            {
                POINT ptCaret;
                RECT rc;
                long lLineHeight;
                HRESULT hr = THR(GetCompositionPos(&ptCaret, &rc, &lLineHeight));

                if (OK(hr))
                {
                    ptCaret.x = max(0L, ptCaret.x);
                    ptCaret.y = max(0L, ptCaret.y);

                    cdCandForm.dwStyle = CFS_CANDIDATEPOS;

                    if (KeyboardCodePage() == _JAPAN_CP)
                    {
                        // Change style to CFS_EXCLUDE, this is to
                        // prevent the candidate window from covering
                        // the current selection.

                        cdCandForm.dwStyle = CFS_EXCLUDE;
                        cdCandForm.rcArea.left = ptCaret.x;                 

                        // FUTURE: for verticle text, need to adjust
                        // the rcArea to include the character width.

                        cdCandForm.rcArea.right =
                            cdCandForm.rcArea.left + 2;
                        cdCandForm.rcArea.top = ptCaret.y - lLineHeight;
                        ptCaret.y += 4;
                        cdCandForm.rcArea.bottom = ptCaret.y;
                    }
                    else
                    {
                        ptCaret.y += 4;
                    }

                    // Most IMEs will have only 1, #0, candidate window. However, some IMEs
                    //  may want to have a window organized alphabetically, by stroke, and
                    //  by radical.

                    cdCandForm.dwIndex = index;                         
                    cdCandForm.ptCurrentPos = ptCaret;
                    ImmSetCandidateWindow(hIMC, &cdCandForm);
                }
            }
            else                                    // Reset back to CFS_DEFAULT.
            {
                if (   ImmGetCandidateWindow(hIMC, index, &cdCandForm)
                    && CFS_DEFAULT != cdCandForm.dwStyle )
                {
                    cdCandForm.dwStyle = CFS_DEFAULT;
                    ImmSetCandidateWindow(hIMC, &cdCandForm);
                }
            }

            ImmReleaseContext( hIMC );         // Done with IME context.
        }
    }

    return S_FALSE;                                 // Allow DefWindowProc
}                                                   //  processing.


//+----------------------------------------------------------------------------
//
//  HRESULT StartHangeulToHanja()
//
//  @func
//      Initiates an IME composition string edit to convert Korean Hanguel to Hanja.
//  @comm
//      Called from the message loop to handle VK_KANJI_KEY.
//
//  @devnote
//      We decide if we need to do a conversion by checking:
//      - the Fonot is a Korean font,
//      - the character is a valid SBC or DBC,
//      - ImmEscape accepts the character and bring up a candidate window
//
//  @rdesc
//      BOOL - FALSE for no conversion. TRUE if OK.
//
//-----------------------------------------------------------------------------

HRESULT
CSelectionManager::StartHangeulToHanja(
    IMarkupPointer * pPointer /*= NULL */,
    CEditEvent* pEvent )
{
    int                 iResult = 0;
    char                abHangeul[3] = {0, 0, 0};
    WCHAR               achHangeul[2] = { 0, 0 };
    HRESULT             hr;
    long                cch = 1;
    const BOOL          fIsOnNT = CSelectionManager::IsOnNT();
    DWORD               dwBreakCondition;
    IHTMLDocument4      *pDoc=NULL;
    IHTMLRenderStyle    *pIHTMLRenderStyle=NULL;

    CEditPointer pEditPosition( GetEditor(), NULL );

    //
    // get the current character
    //

    if (pPointer)
    {
        IFC( pEditPosition->MoveToPointer( pPointer ) );
    }
    else
    {
        SP_IHTMLCaret  spCaret;

        IFC( GetDisplayServices()->GetCaret( &spCaret ));
        IFC( spCaret->MoveMarkupPointerToCaret( pEditPosition ));
    }

    IFC( pEditPosition.Scan(    RIGHT, 
                               BREAK_CONDITION_EnterBlock | BREAK_CONDITION_Text, 
                                &dwBreakCondition, 
                                NULL, 
                                NULL,
                                &achHangeul[0],
                                SCAN_OPTION_None ) );

    if (   cch == 1
        && (   fIsOnNT
            || WideCharToMultiByte(_KOREAN_CP, 0, achHangeul, 1, abHangeul, 2, NULL, NULL) > 0
           )
       )
    {
        HIMC hIMC = ImmGetContext();

        if (hIMC)
        {
            HKL hKL = GetKeyboardLayout(0);

            iResult = fIsOnNT
                      ? ImmEscapeW(hKL, hIMC, IME_ESC_HANJA_MODE, achHangeul)
                      : ImmEscapeA(hKL, hIMC, IME_ESC_HANJA_MODE, abHangeul);

            ImmReleaseContext(hIMC);

            if (iResult)
            {
                if ( pEvent
                    && (   !_pActiveTracker
                        || _pActiveTracker->GetTrackerType() != TRACKER_TYPE_Caret))
                {
                    if (pPointer)
                    {
                        SP_IDisplayPointer spDispPointer;

                        //  
                        // We need not care about BOL here since this only serves as a
                        // re-routing point to reset Tracker to CaretTracker. Once the 
                        // even is re-rounted to this function, it will go through 
                        // the else CIme_HangeulToHanja part. And the caret is going
                        // to be moved one step forward (that is -- re-positioned) so
                        // BOL becomes irrelevant.      [zhenbinx]
                        //
                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        IFC( spDispPointer->MoveToMarkupPointer(pPointer, NULL) );

                        IFC( PositionCaret( spDispPointer, pEvent ));
                    }
                    else
                    {
                        // (cthrash) This is wrong, but we shouldn't get here.

                        AssertSz(0, "We're not supposed to be here.");

                        IFC( PositionCaret( pEvent ));
                    }
                }
                else
                {
                    _pIme = new CIme_HangeulToHanja( this, 0 );
                    
                    if ( _pIme && IsIMEComposition() )
                    {
                        SP_IDisplayPointer spDispPointer;
                        SP_IMarkupPointer   spPointer;

                        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                        
                        IFC( _pIme->Init() );

                        // 
                        // We need to 'select' the character.
                        //
                        IFC( _pIme->AdjustUncommittedRangeAroundInsertionPoint() );

                        // Move to the end of the character to select
                        IFC( spDispPointer->MoveToPointer(_pIme->_pDispInsertionPoint) );
                        IFC( GetEditor()->MoveCharacter(spDispPointer, RIGHT) );
                        IFC( spDispPointer->PositionMarkupPointer(_pIme->_pmpEndUncommitted) );

                        
                        // Select, and highlight, the Hangeul character
                        IFC( GetEditor()->CreateMarkupPointer( &spPointer ) );
                        IFC( _pIme->_pDispInsertionPoint->PositionMarkupPointer( spPointer ) );
                        IFC( _pIme->_pManager->Select(spPointer, pEditPosition, SELECTION_TYPE_Text ) );
                        /* HIGHLIGHT_TYPE_ImeHangul */
                        pDoc = GetEditor()->GetDoc4();
                        pDoc->createRenderStyle(NULL, &pIHTMLRenderStyle);
                        IFC( _pIme->AddHighlightSegment( 0, 1, pIHTMLRenderStyle) );

                        //
                        // The new KOREAN IMEs (2002) send IME_START_COMPOSITION
                        // after hanja mode is initiated. 
                        // 
                        _pIme->_fHanjaMode = TRUE;
                        IFC( _pIme->StartComposition() );
                        
                    }
                }
            }
        }
    }

Cleanup:
    ReleaseInterface(pDoc);
    ReleaseInterface(pIHTMLRenderStyle);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  CIme_Lev3::CIme_Lev3()
//
//  @mfunc
//      CIme_Lev3 Constructor.
//
//-----------------------------------------------------------------------------

CIme_Lev3::CIme_Lev3( CSelectionManager * pManager ) : CIme_Lev2( pManager )
{
    TraceTag((tagEdIME, "CIme_Lev3::CIme_Lev3"));
    
}

//+----------------------------------------------------------------------------
//  CIme_HangeulToHanja::CIme_HangeulToHanja()
//
//  @mfunc
//      CIme_HangeulToHanja Constructor.
//
//  @comm
//      Needed to save Hangeul character width for Block caret
//
//-----------------------------------------------------------------------------

CIme_HangeulToHanja::CIme_HangeulToHanja( CSelectionManager * pManager, LONG xWidth )
    : CIme_Lev3( pManager )
{
    // Set _fResultOccured to FALSE for the Korean HangeulToHanja conversion.
    // The conversion works by replacing the currently selected character.  If
    // we moved the insertion position, the selection would not be 'replaced'
    // when we got our final composition string.
    _fResultOccurred = FALSE;
    _xWidth = xWidth;
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_HangeulToHanja::StartComposition()
//
//  @mfunc
//      Begin CIme_HangeulToHanja composition string processing.
//
//  @comm
//      Call Level3::StartComposition.  Then setup the Korean block
//      caret for the Hanguel character.
//
//  @rdesc
//      Need to adjust _ichStart and _cchCompStr to make the Hanguel character
//      "become" a composition character.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_HangeulToHanja::StartComposition( )
{
    HRESULT hr = S_OK;

    hr = CIme_Lev3::StartComposition();

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  HRESULT CIme_HangeulToHanja::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle CIme_HangeulToHanja EVT_IME_COMPOSITION messages.
//
//  @comm
//      call CIme_Lev3::CompositionString to get rid of the selected Hanguel character,
//      then setup the format for the next Composition message.
//
//  @devnote
//      When the next Composition message comes in and that we are no longer in IME,
//      the new character will use the format as set here.
//
//
//
//-----------------------------------------------------------------------------

HRESULT
CIme_HangeulToHanja::CompositionString(
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    CIme_Lev3::CompositionString( lparam, pEvent );
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  HRESULT CIme_Protected::CompositionString( const LPARAM lparam )
//
//  @mfunc
//      Handle CIme_Protected EVT_IME_COMPOSITION messages.
//
//  @comm
//      Just throw away the restlt string since we are
//  in read-only or protected mode
//
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//      Side effect: _fDestroy is set to notify that composition string
//          processing is finished and this object should be deleted.
//
//-----------------------------------------------------------------------------

HRESULT
CIme_Protected::CompositionString (
    const LPARAM lparam,
    CEditEvent* pEvent )
{
    HRESULT hr;

    if ( CleanupCompositionString(lparam) || HaveResultString(lparam) )
    {
        INT   cch;
        WCHAR achCompStr[256];

        cch = GetCompositionStringInfo( GCS_RESULTSTR,
                                        achCompStr, ARRAY_SIZE(achCompStr),
                                        NULL, 0, NULL, NULL);

        // we should have one or 0 characters to throw away

        Assert ( cch <= 1 );

        hr = S_OK;                                  // Don't want EVT_IME_CHARs.
    }
    else
    {
        // terminate composition to force a end composition message

        TerminateIMEComposition( TERMINATE_NORMAL, pEvent );
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  HRESULT IgnoreIMEInput ( HWND hwnd, DWORD lParam  )
//
//  @func
//      Ignore IME character input
//  @comm
//      Called to handle EVT_KEYDOWN with VK_PROCESSKEY during
//      protected or read-only mode.
//
//  @devnote
//      This is to ignore the IME character.  By translating
//      message with result from ImmGetVirtualKey, we
//      will not receive START_COMPOSITION message.  However,
//      if the host has already called TranslateMessage, then,
//      we will let START_COMPOSITION message to come in and
//      let IME_PROTECTED class to do the work.
//
//  @rdesc
//      HRESULT-S_FALSE for DefWindowProc processing, S_OK if not.
//
//-----------------------------------------------------------------------------

HRESULT IgnoreIMEInput(
    HWND    hwnd,               // @parm parent window handle
    DWORD   dwFlags)            // @parm lparam of EVT_KEYDOWN msg
{
    HRESULT     hr = S_FALSE;
    MSG         msg;

    Assert ( hwnd );
    if (VK_PROCESSKEY != (msg.wParam  = ImmGetVirtualKey( hwnd )))
    {
        // if ImmGetVirtualKey is still returning VK_PROCESSKEY
        // That means the host has already called TranslateMessage.
        // In such case, we will let START_COMPOSITION message
        // to come in and let IME_PROTECTED class to do the work
        msg.hwnd = hwnd;
        msg.message = EVT_KEYDOWN;
        msg.lParam  = dwFlags;
        if (::TranslateMessage ( &msg ))
            hr = S_OK;
    }

    return hr;
}

HRESULT
CIme::GetCaretTracker( CCaretTracker **ppCaretTracker )
{
    HRESULT hr;

    if (   _pManager->_pActiveTracker
        && _pManager->_pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret)
    {
        *ppCaretTracker = DYNCAST(CCaretTracker, _pManager->_pActiveTracker);
        (*ppCaretTracker)->AddRef();
        
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    RRETURN1(hr,S_FALSE);
}

//+----------------------------------------------------------------------------
//  Method:     OpenUndoUnit()
//
//  Purpose:    This method opens another parent undo unit for the IME.  The
//              undo unit will remain open until CloseUndoUnit is called.
//
//  Returns:    HRESULT indicating success
//-----------------------------------------------------------------------------
HRESULT
CIme::OpenUndoUnit(void)
{
    HRESULT hr = S_OK;

    SP_IOleUndoManager spUndoMgr;
    Assert( !_pBatchPUU );
    
     // Create our undo unit.  The batch undo unit is used to group all of the 
    // intermediate composition steps into one parent unit, that can be undone
    // at the same time.  This also allows for canceling the undo unit, in the
    // case that the user cancels the composition string.
     _pBatchPUU = new CBatchParentUndoUnit(_pManager->GetEditor(), IDS_EDUNDOTYPING);

    if( !_pBatchPUU )
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagEdIME, "OpenUndoUnit %p", _pBatchPUU));
    IFC( _pManager->GetEditor()->GetUndoManager(&spUndoMgr));
    IFC(  spUndoMgr->Open(_pBatchPUU) );

Cleanup:
    RRETURN(hr);
}



//+----------------------------------------------------------------------------
//  Method:     CloseUndoUnit()
//
//  Purpose:    This method closes the IME undo unit, using the parameter to
//              determine whether or not to throw away the undo unit.
//
//  Arguments:  fSave = INPUT - Should we save the undo unit?
//
//  Returns:    HRESULT indicating success
//-----------------------------------------------------------------------------
HRESULT
CIme::CloseUndoUnit(BOOL fSave)
{
    HRESULT hr = S_OK;
    SP_IOleUndoManager spUndoMgr;
    Assert( _pBatchPUU );
    TraceTag((tagEdIME, "CloseUndoUnit %p with %s", _pBatchPUU, fSave?"Save":"Discard"));

    IFC( _pManager->GetEditor()->GetUndoManager(&spUndoMgr));
    IFC( spUndoMgr->Close(_pBatchPUU, fSave) );
    ClearInterface(&_pBatchPUU);

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionManager::TerminateIMEComposition(
    DWORD dwMode,
    CEditEvent* pEvent )
{
    HRESULT hr = S_OK;
    

    if (IsIMEComposition())
    {
        IFC( EnsureEditContext());
    
        _pIme->TerminateIMEComposition( dwMode, pEvent );

        if ( ! pEvent )
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }            
    }
Cleanup:

    RRETURN1(hr,S_FALSE);
}

DWORD CSelectionManager::s_dwPlatformId = DWORD(-1);

void
CSelectionManager::CheckVersion()
{
#ifndef WINCE
    OSVERSIONINFOA ovi;
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    Verify(GetVersionExA(&ovi));
#else //WINCE
    OSVERSIONINFO ovi;
    ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    Verify(GetVersionEx(&ovi));
#endif //WINCE

    s_dwPlatformId = ovi.dwPlatformId;
}



HRESULT
CIme::Init()
{
    HRESULT             hr;
    IHTMLDocument2      *pIDocument = _pManager->GetDoc();
    IMarkupServices     *pMarkupServices = NULL;
    IHTMLCaret          *pCaret = NULL;

    extern CODEPAGE     GetKeyboardCodePage();

    // Set the result occured  to true.  This flag is used to determine when the
    // insertion position (for the IME) needs to be moved back to the caret.  When
    // fResultOccurred is TRUE, the insertion position is repositioned.
    _fResultOccurred = TRUE;
    _fInsertInProgress = FALSE;

    if( _pManager->GetActiveTracker() && 
        _pManager->GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Caret )
    {
        CCaretTracker *pCaretTracker = DYNCAST( CCaretTracker, _pManager->GetActiveTracker() );
        Assert(pCaretTracker);

        IFC( pCaretTracker->TerminateTypingBatch() );
    }            

    // Open our initial undo unit
    IFC( OpenUndoUnit() );
    
    // Retrieve our required interfaces
    IFC( pIDocument->QueryInterface(IID_IMarkupServices, (void**)&pMarkupServices) );

    // The InsertionPoint is the point in the current markup where the
    // IME composition will be placed.  Whenever a result string is
    // retrieved, we update this insertion point
    IFC( GetDisplayServices()->CreateDisplayPointer( &_pDispInsertionPoint  ) );
    WHEN_DBG( _pManager->SetDebugName( _pDispInsertionPoint, strImeIP ) );

    // Uncommitted start is the beginning of the uncommitted composition
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &_pmpStartUncommitted ) );
    WHEN_DBG( _pManager->SetDebugName( _pmpStartUncommitted, strImeUncommittedStart ) );

    // Uncommitted end is the end of the uncommitted composition
    IFC( _pManager->GetEditor()->CreateMarkupPointer( &_pmpEndUncommitted ) );
    WHEN_DBG( _pManager->SetDebugName( _pmpEndUncommitted, strImeUncommittedEnd ) );

    // Position our insertion pointer at the caret.
    IFC( GetDisplayServices()->GetCaret( &pCaret ) );
    IFC( pCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );
    IFC( _pDispInsertionPoint->SetPointerGravity( POINTER_GRAVITY_Left ) );
   
Cleanup:

    ReleaseInterface( pCaret );
    ReleaseInterface( pMarkupServices ) ;

    RRETURN(hr);
}

HRESULT
CIme::Deinit()
{
    HRESULT hr = S_OK;
    
    IFC( ClearHighlightSegments() );

    // Terminate the undo unit.  We want to throw away any unfinished compositions
    IFC( CloseUndoUnit(FALSE) );
    
    ClearInterface( &_pDispInsertionPoint );
    ClearInterface( &_pmpStartUncommitted );
    ClearInterface( &_pmpEndUncommitted );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionManager::HandleImeEvent(
    CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG_PTR lParam;
    LONG_PTR wParam;

    switch (pEvent->GetType() )
    {
        case EVT_IME_STARTCOMPOSITION:   // IME input is being kicked off
            hr = THR(StartCompositionGlue( FALSE, pEvent));
            break;

        case EVT_IME_COMPOSITION:        // State of user's input has changed   
            IFC( DYNCAST(CHTMLEditEvent,pEvent)->GetCompositionChange( & lParam ));
            hr = THR(CompositionStringGlue( (LPARAM) lParam, pEvent ));
            break;

        case EVT_IME_ENDCOMPOSITION:     // User has OK'd IME conversions
            hr = THR(EndCompositionGlue(pEvent ));
            break;

        case EVT_IME_NOTIFY:             // Candidate window state change info, etc.
            IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetNotifyCommand( & wParam));
            IFC( DYNCAST(CHTMLEditEvent, pEvent)->GetNotifyData( & lParam ));
            hr = THR(NotifyGlue( (WPARAM) wParam, (LPARAM) lParam ));
            break;

        case EVT_IME_COMPOSITIONFULL:    // Level 2 comp string about to overflow.
            hr = THR(CompositionFullGlue());
            break;

        case EVT_IME_CHAR:               // 2 byte character, usually FE.
            if (IsIMEComposition())
            {
                hr = _pIme->IgnoreIMECharMsg() ? S_OK : S_FALSE;
            }
            else
            {
                hr = _fIgnoreImeCharMsg ? S_OK : S_FALSE;
            }
            break;

        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
            //
            // Sometimes (with old Korean IMEs), the IME will not send
            // a WM_IME_ENDCOMPOSITION message with a lbutton down.. so if
            // we intercept one of these, and we have an active IME
            // composition, then we definitely need to terminate the IME
            // composition
            //
            // Todo: -we do not support IME mouse operation at present
            //          time. Looking for it in next version [zhenbinx]
            //
            IGNORE_HR( TerminateIMEComposition(TERMINATE_NORMAL) );
            break;

        case EVT_KEYPRESS:
            //
            // Some IME such as Simplified Chinese QuanPin allow WM_CHAR
            // to be sent while in IME composition mode. This will cause
            // our undo mechanism to fail since IME Undo is based strickly
            // on the order of StartComposition-Composition-EndComposition.
            // So we need to terminate IME composition if we get a char
            //
            IGNORE_HR( TerminateIMEComposition(TERMINATE_NORMAL) );
            break;
            
        case EVT_KEYDOWN:
            if (IsIMEComposition())
            {
                //
                // During IME composition, there are some key
                // events we should not handle. Also, there are
                // other key events we need to handle by 
                // terminating the IME composition first. 
                //
                //
                LONG keyCode ;
                IGNORE_HR( pEvent->GetKeyCode(&keyCode ) );    
                switch (keyCode)
                {
                    case VK_BACK:
                    case VK_INSERT:
                    case VK_HOME:
                    case VK_END:
                    case VK_PRIOR:
                    case VK_NEXT:
                    case VK_DELETE:
                    case VK_RETURN:
                        //
                        // Instead of tear off IME composition
                        // we disable these keystrokes in IME
                        // composition mode
                        //
                        hr = S_OK;
                        break;
                        
                    case VK_UP:
                    case VK_DOWN:
                    case VK_LEFT:
                    case VK_RIGHT:
                    default:
                        break;
                }
            }
            break;
            
        default:
            break;

    }
Cleanup:

    RRETURN1(hr,S_FALSE);
}

HRESULT
CIme::SetCaretVisible( IHTMLDocument2* pIDoc, BOOL fVisible )
{
    HRESULT hr = S_OK ;
    SP_IHTMLCaret spc;

    IFC( GetDisplayServices()->GetCaret( &spc ));

    if( fVisible )
        hr = spc->Show( FALSE );
    else
        hr = spc->Hide();

Cleanup:
    RRETURN( hr );
}

HRESULT
CIme::ReplaceRange(
    TCHAR * pch,
    LONG cch,
    BOOL fShowCaret /* = TRUE */,
    LONG ichCaret   /* = -1 */,
    BOOL fMoveIP    /* = FALSE */,
    BOOL fOverwrite /* = FALSE */ )
{
    IMarkupServices * pTreeServices = NULL;
    IHTMLCaret * pCaret = NULL;
    BOOL fPositioned;
    HRESULT hr = S_FALSE;
    CEdUndoHelper undoUnit(_pManager->GetEditor());
    CCaretTracker * pCaretTracker = NULL;
    
    if (!OK(GetCaretTracker( &pCaretTracker ) ))
        goto Cleanup;

    if (! pCaretTracker)
        goto Cleanup;

    IFC( ClearHighlightSegments() );
    
    hr = THR( _pManager->GetDoc()->QueryInterface( IID_IMarkupServices, (void**) & pTreeServices));
    if (hr)
        goto Cleanup;


    // Reposition the insertion pointers, if necessary
    if( HasResultOccurred() )
    {
        IFC( UpdateInsertionPoint() );
    }

    // We have had one more replacement
    _fResultOccurred = FALSE;

    //
    // First nuke the old range, if we have one.
    //

    hr = THR( _pmpStartUncommitted->IsPositioned( &fPositioned ) );
    if (hr)
        goto Cleanup;

    //
    // 
    //
    if (fPositioned || cch)
    {
        IFC( undoUnit.Begin(IDS_EDUNDOTYPING) );
    }

    if (fPositioned)
    {
        //
        // Memorize the formatting just before we nuke the old range.
        //

        CSpringLoader * psl = GetSpringLoader();
        if (psl)
        {
            IGNORE_HR(psl->SpringLoad(_pmpStartUncommitted));
        }

        //
        // Now remove.
        //

        hr = THR( pTreeServices->Remove( _pmpStartUncommitted, _pmpEndUncommitted ) );
        if (hr)
            goto Cleanup;
    }

    //
    // Now add the new text
    //

    hr = THR( GetDisplayServices()->GetCaret( &pCaret ));
    if (hr)
        goto Cleanup;

    if (cch)
    {
        // This places the caret *before* the IP

        IFC( pCaret->MoveCaretToPointer( _pDispInsertionPoint, TRUE /* fScrollIntoView */, CARET_DIRECTION_INDETERMINATE));

        IFC( AdjustUncommittedRangeAroundInsertionPoint() );
        
        // In goes the text.  Call through CCaretTracker
        _fInsertInProgress = TRUE;
        IFC( pCaretTracker->InsertText( pch, cch, pCaret, fOverwrite ) );
        _fInsertInProgress = FALSE;

        IFC( ClingUncommittedRangeToText() );

        if (fMoveIP)
        {
            IFC( pCaret->MoveDisplayPointerToCaret( _pDispInsertionPoint ) );

            IFC( AdjustUncommittedRangeAroundInsertionPoint() );

            pCaretTracker->SetCaretShouldBeVisible( TRUE );
        }
        else if (ichCaret != -1)
        {
            AssertSz( ichCaret >= 0 && ichCaret <= cch,
                      "IME caret should be within the text.");
            
            if (ichCaret < cch)
            {
                CEditPointer epForCaret( _pManager->GetEditor()); 
                DWORD dwSearch = BREAK_CONDITION_Text;
                DWORD dwFound;
                SP_IDisplayPointer spDispForCaret;

                IFC( _pDispInsertionPoint->PositionMarkupPointer(epForCaret) );

                while (ichCaret--)
                {
                    hr = THR( epForCaret.Scan(RIGHT, dwSearch, &dwFound) );
                    if (hr)
                        goto Cleanup;

                    if (!epForCaret.CheckFlag(dwFound, dwSearch))
                        break;
                }

                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispForCaret) );
                IFC( spDispForCaret->MoveToMarkupPointer(epForCaret, _pDispInsertionPoint) );

                IFC( pCaret->MoveCaretToPointer( spDispForCaret, TRUE, CARET_DIRECTION_INDETERMINATE ));

                // Todo: (cthrash) Ideally, we want to ensure the whole of the
                // currently converted range to show.  This would require some
                // trickly logic to keep the display from shifting annoyingly.
                // So for now, we only ensure the beginning of it is showing.
                
                IFC( spDispForCaret->ScrollIntoView() );
            }
            else
            {
                SP_IDisplayPointer spDispEndUncommitted;
                
                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEndUncommitted) );
                IFC( spDispEndUncommitted->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
                IFC( spDispEndUncommitted->MoveToMarkupPointer(_pmpEndUncommitted, NULL) );
                IFC( spDispEndUncommitted->ScrollIntoView() );
            }

            pCaretTracker->SetCaretShouldBeVisible( fShowCaret );
        }
    }
    else
    {
        SP_IDisplayPointer spDispCaret;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispCaret) );
        IFC( pCaret->MoveDisplayPointerToCaret(spDispCaret) );
        IFC( spDispCaret->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        IFC( pCaret->MoveCaretToPointer(spDispCaret, FALSE, CARET_DIRECTION_INDETERMINATE) );
    }

Cleanup:

    if (pCaretTracker)
        pCaretTracker->Release();

    ReleaseInterface( pCaret );
    ReleaseInterface( pTreeServices );

    RRETURN1(hr, S_FALSE);
}

HRESULT
CIme::AdjustUncommittedRangeAroundInsertionPoint()
{
    HRESULT hr;
    
    // This places the pointer *before* the IP

    IFC( _pDispInsertionPoint->PositionMarkupPointer(_pmpStartUncommitted) );

    IFC( _pmpStartUncommitted->SetGravity( POINTER_GRAVITY_Left) );

    // This places the pointer *after* the IP (and therefore *after* the caret.)

    IFC( _pDispInsertionPoint->PositionMarkupPointer(_pmpEndUncommitted) );

    IFC( _pmpEndUncommitted->SetGravity( POINTER_GRAVITY_Right) );

Cleanup:

    RRETURN(hr);
}

HRESULT
CIme::ClingUncommittedRangeToText()
{
    HRESULT         hr;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD           dwFound;
    CEditPointer epTest( _pManager->GetEditor() ); 
    

    // Cling to text on the left
    
    IFR( epTest->MoveToPointer(_pmpStartUncommitted) );
    IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) )
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
    {
        IFR( epTest.Scan(LEFT, dwSearch, &dwFound) ); // restore position
        IFR( _pmpStartUncommitted->MoveToPointer(epTest) );
    }

    // Cling to text on the right
    IFR( epTest->MoveToPointer(_pmpEndUncommitted) );
    IFR( epTest.Scan(LEFT, dwSearch, &dwFound) );
    if (epTest.CheckFlag(dwFound, BREAK_CONDITION_TEXT))
    {
        IFR( epTest.Scan(RIGHT, dwSearch, &dwFound) ); // restore position
        IFR( _pmpEndUncommitted->MoveToPointer(epTest) );
    }

    return S_OK;    
}


#endif /*}*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\inscmd.cxx ===
//+------------------------------------------------------------------------
//
//  File:       InsCmd.cxx
//
//  Contents:   CInsertCommand, CInsertObjectCommand Class implementation
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_OLEDLG_H_
#define X_OLEDLG_H_
#include <oledlg.h>
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

extern HRESULT HtmlStringToSignaturedHGlobal (HGLOBAL * phglobal, const TCHAR * pStr, long cch);

using namespace EdUtil;

MtDefine(CInsertCommand, EditCommand, "CInsertCommand")
MtDefine(CInsertObjectCommand, EditCommand, "CInsertObjectCommand")
MtDefine(CInsertParagraphCommand, EditCommand, "CInsertParagraphCommand")

//
// Forward references
//

HRESULT LoadProcedure(DYNPROC *pdynproc);

void DeinitDynamicLibraries();

int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);


//+---------------------------------------------------------------------------
//
//  CInsertCommand Constructor
//
//----------------------------------------------------------------------------

CInsertCommand::CInsertCommand(DWORD cmdId,
                               ELEMENT_TAG_ID etagId,
                               LPTSTR pstrAttribName,
                               LPTSTR pstrAttribValue,  
                                                           CHTMLEditor * pEd )
: CCommand( cmdId, pEd )
{
    _tagId = etagId;

    _bstrAttribName  = pstrAttribName  ? SysAllocString( pstrAttribName  ) : NULL;
    _bstrAttribValue = pstrAttribValue ? SysAllocString( pstrAttribValue ) : NULL;
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand Destructor
//
//----------------------------------------------------------------------------

CInsertCommand::~CInsertCommand()
{
    if (_bstrAttribName)
        SysFreeString( _bstrAttribName );
    
    if (_bstrAttribValue)
        SysFreeString( _bstrAttribValue );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::SetAttributeValue
//
//----------------------------------------------------------------------------

void
CInsertCommand::SetAttributeValue(LPTSTR pstrAttribValue)
{
    Assert(pstrAttribValue);

    if (_bstrAttribValue)
        SysFreeString( _bstrAttribValue );
    
    _bstrAttribValue = SysAllocString( pstrAttribValue );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    CSpringLoader           *psl = GetSpringLoader();
    OLECMD                  cmd;
    CEdUndoHelper           undoUnit(GetEditor());

    IFC( PrivateQueryStatus(&cmd, NULL) );
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;
      
    IFC( GetEditor()->CreateMarkupPointer( &spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ) );

    IFC( undoUnit.Begin(IDS_EDUNDONEWCTRL) );

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->CreateIterator( &spIter ));

    while( spIter->IsDone() == S_FALSE )
    {
        BOOL fResult;
        BOOL  fRepositionSpringLoader = FALSE;

        // Get the position of the curren segment
        IFC( spIter->Current(&spSegment) );        
        IFC( spSegment->GetPointers( spStart, spEnd ) );

        if (_tagId == TAGID_HR && psl)
            fRepositionSpringLoader = psl->IsSpringLoadedAt(spStart);

        if ( pvarargIn )
        {
            CVariant var;
            
            IFC( VariantChangeTypeSpecial( & var, pvarargIn, VT_BSTR ) );
            
            IFC( ApplyCommandToSegment( spStart, spEnd, V_BSTR( & var ) ) );
        }
        else
        {
            IFC( ApplyCommandToSegment( spStart, spEnd, NULL ) );
        }

        //
        // Collapse the pointers after the insertion point
        //

        IFC( spStart->IsRightOf( spEnd, & fResult ) );

        if ( fResult )
        {
            IFC( spEnd->MoveToPointer( spStart ) );
        }
        else
        {
            IFC( spStart->MoveToPointer( spEnd ) );
        }

        // Reposition springloader after insertion (63304).
        if (fRepositionSpringLoader)
            psl->Reposition(spEnd);

       IFC( spIter->Advance() );
    }            

Cleanup:
    RRETURN ( hr );
}


//+---------------------------------------------------------------------------
//
//  CInsertCommand::QueryStatus
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )
{
    HRESULT             hr;
    
    IFC( CommonQueryStatus(pCmd, pcmdtext) );
    if (hr != S_FALSE) 
        goto Cleanup;

    // Make sure the edit context is valid
    if (!(GetCommandTarget()->IsRange()) && GetEditor())
    {
        CSelectionManager *pSelMan;
        
        pSelMan = GetEditor()->GetSelectionManager();
        if (pSelMan && pSelMan->IsEditContextSet() && pSelMan->GetEditableElement())
        {
            ELEMENT_TAG_ID  tagId;

            IFR( GetMarkupServices()->GetElementTagId(pSelMan->GetEditableElement(), &tagId) );

            //From download\htmdesc.cxx:
            //button, input, textarea, a, select are prohinited inside a button. Admittedly, the list is kind of arbitrary.
            if (tagId == TAGID_BUTTON)
            {
                switch (_tagId)
                {
                case TAGID_BUTTON:
                case TAGID_INPUT:
                case TAGID_TEXTAREA:
                case TAGID_SELECT:
                    pCmd->cmdf = MSOCMDSTATE_DISABLED;                
                    hr = S_OK;
                    goto Cleanup;
                }
            }
        }
    }


    pCmd->cmdf = MSOCMDSTATE_UP;
    hr = S_OK;
    
Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   MapObjectToIntrinsicControl
//
//  Synopsis:   Find a match for pClsId within s_aryIntrinsicsClsid[]
//              If a match is found the IDM command corresponding to 
//              the matched intrinsic control is returned in pdwCmdId
//              otherwise 0 is returned.
//
//-------------------------------------------------------------------------

void
CInsertObjectCommand::MapObjectToIntrinsicControl (CLSID * pClsId, DWORD * pdwCmdId)
{
    int i;

    *pdwCmdId = 0;

    for (i = 0; i < ARRAY_SIZE(s_aryIntrinsicsClsid); i++)
    {
        if ( pClsId->Data1 != s_aryIntrinsicsClsid[i].pClsId->Data1 )
            continue;

        if( IsEqualCLSID( *pClsId, *s_aryIntrinsicsClsid[i].pClsId ) )
        {
            // Match is made, congratulations!
            *pdwCmdId = s_aryIntrinsicsClsid[i].CmdId;
            break;
        }
    }
}

//+------------------------------------------------------------------------
//
//  Function:   SetAttributeFromClsid
//
//  Synopsis:   Sets the attribute value for <OBJECT CLASSID=...> using the 
//              class id.
//
//-------------------------------------------------------------------------
HRESULT
CInsertObjectCommand::SetAttributeFromClsid (CLSID * pClsid )
{   
    HRESULT     hr = S_OK;
    TCHAR       pstrClsid[40];
    int         cch;
    TCHAR       pstrParam[ 128 ];

    //
    // Get the string value of pClsid
    //
    cch = StringFromGUID2( *pClsid, pstrClsid, ARRAY_SIZE(pstrClsid) );
    if (!cch)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    //
    // Construct the correct syntax for CLASSID attribute value
    //
    hr = StringCchPrintf(pstrParam, ARRAY_SIZE(pstrParam), _T("clsid%s"), pstrClsid);
    if (hr != S_OK)
        goto Cleanup;

    if ( (_T('{') != pstrParam[5+0]) || (_T('}') != pstrParam[5+37]) )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }   
    pstrParam[5+0 ] = _T(':');
    pstrParam[5+37] = 0;

    //
    // Set _varAttribValue 
    //

    SetAttributeValue( pstrParam );

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
// Function:    OleUIMetafilePictIconFree
//
// Synopsis:    Deletes the metafile contained in a METAFILEPICT structure and
//              frees the memory for the structure itself.
//
//
//--------------------------------------------------------------------

void
CInsertObjectCommand::OleUIMetafilePictIconFree( HGLOBAL hMetaPict )
{
    LPMETAFILEPICT      pMF;

    if (NULL==hMetaPict)
        return;

    pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict);

    if (NULL!=pMF)
    {
        if (NULL!=pMF->hMF)
            DeleteMetaFile(pMF->hMF);
    }

    GlobalUnlock(hMetaPict);
    GlobalFree(hMetaPict);
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleInsertObjectDialog
//
//  Synopsis:   Executes UI for Insert Object
//
//  Arguments   [in]  hwnd          hwnd passed from Trident
//              [out] dwResult      result of user action specified in UI
//              [out] pstrResult    classid, file name, etc., depending
//                                  on dwResult flags
//
//  Returns:    S_OK                OK hit in UI, pstrResult set
//              S_FALSE             CANCEL hit in UI, NULL == *pstrResult
//              other               failure
//
//-----------------------------------------------------------------------------

DYNLIB g_dynlibOLEDLG = { NULL, NULL, "OLEDLG.DLL" };

DYNPROC g_dynprocOleUIInsertObjectA =
         { NULL, &g_dynlibOLEDLG, "OleUIInsertObjectA" };

HRESULT
CInsertObjectCommand::HandleInsertObjectDialog (HWND hwnd, DWORD * pdwResult, DWORD * pdwIntrinsicCmdId)
{
    HRESULT                 hr = S_OK;
    OLEUIINSERTOBJECTA      ouio;
    CHAR                    szFile[MAX_PATH] = "";
    UINT                    uRC;

    *pdwIntrinsicCmdId = 0;
    *pdwResult = 0;

    //
    // Initialize ouio
    //
    memset(&ouio, 0, sizeof(ouio));
    ouio.cbStruct = sizeof(ouio);
    ouio.dwFlags =
            IOF_DISABLELINK |    
            IOF_SELECTCREATENEW |
            IOF_DISABLEDISPLAYASICON |
            IOF_HIDECHANGEICON |
            IOF_VERIFYSERVERSEXIST |
            IOF_SHOWINSERTCONTROL;
    ouio.hWndOwner = hwnd;
    ouio.lpszFile = szFile;
    ouio.cchFile = ARRAY_SIZE(szFile);

    //
    // Bring up the OLE Insert Object Dialog
    //
    hr = THR(LoadProcedure(&g_dynprocOleUIInsertObjectA));
    if (!OK(hr))
        goto Cleanup;

    uRC = (*(UINT (STDAPICALLTYPE *)(LPOLEUIINSERTOBJECTA))
            g_dynprocOleUIInsertObjectA.pfn)(&ouio);

    hr = (OLEUI_OK     == uRC) ? S_OK :
         (OLEUI_CANCEL == uRC) ? S_FALSE :
                                 E_FAIL;
    if (S_OK != hr)
        goto Cleanup;

    //
    // Process what the user wanted
    //
    Assert((ouio.dwFlags & IOF_SELECTCREATENEW) ||
           (ouio.dwFlags & IOF_SELECTCREATEFROMFILE) ||
           (ouio.dwFlags & IOF_SELECTCREATECONTROL));

    *pdwResult = ouio.dwFlags;

    if ( *pdwResult & IOF_SELECTCREATENEW )
    {
        //
        // For create new object, set the CLASSID=... attribute
        //
        SetAttributeFromClsid ( & ouio.clsid );
    }
    else if ( *pdwResult & IOF_SELECTCREATECONTROL )
    {
        //
        // For create control, first check to see whether the selected
        // control maps to an HTML intrinsic control
        // If there is a match PrivateExec will fire the appropriate IDM
        // insert command based on pdwInstrinsicCmdId, otherwise an 
        // <OBJECT> tag will be inserted.
        //
        MapObjectToIntrinsicControl( & ouio.clsid, pdwIntrinsicCmdId );
        if (! *pdwIntrinsicCmdId )
        {
            SetAttributeFromClsid ( & ouio.clsid );
        }
    }
    // TODO: IOF_SELECTCREATEFROMFILE is not supported

Cleanup:
    if (ouio.hMetaPict)
        OleUIMetafilePictIconFree(ouio.hMetaPict);

    DeinitDynamicLibraries();

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  CInsertObjectCommand Exec
//
//----------------------------------------------------------------------------

HRESULT 
CInsertObjectCommand::PrivateExec( DWORD nCmdexecopt,
                                   VARIANTARG * pvarargIn,
                                   VARIANTARG * pvarargOut )
{
    HRESULT     hr;
    HWND        hwndParent;
    DWORD       dwResult;
    DWORD       dwIntrinsicCmdId;
    CCommand *  theCommand = NULL;
    IMarkupPointer* pStart = NULL;
    IMarkupPointer* pEnd = NULL;
    ISegmentList* pSegmentList = NULL;
    SP_IOleWindow spOleWindow;
    
    Assert( nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER );

    IFC( GetSegmentList( &pSegmentList ));
    IFR( GetFirstSegmentPointers(pSegmentList, &pStart, &pEnd) );
    IFC( pStart->SetGravity( POINTER_GRAVITY_Left ));
    IFC( pEnd->SetGravity( POINTER_GRAVITY_Right ));
    
    //
    // Get the parent handle
    //
    IFC(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
    IFC(spOleWindow->GetWindow(&hwndParent));

    //
    // Bring up the dialog and handle user selections
    //
    hr = THR( HandleInsertObjectDialog( hwndParent, &dwResult, & dwIntrinsicCmdId ) );
    if (hr != S_OK)
    {
        // hr can be S_FALSE, indicating cancelled dialog
        hr = S_OK;
        goto Cleanup;
    }

    //
    // Either insert a new <OBJECT> tag or instantiate an intrinsic
    // control based on the results from HandleInsertObjectDialog()
    // s_aryIntrinsicsClsid[] table is used to map Forms3 controls
    // to their corresponding HTML tags, denoted by the CmdId field. 
    // This table enables us to handle the scenario where user picks
    // a Forms3 control using the Insert Object Dialog. In this case
    // rather than inserting an <OBJECT> with the specified class id,
    // we instantiate the corresponding HTML tag.
    //

    if (dwResult & (IOF_SELECTCREATENEW | IOF_SELECTCREATECONTROL) )
    {
        if (! dwIntrinsicCmdId)
        {
            // 
            // Delegate to super class to insert an <OBJECT> tag
            //
            hr = CInsertCommand::PrivateExec( nCmdexecopt, pvarargIn, pvarargOut );
        }
        else   
        {
            //
            // Delegate to the insertcommand denoted by dwIntrinsicCmdId
            // to insert an intrinsic control
            //
            theCommand = GetEditor()->GetCommandTable()->Get( dwIntrinsicCmdId );

            if ( theCommand )
            {
                hr = theCommand->Exec( nCmdexecopt, pvarargIn, pvarargOut, GetCommandTarget() );
            }
            else
            {
                hr = OLECMDERR_E_NOTSUPPORTED;
            }

        }
    }
    else if (dwResult & IOF_SELECTCREATEFROMFILE)
    {
        // TODO (alexz): when async download from file for <OBJECT> tag is implemented,
        // this can be done such that html like <OBJECT SRC = "[pstrResult]"> </OBJECT>
        // is used to create the object.
        // Currently the feature left disabled.
        hr = OLECMDERR_E_NOTSUPPORTED;
        goto Cleanup;
    }

    if ( FAILED(hr) )
        goto Cleanup;

    //
    // Site Select the inserted object
    //
    if ( hr == S_OK )
    {
        GetEditor()->SelectRangeInternal( pStart, pEnd, SELECTION_TYPE_Control, TRUE );
    }
    
Cleanup:
    ReleaseInterface( pSegmentList );
    ReleaseInterface( pStart );
    ReleaseInterface( pEnd );
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
//  CInsertCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertCommand::ApplyCommandToSegment( IMarkupPointer * pStart,
                                       IMarkupPointer * pEnd,
                                       TCHAR *          pchVar,
                                       BOOL             fRemove /* = TRUE */ )
{
    HRESULT             hr = S_OK;
    CStr                strAttributes;
    IMarkupServices     *pMarkupServices = GetMarkupServices();
    IHTMLElement        *pIHTMLElement = NULL;
    CEditPointer        edStart( GetEditor(), pStart );
    CEditPointer        edEnd( GetEditor(), pEnd );
    DWORD               dwFound;
    SP_IDisplayPointer  spDispEnd;

    Assert( pStart );

    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispEnd ) );
    
    if (pchVar && *pchVar)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("src") : _T("id") ) );
        IFC( strAttributes.Append( _T("=") ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("\"") : _T("") ) );
        IFC( strAttributes.Append( pchVar ) );
        IFC( strAttributes.Append( _cmdId == IDM_IMAGE ? _T("\"") : _T("") ) );
    }

    if (_bstrAttribName && _bstrAttribValue)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _bstrAttribName ) );
        IFC( strAttributes.Append( _T("=") ) );
        IFC( strAttributes.Append( _bstrAttribValue ) );
    }

    if (_cmdId == IDM_INSINPUTSUBMIT)
    {
        IFC( strAttributes.Append( _T(" ") ) );
        IFC( strAttributes.Append( _T("value='Submit Query'") ) );
    }

    // When we insert an NBSP, we need to remember the old end position
    IFC( spDispEnd->MoveToMarkupPointer( pEnd, NULL ) );
    IFC( spDispEnd->SetDisplayGravity( DISPLAY_GRAVITY_PreviousLine ) );
    IFC( spDispEnd->SetPointerGravity( POINTER_GRAVITY_Right ) );
    
    //
    // Setup the edit pointers to cling to text (but if we hit a block pointer, then
    // stop at that boundary.  This behavior correctly fixes 71146 and 90862.
    //

    //
    // also break for NoScope's ( scripts or comments). This fixes 89483
    //

    
    IFC( edStart.SetBoundary( GetEditor()->GetStartEditContext(), pEnd ) );
    IFC( edEnd.SetBoundary( pStart, GetEditor()->GetEndEditContext() ) );

#define BREAK_CONDITION_Insert  (BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_NoScope) - BREAK_CONDITION_EnterBlock 
#define BREAK_CONDITION_InsertBackscan (BREAK_CONDITION_OMIT_PHRASE | BREAK_CONDITION_NoScope) 
    //
    // #108607 -- BREAK_CONDITION_Insert is asymmetric! a reverse
    // scan with same parameter does not stop it at the desired 
    // position! consider the following case:
    //
    //      before{epStart}</P>after
    //
    // A forward scan will position the pointer at 
    //
    //      before</P>{epStart}after 
    //
    // while a reverse scan will position the pointer at 
    //
    //      befor{epStart}e</P>after
    //
    // This is because BREAK_CONDITION_EnterBlock is asymmertic!
    // 
    // [zhenbinx]
    //
    IFC( edStart.Scan(RIGHT, BREAK_CONDITION_Insert, &dwFound) );
    if (!edStart.CheckFlag( dwFound, BREAK_CONDITION_Boundary))
    {
        IFC( edStart.Scan(LEFT, BREAK_CONDITION_InsertBackscan, &dwFound) );
    }

    IFC( edEnd.Scan( LEFT, BREAK_CONDITION_Insert, &dwFound ) );
    if (!edEnd.CheckFlag( dwFound, BREAK_CONDITION_Boundary) )
    {
        IFC( edEnd.Scan(RIGHT, BREAK_CONDITION_InsertBackscan, &dwFound) );
    }
#undef BREAK_CONDITION_Insert 
#undef BREAK_CONDITION_InsertBackscan

   
    if (fRemove)
    {
        IFC( pMarkupServices->Remove( pStart, pEnd ) );

        IFC( ClingToText( pEnd, LEFT, pStart ) );
        IFC( ClingToText( pStart, RIGHT, pEnd ) );
    }

    if (_cmdId == IDM_NONBREAK)
    {
        OLECHAR             ch = WCH_NBSP;
        
        IFC( GetEditor()->InsertMaximumText( &ch, 1, pEnd ) );

        // If we're here becuase the user typed CTRL-SHIFT-SPACE to insert a nbsp, we need to 
        // autodetect for URLs. (see bug 83096). If for some reason we shouldn't be autodetecting,
        // ShouldPerformAutoDetection (called from CAutoUrlDetector::DetectCurrentWord) should
        // catch it.
        IFC( GetEditor()->UrlAutoDetectCurrentWord(pEnd) );

        //
        // When we insert an NBSP, we should position the caret tracker after where the
        // NBSP was inserted (word behavior, bug 96433)
        //
        IFC( GetEditor()->GetSelectionManager()->SetCurrentTracker( TRACKER_TYPE_Caret,
                                                                    spDispEnd, spDispEnd ) );
    }
    else
    {
        IFC( pMarkupServices->CreateElement( _tagId, strAttributes, & pIHTMLElement ) );
        IFC( InsertElement( pMarkupServices, pIHTMLElement, pStart, pEnd ) );
    }

    if (_tagId == TAGID_BR)
    {
        SP_ISegmentList spSegmentList;
        SELECTION_TYPE  eSelectionType;
        
        IFR( GetSegmentList(&spSegmentList) );
        if (spSegmentList != NULL)
        {
            IFR( spSegmentList->GetType( &eSelectionType) );
            if (eSelectionType == SELECTION_TYPE_Caret)
            {
                SP_IHTMLCaret      spCaret;
                
                IFR( GetDisplayServices()->GetCaret(&spCaret) );
                if (spCaret != NULL)
                {
                    SP_IDisplayPointer spDispPointer;

                    IFR( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
                    IFR( spCaret->MoveDisplayPointerToCaret(spDispPointer) );
                    IFR( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    
                    IFR( spCaret->MoveCaretToPointer(spDispPointer, TRUE, CARET_DIRECTION_INDETERMINATE) );
                }
            }
        }
    }
    else if(pIHTMLElement                                                   &&
            GetEditor()->IsElementSiteSelectable( pIHTMLElement) == S_OK    &&
            GetEditor()->IsContextEditable()                                && 
            _cmdId != IDM_HORIZONTALLINE ) // don't do this for HR's to make OE happy.
    {
        //
        // Site Select the inserted object
        //
        IFC( pStart->MoveAdjacentToElement( pIHTMLElement , ELEM_ADJ_BeforeBegin ));
        IFC( pEnd->MoveAdjacentToElement( pIHTMLElement , ELEM_ADJ_AfterEnd ));
        IFC( GetEditor()->SelectRangeInternal( pStart, pEnd, SELECTION_TYPE_Control, TRUE));
    }

Cleanup:

    ClearInterface( & pIHTMLElement );

    RRETURN( hr );
}


BOOL 
CInsertCommand::IsValidOnControl()
{
    ELEMENT_TAG_ID          eTag;
    SP_IHTMLElement         spElement;
    BOOL                    fValid = FALSE;
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fEmpty = FALSE;
    
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    IFC( spSegmentList->GetType( &eSelectionType ) );

    if (eSelectionType != SELECTION_TYPE_Control || fEmpty )
        goto Cleanup;

    IFC( spSegmentList->CreateIterator( &spIter ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment) );
        IFC( GetSegmentElement(spSegment, &spElement) );

        if (! spElement)
            goto Cleanup;

        IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));
        fValid = ( eTag == TAGID_IMG && _cmdId == IDM_IMAGE );
        if ( ! fValid )
            goto Cleanup;

        IFC( spIter->Advance() );
    }        
    
Cleanup:
    return fValid;
}


//+---------------------------------------------------------------------------
//
//  CInsertParagraphCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CInsertParagraphCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT                 hr;
    CEdUndoHelper           undoUnit(GetEditor());
    SP_IMarkupPointer       spStart, spEnd;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    CStr                    strPara;
    OLECMD                  cmd;  
    HGLOBAL                 hGlobal = 0;

    IFR( PrivateQueryStatus(&cmd, NULL) );
    if (cmd.cmdf == MSOCMDSTATE_DISABLED)
        return E_FAIL;

    IFR( GetSegmentList( &spSegmentList ));        
    IFR( spSegmentList->CreateIterator( &spIter ) );
    
    IFR( undoUnit.Begin(IDS_EDUNDONEWCTRL) );

    IFR( GetEditor()->CreateMarkupPointer(&spStart) );
    IFR( GetEditor()->CreateMarkupPointer(&spEnd) );

    while( spIter->IsDone() == S_FALSE )
    {
        // Position our pointers to the next segment
        IFR( spIter->Current(&spSegment) );
        IFR( spSegment->GetPointers( spStart, spEnd) );

        if ( pvarargIn )
        {
            CVariant var;
            
            IFR( VariantChangeTypeSpecial(&var, pvarargIn, VT_BSTR) );
            IFR( strPara.Set(_T("<P id=\"")) );
            IFR( strPara.Append(V_BSTR(&var)) );
            IFR( strPara.Append(_T("\"></P>")) );
        }
        else
        {
            IFR( strPara.Set(_T("<P></P>")) );
        }
        
        IFR( HtmlStringToSignaturedHGlobal(&hGlobal, strPara, _tcslen(strPara)) );
        hr = THR( GetEditor()->DoTheDarnIE50PasteHTML(spStart, spEnd, hGlobal) );
        GlobalFree(hGlobal);
        IFR(hr);

        IFR( spIter->Advance() );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\imedesgn.cxx ===
//+----------------------------------------------------------------------------
//
// File:        Imedesgn.CXX
//
// Contents:    Implementation of CIMEManager class
//
// Purpose:     The CIMEManager class implements the IHTMLEditDesigner interface.
//              It is designed to handle all of the IME functionality for the
//              editor.
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_IMEDESGN_H_
#define X_IMEDESGN_H_
#include "imedesgn.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

using namespace EdUtil;

ExternTag(tagEdIME);

//-----------------------------------------------------------------------------
//
//  Function:   CIMEManager::CIMEManager
//
//  Synopsis:   Creates the IME manager
//
//-----------------------------------------------------------------------------
CIMEManager::CIMEManager(void)
{
    _cRef = 1;
}

HRESULT
CIMEManager::PreHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_FALSE;
}

HRESULT
CIMEManager::PostHandleEvent( DISPID inDispId, IHTMLEventObj* pIObj )
{
    HRESULT hr;

    CHTMLEditEvent evt( GetEditor());
    IFC( evt.Init( pIObj , inDispId ));
    hr = THR( HandleEvent( &evt ));

Cleanup:
    return( hr );

}

HRESULT
CIMEManager::PostEditorEventNotify( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_OK;
}

HRESULT
CIMEManager::TranslateAccelerator( DISPID inDispId, IHTMLEventObj* pIObj )
{
    return S_FALSE;
}
//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::HandleMessage
//
//  Synopsis:   This method is responsible for handling any messages from the
//              editor which are interesting to the CIMEManager.
//
//  Arguments:  pMessage = SelectionMessage indicating incoming message
//
//  Returns:    HRESULT indicating whether the message was handled or not
//
//--------------------------------------------------------------------------
#ifndef IMR_DOCUMENTFEED
#define IMR_DOCUMENTFEED    0x0007
#endif
HRESULT
CIMEManager::HandleEvent( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE;
    LONG_PTR wParam;
    Assert( pEvent != NULL );


    switch (pEvent->GetType())
    {
        case EVT_IME_REQUEST:
            IGNORE_HR( DYNCAST(CHTMLEditEvent, pEvent)->GetIMERequest(&wParam) );
            if( ( wParam == IMR_RECONVERTSTRING) ||
                ( wParam == IMR_CONFIRMRECONVERTSTRING)
                /* ||( wParam == IMR_DOCUMENTFEED )*/
              )
            {
                Assert( wParam != IMR_DOCUMENTFEED );
                hr = HandleIMEReconversion(pEvent);
            }
            break;

        case EVT_IME_RECONVERSION:          // application initiated IME reconversion
            hr = HandleIMEReconversion(pEvent);
            break;

       default:
            hr = S_FALSE;
    }

    RRETURN1( hr, S_FALSE );
}

//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::Init
//
//  Synopsis:   Initializes the designer.
//
//  Arguments:  pEd = Pointer to main editor class
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CIMEManager::Init(
    CHTMLEditor *pEd)
{
    HRESULT hr = E_INVALIDARG;

    Assert( pEd );

    if( pEd )
    {
        hr = S_OK;
        _pEd = pEd;
    }

    RRETURN( hr );
}


//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::HandleIMEReconversion
//
//  Synopsis:   Actually does the hard work of handling the IME reconversion
//              Retrieves any selected text, and fills out the RECONVERTSTRING
//              structure required by the IME.
//
//  Arguments:  pMessage = Selection message which generated WM_IMEREQUEST
//
//  Returns:    HRESULT.
//--------------------------------------------------------------------------
/*
@Devnote:
    There different level of reconversion support. The RECONVERSIONSTRING
    structure can store the entire stentence point to the string that will
    be reconverted by dwStartOffset and dwLen. If dwStratOffset is at the
    beginning of the buffer (after the structure) and dwLen is the length
    of the string, the entire string is reconverted by the IME.

    Simple Reconversion:
    The simplest reconversion is when the target string and the composition
    string are the same as the entire string. In this case, dwCompStrOffset
    and dwTargetStrOffset are zero, and dwStrLen, dwCompStrLen, and
    dwTargetStrLen are the same value. An IME will provide the composition
    string of the entire string that is supplied in the structure, and will
    set the target clause by its conversion result.

    Normal Reconversion:
    For an efficient conversion result, the application should provide the
    RECONVERSIONSTRING structure with the information string. In this case,
    the composition string is not the entire string, but is identical to
    the target string. An IME can convert the composition string by
    referencing the entire string and then setting the target clause by its
    conversion result.

    Enhanced Reconversion:
    Applications can set a target string that is different from the
    composition string. The target string (or part of the target string) is
    then included in a target clause in high priority by the IME. The target
    string in the RECONVERSIONSTRING structure must be part of the composition
    string. When the application does not want to change the user's focus
    during the reconversion, the target string should be specified. The IME
    can then reference it.

    (zhenbinx)
*/
HRESULT
CIMEManager::HandleIMEReconversion(
                CEditEvent * pEvent
                )
{
    HRESULT         hr = S_OK;
    long            cch = 0;
    UINT            uiKeyboardCodePage = 0;
    TCHAR           ach[MAX_RECONVERSION_SIZE];
    BOOL            fIsUnicode;
    HIMC            hIMC = NULL;
    LONG_PTR        wParam;
    LONG_PTR        lParam;
    HWND            myHwnd;

    long            cbReconvert;
    long            cbStringSize;
    RECONVERTSTRING *lpRCS = NULL;
    LPSTR           lpReconvertBuf;

    //
    // IME reconversion is disabled by default.
    //
    //
    if (!GetEditor()->IsIMEReconversionEnabled() || !GetEditor()->IsContextEditable())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    if (GetEditor()->GetSelectionManager()->IsIMEComposition())
    {
        hr = S_FALSE;
        goto Cleanup;
    }


    IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetIMERequest(&wParam));
    IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetIMERequestData(&lParam));

    //
    // Check for UNICODE/Ansi flags
    //
    IFC( GetEditor()->GetHwnd(&myHwnd ));
    if (NULL == myHwnd)
        goto Cleanup;
    fIsUnicode = IsWindowUnicode( myHwnd );

    //
    // Look for lParam as possible RECONVERTSTRING
    //
    if (EVT_IME_REQUEST == pEvent->GetType())
    {
        TraceTag((tagEdIME, "EVT_IME_REQUEST"));
        lpRCS   = (RECONVERTSTRING *)(lParam);
        if (IMR_CONFIRMRECONVERTSTRING == wParam)
        {
            //
            // IME is asking for confirmation. Return TRUE/FALSE to IME
            //
            VARIANT v;
            BOOL    fRet;

            TraceTag((tagEdIME, "EVT_IME_REQUEST with IMR_CONFIRMRECONVERTSTRING"));

            Assert (lpRCS);
            WHEN_DBG( DumpReconvertString(lpRCS) );
            fRet = CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, fIsUnicode);
            WHEN_DBG( DumpReconvertString(lpRCS) );

            VariantInit(&v);
            V_VT(&v)   = VT_BOOL;
            V_BOOL(&v) = fRet ? VARIANT_TRUE : VARIANT_FALSE;
            IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetEventObject()->put_returnValue(v) );
            VariantClear(&v);
            goto Cleanup;
        }
    }

    //
    // Check to see if there was a selection
    //
    if (!SUCCEEDED(THR( RetrieveSelectedText(MAX_RECONVERSION_SIZE, &cch, ach))))
        goto Cleanup;

    if (cch)
    {
        //
        // Get the length of our string
        //
        if (fIsUnicode)
        {
            cbStringSize = cch * sizeof(WCHAR);
        }
        else
        {
            uiKeyboardCodePage = GetKeyboardCodePage();
            cbStringSize       = WideCharToMultiByte( uiKeyboardCodePage, 0, ach, cch, NULL, 0, NULL, NULL);
        }
        cbReconvert = cbStringSize + sizeof(RECONVERTSTRING) + 2;
    }
    else
    {
        cbStringSize = 0;
        cbReconvert  = 0;
    }

    //
    // Application initiated reconversion. Allocate the reconversion buffer
    //
    if (EVT_IME_RECONVERSION == pEvent->GetType())
    {
        lpRCS       = reinterpret_cast<RECONVERTSTRING *>(new BYTE[cbReconvert]);
        if (!lpRCS)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        memset(lpRCS, 0, cbReconvert);
    }

    if (EVT_IME_REQUEST == pEvent->GetType() 
        && wParam == IMR_RECONVERTSTRING)
    {
        // IEV6 bug 29552 - SetCandidateWindowPosition 
        hIMC = ImmGetContext(myHwnd);
        if (hIMC)
        {
            CANDIDATEFORM   cdCandForm;
            POINT ptCaret;
            RECT rc;
            long lLineHeight;

            if (SUCCEEDED(GetCompositionPos(&ptCaret, &rc, &lLineHeight)) )
            {
                memset(&cdCandForm, 0, sizeof(CANDIDATEFORM));

                cdCandForm.dwIndex = 0;
                cdCandForm.dwStyle  = CFS_CANDIDATEPOS;
                if (GetEditor()->GetSelectionManager()->KeyboardCodePage() == 932 /*JAPAN_CP*/)
                {
                    cdCandForm.dwStyle  = CFS_EXCLUDE;

                    cdCandForm.rcArea.left  =  ptCaret.x;
                    cdCandForm.rcArea.right =  cdCandForm.rcArea.left + 2;
                    cdCandForm.rcArea.top  =  ptCaret.y - lLineHeight;
                    ptCaret.y += 4;
                    cdCandForm.rcArea.bottom = ptCaret.y;
                }
                cdCandForm.ptCurrentPos = ptCaret;
                
                TraceTag((tagEdIME, "IME_REQUEST::IMR_RECONVERTSTRING ImmSetCandidateWindow [%d]-[%d] excl [%d]-[%d][%d]-[%d]",
                    cdCandForm.ptCurrentPos.x, cdCandForm.ptCurrentPos.y,
                    cdCandForm.rcArea.left, cdCandForm.rcArea.top,
                    cdCandForm.rcArea.right, cdCandForm.rcArea.bottom));
                Verify( ImmSetCandidateWindow(hIMC, &cdCandForm) );
            }
            ImmReleaseContext(myHwnd, hIMC);
        }
    }

    if (lpRCS)
    {
        //
        // Populate the RECONVERTSTRING structure
        // We're doing a simple reconversion
        //
        lpRCS->dwSize           = cbReconvert;
        lpRCS->dwStrOffset      = sizeof(RECONVERTSTRING);
        lpRCS->dwStrLen         = fIsUnicode ? cch : cbStringSize;    // TCHAR or byte counts depending on fUnicode

        lpRCS->dwCompStrOffset  = 0;        // byte counts
        lpRCS->dwCompStrLen     = lpRCS->dwStrLen;

        lpRCS->dwTargetStrOffset= lpRCS->dwCompStrOffset;
        lpRCS->dwTargetStrLen   = lpRCS->dwCompStrLen;

        WHEN_DBG( DumpReconvertString(lpRCS) );
        //
        // Setup the composition string
        //
        lpReconvertBuf = reinterpret_cast<LPSTR>(lpRCS) + sizeof(RECONVERTSTRING);
        if (cbStringSize)
        {
            if (fIsUnicode)
            {
                memcpy(lpReconvertBuf, ach, cch * sizeof(WCHAR));
            }
            else
            {
                WideCharToMultiByte(uiKeyboardCodePage, 0, ach, cch, lpReconvertBuf, cbStringSize, NULL, NULL);
            }
        }
        *(lpReconvertBuf + cbStringSize)     = '\0';
        *(lpReconvertBuf + cbStringSize + 1) = '\0';


        if (EVT_IME_RECONVERSION == pEvent->GetType())
        {
            //
            // Call ImmSetCompositionString to begin the reconversion
            //
            hIMC = ImmGetContext(myHwnd);
            if (hIMC)
            {
                DWORD   imeProperties = ImmGetProperty(GetKeyboardLayout(0), IGP_SETCOMPSTR);
                if ((imeProperties&(SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
                    ==   (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD)
                     )
                {
                    if (fIsUnicode)
                    {
                        if (ImmSetCompositionStringW( hIMC, SCS_QUERYRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0 ))
                        {
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                            //
                            // Need to Adjust Selection Accordingly
                            //
                            CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, TRUE);
                            ImmSetCompositionStringW( hIMC, SCS_SETRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0);
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                        }
                    }
                    else
                    {
                        if (ImmSetCompositionStringA( hIMC, SCS_QUERYRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0 ))
                        {
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                            //
                            // Need to Adjust Selection Accordingly
                            //
                            CheckIMEChange(lpRCS, NULL, NULL, NULL, NULL, FALSE);
                            ImmSetCompositionStringA( hIMC, SCS_SETRECONVERTSTRING, (LPVOID)lpRCS, (DWORD)cbReconvert, NULL, 0);
                            WHEN_DBG( DumpReconvertString(lpRCS) );
                        }
                    }
                    ImmReleaseContext(myHwnd, hIMC);
                } // imeProperties
            } // hIMC
            if (lpRCS)
            {
                delete [] (reinterpret_cast<BYTE *>(lpRCS));
            }
       } // EVT_IME_RECONVERSION == pEvent->GetType()
       else
       {
            goto ReturnSize;
       }
    } // lpRCS ! = NULL
    else
    {
        Assert( EVT_IME_REQUEST == pEvent->GetType() );
        Assert( IMR_RECONVERTSTRING == wParam );
        Assert( NULL == lpRCS );
        TraceTag((tagEdIME, "EVT_IME_REQUEST with IMR_RECONVERTSTRING and NULL lParam"));

ReturnSize:
        // return the size for IME to allocate the buffer
        VARIANT v;
        VariantInit(&v);
        V_VT(&v) = VT_I4;
        V_I4(&v) = cbReconvert;
        IGNORE_HR( DYNCAST(CHTMLEditEvent,pEvent)->GetEventObject()->put_returnValue(v) );
        VariantClear(&v);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::RetrieveSelectedText
//
//  Synopsis:   Retrieves the text which has been selected in the editor for
//              reconversion
//
//  Arguments:  cchMax = IN - indicates number of chars to grab
//              pcch = OUT - number of characters grabbed
//              pch = OUT - buffer containing chars
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CIMEManager::RetrieveSelectedText(
    LONG cchMax,
    LONG * pcch,
    TCHAR * pch )
{
    HRESULT                 hr = S_OK;
    DWORD                   dwSearch = BREAK_CONDITION_Text | BREAK_CONDITION_Block;
    DWORD                   dwFound = BREAK_CONDITION_None;
    const TCHAR             *pchStart = pch;
    const TCHAR             *pchEnd = pch + cchMax;
    SP_IMarkupPointer       spStart, spEnd;
    SELECTION_TYPE          eType;
    CEditPointer            epPointer( _pEd );
    SP_ISegmentList         spSegmentList;
    SP_ISegment             spSegment;
    SP_ISegmentListIterator spIter;
    BOOL                    fEmpty = FALSE;
    BOOL                    fLeftOfEnd;

    Assert( cchMax > 0 );
    Assert( pcch && pch );

    IFC( GetEditor()->GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );
    IFC( spSegmentList->GetType( &eType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    // Make sure we have a valid selection
    if( (fEmpty == FALSE) && (eType == SELECTION_TYPE_Text ) )
    {
        IFC( GetEditor()->CreateMarkupPointer(&spStart) );
        IFC( GetEditor()->CreateMarkupPointer(&spEnd) );

        IFC( spSegmentList->CreateIterator(&spIter ) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spStart, spEnd) );

        // PointersInSameFlowLayout found in Edutil namespace.  It would be
        // nice to get this as a separate utility package.
        if( GetEditor()->PointersInSameFlowLayout( spStart, spEnd, NULL ) )
        {
            IFC( epPointer->MoveToPointer( spStart ) );
            IFC( epPointer.SetBoundary( _pEd->GetSelectionManager()->GetStartEditContext() ,
                                        _pEd->GetSelectionManager()->GetEndEditContext() ));
            IFC( epPointer.Constrain() );

            //
            // Scoot begin pointer to the beginning of the non-white text
            //

            IFC( epPointer.Scan( RIGHT, dwSearch, &dwFound, NULL, NULL, NULL,
                                    SCAN_OPTION_SkipWhitespace | SCAN_OPTION_SkipNBSP ) );

            if ( !epPointer.CheckFlag(dwFound, BREAK_CONDITION_Text) )
                goto Cleanup;

            dwFound = BREAK_CONDITION_None;
            IFC( epPointer.Scan( LEFT, dwSearch, &dwFound ) );

            IFC( spStart->MoveToPointer( epPointer ) );

            //
            // Scoop up the text
            //
            fLeftOfEnd = FALSE;
            while (pch < pchEnd)
            {

                dwFound = BREAK_CONDITION_None;

                IFC( epPointer.Scan( RIGHT, dwSearch, &dwFound, NULL, NULL, pch ) );

                if( epPointer.CheckFlag(dwFound, BREAK_CONDITION_Block) )
                {
                    IFC( epPointer.Scan( LEFT, BREAK_CONDITION_Block, &dwFound, NULL, NULL, NULL) );
                    break;
                }
                else if( !epPointer.CheckFlag( dwFound, BREAK_CONDITION_Text) )
                {
                    break;
                }

                // NOTE (cthrash) WCH_NBSP is not native to any Far East codepage.
                // Here we simply convert to space, thus prevent the IME from getting confused.

                if (*pch == WCH_NBSP)
                {
                    *pch = L' ';
                }

                pch++;

                IFC( epPointer->IsLeftOf( spEnd, &fLeftOfEnd ));

                if (!fLeftOfEnd)
                    break;
            }


            //
            // If current selection has more text than maximum reconversion
            // we don't even want to do reconversion (or maybe we should
            // emit an error message like word does
            //
            if (pch >= pchEnd)      // we reached maximum allowed selection
            {
                if (fLeftOfEnd)     // there are more in the selection
                {
                        pch = const_cast<TCHAR *>(pchStart);
                    goto Cleanup;
                }
            }

            // Re-highlight the text
            IFC( spEnd->MoveToPointer(epPointer) );
            IFC( GetEditor()->SelectRange(spStart, spEnd, SELECTION_TYPE_Text ) );
            {
                SP_IHTMLCaret spCaret;
                SP_IDisplayPointer spDispPos;
                SP_IDisplayPointer spDispCtx;
                
                // now position caret to the end of this range
                IFC( GetEditor()->GetDisplayServices()->GetCaret( & spCaret ));
                IFC( GetEditor()->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
                IFC( GetEditor()->GetDisplayServices()->CreateDisplayPointer(&spDispCtx) );
                IFC( spCaret->MoveDisplayPointerToCaret(spDispCtx) );
                IFC( spDispPos->MoveToMarkupPointer(spEnd, spDispCtx) );
                IFC( spCaret->MoveCaretToPointer( spDispPos, TRUE, CARET_DIRECTION_SAME) );
            }
        }
    }

Cleanup:
    *pcch = pch - pchStart;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CIMEManager::CheckIMEChange
//
//  Synopsis:   Verify if IME wants to re-adjust the selection
//
//  Arguments:
//
//  Returns:
//              TRUE
//                  -- allow IME to change the selection
//              FALSE
//                  -- don't change the selection, use the original
//                     composition string
//
//--------------------------------------------------------------------------
BOOL
CIMEManager::CheckIMEChange(
                RECONVERTSTRING *lpRCS,
                IMarkupPointer  *pContextStart,
                IMarkupPointer  *pContextEnd,
                IMarkupPointer  *pCompositionStart,
                IMarkupPointer  *pCompositionEnd,
                BOOL            fUnicode
                )
{
   lpRCS;
   pContextStart;
   pContextEnd;
   pCompositionStart;
   pCompositionEnd;
   fUnicode;

   return FALSE;    // do not allow selection change
}


//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CIMEManager::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CIMEManager::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CIMEManager::QueryInterface(
    REFIID  iid,
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);

    if (iid == IID_IUnknown || iid == IID_IHTMLEditDesigner)
    {
        *ppvObj = (IHTMLEditDesigner *)this;
    }
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  funtion:    CIMEManager::GetCompositionPos( POINT * ppt, RECT * prc )
//
//  synopsis:   Determine the position for composition windows, etc.
//
//-----------------------------------------------------------------------------

HRESULT
CIMEManager::GetCompositionPos(
    POINT * ppt,
    RECT * prc,
    long * plLineHeight )
{
    HWND hwnd;
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IHTMLCaret spCaret;
    SP_IOleWindow spOleWindow;
    SP_IDisplayPointer spDispPos;
    SP_IMarkupPointer spInsertionPoint;
    SP_ILineInfo spLineInfo;
    LONG lTextDescent;

    Assert(_pEd);
    IFC( _pEd->GetDisplayServices()->CreateDisplayPointer(&spDispPos) );
    Assert(ppt && prc && plLineHeight);

    //
    // We get the line dimensions at the position of the caret. I realize we could
    // get some of the data from the caret, but we have to call through this way
    // anyway to get the descent and line height.
    //
    IFC( _pEd->GetDisplayServices()->GetCaret( & spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( spDispPos ));
    IFC( spDispPos->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_x(&ppt->x) );
    IFC( spLineInfo->get_baseLine(&ppt->y) );
    IFC( spLineInfo->get_textDescent(&lTextDescent) );
    ppt->y += lTextDescent;
    IFC( spLineInfo->get_textHeight(plLineHeight) );

    // Transform it to global coord.
    IFC( spDispPos->GetFlowElement( &spElement ));
    if ( ! spElement )
    {
        IFC( GetEditor()->GetSelectionManager()->GetEditableElement( & spElement ));
    }
    IFC( GetEditor()->GetDisplayServices()->TransformPoint( ppt, COORD_SYSTEM_CONTENT, COORD_SYSTEM_GLOBAL, spElement ));

    // tranlsate the unit
    GetEditor()->DeviceFromDocPixels(ppt);

    IFC( GetEditor()->GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow) );
    IFC(spOleWindow->GetWindow(&hwnd));
    ::GetClientRect(hwnd, prc);

Cleanup:
    RRETURN(hr);    
}



//////////////////////////////////////////////////////////////////////////
//
//  Debugger helper
//
//////////////////////////////////////////////////////////////////////////
WHEN_DBG(void CIMEManager::DumpReconvertString(RECONVERTSTRING *pRev)                       )
WHEN_DBG({                                                                                  )
WHEN_DBG(        TraceTag((tagEdIME, "dwSize             = %d", pRev->dwSize) );            )
WHEN_DBG(        TraceTag((tagEdIME, "dwVersion          = %d", pRev->dwVersion) );         )
WHEN_DBG(        TraceTag((tagEdIME, "dwStrLen           = %d", pRev->dwStrLen) );          )
WHEN_DBG(        TraceTag((tagEdIME, "dwStrOffset        = %d", pRev->dwStrOffset) );       )
WHEN_DBG(        TraceTag((tagEdIME, "dwCompStrOffset    = %d", pRev->dwCompStrOffset) );   )
WHEN_DBG(        TraceTag((tagEdIME, "dwCompStrLen       = %d", pRev->dwCompStrLen) );      )
WHEN_DBG(        TraceTag((tagEdIME, "dwTargetStrLen     = %d", pRev->dwTargetStrLen) );    )
WHEN_DBG(        TraceTag((tagEdIME, "dwTargetStrOffset  = %d", pRev->dwTargetStrOffset) ); )
WHEN_DBG(}                                                                                  )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\isclist.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       ISCLIST.CXX
//
//  Contents:   Implementation of input sequence checker list. Input 
//              Sequence Checkers are used for validating input of languages
//              like Thai, Hindi, and Vietnamese.
//
//  Classes:    CISCList
//
//  History:    10-13-98 - paulnel - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

const IID IID_IInputSequenceChecker = {0x6CF60DE0,0x42DC,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};
const IID IID_IEnumInputSequenceCheckers = {0x6FA9A2A8,0x437A,0x11d2,{0x97,0x12,0x00,0xC0,0x4F,0x79,0xE9,0x8B}};
const IID IID_IInputSequenceCheckerContainer = {0x02D887FA,0x4358,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};
const CLSID CLSID_InputSequenceCheckerContainer = {0x02D887FB,0x4358,0x11D2,{0xBE,0x22,0x08,0x00,0x09,0xDC,0x0A,0x8D}};

MtDefine(CAryISCData_pv, CSelectionManager, "CAryISCData::_pv");

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::CISCList
//
//  Synopsis:   Create the ISC list
//
//-----------------------------------------------------------------------------
CISCList::CISCList()
{
    _lcidCurrent = 0;
    _pISCCurrent = NULL;
    _nISCCount = FillList();
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::~CISCList
//
//  Synopsis:   Release interfaces and destroy the ISC list
//
//-----------------------------------------------------------------------------
CISCList::~CISCList()
{
    ISCDATA* prgISC;
    int i;
    
    for(i = _aryInstalledISC.Size(), prgISC = _aryInstalledISC;
	i > 0;
	i--, prgISC++)
    {
	// We need to make sure to release the ISC interfaces
	ReleaseInterface(prgISC->pISC);
    }
    _aryInstalledISC.DeleteAll();
}


//-----------------------------------------------------------------------------
//
//  Function:   CISCList::FillList
//
//  Synopsis:   Create the list of ISCs from the COM interface (if available)
//
//  Return:     Number of ISCs installed
//
//-----------------------------------------------------------------------------
int CISCList::FillList()
{
    int nListCount = 0;
    LCID lcidCurrent = LOWORD(GetKeyboardLayout(0));

    HRESULT hr = 0;
    IUnknown *pUnk = NULL;
    IInputSequenceCheckerContainer *pISCCont = NULL;
    IEnumInputSequenceCheckers *pEnum = NULL;
    ULONG lRequested = MAX_ISC_COUNT, lFetched;
    ISCDATA pISCEngines[MAX_ISC_COUNT];

    // cocreate the input sequence checker container
    // NT5 bug 298904 - add context CLSCTX_NO_CODE_DOWNLOAD because this
    //                  does not require a download from the Class Store.
    if(g_dwPlatformID == VER_PLATFORM_WIN32_NT && g_dwPlatformVersion >= 0x00050000)
    {
        hr = CoCreateInstance(CLSID_InputSequenceCheckerContainer, 
                  NULL, 
                  CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                  IID_IUnknown,
                  (void**)&pUnk);
    }
    else
    {
        hr = CoCreateInstance(CLSID_InputSequenceCheckerContainer, 
                  NULL, 
                  CLSCTX_INPROC_SERVER, 
                  IID_IUnknown,
                  (void**)&pUnk);
    }

    if(hr || !pUnk)
	goto Cleanup;

    // get the container interface
    hr = pUnk->QueryInterface(IID_IInputSequenceCheckerContainer, (void**)&pISCCont);

    if(hr || !pISCCont)
	goto Cleanup;

    // enum the input sequence checkers
    hr = pISCCont->EnumISCs(&pEnum);

    if(hr | !pEnum)
	goto Cleanup;

    do
    {
	// fetch any input sequence checkers
	hr = pEnum->Next(lRequested, (ISCDATA*) pISCEngines, &lFetched);

	if(FAILED(hr))
		goto Cleanup;

	for (ULONG i = 0; i < lFetched; i++)
	{       
	    // load ISC interfaces into the list.
	    hr = Add(pISCEngines[i].lcidChecker, pISCEngines[i].pISC);

	    if(!hr)
			nListCount++;
	}

    } while (lFetched != 0);

    // set the ISC to the current keyboard LCID
    SetActive(lcidCurrent);

Cleanup:
    ReleaseInterface(pUnk);
    ReleaseInterface(pISCCont);
    ReleaseInterface(pEnum);

    return nListCount;
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::SetActive
//
//  Synopsis:   Set the current ISC to the LCID passed in
//
//  Return:     A pointer to the ISC. This will be NULL if an ISC for the 
//              LCID does not exist.
//
//-----------------------------------------------------------------------------
IInputSequenceChecker* CISCList::SetActive(LCID lcidISC)
{
    // make sure to find the ISC first. We will short circuit inside of Find
    // if _lcidCurrent = lcidISC
    _pISCCurrent = Find(lcidISC);
    _lcidCurrent = lcidISC;

    return _pISCCurrent;
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::CheckInputSequence
//
//  Synopsis:   Pass the input character and a buffer of characters before the
//              location of insertion to be analysed for correctness of addition
//              to text store
//
//  Return:     A BOOL indicating whether the input character should be added
//              to the text store
//
//-----------------------------------------------------------------------------
BOOL CISCList::CheckInputSequence(LPTSTR pszISCBuffer, long ich, WCHAR chTest)
{
    BOOL fAccept=TRUE;
    HRESULT hr;

    Assert(_pISCCurrent);
    hr = _pISCCurrent->CheckInputSequence(pszISCBuffer, ich, chTest, &fAccept);

    // We don't want to lock a person out from editing in
    // the event the sequence checker is hosed.
    return (hr == S_OK ? fAccept : TRUE);
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::Add
//
//  Synopsis:   Add an Input Sequence Check data item to the list of checkers.
//
//  Return:     HRESULT indicating success or error condition
//
//-----------------------------------------------------------------------------
HRESULT CISCList::Add(LCID lcidISC, IInputSequenceChecker* pISC)
{
    ISCDATA newISC;
	
    if(pISC == NULL)
	return E_POINTER;

    if(Find(lcidISC))
	return CONNECT_E_ADVISELIMIT;

    newISC.lcidChecker = lcidISC;
    newISC.pISC = pISC;

    return _aryInstalledISC.AppendIndirect(&newISC);
}

//-----------------------------------------------------------------------------
//
//  Function:   CISCList::Find
//
//  Synopsis:   Find the ISC process that correspondes to an LCID
//
//  Return:     A pointer to the ISC process that corresponds to the LCID. 
//              This will be NULL if an ISC for the LCID does not exist.
//
//-----------------------------------------------------------------------------
IInputSequenceChecker* CISCList::Find(LCID lcidISC)
{
    if(lcidISC == _lcidCurrent)
	return _pISCCurrent;

    ISCDATA* prgISC;
    int i;

    for(i = _aryInstalledISC.Size(), prgISC = _aryInstalledISC;
	i > 0;
	i--, prgISC++)
    {
	if(prgISC->lcidChecker == lcidISC)
	{
	    return prgISC->pISC;
	}
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\iscsa.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue Sep 29 10:54:33 1998
 */
/* Compiler settings for ISCSa.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef UNIX
#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__
#endif

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ISCSa_h__
#define __ISCSa_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IInputSequenceChecker_FWD_DEFINED__
#define __IInputSequenceChecker_FWD_DEFINED__
typedef interface IInputSequenceChecker IInputSequenceChecker;
#endif 	/* __IInputSequenceChecker_FWD_DEFINED__ */


#ifndef __IEnumInputSequenceCheckers_FWD_DEFINED__
#define __IEnumInputSequenceCheckers_FWD_DEFINED__
typedef interface IEnumInputSequenceCheckers IEnumInputSequenceCheckers;
#endif 	/* __IEnumInputSequenceCheckers_FWD_DEFINED__ */


#ifndef __IInputSequenceCheckerContainer_FWD_DEFINED__
#define __IInputSequenceCheckerContainer_FWD_DEFINED__
typedef interface IInputSequenceCheckerContainer IInputSequenceCheckerContainer;
#endif 	/* __IInputSequenceCheckerContainer_FWD_DEFINED__ */


#ifndef __ISCThai_FWD_DEFINED__
#define __ISCThai_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCThai ISCThai;
#else
typedef struct ISCThai ISCThai;
#endif /* __cplusplus */

#endif 	/* __ISCThai_FWD_DEFINED__ */


#ifndef __InputSequenceCheckerContainer_FWD_DEFINED__
#define __InputSequenceCheckerContainer_FWD_DEFINED__

#ifdef __cplusplus
typedef class InputSequenceCheckerContainer InputSequenceCheckerContainer;
#else
typedef struct InputSequenceCheckerContainer InputSequenceCheckerContainer;
#endif /* __cplusplus */

#endif 	/* __InputSequenceCheckerContainer_FWD_DEFINED__ */


#ifndef __EnumInputSequenceCheckers_FWD_DEFINED__
#define __EnumInputSequenceCheckers_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInputSequenceCheckers EnumInputSequenceCheckers;
#else
typedef struct EnumInputSequenceCheckers EnumInputSequenceCheckers;
#endif /* __cplusplus */

#endif 	/* __EnumInputSequenceCheckers_FWD_DEFINED__ */


#ifndef __ISCHindi_FWD_DEFINED__
#define __ISCHindi_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCHindi ISCHindi;
#else
typedef struct ISCHindi ISCHindi;
#endif /* __cplusplus */

#endif 	/* __ISCHindi_FWD_DEFINED__ */


#ifndef __ISCVietnamese_FWD_DEFINED__
#define __ISCVietnamese_FWD_DEFINED__

#ifdef __cplusplus
typedef class ISCVietnamese ISCVietnamese;
#else
typedef struct ISCVietnamese ISCVietnamese;
#endif /* __cplusplus */

#endif 	/* __ISCVietnamese_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IInputSequenceChecker_INTERFACE_DEFINED__
#define __IInputSequenceChecker_INTERFACE_DEFINED__

/* interface IInputSequenceChecker */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInputSequenceChecker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CF60DE0-42DC-11D2-BE22-080009DC0A8D")
    IInputSequenceChecker : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetLCID( 
            /* [out] */ LCID __RPC_FAR *plcid) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckInputSequence( 
            /* [string][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [out] */ BOOL __RPC_FAR *pfValue) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckAndReplaceInputSequence( 
            /* [size_is][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT cchCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [in] */ UINT cchBuffer,
            /* [size_is][out][in] */ LPWSTR pOutBuffer,
            /* [out] */ UINT __RPC_FAR *pchOutBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputSequenceCheckerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputSequenceChecker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputSequenceChecker __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLCID )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [out] */ LCID __RPC_FAR *plcid);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckInputSequence )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [string][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [out] */ BOOL __RPC_FAR *pfValue);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckAndReplaceInputSequence )( 
            IInputSequenceChecker __RPC_FAR * This,
            /* [size_is][in] */ LPWSTR pCharBuffer,
            /* [in] */ UINT cchCharBuffer,
            /* [in] */ UINT ichPosition,
            /* [in] */ WCHAR chEval,
            /* [in] */ UINT cchBuffer,
            /* [size_is][out][in] */ LPWSTR pOutBuffer,
            /* [out] */ UINT __RPC_FAR *pchOutBuffer);
        
        END_INTERFACE
    } IInputSequenceCheckerVtbl;

    interface IInputSequenceChecker
    {
        CONST_VTBL struct IInputSequenceCheckerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputSequenceChecker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputSequenceChecker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputSequenceChecker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputSequenceChecker_GetLCID(This,plcid)	\
    (This)->lpVtbl -> GetLCID(This,plcid)

#define IInputSequenceChecker_CheckInputSequence(This,pCharBuffer,ichPosition,chEval,pfValue)	\
    (This)->lpVtbl -> CheckInputSequence(This,pCharBuffer,ichPosition,chEval,pfValue)

#define IInputSequenceChecker_CheckAndReplaceInputSequence(This,pCharBuffer,cchCharBuffer,ichPosition,chEval,cchBuffer,pOutBuffer,pchOutBuffer)	\
    (This)->lpVtbl -> CheckAndReplaceInputSequence(This,pCharBuffer,cchCharBuffer,ichPosition,chEval,cchBuffer,pOutBuffer,pchOutBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_GetLCID_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [out] */ LCID __RPC_FAR *plcid);


void __RPC_STUB IInputSequenceChecker_GetLCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_CheckInputSequence_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [string][in] */ LPWSTR pCharBuffer,
    /* [in] */ UINT ichPosition,
    /* [in] */ WCHAR chEval,
    /* [out] */ BOOL __RPC_FAR *pfValue);


void __RPC_STUB IInputSequenceChecker_CheckInputSequence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceChecker_CheckAndReplaceInputSequence_Proxy( 
    IInputSequenceChecker __RPC_FAR * This,
    /* [size_is][in] */ LPWSTR pCharBuffer,
    /* [in] */ UINT cchCharBuffer,
    /* [in] */ UINT ichPosition,
    /* [in] */ WCHAR chEval,
    /* [in] */ UINT cchBuffer,
    /* [size_is][out][in] */ LPWSTR pOutBuffer,
    /* [out] */ UINT __RPC_FAR *pchOutBuffer);


void __RPC_STUB IInputSequenceChecker_CheckAndReplaceInputSequence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputSequenceChecker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ISCSa_0209 */
/* [local] */ 

typedef struct  tagISCDATA
    {
    LCID lcidChecker;
    IInputSequenceChecker __RPC_FAR *pISC;
    }	ISCDATA;



extern RPC_IF_HANDLE __MIDL_itf_ISCSa_0209_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ISCSa_0209_v0_0_s_ifspec;

#ifndef __IEnumInputSequenceCheckers_INTERFACE_DEFINED__
#define __IEnumInputSequenceCheckers_INTERFACE_DEFINED__

/* interface IEnumInputSequenceCheckers */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumInputSequenceCheckers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FA9A2A8-437A-11d2-9712-00C04F79E98B")
    IEnumInputSequenceCheckers : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cISCs,
            /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cICSs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputSequenceCheckersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ ULONG cISCs,
            /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [in] */ ULONG cICSs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumInputSequenceCheckers __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumInputSequenceCheckers __RPC_FAR * This,
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumInputSequenceCheckersVtbl;

    interface IEnumInputSequenceCheckers
    {
        CONST_VTBL struct IEnumInputSequenceCheckersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputSequenceCheckers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputSequenceCheckers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputSequenceCheckers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputSequenceCheckers_Next(This,cISCs,pISCData,pcFetched)	\
    (This)->lpVtbl -> Next(This,cISCs,pISCData,pcFetched)

#define IEnumInputSequenceCheckers_Skip(This,cICSs)	\
    (This)->lpVtbl -> Skip(This,cICSs)

#define IEnumInputSequenceCheckers_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputSequenceCheckers_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Next_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [in] */ ULONG cISCs,
    /* [length_is][size_is][out] */ ISCDATA __RPC_FAR *pISCData,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumInputSequenceCheckers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Skip_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [in] */ ULONG cICSs);


void __RPC_STUB IEnumInputSequenceCheckers_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Reset_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This);


void __RPC_STUB IEnumInputSequenceCheckers_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IEnumInputSequenceCheckers_Clone_Proxy( 
    IEnumInputSequenceCheckers __RPC_FAR * This,
    /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumInputSequenceCheckers_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputSequenceCheckers_INTERFACE_DEFINED__ */


#ifndef __IInputSequenceCheckerContainer_INTERFACE_DEFINED__
#define __IInputSequenceCheckerContainer_INTERFACE_DEFINED__

/* interface IInputSequenceCheckerContainer */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IInputSequenceCheckerContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02D887FA-4358-11D2-BE22-080009DC0A8D")
    IInputSequenceCheckerContainer : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnumISCs( 
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInputSequenceCheckerContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IInputSequenceCheckerContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IInputSequenceCheckerContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IInputSequenceCheckerContainer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumISCs )( 
            IInputSequenceCheckerContainer __RPC_FAR * This,
            /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IInputSequenceCheckerContainerVtbl;

    interface IInputSequenceCheckerContainer
    {
        CONST_VTBL struct IInputSequenceCheckerContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInputSequenceCheckerContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInputSequenceCheckerContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInputSequenceCheckerContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInputSequenceCheckerContainer_EnumISCs(This,ppEnum)	\
    (This)->lpVtbl -> EnumISCs(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IInputSequenceCheckerContainer_EnumISCs_Proxy( 
    IInputSequenceCheckerContainer __RPC_FAR * This,
    /* [out] */ IEnumInputSequenceCheckers __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IInputSequenceCheckerContainer_EnumISCs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInputSequenceCheckerContainer_INTERFACE_DEFINED__ */



#ifndef __ISCSALib_LIBRARY_DEFINED__
#define __ISCSALib_LIBRARY_DEFINED__

/* library ISCSALib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ISCSALib;

EXTERN_C const CLSID CLSID_ISCThai;

#ifdef __cplusplus

class DECLSPEC_UUID("6CF60DE1-42DC-11D2-BE22-080009DC0A8D")
ISCThai;
#endif

EXTERN_C const CLSID CLSID_InputSequenceCheckerContainer;

#ifdef __cplusplus

class DECLSPEC_UUID("02D887FB-4358-11D2-BE22-080009DC0A8D")
InputSequenceCheckerContainer;
#endif

EXTERN_C const CLSID CLSID_EnumInputSequenceCheckers;

#ifdef __cplusplus

class DECLSPEC_UUID("BCB80276-4807-11d2-9717-00C04F79E98B")
EnumInputSequenceCheckers;
#endif

EXTERN_C const CLSID CLSID_ISCHindi;

#ifdef __cplusplus

class DECLSPEC_UUID("0666DB29-4823-11d2-9717-00C04F79E98B")
ISCHindi;
#endif

EXTERN_C const CLSID CLSID_ISCVietnamese;

#ifdef __cplusplus

class DECLSPEC_UUID("75624FA1-4826-11d2-9717-00C04F79E98B")
ISCVietnamese;
#endif
#endif /* __ISCSALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\makefile.inc ===
#MIDL= $(DEVTOOLS)\midl.exe

PASS0_HEADERDIR =$(O)
PASS0_SOURCEDIR =$(O)
MIDL_UUIDDIR    =$(O)

$O\OptsHold.idl : $(ROOT)\src\edit\OptsHold.idl
    copy $** $@

$O\OptsHold.h $O\OptsHold.tlb libmain.cxx : OptsHold.idl

#this is not final yet
$O\optshold.tlb : $O\optshold.idl
    $(MIDL) \
!ifndef WIN16
    -Zp8 \
!else
    /Zp2 /DWIN16 /DDOS /DWIN $(MIDL_FLAGS) \
!endif
    $(INCPATH0) \
    -char unsigned \
    -ms_ext -c_ext \
    -proxy $O\optshold_p.c \
    -dlldata $O\dlldata.c \
    -iid $O\optshold_i.c \
    -header $O\optshold.h \
    -cpp_cmd $(TARGET_CPP) \
    -tlb $(O)\optshold.tlb \
    $(C_DEFINES) \
    $(MIDL_OPTIMIZATION) \
    $O\optshold.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\misccmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       MiscCmd.cxx
//
//  Contents:   Implementation of miscellaneous edit commands
//
//  Classes:    CComposeSettingsCommand
//
//  History:    08-05-98 - OliverSe - created
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDUTIL_HXX_
#define _X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_RESOURCE_H_
#define _X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CComposeSettingsCommand, EditCommand, "CComposeSettingsCommand");
MtDefine(COverwriteCommand, EditCommand, "COverwriteCommand");
MtDefine(CAutoDetectCommand, EditCommand, "CAutoDetectCommand");
MtDefine(CMovePointerToSelectionCommand, EditCommand, "CMovePointerToSelectionCommand");
MtDefine(CLocalizeEditorCommand, EditCommand, "CLocalizeEditorCommand");
MtDefine(CAutoUrlDetectModeCommand, EditCommand, "CAutoUrlDetectModeCommand");
MtDefine(CIE50PasteModeCommand, EditCommand, "CIE50PasteModeCommand");
MtDefine(CCssEditingLevelCommand, EditCommand, "CCssEditingLevelCommand");
MtDefine(CIMEReconversionCommand, EditCommand, "CIMEReconversionCommand");

CRITICAL_SECTION CComposeSettingsCommand::s_csLastComposeSettings;
BSTR             CComposeSettingsCommand::s_bstrLastComposeSettings = NULL;
BOOL             CComposeSettingsCommand::s_fCSInited = FALSE;

//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::PrivateExec
//
//  Synopsis: Pass compose settings to the springloader
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    // If an inArg and an outArg was specified, this means we are querying the
    // compose font.
    if (pvarargIn && pvarargOut)
    {
        return THR(QueryComposeSettings(pvarargIn, pvarargOut));
    }

    struct COMPOSE_SETTINGS * pComposeSettings = NULL;
    CSpringLoader     * psl = GetSpringLoader();
    IHTMLCaret        * pCaret = NULL;
    IMarkupPointer    * pmpCaret = NULL;
    BOOL                fToggleComposeSettings = FALSE;
    HRESULT             hr;

    Assert(GetEditor());

    //
    // Check parameters.
    //

    if (!pvarargIn || (V_VT(pvarargIn) != VT_BSTR && V_VT(pvarargIn) != VT_BOOL))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    //
    // If specified, parse and memorize compose settings.
    //

    if (V_VT(pvarargIn) == VT_BSTR)
    {
        pComposeSettings = GetEditor()->EnsureComposeSettings();
        if (!pComposeSettings)
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        Assert(pvarargIn && V_VT(pvarargIn) == VT_BSTR);

        hr = THR(ParseComposeSettings(V_BSTR(pvarargIn), pComposeSettings));
        if (hr)
            goto Error;

        fToggleComposeSettings = TRUE;
    }
    else
    {
        BOOL fComposeSettings;

        fToggleComposeSettings = TRUE;
        pComposeSettings = GetEditor()->GetComposeSettings(fToggleComposeSettings);

        Assert(pvarargIn && V_VT(pvarargIn) == VT_BOOL);
        fComposeSettings = !!V_BOOL(pvarargIn);

        if (!pComposeSettings || !!pComposeSettings->_fComposeSettings == fComposeSettings)
            goto Cleanup;

        pComposeSettings->_fComposeSettings = fComposeSettings;
    }

    //
    // Springload compose settings at the caret.
    //

    hr = THR(GetDisplayServices()->GetCaret(&pCaret));
    if (hr || !pCaret)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = THR(GetEditor()->CreateMarkupPointer(&pmpCaret));
    if (!hr && pmpCaret)
    {
        if (S_OK != THR(pCaret->MoveMarkupPointerToCaret(pmpCaret)))
        {
            ClearInterface(&pmpCaret);
        }
    }

    IGNORE_HR(psl->SpringLoadComposeSettings(pmpCaret, fToggleComposeSettings));

Cleanup:

    if (!fToggleComposeSettings)
    {
        Assert(pvarargIn && V_VT(pvarargIn) == VT_BSTR);
        EnterCriticalSection(&s_csLastComposeSettings);

        if (s_bstrLastComposeSettings)
            SysFreeString(s_bstrLastComposeSettings);

        s_bstrLastComposeSettings = SysAllocString(V_BSTR(pvarargIn));

        LeaveCriticalSection(&s_csLastComposeSettings);
    }

    hr = S_OK;

Error:

    ReleaseInterface(pmpCaret);
    ReleaseInterface(pCaret);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::ParseComposeSettings
//
//  Synopsis:   This function parses the string coming in and sets up the
//              default composition font.
//
//  Params:     [pbstrComposeSettings]: A BSTR containing the string telling
//                                      us the font settings to use.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::ParseComposeSettings(
    BSTR bstrComposeSettings,
    struct COMPOSE_SETTINGS * pComposeSettings )
{
    typedef enum {
        IT_INT,
        IT_COLOR,
        IT_STRING
    } INFO_TYPE;

    static const struct {
        INFO_TYPE itType;
        DWORD     offset;
    } itParseTable[] = {
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fBold)      },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fItalic)    },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fUnderline) },
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _lSize)      },
        {IT_COLOR, offsetof(struct COMPOSE_SETTINGS, _color)      },
        {IT_COLOR, offsetof(struct COMPOSE_SETTINGS, _colorBg)    },
        {IT_STRING,offsetof(struct COMPOSE_SETTINGS, _varFont)    },
        {IT_STRING,offsetof(struct COMPOSE_SETTINGS, _varSpanClass)},
        {IT_INT,   offsetof(struct COMPOSE_SETTINGS, _fUseOutsideSpan)},
    };

    const TCHAR FIELD_SEPARATOR = _T(',');
    const TCHAR COLOR_SEPARATOR = _T('.');
    const INT REQUIRED_FIELDS = 7; // 8th and 9th fields optional
    TCHAR   achComposeFont[LF_FACESIZE];
    TCHAR * pstr;
    TCHAR * pstrEnd;
    DWORD_PTR pDest;
    INT     index;
    HRESULT hr = E_INVALIDARG;

    Assert(pComposeSettings);

    // Setup the default compose settings.
    SetDefaultComposeSettings(pComposeSettings);

    // Get the string.
    pstr = bstrComposeSettings;

    // Index is used to walk the parse table.
    index = 0;

    while (index < ARRAY_SIZE(itParseTable))
    {
        // Skip commas: empty fields indicate that we should use
        // defaults for that field.
        while(   *pstr == FIELD_SEPARATOR
              && *pstr != 0
              && index < ARRAY_SIZE(itParseTable)
             )
        {
            index++;
            pstr++;
        }

        // Last field was omitted, so quit.
        if (index >= ARRAY_SIZE(itParseTable))
            break;

        // Ran out of the string early --> invalid arg, return
        if (*pstr == 0)
        {
            if (index >= REQUIRED_FIELDS)
                hr = S_OK;
            goto Cleanup;
        }

        pstrEnd = NULL;
        pDest = ((DWORD_PTR)pComposeSettings) + itParseTable[index].offset;
        switch (itParseTable[index].itType)
        {
        case IT_INT:
            *((INT *)pDest) = wcstol(pstr, &pstrEnd, 10);
            break;

        case IT_COLOR:
        {

            INT Colors[3];
            INT i;
            for (i = 0; i < 3; i++)
            {
                Colors[i] = wcstol(pstr, &pstrEnd, 10);

                Assert(    *pstrEnd == COLOR_SEPARATOR
                       || (*pstrEnd == FIELD_SEPARATOR && (i == 2))
                      );
                if  (!(    *pstrEnd == COLOR_SEPARATOR
                       || (*pstrEnd == FIELD_SEPARATOR && (i == 2))
                      )
                    )
                    goto Cleanup;

                // RGB values are separated by a '.'. Go past them.
                pstr = pstrEnd + 1;
            }

            // Finally construct the color.
            *((INT *)pDest) = RGB(Colors[0], Colors[1], Colors[2]);
            break;
        }

        case IT_STRING:
        {
            INT    i = 0;
            TCHAR *pDestChar = achComposeFont;
            INT iSize = ARRAY_SIZE(achComposeFont);

            //
            // Loop thru the string till we reach the end or a comma.
            //

            while (*pstr != 0 && *pstr != FIELD_SEPARATOR && i < iSize)
            {
                // Copy the character into the destination
                *pDestChar++ = *pstr++;
                i++;
            }

            // If some character was copied to the destination then we need
            // to put in the NULL terminator. If no character was copied, then
            // we want to leave the destn as it was since, we want to retain
            // the default values in it.
            if (i > 0)
            {
                // If the while loop terminated because we ran out of space
                // in the destination then put the \0 in the last possible space
                // of the destination.
                if (i >= iSize)
                    pDestChar--;

                // Finally, terminate the string.
                *pDestChar = 0;

                {
                    CVariant * pvarDest = (CVariant *)pDest;
                    V_VT(pvarDest) = VT_BSTR;
                    THR(EdUtil::FormsAllocString(achComposeFont, &V_BSTR(pvarDest)));
                }
            }

            // This is where the string field ended.
            pstrEnd = pstr;
            break;
        }

        default:
            AssertSz(0, "Unexpected type");
            goto Cleanup;
        }

        // We are either at the EOI, or end of a field
        Assert(*pstrEnd == 0 || *pstrEnd == FIELD_SEPARATOR);
        if  (!(*pstrEnd == 0 || *pstrEnd == FIELD_SEPARATOR))
            goto Cleanup;

        // Read next field from the string
        index++;

        if (*pstrEnd == 0)
        {
            if (index >= REQUIRED_FIELDS)
                hr = S_OK;
            goto Cleanup;
        }

        pstr = pstrEnd + 1;
    }

    hr = S_OK;

Cleanup:

    // Do we have any compose settings?
    pComposeSettings->_fComposeSettings = hr == S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::SetDefaultComposeSettings
//
//  Synopsis:   This function sets up the default values in compose settings.
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

void
CComposeSettingsCommand::SetDefaultComposeSettings(struct COMPOSE_SETTINGS * pComposeSettings)
{
    Assert(pComposeSettings);

    //
    // By default, no underline, bold or italic
    //

    pComposeSettings->_fBold        = FALSE;
    pComposeSettings->_fItalic      = FALSE;
    pComposeSettings->_fUnderline   = FALSE;
    pComposeSettings->_fSuperscript = FALSE;
    pComposeSettings->_fSubscript   = FALSE;

    // Compose sizes in option settings are in 1-7 range
    pComposeSettings->_lSize        = -1;

    // By default, FG and BG undefined
    pComposeSettings->_color        = VALUE_UNDEF;
    pComposeSettings->_colorBg      = VALUE_UNDEF;

    // By default, fontface and spanclass are undefined.
    VariantClear(&pComposeSettings->_varFont);
    V_VT(&pComposeSettings->_varFont)= VT_NULL;

    VariantClear(&pComposeSettings->_varSpanClass);
    V_VT(&pComposeSettings->_varSpanClass)= VT_NULL;

    // Don't use compose settings everywhere outside span by default.
    pComposeSettings->_fUseOutsideSpan = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CComposeSettingsCommand::ExtractLastComposeSettings
//
//  Synopsis:   This function extracts the compose settings of a previous
//              document if we don't have any.
//
//  Returns:    Nothing.
//
//----------------------------------------------------------------------------

void
CComposeSettingsCommand::ExtractLastComposeSettings(CHTMLEditor * pEditor, BOOL fEditorHasComposeSettings)
{
    Assert(pEditor);

    if (!s_bstrLastComposeSettings)
        return;

    EnterCriticalSection(&s_csLastComposeSettings);

    if (s_bstrLastComposeSettings)
    {
        //
        // If we don't have compose settings, parse and memorize last compose settings.
        //

        if (!fEditorHasComposeSettings)
        {
            // Ensure compose settings.
            struct COMPOSE_SETTINGS * pComposeSettings = pEditor->EnsureComposeSettings();
            if (pComposeSettings)
            {
                IGNORE_HR(ParseComposeSettings(s_bstrLastComposeSettings, pComposeSettings));
            }
        }

        SysFreeString(s_bstrLastComposeSettings);
        s_bstrLastComposeSettings = NULL;
    }

    LeaveCriticalSection(&s_csLastComposeSettings);
}


//+------------------------------------------------------------------------
//
//  Function:  CComposeSettingsCommand::QueryComposeSettings
//
//  Synopsis:  Return information about the current compose settings
//
//  Arguments: pvarargIn:  Which IDM command to return the value for.
//                         If this is of type VT_UNKNOWN, we interpret
//                         it as a markup pointer, and ask the springloader
//                         whether it would springload at that position.
//
//                         If no markup pointer is passed in, we are
//                         asking about the current (springloaded) font
//                         instead.
//
//             pvarargOut: The value of the IDM command as found in
//                         the compose settings.
//
//  Returns:   VT_NULL in pvarargOut if we don't have compose settings or
//             they don't apply to the position of the markup pointer
//             passed in.
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::QueryComposeSettings( 
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    CHTMLEditor     *pEditor = GetEditor();
    CSpringLoader   *psl = GetSpringLoader();
    HRESULT         hr = S_OK;
    DWORD           cmdId;
    DWORD           dwSearch = BREAK_CONDITION_OMIT_PHRASE;
    DWORD           dwFound = 0;
    
    Assert(pvarargIn && pvarargOut);
    Assert(V_VT(pvarargIn) == VT_I4 || V_VT(pvarargIn) == VT_UNKNOWN);
    Assert(psl);

    V_VT(pvarargOut) = VT_NULL;

    if (VT_UNKNOWN == V_VT(pvarargIn))
    {
        IMarkupPointer * pmpPosition = ((IMarkupPointer *)V_UNKNOWN(pvarargIn));
        psl->OverrideComposeSettings(FALSE);

        if( pmpPosition )
        {
            CEditPointer ep(pEditor, pmpPosition);
        
            if( psl->IsSpringLoadedAt( pmpPosition ) )
            {
                // Return success
                psl->OverrideComposeSettings(TRUE);
                V_VT(pvarargOut) = VT_I4;
                V_I4(pvarargOut) = 1;
            }
            else
            {
                IFC( ep.Scan(LEFT, dwSearch | BREAK_CONDITION_ExitPhrase, &dwFound) );

                // Scan to the right inner-most phrase element, return the formatting there
                if( ep.CheckFlag( dwFound, BREAK_CONDITION_ExitPhrase ) )
                {
                    IFC( ep.Scan(RIGHT, dwSearch | BREAK_CONDITION_EnterPhrase ) );
                    IFC( GetDisplayServices()->GetComputedStyle(ep, &_spComputedStyle) );

                    V_VT(pvarargOut) = VT_I4;
                    V_I4(pvarargOut) = 1;
                }
                    
            }
        }
        else
        {
            if( psl->IsSpringLoaded() )
            {
                // Springloader overrides composesettings.
                psl->OverrideComposeSettings(TRUE);

                // Success
                V_VT(pvarargOut) = VT_I4;
                V_I4(pvarargOut) = 1;
            }
        }
    }
    else if (psl->IsSpringLoaded() && psl->OverrideComposeSettings())
    {
        cmdId = V_I4(pvarargIn);

        switch (cmdId)
        {
            case IDM_BOLD:
            case IDM_ITALIC:
            case IDM_UNDERLINE:
            case IDM_SUPERSCRIPT:
            case IDM_SUBSCRIPT:
            {
                OLECMD cmd;
                IFC( psl->PrivateQueryStatus(cmdId, &cmd) );
                V_I4(pvarargOut) = cmd.cmdf == MSOCMDSTATE_DOWN;
                break;
            }

            case IDM_FONTSIZE:
            case IDM_FONTNAME:
            case IDM_FORECOLOR:
            case IDM_BACKCOLOR:
                IFC( psl->PrivateExec(cmdId, NULL, pvarargOut, NULL) );
                break;
        }
    }
    else
    {
        cmdId = V_I4(pvarargIn);

        switch (cmdId)
        {
            case IDM_BOLD:
            case IDM_ITALIC:
            case IDM_UNDERLINE:
            case IDM_SUPERSCRIPT:
            case IDM_SUBSCRIPT:
            case IDM_FORECOLOR:
            case IDM_BACKCOLOR:
            case IDM_INSERTSPAN:
                AssertSz( FALSE, "CComposeSettings::QueryComposeSettings: Invalid QUERY");
                break;

               
            case IDM_FONTSIZE:
            {
                LONG lFontSize;
                
                V_VT(pvarargOut) = VT_I4;
                IFC( _spComputedStyle->get_fontSize(&lFontSize) );
                V_I4(pvarargOut) = EdUtil::ConvertTwipsToHtmlSize(lFontSize);
                break;
            }

            case IDM_FONTNAME:
            {
                TCHAR szFont[LF_FACESIZE+1];
                
                V_VT(pvarargOut) = VT_BSTR;
                IFC( _spComputedStyle->get_fontName((TCHAR *)&szFont) );
                V_BSTR(pvarargOut) = SysAllocString(szFont);
                if (V_BSTR(pvarargOut) == NULL)
                    hr = E_OUTOFMEMORY;

                break;
            }
        }

    }

Cleanup:

    // Don't return failure, renderer will use default font size
    hr = S_OK;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    if (pCmd)
        pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::Init (static)
//
//-------------------------------------------------------------------------

HRESULT
CComposeSettingsCommand::Init()
{
    HRESULT hr;

    hr = HrInitializeCriticalSection(&s_csLastComposeSettings);
    if (hr)
        goto Cleanup;

    s_fCSInited = TRUE;
    s_bstrLastComposeSettings = NULL;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function: CComposeSettingsCommand::Deinit (static)
//
//-------------------------------------------------------------------------

void
CComposeSettingsCommand::Deinit()
{
    if (s_bstrLastComposeSettings)
        SysFreeString(s_bstrLastComposeSettings);

    s_bstrLastComposeSettings = NULL;

    if (s_fCSInited)
    {
        DeleteCriticalSection(&s_csLastComposeSettings);
        s_fCSInited = FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Function: COverwriteCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
COverwriteCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    if (pCmd)
    {
        if (!GetEditor()->GetSelectionManager()->IsContextEditable())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
        }
        else
        {        
            pCmd->cmdf = (GetEditor()->GetSelectionManager()->GetOverwriteMode()) 
                                          ? MSOCMDSTATE_DOWN
                                          : MSOCMDSTATE_UP;
        }
    }

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function: COverwriteCommand::PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
COverwriteCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT             hr                 = S_OK;
    CSelectionManager   *pSelectionManager = GetEditor()->GetSelectionManager();
    CVariant            var;

    if (pvarargOut && V_VT(pvarargOut) == VT_BOOL)
    {
        // Output param is specified, return current stat of overwrite flag and bool
        V_BOOL(pvarargOut) = (pSelectionManager->GetOverwriteMode())
                ? VB_TRUE
                : VB_FALSE;
    }
    else
    {
        if (!pSelectionManager->IsContextEditable())
        {
            hr = MSOCMDERR_E_DISABLED;
            goto Cleanup;
        }

        if (pvarargIn)
        {

            // Try to convert the argument to boolean
            IFC( VariantChangeType(&var, pvarargIn, 0, VT_BOOL) );
            if (hr == S_OK)
            {
                pSelectionManager->SetOverwriteMode(V_BOOL(&var) == VB_TRUE);
            }
            else 
            {                
                pSelectionManager->SetOverwriteMode(FALSE);
                hr = S_OK;
            }
        }
        else
        {
            // No input argument was specified, toggle the overwrite flag
            pSelectionManager->SetOverwriteMode(!pSelectionManager->GetOverwriteMode());
        }

    }

Cleanup:
    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function: CAutoDetectCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------

HRESULT
CAutoDetectCommand::PrivateQueryStatus( 
        OLECMD * pCmd,
        OLECMDTEXT * pcmdtext )

{
    pCmd->cmdf = MSOCMDSTATE_UP;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function: CAutoDetectCommand::PrivateExec
//
//-------------------------------------------------------------------------

HRESULT
CAutoDetectCommand::PrivateExec( 
    DWORD               nCmdexecopt,
    VARIANTARG *        pvarargIn,
    VARIANTARG *        pvarargOut )
{
    HRESULT                 hr;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->CreateIterator(&spIter ) );
    
    IFC( GetEditor()->CreateMarkupPointer( & spStart ) );
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ) );

    while( spIter->IsDone() == S_FALSE )
    {
        IFC( spIter->Current(&spSegment ) );
        IFC( spSegment->GetPointers( spStart, spEnd ) );

        IFC( GetEditor()->GetAutoUrlDetector()->DetectRange( spStart, spEnd, FALSE ) );

        IFC( spIter->Advance() );
    }


Cleanup:
    RRETURN(hr);

}

//+------------------------------------------------------------------------
//
//  Function: CLocalizeEditorCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CLocalizeEditorCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CLocalizeEditorCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT     hr;
    HINSTANCE   hinst;

    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    if (V_BOOL(pvarargIn))
    {
        // Use localized resource dll
        IFR( GetEditResourceLibrary(&hinst) );    
        CGetBlockFmtCommand::LoadDisplayNames(hinst);
    }
    else
    {
        // Use local english version
        CGetBlockFmtCommand::LoadDisplayNames(g_hInstance);
    }
    
    return S_OK;    
}

//+------------------------------------------------------------------------
//
//  Function: CAutoUrlDetectModeCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CAutoUrlDetectModeCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CAutoUrlDetectModeCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    Assert(GetEditor()->GetAutoUrlDetector());
    GetEditor()->GetAutoUrlDetector()->SetEnabled(V_BOOL(pvarargIn));
    
    return S_OK;    
}


//+------------------------------------------------------------------------
//
//  Function: CIE50PasteModeCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CIE50PasteModeCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    


HRESULT 
CIE50PasteModeCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    GetEditor()->SetIE50PasteMode(V_BOOL(pvarargIn));
    
    return S_OK;    
}


//+------------------------------------------------------------------------
//
//  Function: CEditingCssLevelCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CCssEditingLevelCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}    

//+------------------------------------------------------------------------
//
//  Function: CEditingCssLevelCommand::PrivateExec
//
//  Synopsis: What kind of css can we generate?
//              0 - none
//              1 - must be down level 
//              2 - rich css editing
//
//-------------------------------------------------------------------------

HRESULT 
CCssEditingLevelCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT hr = S_OK;
    VARIANT varLevel;

    VariantInit(&varLevel);

    if (pvarargOut != NULL)
    {
        V_VT(pvarargOut) = VT_I4;
        V_I4(pvarargOut) = GetEditor()->GetCssEditingLevel();
        goto Cleanup;
    }

    if (pvarargIn == NULL)
        return E_INVALIDARG;

    IFC( VariantChangeTypeSpecial(&varLevel, pvarargIn, VT_I4) );
    switch (V_I4(&varLevel))
    {
        case 0:
        case 1:
            GetEditor()->SetCssEditingLevel(V_I4(&varLevel));
            break;

        case 2:
            hr = E_NOTIMPL;
            break;

        default:
            hr = E_INVALIDARG;
            break;                    
    }

Cleanup:
    VariantClear(&varLevel);    
    RRETURN(hr);    
}


//+------------------------------------------------------------------------
//
//  Function: CIMEReconversionCommand::PrivateQueryStatus
//
//-------------------------------------------------------------------------
HRESULT
CIMEReconversionCommand::PrivateQueryStatus(
    OLECMD * pCmd,
    OLECMDTEXT * pcmdtext )
{
    if (!pCmd)
        return E_INVALIDARG;

    pCmd->cmdf = GetEditor()->IsIMEReconversionEnabled() ? MSOCMDSTATE_UP : MSOCMDSTATE_DOWN;

    return S_OK;
}    


HRESULT 
CIMEReconversionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,     
    VARIANTARG * pvarargOut     
    )
{
    if (pvarargIn == NULL || V_VT(pvarargIn) != VT_BOOL)
        return E_INVALIDARG;

    GetEditor()->EnableIMEReconversion(V_BOOL(pvarargIn));
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\pastecmd.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998, 1999
//
//  File:       PASTECMD.CXX
//
//  Contents:   Implementation of Paste command.
//
//  History:    07-14-98 - raminh - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_PASTECMD_HXX_
#define _X_PASTECMD_HXX_
#include "pastecmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_SLOAD_HXX_
#define X_SLOAD_HXX_
#include "sload.hxx"
#endif

#ifndef X_IME_HXX_
#define X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_BLOCKCMD_HXX_
#define X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

using namespace EdUtil;

ExternTag(tagIE50Paste);

extern LONG edNlstrlenW(LPWSTR pstrIn, LONG cchLimit );

//
// Externs
//

MtDefine(CPasteCommand, EditCommand, "CPasteCommand");
MtDefine(CPasteCharFormatManager_aryCommands_pv, Locals, "PasteCharFormatManager_aryCommands_pv")
MtDefine(CPasteCharFormatManager_formatMap_pv, Locals, "PasteCharFormatManager_formatMap_pv")

//+---------------------------------------------------------------------------
//
//  Member:     ScanForText, helper function
//
//  Synopsis:   Scan right for CONTEXT_TYPE_Text while remaining left of pLimit
//
//  Arguments:  [pPointer] - pointer used for scan
//              [pLimit]   - right limit
//              [pCch]     - pCch for IMarkupPointer::Right
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ScanForText(IMarkupPointer *pPointer, IMarkupPointer *pLimit, LONG *pCch, IMarkupPointer *pLastBlockPointer = NULL)
{
    HRESULT             hr;
    MARKUP_CONTEXT_TYPE context;
    BOOL                fNotFound;
    LONG                cch;
    LONG                cchGoal = pCch ? *pCch : -1;
    SP_IHTMLElement     spElement;
    BOOL                fBlock, fLayout;
    
    for (;;)
    {
        cch = cchGoal;
        IFC( pPointer->Right(TRUE, &context, &spElement, &cch, NULL) );        

        switch (context)
        {
            case CONTEXT_TYPE_None:
                hr = S_FALSE; // not found
                goto Cleanup;

            case CONTEXT_TYPE_Text:
                if (pCch)
                    *pCch = cch;
                    
                goto Cleanup; // found

            case CONTEXT_TYPE_EnterScope:                
            case CONTEXT_TYPE_ExitScope:                
                if (pLastBlockPointer)
                {
                    IFC( IsBlockOrLayoutOrScrollable(spElement, &fBlock, &fLayout) );
                    if (fBlock || fLayout)
                    {
                        IFC( pLastBlockPointer->MoveToPointer(pPointer) );
                    }
                }
                break;
        }

        if (pLimit)
        {
            IFC( pPointer->IsRightOfOrEqualTo(pLimit, &fNotFound) );
            if (fNotFound)
            {
                hr = S_FALSE; // not found
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Struct:     CFormatMapInfo 
//
//  Synopsis:   Stores formatting at a particular position in a markup
//
//-----------------------------------------------------------------------------

struct CFormatMapInfo
{
    SP_IHTMLComputedStyle   _spComputedStyle;
    SP_IHTMLComputedStyle   _spBlockComputedStyle;
    LONG                    _cchNext;   // Number of characters to the next CFormatMapInfo
};

//+----------------------------------------------------------------------------
//
//  Class:      CFormatMap
//
//  Synopsis:   Array of CFormatMapInfo's
//
//-----------------------------------------------------------------------------

class CFormatMap : public CDataAry<CFormatMapInfo> 
{
public:
    CFormatMap(PERFMETERTAG mt) : CDataAry<CFormatMapInfo> (mt) 
        {}
        
    CFormatMapInfo *Item(INT i) 
        {return &CDataAry<CFormatMapInfo>::Item(i);}
};

//+----------------------------------------------------------------------------
//
//  Class:      CFormatMapPointer
//
//  Synopsis:   Format map pointer used to move through format map.
//
//-----------------------------------------------------------------------------

class CFormatMapPointer
{
public:
    CFormatMapPointer(CFormatMap *_pFormatMap);

    HRESULT Right(LONG *pCch);
    HRESULT Left(LONG *pCch);

    IHTMLComputedStyle *GetComputedStyle();
    IHTMLComputedStyle *GetBlockComputedStyle();

private:
    INT         _iCurrentFormat; // Index of current CFormatMapInfo
    INT         _icch;           // Character offset into a CFormatMapInfo
    CFormatMap  *_pFormatMap;    // Pointer to the format map
};

//+----------------------------------------------------------------------------
//
//  Class:      CPasteCharFormatManager
//
//  Synopsis:   Preserves character formatting on paste
//
//-----------------------------------------------------------------------------

class CPasteCharFormatManager
{
public:
    CPasteCharFormatManager(CHTMLEditor *pEd);
    ~CPasteCharFormatManager();

    // Remembers formatting in source range
    HRESULT ComputeFormatMap(        
        IMarkupPointer  *pSourceStart, 
        IMarkupPointer  *pSourceFinish);

    // Applies formatting to target
    HRESULT FixupFormatting(
        IMarkupPointer      *pTarget,
        BOOL                 fFixupOrderedList,
        BOOL                 fForceFixup);

private:
    HRESULT ScanForTextStart(IMarkupPointer *pPointer, IMarkupPointer *pLastBlockPointer);
    HRESULT SyncScanForTextEnd(CFormatMapPointer *pSource, IMarkupPointer *pTarget);

public:
    // Used to defer application of commands
    struct CCommandParams
    {
        DWORD             _cmdId;
        IMarkupPointer    *_pStart;
        IMarkupPointer    *_pEnd;
        VARIANT           _varValue;        
    };
    
private:
    CHTMLEditor          *_pEd;      // Editor
    SP_IHTMLTxtRange      _spRange;   // Used to exec commands

    enum FormatType
    {
        FT_Bold,
        FT_Italic,
        FT_Underline,
        FT_Superscript,
        FT_Subscript,
        FT_Strikethrough,
        FT_ForeColor,
        FT_BackColor,
        FT_FontFace,
        FT_FontName,
        FT_FontSize,
        FT_OrderedList,
        FT_NumFormatTypes
    };

    struct
    {
        IMarkupPointer *_pStart;
        VARIANT        _varValue;
    } 
    _rgFixupTable[FT_NumFormatTypes];       // Used to manage fixup ranges

    CDataAry<CCommandParams> _aryCommands;  // Deferred commands
    CFormatMap               _formatMap;    // Source formatting

    IMarkupServices  *GetMarkupServices()  {return _pEd->GetMarkupServices();}
    IDisplayServices *GetDisplayServices() {return _pEd->GetDisplayServices();}
    IHTMLDocument2   *GetDoc()             {return _pEd->GetDoc();}
private:
    HRESULT InitFixupTable();

    HRESULT FixupPosition(
        CFormatMapPointer       *pSource,
        IMarkupPointer          *pTarget,
        IMarkupPointer          *pTargetBlock,
        BOOL                    fFixupOrderedList,
        BOOL                    fForceFixup);

    HRESULT FinishFixup(IMarkupPointer *pTarget, BOOL fFixupOrderedList);

    HRESULT RegisterCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn);
    HRESULT FireCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn);
    HRESULT FireRegisteredCommands();
    HRESULT FixupBoolCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual);
    HRESULT FixupVariantCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual, VARIANT *pvarargIn);
};


//+----------------------------------------------------------------------------
//
//  Functions:  ShouldFixupFormatting
//
//  Synopsis:   Given char and block format for source and target, should we 
//              fixup formatting.
//
//-----------------------------------------------------------------------------

template <class T> BOOL 
ShouldFixupFormatting( T& charFormatSource, T& blockFormatSource, T& charFormatTarget, T& blockFormatTarget, BOOL fForceFixup)
{
    if (charFormatSource == charFormatTarget)
        return FALSE;

    if (blockFormatTarget == blockFormatSource || fForceFixup)
        return TRUE;

    //
    // blockFormatTarget != blockFormatSource
    //

    return (charFormatSource != blockFormatSource);        
}

//+----------------------------------------------------------------------------
//
//  Functions:  ShouldFixupFormatting
//
//  Synopsis:   Given char and block format for source and target, should we 
//              fixup formatting.
//
//-----------------------------------------------------------------------------

BOOL 
ShouldFixupFormatting(
    TCHAR *szCharFormatSource, 
    TCHAR *szBlockFormatSource, 
    TCHAR *szCharFormatTarget, 
    TCHAR *szBlockFormatTarget,
    BOOL   fForceFixup)
{
    //
    // For perf reasons, the caller does this initial check
    //
    
#if 0
    if (_tcscmp(szCharFormatSource, szBlockFormatSource) == 0)
        return FALSE;
#endif

    //
    // Compute block format info
    //

    if (_tcscmp(szBlockFormatTarget, szBlockFormatSource) == 0 || fForceFixup)
        return TRUE;

    //
    // blockFormatTarget != blockFormatSource
    //

    return (_tcscmp(szCharFormatSource, szBlockFormatSource) != 0);      
}

//+----------------------------------------------------------------------------
//
//  Functions:  Equal & Compare
//
//  Synopsis:   Helpers for comparing IMarkupPointers
//
//-----------------------------------------------------------------------------

static inline BOOL
IsEqualTo ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    BOOL fEqual;
    IGNORE_HR( p1->IsEqualTo( p2, & fEqual ) );
    return fEqual;
}

static inline int
Compare ( IMarkupPointer * p1, IMarkupPointer * p2 )
{
    int result;
    IGNORE_HR( OldCompare( p1, p2, & result ) );
    return result;
}

//+---------------------------------------------------------------------------
//
//  CPasteCommand::Paste
//
//----------------------------------------------------------------------------

enum FETCINDEX                          // Keep in sync with g_rgFETC[]
{
    iHTML,                              // HTML (in ANSI)
    iRtfFETC,                           // RTF
#ifndef WIN16
    iUnicodeFETC,                       // Unicode plain text
#endif // !WIN16
    iAnsiFETC,                          // ANSI plain text
//    iFilename,                          // Filename
    iRtfAsTextFETC,                     // Pastes RTF as text
    iFileDescA,                         // FileGroupDescriptor
    iFileDescW,                         // FileGroupDescriptorW
    iFileContents                       // FileContents
};

FORMATETC *
GetFETCs ( int * pnFETC )
{
    static int fInitted = FALSE;

    static FORMATETC rgFETC[] =
    {
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_HTML
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTF
    #ifndef WIN16
        { CF_UNICODETEXT,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    #endif
        { CF_TEXT,           NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_RTFASTEXT
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORA
        { 0,                 NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL}, // CF_FILEDESCRIPTORW
        { 0,                 NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL}, // CF_FILECONTENTS
    };

    if (!fInitted)
    {
        fInitted = TRUE;

        Assert( ! rgFETC [ iHTML          ].cfFormat );
        Assert( ! rgFETC [ iRtfFETC       ].cfFormat );
        Assert( ! rgFETC [ iRtfAsTextFETC ].cfFormat );
        Assert( ! rgFETC [ iFileDescA     ].cfFormat );
        Assert( ! rgFETC [ iFileContents  ].cfFormat );

        rgFETC [ iHTML          ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "HTML Format" );
        rgFETC [ iRtfFETC       ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "Rich Text Format" );
        rgFETC [ iRtfAsTextFETC ].cfFormat = (CLIPFORMAT)RegisterClipboardFormatA( "RTF As Text" );
        rgFETC [ iFileDescW     ].cfFormat = (CLIPFORMAT)RegisterClipboardFormat ( CFSTR_FILEDESCRIPTORW );
        rgFETC [ iFileContents  ].cfFormat = (CLIPFORMAT)RegisterClipboardFormat ( CFSTR_FILECONTENTS );
    }

    if (pnFETC)
        *pnFETC= ARRAY_SIZE( rgFETC );

    return rgFETC;
}

extern HGLOBAL TextHGlobalAtoW( HGLOBAL hglobalA );

HRESULT 
CPasteCommand::Paste (
    IMarkupPointer* pStart, IMarkupPointer* pEnd, CSpringLoader * psl, BSTR bstrText /* = NULL */)
{
    HRESULT           hr;
    IMarkupServices * pMarkupServices = GetMarkupServices();
    BOOL              fResult;
    
    //
    // Delete the range first
    //
    IFC( pMarkupServices->Remove( pStart, pEnd ) );

    //
    // If there is nothing to paste we're done
    //
    if (bstrText == NULL || *bstrText == 0)
    {
        return S_OK;
    }

    //
    // InsertSanitized text checks whether we accept html or not
    // and handles CR LF characters appropriately
    //
    IFC( GetEditor()->InsertSanitizedText( bstrText, SysStringLen(bstrText), pStart, pMarkupServices, psl, FALSE ) );

    // Call the url autodetector

    IFC( pStart->IsRightOf(pEnd, &fResult) );

    if (fResult)
    {
        IFC( AutoUrlDetect(pEnd, pStart) );
    }
    else
    {    
        IFC( AutoUrlDetect(pStart, pEnd) );
    }

    // Collapse the range
    IFC( pStart->IsRightOf( pEnd, & fResult ) );
    if ( fResult )
    {
        IFC( pEnd->MoveToPointer( pStart ) );
    }
    else
    {
        IFC( pStart->MoveToPointer( pEnd ) );
    }

Cleanup:
    RRETURN( hr );
}


#ifdef MERGEFUN
//TODO: this function came from the old LDTE code
//
//+----------------------------------------------------------------------------
//
//  Member:     FilterReservedChars
//
//  Synopsis:   Replaces any characters within our reserved unicode range
//              with question marks.
//
//-----------------------------------------------------------------------------


static void
FilterReservedChars( TCHAR * pStrText )
{
    while (*pStrText)
    {
        if (!IsValidWideChar(*pStrText))
        {
            *pStrText = _T('?');
        }
        pStrText++;
    }
}
#endif

HRESULT 
CPasteCommand::PasteFromClipboard (
                    IMarkupPointer *  pPasteStart, 
                    IMarkupPointer *  pPasteEnd, 
                    IDataObject *     pDataObject,
                    CSpringLoader *   psl,
                    BOOL              fForceIE50Compat,
                    BOOL              fClipboardDone)
{
    CHTMLEditor * pEditor = GetEditor();
    IDataObject * pdoFromClipboard = NULL;
    CLIPFORMAT  cf = 0;
    HGLOBAL     hglobal = NULL;
    HRESULT     hr = DV_E_FORMATETC;
    HRESULT     hr2 = S_OK;
    HGLOBAL     hUnicode = NULL;
    int         i;
    int         nFETC;
    STGMEDIUM   medium = {0, NULL};
    FORMATETC * pfetc;
    LPTSTR      ptext = NULL;
    LONG        cCh   = 0;
    IHTMLElement        *   pElement = NULL;
    IHTMLElement        *   pFlowElement = NULL;
    VARIANT_BOOL            fAcceptsHTML;
    LPSTR                   pszRtf;
    IMarkupServices     *   pMarkupServices = pEditor->GetMarkupServices();
    IMarkupPointer      *   pRangeStart   = NULL;
    IMarkupPointer      *   pRangeEnd     = NULL;
    IDataObject         *   pdoFiltered = NULL;
    IDocHostUIHandler   *   pHostUIHandler = NULL;
    SP_IServiceProvider     spSP;
    SP_IHTMLElement3        spElement3;
    BOOL                    fIgnoreGlyphs = GetEditor()->IgnoreGlyphs(TRUE);

    //
    // Set up a pair of pointers for URL Autodetection after the insert
    //
    IFC( GetEditor()->CreateMarkupPointer( &pRangeStart ) );
    IFC( pRangeStart->MoveToPointer( pPasteStart ) );
    IFC( pRangeStart->SetGravity( POINTER_GRAVITY_Left ) );        

    IFC( GetEditor()->CreateMarkupPointer( &pRangeEnd ) );
    IFC( pRangeEnd->MoveToPointer( pPasteStart ) );
    IFC( pRangeEnd->SetGravity( POINTER_GRAVITY_Right ) );

    pfetc = GetFETCs ( & nFETC );

    Assert( pfetc );

    if (!pDataObject)
    {
        hr2 = OleGetClipboard( & pdoFromClipboard );
        
        if (hr2 != NOERROR)
        {
            hr = hr2;
            goto Cleanup;
        }

        Assert( pdoFromClipboard );

        //
        // See if the host handler wants to give us a massaged data object.
        //
        
        IFC(GetDoc()->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP));
        spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)&pHostUIHandler);

        pDataObject = pdoFromClipboard;
        
        if (pHostUIHandler)
        {
            //
            // The host may want to massage the data object to block/add
            // certain formats.
            //
            
            hr = THR( pHostUIHandler->FilterDataObject( pDataObject, & pdoFiltered ) );
            
            if (!hr && pdoFiltered)
            {
                pDataObject = pdoFiltered;
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    if ( pPasteEnd )
    {
        IFC( pMarkupServices->Remove( pPasteStart, pPasteEnd ) );
    }

    if (fClipboardDone)
        goto Cleanup;
        
    //
    // Check if we accept HTML
    //
    IFC( GetEditor()->GetFlowElement(pPasteStart, & pFlowElement) );

    if (! pFlowElement)
    {
        //
        // Elements that do not accept HTML, e.g. TextArea, always have a flow layout.
        // If the element does not have a flow layout then it might have been created
        // using the DOM (see bug 42685). Set fAcceptsHTML to true.
        //
        fAcceptsHTML = TRUE;
    }
    else
    {
        IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
        IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    }
    
    for( i = 0; i < nFETC; i++, pfetc++ )
    {
        // make sure the format is either 1.) a plain text format
        // if we are in plain text mode or 2.) a rich text format
        // or 3.) matches the requested format.

        if( cf && cf != pfetc->cfFormat )
        {
            continue;
        }

        //
        // If we don't accept HTML and i does not correspond to text format
        // skip it
        //
#ifndef WIN16
        if ( fAcceptsHTML || i == iAnsiFETC || i == iUnicodeFETC )
#else
        if ( fAcceptsHTML || i == iAnsiFETC )                        
#endif // !WIN16
        {
            //
            // make sure the format is available
            //
            if( pDataObject->QueryGetData(pfetc) != NOERROR )
            {
                continue;
            }

            //
            // If we have one of the formats that uses an hglobal get it
            // and lock it.
            //
            if (
#ifndef NO_RTF
                i == iRtfAsTextFETC ||  i == iRtfFETC ||
#endif
                i == iAnsiFETC ||
#ifndef WIN16
                i == iUnicodeFETC ||
#endif // !WIN16
                i == iHTML )
            {
                if( pDataObject->GetData(pfetc, &medium) == NOERROR )
                {
                    Assert(medium.tymed == TYMED_HGLOBAL);

                    hglobal = medium.hGlobal;
                    ptext = (LPTSTR)GlobalLock(hglobal);
                    if( !ptext )
                    {
                        ReleaseStgMedium(&medium);
                        return E_OUTOFMEMORY;
                    }
                }
                else
                {
                    continue;
                }
            }

            switch(i)
            {
            case iHTML:
            {
                if (fForceIE50Compat || GetEditor()->IsIE50CompatiblePasteMode())
                {
                    IFC( GetEditor()->DoTheDarnIE50PasteHTML(pPasteStart, pPasteEnd, hglobal) );
                }
                else
                {
                    IFC( HandleUIPasteHTML(pPasteStart, pPasteEnd, hglobal) );
                }

                goto Cleanup;
            }
            case iRtfFETC:
            {
                BOOL fEnabled = IsRtfConverterEnabled(pHostUIHandler);
                if (!fEnabled)
                    continue;
                
                pszRtf = LPSTR( GlobalLock( hglobal ) );

                if(!pszRtf)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                hr = THR(GetEditor()->ConvertRTFToHTML((LPOLESTR)pszRtf, &hglobal));


                if (!hr)
                {
                    //
                    // RTF conversion worked
                    //

                    if (fForceIE50Compat || GetEditor()->IsIE50CompatiblePasteMode())
                    {
                        IFC( GetEditor()->DoTheDarnIE50PasteHTML(pPasteStart, pPasteEnd, hglobal) );
                    }
                    else
                    {
                        IFC( HandleUIPasteHTML(pPasteStart, pPasteEnd, hglobal) );
                    }

                }
                else
                {
                    // RTF conversion failed, try the next format
                    hr = DV_E_FORMATETC;
                    continue;
                }

                goto Cleanup;
            }

            case iRtfAsTextFETC:
            case iAnsiFETC:         // ANSI plain text. If data can be stored

                hUnicode = TextHGlobalAtoW(hglobal);

                if (hUnicode)
                {
                    ptext = (LPTSTR)GlobalLock(hUnicode);
                    if(!ptext)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    //FilterReservedChars(ptext);


                    //
                    // Review-2000/07/25-zhenbinx: 
                    //
                    // We still expect ptext to be NULL terminated!!! GlobalSize does not really return the exact 
                    // bytes allocated. Here we just want to make sure the strlen code does not step over other's 
                    // memory space in case ptext is not NULL terminated.   (zhenbinx)
                    //
                    cCh = edNlstrlenW(ptext, GlobalSize(hUnicode)/sizeof(WCHAR));
                    hr = THR( GetEditor()->InsertSanitizedText( ptext, cCh, pPasteStart, pMarkupServices, psl, FALSE ) );
                    
                    IGNORE_HR( AutoUrlDetect(pRangeStart, pRangeEnd) );
                    
                    GlobalUnlock(hUnicode);
                }

                goto Cleanup;

            case iUnicodeFETC:                          // Unicode plain text

                ptext   = (LPTSTR)GlobalLock(hglobal);
                if(!ptext)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                //FilterReservedChars(ptext);

                //
                // Review-2000/07/25-zhenbinx: 
                //      Better be NULL terminated! Otherwise we might insert
                //      extra text since GlobalSize could be aligned to some
                //      memory boundary. 
                //
                cCh= edNlstrlenW(ptext, GlobalSize(hglobal)/sizeof(WCHAR));
                hr = THR( GetEditor()->InsertSanitizedText( ptext, cCh, pPasteStart, pMarkupServices, psl, FALSE ) );

                IGNORE_HR( AutoUrlDetect(pRangeStart, pRangeEnd) );

                goto Cleanup;
            }

            //Break out of the for loop
            break;
        }
    }

Cleanup:
    GetEditor()->IgnoreGlyphs(fIgnoreGlyphs);

    ReleaseInterface( pRangeStart );
    ReleaseInterface( pRangeEnd );

    ReleaseInterface( pElement );
    ReleaseInterface( pFlowElement );

    ReleaseInterface( pdoFiltered );
    ReleaseInterface( pHostUIHandler );

    ReleaseInterface( pdoFromClipboard );

    if (hUnicode)
    {
        GlobalFree(hUnicode);
    }

    //If we used the hglobal unlock it and free it.
    if(hglobal)
    {
        GlobalUnlock(hglobal);
        ReleaseStgMedium(&medium);
    }

    return hr;
}


HRESULT
CPasteCommand::InsertText(OLECHAR         * pchText,
                          long              cch,
                          IMarkupPointer  * pPointerTarget,
                          CSpringLoader   * psl)
{
    // Fire the spring loader.
    if (psl)
    {
        Assert(pPointerTarget);

        IGNORE_HR(psl->Fire(pPointerTarget));
    }

    RRETURN( THR( GetEditor()->InsertMaximumText( pchText, cch, pPointerTarget ) ) );
}


//+---------------------------------------------------------------------------
//
//  CPasteCommand::Exec
//
//----------------------------------------------------------------------------

HRESULT
CPasteCommand::PrivateExec( 
                    DWORD nCmdexecopt,
                    VARIANTARG * pvarargIn,
                    VARIANTARG * pvarargOut )
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_ISegmentListIterator spIter;
    SP_ISegmentList         spSegmentList;
    SP_ISegment             spSegment;
    SELECTION_TYPE          eSelectionType;
    BOOL                    fRet;
    VARIANT_BOOL            fRetVal;
    CHTMLEditor             *pEditor = GetEditor();
    CEdUndoHelper           undoUnit(pEditor);
    BOOL                    fEmpty = FALSE;
    int                     iCount = 0;
    
    ((IHTMLEditor *) pEditor)->AddRef();    // FireOnCancelableEvent can remove the whole doc

    if (IsSelectionActive())
        return S_OK; // don't paste into an active selection

    if( GetEditor()->GetSelectionManager()->IsIMEComposition() )
        IFC( GetEditor()->GetSelectionManager()->TerminateIMEComposition(TERMINATE_NORMAL) );

    //
    // Get the segment etc., let's get busy
    //
    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    IFC (GetSegmentCount(spSegmentList, &iCount));

    // multiple selection and paste, will put the insertion point at the 
    // start of the body element
    if (eSelectionType == SELECTION_TYPE_Control && iCount > 1)
    {
        SP_IDisplayPointer spDispCtlTemp;
        SP_IMarkupPointer  spPointer ;
        SP_IHTMLElement    spElement ;
        
        IFC (GetEditor()->GetBody( &spElement ));
        IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
        IFC( spPointer->MoveAdjacentToElement( spElement,ELEM_ADJ_AfterBegin));
   
        IFC( pEditor->GetSelectionManager()->GetDisplayServices()->CreateDisplayPointer(&spDispCtlTemp) );
        IFC( spDispCtlTemp->MoveToMarkupPointer(spPointer, NULL) );       
        IFC( spDispCtlTemp->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        hr = THR( pEditor->GetSelectionManager()->SetCurrentTracker( TRACKER_TYPE_Caret, spDispCtlTemp, spDispCtlTemp ) );
    }
    
    IFC( GetEditor()->CreateMarkupPointer( &spStart ));
    IFC( GetEditor()->CreateMarkupPointer( &spEnd ));

    if ( fEmpty == FALSE )
    {       
        SP_IHTMLElement spElement;
        SP_IHTMLElement3 spElement3;
        BOOL fClipboardDone = FALSE ;

        IFC( undoUnit.Begin(IDS_EDUNDOPASTE) );

        IFC( spSegmentList->CreateIterator(&spIter ) );
                
        while( spIter->IsDone() == S_FALSE )
        {
            //
            // Continues all over this function means we have to advance our 
            // iterator at top
            //
            IFC( spIter->Current(&spSegment) );
            IFC( spIter->Advance() );

            IFC( spSegment->GetPointers( spStart, spEnd ));

            // Bug 103778: Make sure that spStart and spEnd are not in an atomic element.
            // Adjust out if necessary.
            IFC( AdjustPointersForAtomic(spStart, spEnd) );

            IFC( IsPastePossible( spStart, spEnd, & fRet ) );
            if (! fRet)
            {
                continue;
            }

            IFC( GetEditor()->FindCommonElement( spStart, spEnd, &spElement ));

            if (! spElement)
            {
                continue;
            }

            IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
            IFC(spElement3->fireEvent(_T("onpaste"), NULL, &fRetVal));
            
            if (! fRetVal)
            {
                continue;
            }

            //
            // Paste can cause re-entrancy which will invalidate the cmdtarget.  So, we must
            // must cache it and restore it.
            //

            if (pvarargIn && V_VT(pvarargIn) == VT_BSTR)
            {
                // Paste the passed in bstrText 
                IFC( Paste( spStart, spEnd, GetSpringLoader(), V_BSTR(pvarargIn) ) );
            }
            else
            {
                // Paste from the clipboard
                IFC( PasteFromClipboard( spStart, spEnd, NULL, GetSpringLoader(), 
                                         GetCommandTarget()->IsRange()/* fForceIE50Compat */,
                                         fClipboardDone));

                if (eSelectionType == SELECTION_TYPE_Control)
                      fClipboardDone = TRUE ;
            }

        }

        if ( ! GetCommandTarget()->IsRange() && 
             eSelectionType != SELECTION_TYPE_Control  ) // Control is handled in ExitTree
        {
            pEditor->GetSelectionManager()->EmptySelection();
        }


        if ( ! GetCommandTarget()->IsRange() )
        {
            //
            // Update selection - go to pStart since it has gravity Right
            //
            IGNORE_HR( spEnd->MoveToPointer( spStart ) );            
            pEditor->SelectRangeInternal( spStart, spEnd, SELECTION_TYPE_Caret,TRUE);

            CSelectionChangeCounter selCounter(GetEditor()->GetSelectionManager());
            selCounter.SelectionChanged();
        }
    }

Cleanup:   
    ReleaseInterface((IHTMLEditor *) pEditor);
    RRETURN ( hr );
}

//+----------------------------------------------------------------------------
//
//  Member:     CheckOnBeforePasteSecurity
//
//  Synopsis:   Since we fire OnBeforePaste synchronously, the script can
//              switch focus and cause the target of the paste to change.  
//              Make sure that the target never changes to a different
//              file upload input.
//
//  Arguments:  [pElementActiveBefore] - active element before we fired OnBeforePaste
//              [pElementActiveAfter]  - active element after we fired OnBeforePaste
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::CheckOnBeforePasteSecurity(
    IHTMLElement *pElementActiveBefore,
    IHTMLElement *pElementActiveAfter)
{
    HRESULT hr = S_OK;
    BSTR    bstrType = NULL;

    //
    // If the active element after OnBeforeFocus is a file upload input,
    // we could have a security violation if it is not the same element
    // we had before OnBeforeFocus was called.
    //

    if (pElementActiveAfter != NULL)
    {
        ELEMENT_TAG_ID tagId;

        // Check for file upload input 
        IFC(GetMarkupServices()->GetElementTagId(pElementActiveAfter, &tagId));
        if (tagId == TAGID_INPUT)
        {
            SP_IHTMLInputElement spInputElement;

            IFC(pElementActiveAfter->QueryInterface(IID_IHTMLInputElement, (void **)&spInputElement));
            IFC(spInputElement->get_type(&bstrType));

            if (bstrType && !StrCmpIC(bstrType, TEXT("file")))
            {
                SP_IObjectIdentity spIdent;

                // Fail security check if the previous active element was NULL
                if (pElementActiveBefore == NULL)
                {
                    hr = E_ACCESSDENIED;  // fail security check
                    goto Cleanup;
                }

                // Fail security check if the previous active element was different
                IFC(pElementActiveBefore->QueryInterface(IID_IObjectIdentity, (void **)&spIdent));
                if (spIdent->IsEqualObject(pElementActiveAfter) != S_OK)
                {
                    hr = E_ACCESSDENIED;
                    goto Cleanup;
                }
            }
        }
    }

Cleanup:
    SysFreeString(bstrType);
    RRETURN(hr);
}


HRESULT
CPasteCommand::PrivateQueryStatus( 
                        OLECMD * pCmd,
                        OLECMDTEXT * pcmdtext )
{
    HRESULT             hr = S_OK;
    SP_IMarkupPointer   spStart ;
    SP_IMarkupPointer   spEnd ;
    SP_IHTMLElement     spElement ;
    SP_ISegmentList     spSegmentList ;
    SP_IHTMLElement3    spElement3;
    SP_IHTMLElement     spElementActiveBefore;
    SP_IHTMLElement     spElementActiveAfter;
    SELECTION_TYPE      eSelectionType;
    VARIANT_BOOL        fEditable;
    VARIANT_BOOL        fRetVal;
    BOOL                fRet;
    BOOL                fEmpty;

    // Status is disabled by default
    pCmd->cmdf = MSOCMDSTATE_DISABLED;

    IFC( GetSegmentList( &spSegmentList ));
    IFC( spSegmentList->GetType( &eSelectionType ) );
    IFC( spSegmentList->IsEmpty( &fEmpty ) );
    if ( fEmpty ) 
        goto Cleanup;

    IFC( GetFirstSegmentPointers(spSegmentList, &spStart, &spEnd) );
    IFC( GetEditor()->FindCommonElement( spStart, spEnd, &spElement ) );
    if (! spElement)
        goto Cleanup;

    //
    // We are about the fire a sync event, so we can re-enter here and 
    // focus can be switched to another element like a file upload input.
    //
    // For security purposes, we need to check for the file upload input.
    // case.
    //
    
    IFC(GetDoc()->get_activeElement(&spElementActiveBefore));

    IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
    IFC(spElement3->fireEvent(_T("onbeforepaste"), NULL, &fRetVal));

    IFC(GetDoc()->get_activeElement(&spElementActiveAfter));

    if (CheckOnBeforePasteSecurity(spElementActiveBefore, spElementActiveAfter) != S_OK)
    {
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        goto Cleanup;
    }
    fRet = !!fRetVal;

    if (! fRet)
    {
        pCmd->cmdf = MSOCMDSTATE_UP;
        goto Cleanup;
    }

    if ( ! GetCommandTarget()->IsRange() && eSelectionType != SELECTION_TYPE_Control)
    {
        IFC(spElement3->get_isContentEditable(&fEditable));
        if (! fEditable)
            goto Cleanup;
    }

    if (!GetCommandTarget()->IsRange())
    {
        VARIANT_BOOL fDisabled;

        spElement = GetEditor()->GetSelectionManager()->GetEditableElement();
        
        IFC(spElement->QueryInterface(IID_IHTMLElement3, (void **)&spElement3));
        IFC(spElement3->get_isDisabled(&fDisabled));

        if (fDisabled)
            goto Cleanup;
    }

    IFC( IsPastePossible( spStart, spEnd, & fRet ) );
    if ( fRet )
    {
        pCmd->cmdf = MSOCMDSTATE_UP; // It's a GO
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CPasteCommand::IsPastePossible ( IMarkupPointer * pStart,
                                 IMarkupPointer * pEnd,
                                 BOOL * pfResult )
{    
    HRESULT         hr = S_OK;    
    IHTMLElement *  pFlowElement = NULL;
    VARIANT_BOOL    fAcceptsHTML;
    CLIPFORMAT      cf;
    int             nFETC = 0;
    FORMATETC *     pfetc;
    SP_IHTMLElement3 spElement3;

    Assert( pfResult );
    *pfResult = FALSE;

    //
    // Cannot paste unless the range is in the same flow layout
    //            
    if( !GetEditor()->PointersInSameFlowLayout( pStart, pEnd, & pFlowElement ) )
    {
        goto Cleanup;
    }

    if (! pFlowElement)
        goto Cleanup;

    pfetc = GetFETCs ( & nFETC );
    
    //
    // If we don't accept HTML and there is no text on clipboard, it's a no go
    //    
    IFC(pFlowElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC(spElement3->get_canHaveHTML(&fAcceptsHTML));
    if ( (! fAcceptsHTML) && 
         (! IsClipboardFormatAvailable( pfetc[iAnsiFETC].cfFormat ) ) )
    {
        goto Cleanup;
    }

    //
    // Make sure that the clipboard has data in it
    //
    while (nFETC--)                 
    {
        cf = pfetc[nFETC].cfFormat;
        if( IsClipboardFormatAvailable(cf) )
        {
            *pfResult = TRUE; // It's a GO
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseInterface( pFlowElement );
    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCommand::AutoUrlDetect
//
//  Synopsis:   Does a paste limited auto url detect.  See comments below.
//
//  Arguments:  [pUU] -- Unit to add
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT 
CPasteCommand::AutoUrlDetect(IMarkupPointer *pStart,
                             IMarkupPointer *pEnd)
{
    HRESULT             hr;
    SP_IHTMLElement     spElement;
    SP_IMarkupPointer   spLimit;
    BOOL                fResult;
    
    // In general, we want to limit autodetection to the next word immediately to the right
    // of the pasted text is not autodetected.  For example:
    //
    // {paste www.foo.com}other words
    //
    // products:
    //
    // <a>www.foo.com</a>other words
    //
    // However, if we are pasting inside an existing anchor, we don't want this limit to apply.
    //
    IFC( pStart->IsRightOf(pEnd, &fResult) );
    spLimit = fResult ? pStart : pEnd;

    IFC( spLimit->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        SP_IHTMLElement spAnchorElement;
        
        IFC( FindTagAbove( GetMarkupServices(), spElement, TAGID_A, &spAnchorElement) );        
        if (spAnchorElement != NULL)
        {
            spLimit = NULL; // ignore limit if inside anchor
        }
    }
    
    IFC( GetEditor()->GetAutoUrlDetector()->DetectRange( pStart, pEnd, TRUE, spLimit) );

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     SearchBranchToRootForTag
//
//  Synopsis:   Looks up the parent chain for the first element which
//              matches the tag.  No stopper element here, goes all the
//              way up to the <HTML> tag.
//
//-----------------------------------------------------------------------------

HRESULT 
CPasteCommand::SearchBranchToRootForTag (ELEMENT_TAG_ID tagIdDest, IHTMLElement *pElemStart, IHTMLElement **ppElement)
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    ELEMENT_TAG_ID  tagId;

    Assert(ppElement && pElemStart);
    *ppElement = NULL;

    ReplaceInterface(&pElemCurrent, pElemStart);
    do
    {        
        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );
        if (tagId == tagIdDest)
        {
            *ppElement = pElemCurrent;
            (*ppElement)->AddRef();
            goto Cleanup;
        }

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     HasContainer
//
//  Synopsis:   Searches the given branch for a container
////
//-----------------------------------------------------------------------------
BOOL
CPasteCommand::HasContainer(IHTMLElement *pElement)
{
    HRESULT         hr;
    BOOL            fResult = FALSE;
    IHTMLElement    *pElemCurrent = pElement;

    Assert(pElemCurrent);
    pElemCurrent->AddRef();
    
    do
    {
        if (GetEditor()->IsContainer(pElemCurrent))
        {
            fResult = TRUE;
            goto Cleanup;
        }
        
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );        
    }
    while (pElemCurrent);

Cleanup:
    ReleaseInterface(pElemCurrent);
    return fResult;
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceFragComments
//
//  Synopsis:   Remove the fragment begin and end comments which occur
//              in CF_HTML.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSourceFragComments(
    IMarkupPointer  *pSourceStart,
    IMarkupPointer  *pSourceFinish )
{
    HRESULT             hr = S_OK;
    IMarkupPointer      *pmp = NULL;
    IHTMLElement        *pElement = NULL;
    IHTMLCommentElement *pElemComment = NULL;
    MARKUP_CONTEXT_TYPE ct;
    BSTR                bstrCommentText = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pmp) );

    //
    // Remove the start frag comment
    //

    IFC( pmp->MoveToPointer(pSourceStart) );

    for (;;)
    {
        ClearInterface(&pElement);
        IFC( pmp->Left(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope)
        {
            ELEMENT_TAG_ID tagId;        

            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

            if (tagId == TAGID_COMMENT_RAW)
            {
                LONG lAtomic;
                
                ClearInterface(&pElemComment);
                IFC( pElement->QueryInterface(IID_IHTMLCommentElement, (LPVOID *)&pElemComment) );

                IFC( pElemComment->get_atomic(&lAtomic) );
                if (lAtomic)
                {
                    SysFreeString(bstrCommentText);
                    IFC( pElemComment->get_text(&bstrCommentText) );
                    if (!StrCmpIC( _T("<!--StartFragment-->"), bstrCommentText))
                    {
                        IFC( GetMarkupServices()->RemoveElement(pElement) );
                        break;
                    }
                }                
            }
        }
    }

    //
    // Remove the end frag comment
    //

    IFC( pmp->MoveToPointer( pSourceFinish ) );

    for ( ; ; )
    {
        ClearInterface(&pElement);
        IFC( pmp->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_None)
            break;

        if (ct == CONTEXT_TYPE_NoScope)
        {
            ELEMENT_TAG_ID tagId;        

            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );

            if (tagId == TAGID_COMMENT_RAW)
            {
                LONG lAtomic;
                
                ClearInterface(&pElemComment);
                IFC( pElement->QueryInterface(IID_IHTMLCommentElement, (LPVOID *)&pElemComment) );

                IFC( pElemComment->get_atomic(&lAtomic) );
                if (lAtomic)
                {
                    SysFreeString(bstrCommentText);
                    IFC( pElemComment->get_text(&bstrCommentText) );
                    if (!StrCmpIC( _T("<!--EndFragment-->"), bstrCommentText))
                    {
                        IFC( GetMarkupServices()->RemoveElement(pElement) );
                        break;
                    }
                }                
            }
        }
    }

Cleanup:
    ReleaseInterface(pmp);
    ReleaseInterface(pElement);
    ReleaseInterface(pElemComment);
    SysFreeString(bstrCommentText);

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceTables
//
//  Synopsis:   Makes sure that whole (not parts of) tables are included in
//              the source of a paste.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSourceTables (
    IMarkupPointer  *pSourceStart,
    IMarkupPointer  *pSourceFinish )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemTable = NULL;
    IHTMLElement    *pElement = NULL;
    IMarkupPointer  *pPointer;

    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    
    //
    // Here we make sure there are no stranded tables in the source
    //

    Assert( Compare(pSourceStart, pSourceFinish) <= 0 );

    for ( pPointer->MoveToPointer(pSourceStart) ;
          Compare(pPointer, pSourceFinish) < 0 ; )
    {
        MARKUP_CONTEXT_TYPE ct;

        ClearInterface(&pElement);
        IFC( pPointer->Right(TRUE, &ct, &pElement, NULL, NULL) );

        if (ct == CONTEXT_TYPE_EnterScope)
        {
            ELEMENT_TAG_ID tagId;
            
            IFC( GetMarkupServices()->GetElementTagId(pElement, &tagId) );
            switch (tagId)
            {
            case TAGID_TC : case TAGID_TD : case TAGID_TR : case TAGID_TBODY :
            case TAGID_THEAD : case TAGID_TFOOT : case TAGID_TH : case TAGID_TABLE :
            case TAGID_CAPTION: case TAGID_COL: case TAGID_COLGROUP:
                {
                    ClearInterface(&pElemTable);
                    IFC( SearchBranchToRootForTag(TAGID_TABLE, pElement, &pElemTable) );

                    if (pElemTable)
                    {
                        BOOL fResult;

                        IFC( pPointer->MoveAdjacentToElement(pElemTable, ELEM_ADJ_BeforeBegin) );
                        IFC( pSourceStart->IsRightOf(pPointer, &fResult) );
                        if (fResult)
                        {
                            IFC( pSourceStart->MoveToPointer(pPointer) );
                        }
                        
                        IFC( pPointer->MoveAdjacentToElement(pElemTable, ELEM_ADJ_AfterEnd) );
                        IFC( pSourceFinish->IsLeftOf(pPointer, &fResult) );
                        if (fResult)
                        {
                            IFC( pSourceFinish->MoveToPointer(pPointer) );
                        }
                        
                    } // if pElemTable
                } // case
            } // switch (tagId)
        } // if CONTEXT_TYPE_EnterScope
    }

    
Cleanup:
    ReleaseInterface(pElement);
    ReleaseInterface(pElemTable);
    ReleaseInterface(pPointer);

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSourceBody
//
//  Synopsis:   Makes sure the <body> is NOT included in the source of the
//              paste.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::Contain (
    IMarkupPointer *pPointer,
    IMarkupPointer *pPointerLeft,
    IMarkupPointer *pPointerRight )
{
    HRESULT hr = S_OK;
    
    if (Compare(pPointerLeft, pPointer) > 0)
    {
        IFC( pPointer->MoveToPointer(pPointerLeft) );
    }

    if (Compare(pPointerRight, pPointer ) < 0)
    {
        IFC( pPointer->MoveToPointer(pPointerRight) );
    }

Cleanup:
    RRETURN( hr );
}

HRESULT
CPasteCommand::FixupPasteSourceBody (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT             hr = S_OK;
    IHTMLElement        *pElementClient = NULL;
    IMarkupContainer    *pMarkupContainer = NULL;
    IMarkupPointer      *pPointerBodyStart = NULL;
    IMarkupPointer      *pPointerBodyFinish = NULL;
    ELEMENT_TAG_ID      tagId;
    
    //
    // Get the markup container associated with the sel
    //

    IFC( pPointerSourceStart->GetContainer(&pMarkupContainer) );
    Assert( pMarkupContainer );

    //
    // Get the client element from the markup and check to make sure
    // it's there and is a body element.
    //

    IFC( GetElementClient(pMarkupContainer, &pElementClient) );
    if (!pElementClient)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( GetMarkupServices()->GetElementTagId(pElementClient, &tagId) );
    if (tagId != TAGID_BODY)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    //
    // Move temp pointers to the inside edges of the body
    //

    IFC( GetEditor()->CreateMarkupPointer(&pPointerBodyStart) );
    IFC( pPointerBodyStart->MoveAdjacentToElement(pElementClient, ELEM_ADJ_AfterBegin) );
    
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBodyFinish) );    
    IFC( pPointerBodyFinish->MoveAdjacentToElement(pElementClient, ELEM_ADJ_BeforeEnd) );

    //
    // Make sure the source start and finish are within the body
    //

    IFC( Contain(pPointerSourceStart, pPointerBodyStart, pPointerBodyFinish) );
    IFC( Contain(pPointerSourceFinish, pPointerBodyStart, pPointerBodyFinish) );
    
Cleanup:
    ReleaseInterface(pElementClient);
    ReleaseInterface(pMarkupContainer);
    ReleaseInterface(pPointerBodyStart);
    ReleaseInterface(pPointerBodyFinish);
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPastePhraseElements
//
//  Synopsis:   To excessive nesting, adjust past edge phrase elements. 
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPastePhraseElements (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT         hr;
    CEditPointer    epStart(GetEditor());
    CEditPointer    epFinish(GetEditor());
    DWORD           dwFound;
    DWORD           dwSearchForward = BREAK_CONDITION_ANYTHING - BREAK_CONDITION_EnterPhrase;
    DWORD           dwSearchBack    = BREAK_CONDITION_ANYTHING;
    DWORD           eScanOptions    = SCAN_OPTION_None;     
    SP_IDocHostUIHandler spHostUIHandler;
    SP_IServiceProvider  spSP;
    DOCHOSTUIINFO        info;

    //
    // Cling to content to avoid generate nesting tags.  Contextual paste will
    // take of the formatting except for the following case:
    //
    // <B><P>...</P></B>
    //
    // In this case, contextual paste assumes the <B> is paragraph level formatting
    // so it won't pick it up.  So, we must be careful to throw away the 
    // <B>.  (Note, this structure is generated by the RTF converter.  See
    // bug 105644)
    //
    
    //
    // Skip start past phrase elements 
    //
    
    //
    // IE6 bug# 31832 (mharper) Generics (tags with a namespace) are considered phrase elements if
    // there is no <?import...?> on the source or destination.  This breaks VS7 drag-drop behavior
    // for behaviors because they don't use import PI's and they don't yet have the implementation
    // or the namespace in the target document.  
    //

    if ( SUCCEEDED(GetDoc()->QueryInterface(IID_IServiceProvider, (LPVOID *)&spSP)) )
    {
        
        if ( SUCCEEDED( spSP->QueryService(IID_IDocHostUIHandler, IID_IDocHostUIHandler, (LPVOID *)& spHostUIHandler) ) )
        {
            memset(reinterpret_cast<VOID **>(&info), 0, sizeof(DOCHOSTUIINFO));
            info.cbSize = sizeof(DOCHOSTUIINFO);
        
            if (SUCCEEDED(spHostUIHandler->GetHostInfo(&info))
                && (info.dwFlags & DOCHOSTUIFLAG_DISABLE_EDIT_NS_FIXUP))
            {
                eScanOptions = SCAN_OPTION_BreakOnGenericPhrase;
            }
        }
    }



    IFC( epStart->MoveToPointer(pPointerSourceStart) );
    IFC( epStart.Scan(RIGHT, dwSearchForward, &dwFound, 
                      NULL /*ppElement*/, NULL /*peTagId*/, NULL /*pChar*/, eScanOptions) );

    if (!epStart.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( epStart.Scan(LEFT, dwSearchBack, &dwFound) );
        IFC( pPointerSourceStart->MoveToPointer(epStart) );
    }

    //
    // Skip finish past phrase elements 
    //

    IFC( epFinish->MoveToPointer(pPointerSourceFinish) );
    IFC( epFinish.Scan(LEFT, dwSearchForward, &dwFound,
                        NULL /*ppElement*/, NULL /*peTagId*/, NULL /*pChar*/, eScanOptions) );
    if (!epFinish.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock))
    {
        IFC( epFinish.Scan(RIGHT, dwSearchBack, &dwFound) );
        IFC( pPointerSourceFinish->MoveToPointer(epFinish) );
    }
     

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   FixupPasteSource
//
//  Synopsis:   Makes sure the source of a paste is valid.  This means, for
//              the most part, that sub-parts of tables must not be pasted
//              without their corresponding table.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::FixupPasteSource (
    IMarkupPointer  *pPointerSourceStart,
    IMarkupPointer  *pPointerSourceFinish )
{
    HRESULT hr = S_OK;

    IFC( FixupPasteSourceFragComments(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPasteSourceBody(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPasteSourceTables(pPointerSourceStart, pPointerSourceFinish) );

    IFC( FixupPastePhraseElements(pPointerSourceStart, pPointerSourceFinish) );

Cleanup:
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   IsContainedInElement
//
//  Synopsis:   Is pPointer contained in the scope of pElement
//
//-----------------------------------------------------------------------------
HRESULT
CPasteCommand::IsContainedInElement(
    IMarkupPointer  *pPointer,
    IHTMLElement    *pElement,
    IMarkupPointer  *pTempPointer, 
    BOOL            *pfResult)
{
    HRESULT hr;
    BOOL    fResult;

    Assert(pPointer && pElement && pTempPointer && pfResult);

    *pfResult = FALSE;

    IFC( pTempPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_AfterEnd) );
    IFC( pTempPointer->IsRightOf(pPointer, &fResult) );
    if (fResult)
    {
        IFC( pTempPointer->MoveAdjacentToElement(pElement, ELEM_ADJ_BeforeBegin) );
        IFC( pTempPointer->IsLeftOf(pPointer, &fResult) );        
        if (fResult)
            *pfResult = TRUE;
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   IsContainedInOL
//
//  Synopsis:   Determines if the markup pointer is contained within an OL
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::IsContainedInOL (
    IMarkupPointer  *pPointerLeft,
    IMarkupPointer  *pPointerRight,
    BOOL            *pfInOrderedList )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    IMarkupPointer  *pTemp = NULL;
    ELEMENT_TAG_ID  tagId;
    BOOL            fContained;

    Assert(pPointerLeft && pPointerRight);
    Assert(pfInOrderedList);

    *pfInOrderedList = FALSE;

    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

    IFC( pPointerLeft->CurrentScope(&pElemCurrent) );

    // Walk up looking of OLs or LIs
    while (pElemCurrent)
    {
        IFC( GetMarkupServices()->GetElementTagId(pElemCurrent, &tagId) );

        if (tagId == TAGID_OL)
        {
            *pfInOrderedList = TRUE;
            goto Cleanup;
        }

        if (tagId == TAGID_LI)
        {
            SP_IMarkupPointer       spCurrent;
            long                    cchNext = -1;

            // If we've found an LI, we only care about the parent if the range is not
            // contained within the LI. If the range is contained within the LI, we don't 
            // want to paste the LI or the OL.
            IFC( IsContainedInElement(pPointerRight, pElemCurrent, pTemp, &fContained) );

            if (!fContained)
            {
                IFC( GetEditor()->CreateMarkupPointer(&spCurrent) );
                IFC( spCurrent->MoveToPointer(pPointerLeft) );

                IFC( ScanForText(spCurrent, pPointerRight, &cchNext) );
                if (hr == S_OK)
                {
                    SP_IHTMLComputedStyle   spStyle;
                    VARIANT_BOOL            vb;

                    IFC( GetDisplayServices()->GetComputedStyle(spCurrent, &spStyle) );

                    IFC( spStyle->get_OL(&vb) );
                    *pfInOrderedList = vb == VB_TRUE;
                
                    goto Cleanup;
                }
            }
            else
            {
                goto Cleanup;
            }
        }

        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    }

Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pTemp);

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetRightPartialBlockElement
//
//  Synopsis:   Get the partial block element on the right
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::GetRightPartialBlockElement (
    IMarkupPointer  *pPointerLeft,
    IMarkupPointer  *pPointerRight,
    IHTMLElement    **ppElementPartialRight )
{
    HRESULT         hr = S_OK;
    IHTMLElement    *pElemCurrent = NULL;
    IMarkupPointer  *pLeft = NULL;
    IMarkupPointer  *pRight = NULL;
    IMarkupPointer  *pTemp = NULL;
    BOOL            fContained;

    Assert(ppElementPartialRight && pPointerLeft && pPointerRight);
    *ppElementPartialRight = NULL;

    IFC( GetEditor()->CreateMarkupPointer(&pLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

    IFC( pPointerRight->CurrentScope(&pElemCurrent) );
    while (pElemCurrent)
    {        
        if (IsBlockElement(pElemCurrent))
        {
            IFC( IsContainedInElement(pPointerRight, pElemCurrent, pTemp, &fContained) );
            if (fContained)
            {
                IFC( IsContainedInElement(pPointerLeft, pElemCurrent, pTemp, &fContained) );
                if (!fContained)
                {
                    *ppElementPartialRight = pElemCurrent;
                    pElemCurrent->AddRef();
                    
                    goto Cleanup;
                }
            }
        }
        IFC( ParentElement(GetMarkupServices(), &pElemCurrent) );
    } 

Cleanup:
    ReleaseInterface(pElemCurrent);
    ReleaseInterface(pLeft);
    ReleaseInterface(pRight);
    ReleaseInterface(pTemp);

    RRETURN(hr);
}
    
//+----------------------------------------------------------------------------
//
//  Function:   ResolveConflict
//
//  Synopsis:   Resolves an HTML DTD conflict between two elements by removing
//              the top element over a limited range (defined by the bottom
//              element).
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::ResolveConflict(
    IHTMLElement    *pElementBottom,
    IHTMLElement    *pElementTop,
    BOOL            fIsOfficeContent)
{
    HRESULT             hr = S_OK;
    BOOL                fFoundContent;
    IHTMLElement        *pElementClone = NULL;
    SP_IHTMLElement     spElementPara;
    IMarkupPointer      *pPointerTopStart = NULL;
    IMarkupPointer      *pPointerTopFinish = NULL;
    IMarkupPointer      *pPointerBottomStart = NULL;
    IMarkupPointer      *pPointerBottomFinish = NULL;
    IMarkupPointer      *pPointerInsertClone = NULL;
    CEditPointer        epPointerTemp(GetEditor());
    DWORD               dwFound;
    ELEMENT_TAG_ID       tagIdTop = TAGID_NULL;
    ELEMENT_TAG_ID       tagIdBottom = TAGID_NULL;
    MARKUP_CONTEXT_TYPE  ct = CONTEXT_TYPE_None;

    //
    // Addref the top element to make sure it does not go away while it
    // is out of the tree.
    //

    pElementTop->AddRef();

    IFC( GetEditor()->CreateMarkupPointer(&pPointerTopStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerTopFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBottomStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerBottomFinish) );
    
    //
    // In IE4, we would never remove a ped (IsContainer is nearly equivalent).
    // So, if a conflict arises where the top element is a ccontainer, remove
    // the bottom element instead.  Also, if there is no container above the
    // top element, we should not remove it.  THis takes care to not remove
    // elements like HTML.
    //

    if (GetEditor()->IsContainer(pElementTop) 
        || !HasContainer(pElementTop))
    {
        IFC( GetMarkupServices()->RemoveElement(pElementBottom) );
        goto Cleanup;
    }

#if DBG == 1
    IEditDebugServices *pEditDebugServices;
    
    if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
    {
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerTopStart, _T("Top Start")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerTopFinish, _T("Top Finish")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerBottomStart, _T("Bottom Start")) );
        IGNORE_HR( pEditDebugServices->SetDebugName(pPointerBottomFinish, _T("Bottom Finish")) );

        pEditDebugServices->Release();
    }
#endif
    
    //
    // First, more pointer to the locations of the elements in question.
    //
    
    IFC( pPointerTopStart->MoveAdjacentToElement(pElementTop, ELEM_ADJ_BeforeBegin) );
    IFC( pPointerTopFinish->MoveAdjacentToElement(pElementTop, ELEM_ADJ_AfterEnd) );

    IFC( pPointerBottomStart->MoveAdjacentToElement(pElementBottom, ELEM_ADJ_BeforeBegin) );
    IFC( pPointerBottomFinish->MoveAdjacentToElement(pElementBottom, ELEM_ADJ_AfterEnd) );

    {
        SP_IObjectIdentity spIdent;

        IFC( pElementTop->QueryInterface(IID_IObjectIdentity, (LPVOID *)&spIdent) );
        if (spIdent->IsEqualObject(pElementBottom) == S_OK)
            goto Cleanup;
    }        

    //
    // Make sure the input elements are where we think they 'aught to be
    //

#ifdef _PREFIX_
    BOOL fDbgFlag;
#else
    WHEN_DBG( BOOL fDbgFlag; )
#endif    
    Assert( pPointerTopStart->IsLeftOf(pPointerBottomStart, &fDbgFlag) == S_OK && fDbgFlag);
    Assert( pPointerTopFinish->IsRightOf(pPointerBottomStart, &fDbgFlag) == S_OK && fDbgFlag);

    //
    // Now, remove the top element and reinsert it so that it is no
    // over the bottom element.
    //

    IFC( GetMarkupServices()->RemoveElement(pElementTop) );

    //
    // Look left.  If we can get to the beginning of the top element,
    // without seeing any text (including break chars) or any elements
    // terminating then we must not put the top element back in before
    // the bottom.
    //

    IFC( epPointerTemp->MoveToPointer(pPointerBottomStart) );
    
    IFC( epPointerTemp.SetBoundaryForDirection(LEFT, pPointerTopStart) );
    IFC( epPointerTemp.Scan(LEFT, BREAK_CONDITION_Content, &dwFound) );

    fFoundContent = !epPointerTemp.CheckFlag(dwFound, BREAK_CONDITION_Boundary);

    if (fFoundContent)
    {
        IFC( GetMarkupServices()->InsertElement(pElementTop, pPointerTopStart, pPointerBottomStart) );
    }

    //
    // Look right.
    //
    

    IFC( epPointerTemp->MoveToPointer(pPointerBottomFinish) );

    IFC( epPointerTemp.SetBoundaryForDirection(RIGHT, pPointerTopFinish) );
    IFC( epPointerTemp.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );

    fFoundContent = !epPointerTemp.CheckFlag(dwFound, BREAK_CONDITION_Boundary);

    if (fFoundContent)
    {
 
        IFC( GetMarkupServices()->CloneElement(pElementTop, &pElementClone) );
        IFC( GetEditor()->CreateMarkupPointer(&pPointerInsertClone) );
        IFC( pPointerInsertClone->MoveToPointer(pPointerBottomFinish) );

        //
        // Now we check for the degenarate case where multiple <p></p>'s are being pasted
        // If we have a document that looks like this:
        //
        // {top start}
        // <p>
        //    {bottom start}<p> </p>{bottom finish}
        //    <p> </p>
        // </p>{top finish}
        //    
        // and we then just remove the top element and insert it right after {bottom finish}
        // we are sure to *generate* another conflict immediately below bottom because the document
        // will look like:  
        //
        // <p></p>
        // <p>  <-- (this is where the top element moved to) 
        //    <p></p>
        // </p>
        //
        // so we will now pass as many consecutive <p></p>'s as we can in one fell swoop
        // -mharper
        // 


        if( fIsOfficeContent )
        {

            IFC( GetMarkupServices()->GetElementTagId(pElementTop, &tagIdTop) );
            IFC( GetMarkupServices()->GetElementTagId(pElementBottom, &tagIdBottom) );

            if( tagIdTop == TAGID_P && tagIdBottom == TAGID_P)
            {
        
                do
                {
                    IFC( pPointerInsertClone->Right(FALSE, &ct, &spElementPara, NULL, NULL) );

                    if(spElementPara && ct == CONTEXT_TYPE_EnterScope)
                    {
                    
                        IFC( GetMarkupServices()->GetElementTagId(spElementPara, &tagIdBottom) ); 

                        if( tagIdBottom == TAGID_P )
                        {
                            IFC( pPointerInsertClone->MoveAdjacentToElement(spElementPara, ELEM_ADJ_AfterEnd) );
                        }

                    }
                }
                while(spElementPara && tagIdBottom == TAGID_P && ct == CONTEXT_TYPE_EnterScope);

            }
        }
        
        IFC( GetMarkupServices()->InsertElement(pElementClone, pPointerInsertClone, pPointerTopFinish) );


    }

Cleanup:
    ReleaseInterface(pPointerTopStart);
    ReleaseInterface(pPointerTopFinish);
    ReleaseInterface(pPointerBottomStart);
    ReleaseInterface(pPointerBottomFinish);
    ReleaseInterface(pPointerInsertClone);
    ReleaseInterface(pElementClone);
    ReleaseInterface(pElementTop);
    
    RRETURN( hr );
}

HRESULT
CPasteCommand::UiDeleteContent(IMarkupPointer * pmpStart, IMarkupPointer * pmpFinish)
{
    HRESULT hr;;
    
    hr = THR( GetEditor()->Delete(pmpStart, pmpFinish, TRUE) );

    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Performs the actual work of pasting (like, ctrl-V)
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::HandleUIPasteHTML (
    IMarkupPointer  *pPointerTargetStart,
    IMarkupPointer  *pPointerTargetFinish,
    HGLOBAL          hglobal)
{
    HRESULT                hr = S_OK;
    IMarkupContainer       *pMarkup = NULL;
    IMarkupContainer       *pMarkupContext = NULL;
    IMarkupPointer         *pPointerSourceStart = NULL;
    IMarkupPointer         *pPointerSourceFinish = NULL;
    IMarkupPointer         *pPointerStatus = NULL;
    IMarkupPointer         *pPointerNewContentLeft = NULL;
    IMarkupPointer         *pPointerNewContentRight = NULL;
    IMarkupPointer         *pPointerMergeRight = NULL;
    IMarkupPointer         *pPointerMergeLeft = NULL;
    IMarkupPointer         *pPointerRemoveLeft = NULL;
    IMarkupPointer         *pPointerRemoveRight = NULL;
    IMarkupPointer         *pPointerDoubleBulletsLeft = NULL;
    IMarkupPointer         *pPointerDoubleBulletsRight = NULL;
    IMarkupPointer         *pTemp = NULL;
    IHTMLElement           *pElementMergeRight = NULL;
    IHTMLElement           *pElement = NULL;
    IHTMLElement           *pElemFailBottom = NULL;
    IHTMLElement           *pElemFailTop = NULL;
    IMarkupPointer         *pPointer = NULL;
    CStackPtrAry <IHTMLElement *, 4 > aryRemoveElems ( Mt( Mem ) );
    INT                    i;
    SP_IMarkupPointer      spLocalPointerTargetFinish;
    BOOL                   fInOrderedList = FALSE;
    CEditPointer           ep(GetEditor());
    DWORD                  dwFound = NULL;
    SP_IHTMLElement        spElement;
    BOOL                   fIsOfficeContent = FALSE;
    MARKUP_CONTEXT_TYPE    ct = CONTEXT_TYPE_None;
    TCHAR                  ch = NULL;
    long                   cch = 0l;


    CPasteCharFormatManager charFormatManager(GetEditor());

    if (!pPointerTargetFinish)
    {
        IFC( GetEditor()->CreateMarkupPointer(&spLocalPointerTargetFinish) );
        IFC( spLocalPointerTargetFinish->MoveToPointer(pPointerTargetStart) );

        pPointerTargetFinish = spLocalPointerTargetFinish;
    }

#if DBG==1
    {
        BOOL fDbgIsPositioned;
        IEditDebugServices *pEditDebugServices = NULL;
        IMarkupContainer *pDbgMarkup1, *pDbgMarkup2;
        IObjectIdentity *pDbgIdent = NULL;
        
        //
        // Make sure the pointers are in the same markup and are ordered
        // correctly.
        //

        Assert( pPointerTargetStart->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
        Assert( pPointerTargetFinish->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned);

        if (SUCCEEDED(pPointerTargetStart->GetContainer(&pDbgMarkup1)))
        {
            if (SUCCEEDED(pPointerTargetStart->GetContainer(&pDbgMarkup2)))
            {
                if (SUCCEEDED(pDbgMarkup1->QueryInterface(IID_IObjectIdentity, (LPVOID *)&pDbgIdent)))
                {
                    Assert(pDbgIdent->IsEqualObject(pDbgMarkup2) == S_OK);
                    pDbgIdent->Release();
                }
                pDbgMarkup2->Release();        
            }       
            pDbgMarkup1->Release();        
        }
        
        if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            WHEN_DBG( pEditDebugServices->SetDebugName(pPointerTargetStart, _T("Target Start")) );
            WHEN_DBG( pEditDebugServices->SetDebugName(pPointerTargetFinish, _T("Target Finish")) );

            pEditDebugServices->Release();
        }
    }
#endif

    IFC( GetEditor()->CreateMarkupPointer(&pPointerSourceStart) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerSourceFinish) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerNewContentLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerNewContentRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerMergeRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerMergeLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerRemoveLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerRemoveRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerDoubleBulletsLeft) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerDoubleBulletsRight) );
    IFC( GetEditor()->CreateMarkupPointer(&pPointerStatus) );
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );


    //
    // Make sure the target start and end are properly oriented (the
    // start must be before the end.
    //

    IFC( EnsureLogicalOrder(pPointerTargetStart, pPointerTargetFinish) );

    Assert( Compare(pPointerTargetStart, pPointerTargetFinish) <= 0 );

    //
    // Now, parse (or attempt to) the HTML given to us
    //

    IFC( pPointerTargetStart->GetContainer(&pMarkupContext) );

    IFC( GetMarkupServices()->ParseGlobalEx( 
            hglobal,
            PARSE_ABSOLUTIFYIE40URLS,
            pMarkupContext,  // pContextMarkup
            & pMarkup,
            pPointerSourceStart,
            pPointerSourceFinish ) );
    
#if DBG==1
    {
        IEditDebugServices *pEditDebugServices = NULL;

        if (SUCCEEDED(GetMarkupServices()->QueryInterface(IID_IEditDebugServices, (LPVOID *)&pEditDebugServices)))
        {
            IGNORE_HR( pEditDebugServices->SetDebugName(pPointerSourceStart, _T("Source Start")) );
            IGNORE_HR( pEditDebugServices->SetDebugName(pPointerSourceFinish, _T("Source Finish")) );

            pEditDebugServices->Release();
        }
    }
#endif    

    //
    // If there was nothing really there to parse, just do a remove
    //
    
    if (!pMarkup)
    {
        IFC( UiDeleteContent(pPointerTargetStart, pPointerTargetFinish) );
        goto Cleanup;
    }
    


    //
    // Make sure this current range is one which is valid to delete and/or
    // replace with something else.  In the old IE4 code, the function
    // ValidateRplace was used to determine this.
    //
    // Also, the ole code used to call ValidateInsert which would decide if
    // the target location was a validate place to insert stuff.
    //
    // Ramin - do this here.
    //

// ValidateInsert code goes here (or similar)

    //
    // Cleanup the source to paste, possibly adjusting the sel range.
    // We paste NULL for the last parameter because I do not want the
    // fixup code to conditionally not do the table check.
    //
    
    IFC( FixupPasteSource(pPointerSourceStart, pPointerSourceFinish) );
    

    //
    // Check to see if the content comes from Excel or Word
    // and then apply styles that are not in the Computed Formats
    // Office uses stylesheet rules that can change (among other 
    // things)  the margins on <P> tags which are quite different
    // from the default.
    //
    
    IFC( IsOfficeFormat(pPointerSourceStart, &fIsOfficeContent) );
    if ( fIsOfficeContent )
    {

        IFC( FixupStyles(pPointerSourceStart, pPointerSourceFinish) );

        //
        // APPHACK: Office adds multiple cr-lf pairs after the <!--StartFragment-->
        // these are correctly converted to a space in ParseGlobal() which causes
        // a <P> </P> to be added in ResolveConflicts().  
        //
        // ParseGlobal can't just go around eating whitespace after the StartFragment
        // because that would break the scenario where the selection is 
        // <!--StartFragment--> two<!--EndFragment--> and we are pasting into
        // <body>one{target}</body. So we can only eat this space if we are sure that
        // it is evil i.e.: a)This is office content b)the first content is a space, and 
        // c)the next non-whitespace content is entering a block element -(mharper)
        // 

        IGNORE_HR(pPointerSourceStart->Right(FALSE, &ct, NULL, &(cch = 1), &ch ) );

        if( ct == CONTEXT_TYPE_Text && ch == _T(' ') )
        {
            IFC( ep->MoveToPointer(pPointerSourceStart) );
            IFC( ep.Scan( RIGHT, BREAK_CONDITION_Content, &dwFound, &spElement, 
                            NULL, NULL, SCAN_OPTION_SkipWhitespace) );

            if ( ep.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock) )
            {
                IFC( pTemp->MoveAdjacentToElement(spElement, ELEM_ADJ_BeforeBegin) );
                IFC( GetMarkupServices()->Remove(pPointerSourceStart, pTemp) );
            }
        }

    }

    //
    // We need to remember the formatting at this position before the markup
    // is munged and before we lose the information on the move.
    //

    IFC( charFormatManager.ComputeFormatMap(pPointerSourceStart, pPointerSourceFinish) );
    
    //
    // Compute right block element to merge.  However, we only merge if the target
    // contains content to the right.  
    //
    // For example:
    //
    // source:   {start fragment><p>foo{end fragment}</p>
    //
    // target 1: <P>{target}sometext</P> - we need to merge to avoid introducing a line break before sometext
    // target 2: <P>{target}</P> - we shouldn't merge.  
    //

    IFC( ep->MoveToPointer(pPointerTargetFinish) );
    IFC( ep.Scan(RIGHT, BREAK_CONDITION_Content, &dwFound) );
    if (!ep.CheckFlag(dwFound, BREAK_CONDITION_Site | BREAK_CONDITION_Block))
    {
        IFC( GetRightPartialBlockElement(pPointerSourceStart, pPointerSourceFinish, &pElementMergeRight) );
    }
    
    //
    // If we overlap or are within a LI, we need to see if we're within a OL and reapply the OL
    // when we paste.
    //

    IFC( IsContainedInOL(pPointerSourceStart, pPointerSourceFinish, &fInOrderedList) );

    //
    // In IE4 because of the way the splice operation was written, any
    // elements which partially overlapped the left side of the stuff to
    // move would not be move to the target.  This implicit behaviour
    // was utilized to effectively get left handed block merging (along
    // with not moving any elements which partially overlapped).
    //
    // Here, I remove all elements which partially overlap the left
    // hand side so that the move operation does not move a clone of them
    // to the target.
    //

    ClearInterface(&pElement);
    IFC( pPointerSourceStart->CurrentScope(&pElement) );

    while (pElement)
    {        
        BOOL fContained;
                
        IFC( IsContainedInElement(pPointerSourceStart, pElement, pTemp, &fContained) );
        if (fContained)
        {
            IFC( IsContainedInElement(pPointerSourceFinish, pElement, pTemp, &fContained) );
            if (!fContained)
            {
                pElement->AddRef();
                IFC( aryRemoveElems.Append(pElement) );
            }
        }

        IFC( ParentElement(GetMarkupServices(), &pElement) );
    }
    
    for (i = 0; i < aryRemoveElems.Size(); i++)
    {
        IFC( GetMarkupServices()->RemoveElement(aryRemoveElems[i]) );
        ClearInterface(&aryRemoveElems[i]);
    }
    
    //
    // Before actually performing the move, insert two pointers into the
    // target such that they will surround the moved source.
    //
    
    IGNORE_HR( pPointerNewContentLeft->SetGravity( POINTER_GRAVITY_Left ) );
    IGNORE_HR( pPointerNewContentRight->SetGravity( POINTER_GRAVITY_Right ) );

    IFC( pPointerNewContentLeft->MoveToPointer(pPointerTargetStart) );
    IFC( pPointerNewContentRight->MoveToPointer(pPointerTargetStart) );

    //
    // Locate the target with pointers which stay to the right of
    // the newly inserted stuff.  This is especially needed when
    // the two are equal.
    //

    IFC( pPointerRemoveLeft->MoveToPointer(pPointerTargetStart) );
    IFC( pPointerRemoveRight->MoveToPointer(pPointerTargetFinish) );


    IGNORE_HR( pPointerRemoveLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerRemoveRight->SetGravity(POINTER_GRAVITY_Right) );

    //
    // Before performing the move, we insert pointers with cling next
    // to elements which we will later perform a merge.  We need to do
    // this because (potentially) clones of the merge elements in the
    // source will be moved to the target because those elements are
    // only partially selected int the source.
    //

    if (pElementMergeRight)
    {
        IFC( pPointerMergeRight->MoveAdjacentToElement(pElementMergeRight, ELEM_ADJ_BeforeBegin) );

        IGNORE_HR( pPointerMergeRight->SetGravity( POINTER_GRAVITY_Right ) );        
        IGNORE_HR( pPointerMergeRight->SetCling( TRUE ) );
    }

    //
    // Now, move the source to the target. Here I insert two pointers
    // to record the location of the source after it has moved to the
    // target.
    //

    IFC( GetMarkupServices()->Move(pPointerSourceStart, pPointerSourceFinish, pPointerTargetStart ) );

    //
    // If this is not being performed from the automation range, then
    // include formatiing elements from the context
    //

    IFC( charFormatManager.FixupFormatting(pPointerNewContentLeft, fInOrderedList, fIsOfficeContent) );
        
    //
    // Now that the new stuff is in, make the pointers which indicate
    // it point inward so that the isolating char does not get in between
    // them.
    //

    IGNORE_HR( pPointerNewContentLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerNewContentRight->SetGravity(POINTER_GRAVITY_Left) );

    //
    // Now, remove the old stuff.  Because we use a rather high level
    // operation to do this, we have to make sure the newly inserted
    // stuff does not get mangled.  We do this by inserting an insulating
    // character.
    //

    {
        long  cch;
        TCHAR ch = _T('~');

        IFC( GetMarkupServices()->InsertText(&ch, 1, pPointerNewContentRight) );

        IFC( UiDeleteContent(pPointerRemoveLeft, pPointerRemoveRight) );

#if DBG == 1
        {
            MARKUP_CONTEXT_TYPE ct;
        
            IGNORE_HR(
                pPointerNewContentRight->Right(
                    FALSE, & ct, NULL, & (cch = 1), & ch ) );

            Assert( ct == CONTEXT_TYPE_Text && ch == _T('~') );
        }
#endif

        IFC( pPointerRemoveLeft->MoveToPointer(pPointerNewContentRight) );
        IFC( pPointerRemoveLeft->Right(TRUE, NULL, NULL, & (cch = 1), NULL) );

        IFC( GetMarkupServices()->Remove(pPointerNewContentRight, pPointerRemoveLeft) );

        IFC( pPointerRemoveLeft->Unposition() );
        IFC( pPointerRemoveRight->Unposition() );
    }

    //
    // Now, recover the elements to merge in the target tree
    //

    if (pElementMergeRight)
    {
        MARKUP_CONTEXT_TYPE ct;

#if DBG==1
    BOOL fDbgIsPositioned;
    
    Assert( pPointerMergeRight->IsPositioned(&fDbgIsPositioned) == S_OK && fDbgIsPositioned );
#endif

        ClearInterface(&pElementMergeRight);
        pPointerMergeRight->Right(FALSE, &ct, &pElementMergeRight, NULL, NULL);

        Assert( ct == CONTEXT_TYPE_EnterScope );

        IFC( pPointerMergeRight->Unposition() );
    }
    
    //
    // Now, look for conflicts and remove them
    //

    //
    // Make sure changes to the document get inside the new content pointers
    //
    
    IGNORE_HR( pPointerNewContentLeft->SetGravity(POINTER_GRAVITY_Left) );
    IGNORE_HR( pPointerNewContentRight->SetGravity(POINTER_GRAVITY_Right) );
    
    //
    // (Bug 1677) - ResolveConflict can cause the pPointerNewContentLeft and
    // new pPointerNewContentRight to float outward because of their Left and
    // Right gravity respectively, so here we use temporary markup pointers 
    // pPointerDoubleBulletsLeft (with right gravity) and pPointerDoubleBulletsRight 
    // (with left gravity) 
    //

    IFC( pPointerDoubleBulletsLeft->MoveToPointer(pPointerNewContentLeft) );
    IFC( pPointerDoubleBulletsRight->MoveToPointer(pPointerNewContentRight) );

    IGNORE_HR( pPointerDoubleBulletsLeft->SetGravity(POINTER_GRAVITY_Right) );
    IGNORE_HR( pPointerDoubleBulletsRight->SetGravity(POINTER_GRAVITY_Left) );


    for ( ; ; )
    {
        ClearInterface(&pElemFailBottom);
        ClearInterface(&pElemFailTop);
    
        IFC( GetMarkupServices()->ValidateElements(
                pPointerNewContentLeft, pPointerNewContentRight, NULL,
                pPointerStatus, &pElemFailBottom, &pElemFailTop) );

        if (hr == S_OK)
            break;

        IFC( ResolveConflict(pElemFailBottom, pElemFailTop, fIsOfficeContent) );
    }


    //
    // Perform any merging
    //

    if (pElementMergeRight)
    {
        IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
        
        ClearInterface(&pMarkupContext);
        IFC( pPointer->GetContainer(&pMarkupContext) );

        IFC( pPointer->MoveAdjacentToElement(pElementMergeRight, ELEM_ADJ_BeforeEnd) );

        IFC( MergeBlock(pPointer) );
    }

    //
    // Because the source context for the paste may have allowed \r's and
    // the like in the text which we just pasted to the target, and the
    // recieving target element may not allow these kind of chars, we must
    // sanitize here.
    //

    IFC( SanitizeRange(pPointerNewContentLeft, pPointerNewContentRight) );

    //
    // Check for double bullets
    //

    IFC( pPointerDoubleBulletsLeft->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }

    IFC( pPointerDoubleBulletsRight->CurrentScope(&spElement) );
    if (spElement != NULL)
    {
        IFC( RemoveDoubleBullets(spElement) );                
    }

    //
    // Unposition pointers
    //

    IFC( pPointerNewContentLeft->Unposition() );
    IFC( pPointerNewContentRight->Unposition() );

    IFC( pPointerDoubleBulletsLeft->Unposition() );
    IFC( pPointerDoubleBulletsRight->Unposition() );

Cleanup:
    ReleaseInterface(pMarkup);
    ReleaseInterface(pMarkupContext);
    ReleaseInterface(pPointerSourceStart);
    ReleaseInterface(pPointerSourceFinish);
    ReleaseInterface(pPointerStatus);
    ReleaseInterface(pPointerNewContentLeft);
    ReleaseInterface(pPointerNewContentRight);
    ReleaseInterface(pPointerMergeRight);
    ReleaseInterface(pPointerMergeLeft);
    ReleaseInterface(pPointerRemoveLeft);
    ReleaseInterface(pPointerRemoveRight);
    ReleaseInterface(pPointerDoubleBulletsLeft);
    ReleaseInterface(pPointerDoubleBulletsRight);
    ReleaseInterface(pTemp);
    ReleaseInterface(pElementMergeRight);
    ReleaseInterface(pElement);
    ReleaseInterface(pElemFailBottom);
    ReleaseInterface(pElemFailTop);
    ReleaseInterface(pPointer);
    
    RRETURN( hr );
}

//+----------------------------------------------------------------------------
//
//  Function:   HandleUIPasteHTML
//
//  Synopsis:   Helper function which taks string, coverts it to a global
//              and calls real function.
//
//-----------------------------------------------------------------------------

HRESULT
CPasteCommand::HandleUIPasteHTML (
    IMarkupPointer * pPointerTargetStart,
    IMarkupPointer * pPointerTargetFinish,
    const TCHAR *    pStr,
    long             cch)
{
    HRESULT hr = S_OK;
    HGLOBAL hHtmlText = NULL;

    if (pStr && *pStr)
    {
        extern HRESULT HtmlStringToSignaturedHGlobal (
            HGLOBAL * phglobal, const TCHAR * pStr, long cch );

        hr = THR(
            HtmlStringToSignaturedHGlobal(
                & hHtmlText, pStr, _tcslen( pStr ) ) );

        if (hr)
            goto Cleanup;

        Assert( hHtmlText );
    }

    IFC( HandleUIPasteHTML(pPointerTargetStart, pPointerTargetFinish, hHtmlText) );


Cleanup:
    
    if (hHtmlText)
        GlobalFree( hHtmlText );
    
    RRETURN( hr );
}


//+----------------------------------------------------------------------------
//
//  Function:   IsOfficeFormat
//
//  Synopsis:   Determines if the HTML is coming from an Office document
//              
//
//-----------------------------------------------------------------------------

HRESULT 
CPasteCommand::IsOfficeFormat(
    IMarkupPointer      *pPointerSourceStart,
    BOOL                *pfIsOfficeFormat)
{

    HRESULT             hr = S_OK;
    IMarkupPointer      *pPointer = NULL;
    IMarkupContainer    *pMarkup = NULL;
    ELEMENT_TAG_ID      tagId = TAGID_NULL;
    SP_IHTMLElement     spElement; 
    VARIANT             var;
    MARKUP_CONTEXT_TYPE ct = CONTEXT_TYPE_None;


    VariantInit(&var);
    *pfIsOfficeFormat = FALSE;


    IFC( GetEditor()->CreateMarkupPointer(&pPointer) );
    IFC( pPointerSourceStart->GetContainer(&pMarkup) );
    IFC( pPointer->MoveToContainer(pMarkup, TRUE) );
    
    //
    // Start from the beginning of the MarkupContainer looking for 
    // META tags.  Word adds the following:
    //     <meta name=Generator content="Microsoft Word 9">
    // and Excel adds:
    //     <meta name=Generator content="Microsoft Excel 9">
    //


    for(;;)
    {
        hr = THR( pPointer->Right(TRUE, &ct, &spElement, NULL, NULL) );

        switch(ct)
        {
            case CONTEXT_TYPE_EnterScope:
            case CONTEXT_TYPE_NoScope:
                IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );

                if ( tagId == TAGID_META )
                {
                    VariantClear(&var);
                    IFC( spElement->getAttribute(_T("name"), 0, &var) );

                    if ( V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL 
                        && StrCmpIC( _T("Generator"), var.bstrVal) == 0 )
                    {
                        VariantClear(&var);

                        IFC( spElement->getAttribute( _T("content"), 0, &var) );

                        if( V_VT(&var) == VT_BSTR && V_BSTR(&var) != NULL &&
                            ( StrCmpNIC( _T("Microsoft Word"), var.bstrVal, 14) == 0 || 
                            StrCmpNIC( _T("Microsoft Excel"), var.bstrVal, 15) == 0) )
                        {
                            *pfIsOfficeFormat = TRUE;  //found it
                            goto Cleanup;
                        }

                    }
                } 
                else if (tagId == TAGID_BODY)
                {
                    //
                    // Since META tags (at least the ones we are interested in) 
                    // should be in the HEAD, if we are already entering the scope 
                    // of the BODY and haven't found what we're looking for, then 
                    // we never will.
                    // 

                    *pfIsOfficeFormat = FALSE;
                    goto Cleanup;
                }
                
                break;

            case CONTEXT_TYPE_None:
                *pfIsOfficeFormat = FALSE;
                goto Cleanup;
        }       
    }


Cleanup:
  
    ReleaseInterface(pPointer);
    ReleaseInterface(pMarkup);
    VariantClear(&var);

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   FixupStyle
//
//  Synopsis:   Applies styles that are not part of the computed format
//              
//
//-----------------------------------------------------------------------------
HRESULT
CPasteCommand::FixupStyles(
    IMarkupPointer      *pPointerSourceStart,
    IMarkupPointer      *pPointerSourceFinish)
{
    
    HRESULT                 hr = S_OK;
    IMarkupPointer          *pTemp = NULL;
    SP_IHTMLStyle           spStyle;
    SP_IHTMLCurrentStyle    spCurrentStyle;
    SP_IHTMLElement2        spElement2;
    SP_IHTMLElement         spElement;
    BSTR                    bstrClassName = NULL;
    BSTR                    bstrStyleValue = NULL;
    VARIANT                 vStyleValue;
    ELEMENT_TAG_ID          tagId = TAGID_NULL;
    MARKUP_CONTEXT_TYPE     ct = CONTEXT_TYPE_None;

    VariantInit(&vStyleValue);
    IFC( GetEditor()->CreateMarkupPointer(&pTemp) );

#define COPY_STYLE_VARIANT(style)                                                   \
                    VariantClear( &vStyleValue );                                   \
                    IFC( spCurrentStyle->get_ ## style( &vStyleValue ) );           \
                    IFC( spStyle->put_ ## style( vStyleValue ) );   

#define COPY_STYLE_BSTR(style)                                                      \
                    SysFreeString( bstrStyleValue );                                \
                    IFC( spCurrentStyle->get_ ## style( &bstrStyleValue ) );        \
                    IFC( spStyle->put_ ## style( bstrStyleValue ) ); 




    IFC( pTemp->MoveToPointer(pPointerSourceStart) );

    IFC( pTemp->Right(TRUE, &ct, &spElement, NULL, NULL) );
    
    while ( ct != CONTEXT_TYPE_None && Compare(pTemp, pPointerSourceFinish) < 0 )
    {
        
        
        if ( ct == CONTEXT_TYPE_EnterScope )
        {

            IFC( spElement->get_className(&bstrClassName) );
            IFC( GetMarkupServices()->GetElementTagId(spElement, &tagId) );
            
            //
            // If bstrTemp is not NULL and is not pointing to a null string, then there is a value
            // for class name, and is likely to have styles that are of interest to us.  Also,
            // Word/Excel may define rules for tags without giving specific class names, so we would 
            // also be interested in the tags listed below. (mharper - 11/7/2000)
            //

            if ( (bstrClassName && *bstrClassName) || tagId == TAGID_TD || tagId == TAGID_SPAN || tagId == TAGID_H1 ||
                tagId == TAGID_H2 || tagId == TAGID_H3 || tagId == TAGID_H4 || tagId == TAGID_H5)
            {

                IFC( spElement->QueryInterface(IID_IHTMLElement2, (void**)&spElement2) );


                if ( spElement2 )
                {

                    IFC( spElement->get_style( & spStyle) );
                    IFC( spElement2->get_currentStyle( & spCurrentStyle ) );
                    
                    SysFreeString( bstrStyleValue );
                    IFC( spCurrentStyle->get_margin(&bstrStyleValue) );
                    
                    if(bstrStyleValue && StrCmpC(_T("auto"), bstrStyleValue) != 0 )
                    {

                        COPY_STYLE_VARIANT( marginBottom );     // "auto" is default for margin
                        COPY_STYLE_VARIANT( marginTop );        
                        COPY_STYLE_VARIANT( marginRight );
                        COPY_STYLE_VARIANT( marginLeft );

                    }

                    if (tagId == TAGID_TD)
                    {
                        COPY_STYLE_VARIANT( backgroundColor );
                        COPY_STYLE_VARIANT( borderTopWidth );
                        COPY_STYLE_VARIANT( borderBottomWidth );
                        COPY_STYLE_VARIANT( borderLeftWidth );
                        COPY_STYLE_VARIANT( borderRightWidth );
                        COPY_STYLE_BSTR( borderTopStyle );          
                        COPY_STYLE_BSTR( borderBottomStyle );
                        COPY_STYLE_BSTR( borderLeftStyle );
                        COPY_STYLE_BSTR( borderRightStyle );
                        COPY_STYLE_VARIANT( borderTopColor );
                        COPY_STYLE_VARIANT( borderBottomColor );
                        COPY_STYLE_VARIANT( borderLeftColor );
                        COPY_STYLE_VARIANT( borderRightColor );
                    }
            
                }

#undef COPY_STYLE_VARIANT
#undef COPY_STYLE_BSTR
 
            }
        }

        IFC( pTemp->Right(TRUE, &ct, &spElement, NULL, NULL) );

    }
    
Cleanup:
    
    ReleaseInterface( pTemp );
    SysFreeString( bstrStyleValue );
    SysFreeString( bstrClassName );
    VariantClear( &vStyleValue );

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::CPasteCharFormatManager, public
//
//  Synopsis:   ctor
//
//  Arguments:  [pEd] -- CHTMLEditor pointer
//
//----------------------------------------------------------------------------

CPasteCharFormatManager::CPasteCharFormatManager(CHTMLEditor *pEd) 
: _aryCommands(Mt(CPasteCharFormatManager_aryCommands_pv) ),
_formatMap(Mt(CPasteCharFormatManager_formatMap_pv) )
{
    _pEd = pEd; 
    memset(&_rgFixupTable, 0, sizeof(_rgFixupTable));
}


//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::~CPasteCharFormatManager, public
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------

CPasteCharFormatManager::~CPasteCharFormatManager()
{
    int             i;
    CFormatMapInfo  *pFormatMapInfo;

    //
    // Release fixup table
    //    
    for (i = 0; i < FT_NumFormatTypes; ++i)
    {
        ReleaseInterface(_rgFixupTable[i]._pStart);
        VariantClear(&_rgFixupTable[i]._varValue);
    }

    //
    // Release format cache
    //

    for (i = _formatMap.Size(), pFormatMapInfo = _formatMap;
         i > 0;
         i--, pFormatMapInfo++)
    {
        pFormatMapInfo->_spComputedStyle = NULL;        // release computed style
        pFormatMapInfo->_spBlockComputedStyle = NULL;   // release computed style
    }   
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::SyncScanForTextStart, private
//
//  Synopsis:   Scan both pointers right for CONTEXT_TYPE_Text and break
//              before the text.
//
//  Arguments:  [pPointer] - pointer used for scan
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::ScanForTextStart(IMarkupPointer *pPointer, IMarkupPointer *pLastBlockPointer)
{
    HRESULT hr;
    LONG    cch = -1;

    // Search for CONTEXT_TYPE_Text from pTarget
    cch = -1;
    IFC( ScanForText(pPointer, NULL, &cch, pLastBlockPointer) );
    if (hr == S_FALSE)
        goto Cleanup;

    // Position pointers before text
    IFC( pPointer->Left(TRUE, NULL, NULL, &cch, NULL) );    
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::SyncScanForTextEnd, private
//
//  Synopsis:   Scan both pointers right for CONTEXT_TYPE_Text and break
//              after the text.  However, assure that both pointers moved
//              the same number of characters.
//
//  Arguments:  [pPointer1] - pointer1 used for scan
//              [pPointer2] - pointer2 used for scan
//              [pLimit1]   - rightmost limit for scan
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::SyncScanForTextEnd(CFormatMapPointer *pSource, IMarkupPointer *pTarget)
{
    HRESULT hr;
    LONG    cch1;
    LONG    cch = -1;
    BOOL    fDone = FALSE;

    // Scan format map pointer
    IFC( pSource->Right(&cch) );
    fDone = (hr == S_FALSE); // if fDone == TRUE, cch is still valid
    cch1 = cch;
    
    // Search for CONTEXT_TYPE_Text from pPointer2
    IFC( ScanForText(pTarget, NULL, &cch) );
    if (hr == S_FALSE)
        goto Cleanup;

    Assert(cch <= cch1);

    // Position pointers at min(cch1, cch2) so that we advance
    // both pointers the same cch
    if (cch < cch1)
    {
        cch = cch1 - cch;
        IFC( pSource->Left(&cch) );
    }

    hr = fDone ? S_FALSE : S_OK;
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::InitFixupTable, private
//
//  Synopsis:   Init the format fixup table
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::InitFixupTable()
{
    HRESULT         hr = S_OK;
    IMarkupPointer  *pPointer;

    for (int i = 0; i < FT_NumFormatTypes; ++i)
    {
        pPointer = _rgFixupTable[i]._pStart;
        if (pPointer)
            IFC( pPointer->Unposition() );

        VariantClear(&_rgFixupTable[i]._varValue);
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FireRegisteredCommands, private
//
//  Synopsis:   Fires all fixup commands
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::FireRegisteredCommands()
{
    HRESULT         hr = S_OK;
    CCommandParams  *pCmdParams;
    int             i;
    VARIANT         *pvarargIn = NULL;

    for (i = _aryCommands.Size(), pCmdParams = _aryCommands;
         i > 0;
         i--, pCmdParams++)
    {
        if (V_VT(&pCmdParams->_varValue) != VT_NULL)
            pvarargIn = &pCmdParams->_varValue;
            
        IFC( FireCommand(pCmdParams->_cmdId, pCmdParams->_pStart, pCmdParams->_pEnd, pvarargIn) ); 
        pCmdParams->_pStart->Release();
        pCmdParams->_pEnd->Release();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FireCommand, private
//
//  Synopsis:   Fire an editor command through a text range
//
//  Arguments:  [cmdId]     - command to fire
//              [pStart]    - range start
//              [pEnd]      - range end
//              [pvarargIn] - argument for command
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FireCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT                 hr = S_OK;
    GUID                    guidCmdGroup = CGID_MSHTML;
    SP_IOleCommandTarget    spCmdTarget;

    // create the text range (on demand)
    if (_spRange == NULL)
    {
        SP_IHTMLElement     spElement;
        SP_IHTMLBodyElement spBody;
    
        IFC( _pEd->GetBody(&spElement) );

        IFC( spElement->QueryInterface(IID_IHTMLBodyElement, (void **)&spBody) );
        IFC( spBody->createTextRange(&_spRange) );
    }
    
    Assert(_spRange != NULL);
    
    IFC( GetMarkupServices()->MoveRangeToPointers( pStart, pEnd, _spRange));
    
    // Fire the command

    IFC( _spRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&spCmdTarget) );

    //
    // Note that we may try to fixup content that can't accept HTML here.  
    // However, the commands will check and fail this operation.  So, since
    // the commands do the validation, we don't need to repeat it here.  Instead, 
    // just IGNORE_HR.
    //
    
    IGNORE_HR( spCmdTarget->Exec(&guidCmdGroup, cmdId, 0, pvarargIn, NULL) );


Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::RegisterCommand, private
//
//  Synopsis:   Register an editor command to be fired at some later point in time
//
//  Arguments:  [cmdId]     - command to fire
//              [pStart]    - range start
//              [pEnd]      - range end
//              [pvarargIn] - argument for command
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::RegisterCommand(DWORD cmdId, IMarkupPointer *pStart, IMarkupPointer *pEnd, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    CCommandParams  *pParams;

    IFC( _aryCommands.AppendIndirect(NULL, &pParams) );

    pParams->_cmdId = cmdId;

    IFC( _pEd->CreateMarkupPointer(&pParams->_pStart) );
    IFC( pParams->_pStart->MoveToPointer(pStart) );

    IFC( _pEd->CreateMarkupPointer(&pParams->_pEnd) );
    IFC( pParams->_pEnd->MoveToPointer(pEnd) );

    if (pvarargIn == NULL)
    {
        V_VT(&pParams->_varValue) = VT_NULL;
    }
    else
    {
        IFC( VariantCopy(&pParams->_varValue, pvarargIn) );
    }
    
Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupBoolCharFormat, private
//
//  Synopsis:   Fixup paste formatting for boolean format type like B, I, U.
//
//  Arguments:  [ft]               - formatting type
//              [cmdId]            - fixup command
//              [pPosition]        - position in target
//              [fFormattingEqual] - is source formatting equal
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupBoolCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual)
{
    HRESULT          hr = S_OK;
    BOOL             fPrevFormattingEqual;
    IMarkupPointer   *pPrevPointer = _rgFixupTable[ft]._pStart;

    fPrevFormattingEqual = TRUE;
    if (pPrevPointer)
    {
        BOOL fPositioned;
        
        IFC( pPrevPointer->IsPositioned(&fPositioned) );
        fPrevFormattingEqual = !fPositioned;
    }

    if (fPrevFormattingEqual && !fFormattingEqual)
    {
        //
        // Start a fixup segment
        //

        if (!pPrevPointer)
        {
            IFC( _pEd->CreateMarkupPointer(&_rgFixupTable[ft]._pStart) );
        }

        IFC( _rgFixupTable[ft]._pStart->MoveToPointer(pPosition) );
    }
    else if (!fPrevFormattingEqual && fFormattingEqual)
    {
        //
        // End a fixup segment
        //

#if DBG==1       
        BOOL fDbgIsPositioned;
        
        Assert(_rgFixupTable[ft]._pStart);
        
        IGNORE_HR(_rgFixupTable[ft]._pStart->IsPositioned(&fDbgIsPositioned));
        Assert(fDbgIsPositioned);
#endif        

        IFC( RegisterCommand(cmdId, _rgFixupTable[ft]._pStart, pPosition, NULL) );
        IFC( _rgFixupTable[ft]._pStart->Unposition() );
    }

Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupVariantCharFormat, private
//
//  Synopsis:   Fixup paste formatting for variant format type like font color, font size, etc...
//
//  Arguments:  [ft]               - formatting type
//              [cmdId]            - fixup command
//              [pPosition]        - position in target
//              [fFormattingEqual] - is source formatting equal
//              [pvarargIn]        - input variant
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupVariantCharFormat(FormatType ft, DWORD cmdId, IMarkupPointer *pPosition, BOOL fFormattingEqual, VARIANT *pvarargIn)
{
    HRESULT         hr = S_OK;
    BOOL            fPrevFormattingEqual;
    IMarkupPointer  *pPrevPointer = _rgFixupTable[ft]._pStart;
    BOOL            fValueChange = FALSE;

    fPrevFormattingEqual = TRUE;
    if (pPrevPointer)
    {
        BOOL fPositioned;
        
        IFC( pPrevPointer->IsPositioned(&fPositioned) );
        fPrevFormattingEqual = !fPositioned;
    }


    if (!fPrevFormattingEqual && !fFormattingEqual)
    {
        // Compare variants
        if (V_VT(pvarargIn) == VT_BSTR && V_VT(&_rgFixupTable[ft]._varValue) == VT_BSTR)
        {
            UINT iLen1 = SysStringLen(V_BSTR(&_rgFixupTable[ft]._varValue));
            UINT iLen2 = SysStringLen(V_BSTR(pvarargIn));

            if (iLen1 != iLen2)
                fValueChange = TRUE;
            else
                fValueChange = memcmp(V_BSTR(pvarargIn), V_BSTR(&_rgFixupTable[ft]._varValue), min(iLen1, iLen2));
        }
        else
        {
            fValueChange = memcmp(pvarargIn, &_rgFixupTable[ft]._varValue, sizeof(VARIANT));
        }
    }

    if (!fPrevFormattingEqual && (fFormattingEqual || fValueChange))
    {
        //
        // End a fixup segment
        //

        IFC( RegisterCommand(cmdId, _rgFixupTable[ft]._pStart, pPosition, &_rgFixupTable[ft]._varValue) );
        IFC( _rgFixupTable[ft]._pStart->Unposition() );
        IFC( VariantClear(&_rgFixupTable[ft]._varValue) );
    }

    if (fValueChange || (fPrevFormattingEqual && !fFormattingEqual))
    {
        //
        // Start a fixup segment
        //

        if (!pPrevPointer)
        {
            IFC( _pEd->CreateMarkupPointer(&_rgFixupTable[ft]._pStart) );
        }

        IFC( _rgFixupTable[ft]._pStart->MoveToPointer(pPosition) );
        IFC( VariantClear(&_rgFixupTable[ft]._varValue) );
        IFC( VariantCopy(&_rgFixupTable[ft]._varValue, pvarargIn) );
    }

Cleanup:
    RRETURN(hr);    
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FinishFixup, private
//
//  Synopsis:   Closes all open fixup ranges
//
//  Arguments:  [pTarget] - end of fixup range
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FinishFixup(
    IMarkupPointer *pTarget, BOOL fFixupOrderedList)
{
    HRESULT hr;
    VARIANT varargIn;
    
    //
    // Fixup bool-style formatting
    //    

    IFC( FixupBoolCharFormat(FT_Bold, IDM_BOLD, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Italic, IDM_ITALIC, pTarget, TRUE) );   
    IFC( FixupBoolCharFormat(FT_Underline, IDM_UNDERLINE, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Subscript, IDM_SUBSCRIPT, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Superscript, IDM_SUPERSCRIPT, pTarget, TRUE) );
    IFC( FixupBoolCharFormat(FT_Strikethrough, IDM_STRIKETHROUGH, pTarget, TRUE) );

    if (fFixupOrderedList)
    {
        IFC( FixupBoolCharFormat(FT_OrderedList, IDM_ORDERLIST, pTarget, TRUE) );
    }

    //
    // Fixup variant based formatting
    //    
    V_VT(&varargIn) = VT_NULL;

    IFC( FixupVariantCharFormat(FT_FontSize, IDM_FONTSIZE, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_ForeColor, IDM_FORECOLOR, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_BackColor, IDM_BACKCOLOR, pTarget, TRUE, &varargIn) );
    IFC( FixupVariantCharFormat(FT_FontFace, IDM_FONTNAME, pTarget, TRUE, &varargIn) );

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupPosition, private
//
//  Synopsis:   Fixup paste formatting at current pSource (and pTarget) using 
//              format cache info
//
//  Arguments:  [pSource]          - source position
//              [pTarget]          - matching target position
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupPosition(
    CFormatMapPointer    *pSource, 
    IMarkupPointer       *pTarget,
    IMarkupPointer       *pBlockTarget,
    BOOL                  fFixupOrderedList,
    BOOL                  fForceFixup)
{
    HRESULT                 hr;
    VARIANT                 varargIn;
    BOOL                    fEqual;
    SP_IHTMLComputedStyle   spStyleSource, spStyleSourceBlock;
    SP_IHTMLComputedStyle   spStyleTarget, spStyleTargetBlock;
    VARIANT_BOOL            bSourceAttribute, bTargetAttribute;
    VARIANT_BOOL            bSourceBlockAttribute, bTargetBlockAttribute;
    VARIANT_BOOL            fAllEqual;
    LONG                    lHeightTarget, lHeightSource;
    DWORD                   dwColorTarget, dwColorSource;
    LONG                    lHeightTargetBlock, lHeightSourceBlock;
    DWORD                   dwColorTargetBlock, dwColorSourceBlock;
    
    VariantInit(&varargIn);

    // 
    // Get the format cache info at the source/target
    //

    spStyleSource = pSource->GetComputedStyle();
    if (spStyleSource == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    spStyleSourceBlock = pSource->GetBlockComputedStyle();
    if (spStyleSourceBlock == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }        

    IFC( GetDisplayServices()->GetComputedStyle(pTarget, &spStyleTarget) );
    if (spStyleTarget == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( GetDisplayServices()->GetComputedStyle(pBlockTarget, &spStyleTargetBlock) );
    if (spStyleTargetBlock == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( spStyleSource->IsEqual(spStyleTarget, &fAllEqual) );
    
    //
    // Fixup bool-style formatting
    //    

#define FIXUP_FORMATTING(index, cmd, attr)                                      \
    if (fAllEqual == VB_TRUE)                                                   \
    {                                                                           \
        IFC( FixupBoolCharFormat(index, cmd, pTarget, TRUE) );                  \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        IFC( spStyleSource->get_ ## attr(&bSourceAttribute) );                  \
        IFC( spStyleTarget->get_ ## attr(&bTargetAttribute) )                   \
        IFC( spStyleSourceBlock->get_ ## attr(&bSourceBlockAttribute) );        \
        IFC( spStyleTargetBlock->get_ ## attr(&bTargetBlockAttribute) );        \
        fEqual = !ShouldFixupFormatting(bSourceAttribute, bSourceBlockAttribute, bTargetAttribute, bTargetBlockAttribute, fForceFixup);  \
        IFC( FixupBoolCharFormat(index, cmd, pTarget, fEqual) );                \
    }                                                                         

    
    FIXUP_FORMATTING( FT_Bold, IDM_BOLD, bold );
    FIXUP_FORMATTING( FT_Italic, IDM_ITALIC, italic );   
    FIXUP_FORMATTING( FT_Underline, IDM_UNDERLINE, underline );
    FIXUP_FORMATTING( FT_Subscript, IDM_SUBSCRIPT, subScript );
    FIXUP_FORMATTING( FT_Superscript, IDM_SUPERSCRIPT, superScript );
    FIXUP_FORMATTING( FT_Strikethrough, IDM_STRIKETHROUGH, strikeOut);
#undef FIXUP_FORMATTING

    if (fFixupOrderedList)
    {
        IFC( spStyleSource->get_OL(&bSourceAttribute) );
        IFC( spStyleTarget->get_OL(&bTargetAttribute) );

        fEqual = (bSourceAttribute == bTargetAttribute);

        IFC( FixupBoolCharFormat(FT_OrderedList, IDM_ORDERLIST, pTarget, fEqual) );              
    }

    //
    // Fixup variant based formatting
    //    

    // Font size
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        IFC( spStyleSource->get_fontSize(&lHeightSource) );
        IFC( spStyleTarget->get_fontSize(&lHeightTarget) );
        fEqual = (lHeightSource == lHeightTarget);
        if (!fEqual)
        {
            IFC( spStyleSourceBlock->get_fontSize(&lHeightSourceBlock) );
            IFC( spStyleTargetBlock->get_fontSize(&lHeightTargetBlock) );
            fEqual = !ShouldFixupFormatting(lHeightSource, lHeightSourceBlock, lHeightTarget, lHeightTargetBlock, fForceFixup);
        }
        if (!fEqual)
        {
            V_VT(&varargIn) = VT_I4;
            V_I4(&varargIn) = EdUtil::ConvertTwipsToHtmlSize(lHeightSource);
        }   
    }
    IFC( FixupVariantCharFormat(FT_FontSize, IDM_FONTSIZE, pTarget, fEqual, &varargIn) );
    
    // Fore color
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
         IFC( spStyleSource->get_textColor(&dwColorSource) );
         IFC( spStyleTarget->get_textColor(&dwColorTarget) );
         fEqual = (dwColorSource == dwColorTarget);
         if (!fEqual)
         {
             IFC( spStyleSourceBlock->get_textColor(&dwColorSourceBlock) );
             IFC( spStyleTargetBlock->get_textColor(&dwColorTargetBlock) );
             fEqual = !ShouldFixupFormatting(dwColorSource, dwColorSourceBlock, dwColorTarget, dwColorTargetBlock, fForceFixup);
         }
         if (!fEqual)
         {
             V_VT(&varargIn) = VT_I4;
             V_I4(&varargIn) = ConvertRGBColorToOleColor(dwColorSource);
         }   
    }
    IFC( FixupVariantCharFormat(FT_ForeColor, IDM_FORECOLOR, pTarget, fEqual, &varargIn) );

    // Background color
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        IFC( spStyleSource->get_hasBgColor(&bSourceAttribute) );
        IFC( spStyleTarget->get_hasBgColor(&bTargetAttribute) );
        fEqual = (bSourceAttribute == FALSE);
        if (!fEqual)
        {
            IFC( spStyleSource->get_backgroundColor(&dwColorSource) );
            IFC( spStyleTarget->get_backgroundColor(&dwColorTarget) );
            fEqual = (dwColorSource == dwColorTarget);
            if (!fEqual)
            {
                IFC( spStyleSourceBlock->get_backgroundColor(&dwColorSourceBlock) );
                IFC( spStyleTargetBlock->get_backgroundColor(&dwColorTargetBlock) );
                fEqual = !ShouldFixupFormatting(dwColorSource, dwColorSourceBlock, dwColorTarget, dwColorTargetBlock, fForceFixup);
            }
            if (!fEqual)
            {
                V_VT(&varargIn) = VT_I4;
                V_I4(&varargIn) = ConvertRGBColorToOleColor(dwColorSource);
            }
        }
    }
    IFC( FixupVariantCharFormat(FT_BackColor, IDM_BACKCOLOR, pTarget, fEqual, &varargIn) );

    // Font face 
    fEqual = BOOL_FROM_VARIANT_BOOL(fAllEqual);
    if (!fEqual)
    {
        TCHAR szFontNameSource[LF_FACESIZE+1];
        TCHAR szFontNameTarget[LF_FACESIZE+1];

        IFC( spStyleSource->get_fontName(szFontNameSource) );
        IFC( spStyleTarget->get_fontName(szFontNameTarget) );
        
        fEqual = (_tcscmp(szFontNameSource, szFontNameTarget) == 0);
        if (!fEqual)
        {
            TCHAR szFontNameSourceBlock[LF_FACESIZE+1];
            TCHAR szFontNameTargetBlock[LF_FACESIZE+1];            

            IFC( spStyleSourceBlock->get_fontName(szFontNameSourceBlock) );
            IFC( spStyleTargetBlock->get_fontName(szFontNameTargetBlock) );

            fEqual = !ShouldFixupFormatting(szFontNameSource, szFontNameSourceBlock, szFontNameTarget, szFontNameTargetBlock, fForceFixup);            
        }
        
        if (!fEqual)
        {
            V_VT(&varargIn) = VT_BSTR;
            V_BSTR(&varargIn) = SysAllocString(szFontNameSource);
        }   
    }
    IFC( FixupVariantCharFormat(FT_FontFace, IDM_FONTNAME, pTarget, fEqual, &varargIn) );

Cleanup:
    VariantClear(&varargIn);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::FixupFormatting, private
//
//  Synopsis:   Fixup paste formatting for pasted range
//
//  Arguments:  [pSourceStart]     - source start position
//              [pSourceFinish]    - source finish position
//              [pTarget]          - target for paste
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CPasteCharFormatManager::FixupFormatting(
    IMarkupPointer  *pTarget,
    BOOL             fFixupOrderedList,
    BOOL             fForceFixup)
{
    HRESULT             hr ;
    SP_IMarkupPointer   spTargetCurrent;
    CFormatMapPointer   formatMapPointer(&_formatMap);
    CEditPointer        epLastBlockPointer(_pEd);
    DWORD               dwFound;

    IFC( _pEd->CreateMarkupPointer(&spTargetCurrent) );

    //
    // If there was no text being pasted, we don't need to fixup the formatting
    //

    if (_formatMap.Size() == 0)
    {
        hr = S_OK;
        goto Cleanup;
    }

    IFC( InitFixupTable() );
    
    //
    // Move sourceCurrent and targetCurrent to pSourceStart and pTarget
    //

    IFC( spTargetCurrent->MoveToPointer(pTarget) );
    IFC( spTargetCurrent->SetGravity(POINTER_GRAVITY_Right) );

    //
    // Position spLastBlockPointer so that the loop below can always assume it has a positioned pointer
    //

    IFC( epLastBlockPointer->MoveToPointer(spTargetCurrent) );
    IFC( epLastBlockPointer.Scan(LEFT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    // Make sure we have some block.  Since we're always in the body or a table, we should
    // not walk off the edge of the document.
    Assert(epLastBlockPointer.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site) );

    IFC( epLastBlockPointer.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    //
    // Scan until we see text
    //
    
    do
    { 
        IFC( ScanForTextStart(spTargetCurrent, epLastBlockPointer) );    
        if (hr == S_FALSE)
            break;

        IFC( FixupPosition(&formatMapPointer, spTargetCurrent, epLastBlockPointer, fFixupOrderedList, fForceFixup) );
        
        //
        // Scan for next text block
        //        
        
        IFC( SyncScanForTextEnd(&formatMapPointer, spTargetCurrent) );    
    }
    while (hr != S_FALSE);

    //
    // Flush formatting
    //

    IFC( FinishFixup(spTargetCurrent, fFixupOrderedList) );
    IFC( FireRegisteredCommands() );

    // Proper termination
    hr = S_OK; 
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::ComputeFormatMap, private
//
//  Synopsis:   Remember formatting from source markup
//
//  Arguments:  [pSourceStart]     - source start position
//              [pSourceFinish]    - source finish position
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CPasteCharFormatManager::ComputeFormatMap(        
        IMarkupPointer  *pSourceStart, 
        IMarkupPointer  *pSourceFinish)
{                
    HRESULT             hr ;
    SP_IMarkupPointer   spSourceCurrent;
    CEditPointer        epLastBlockPointer(_pEd);
    LONG                cchNext = -1;
    CFormatMapInfo      *pFormatInfo;
    DWORD               dwFound;

    AssertSz(_formatMap.Size() == 0, "ComputeFormatMap called more than once");

    IFC( _pEd->CreateMarkupPointer(&spSourceCurrent) );
    IFC( _pEd->CreateMarkupPointer(&epLastBlockPointer) );

    //
    // Position spLasteBlockPointer so that the loop below can always assume it has a positioned pointer
    //

    IFC( epLastBlockPointer->MoveToPointer(pSourceStart) );
    IFC( epLastBlockPointer.Scan(LEFT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );

    // Make sure we have some block.  Since we're always in the body or a table, we should
    // not walk off the edge of the document.
    Assert(epLastBlockPointer.CheckFlag(dwFound, BREAK_CONDITION_Block | BREAK_CONDITION_Site) );

    IFC( epLastBlockPointer.Scan(RIGHT, BREAK_CONDITION_Block | BREAK_CONDITION_Site, &dwFound) );
    
    //
    // Compute the format map
    //
    
    IFC( spSourceCurrent->MoveToPointer(pSourceStart) );
    do
    { 
        //
        // Scan for text
        //
        cchNext = -1;
        IFC( ScanForText(spSourceCurrent, pSourceFinish, &cchNext, epLastBlockPointer) );
        if (hr == S_FALSE)
            break; 

        //
        // Add to format map
        //
        IFC( _formatMap.AppendIndirect(NULL, &pFormatInfo) );

        pFormatInfo->_cchNext = cchNext;
        IFC( GetDisplayServices()->GetComputedStyle(spSourceCurrent, &pFormatInfo->_spComputedStyle) );
        IFC( GetDisplayServices()->GetComputedStyle(epLastBlockPointer, &pFormatInfo->_spBlockComputedStyle) );
    }
    while (hr != S_FALSE);

    //
    // proper termination
    //
    
    hr = S_OK;
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::CFormatMapPointer, public
//
//  Synopsis:   ctor
//
//  Arguments:  [pFormatMap] - Format map pointer
//
//----------------------------------------------------------------------------
CFormatMapPointer::CFormatMapPointer(CFormatMap *pFormatMap)
{
    Assert(pFormatMap);

    _iCurrentFormat = 0;
    _icch = 0;
    _pFormatMap = pFormatMap;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::Right, public
//
//  Synopsis:   Moves format pointer pCch characters through the format map.
//              if *pCch < 0, the pointer is moved to the position in the 
//              format map
//
//  Arguments:  [pCch] - Number of characters moved.  Also used to return 
//                       characters actually moved.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CFormatMapPointer::Right(LONG *pCch)
{
    HRESULT         hr = S_OK;
    CFormatMapInfo  *pFormatInfo;

    Assert(pCch);    
    Assert(_iCurrentFormat < _pFormatMap->Size());

    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    Assert(pFormatInfo && _icch < pFormatInfo->_cchNext);

    if (*pCch == -1)
    {
        *pCch = pFormatInfo->_cchNext - _icch;
    }
    else
    {
        *pCch = min(*pCch, LONG(pFormatInfo->_cchNext - _icch));
    }

     _icch += *pCch;
        
    if (_icch >= pFormatInfo->_cchNext)
    {
        if (_iCurrentFormat >= _pFormatMap->Size() - 1)
        {
            hr = S_FALSE;
            goto Cleanup;
        }

        _icch = 0;        
        _iCurrentFormat++;            
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPasteCharFormatManager::Left, public
//
//  Synopsis:   Moves format pointer pCch characters left through the
//              format map.
//
//              NOTE: left doesn't currently support moving to the 
//              previous format map entry
//
//  Arguments:  [pCch] - Number of characters moved.  Also used to return 
//                       characters actually moved.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CFormatMapPointer::Left(LONG *pCch)
{
    HRESULT         hr = S_OK;
    CFormatMapInfo  *pFormatInfo;

    Assert(pCch && *pCch > 0);    
    Assert(_iCurrentFormat < _pFormatMap->Size());

    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    Assert(pFormatInfo && _icch < pFormatInfo->_cchNext && *pCch < _icch);

    _icch -= *pCch;
    
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::GetComputedStyle, public
//
//  Synopsis:   Gets the IHTMLComputedStyle object.
//
//  Returns:    IHTMLComputedStyle*
//
//----------------------------------------------------------------------------
IHTMLComputedStyle *
CFormatMapPointer::GetComputedStyle()
{
    CFormatMapInfo *pFormatInfo;

    Assert(_iCurrentFormat < _pFormatMap->Size());
    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    
    return  pFormatInfo->_spComputedStyle;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFormatMapPointer::GetBlockComputedStyle, public
//
//  Synopsis:   Gets the IHTMLComputedStyle object.
//
//  Returns:    IHTMLComputedStyle*
//
//----------------------------------------------------------------------------
IHTMLComputedStyle *
CFormatMapPointer::GetBlockComputedStyle()
{
    CFormatMapInfo *pFormatInfo;

    Assert(_iCurrentFormat < _pFormatMap->Size());
    pFormatInfo = _pFormatMap->Item(_iCurrentFormat);
    
    return  pFormatInfo->_spBlockComputedStyle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\mshtmled.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       MSHTMLED.CXX
//
//  Contents:   Implementation of Mshtml Editing Component
//
//  Classes:    CMshtmlEd
//
//  History:    7-Jan-98   raminh  Created
//             12-Mar-98   raminh  Converted over to use ATL
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef _X_HTMLED_HXX_
#define _X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDUTIL_HXX_
#define _X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef _X_CHARCMD_HXX_
#define _X_CHARCMD_HXX_
#include "charcmd.hxx"
#endif
#ifndef _X_INSCMD_HXX_
#define _X_INSCMD_HXX_
#include "inscmd.hxx"
#endif
#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif
#ifndef _X_DLGCMD_HXX_
#define _X_DLGCMD_HXX_
#include "dlgcmd.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif

MtDefine(CMshtmlEd, Utilities, "CMshtmlEd")

extern HRESULT      InsertObject (UINT cmdID, LPTSTR pstrParam, IHTMLTxtRange * pRange, HWND hwnd);
extern HRESULT      ShowEditDialog(UINT idm, VARIANT * pvarExecArgIn, HWND hwndParent, VARIANT * pvarArgReturn);

extern "C" const GUID CGID_EditStateCommands;

DeclareTag(tagEditingTrackQueryStatusFailures, "Edit", "Track query status failures")
ExternTag(tagEditingTrackExecFailures);
ExternTag(tagEditingExecRouting);

//+---------------------------------------------------------------------------
//
//  CMshtmlEd Constructor
//
//----------------------------------------------------------------------------
CMshtmlEd::CMshtmlEd( CHTMLEditor * pEd, BOOL fRange )
                        : _sl(this)
{
    Assert( pEd );
    Assert (_pISegList == NULL);
    Assert (_pSelectionServices == NULL);
    Assert (_fMultipleSelection == FALSE);          
    Assert (_fLiveResize == FALSE);
    Assert (_f2DPositionMode == FALSE);
    Assert (_fDisableEditFocusHandles == FALSE);    
    Assert (_fNoActivateNormalOleControls == FALSE);    
    Assert (_fNoActivateDesignTimeControls == FALSE);
    Assert (_fNoActivateJavaApplets == FALSE);;        
    Assert (_fInitialized == FALSE);
    
    _pEd = pEd;
    _cRef = 1;
    SetRange(fRange);
}


CMshtmlEd::~CMshtmlEd()
{
    ReleaseInterface( _pISegList );
    ReleaseInterface( _pIContainer );
    ReleaseInterface( (ISegmentList *)_pSelectionServices );
}


HRESULT
CMshtmlEd::Initialize( IUnknown *pContext )
{
    HRESULT hr = S_OK;

    //
    // If we have a range, then the context must be passed in (as we retrieve
    // the ISegmentList pointer off the context).  If we don't have a range, we
    // are being attached to an IHTMLDocument2 pointer, and we need to create
    // a selection services for this pointer
    //
#if DBG == 1
    {
        SP_IMarkupContainer spContainer;
        SP_ISegmentList     spSegList;

        if( _fRange )
        {
            IFC( pContext->QueryInterface( IID_ISegmentList, (void **)&spSegList ) );
            AssertSz( spSegList.p, "CMshtmlEd::Initialize: Trying to initialize a range based CMshtmlEd without an ISegmentList" );
        }
        else
        {
            IFC( pContext->QueryInterface( IID_IMarkupContainer, (void **)&spContainer ) );
            AssertSz( spContainer.p, "CMshtmlEd::Initialize: Trying to initialize a document based CMshtmlEd without an IHTMLDocument2" );
        }
    }
#endif // DBG
    
    if ( !_fRange )
    {       
        // Grab the IMarkupContainer interface
        IFC( pContext->QueryInterface( IID_IMarkupContainer, (void **)&_pIContainer ) );

        Assert( _pIContainer );
        
        //
        // We are a document command target.  Create a selection services pointer
        // to contain the selected segments for this doc.
        //
        _pSelectionServices = new CSelectionServices();
        if( !_pSelectionServices )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        IFC( _pSelectionServices->Init( _pEd, _pIContainer ) );
        IFC( _pSelectionServices->QueryInterface( IID_ISegmentList, (void **)&_pISegList ) );
    }
    else
    {
        IFC( pContext->QueryInterface( IID_ISegmentList, (void **)&_pISegList ) );
    }
        
    _fInitialized = TRUE;
    
Cleanup:
    RRETURN(hr);
}    


//////////////////////////////////////////////////////////////////////////
//
//  Public Interface CCaret::IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CMshtmlEd::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CMshtmlEd::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CMshtmlEd::QueryInterface(
    REFIID              iid, 
    LPVOID *            ppv )
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    *ppv = NULL;
    
    if( iid == IID_IUnknown )
    {
        *ppv = static_cast< IUnknown * >( this );
    }
    else if( iid == IID_IOleCommandTarget )
    {
        *ppv = static_cast< IOleCommandTarget * >( this );
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
    
}

BOOL
CMshtmlEd::IsDialogCommand(DWORD nCmdexecopt, DWORD nCmdID, VARIANT *pvarargIn)
{
    BOOL bResult = FALSE;
    
    if (nCmdID == IDM_HYPERLINK)
    {
        bResult = (pvarargIn == NULL) || (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER);
    }
    else if (nCmdID == IDM_IMAGE || nCmdID == IDM_FONT)
    {
        bResult = (nCmdexecopt != OLECMDEXECOPT_DONTPROMPTUSER);
    }
    
    return bResult;
}


//+---------------------------------------------------------------------------
//
//  CMshtmlEd IOleCommandTarget Implementation for Exec() 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CMshtmlEd::Exec( const GUID *       pguidCmdGroup,
                       DWORD        nCmdID,
                       DWORD        nCmdexecopt,
                       VARIANTARG * pvarargIn,
                       VARIANTARG * pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    CCommand* theCommand = NULL;

    Assert( *pguidCmdGroup == CGID_MSHTML );
    Assert( _pEd );
    Assert( _pEd->GetDoc() );
    Assert( _pISegList );

    ((IHTMLEditor*) GetEditor())->AddRef();

    // ShowHelp is not implemented 
    if(nCmdexecopt == OLECMDEXECOPT_SHOWHELP)
        goto Cleanup;

    //
    // Do any pending tasks.
    //
    //
    // Dont do this for ComposeSettings, as the pending tasks, may cause the caret 
    // to attempt a scroll in the middle of a measure ( which will assert )
    //
    if ( nCmdID != IDM_COMPOSESETTINGS )
    {
        IFC( GetEditor()->DoPendingTasks() );
    }
    
    //
    // Give the editor a chance to route this exec to any external components
    // 
    IFC( GetEditor()->InternalExec( pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut ) );
    
    if( hr == S_OK )
        goto Cleanup;
    
    switch (nCmdID)
    {
        case IDM_NOACTIVATENORMALOLECONTROLS:
        case IDM_NOACTIVATEDESIGNTIMECONTROLS:
        case IDM_NOACTIVATEJAVAAPPLETS:
        {
            if (!pvarargIn || V_VT(pvarargIn) != VT_BOOL)
                return E_INVALIDARG;

            BOOL fSet = ENSURE_BOOL(V_BOOL(pvarargIn));

            if (nCmdID == IDM_NOACTIVATENORMALOLECONTROLS)
                SetNoActivateNormalOleControls(fSet);
            else if (nCmdID == IDM_NOACTIVATEDESIGNTIMECONTROLS)
                SetNoActivateDesignTimeControls(fSet);
            else if (nCmdID == IDM_NOACTIVATEJAVAAPPLETS)
                SetNoActivateJavaApplets(fSet);

            hr = S_OK;
            goto Cleanup;
        }

        default:
            break;
    }

    if (IsDialogCommand(nCmdexecopt, nCmdID, pvarargIn) )
    {
        // Special case for image or hyperlink or font dialogs
        theCommand = _pEd->GetCommandTable()->Get( ~nCmdID );    
    }
    else
    {
        theCommand = _pEd->GetCommandTable()->Get( nCmdID );
    }
    
    if ( theCommand )
    {
        hr = theCommand->Exec( nCmdexecopt, pvarargIn, pvarargOut, this );
    }
    else
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

#if DBG==1
    if (IsTagEnabled(tagEditingTrackExecFailures))
    {
        if (FAILED(hr))
        {
            CHAR szBuf[1000];

            wsprintfA(szBuf, "CHTMLEditor::Exec failed: nCmdId=%d, nCmdexecopt=0x%x, pvarargIn=0x%x, pvarargOut=0x%x",
                    nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            AssertSz(0, szBuf);
        }
    }
#endif    

Cleanup:

    ((IHTMLEditor*) GetEditor())->Release();

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  CMshtmlEd IOleCommandTarget Implementation for QueryStatus()
//
//  Note: QueryStatus() is still being handled by Trident
//----------------------------------------------------------------------------
STDMETHODIMP
CMshtmlEd::QueryStatus(
        const GUID * pguidCmdGroup,
        ULONG cCmds,
        OLECMD rgCmds[],
        OLECMDTEXT * pcmdtext)
{
    HRESULT   hr = OLECMDERR_E_NOTSUPPORTED ;
    CCommand *theCommand = NULL;
    OLECMD   *pCmd = &rgCmds[0];

    Assert( *pguidCmdGroup == CGID_MSHTML );
    Assert( _pEd );
    Assert( _pEd->GetDoc() );
    Assert( _pISegList );
    Assert( cCmds == 1 );

    //
    // Give the editor a chance to intercept this query for any registered components
    // 
    IFC( GetEditor()->InternalQueryStatus( pguidCmdGroup, cCmds, rgCmds, pcmdtext ) );

    if (hr == S_OK && pCmd->cmdf)
        goto Cleanup;
    
    // TODO: The dialog commands are hacked with strange tagId's.  So, for now we just
    // make sure the right command gets the query status [ashrafm]
    
    if (pCmd->cmdID == IDM_FONT)
    {
        theCommand = GetEditor()->GetCommandTable()->Get( ~(pCmd->cmdID)  );
    }
    else
    {
        theCommand = GetEditor()->GetCommandTable()->Get( pCmd->cmdID  );
    }
    
    if (theCommand )
    {
        hr = theCommand->QueryStatus( pCmd, pcmdtext, this );                      
    }
    else 
    {
        hr = OLECMDERR_E_NOTSUPPORTED;
    }

#if DBG==1
    if (IsTagEnabled(tagEditingTrackQueryStatusFailures))
    {
        if (FAILED(hr))
        {
            CHAR szBuf[1000];

            wsprintfA(szBuf, "CMshtmlEd::QueryStatus failed: nCmdId=%d", pCmd->cmdID);
            AssertSz(0, szBuf);
        }
    }
#endif

Cleanup:
    RRETURN ( hr ) ;
}


HRESULT 
CMshtmlEd::GetSegmentList( ISegmentList **ppSegmentList ) 
{ 
    HRESULT hr = S_OK;

    Assert( ppSegmentList && IsInitialized() && _pISegList);
    
    IFC(  _pISegList->QueryInterface( IID_ISegmentList, (void **)ppSegmentList ));

Cleanup:    
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\libmain.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       LIBMAIN.CXX
//
//  Contents:   DLL implementation for MSHTMLED
//
//  History:    7-Jan-98   raminh  Created
//             12-Mar-98   raminh  Converted over to use ATL
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_RESOURCE_H_
#define X_RESOURCE_H_
#include "resource.h"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#include "initguid.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#include "optshold_i.c"

#ifndef X_DLGHELPR_H_
#define X_DLGHELPR_H_
#include "dlghelpr.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef _X_EDTRACK_HXX_
#define _X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_EDUTIL_H_
#define X_EDUTIL_H_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_H_
#define X_EDCMD_H_
#include "edcmd.hxx"
#endif

#ifndef X_BLOCKCMD_H_
#define X_BLOCKCMD_H_
#include "blockcmd.hxx"
#endif

#ifndef _X_MISCCMD_HXX_
#define _X_MISCCMD_HXX_
#include "misccmd.hxx"
#endif

#ifndef NO_IME
#ifndef X_DIMM_H_
#define X_DIMM_H_
#include "dimm.h"
#endif
#endif

#ifndef X_RTFTOHTM_HXX_
#define X_RTFTOHTM_HXX_
#include "rtftohtm.hxx"
#endif

MtDefine(OpNewATL, Mem, "operator new (mshtmled ATL)")

//
// Misc stuff to keep the linker happy
//
DWORD               g_dwFALSE = 0;          // Used for assert to fool the compiler
EXTERN_C HANDLE     g_hProcessHeap = NULL;  // g_hProcessHeap is set by the CRT in dllcrt0.c
HINSTANCE           g_hInstance = NULL;
HINSTANCE           g_hEditLibInstance = NULL;

BOOL                g_fInVizAct2000;
BOOL                g_fInPhotoSuiteIII;
BOOL                g_fInVid = FALSE ;

#ifdef DLOAD1
// Module handle for delay load error hook
extern "C" HANDLE BaseDllHandle;
           HANDLE BaseDllHandle;
#endif

// Below is the trick used to make ATL use our memory allocator
void    __cdecl ATL_free(void * pv) { MemFree(pv); }
void *  __cdecl ATL_malloc(size_t cb) { return(MemAlloc(Mt(OpNewATL), cb)); }
void *  __cdecl ATL_realloc(void * pv, size_t cb)
{
    void * pvNew = pv;
    HRESULT hr = MemRealloc(Mt(OpNewATL), &pvNew, cb);
    return(hr == S_OK ? pvNew : NULL);
}

//
// For the Active IMM (aka DIMM)
//
// This object is cocreated inside mshtml.  We need to get the
// pointer from mshtml because DIMM needs to intercept IMM32 calls. Currently
// DIMM functionality is crippled because we never set g_pActiveIMM.
//

#ifndef NO_IME
CRITICAL_SECTION g_csActiveIMM ; // Protect access to IMM
int g_cRefActiveIMM = 0;    // Local Ref Count for acess to IMM
IActiveIMMApp * g_pActiveIMM = NULL;
BOOL HasActiveIMM() { return g_pActiveIMM != NULL; }
IActiveIMMApp * GetActiveIMM() { return g_pActiveIMM; }
#endif

//
// CComModule and Object map for ATL
//

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_HtmlDlgHelper, CHtmlDlgHelper)
    OBJECT_ENTRY(CLSID_HtmlDlgSafeHelper, CHtmlDlgSafeHelper)
    OBJECT_ENTRY(CLSID_HTMLEditor, CHTMLEditorProxy)
END_OBJECT_MAP()

#ifdef UNIX
void DeinitDynamicLibraries();
#endif

//+----------------------------------------------------------------------------
//
// Function: DllMain
//
//+----------------------------------------------------------------------------
#ifdef UNIX
extern "C"
#endif
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    BOOL fInit = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef UNIX // Unix setup doesn't invoke COM. Need to do it here.
        CoInitialize(NULL);
#endif
        _Module.Init(ObjectMap, hInstance);
        CEditTracker::InitMetrics();
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
#ifdef DLOAD1
        BaseDllHandle = hInstance;
#endif
        if (CGetBlockFmtCommand::Init() != S_OK)
            fInit = FALSE;
        else if (CComposeSettingsCommand::Init() != S_OK)
            fInit = FALSE;
        else if (CRtfToHtmlConverter::Init() != S_OK)
            fInit = FALSE;            

        InitUnicodeWrappers();

        char szModule[MAX_PATH];
        GetModuleFileNameA(NULL, szModule, MAX_PATH);
        g_fInVizAct2000 = NULL != StrStrIA(szModule, "vizact.exe");
        g_fInPhotoSuiteIII = NULL != StrStrIA(szModule, "PhotoSuite.exe");

#if DBG==1

    //  Tags for the .dll should be registered before
    //  calling DbgExRestoreDefaultDebugState().  Do this by
    //  declaring each global tag object or by explicitly calling
    //  DbgExTagRegisterTrace.

    DbgExRestoreDefaultDebugState();

#endif // DBG==1

#ifdef UNIX
        CoUninitialize();
#endif
#ifndef NO_IME
        if (HrInitializeCriticalSection(&g_csActiveIMM) != S_OK)
            fInit = FALSE;
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
#ifndef UNIX    // because of the extern "C" change above
        extern void DeinitDynamicLibraries();
#endif
        _Module.Term();
        CGetBlockFmtCommand::Deinit();
        CComposeSettingsCommand::Deinit();
        CRtfToHtmlConverter::Deinit();
        DeinitDynamicLibraries();

#ifndef NO_IME
        DeleteCriticalSection( & g_csActiveIMM );
#endif        
    }
    return fInit;    
}

static BOOL DllCanUnloadNowAlwaysFalse()
{
    HKEY  hKey;
    DWORD dwCount = sizeof(DWORD);
	static DWORD dwDllCanUnloadNowAlways = (DWORD)-1;

    if(dwDllCanUnloadNowAlways == -1)
    {   
        if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Internet Explorer\\Main"), 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS != RegQueryValueEx( hKey, _T("UnloadED"), NULL, NULL, (LPBYTE)&dwDllCanUnloadNowAlways, &dwCount))
				dwDllCanUnloadNowAlways = 0;
			RegCloseKey(hKey);
        }
    }

    return dwDllCanUnloadNowAlways;
}


//+----------------------------------------------------------------------------
//
// Function: DllCanUnloadNow
//
// Used to determine whether the DLL can be unloaded by OLE
//+----------------------------------------------------------------------------
STDAPI 
DllCanUnloadNow(void)
{
    if(DllCanUnloadNowAlwaysFalse())
        return S_FALSE;
    else
        return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
// Function: DllClassObject
//
// Returns a class factory to create an object of the requested type
//+----------------------------------------------------------------------------
STDAPI 
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

//+----------------------------------------------------------------------------
//
// Function: DllRegisterServer
//
// Adds entries to the system registry
//+----------------------------------------------------------------------------
STDAPI 
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    DbgMemoryTrackDisable(TRUE);
    HRESULT hr = _Module.RegisterServer(TRUE);
    DbgMemoryTrackDisable(FALSE);
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Function: DllUnRegisterServer
//
// Removes entries from the system registry
//+----------------------------------------------------------------------------
STDAPI 
DllUnregisterServer(void)
{
    DbgMemoryTrackDisable(TRUE);
    THR_NOTRACE( _Module.UnregisterServer() );
    DbgMemoryTrackDisable(FALSE);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Function:   DllEnumClassObjects
//
//  Synopsis:   Given an index in class object map, returns the
//              corresponding CLSID and IUnknown
//              This function is used by MsHtmpad to CoRegister
//              local class ids. 
//
//----------------------------------------------------------------
STDAPI
DllEnumClassObjects(int i, CLSID *pclsid, IUnknown **ppUnk)
{
    HRESULT             hr      = S_FALSE;
    _ATL_OBJMAP_ENTRY * pEntry  = _Module.m_pObjMap;
    
    if (!pEntry)
        goto Cleanup;

    pEntry += i;

    if (pEntry->pclsid == NULL)
        goto Cleanup;

    memcpy(pclsid, pEntry->pclsid, sizeof( CLSID ) );
    hr = THR( DllGetClassObject( *pclsid, IID_IUnknown, (void **)ppUnk) );

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\selcmd.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_EDCMD_HXX_
#define X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef X_SELCMD_HXX_
#define X_SELCMD_HXX_
#include "selcmd.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef _X_AUTOURL_H_ 
#define _X_AUTOURL_H_ 
#include "autourl.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef X_SLIST_HXX_
#define X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_
#include "mshtmled.hxx"
#endif

//
// Externs
//
MtDefine(CSelectAllCommand, EditCommand, "CSelectAllCommand");
MtDefine(CClearSelectionCommand, EditCommand, "CClearSelectionCommand");
MtDefine(CKeepSelectionCommand, EditCommand, "CKeepSelectionCommand");

using namespace EdUtil;

////////////////////////////////////////////////////////////////////////////////
// CSelectAllCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CSelectAllCommand::PrivateExec( 
                        DWORD nCmdexecopt,
                        VARIANTARG * pvarargIn,
                        VARIANTARG * pvarargOut )
{
    HRESULT         hr = S_OK;

#ifdef FORMSMODE
    if (GetEditor()->GetSelectionManager()->IsInFormsSelectionMode())
    {
        IFC (SelectAllSiteSelectableElements());
    }
    else
    {
#endif
        SP_ISegmentList     spSegmentList;
        SP_IMarkupPointer   spStart;
        SP_IMarkupPointer   spEnd;
        SELECTION_TYPE      eSelType;
        BOOL                fSelectedAll = FALSE;
        BOOL                fEmpty = FALSE;

        
        IFC( GetSegmentList( &spSegmentList ));
                
        //
        // NOTE: This code is required for select all after range.pastehtml
        //       so that it auto-detects any existing url's.  This is
        //       a BVT case.  See bug 40009. [ashrafm]
        //

        if ( GetEditor()->GetSelectionManager()->IsParentEditable() )
        {
            IFC( spSegmentList->GetType( &eSelType ) );
            IFC( spSegmentList->IsEmpty( &fEmpty ) );

            if( eSelType == SELECTION_TYPE_Caret && !fEmpty )
            {           
                IFC( GetFirstSegmentPointers( spSegmentList, &spStart, &spEnd ) );
                IGNORE_HR( GetEditor()->GetAutoUrlDetector()->DetectCurrentWord( spStart, NULL, NULL ));
            }
        }

        // Check to see if the edit context is contained in the doc that our CommandTarget 
        // is based off of.  If the command target executing this command belongs to a different
        // IHTMLDocument than the edit context, we need to adjust the edit context

        if( !GetCommandTarget()->IsRange() )
        {
            BOOL                fHasContext;
            SP_IHTMLDocument2   spDoc;
            SP_IHTMLElement     spBody;

            IFC( GetEditor()->GetSelectionManager()->IsContextWithinContainer(  GetCommandTarget()->GetMarkupContainer(),
                                                                                &fHasContext ) );
            if( !fHasContext || !GetEditor()->GetSelectionManager()->IsEnabled())
            {
                // The markup container on which this command was executed was not in our edit
                // context, or our edit context is not enabled.  Get the body of the markup 
                // container on which this command was executed, and make it current.

                IFC( GetCommandTarget()->GetMarkupContainer()->QueryInterface(IID_IHTMLDocument2, (void **)&spDoc) );
                IFC( GetEditor()->GetBody(&spBody, spDoc ) );
                IFC( GetEditor()->GetSelectionManager()->EnsureEditContextClick( spBody ) );
            }
        }                                               
                                        
        IFC( GetEditor()->GetSelectionManager()->SelectAll( spSegmentList, & fSelectedAll, GetCommandTarget()->IsRange() ));   
#ifdef FORMSMODE
    }
#endif 

Cleanup:

    return S_OK;
}

HRESULT 
CSelectAllCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
// CClearSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CClearSelectionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    IGNORE_HR( GetEditor()->GetSelectionManager()->EmptySelection( FALSE /*fHideCaret*/, FALSE /*fChangeTrackerAndSetRange*/) );

    return S_OK;
}

HRESULT 
CClearSelectionCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = MSOCMDSTATE_UP;

    return S_OK;
}

HRESULT 
CSelectAllCommand::SelectAllSiteSelectableElements()
{
    HRESULT              hr = S_OK;
    CSegmentList        *pSegmentList = NULL;
    SP_IHTMLElement      spStartElement ;
    SP_ISegmentList      spISegmentList ;
    SP_IElementSegment   spISegment ;
    int                  iCount = 0;
    BOOL                 fEqual = FALSE ;

    CEditPointer         ep(GetEditor());
    CEditPointer         epStart(GetEditor());
    CEditPointer         epEnd(GetEditor());

    CControlTracker::HOW_SELECTED eHow =  CControlTracker::HS_NONE ;    
 
    pSegmentList = new CSegmentList ;
    if( !pSegmentList )
        goto Error;

    pSegmentList->SetSelectionType( SELECTION_TYPE_Control );

    IFC( GetEditor()->GetBody(&spStartElement));
    IFC( epStart->MoveAdjacentToElement( spStartElement, ELEM_ADJ_AfterBegin ));
    IFC( epEnd->MoveAdjacentToElement  ( spStartElement, ELEM_ADJ_BeforeEnd  ));

    IFC( ep->MoveToPointer(epStart) );
    IFC( ep.SetBoundary( epStart, epEnd ));
    IFC( ep.Constrain() );
       
    IFC( epStart->IsEqualTo(epEnd, &fEqual) );
    
    while (!fEqual)
    {
        SP_IHTMLElement     spElement;
        ELEMENT_TAG_ID      eTag;
        DWORD               dwSearch = BREAK_CONDITION_EnterSite | BREAK_CONDITION_NoScopeSite;
        DWORD               dwFound = 0;

        IFC ( ep.Scan(RIGHT, dwSearch, &dwFound, &spElement, &eTag) );

        if  (!ep.CheckFlag(dwFound, BREAK_CONDITION_EnterSite | BREAK_CONDITION_NoScopeSite))
            break;

        //
        // Verify that this object CAN be site selected
        //
        IGNORE_HR( GetEditor()->GetSelectionManager()->GetControlTracker()->IsElementSiteSelectable( eTag, spElement, &eHow ));       
        if( eHow == CControlTracker::HS_FROM_ELEMENT )
        {            
            IFC( pSegmentList->AddElementSegment( spElement, &spISegment ) );
        }
        IFC( ep->IsEqualTo(epEnd, &fEqual) );
    }

    IFC(pSegmentList->QueryInterface(IID_ISegmentList, (void**)&spISegmentList));
    IFC(GetSegmentCount(spISegmentList , &iCount));
    if (iCount > 0)
    {       
         IFC(GetEditor()->GetSelectionManager()->Select(spISegmentList));
    }
    
Cleanup:
      if (pSegmentList)
        pSegmentList->Release();
    RRETURN (hr);

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

////////////////////////////////////////////////////////////////////////////////
// CKeepSelectionCommand
////////////////////////////////////////////////////////////////////////////////

HRESULT 
CKeepSelectionCommand::PrivateExec( 
    DWORD nCmdexecopt,
    VARIANTARG * pvarargIn,
    VARIANTARG * pvarargOut )
{
    HRESULT hr = S_OK;
    
    if ( pvarargIn && pvarargIn->vt == VT_BOOL )
    {
        GetCommandTarget()->SetKeepSelection( ENSURE_BOOL(pvarargIn->bVal));
    }
    else if ( (pvarargIn && pvarargIn->vt == VT_EMPTY) || !pvarargIn )
    {
        GetCommandTarget()->SetKeepSelection( ! GetCommandTarget()->IsKeepSelection());
    }
    else
    {
        hr = E_INVALIDARG;
    }
    
    return hr ;
}

HRESULT 
CKeepSelectionCommand::PrivateQueryStatus( OLECMD * pcmd,
                     OLECMDTEXT * pcmdtext )
{
    pcmd->cmdf = GetCommandTarget()->IsKeepSelection() ?  MSOCMDSTATE_DOWN : MSOCMDSTATE_UP ;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OptsHold.rc
//
#define IDS_PROJNAME                    100
#define IDR_HTMLDLGHELPER               101
#define IDR_MSHTMLED                    102
#define IDR_FONTSOPTION                 103
#define IDR_HTMLEDITOR                  104
#define IDR_HTMLDLGSAFEHELPER           105
#define IDS_BLOCKFMT_NORMAL             1000
#define IDS_BLOCKFMT_PRE                1001
#define IDS_BLOCKFMT_ADDRESS            1002
#define IDS_BLOCKFMT_H1                 1003
#define IDS_BLOCKFMT_H2                         1004
#define IDS_BLOCKFMT_H3                         1005
#define IDS_BLOCKFMT_H4                         1006
#define IDS_BLOCKFMT_H5                         1007
#define IDS_BLOCKFMT_H6                         1008
#define IDS_BLOCKFMT_OL                         1009
#define IDS_BLOCKFMT_UL                         1010
#define IDS_BLOCKFMT_DIR                        1011
#define IDS_BLOCKFMT_MENU                       1012
#define IDS_BLOCKFMT_DT                         1013
#define IDS_BLOCKFMT_DD                         1014
#define IDS_BLOCKFMT_P                          1016
#define IDS_BLOCKFMT_PRE_TAG                    1017
#define IDS_BLOCKFMT_ADDRESS_TAG                1018
#define IDS_BLOCKFMT_H1_TAG                     1019
#define IDS_BLOCKFMT_H2_TAG                     1020
#define IDS_BLOCKFMT_H3_TAG                     1021
#define IDS_BLOCKFMT_H4_TAG                     1022
#define IDS_BLOCKFMT_H5_TAG                     1023
#define IDS_BLOCKFMT_H6_TAG                     1024
#define IDS_BLOCKFMT_OL_TAG                     1025
#define IDS_BLOCKFMT_UL_TAG                     1026
#define IDS_BLOCKFMT_DIR_TAG                    1027
#define IDS_BLOCKFMT_MENU_TAG                   1028
#define IDS_BLOCKFMT_DT_TAG                     1029
#define IDS_BLOCKFMT_DD_TAG                     1030
#define IDS_BLOCKFMT_P_TAG                      1031
#define IDS_BLOCKFMT_DIV_TAG                    1032

#define IDS_BEGIN_DELIMITER                     1033
#define IDS_END_DELIMITER                       1034
#define IDS_END_LINE_DELIMITER                  1035

//------------------------------------------------------------------------------------
//
// Bitmaps and other UI goodies
//
//------------------------------------------------------------------------------------

#define IDR_FEEDBACKRECTBMP             2505
#define IDR_HATCHBMP                    2503    // Bitmap for border hatching
//----------------------------------------------------------------------------
//
// Undo strings
//
//----------------------------------------------------------------------------

#define IDS_CACHE_BEGIN                   2000
#define IDS_EDUNDO                        (IDS_CACHE_BEGIN)
#define IDS_EDREDO                        (IDS_EDUNDO + 1)
#define IDS_EDCANTUNDO                    (IDS_EDUNDO + 2)
#define IDS_EDCANTREDO                    (IDS_EDUNDO + 3)
#define IDS_EDUNDONEWCTRL                 (IDS_EDUNDO + 4)
#define IDS_EDUNDODELETE                  (IDS_EDUNDO + 5)
#define IDS_EDUNDOPROPCHANGE              (IDS_EDUNDO + 6)
#define IDS_EDUNDOMOVE                    (IDS_EDUNDO + 7)
#define IDS_EDUNDORESIZE                  (IDS_EDUNDO + 8)
#define IDS_EDUNDODRAGDROP                (IDS_EDUNDO + 9)
#define IDS_EDUNDOALIGN                   (IDS_EDUNDO + 10)
#define IDS_EDUNDOCENTER                  (IDS_EDUNDO + 11)
#define IDS_EDUNDOSIZETO                  (IDS_EDUNDO + 12)
#define IDS_EDUNDOSPACING                 (IDS_EDUNDO + 13)
#define IDS_EDUNDOARRANGE                 (IDS_EDUNDO + 14)
#define IDS_EDUNDOPASTE                   (IDS_EDUNDO + 15)
#define IDS_EDUNDOTYPING                  (IDS_EDUNDO + 16)
#define IDS_EDUNDOTEXTDELETE              (IDS_EDUNDO + 17)
#define IDS_EDUNDOCUT                     (IDS_EDUNDO + 18)
#define IDS_EDUNDOGENERICTEXT             (IDS_EDUNDO + 19)
#define IDS_EDUNDOCHANGEVALUE             (IDS_EDUNDO + 20)
#define IDS_EDUNDOBACKSPACE               (IDS_EDUNDO + 21)
#define IDS_EDUNDOBLOCKDIR                (IDS_EDUNDO + 22)
#define IDS_EDUNDOOVERWRITE               (IDS_EDUNDO + 23)
#define IDS_CACHE_END                     IDS_EDUNDOOVERWRITE

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\selserv.cxx ===
//+----------------------------------------------------------------------------
//
// File:        selserv.CXX
//
// Contents:    Implementation of CSelectionServices class
//
// Purpose:
//
// Copyright (c) 1998 Microsoft Corporation. All rights reserved.
//
//
//-----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_SELSERV_HXX_
#define X_SELSERV_HXX_
#include "selserv.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif


#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif


#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef X_SLIST_HXX_
#define X_SLIST_HXX_
#include "slist.hxx"
#endif

#ifndef X_SEGMENT_HXX_
#define X_SEGMENT_HXX_
#include "segment.hxx"
#endif

using namespace EdUtil;

#if DBG == 1 
int CSelectionServices::s_NextSerialNumber = 1;
#endif

//-----------------------------------------------------------------------------
//
//  Function:   CSelectionServices::CSelectionServices
//
//  Synopsis:   Constructor
//
//-----------------------------------------------------------------------------
CSelectionServices::CSelectionServices(void)
#if DBG == 1
    : _nSerialNumber( CSelectionServices::s_NextSerialNumber++ )
#endif
{
    _cRef = 1;
    _eType = SELECTION_TYPE_None;
    _pISelListener = NULL;
    _pIContainer = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::~CSelectionServices
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------------
CSelectionServices::~CSelectionServices(void)
{
    ClearSegments();
    ReleaseInterface( _pISelListener );
    ReleaseInterface( _pIContainer );
}


//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::Init
//
//  Synopsis:   Initializes the CSelectionServices object
//
//  Arguments:  pEd = Pointer to CHTMLEditor object
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::Init(CHTMLEditor *pEd, IMarkupContainer *pIContainer)
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( pEd && pIContainer );

    if( pEd && pIContainer )
    {
        _pEd = pEd;
        if (_pEd && _pEd->GetSelectionManager() && !_pEd->GetSelectionManager()->_fInitialized)
        {
            _pEd->GetSelectionManager()->Initialize();
        }
        _pIContainer = pIContainer;
        _pIContainer->AddRef();
        
        hr = S_OK;
    }

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSegmentList::GetType
//
//  Synopsis:   Retrieves the type of selection this segment list contains
//
//  Arguments:  peType = OUT pointer
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::GetType( SELECTION_TYPE *peType )
{
    HRESULT hr = E_FAIL;
    
    Assert( peType );

    if( _pEd->ShouldLieToAccess()  )
    {
        *peType = _pEd->AccessLieType(); 
        hr = S_OK;
    }
    else
    {
        hr = CSegmentList::GetType(peType);
    }
    
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::SetSelectionType
//
//  Synopsis:   Sets the current selection type of the CSelectionServices.
//              Only one type of selection can be active at any given point.
//              Any time this method is called, all segments are cleared.
//
//  Arguments:  eType = new selection type
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::SetSelectionType(SELECTION_TYPE eType, ISelectionServicesListener* pIListener )
{
    HRESULT         hr = S_OK;
    SP_ISegment     spICaretSegment = NULL;
    SP_IHTMLCaret   spICaret = NULL;

    Assert( eType == SELECTION_TYPE_None || pIListener );
    if ( _pISelListener )
    {
        IGNORE_HR( _pISelListener->OnChangeType( eType, pIListener ));
    }
    
    // Clear any existing segments, and set the new type
    IFC( CSegmentList::SetSelectionType(eType) );

    //
    // Setup the selection listener interfaces
    //
    ClearInterface( & _pISelListener );

    if ( pIListener )
    {
        ReplaceInterface( & _pISelListener, pIListener );
    }

    if( eType == SELECTION_TYPE_Caret )
    {
        SP_IMarkupPointer   spPointer;
        BOOL                fPositioned;
        BOOL                fVisible;

        IFC( _pEd->GetDisplayServices()->GetCaret(&spICaret) );

        IFC( _pEd->CreateMarkupPointer(&spPointer) );
        IFC( spICaret->MoveMarkupPointerToCaret(spPointer) );

        IFC( spPointer->IsPositioned(&fPositioned) );
        IFC( spICaret->IsVisible( &fVisible ) );

        if( fPositioned && fVisible )
        {
            IFC( AddCaretSegment( spICaret, &spICaretSegment ) );
        }
        else
        {
            IFC( CSegmentList::SetSelectionType(SELECTION_TYPE_None) );
        }
    }
       
Cleanup:
    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::GetMarkupContainer
//
//  Synopsis:   Retrieves the markup container in which all the segments
//              in CSelectionServices belong to.  CSelectionServices
//              can only contain selection segments from the same markup.
//              Any attempt to add multiple segments which belong to different
//              markups will result in a failure.
//
//  Arguments:  ppIContainer = OUTPUT - Markup container
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::GetMarkupContainer(IMarkupContainer **ppIContainer)
{
    HRESULT hr = E_INVALIDARG;
    
    Assert( ppIContainer && _pIContainer);

    if( ppIContainer && _pIContainer )
    {
        *ppIContainer = _pIContainer;
        (*ppIContainer)->AddRef();

        hr = S_OK;
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::EnsureMarkupContainer
//
//  Synopsis:   Ensures the pointers passed in are compatible with the 
//              current markup container.
//
//  Arguments:  pIStart = INPUT - Starting pointer
//              pIEnd = INPUT - Ending pointer
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::EnsureMarkupContainer(IMarkupPointer *pIStart, IMarkupPointer *pIEnd )
{
    HRESULT             hr;
    SP_IMarkupContainer spStartContainer;
    SP_IMarkupContainer spEndContainer;
    
    Assert( pIStart && pIEnd );
    Assert( _pIContainer != NULL );

    //
    // Retrieve the containers
    //
    IFC( pIStart->GetContainer( &spStartContainer ) );
    IFC( pIEnd->GetContainer( &spEndContainer ) );

    //
    // Make sure the containers are equal, and they match the current container
    //
    if( !EqualContainers( spStartContainer, spEndContainer ) ||
        !EqualContainers( spStartContainer, _pIContainer )  )
    {
        AssertSz(FALSE, "Attempting to add a segment from a different markup to SelServ");
        hr = E_FAIL;
    }
    
Cleanup:

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::EnsurePositioned
//
//  Synopsis:   Ensures the pointers passed in are positioned
//
//  Arguments:  pIStart = INPUT - Starting pointer
//              pIEnd = INPUT - Ending pointer
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionServices::EnsurePositioned(IMarkupPointer *pIStart, IMarkupPointer *pIEnd )
{
    BOOL    fPositioned;
    HRESULT hr = S_OK;
    
    Assert( pIStart && pIEnd );
    
    IFC( pIStart->IsPositioned(&fPositioned) );
    if( !fPositioned )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    IFC( pIEnd->IsPositioned(&fPositioned) );
    if( !fPositioned )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////
//
//  IUnknown's Implementation
//
//////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CSelectionServices::AddRef( void )
{
    return( ++_cRef );
}


STDMETHODIMP_(ULONG)
CSelectionServices::Release( void )
{
    --_cRef;

    if( 0 == _cRef )
    {
        delete this;
        return 0;
    }

    return _cRef;
}


STDMETHODIMP
CSelectionServices::QueryInterface(
    REFIID  iid, 
    LPVOID  *ppvObj )
{
    if (!ppvObj)
        RRETURN(E_INVALIDARG);
  
    if (iid == IID_IUnknown || iid == IID_ISegmentList)
    {
        *ppvObj = (ISegmentList *)this;
    }
    else if( iid == IID_ISelectionServices )
    {
        *ppvObj = (ISelectionServices *)this;
    }    
    else
    {
        *ppvObj = NULL;
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    ((IUnknown *)(*ppvObj))->AddRef();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CSelectionServices::ClearSegments
//
//  Synopsis:   Removes all of the segments currently in use
//
//  Arguments:  fInvalidate = BOOLEAN indicating whether to invalidate the
//              segments.
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT 
CSelectionServices::ClearSegments()
{
    HRESULT         hr = S_OK;

    // Free any empty elements so we can
    // do a simple recursion thru our segments
    IFC( RemoveAll() );
    
Cleanup:
    
    RRETURN(hr);
}

HRESULT
CSelectionServices::AddSegment( IMarkupPointer  *pStart,
                                IMarkupPointer  *pEnd,
                                ISegment        **pISegmentAdded)
{
    HRESULT             hr;

    //
    // Make sure we are positioned
    //
    IFC( EnsurePositioned( pStart, pEnd ) );
    
    //
    // Ensure we are in the right container
    //
    // IFC( EnsureMarkupContainer( pStart, pEnd ) );

    //
    // Add the element segment
    //
    IFC( CSegmentList::AddSegment(pStart, pEnd, pISegmentAdded) );

Cleanup:
    RRETURN(hr);
}

HRESULT
CSelectionServices::AddElementSegment(  IHTMLElement     *pIElement,
                                        IElementSegment  **ppISegmentAdded)
{
    HRESULT             hr;
    SP_IMarkupPointer   spStart;
    SP_IMarkupPointer   spEnd;

    //
    // Add the element segment
    //
    IFC( CSegmentList::AddElementSegment(pIElement, ppISegmentAdded) );

    //
    // Position pointers, and set (or ensure) the markup container
    //       
    IFC( CreateMarkupPointer2( GetEditor(), &spStart ) );
    IFC( CreateMarkupPointer2( GetEditor(), &spEnd ) );
    IFC( (*ppISegmentAdded)->GetPointers( spStart, spEnd ) );

    //
    // Ensure we are position
    //
    IFC( EnsurePositioned( spStart, spEnd ) );
    
    //
    // We have to do the add first, to get the IElementSegment
    //
    Assert( GetSize() );

    // IFC( EnsureMarkupContainer( spStart, spEnd ) );

Cleanup:
    RRETURN(hr);
    
}

HRESULT
CSelectionServices::RemoveSegment(ISegment *pISegment)
{
    HRESULT hr;
    BOOL fEmpty;
    
    hr = THR( CSegmentList::RemoveSegment(pISegment));

    IGNORE_HR( IsEmpty( & fEmpty ));

    if ( fEmpty )
    {
        CSegmentList::SetSelectionType( SELECTION_TYPE_None);
        ClearInterface( & _pISelListener );
    }
    
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionServices::GetSelectionServicesListener( ISelectionServicesListener** ppISelectionUndoListener)
{
    if ( ! ppISelectionUndoListener )
    {
        return E_INVALIDARG;
    }

    *ppISelectionUndoListener = NULL;
    
    if( ! _pISelListener )
    {
        return E_FAIL;
    }    

    ReplaceInterface( ppISelectionUndoListener,_pISelListener );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\mshtml\src\edit\selman.cxx ===
//+------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       SELMAN.CXX
//
//  Contents:   Implementation of ISelectionManager interface inisde of mshtmled.dll
//
//  Classes:    CMshtmlEd
//
//  History:    06-10-98 - marka - created
//
//-------------------------------------------------------------------------
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_STDAFX_H_
#define X_STDAFX_H_
#include "stdafx.h"
#endif

#ifndef X_OptsHold_H_
#define X_OptsHold_H_
#include "optshold.h"
#endif

#ifndef X_COREGUID_H_
#define X_COREGUID_H_
#include "coreguid.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include "mshtmhst.h"
#endif

#ifndef X_MSHTMLED_HXX_
#define X_MSHTMLED_HXX_ 
#include "mshtmled.hxx"
#endif

#ifndef X_SELMAN_HXX_
#define X_SELMAN_HXX_
#include "selman.hxx"
#endif

#ifndef X_HTMLED_HXX_
#define X_HTMLED_HXX_
#include "htmled.hxx"
#endif

#ifndef X_EDUTIL_HXX_
#define X_EDUTIL_HXX_
#include "edutil.hxx"
#endif

#ifndef _X_EDCMD_HXX_
#define _X_EDCMD_HXX_
#include "edcmd.hxx"
#endif

#ifndef _X_DELCMD_HXX_
#define _X_DELCMD_HXX_
#include "delcmd.hxx"
#endif

#ifndef _X_BLOCKCMD_HXX_
#define _X_BLOCKCMD_HXX_
#include "blockcmd.hxx"
#endif

#ifndef  X_EDTRACK_HXX_
#define  X_EDTRACK_HXX_
#include "edtrack.hxx"
#endif

#ifndef _X_EDADORN_HXX_
#define _X_EDADORN_HXX_
#include "edadorn.hxx"
#endif

#ifndef X_IME_HXX_
#define X_IME_HXX_
#include "ime.hxx"
#endif

#ifndef _X_CARTRACK_HXX_
#define _X_CARTRACK_HXX_
#include "cartrack.hxx"
#endif

#ifndef _X_SELTRACK_HXX_
#define _X_SELTRACK_HXX_
#include "seltrack.hxx"
#endif

#ifndef _X_CTLTRACK_HXX_
#define _X_CTLTRACK_HXX_
#include "ctltrack.hxx"
#endif

#ifndef _X_SELSERV_HXX_
#define _X_SELSERV_HXX_
#include "selserv.hxx"
#endif 

#ifndef X_EDEVENT_H_
#define X_EDEVENT_H_
#include "edevent.hxx"
#endif

#ifndef X_EDUNDO_HXX_
#define X_EDUNDO_HXX_
#include "edundo.hxx"
#endif

#ifndef X_COMCAT_H_
#define X_COMCAT_H_
#include "comcat.h"
#endif

using namespace EdUtil;
using namespace MshtmledUtil;

MtDefine(CSelectionManager, Utilities, "Selection Manager")
DeclareTag(tagSelectionMgrState, "Selection", "Selection show manager state")
DeclareTag(tagSelectionMgrNotify, "Selection", "SelectionManager show TrackerNotify")
DeclareTag(tagSelectionMessage, "Selection","Show New Edit Messages")
DeclareTag(tagSelectionChangeCounter, "Selection", "Selection change counter");

ExternTag( tagSelectionTrackerState );

extern int edWsprintf(LPTSTR pstrOut, LPCTSTR pstrFormat, LPCTSTR pstrParam);
#if DBG == 1

static const LPCTSTR strStartContext = _T( "   ** Start_Edit_Context");
static const LPCTSTR strEndContext = _T( "   ** End_Edit_Context");
#endif

extern BOOL g_fInVizAct2000  ;

CSelectionManager::CSelectionManager( CHTMLEditor * pEd )
                                 : _pEd( pEd )
{
    _ulRefs = 1;
    Init();
}

HRESULT
CSelectionManager::Initialize()
{
    HRESULT hr = S_OK;
    IHTMLDocument4 *pDoc = NULL;

    if (_fInInitialization)
    {
        return hr;
    }
    _fInInitialization = TRUE;
    
    //
    // Create our listeners that derive from CDispWrapper.  Since we pass
    // out IDispatch pointers when we do an AttachEvent() with these 
    // listeners, they must obey all nice COM rules.
    //
    _pEditContextBlurHandler = new CEditContextHandler(this);
    if( !_pEditContextBlurHandler )
        goto Error;

    _pActElemHandler = new CActiveElementHandler(this);
    if( !_pActElemHandler )
        goto Error;

    _pDragListener = new CDragListener(this);
    if( !_pDragListener )
        goto Error;

    _pFocusHandler = new CFocusHandler(this);
    if( !_pFocusHandler )
        goto Error;
        
    _pExitTimer = new CExitTreeTimer(this);
    if( !_pExitTimer )
        goto Error;

    _pDropListener = new CDropListener(this);
    if( !_pDropListener )
        goto Error;
   
    IFC( _pEd->CreateMarkupPointer(& _pStartContext ));
    IFC( _pStartContext->SetGravity( POINTER_GRAVITY_Left ) );
    IFC( _pEd->CreateMarkupPointer( &_pEndContext ));
    IFC( _pEndContext->SetGravity( POINTER_GRAVITY_Right ) );

    pDoc = _pEd->GetDoc4();
    IFC(pDoc->createRenderStyle(NULL, &_pISelectionRenderStyle));
    
#if DBG == 1
    SetDebugName( _pStartContext,strStartContext );
    SetDebugName( _pEndContext,strEndContext );
#endif

    IFC( InitTrackers());
    IFC( EnsureDefaultTracker());
    

    IFC( SetInitialEditContext());    

Cleanup:
    ReleaseInterface(pDoc);
    _fInitialized = TRUE;
    _fInInitialization = FALSE;
    RRETURN( hr );

Error:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}


HRESULT 
CSelectionManager::Passivate(BOOL fEditorReleased /* = FALSE */)
{
    if (_pEd)
    {
        ClearInterface( &_pStartContext );
        ClearInterface( &_pEndContext );
        ClearInterface( &_pIEditableElement );
        ClearInterface( &_pIEditableFlowElement );
        ClearInterface( &_pDeferStart );
        ClearInterface( &_pDeferEnd ); 
        ClearInterface( &_pISelectionRenderStyle );

        ClearInterface( &_pIElementExitStart);
        ClearInterface( &_pIElementExitEnd );
        ClearInterface( &_pIElementExitContentStart );
        ClearInterface( &_pIElementExitContentEnd);
        IGNORE_HR( DestroyFakeSelection());
       
        if ( _pIBlurElement )
        {
            IGNORE_HR( DetachEditContextHandler());
        }
        
        if ( _pIActiveElement )
        {
            IGNORE_HR( DetachActiveElementHandler());
        }
        if ( _pIDropListener )
        {
            IGNORE_HR( DetachDropListener());
        }
        if ( _fInExitTimer )
        {
            IGNORE_HR( StopExitTreeTimer());
            Assert( ! _pITimerWindow );
        }

        if( _pISCList )
        {
            delete _pISCList;
            _pISCList = NULL;
        }
            
        //
        // Release all of our IDispatch based event handlers
        //
        if ( _pEditContextBlurHandler )
        {
            _pEditContextBlurHandler->SetManager(NULL);
            ClearInterface( &_pEditContextBlurHandler );
        }
        if ( _pActElemHandler )
        {
            _pActElemHandler->SetManager(NULL);
            ClearInterface( &_pActElemHandler );
        }
        if ( _pDragListener )
        {
            _pDragListener->SetManager(NULL);
            ClearInterface( &_pDragListener );
        }
        if ( _pFocusHandler )
        {    
            _pFocusHandler->SetManager(NULL);
            ClearInterface( &_pFocusHandler );
        }
        if ( _pExitTimer )
        {
            _pExitTimer->SetManager(NULL);
            ClearInterface( &_pExitTimer );
        }
        if ( _pDropListener )
        {
            _pDropListener->SetManager(NULL);
            ClearInterface( &_pDropListener );
        }

        Assert(!_pIme);

        DestroyAdorner();
        DestroyTrackers(); 

        if ( _pIFocusWindow )
        {
            IGNORE_HR( DetachFocusHandler());
            Assert( ! _pIFocusWindow );
        }
        
        Assert( ! _fInCapture );
    }

    if (fEditorReleased)
        _pEd = NULL;

    return S_OK;
}


CSelectionManager::~CSelectionManager()
{
    Passivate();
}


VOID
CSelectionManager::Init()
{
    Assert( !_pActiveTracker );    // The currently active tracker.
    Assert( !_pAdorner );
    Assert( !_pStartContext );
    Assert( ! _pEndContext );
    Assert( !_pISCList );
    Assert( !_pIEditableElement);
    Assert( !_pIEditableFlowElement);
    Assert( !_pEditContextBlurHandler );
    Assert( !_pActElemHandler );
    Assert( !_pDragListener );
    Assert( !_pFocusHandler );
    Assert( !_pExitTimer );
    
    _fInitSequenceChecker = FALSE;
    _fIgnoreSetEditContext = FALSE;
    _fDontChangeTrackers = FALSE;
    _fDrillIn = FALSE;
    _fLastMessageValid = FALSE;
    _fNoScope = FALSE;
    _fInTimer = FALSE;
    _fInCapture = FALSE;
    _fContextAcceptsHTML = FALSE;
    _fPendingUndo = FALSE ;
    _pDeferStart = NULL;
    _pDeferEnd = NULL;
    _fContextEditable = FALSE;
    _fParentEditable = FALSE;
    _fPositionedSet = FALSE;
    _fDontScrollIntoView = FALSE ;
    _fDestroyedTextSelection = FALSE ;
    
    _eDeferSelType = SELECTION_TYPE_None;
    _lastStringId = UINT(-1);
    _eContextTagId = TAGID_NULL ;
    _fEditFocusAllowed = TRUE;

    _fInitialized = FALSE;
    _fInInitialization = FALSE;

#ifdef FORMSMODE
    _eSelectionMode = SELMODE_MIXED; // THIS MUST go before setting the edit context
#endif
    
    WHEN_DBG( _ctMsgLoop = 0 );
    WHEN_DBG( _ctEvtLoop = 0 );
    WHEN_DBG( _ctSetEditContextCurChg = 0 );    

    CreateISCList();
}
//+------------------------------------------------------------------------
//
//  Member:     CSelectionManager::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------
HRESULT
CSelectionManager::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown ||
       riid == IID_ISelectionServicesListener )
    {
        *ppv = this;
    }
    
    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}
//+====================================================================================
//
// Method: InitTrackers
//
// Synopsis: Initialize all trackers 
//
//------------------------------------------------------------------------------------


HRESULT
CSelectionManager::InitTrackers()
{
    Assert( ! _pCaretTracker );
    _pCaretTracker = new CCaretTracker( this );
    if ( ! _pCaretTracker )
        goto Error;

    Assert( ! _pSelectTracker );
    _pSelectTracker = new CSelectTracker( this );
    if ( ! _pSelectTracker )
        goto Error;

    Assert( ! _pControlTracker );
    _pControlTracker = new CControlTracker( this );        
    if ( ! _pControlTracker )
        goto Error;

    return S_OK;
  
Error:
    return( E_OUTOFMEMORY );
}

VOID
CSelectionManager::DestroyTrackers()
{
    HibernateTracker( NULL, TRACKER_TYPE_None, FALSE); // don't tear down UI during passivation
    _pActiveTracker = NULL;
    _pCaretTracker->Release();   _pCaretTracker = NULL;
    _pSelectTracker->Release();  _pSelectTracker = NULL;
    _pControlTracker->Release(); _pControlTracker = NULL;
}

//+=====================================================================
// Method: HandleMessage
//
// Synopsis: Handle a UI Message passed from Trident to us.
//
//----------------------------------------------------------------------
#define OEM_SCAN_RIGHTSHIFT 0x36

HRESULT
CSelectionManager::HandleEvent( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE ;
    BOOL    fStarted = FALSE;
    Assert( _pEd->GetDoc() );
    HWND    hwndDoc;
    CEditTracker* pTracker = _pActiveTracker;

    if ( pTracker )
        pTracker->AddRef();
        
#ifndef NO_IME
    //
    // Always check to see if IME wants to handle it.
    //
    hr = THR( HandleImeEvent(pEvent) );
    if (S_OK == hr)
    {
        goto Cleanup;
    }
#endif // NO_IME
    
    switch ( pEvent->GetType() )
    {
        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
#ifdef UNIX
        case EVT_MMOUSEDOWN:
#endif
            {
                CSelectionChangeCounter selCounter(this);
                BOOL fChangedCurrency = FALSE;
                BOOL fSelectionTrackerChange = FALSE;
                BOOL fSelectionExtended = FALSE;
                TRACKER_TYPE eType = GetTrackerType();
                TRACKER_TYPE eNewType = eType;

                SP_IHTMLElement spElement;
                IFC( pEvent->GetElement( & spElement));
                if ( CheckUnselectable( spElement ) == S_OK )
                {
                    goto Cleanup;
                }

                selCounter.BeginSelectionChange();

                if ( pEvent->GetType() == EVT_LMOUSEDOWN ||
                     pEvent->GetType() == EVT_RMOUSEDOWN )
                {
                    IFC( EnsureEditContextClick( spElement, pEvent , & fChangedCurrency ));
                }

                if ( IsDefaultTrackerPassive() ||
                    !_pActiveTracker->IsListeningForMouseDown(pEvent) )
                {
                    SP_IOleWindow spOleWindow;

                    IFC(GetDoc()->QueryInterface(IID_IOleWindow, (void **)&spOleWindow));
                    IFC(spOleWindow->GetWindow(&hwndDoc));
                    POINT pt;
                    IFC( pEvent->GetPoint( & pt ));

                    if ( ! GetEditor()->IsInWindow( hwndDoc, pt , TRUE))
                    {
                        hr = S_FALSE;
                        goto Cleanup; // Ignore mouse down messages that aren't in Trident's Window or in the Content of the EditContext
                    }                        
                    hr = ShouldChangeTracker( pEvent, & fStarted );
                    if ( !fStarted )
                        hr = _pActiveTracker->HandleEvent( pEvent );
                }
                else
                {
                    if( pEvent->GetType() != EVT_RMOUSEDOWN || IsIMEComposition() )
                        hr = _pActiveTracker->HandleEvent( pEvent );
                }

                //  Now determine if we changed to/from a select tracker.  If we did then we want to
                //  fire off a selection change event.

                eNewType = GetTrackerType();

                if (eType != eNewType &&
                    (eType == TRACKER_TYPE_Selection || eNewType == TRACKER_TYPE_Selection))
                {
                    fSelectionTrackerChange = TRUE;
                }

                if (eNewType == TRACKER_TYPE_Selection && _pSelectTracker->IsSelectionShiftExtending())
                {
                    fSelectionExtended = TRUE;
                }

                selCounter.EndSelectionChange( fChangedCurrency || fStarted || fSelectionTrackerChange || fSelectionExtended);
                
#ifdef UNIX
                if ( pEvent->GetType() == EVT_MMOUSEDOWN )
                    hr = S_FALSE;
#endif
                //
                // Special case context menu.
                //

                if ( pEvent->GetType() == EVT_RMOUSEDOWN )
                    hr = S_FALSE ;  // don't cancel bubbling for the editor

                _fEnsureAtomicSelection = TRUE;
            }                
            break;

        case EVT_KEYDOWN:
        case EVT_KEYUP:
            if ( ! IsEnabled() )
            {
                goto Cleanup;
            }
            // else continue
            //
            
        case EVT_LMOUSEUP:
        case EVT_RMOUSEUP:
        case EVT_DBLCLICK:
        case EVT_MOUSEMOVE:
        case EVT_CONTEXTMENU:
        case EVT_TIMER:
        case EVT_CLICK:
        case EVT_INTDBLCLK:
        case EVT_LOSECAPTURE:

        case EVT_KILLFOCUS:
        case EVT_SETFOCUS:

            AssertSz( _pActiveTracker, "Expected to have a tracker when you have an event");            
            if ( _pActiveTracker )
            {
                hr = _pActiveTracker->HandleEvent( pEvent );

                if (pEvent->GetType() == EVT_RMOUSEUP )
                    hr = S_FALSE;
            }

            //
            // Pretend we didn't handle this internal event.  This event occurs when
            // Trident gets a WM_LBUTTONDBLCLK windows message.  We use this to
            // maintain compat with previous versions of IE, and it shouldn't look
            // like we handle this message
            //
            if( pEvent->GetType() == EVT_INTDBLCLK )
            {
                hr = S_FALSE;
            }

            // See if we got a click event on a control in a text selection.  If so,
            // we want to transition to a control tracker.

            if (pEvent->GetType() == EVT_CLICK &&
                GetTrackerType() == TRACKER_TYPE_Selection)
            {
                ELEMENT_TAG_ID      eTag;
                SP_IHTMLElement     spElement ;
                SST_RESULT          eResult      = SST_NO_CHANGE;

                //  We need to check to see if we are clicking in a table.  The table
                //  editor designer could have made a text selection here while the
                //  user clicked within the table (eg. column selection).  However,
                //  we don't want to site select the table.  We won't get to this point
                //  when normally site selecting the table because we would have already
                //  done that by now on the mouse down.
                IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));
                if (eTag != TAGID_TABLE)
                {
                    IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
                
                    if (eResult == SST_CHANGE)
                    {
                        CSelectionChangeCounter selCounter(this);
                        selCounter.BeginSelectionChange();

                        hr = THR( SetCurrentTracker( TRACKER_TYPE_Control, pEvent, 0));
                        // fire the selectionchange event
                        selCounter.EndSelectionChange();         
                    }
                }
            }
            
            if (pEvent->GetType() == EVT_LMOUSEUP || pEvent->GetType() == EVT_RMOUSEUP || pEvent->GetType() == EVT_INTDBLCLK)
            {
                _fEnsureAtomicSelection = TRUE;
            }

            break;


        case EVT_KEYPRESS: 
            if ( ! IsEnabled() )
            {
                goto Cleanup;
            }
            hr = _pActiveTracker->HandleEvent( pEvent );
            break;

        case EVT_INPUTLANGCHANGE:

            // Update the Input Sequence Checker (Thai, Hindi, Vietnamese, etc.)
            LONG_PTR lParam;
            IFC( DYNCAST( CHTMLEditEvent, pEvent)->GetKeyboardLayout( & lParam ));
            LCID lcidCurrent = LOWORD(lParam);            
            // PaulNel - If ISC is not initialized, this is a good place to do it.
            if(!_fInitSequenceChecker)
            {
                CreateISCList();
            }
            if(_pISCList)
            {
                _pISCList->SetActive(lcidCurrent);
            }

            hr = _pActiveTracker->HandleEvent( pEvent );
            break;
    }

    //  Make sure we don't position a caret inside of an atomic element
    if (_fEnsureAtomicSelection &&
        (GetTrackerType() == TRACKER_TYPE_Caret ||
         GetTrackerType() == TRACKER_TYPE_Selection))
    {
        IGNORE_HR( _pActiveTracker->EnsureAtomicSelection(pEvent) );
    }
    
Cleanup:

    _fEnsureAtomicSelection = FALSE;

    if ( pTracker )
        pTracker->Release();

    return ( hr );
}

HRESULT
CSelectionManager::EnsureEditContext()
{
    HRESULT hr = S_OK;

    if (!_fInitialized)
    {
        hr = THR(Initialize() );
        if (hr)
            goto Cleanup;
    }
    
    if ( !_pIEditableElement )
    {
        IFC( SetInitialEditContext());
    }

    IFC( DoPendingTasks() );
    
    if (! _pIEditableElement)
        hr = E_FAIL;
Cleanup:        
    RRETURN( hr );
}

//+====================================================================================
//
// Method:      SetEditContext
//
// Synopsis:    Sets the "edit context". Called by trident when an Editable
//              element is made current.
//
// Arguements:  fEditable = Is the element becoming active editable?
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::SetEditContext(  
                            BOOL fEditable,
                            BOOL fParentEditable,
                            IMarkupPointer* pStart,
                            IMarkupPointer* pEnd,
                            BOOL fNoScope ,
                            BOOL fFromClick /*=FALSE*/ )
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    BOOL            fContextChanging;
    
    Assert( GetDoc() );

    IFC( GetEditor()->SetActiveCommandTargetFromPointer( pStart ) );
    
    fContextChanging = IsContextChanging( fEditable, fParentEditable, pStart, pEnd, fNoScope );
    
    if ( fContextChanging )
    {
        IFC( InitEditContext ( fEditable, 
                               fParentEditable, 
                               pStart, 
                               pEnd, 
                               fNoScope ));
    }

    //
    // Set our "enableness" based on whether the edit context is enabled. .
    //
    SetEnabled( EdUtil::IsEnabled( _pIEditableElement) == S_OK );
    
    if ( fContextChanging ||
         IsDefaultTrackerPassive() ||   // we may have lost a tracker on a lose focus
         _fDrillIn )            // always bounce trackers on Drilling In
    {
        IFC( CreateTrackerForContext( pStart, pEnd ));       
    }

#ifdef FORMSMODE
    // Set the selection mode based on the currently editable content (for view linking, this
    // will return the root element)
    IFC( GetEditableContent(&spElement) );
    if (spElement != NULL)
    {
        IFC( SetSelectionMode(spElement) );
    }
#endif    

    Assert( _pActiveTracker );
    IFC( _pActiveTracker->OnSetEditContext( fContextChanging ));

    IFC( EnsureAdornment( !fFromClick || fContextChanging ));    

    //
    // Reset the drill in flag
    //
    _fDrillIn = FALSE;

Cleanup:

    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsContextChanging ?
//
// Synopsis:Is the Current context in any way different from the given context ?
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::IsContextChanging(
                            BOOL fEditable, 
                            BOOL fParentEditable,
                            IMarkupPointer* pStart,
                            IMarkupPointer* pEnd,
                            BOOL fNoScope )
{
    BOOL fChanging = FALSE;
    
    fChanging =  fEditable !=  ENSURE_BOOL( _fContextEditable) ||
                 fNoScope != ENSURE_BOOL( _fNoScope ) ||
                 fParentEditable != ENSURE_BOOL( _fParentEditable ) ||
                 ! IsSameEditContext( pStart, pEnd ) ||
                 _pIEditableElement == NULL ;

    return fChanging ;
    
}

//+====================================================================================
//
// Method: InitEditContext
//
// Synopsis: Set all state associated with the edit context.
//
//------------------------------------------------------------------------------------

HRESULT 
CSelectionManager::InitEditContext(
                           BOOL fEditable,
                           BOOL fParentEditable,
                           IMarkupPointer* pStart,
                           IMarkupPointer* pEnd,
                           BOOL fNoScope)
{
    HRESULT hr = S_OK;
    BOOL    fIsPassword = FALSE;
    SP_IHTMLElement  spElement;
    SP_IHTMLElement3 spElement3;
    SP_IHTMLElement  spContainer;
    VARIANT_BOOL     fHTML;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;            
    
    IFC( _pStartContext->MoveToPointer( pStart ));
    IFC( _pEndContext->MoveToPointer( pEnd ));
    _fNoScope = fNoScope; // Why ? We need to set this to ensure edit context is set correctly.
    
    //
    // Set the Editable Element
    //

    if ( _pIBlurElement )
    {
        IFC( DetachEditContextHandler());
    }
    
    ClearInterface( & _pIEditableElement );
    ClearInterface( & _pIEditableFlowElement );

    IFC( InitializeEditableElement());

    //
    // Set the doc the editor is in.
    //
    IFC( GetEditableElement()->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
    GetEditor()->SetDoc( spElemDoc );
    
    IFC( GetEditor()->IsPassword( _pIEditableElement, & fIsPassword ));

    _fEnableWordSel =  ! fIsPassword ;
    _fContextEditable = fEditable;
    _fParentEditable = fParentEditable ;
    _eContextTagId = TAGID_NULL;
    _fPositionedSet = FALSE;
    _fEditFocusAllowed = TRUE;
    //
    // Set _fContextAcceptsHTML - and reset spring loader - if context doesn't accept HTML
    //
    _fContextAcceptsHTML = FALSE; // false by default

    // Determine the ContextAcceptsHTML attribute based on the editable element
    // (master in the view-linking scenario)
    IFC( _pIEditableElement->QueryInterface(IID_IHTMLElement3, (LPVOID*)&spElement3) )
    IFC( spElement3->get_canHaveHTML(&fHTML) );
    _fContextAcceptsHTML = !!fHTML;
    
    if (!_fContextAcceptsHTML )
    {
        CSpringLoader *psl = _pActiveTracker->GetSpringLoader();

        if (psl)
            psl->Reset();
    }

    IFC( AttachEditContextHandler());
    
Cleanup:
    RRETURN( hr );
    
}

//+====================================================================================
//
// Method: CreateTrackerForContext
//
// Synopsis: Create a tracker appropriate for your edit context. If we had a caret
//           in the context - and we are creating a caret - we restore the caret to that location.
//
//------------------------------------------------------------------------------------

//
// NOTE: the pointers passed in may be adjusted ( due to caret calling AdjPointerForIns ).
//

HRESULT
CSelectionManager::CreateTrackerForContext( 
                                IMarkupPointer* pStart, 
                                IMarkupPointer* pEnd )
{
    HRESULT hr = S_OK;

    TRACKER_TYPE myType = TRACKER_TYPE_Caret;

    if ( WeOwnSelectionServices() == S_FALSE )
        goto Cleanup;

#ifdef FORMSMODE
    if (IsInFormsSelectionMode())
    {
        SP_IDisplayPointer spDispPointer;

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
        hr = THR( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
        if ( hr == CTL_E_INVALIDLINE)
        {
            CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
            hr = S_OK;
            goto Cleanup;
        }
        else if ( FAILED(hr))
        {
            goto Cleanup;
        }
        hr = SetCurrentTracker( TRACKER_TYPE_Caret , spDispPointer, spDispPointer );
    }
    else
    {      
#endif
        if ( ! IsDontChangeTrackers() &&
               GetEditableElement() && 
               CheckUnselectable( GetEditableElement() ) != S_OK )
        {

            //
            // don't change trackers if we have a selection in the context already.
            //
            if ( GetTrackerType() == TRACKER_TYPE_Selection &&
                 _pActiveTracker->IsPassive() && 
                 IsInEditContext( _pSelectTracker->GetStartSelection(), TRUE ) &&
                 IsInEditContext( _pSelectTracker->GetEndSelection() , TRUE ))
            {
                goto Cleanup;                
            }
            
            //
            // If we have a no scope element, we don't want to destroy the current tracker unless
            // we are drilling into an element.
            //
            ELEMENT_TAG_ID  eTag;
        
            IFC( GetMarkupServices()->GetElementTagId(_pIEditableElement, & eTag));

            if( !_fNoScope || _fDrillIn || eTag == TAGID_APPLET)
            {
            //
                // See if we already had a caret in this edit context.
                // if so - create the tracker there instead of just at the start of the edit context
                //
                if ( myType == TRACKER_TYPE_Caret && !_fInPendingElementExit && 
                     IsCaretAlreadyWithinContext() && 
                     GetTrackerType() != TRACKER_TYPE_Control)
                {
                    SP_IHTMLCaret       spCaret;
                    SP_IDisplayPointer  spDispPointer;
                    CSelectionChangeCounter selCounter(this);
                    BOOL                fOldDontScrollIntoView;
                    
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                    
                    IFC( GetDisplayServices()->GetCaret(&spCaret) );
                    IFC( spCaret->MoveDisplayPointerToCaret(spDispPointer) );

                    selCounter.BeginSelectionChange();
                    fOldDontScrollIntoView = _fDontScrollIntoView;
                    _fDontScrollIntoView = TRUE;
                    hr = SetCurrentTracker( myType  , spDispPointer, spDispPointer );
                    _fDontScrollIntoView = fOldDontScrollIntoView;
                    selCounter.EndSelectionChange(); 
                }
                else
                {
                    CSelectionChangeCounter selCounter(this);
                    SP_IDisplayPointer spDispStart;
                    SP_IDisplayPointer spDispEnd;

                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) )

                    hr = THR( spDispStart->MoveToMarkupPointer(pStart, NULL) );
                    if ( hr == CTL_E_INVALIDLINE)
                    {
                        CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else if ( FAILED(hr))
                    {
                        goto Cleanup;
                    }
                    
                    IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                    
                    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) )

                    hr = THR( spDispEnd->MoveToMarkupPointer(pEnd, NULL) );
                    if ( hr == CTL_E_INVALIDLINE)
                    {
                        CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                        hr = S_OK;
                        goto Cleanup;
                    }
                    else if ( FAILED(hr))
                    {
                        goto Cleanup;
                    }

                    IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );                

                    selCounter.BeginSelectionChange();
                    hr = SetCurrentTracker( myType , spDispStart, spDispEnd );
                    selCounter.EndSelectionChange();                    
                }

                //
                // We must hide the caret that was just positioned if the
                // context is being set to a no-scope element.  The start
                // and end pointers will be set to before and after the element,
                // so the caret will actually be hidden before the element.
                //
                if( _fNoScope )
                {
                    CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
                }
                
            }
            else
            {
                CCaretTracker::SetCaretVisible( GetDoc(), FALSE );
            }            
        }
#ifdef FORMSMODE
    }            
#endif

Cleanup:
    if ( ShouldDestroyAdorner() == S_OK )         
        DestroyAdorner();

    RRETURN ( hr );    
}

//
// CHeck to see if we should tear down the existing adorner
// for the current edit context
//
HRESULT
CSelectionManager::ShouldDestroyAdorner()
{
    HRESULT hr;
    SP_IHTMLElement spAdornElement;;

    if ( _pAdorner )
    {
        IFC( GetElementToAdorn( GetEditableElement(), & spAdornElement ));
        hr = SameElements( _pAdorner->GetAdornedElement(), spAdornElement ) ? S_FALSE : S_OK;
    }
    else
        hr = S_FALSE;
        
Cleanup:
    RRETURN1( hr, S_FALSE );
}

HRESULT
CSelectionManager::GetElementToAdorn(
            IHTMLElement* pIElement , 
            IHTMLElement** ppIElement , 
            BOOL* pfAtBoundaryOfVL)
{
    HRESULT hr = S_OK ;
    SP_IHTMLElement spAdorn;
    BOOL fAtVL = FALSE;
    
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK  )
    {
        IFC( GetEditor()->GetMasterElement( pIElement, ppIElement ));   
        fAtVL = TRUE;
    }
    else
    {
        *ppIElement = pIElement;
        (*ppIElement)->AddRef();
        
    }
Cleanup:
    if ( pfAtBoundaryOfVL )
        *pfAtBoundaryOfVL = fAtVL;  
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsCaretAlreadyWithinContext
//
// Synopsis: Look and see if the physical Caret is already within the edit context
//           This is a check to see if we previously had the focus - and we can just restore
//           the caret to where we were
//          
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsCaretAlreadyWithinContext(BOOL * pfVisible /* =NULL*/)
{
    HRESULT           hr ;
    SP_IMarkupPointer spPointer;
    SP_IHTMLCaret     spCaret;
    BOOL              fInEdit = FALSE;
    BOOL              fPositioned = FALSE;

    IFC( GetEditor()->CreateMarkupPointer( & spPointer ));
    
    IFC( GetDisplayServices()->GetCaret( & spCaret ));    
    IFC( spCaret->MoveMarkupPointerToCaret( spPointer ));
    IFC( spPointer->IsPositioned( & fPositioned ));

    if ( fPositioned )
    {    
        IFC( IsInEditContext( spPointer, & fInEdit, TRUE /* fCheckContainer */));
    }

    if ( pfVisible )
    {
        IFC( spCaret->IsVisible( pfVisible ));
    }


Cleanup:
    return  fInEdit ;
}


//+====================================================================================
//
// Method: EnsureAdornment
//
// Synopsis: Ensure that if it's valid for us to have a UI-Active border - that we have one.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureAdornment( BOOL fFireEventLikeIE5 )
{
    //
    // Create a UI-Active adorner, if the TrackerType() is CONTROL, we may
    // have a NO-SCOPE element becoming current.  If we are drilling into a
    // no scope item, then create an adorner for the element
    // 
    if ( ShouldElementShowUIActiveBorder(fFireEventLikeIE5) &&
         _fEditFocusAllowed && 
         !_pAdorner &&
         (GetTrackerType() != TRACKER_TYPE_Control) &&
         !IsDontChangeTrackers() )
    {
        IGNORE_HR( CreateAdorner() );
    }
 
    RRETURN( S_OK );
}

HRESULT
CSelectionManager::EmptySelection(
                        BOOL   fHideCaret /*= FALSE */,
                        BOOL   fChangeTrackerAndSetRange /*=TRUE*/) // If called from the OM Selection, it may want to hide the caret
{
    HRESULT                 hr = S_OK;
    
    SP_IMarkupPointer       spPointer;
    SP_IMarkupPointer       spPointer2;
    SP_IDisplayPointer      spDispPointer;
    SP_IDisplayPointer      spDispPointer2;
    SP_ISegmentList         spSegmentList;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;   
    BOOL                    fEmpty = FALSE;

    if ( _fInFireOnSelect )
    {
        _fFailFireOnSelect = TRUE;
    }
    
    IFC( EnsureEditContext() );    
    IFC( GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );

    //
    // We will always position the Caret on Selection End. The Caret will decide
    // whehter it's visible
    //
    IFC( GetEditor()->CreateMarkupPointer( &spPointer ));
    IFC( GetEditor()->CreateMarkupPointer( &spPointer2 ));

    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer ));
    IFC( GetDisplayServices()->CreateDisplayPointer( &spDispPointer2 ));

    IFC( spSegmentList->IsEmpty( &fEmpty ) )
    if( !fEmpty  )
    {
        IFC( spSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );

        IFC( spSegment->GetPointers( spPointer, spPointer2 ));
        
        IFC( spDispPointer->MoveToMarkupPointer(spPointer, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        
        IFC( spDispPointer2->MoveToMarkupPointer(spPointer2, NULL) );
        IFC( spDispPointer2->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );
        
        AssertSz( hr == 0 , "Unable to position pointers");
    }

    // Clear the segments
    IFC( _pActiveTracker->EmptySelection(fChangeTrackerAndSetRange) );

    if ( fChangeTrackerAndSetRange )
    {
        //
        // After the delete the BOL'ness maybe invalid. Force a recalc.
        //
        _pActiveTracker->SetRecalculateBOL( TRUE);

        //
        // We want to have currency if this becomes empty. #95487
        //
        SetEnabled(TRUE);

        IFC( SetCurrentTracker( TRACKER_TYPE_Caret, spDispPointer, spDispPointer2 ) );
    }

    if( fHideCaret )
    {
        if ( fChangeTrackerAndSetRange )
        {
            IFC( EnsureDefaultTrackerPassive()); // go to a passive state.           
        }
        else
            CCaretTracker::SetCaretVisible( GetDoc(), FALSE);
    }

Cleanup:

    RRETURN ( hr );
}


//+====================================================================================
//
// Method: OnTimerTick
//
// Synopsis: Callback from Trident - for WM_TIMER messages. Route these to the tracker (if any).
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::OnTimerTick()
{
    HRESULT hr = S_OK;
    Assert( _pActiveTracker );
    hr = _pActiveTracker->OnTimerTick();
    RRETURN1 ( hr, S_FALSE );
}

//+====================================================================================
//
// Method: DeleteSelection
//
// Synopsis: Do the deletion of the Selection by firing IDM_DELETE
//
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::DeleteSelection(BOOL fAdjustPointersBeforeDeletion )
{
    HRESULT hr = S_OK;

    Assert( _fContextEditable );
    
    if( GetActiveTracker()->GetTrackerType() == TRACKER_TYPE_Selection )
    {
        IFC( DYNCAST( CSelectTracker, _pActiveTracker )->DeleteSelection( fAdjustPointersBeforeDeletion ) );
    }
        

Cleanup:
    RRETURN( hr );
}

IHTMLDocument2*
CSelectionManager::GetDoc()
{
    return _pEd->GetDoc();
}

//+====================================================================================
//
// Method: HandleAdornerResize
//
// Synopsis: Check to see if the down-click was inside the UI-Active adorner of the Edit
//           context.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::HandleAdornerResize( 
                        CEditEvent* pEvent  , 
                        SST_RESULT* peResult )
{
    HRESULT    hr = S_OK;    
    SST_RESULT eResult = SST_NO_CHANGE;        
    BOOL       fInResize = FALSE;
    BOOL       fInMove = FALSE;
    DWORD      dwTCFlags = 0;
    
    
    Assert( pEvent && _pAdorner );

    fInResize = _pAdorner->IsInResizeHandle(pEvent);
    if ( ! fInResize )
        fInMove = _pAdorner->IsInMoveArea(pEvent);
    
    if ( fInMove || fInResize )
    {
        TRACKER_TYPE    eType = GetTrackerType();

        DestroyAdorner();

        //
        // We are transitioning from a UI Active tracker, to begin a move/resize
        // If we have a text selection - we whack it - or else we will end up dragging
        // the text (and mess-up access which uses the type of selection)
        // IE 5 Bug 39974
        //
        if ( GetTrackerType() == TRACKER_TYPE_Selection )
            EmptySelection(FALSE/*fHideCaret*/,FALSE/*fChangeTrackerAndSetRange*/);
        //
        // we are transitioning from a UI Active tracker
        // to a SiteSelected tracker, and will allow dragging/resizing.
        // We need to force a currency change here ( important for OLE Controls )
        // BUT We don't want to whack any trackers on the set edit context
        //
        SP_IHTMLElement spElement = GetEditableElement();
        
        SetDontChangeTrackers( TRUE );
        IGNORE_HR( GetEditor()->MakeParentCurrent( spElement ));
        SetDontChangeTrackers( FALSE );

        if ( !fInMove  )
        {
            //
            // More specialness for going from UI-Active to a live resizing site selection
            // we need to listed for the AdornerPositioned Notification from the tracker
            // to then tell the tracker to to go "live"
            //
            _fPendingAdornerPosition = TRUE;
            _lastEvent = new CHTMLEditEvent( DYNCAST( CHTMLEditEvent, pEvent ));
            if (_lastEvent == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }

        if (fInMove)
        {
            dwTCFlags |= TRACKER_CREATE_ACTIVEONMOVE;
        }

        dwTCFlags |= TRACKER_CREATE_GOACTIVE;

        hr =  SetCurrentTracker( TRACKER_TYPE_Control ,
                                 pEvent,
                                 dwTCFlags,
                                 CARET_MOVE_NONE,
                                 FALSE,
                                 spElement  );

        //  Make sure we are still in a control tracker
        if (!hr && !fInMove && GetTrackerType() == TRACKER_TYPE_Control)
            AdornerPositionSet(); // marka says this will just do the magic

        //  Did the tracker change?
        if (eType != GetTrackerType())
            eResult = SST_TRACKER_CHANGED;            
    }
 
    *peResult = eResult;

Cleanup:
    RRETURN ( hr );
}


HRESULT
CSelectionManager::ShouldHandleEventInPre( CEditEvent* pEvent )
{
    HRESULT hr = S_FALSE ;
    ELEMENT_TAG_ID      eTag;
    SP_IHTMLElement     spElement ;
    SST_RESULT          eResult      = SST_NO_CHANGE;

    switch( pEvent->GetType() )
    {
        case EVT_LMOUSEDOWN:
        case EVT_RMOUSEDOWN:
        case EVT_MMOUSEDOWN:
        {
            IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));

            IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));

            if (eResult == SST_NO_CHANGE && CheckAtomic(spElement) == S_OK)
            {
                IFC(_pSelectTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
            }

            hr = ( ( eResult == SST_CHANGE ) || 
                   ( eResult == SST_NO_BUBBLE && GetTrackerType() == TRACKER_TYPE_Control ) )
                     ? S_OK 
                     : S_FALSE;
        }
        break;

        //
        // This message is generated when Trident receives a WM_LBUTTONDBLCLK message.
        // We need to always handle this event in the PRE, because CDoc::PumpMessage
        // will sometimes cause the LBUTTONDBLCLK message to get swallowed after 
        // giving it to the editor in the PRE, so we don't get the EVT_INTDBLCLK in the
        // post handle message
        //
        case EVT_INTDBLCLK:
            hr = S_OK;
            break;
            
        
    }
    
Cleanup:
    RRETURN1( hr, S_FALSE );
    
}

//+====================================================================================
//
// Method:
//
// Synopsis: An Event has occurred, which may require changing of the current tracker,
//           poll all your trackers, and see if any require a change.
//
//           If any trackers require changing, end them, and start the new tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ShouldChangeTracker(
                        CEditEvent *pEvent  ,
                        BOOL       *pfStarted)
{
    ELEMENT_TAG_ID      eTag;
    HRESULT             hr           = S_OK;
    SP_IHTMLElement     spElement ;
    SST_RESULT          eResult      = SST_NO_CHANGE;
    TRACKER_TYPE        eTrackerType = TRACKER_TYPE_None;
    
    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    IFC ( pEvent->GetElementAndTagId( &spElement, & eTag ));

    if ( pEvent && _pAdorner )
    {
        IFC( HandleAdornerResize( pEvent, & eResult )) ;
        if ( eResult == SST_TRACKER_CHANGED )
        {
            goto Cleanup;
        }
    }

    IFC( _pControlTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
    if ( eResult == SST_CHANGE )
    {
        eTrackerType = TRACKER_TYPE_Control;
    }
    else if ( eResult != SST_NO_BUBBLE )
    {
        IFC( _pSelectTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
        if ( eResult == SST_CHANGE )
        {
           eTrackerType = TRACKER_TYPE_Selection;
        }
        else if ( eResult != SST_NO_BUBBLE )        
        {
           IFC( _pCaretTracker->ShouldStartTracker( pEvent, eTag, spElement, &eResult ));
           if ( eResult == SST_CHANGE )
           {
                eTrackerType = TRACKER_TYPE_Caret;    
           }
        }
    }    
    
    if ( eResult == SST_CHANGE )
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.BeginSelectionChange();

        hr = THR( SetCurrentTracker( eTrackerType, pEvent, 0));
         // fire the selectionchange event
        selCounter.EndSelectionChange();         
    }

Cleanup:
    if ( eResult == SST_CHANGE || eResult == SST_TRACKER_CHANGED )
        *pfStarted = TRUE ;
    else
        *pfStarted = FALSE;
        
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: ChangeTracker
//
// Synopsis: Change what my Tracker is
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ChangeTracker( TRACKER_TYPE eType, CEditEvent* pEvent)
{
    HRESULT hr = S_OK;

    //
    // Did we just destroy a text selection?
    //
    _fDestroyedTextSelection = ( _pActiveTracker                                            && 
                                _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection &&
                                 _pSelectTracker->GetMadeSelection() );
                                 
    if ( _pActiveTracker ) // possible to be null on startup.
    {
        IFC( HibernateTracker( pEvent, eType ));
    }        
    
    switch ( eType )
    {
        case TRACKER_TYPE_Caret:
            _pActiveTracker = _pCaretTracker;            
            break;

        case TRACKER_TYPE_Selection:
            _pActiveTracker = _pSelectTracker;
            break;

        case TRACKER_TYPE_Control:
            _pActiveTracker = _pControlTracker;
            break;
    }
    IFC( _pActiveTracker->Awaken() );

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: SetCurrent Tracker.
//
// Synopsis: Set what the current tracker is from MarkupPointers
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::SetCurrentTracker(
                        TRACKER_TYPE        eType ,
                        IDisplayPointer*    pDispStart,
                        IDisplayPointer*    pDispEnd,
                        DWORD               dwTCFlagsIn,
                        CARET_MOVE_UNIT     inLastCaretMove,
                        BOOL                fSetTCFromActiveTracker /*= TRUE*/)
{
    HRESULT  hr = S_OK;
    DWORD    dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType );
    
    hr = _pActiveTracker->Init2( pDispStart, pDispEnd, dwTCFlags, inLastCaretMove );

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     SetCurrentTracker
//
//  Synopsis:   ISegmentList based way of starting a tracker.
//
//----------------------------------------------------------------------------

HRESULT 
CSelectionManager::SetCurrentTracker(                     
                        TRACKER_TYPE    eType , 
                        ISegmentList*   pSegmentList,
                        DWORD           dwTCFlagsIn /*=0*/,
                        CARET_MOVE_UNIT inLastCaretMove /*=CARET_MOVE_NONE*/, 
                        BOOL            fSetTCFromActiveTracker /*=FALSE*/ )
{
    HRESULT  hr  = S_OK;
    DWORD    dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType );
    
    hr = _pActiveTracker->Init2( pSegmentList, dwTCFlags, inLastCaretMove );

    RRETURN ( hr );
 }
            
//+====================================================================================
//
// Method: SetCurrent Tracker.
//
// Synopsis: Set what the current tracker is from a SelectionMessage
//
//------------------------------------------------------------------------------------


HRESULT
CSelectionManager::SetCurrentTracker(
                            TRACKER_TYPE    eType ,
                            CEditEvent*     pEvent,
                            DWORD           dwTCFlagsIn,
                            CARET_MOVE_UNIT inLastCaretMove,
                            BOOL            fSetTCFromActiveTracker /*= TRUE*/,
                            IHTMLElement    *pIElement /*=NULL*/)
{
    HRESULT         hr        = S_OK;
    DWORD           dwTCFlags = dwTCFlagsIn ;

    Assert( _pCaretTracker && _pSelectTracker && _pControlTracker);

    ChangeTracker( eType, pEvent );
    
    hr = _pActiveTracker->Init2( pEvent , dwTCFlags, pIElement );

    RRETURN ( hr );
}

HRESULT
CSelectionManager::CreateFakeSelection(IHTMLElement* pIElement, IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr;

    Assert( ! _pIRenderSegment );
    
    IFC( GetEditor()->GetHighlightServices()->AddSegment( 
                                                                pDispStart, 
                                                                pDispEnd, 
                                                                GetSelRenderStyle(), 
                                                                &_pIRenderSegment ));
    IFC( AttachDragListener( pIElement ));

Cleanup:    

    RRETURN( hr );    
}

HRESULT
CSelectionManager::DestroyFakeSelection()
{
    HRESULT hr = S_OK;
   
    if ( _pIRenderSegment )
    {
        IFC( GetEditor()->GetHighlightServices()->RemoveSegment( _pIRenderSegment ) );
        ClearInterface( &_pIRenderSegment );
        IFC( DetachDragListener());
    }

Cleanup:

    RRETURN( hr );    
}

HRESULT 
CDragListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                _pMan->DestroyFakeSelection();
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

HRESULT 
CDropListener::Invoke(
                        DISPID      dispidMember,
                        REFIID      riid,
                        LCID        lcid,
                        WORD        wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT    *pvarResult,
                        EXCEPINFO  *pexcepinfo,
                        UINT       *puArgErr)
{
    HRESULT          hr = S_OK ;
    SP_IHTMLElement  spElement;
    SP_IHTMLEventObj spObj;

    if( _pMan )
    {
        if (pdispparams && pdispparams->rgvarg[0].vt == VT_DISPATCH && pdispparams->rgvarg[0].pdispVal)
        {
            IFC ( pdispparams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&spObj) );
            if ( spObj )
            {
                CVariant cvarRet;
                
                IFC( spObj->get_returnValue( & cvarRet ));
                
                if ( ( V_VT( & cvarRet ) == VT_BOOL )  &&
                     ( V_BOOL( & cvarRet ) == VARIANT_FALSE ) )
                {
                    _pMan->OnDropFail();
                }
            }
        }
    }

Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: EnsureDefaultTracker
//
// Synopsis: Make sure we always have a current tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureDefaultTracker(BOOL fFireOnChangeSelect /*=TRUE*/ )
{
    HRESULT hr = S_OK;
    CEditTracker* pTrack = _pActiveTracker;
    
    IFC( ChangeTracker( TRACKER_TYPE_Caret ));
    IFC( _pActiveTracker->Init2());

    // fire the type change event
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.SelectionChanged( fFireOnChangeSelect && pTrack != NULL );
    }
    
Cleanup:
    RRETURN ( hr );    
}

BOOL
CSelectionManager::IsDefaultTracker()
{
    return ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret );
}

BOOL
CSelectionManager::IsDefaultTrackerPassive()
{
    return ( ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Caret ) &&
               _pActiveTracker->IsPassive() );
}

//+====================================================================================
//
// Method: EnsureDefaultTrackerPassive
//
// Synopsis: Return to the "default tracker" and make it's state passive
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::EnsureDefaultTrackerPassive(
                                                CEditEvent* pEvent /* = NULL */, 
                                                BOOL fFireOnChangeSelect /*=TRUE*/)                                                
{
    HRESULT hr = S_OK;
    
    if ( !IsDefaultTracker() || !_pActiveTracker->IsPassive() )
    {
        IFC( HibernateTracker( pEvent, TRACKER_TYPE_Caret, TRUE ));
        IFC( EnsureDefaultTracker( fFireOnChangeSelect ));
    }
    
Cleanup:
    RRETURN( hr );
}    

//+====================================================================================
//
// Method: StartSelectionFromShift
//
// Synopsis:
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::StartSelectionFromShift(
                            CEditEvent* pEvent )
{
    HRESULT hr = S_OK;

    IDisplayPointer* pDispStartCaret = NULL ;
    IDisplayPointer* pDispEndCaret = NULL   ;
    LONG  eLineDir = LINE_DIRECTION_LeftToRight;
    SP_IHTMLCaret      spCaret;
    DWORD dwCode = TRACKER_CREATE_STARTFROMSHIFTKEY;
    CARET_MOVE_UNIT eCaretMove = CARET_MOVE_NONE;
    POINT   ptGlobal;
    BOOL    fVertical = FALSE;
    SP_ILineInfo spLineInfo;
    SP_IMarkupPointer   spMarkup;
    SP_IHTMLElement     spElement;
    CSelectionChangeCounter selCounter(this);

    Assert( GetTrackerType() == TRACKER_TYPE_Caret );
    CCaretTracker* pCaretTracker = DYNCAST( CCaretTracker, _pActiveTracker );

    IFC( GetDisplayServices()->CreateDisplayPointer( & pDispStartCaret ));
    IFC( GetDisplayServices()->CreateDisplayPointer( & pDispEndCaret ));

    
    IFC( GetDisplayServices()->GetCaret( &spCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispStartCaret ));
    IFC( spCaret->MoveDisplayPointerToCaret( pDispEndCaret ));
    IFC( spCaret->GetLocation( &ptGlobal , TRUE /* fTranslate to global */));
    IFC( pDispStartCaret->GetLineInfo(&spLineInfo) );
    IFC( spLineInfo->get_lineDirection(&eLineDir));

    IFC( GetEditor()->CreateMarkupPointer(&spMarkup) );
    IFC( pDispEndCaret->PositionMarkupPointer(spMarkup) );
    IFC( spMarkup->CurrentScope(&spElement) );
    IFC( MshtmledUtil::IsElementInVerticalLayout(spElement, &fVertical) );

    eCaretMove = CCaretTracker::GetMoveDirectionFromEvent( pEvent, (eLineDir == LINE_DIRECTION_RightToLeft), fVertical);

    if ( FAILED( pCaretTracker->MovePointer( eCaretMove, pDispEndCaret, &ptGlobal, NULL )))
    {
        if ( pCaretTracker->GetPointerDirection(eCaretMove) == RIGHT)
        {
            IGNORE_HR(  pCaretTracker->MovePointer( CARET_MOVE_LINEEND, pDispEndCaret, &ptGlobal, NULL ));
        }
        else
        {
            IGNORE_HR(  pCaretTracker->MovePointer( CARET_MOVE_LINESTART, pDispEndCaret, &ptGlobal, NULL ));     
        }    
    }

    IGNORE_HR( pDispEndCaret->ScrollIntoView() );   // DO NOT CHANGE THIS TO AN IFC. It can return S_FALSE - saying we didn't handle the event.
                                                    // if you change this to an IFC - YOU WILL BREAK THE DRT ( try merge.js in edit2.js)

    selCounter.BeginSelectionChange();
    
    SetCurrentTracker(  TRACKER_TYPE_Selection,
                        pDispStartCaret,
                        pDispEndCaret, 
                        dwCode, 
                        eCaretMove,
                        FALSE );

    // fire the selectionchange event
    selCounter.EndSelectionChange() ;

Cleanup:
    ReleaseInterface( pDispStartCaret);
    ReleaseInterface( pDispEndCaret);
    RRETURN1( hr, S_FALSE );
}

//+====================================================================================
//
// Method: Hibernate Tracker
//
// Synopsis: Make the current tracker become dormant.
//
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::HibernateTracker(CEditEvent      *pEvent,
                                    TRACKER_TYPE    eType,
                                    BOOL            fTearDownUI /* = TRUE*/ )
{
    HRESULT hr = S_OK;
    
    Assert( _pActiveTracker );
    
    CEditTracker * pTracker = _pActiveTracker;
    pTracker->BecomeDormant( pEvent, eType, fTearDownUI );
    

    //
    // After we kill ANY tracker, we better not have capture or a timer.
    //
    Assert( !_fInTimer );
    Assert( !_fInCapture );

    RRETURN( hr );
}

SELECTION_TYPE
CSelectionManager::ConvertTrackerType(TRACKER_TYPE eType)
{
    SELECTION_TYPE selType = SELECTION_TYPE_None;
    switch (eType)
    {
        case TRACKER_TYPE_Caret :
            selType =  SELECTION_TYPE_Caret;
            break;

        case TRACKER_TYPE_Selection :
            selType =  SELECTION_TYPE_Text;
            break;

        case TRACKER_TYPE_Control :
            selType =  SELECTION_TYPE_Control;
            break;
    }
    return selType;
}

TRACKER_TYPE
CSelectionManager::ConvertSelectionType(SELECTION_TYPE eType)
{
    TRACKER_TYPE trType = TRACKER_TYPE_None;
    switch (eType)
    {
        case SELECTION_TYPE_Caret :
            trType =  TRACKER_TYPE_Caret;
            break;

        case SELECTION_TYPE_Text :
            trType =  TRACKER_TYPE_Selection;
            break;

        case SELECTION_TYPE_Control :
            trType =  TRACKER_TYPE_Control;
            break;
    }
    return trType;
}

SELECTION_TYPE
CSelectionManager::GetSelectionType()
{
    if ( _pActiveTracker )
        return ConvertTrackerType(_pActiveTracker->GetTrackerType());
    else
        return SELECTION_TYPE_None;
}

HRESULT
CSelectionManager::GetSelectionType ( 
                              SELECTION_TYPE * peSelectionType )
{
    HRESULT hr = S_OK;

    Assert( peSelectionType );

    if ( peSelectionType )
    {
        *peSelectionType = GetSelectionType();
    }
    else
        hr = E_INVALIDARG;

    RRETURN ( hr );
}

TRACKER_TYPE
CSelectionManager::GetTrackerType()
{
    if ( _pActiveTracker )
        return _pActiveTracker->GetTrackerType();
    else
        return TRACKER_TYPE_None;
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::NotifyBeginSelection
//
//  Synopsis:   Posts a WM_BEGINSELECTION message to every Trident HWND.  This allows
//              other trident instances to determine when a selection has been started
//              in a seperate trident instance.
//
//  Arguments:  wParam = Additional data to post with WM_BEGINSELECTION
//
//  Returns:    HRESULT indicating success
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::NotifyBeginSelection(WPARAM wParam)
{
    HRESULT hr = S_OK;
    HWND    hwndCur;                        // Current HWND for trident
    HWND    hwndParent;                     // Parent window walk
    HWND    hwndTopTrident = NULL;          // Top HWND of trident

    IFC( GetEditor()->GetHwnd( &hwndCur ) );
    
    SetNotifyBeginSelection(TRUE);

    //
    // Find the topmost Instance of Trident
    //
    while(hwndCur)
    {
        if ( EdUtil::IsTridentHwnd( hwndCur ))
        {
            hwndTopTrident = hwndCur;
        }    
        hwndParent = hwndCur;
        hwndCur = GetParent(hwndCur);        
    }

    if( hwndTopTrident )
    {
        ::SendMessage( hwndTopTrident,
                       WM_BEGINSELECTION, 
                       wParam ,
                       0);
    }

    SetNotifyBeginSelection(FALSE);
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: Notify
//
// Synopsis: This is the 'external' notify - used by Trident to tell the selection manager
//           that 'something' has happened that it should do soemthing about.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::Notify(
        EDITOR_NOTIFICATION eSelectionNotification,
        IUnknown* pUnknown,
        DWORD dword )
{
    HRESULT hr = S_OK;

    if (eSelectionNotification != EDITOR_NOTIFY_DOC_ENDED &&
        eSelectionNotification != EDITOR_NOTIFY_YIELD_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_BEFORE_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_EXIT_TREE &&
        eSelectionNotification != EDITOR_NOTIFY_LOSE_FOCUS &&
        eSelectionNotification != EDITOR_NOTIFY_ATTACH_WIN
        )
        IFC( EnsureEditContext() );
    
    switch( eSelectionNotification )
    {
        case EDITOR_NOTIFY_BEFORE_CURRENCY_CHANGE:
            {
                //
                // disallow currency changes on unselectable.
                //
                SP_IHTMLElement spElement;
                IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
                if ( CheckUnselectable( spElement) == S_OK )
                {
                    hr = S_FALSE;
                }
            }
            break;
            
        case EDITOR_NOTIFY_BEGIN_SELECTION_UNDO:
        case EDITOR_NOTIFY_UPDATE_CARET:
            hr = THR( DoPendingTasks() );
            break;

        case EDITOR_NOTIFY_EDITABLE_CHANGE :
            {
                SP_IHTMLElement spElement;
                ELEMENT_TAG_ID  eTag;
                IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
                IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));

                Assert( eTag != TAGID_ROOT );
                if( eTag != TAGID_ROOT )
                {               
                    hr = EditableChange( pUnknown);
                }
            }
            break;
            
        case EDITOR_NOTIFY_YIELD_FOCUS:
                IFC( YieldFocus( pUnknown) );
            break;
            
        case EDITOR_NOTIFY_CARET_IN_CONTEXT:
            hr = CaretInContext();
            break;

        case EDITOR_NOTIFY_TIMER_TICK:
            hr = OnTimerTick(  );
            break;

        case EDITOR_NOTIFY_EXIT_TREE:
        case EDITOR_NOTIFY_SETTING_VIEW_LINK:
            {
                //
                // An element left the tree.  This potentially caused a change in our cached
                // values for our display pointers, so increment the counter so that
                // the events 
                GetEditor()->IncEventCacheCounter();
                hr = ExitTree( pUnknown );
            }

            // We are setting the viewlink here.  We need to destroy our selection because
            // we may crash when trying to destroy the selection after the viewlink is set
            // if the viewlink removes the selection context.  Pending tasks will clean up.
            if (hr == S_OK && eSelectionNotification == EDITOR_NOTIFY_SETTING_VIEW_LINK)
            {
                if (GetTrackerType() == TRACKER_TYPE_Selection)
                {
                    DYNCAST( CSelectTracker, _pActiveTracker )->EmptySelection();
                }
            }
            break;

        case EDITOR_NOTIFY_BEFORE_FOCUS:
            {
                SP_IHTMLEventObj spEventObj;
                SP_IHTMLElement spElement;
                ELEMENT_TAG_ID  eTag;
                
                IFC( pUnknown->QueryInterface( IID_IHTMLEventObj, (void**) & spEventObj));
                IFC( spEventObj->get_toElement( & spElement ));                
                IFC( GetMarkupServices()->GetElementTagId( spElement, & eTag ));

                Assert( eTag != TAGID_ROOT );
                if( eTag != TAGID_ROOT )
                {               
                    IFC( SetEditContextFromCurrencyChange( spElement, dword , spEventObj ));
                }
            }
            break;

        case EDITOR_NOTIFY_DOC_ENDED:

            
            if ( ! IsInFireOnSelectStart() )
            {
                IFC( EnsureDefaultTrackerPassive( NULL,  FALSE ));
            }                    
            else
            {
                //
                // We're unloading during firing of OnSelectStart
                // We want to not kill the tracker now - but fail the OnSelectStart
                // resulting in the Tracker dieing gracefully.
                //
                SetFailFireOnSelectStart( TRUE );
            }
            
            if ( eSelectionNotification == EDITOR_NOTIFY_DOC_ENDED )
            {
                SetDrillIn( FALSE );
            }

            //
            // Sometimes we navigate away to a different URL
            // without losing focus. So we double-check to 
            // terminate IME composition. 
            //
            if (IsIMEComposition())
            {
                IGNORE_HR(TerminateIMEComposition(TERMINATE_FORCECANCEL));
            }
            break;
            
        case EDITOR_NOTIFY_LOSE_FOCUS_FRAME: 
            //
            // Selection is being made in another frame/instance of trident
            // we just kill ourselves.
            //
            if( ! _fNotifyBeginSelection && !GetEditor()->GetActiveCommandTarget()->IsKeepSelection())
            {
                hr = LoseFocusFrame( dword );
            }
            
            break;

        case EDITOR_NOTIFY_LOSE_FOCUS:
            _fLastMessageValid = FALSE;
            hr = LoseFocus();
            break;

        case EDITOR_NOTIFY_ATTACH_WIN:
            {
                Assert ( GetEditor() ); // This is true for now since we fire this notification only after Editor is created!
                hr = GetEditor()->SetupActiveIMM(pUnknown);
            }
            break;
    }

Cleanup:

    RRETURN1 ( hr, S_FALSE );
}


HRESULT
CSelectionManager::YieldFocus( IUnknown* pUnkElemNext )
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spElement;
    SP_IObjectIdentity spIdent;

    if( pUnkElemNext )
    {
        IFC( pUnkElemNext->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
        IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

        if ( spIdent->IsEqualObject( GetEditableElement() ) == S_FALSE &&
             IsElementContentSameAsContext( spElement) != S_OK )
        {
            //
            // an element other than the edit context is becoming current.
            // we whack the caret if there is one.
            // at some point we may want to hide selection
            //
            if ( GetTrackerType() == TRACKER_TYPE_Caret && 
                 CheckUnselectable(spElement) == S_FALSE )
            {
                EnsureDefaultTrackerPassive();
            }
            SetEnabled( FALSE );
        }
    }
    else
    {
        //
        // ROOT element become active... make sure default tracker is passive
        //
        EnsureDefaultTrackerPassive();
        SetEnabled(FALSE);
    }
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::EditableChange( IUnknown* pUnkElemNext )
{
    HRESULT hr;
    SP_IHTMLElement spElement;
    SP_IObjectIdentity spIdent;
    SP_IMarkupPointer spStart, spEnd ;

    IFC( pUnkElemNext->QueryInterface( IID_IHTMLElement, (void**) & spElement ));
    IFC( spElement->QueryInterface( IID_IObjectIdentity, (void**) & spIdent ));

    IFC( GetEditor()->CreateMarkupPointer( & spStart ));
    IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

    IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin ));
    IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd ));
    
    if ( spIdent->IsEqualObject( GetEditableElement() ) == S_OK ||
         IsElementContentSameAsContext( spElement) == S_OK ||    

        //
        // this is for "reductions" in edit context - ie. a sub-region of the edit context
        // became editable
        //
        
         ( IsInEditContext( spStart ) &&          
           IsInEditContext( spEnd ) &&
           IsEditable( spElement) == S_OK  ) ) 
    {
        IFC( SetEditContextFromElement( spElement ));
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: LoseFocusFrame
//
// Synopsis: Do some work to end the current tracker, and to create/destroy adorners
//           for Iframes
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::LoseFocusFrame( DWORD selType )
{
    HRESULT hr = S_OK;
    
    IFC( EnsureDefaultTrackerPassive());
    
    if ( selType == START_TEXT_SELECTION )
    {
        //
        // I'm in a UIActive control - that doesn't have an adorner
        // Special case Adorner Creation for Iframes. Why ? because the above would
        // have destroyed it
        //
        // Only if this is an Iframe - can we guess that it's ok to create the adorner.
        // otherwise the adorner should be already created around the element that's we're making
        // the selection in.
        // Why all this bizarreitude ? Because IFrames are in one document - and their inner 
        // document is in another
        // 
        if ( !_pAdorner && 
             ShouldElementShowUIActiveBorder()  && 
             GetEditableTagId() == TAGID_IFRAME  )
        {
            hr = THR( CreateAdorner() ) ;
            _pAdorner->InvalidateAdorner() ;
        }
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: ExitTree
//
// Synopsis: Check to see if the element leaving the tree intersects the current selserv.
//           if it does - we tell the SelectionServicesListener.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::ExitTree( IUnknown* pUnknown)
{
    HRESULT         hr = S_OK;
    SP_IHTMLElement spElement;
    SP_ISegmentList spSegmentList;

    
    IFC( pUnknown->QueryInterface( IID_IHTMLElement, (void**) &spElement ));
    IFC( GetEditor()->GetISelectionServices()->QueryInterface( IID_ISegmentList, (void**) & spSegmentList ));

    if( _pIElementExitStart ||
        EdUtil::SegmentIntersectsElement(GetEditor(), spSegmentList, spElement) == S_OK )
    {    
        if ( ! _pIElementExitStart )
        {        
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitStart ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitEnd ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitContentStart ) );
            IFC( GetEditor()->CreateMarkupPointer( & _pIElementExitContentEnd ) );

            IFC( _pIElementExitStart->SetGravity(POINTER_GRAVITY_Left));
            IFC( _pIElementExitEnd->SetGravity(POINTER_GRAVITY_Right));
            IFC( _pIElementExitContentStart->SetGravity(POINTER_GRAVITY_Left));
            IFC( _pIElementExitContentEnd->SetGravity(POINTER_GRAVITY_Right));
            
            IFC( _pIElementExitStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin));
            IFC( _pIElementExitEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd));  

            SP_IMarkupPointer2 spStartContent;
            SP_IMarkupPointer2 spEndContent;

            IFC( _pIElementExitContentStart->QueryInterface( IID_IMarkupPointer2, ( void**) & spStartContent ));
            IFC( _pIElementExitContentEnd->QueryInterface( IID_IMarkupPointer2, ( void**) & spEndContent ));

            IGNORE_HR( spStartContent->MoveToContent( spElement , TRUE));
            IGNORE_HR( spEndContent->MoveToContent( spElement, FALSE ));

            IFC( StartExitTreeTimer());
        }
        else
        {
            // 
            // we have gotten several exit trees, that intersect selection
            // we conglomerate them - and get the "biggest" range
            //
            Assert( _fInExitTimer );
            SP_IMarkupPointer spStart;
            SP_IMarkupPointer spEnd;
            BOOL fRightOf, fLeftOf;
            
            IFC( GetEditor()->CreateMarkupPointer( & spStart ));
            IFC( GetEditor()->CreateMarkupPointer( & spEnd ));

            IFC( spStart->MoveAdjacentToElement( spElement, ELEM_ADJ_BeforeBegin));
            IFC( spEnd->MoveAdjacentToElement( spElement, ELEM_ADJ_AfterEnd));  

            IFC( spStart->IsLeftOf( _pIElementExitStart , & fLeftOf ));
            if ( fLeftOf )
            {
                IFC( _pIElementExitStart->MoveToPointer( spStart ));
            }

            IFC( spEnd->IsRightOf( _pIElementExitEnd , & fRightOf ));
            if ( fRightOf )
            {
                IFC( _pIElementExitEnd->MoveToPointer( spEnd ));
            }

        }

    }
    
Cleanup:
    RRETURN ( hr );
}

HRESULT
CSelectionManager::DoPendingElementExit()
{
    HRESULT hr = S_OK ;
    Assert( _pIElementExitStart || _fInPendingElementExit );
    SP_ISelectionServicesListener spListener;
    BOOL fPosStart, fPosEnd;
    BOOL fPosElemStart, fPosElemEnd;
    BOOL fPosElemCtxStart, fPosElemCtxEnd;
    
    if ( _fInPendingElementExit )
        return S_OK;
        
    _fInPendingElementExit = TRUE;
    if ( GetEditor()->GetISelectionServices()->GetSelectionServicesListener( & spListener ) == S_OK )
    {
        IFC( spListener->OnSelectedElementExit(  _pIElementExitStart, _pIElementExitEnd, _pIElementExitContentStart, _pIElementExitContentEnd ));
    }

    //
    // If we are UI-active, and the element leaving contained us - destroy the UI-active.
    //
    IFC( _pStartContext->IsPositioned( & fPosStart ));
    IFC( _pEndContext->IsPositioned( & fPosEnd ));
    IFC( _pIElementExitStart->IsPositioned( & fPosElemStart ));
    IFC( _pIElementExitEnd->IsPositioned( & fPosElemEnd ));
    IFC( _pIElementExitContentStart->IsPositioned( & fPosElemCtxStart ));
    IFC( _pIElementExitContentStart->IsPositioned( & fPosElemCtxEnd ));
    
    if ( fPosStart && fPosEnd &&
         ( ( fPosElemStart && fPosElemEnd && 
           Between( _pStartContext, _pIElementExitStart, _pIElementExitEnd ) &&
           Between( _pEndContext, _pIElementExitStart, _pIElementExitEnd ) ) ||
         ( fPosElemCtxStart && fPosElemCtxEnd &&
           Between( _pStartContext, _pIElementExitContentStart, _pIElementExitContentEnd ) &&
           Between( _pEndContext, _pIElementExitContentStart, _pIElementExitContentEnd ) ) ) )
    {
        if ( _pAdorner )
            DestroyAdorner();

        //
        // While this call to ClearInterface seems redundant, given that EnsureEditContext() will clear it 
        // and initialize it... we clear the editable element here so that WE FORCE a context change when
        // we attempt to set the edit context.
        //
        ClearInterface( & _pIEditableElement );
        EnsureDefaultTrackerPassive();
        EnsureEditContext( _pIElementExitStart );
    }
    
    
    ClearInterface( & _pIElementExitStart );
    ClearInterface( & _pIElementExitEnd );
    ClearInterface( & _pIElementExitContentStart );
    ClearInterface( & _pIElementExitContentEnd );
 
    Assert( ! IsInCapture());
    Assert( ! IsInTimer() );

    if ( _fInExitTimer )
    {
        IFC( StopExitTreeTimer());
    }
Cleanup:
    _fInPendingElementExit = FALSE;

    RRETURN1( hr , S_FALSE );
}

HRESULT
CSelectionManager::LoseFocus()
{
    HRESULT        hr = S_OK;
    SP_IHTMLCaret  spCaret = 0;

    IFC( GetDisplayServices()->GetCaret( & spCaret ));

    TerminateIMEComposition(TERMINATE_NORMAL);
    
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: CaretInContext
//
// Synopsis: Position a Caret at the start of the edit context. Used to do somehting
//           meaningful on junk, eg. calling select() on a control range that is empty
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::CaretInContext(  )
{
    HRESULT             hr = S_OK;
    SP_IDisplayPointer  spDispPointer;

    IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
    IFC( spDispPointer->MoveToMarkupPointer(_pStartContext, NULL) );
    IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

    hr = THR ( SetCurrentTracker(
                        TRACKER_TYPE_Caret, 
                        spDispPointer, 
                        spDispPointer ) );
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::DestroySelection( )
{
    HRESULT hr = S_OK;
    if( ! IsDontChangeTrackers() )
    {
        // 
        // Destroy any and all selections, by causing the
        // caret tracker to become active
        //
        IFC( EnsureDefaultTrackerPassive() );
        DestroyAdorner();
    }
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method:ShouldElementBeAdorned
//
// Synopsis: Is it valid to show a UI Active border around this element ? 
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::IsElementUIActivatable()
{
    if ( _fParentEditable )
    {
        return IsElementUIActivatable( GetEditableElement());
    }
    else
        return FALSE;        
}

//+====================================================================================
//
// Method:IsElementUIActivatable
//
// Synopsis: Is it valid to show a UI Active border around this element ? 
//
//------------------------------------------------------------------------------------

//**************************************************
//
// This function is called by trident during design time - to see if an element can be made current.
//
// Look out for making this too heavy. Also changes can make different elements become editable
//
//**************************************************

BOOL 
CSelectionManager::IsElementUIActivatable(IHTMLElement* pIElement)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spMaster;
    BOOL fShouldBeActive = FALSE;
    ELEMENT_TAG_ID eTag = TAGID_NULL;

    if (!pIElement)
          goto Cleanup;

    IFC( GetMarkupServices()->GetElementTagId( pIElement, & eTag ));
 
    //
    // Are we inside a viewlink'ed master, and putting inside the master gets us to the edit ctxt ?
    //
    if ( IsAtBoundaryOfViewLink( pIElement ) == S_OK )
    {
        fShouldBeActive = TRUE;
        goto Cleanup;
    }


    switch( eTag )
    {
        case TAGID_INPUT:
        case TAGID_BUTTON:
//      case TAGID_HTMLAREA:
        case TAGID_TEXTAREA:
        case TAGID_DIV:
        case TAGID_SPAN:   // Divs and Spans - because if these have the Edit COntext - they must be current.
        case TAGID_LEGEND:
        case TAGID_MARQUEE:
        case TAGID_IFRAME:
        case TAGID_SELECT:
            fShouldBeActive = TRUE;
            break;

        case TAGID_BODY:                
        case TAGID_TABLE:
            goto Cleanup; // skip the positioning checks here for these common cases

        case TAGID_OBJECT:
        {
            fShouldBeActive = ShouldObjectHaveBorder(pIElement);
        }
        break;
    }
    
    if ( ! fShouldBeActive )
    {
        fShouldBeActive = (IsLayout( pIElement ) == S_OK);
    }

Cleanup:
    return fShouldBeActive;
}

EXTERN_C const CLSID CLSID_AppletOCX = { 0x08B0e5c0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01 };
EXTERN_C const IID IID_IActiveDesigner;

//+====================================================================================
//
// Method:ShouldObjectHaveBorder
//
// Synopsis: Should there be a border around the object element
//
//------------------------------------------------------------------------------------

BOOL 
CSelectionManager::ShouldObjectHaveBorder(IHTMLElement* pIElement)
{
    HRESULT             hr = S_OK;
    SP_IPersist         spPersist;
    BOOL                fBorder = FALSE;
    BOOL                fJavaApplet = FALSE;
    BOOL                fHasClassid = FALSE;
    CLSID               classid;

    Assert(pIElement);

    hr = THR_NOTRACE(pIElement->QueryInterface(IID_IPersist, (void **)&spPersist));
    if (hr == S_OK)
    {
        fHasClassid = TRUE;
        IGNORE_HR(spPersist->GetClassID(&classid));
        if (IsEqualGUID((REFGUID)classid, (REFGUID)CLSID_AppletOCX))
            fJavaApplet = TRUE;
    }

    if (!fJavaApplet)
    {
        SP_IOleControl      spCtrl;
        SP_IQuickActivate   spQA;

        hr = THR_NOTRACE(pIElement->QueryInterface(IID_IQuickActivate, (LPVOID*)&spQA));
        if (hr)  // not a quick activate control
        {
            hr = THR_NOTRACE(pIElement->QueryInterface(IID_IOleControl, (LPVOID*)&spCtrl));
            if (hr == S_OK) // is ole control
                fBorder = TRUE;
        }
    }

    if (GetCommandTarget()->IsNoActivateNormalOleControls() ||
        GetCommandTarget()->IsNoActivateDesignTimeControls() ||
        GetCommandTarget()->IsNoActivateJavaApplets() )
    {
        SP_IUnknown     spAD;
        BOOL            fDesignTimeControl = FALSE;

        if (S_OK == (pIElement->QueryInterface(IID_IActiveDesigner, (LPVOID*)&spAD)))
            fDesignTimeControl = TRUE;

        fBorder = ( (GetCommandTarget()->IsNoActivateNormalOleControls()  && fDesignTimeControl) ||
                    (GetCommandTarget()->IsNoActivateDesignTimeControls() && fJavaApplet) ||
                    (GetCommandTarget()->IsNoActivateJavaApplets() && !fDesignTimeControl && !fJavaApplet) ) ;
    }

    //
    // If NoUIActivateInDesign is set, then override this if they support 
    // CATID_DesignTimeUIActivatableControl. Note that anything with an appropriate
    // CATID will be UI active even if the HOST tells us not to do so.
    //

    if (fBorder)
    {
        //
        // Get the category manager
        //
        SP_ICatInformation spCatInfo;
        
        hr = THR(CoCreateInstance(
                        CLSID_StdComponentCategoriesMgr, 
                        NULL, 
                        CLSCTX_INPROC_SERVER, 
                        IID_ICatInformation, 
                        (void **) &spCatInfo));

        if (hr) // couldn't get the category manager--
            goto Cleanup;

        Assert(spCatInfo.p);
        
        //
        // Check if control supports CATID_DesignTimeUIActivatableControl
        //
        CATID rgcatid[1];
        rgcatid[0] = CATID_DesignTimeUIActivatableControl;

        if (fHasClassid)
        {
            fBorder = (spCatInfo->IsClassOfCategories(classid, 1, rgcatid, 0, NULL) != S_OK);        
        }
        else
        {
            fBorder = TRUE;
        }
    }    

Cleanup:    
    return fBorder;
}

//+====================================================================================
//
// Method:ShouldElementShowUIActiveBorder
//
// Synopsis: Should there be a UI-Active border around the current element that has focus
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::ShouldElementShowUIActiveBorder( BOOL fFireEventLike5 )
{
#ifdef FORMSMODE
    if (IsInFormsSelectionMode(GetEditableElement()))
         return FALSE;
    else
    {
#endif
        BOOL fOkEditFocus = TRUE;
        
        BOOL fActivatable = IsElementUIActivatable( );

        if ( fFireEventLike5 )
        {
            fOkEditFocus = FireOnBeforeEditFocus();
        }
        
        return fActivatable && fOkEditFocus ; 
        
#ifdef FORMSMODE
    }
#endif
}

//+====================================================================================
//
// Method:CreateAdorner
//
// Synopsis: Create a UI Active Adorner for this type of tracker.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::CreateAdorner()
{
    HRESULT         hr = S_OK;
    BOOL            fLocked = FALSE ;
    BOOL fAdornMaster = FALSE; 
    Assert( ! _pAdorner );
    SP_IHTMLElement spAdornerElement;
    AssertSz( _fEditFocusAllowed , " UI Activation of Control not allowed" );
    ELEMENT_TAG_ID eTag;
    BOOL fAtBoundary;
    SP_IDispatch spElemDocDisp;
    SP_IHTMLDocument2 spElemDoc;
    

    IFC( GetElementToAdorn( GetEditableElement(), & spAdornerElement, & fAtBoundary));
    IFC( GetMarkupServices()->GetElementTagId( spAdornerElement, & eTag ));
    
    fAdornMaster= fAtBoundary || eTag == TAGID_IFRAME ; 

    IFC( GetEditableElement()->get_document(& spElemDocDisp ));
    IFC( spElemDocDisp->QueryInterface(IID_IHTMLDocument2, (void**) & spElemDoc ));
        
    IFC( GetEditor()->IsElementLocked( spAdornerElement, & fLocked ));
    if ( ! fAdornMaster )
    {
        _pAdorner = new CActiveControlAdorner( spAdornerElement , spElemDoc , fLocked );
    }
    else
    {
        _pAdorner = new CSelectedControlAdorner( spAdornerElement , spElemDoc , fLocked );
    }
    
    if ( ! _pAdorner )
        goto Error;

    _pAdorner->SetManager( this );
    _pAdorner->AddRef();

    hr = _pAdorner->CreateAdorner() ;

Cleanup:
    
    RRETURN ( hr );

Error:
    return E_OUTOFMEMORY;
}


//+====================================================================================
//
// Method:DestroyAdorner
//
// Synopsis: Destroy the adorner associated with this tracker
//
//------------------------------------------------------------------------------------

VOID
CSelectionManager::DestroyAdorner()
{
    if ( _pAdorner ) 
    {
        _pAdorner->DestroyAdorner();
        _pAdorner->Release();
        _pAdorner = NULL;
    }
}


BOOL
CSelectionManager::HasFocusAdorner()
{
    return ( _pAdorner != NULL );
}

#if DBG == 1

void
TrackerTypeToString( TCHAR* pAryMsg, TRACKER_TYPE eType )
{
    switch ( eType )
    {
        case TRACKER_TYPE_None:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_None"));
            break;

        case TRACKER_TYPE_Caret:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Caret"));
            break;

        case TRACKER_TYPE_Selection:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Selection"));
            break;

        case TRACKER_TYPE_Control:
            edWsprintf( pAryMsg, _T("%s"), _T("TRACKER_TYPE_Control"));
            break;

        default:
            edWsprintf( pAryMsg, _T("%s"), _T("Unknown Type"));
            break;
    }
}

#endif


ELEMENT_TAG_ID
CSelectionManager::GetEditableTagId()
{
    IHTMLElement    *pIElement = NULL;
    HRESULT          hr = S_OK;

    if ( _eContextTagId == TAGID_NULL )
    {
        hr = THR( GetEditableElement( & pIElement ));
        if ( hr)
            goto Cleanup;

        hr = THR( _pEd->GetMarkupServices()->GetElementTagId( pIElement, & _eContextTagId ));
    }
Cleanup:
    ReleaseInterface(pIElement);
    return ( _eContextTagId );
}

BOOL 
CSelectionManager::IsEditContextPositioned()
{
    if (! _fPositionedSet )
    {
        _fPositioned = IsElementPositioned( GetEditableElement() );
        _fPositionedSet = TRUE;
    }

    return ( _fPositioned );
}

BOOL
CSelectionManager::IsEditContextSet()
{
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    if ( fPositioned )
        IGNORE_HR( _pEndContext->IsPositioned( & fPositioned ));

    return fPositioned;
}

HRESULT
CSelectionManager::MovePointersToContext(
                        IMarkupPointer*  pLeftEdge,
                        IMarkupPointer*  pRightEdge )
{
    HRESULT hr = S_OK;
    IFR( pLeftEdge->MoveToPointer( _pStartContext ));
    IFR( pRightEdge->MoveToPointer( _pEndContext ));
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given markup pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsInEditContext( IMarkupPointer* pPointer, BOOL fCheckContainer /*=FALSE*/)
{
    BOOL fInside = FALSE;
    
    IsInEditContext( pPointer, & fInside, fCheckContainer );
    
    return fInside;
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given display pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsInEditContext(IDisplayPointer* pDispPointer, BOOL fCheckContainer /*=FALSE*/)
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    return IsInEditContext(spPointer, fCheckContainer);
    
Cleanup:
    return FALSE;
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given display pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditContext(IDisplayPointer* pDispPointer, BOOL *pfInEdit , BOOL fCheckContainer )
{
    HRESULT             hr;
    SP_IMarkupPointer   spPointer;

    IFC( GetEditor()->CreateMarkupPointer(&spPointer) );
    IFC( pDispPointer->PositionMarkupPointer(spPointer) );

    IFC( IsInEditContext( spPointer, pfInEdit, fCheckContainer  ));
Cleanup:
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsInEditContext
//
// Synopsis: Check to see that the given markup pointer is within the Edit Context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditContext( IMarkupPointer  *pPointer, 
                                    BOOL            *pfInEdit,
                                    BOOL            fCheckContainer /* = FALSE */)
{
    HRESULT hr = S_OK;
    BOOL fInside = FALSE;
    BOOL fResult = FALSE;
    
#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned  ));
    Assert( fPositioned );
#endif

    IFC( pPointer->IsLeftOf( _pStartContext, & fResult ));
        
    if ( fResult )
        goto Cleanup;

    IFC( pPointer->IsRightOf( _pEndContext, & fResult ));
    
    if ( fResult )
        goto Cleanup;

    //
    // Check the container, if necessary, otherwise, then the pointers
    // are in the same markup
    //
    if( fCheckContainer )
    {
        IFC( ArePointersInSameMarkup( pPointer, _pStartContext, &fInside ) );
    }
    else
    {
        fInside = TRUE;
    }

Cleanup:
    if ( pfInEdit )
        *pfInEdit = fInside;

    return ( hr );
}

//+====================================================================================
//
// Method: IsAfterStart
//
// Synopsis: Check to see if this markup pointer is After the Start ( ie to the Right )
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsAfterStart( IMarkupPointer* pPointer, BOOL * pfAfterStart )
{
    HRESULT hr = S_OK;
    Assert( pfAfterStart );

    BOOL fAfterStart = FALSE;

#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
#endif
    int iWherePointer = SAME;

    hr = THR( OldCompare( _pStartContext, pPointer, & iWherePointer  ));
    if ( hr )
    {
        //AssertSz(0, "Unable To Compare Pointers - Are they in the same tree?");
        goto Cleanup;
    }

    fAfterStart =  ( iWherePointer != LEFT );

Cleanup:
    *pfAfterStart = fAfterStart;
    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsBeforeEnd
//
// Synopsis: Check to see if this markup pointer is Before the End ( ie to the Left )
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsBeforeEnd( IMarkupPointer* pPointer, BOOL *pfBeforeEnd )
{
    HRESULT hr = S_OK;
    BOOL fBeforeEnd = FALSE;

#if DBG == 1
    BOOL fPositioned = FALSE;
    IGNORE_HR( _pEndContext->IsPositioned( & fPositioned ));
    Assert( fPositioned );
#endif
    int iWherePointer = SAME;

    hr = THR( OldCompare( _pEndContext, pPointer, & iWherePointer  ));
    if ( hr )
    {
        //AssertSz(0, "Unable To Compare Pointers - Are they in the same tree?");
        goto Cleanup;
    }

    fBeforeEnd =  ( iWherePointer != RIGHT );

Cleanup:
    *pfBeforeEnd = fBeforeEnd;

    RRETURN( hr );
}

//+====================================================================================
//
// Method: IsSameEditContext
//
// Synopsis: Compare two given markup pointers to see if they represent a context
//           change from the current markup context
//
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::IsSameEditContext(
                        IMarkupPointer* pPointerStart,
                        IMarkupPointer* pPointerEnd,
                        BOOL * pfPositioned /* = NULL */ )
{
    HRESULT hr = S_OK;
    BOOL fSame = FALSE;
    BOOL fPositioned = FALSE;

    hr = THR(_pStartContext->IsPositioned( & fPositioned));
    if (hr)
        goto Cleanup;
        
    if ( ! fPositioned )
        goto Cleanup;

    hr = THR(_pEndContext->IsPositioned( & fPositioned));
    if (hr)
        goto Cleanup;

    if ( ! fPositioned )
        goto Cleanup;

    hr = THR(_pStartContext->IsEqualTo( pPointerStart, & fSame ));
    if (hr)
        goto Cleanup;
        
    if ( ! fSame )
        goto Cleanup;

    hr = THR(_pEndContext->IsEqualTo( pPointerEnd, & fSame ));
    if (hr)
        goto Cleanup;
        
Cleanup:
    if ( pfPositioned )
        *pfPositioned = fPositioned;

    return ( fSame );
}

//+-------------------------------------------------------------------------
//
//  Method:     CSelectionManager::InitializeEditableElement
//
//  Synopsis:   Retrieves the currently editable element and stores it in a
//              local variable for retrieval.
//
//  Arguments:  NONE
//
//  Returns:    HRESULT indicating success.
//
//--------------------------------------------------------------------------
HRESULT
CSelectionManager::InitializeEditableElement(void)
{
    HRESULT                 hr = S_FALSE;
    SP_IMarkupContainer     spIContainer;
    SP_IMarkupContainer     spIContainer2;
    BOOL                    fPositioned = FALSE;
    
    Assert( _pStartContext );

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned));

    if ( fPositioned )
    {       
        if( ! _fNoScope )
        {
            IFC( GetEditor()->CurrentScopeOrMaster( _pStartContext, &_pIEditableElement ) );
        }
        else
        {
            // Our edit context is outside of a no-scope element, scan right with
            // the start pointer to see what it is
            IFC( _pStartContext->Right( FALSE, FALSE, &_pIEditableElement, NULL, NULL ) );;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+====================================================================================
//
// Method: GetEditableElement
//
// Synopsis: Return an IHTMLElement of the current editing context
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::GetEditableElement( IHTMLElement** ppElement)
{
    Assert( ppElement );
    Assert( _pIEditableElement );

    *ppElement = _pIEditableElement;
    (*ppElement)->AddRef();

    return S_OK;
}

//+====================================================================================
//
// Method: GetEditableElement
//
// Synopsis: GetEditable Element as an Accessor
//
//------------------------------------------------------------------------------------

IHTMLElement* 
CSelectionManager::GetEditableElement()
{
    return _pIEditableElement;
}

IHTMLElement*
CSelectionManager::GetEditableFlowElement()
{
    HRESULT hr = S_OK;

    if ( ! _pIEditableFlowElement )
    {   
        SP_IDisplayPointer spDispPtr;
        IFC( GetDisplayServices()->CreateDisplayPointer( & spDispPtr ));
        IFC( spDispPtr->SetPointerGravity(POINTER_GRAVITY_Left));
        IFC( spDispPtr->MoveToMarkupPointer( GetStartEditContext(), NULL ));
        IFC( spDispPtr->GetFlowElement( & _pIEditableFlowElement ));
    }

Cleanup:
    Assert( SUCCEEDED( hr ));
    Assert( _pIEditableFlowElement );
    return ( _pIEditableFlowElement );
}

HRESULT
CSelectionManager::IsElementContentSameAsContext(IHTMLElement* pIElement )
{
    HRESULT  hr  ;
    BOOL     fEqual = FALSE;
    SP_IMarkupPointer  spInsideMaster;
    SP_IMarkupPointer spEndInsideMaster;    
    ELEMENT_TAG_ID eTag;
    BOOL fNoScope = FALSE;
    
    IFC( GetEditor()->CreateMarkupPointer( & spInsideMaster ));
    IFC( GetEditor()->CreateMarkupPointer( & spEndInsideMaster ));
    IFC( GetMarkupServices()->GetElementTagId( pIElement, &eTag ) );
    
    if ( _pEd->IsMasterElement( pIElement ) == S_OK )
    {
        hr = THR( PositionPointersInMaster( pIElement, spInsideMaster, spEndInsideMaster ));
        if (FAILED( hr)  )
        {
            //
            // move to content fails on img.
            //
            hr = S_OK;
            goto Cleanup;
        }
    }
    else if ( IsNoScopeElement( pIElement, eTag ) == S_OK )
    {
        IFC( spInsideMaster->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeBegin ));
        fNoScope = TRUE; 
    }
    else
    {
        IFC( spInsideMaster->MoveAdjacentToElement( pIElement, ELEM_ADJ_AfterBegin ));
    }

    
    IFC( spInsideMaster->IsEqualTo( _pStartContext, & fEqual ));

    //
    // We can only be equal for no-scopes - if the edit context is also equal.
    //
    
    if ( fNoScope && fEqual )
    {
        fEqual = _fNoScope; 
    }
    
Cleanup:
    if ( ! FAILED( hr ))
    {
        hr = fEqual ? S_OK: S_FALSE;
    }

    RRETURN1( hr, S_FALSE );
}    

HRESULT
CSelectionManager::GetEditableContent(IHTMLElement **ppIElement)
{
    Assert( _pStartContext );
 
    BOOL fPositioned = FALSE;

    IGNORE_HR( _pStartContext->IsPositioned( & fPositioned));

    if ( fPositioned )
    {
        if ( ! _fNoScope )
            RRETURN( _pStartContext->CurrentScope( ppIElement ));
        else
        {
            RRETURN ( _pStartContext->Right( FALSE, FALSE, ppIElement, NULL, NULL ) );
        }
    }
    return S_FALSE;
}

//+====================================================================================
//
// Method: SetDrillIn
//
// Synopsis: Tell the Manager we're "drilling in". Used so we know whether to set
//           or reset the _fHadGrabHandles Flag ( further used to ensure we don't create
//           a Site Selection again on an object that's UI Active).
//
//------------------------------------------------------------------------------------

void
CSelectionManager::SetDrillIn(BOOL fDrillIn)
{
    _fDrillIn = fDrillIn;
}

//+====================================================================================
//
// Method: Select All
//
// Synopsis: Do the work required by a select all.
//
//          If ISegmentList is not null it is either a TextRange or a Control Range, and we
//          select around this segment
//
//          Else we do a Select All on the Current Edit Context.
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::SelectAll(ISegmentList * pSegmentList, BOOL *pfDidSelectAll, BOOL fIsRange /*=FALSE*/)
{
    HRESULT                 hr = S_OK;
    SP_IMarkupPointer       spStart;
    SP_IMarkupPointer       spEnd;
    SP_IHTMLElement         spIOuterElement;
    SP_ISegmentListIterator spIter;
    SP_ISegment             spSegment;
    int                     iWherePointer = SAME;
    SELECTION_TYPE          desiredType = SELECTION_TYPE_Text;
    BOOL                    fEmpty = FALSE;
    
    Assert( pSegmentList );


    if ( pSegmentList )
    {
        IFC( pSegmentList->GetType( &desiredType ));
        IFC( pSegmentList->IsEmpty(&fEmpty ) );
    }

    if ( fIsRange && !fEmpty )
    {
        IFC( _pEd->CreateMarkupPointer( &spStart));
        IFC( _pEd->CreateMarkupPointer( &spEnd ));

        IFC( pSegmentList->CreateIterator(&spIter) );
        IFC( spIter->Current(&spSegment) );
        IFC( spSegment->GetPointers( spStart, spEnd ));

        IFC( OldCompare( spStart, spEnd, & iWherePointer));

        if ( iWherePointer == SAME )
            desiredType = SELECTION_TYPE_Caret;
        else
            desiredType = SELECTION_TYPE_Text;

        IFC( EnsureEditContext( spStart ));            
            
        hr = Select( spStart, spEnd , desiredType, pfDidSelectAll );

    }
    else
    {
        BOOL fStartPositioned = FALSE;
        BOOL fEndPositioned = FALSE;

        IGNORE_HR( _pStartContext->IsPositioned( & fStartPositioned ));
        IGNORE_HR( _pEndContext->IsPositioned( & fEndPositioned ));
        desiredType = SELECTION_TYPE_Text;

        //
        // If we're not editable, or we're UI Active we select the edit context
        //
        if ( ( !IsParentEditable() || HasFocusAdorner() )
                && fStartPositioned && fEndPositioned )
        {
           SP_IHTMLElement spElement;
           IFC( _pEndContext->CurrentScope(&spElement) );
           if ( CheckUnselectable(spElement) == S_OK )
               goto Cleanup;

           hr = Select( _pStartContext, _pEndContext , desiredType , pfDidSelectAll );
        }
        else
        {
            //
            // Select the "outermost editable element"
            //
            IFC( _pEd->CreateMarkupPointer( & spStart));
            IFC( _pEd->CreateMarkupPointer( & spEnd ));
            SP_IHTMLElement spActive;
            IFC( GetDoc()->get_activeElement( & spActive ));
            hr = THR( _pEd->GetOuterMostEditableElement( spActive , &spIOuterElement ));
            if (FAILED(hr))
            { 
                // We can fail in frameset cases, so don't propogate the hr
                hr = S_OK;
                goto Cleanup;
            }
            
            if ( CheckUnselectable(spIOuterElement) == S_OK )
                goto Cleanup;

            IFC( spStart->MoveAdjacentToElement( spIOuterElement, ELEM_ADJ_AfterBegin));
            IFC( spEnd->MoveAdjacentToElement( spIOuterElement, ELEM_ADJ_BeforeEnd ));

            IFC( EnsureEditContext( spStart ));
#if DBG == 1
            BOOL fEqual = FALSE;
            IGNORE_HR( _pStartContext->IsEqualTo( spStart, & fEqual ));
            AssertSz( fEqual , "Pointers not same - did Ensure Edit Context work ?");
#endif 
            hr = Select( spStart, spEnd , desiredType, pfDidSelectAll );
        }
    }

Cleanup:
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: Select
//
// Synopsis: SegmentList based way of implementing selection
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::Select( ISegmentList * pISegmentList )
{
    HRESULT        hr = S_OK;
    SELECTION_TYPE eType  = SELECTION_TYPE_None;
    TRACKER_TYPE   trType = TRACKER_TYPE_None;
    CSelectionChangeCounter selCounter(this);

    // chandras04/27/2000 :
    //          we should be checking for the empty segment list condition here to avoid 
    //          unnecessary code execution
    //
    selCounter.BeginSelectionChange();
    
    IFC( EnsureEditContext( pISegmentList ));
    if( hr == S_FALSE )
    {
        //
        // The become current call was cancelled, we need to gracefully bail the select
        //
        hr = S_OK;
        goto Cleanup;
    }
    
    IFC( pISegmentList->GetType( & eType ));

    trType = ConvertSelectionType(eType);

    Assert( trType == TRACKER_TYPE_Control || trType == TRACKER_TYPE_Selection || trType == TRACKER_TYPE_Caret );
    
    IFC( SetCurrentTracker( trType, pISegmentList ));

    // fire the selectionchange event
    selCounter.EndSelectionChange();
    
Cleanup:
    RRETURN( hr );
}

HRESULT
CSelectionManager::Select(  
                    IMarkupPointer* pStart, 
                    IMarkupPointer * pEnd, 
                    SELECTION_TYPE eType,
                    BOOL *pfDidSelection /*= FALSE */)
{
    HRESULT             hr = S_OK;
    BOOL                fDidSelection = FALSE;      // Success
    SP_IDisplayPointer  spDispStart;                // Begin display pointer
    SP_IDisplayPointer  spDispEnd;                  // End display pointer
    BOOL                fPositioned;                // Are the pointers positioned?
    DWORD               dwTCCode = 0;               // For transitioning trackers
    POINTER_GRAVITY     eGravity;
    TRACKER_TYPE        trType ;
    BOOL                fSameMarkup;
    CSelectionChangeCounter selCounter(this);

    //  Make sure pStart is not in a master element
    hr = THR( GetEditor()->IsPointerInMasterElementShadow(pStart) );
    if ( hr == S_OK )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    else if ( FAILED(hr) )
    {
        goto Cleanup;
    }

    selCounter.BeginSelectionChange();
    
    IFC( EnsureEditContext( pStart ));
    if ( hr == S_FALSE )
    {
        hr = S_OK;
        goto Cleanup;
    }
    
    trType = ConvertSelectionType(eType);

#ifdef FORMSMODE
    Assert (!(IsInFormsSelectionMode() && (trType == TRACKER_TYPE_Caret || trType == TRACKER_TYPE_Selection)));
#endif

    if (_fDeferSelect)
    {
        //
        // Ensure we have defer pointers
        //

        if (!_pDeferStart)
            IFC( _pEd->CreateMarkupPointer(&_pDeferStart) );
    
        if (!_pDeferEnd)
            IFC( _pEd->CreateMarkupPointer(&_pDeferEnd) );

        //
        // Just remember the parameters for now.  At some point, we should
        // get another select call with _fDeferSelect == FALSE.
        //

        IFC( _pDeferStart->MoveToPointer(pStart) );
        IFC( pStart->Gravity(&eGravity) );
        IFC( _pDeferStart->SetGravity(eGravity) );

        IFC( _pDeferEnd->MoveToPointer(pEnd) );
        IFC( pEnd->Gravity(&eGravity) );
        IFC( _pDeferEnd->SetGravity(eGravity) );

        _eDeferSelType = eType; 
    }
    else
    {
        Assert( pStart && pEnd );

        IFC( pStart->IsPositioned( &fPositioned ));

        if ( ! fPositioned )
        {
            AssertSz( 0, "Select - Start Pointer is NOT positioned!");
            hr = E_INVALIDARG;
            goto Cleanup;
        }


        IFC( pEnd->IsPositioned( &fPositioned ));
        if ( ! fPositioned )
        {
            AssertSz( 0, "Select - End Pointer is NOT positioned!");
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        //
        // Verify that the pointers we're been given are in the Edit Context.
        //
        AssertSz( IsInEditContext(pStart), "Start Pointer is NOT in Edit Context");
        AssertSz( IsInEditContext(pEnd), "End Pointer is NOT in Edit Context");

        //
        // If the specified type is of type selection, but the two pointers they
        // gave us are equal, coerce the type so that we create a caret tracker
        // instead
        //
        if( trType == TRACKER_TYPE_Selection )
        {
            CEditPointer    edptrStart( GetEditor(), pStart );
            BOOL            fEqual;

            IFC( edptrStart.IsEqualTo( pEnd, 
                    BREAK_CONDITION_ANYTHING - BREAK_CONDITION_OMIT_PHRASE - BREAK_CONDITION_Anchor, 
                    &fEqual ) ); 

            if( fEqual )
                trType = TRACKER_TYPE_Caret;
        }

         // If caret tracker is both source and destination, and the caret did not move, do nothing
        if (trType == TRACKER_TYPE_Caret )
        {                
            if( GetTrackerType() == TRACKER_TYPE_Caret && 
                !IsDefaultTrackerPassive() )
            {
                BOOL                fEqual;
                SP_IMarkupPointer   spMarkupCaret;
                SP_IDisplayPointer  spDispCaret;
                CCaretTracker       *pCaretTracker = DYNCAST(CCaretTracker, _pActiveTracker);

                if (pCaretTracker)
                {
                    IFC( pCaretTracker->GetCaretPointer(&spDispCaret) );
                    IFC( GetEditor()->CreateMarkupPointer(&spMarkupCaret) );
                    IFC( spDispCaret->PositionMarkupPointer(spMarkupCaret) );
                    
                    if (spMarkupCaret != NULL )
                    {
                        IFC( spMarkupCaret->IsEqualTo(pStart, &fEqual) );

                        if (fEqual)
                        {
                            IFC( spMarkupCaret->IsEqualTo(pEnd, &fEqual) );

                            if (fEqual)
                            {
                                SP_IDisplayPointer spDispPointer;
                                SP_IHTMLCaret      spCaret;
                                CARET_DIRECTION    eOrigDir;

                                IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
                                hr = THR( spDispPointer->MoveToMarkupPointer(pStart, NULL) );
                                if ( hr == CTL_E_INVALIDLINE )
                                {
                                    hr = S_OK;
                                    goto Cleanup;
                                }
                                else if ( FAILED( hr ))
                                {
                                    goto Cleanup;
                                }

                                //
                                // Since range select is ambiguous, we normalize by setting gravity to line start
                                //
                                
                                IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
                                
                                //
                                // For app compat, if you select and the caret doesn't move, then we don't
                                // do anything.  (bug 99367)
                                //
                                
                                IFC( spDispPointer->IsEqualTo(spDispCaret, &fEqual) );
                                if (fEqual)
                                {   
                                    goto Cleanup;
                                }                 
                                
                                //
                                // We need to preserve the caret direction just in case
                                // we are calling select and the caret is already there.
                                // [zhenbinx]
                                //
                                IFC( GetDisplayServices()->GetCaret(&spCaret) );
                                IFC( spCaret->GetCaretDirection(&eOrigDir) );
                                IFC( pCaretTracker->PositionCaretAt( spDispPointer, eOrigDir, POSCARETOPT_None, ADJPTROPT_None ));
                            }
                        }           
                    }
                }
            }
        }

        IFC( EnsureAdornment( FALSE ));

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispStart) );
        hr = THR( spDispStart->MoveToMarkupPointer(pStart, NULL) );
        if ( hr == CTL_E_INVALIDLINE )
        {
            hr = S_OK;
            ED_PTR( edStart );
            IFC( edStart.MoveToPointer( pStart ));
            DWORD dwBreak;
            
            edStart.SetBoundary( GetStartEditContext() , pEnd );

            IFC( edStart.Scan( RIGHT , BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite , & dwBreak ));
            if ( edStart.CheckFlag( dwBreak, BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite ))
            {
                if ( edStart.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                {
                    IFC( edStart.Scan( LEFT , BREAK_CONDITION_Text, & dwBreak ));            // bring it back to before the start of the text.            
                }                            
                IFC( spDispStart->MoveToMarkupPointer( edStart , NULL) );
            }
            else
            {
                hr = S_OK;
                AssertSz(0,"Not a valid point for start of selection");
            }
        }
        else if ( FAILED( hr ))
        {
            goto Cleanup;
        }
        
        IFC( spDispStart->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );
        
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispEnd) );
        hr = THR ( spDispEnd->MoveToMarkupPointer(pEnd, NULL) );

        //
        // Not a valid place for the display pointer. We handle by scanning for text.
        //
        if ( hr == CTL_E_INVALIDLINE )
        {
            hr = S_OK;
            ED_PTR( edEnd );
            IFC( edEnd.MoveToPointer( pEnd ));
            DWORD dwBreak;
            
            edEnd.SetBoundary( pStart , GetEndEditContext());

            IFC( edEnd.Scan( LEFT, BREAK_CONDITION_Text| BREAK_CONDITION_EnterTextSite , & dwBreak ));
            if ( edEnd.CheckFlag( dwBreak, BREAK_CONDITION_Text | BREAK_CONDITION_EnterTextSite ))
            {
                if ( edEnd.CheckFlag( dwBreak, BREAK_CONDITION_Text ))
                {
                    IFC( edEnd.Scan( RIGHT, BREAK_CONDITION_Text  & dwBreak ));            // bring it back to before the start of the text.
                }                    
                IFC( spDispEnd->MoveToMarkupPointer( edEnd , NULL) );
            }
            else
            {
                hr = S_OK;
                AssertSz(0,"Not a valid point for end of selection");
            }
        }
        else if ( FAILED( hr ))
        {
            goto Cleanup;
        }
       
        IFC( spDispEnd->SetDisplayGravity(DISPLAY_GRAVITY_PreviousLine) );

        // We just potentially moved our pointers into different markup containers
        // If this happens, fail the select, but don't propogate the hr
        IFC( ArePointersInSameMarkup( GetEditor(), spDispStart, spDispEnd, &fSameMarkup ) );
        if( !fSameMarkup )
        {
            goto Cleanup;
        }

        if( trType == TRACKER_TYPE_Selection )
        {
            SP_IHTMLElement  spIEditElement;             // Which element is bound by the pointers

            // Try to find the element under the start pointer
            IFC( GetEditor()->CurrentScopeOrMaster( spDispStart, &spIEditElement, pStart ));
            BOOL fSelect;
            
            IFC( FireOnSelectStart( spIEditElement, &fSelect , NULL));

            if ( ! fSelect )
            {
                fDidSelection = FALSE;
                goto Cleanup;
            }
        }
        
        hr = SetCurrentTracker ( trType,  
                                 spDispStart, 
                                 spDispEnd, 
                                 dwTCCode, 
                                 CARET_MOVE_NONE, 
                                 FALSE );

        if (hr == S_OK)
            fDidSelection = TRUE;
    }

    if (fDidSelection)
    {
        // fire the selectionchange event
        selCounter.EndSelectionChange();
    }

Cleanup:
    if ( pfDidSelection )
        *pfDidSelection = fDidSelection;
    RRETURN ( hr );
}

//+====================================================================================
//
// Method: IsElementSiteSelected
//
// Synopsis: See if the given element is Site Selected
//
//------------------------------------------------------------------------------------
HRESULT
CSelectionManager::IsElementSiteSelected( IHTMLElement* pIElement)
{
    HRESULT hr = S_FALSE;

    if ( GetTrackerType() == TRACKER_TYPE_Control )
    {
        CControlTracker* pControlTrack = DYNCAST( CControlTracker, _pActiveTracker );
        hr = pControlTrack->IsSelected( pIElement , NULL ) ;
    }
        
    RRETURN1 ( hr , S_FALSE);
}

//+====================================================================================
//
// Method: IsPointerInSelection
//
// Synopsis: Check to see if the given pointer is in a Selection
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsPointerInSelection( 
                         IDisplayPointer    *pIDispPointer ,
                         BOOL               *pfPointInSelection,
                         POINT              *pptGlobal,
                         IHTMLElement       *pIElementOver)
{
    BOOL fInSelection = FALSE;


    if ( ! IsDefaultTrackerPassive() )
    {
        fInSelection = _pActiveTracker->IsPointerInSelection( pIDispPointer, pptGlobal, pIElementOver );
    }

    if ( pfPointInSelection )
        *pfPointInSelection = fInSelection;

    RRETURN ( S_OK );
}

VOID
CSelectionManager::AdornerPositionSet()
{
    Assert( _fPendingAdornerPosition );

    if (_lastEvent)
    {
        DYNCAST( CControlTracker, _pActiveTracker)->BecomeActiveOnFirstMove( _lastEvent );
        delete _lastEvent;
        _lastEvent = NULL;
    }
    _fPendingAdornerPosition = FALSE;
}

//+===================================================================================
// Method: IsMessageInSelection
//
// Synopsis: Check to see if the given message is in the current SelectionRenderingServices
//
//------------------------------------------------------------------------------------
BOOL
CSelectionManager::IsMessageInSelection( CEditEvent* pEvent )
{
    HRESULT         hr = S_OK;
    SELECTION_TYPE  eSegmentType = SELECTION_TYPE_None;
    BOOL            fEmpty = FALSE;
    BOOL            fIsInSelection = FALSE;
    SP_ISegmentList spSegmentList;

    IFC( GetSelectionServices()->QueryInterface( IID_ISegmentList, (void **)&spSegmentList ) );

    IFC( spSegmentList->GetType(&eSegmentType ));
    IFC( spSegmentList->IsEmpty( &fEmpty ) );

    if ( ( fEmpty == FALSE ) &&
         ( GetTrackerType() == TRACKER_TYPE_Selection ) )
    {
        fIsInSelection = DYNCAST( CSelectTracker, _pActiveTracker )->IsMessageInSelection(pEvent);
    }

Cleanup:
    return fIsInSelection;
}

//+====================================================================================
//
// Method: IsOkToEditContents
//
// Synopsis: Fires the OnBeforeXXXX Event back to Trident to see if its' ok to UI-Activate,
//           and place a caret inside a given control.
//
// RETURN: TRUE - if it's ok to go ahead and UI Activate
//         FALSE - if it's not ok to UI Activate 
//------------------------------------------------------------------------------------

BOOL
CSelectionManager::FireOnBeforeEditFocus()
{
    BOOL fEditFocusBefore = _fEditFocusAllowed;
    SP_IHTMLElement spElement = GetEditableElement();

    if ( IsDontFireEditFocus() )
    {
        return TRUE;
    }
    
    BOOL fReturn = EdUtil::FireOnBeforeEditFocus(spElement,IsContextEditable() ) ;

    _fEditFocusAllowed = fReturn ;
    //
    // We have changed states - so we need to enable/disable the UI Active border
    // Note that by default _fUIActivate == TRUE - so this will not fire on SetEditContextPrivate
    // for the first time.
    //
    if ( _fEditFocusAllowed != fEditFocusBefore )
    {
        if ( _fEditFocusAllowed && IsElementUIActivatable())
        {
            IGNORE_HR( CreateAdorner());
        }
        else if ( !_fEditFocusAllowed && _pAdorner )
        {
            DestroyAdorner();
        }
        _pActiveTracker->OnEditFocusChanged();
    }

    return fReturn;
}

//+====================================================================================
//
// Method: IsInEditContextClientRect
//
// Synopsis: Is the given point in the content area of the Editable Element ?
//
//------------------------------------------------------------------------------------

HRESULT
CSelectionManager::IsInEditableClientRect( POINT ptGlobal )
{
    HRESULT         hr = S_OK;
    RECT            rectGlobal;

    //
    // Retrieve the rect for our editable element, and transform
    // it to global coord's
    //
    IFC( GetEditor()->GetClientRect( GetEditableElement() , &rectGlobal ));

    // Check if our event is in the rect
    hr =  ::PtInRect( & rectGlobal, ptGlobal ) ? S_OK : S_FALSE;
    
Cleanup:
    RRETURN1( hr, S_FALSE );
}

#if DBG == 1

void 
CSelectionManager::DumpTree( IMarkupPointer* pPointer )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled
    if ( GetEditDebugServices() )
    {
        IGNORE_HR( GetEditDebugServices()->DumpTree( pPointer ));
    }        
}

long
CSelectionManager::GetCp( IMarkupPointer* pPointer )
{
    long cp = 0;

    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled
    
    if ( GetEditDebugServices() )
    {
        IGNORE_HR( GetEditDebugServices()->GetCp( pPointer, & cp));
    }
    return cp;
}

void 
CSelectionManager::SetDebugName( IMarkupPointer* pPointer, LPCTSTR strDebugName )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled

    if ( GetEditDebugServices())
    {
        IGNORE_HR( GetEditDebugServices()->SetDebugName( pPointer, strDebugName));
    }        
}

void 
CSelectionManager::SetDebugName( IDisplayPointer* pDispPointer, LPCTSTR strDebugName )
{
    Assert( GetEditDebugServices()) ; // possible for this to be null if a retail mshtml creates a debug mshtmled

    if ( GetEditDebugServices())
    {
        IGNORE_HR( GetEditDebugServices()->SetDisplayPointerDebugName( pDispPointer, strDebugName));
    }        
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CSelectionmManager::DeferSelection, public
//
//  Synopsis:   Defers selection until some future point in time.  Created for undo batching.
//
//  Arguments:  [fDeferSelect] - If fDeferSelection==TRUE, selection is deferred until 
//                               fDeferSelection is called with fDeferSelect==FALSE.  
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT 
CSelectionManager::DeferSelection(BOOL fDeferSelect)
{
    HRESULT hr = S_OK;

    _fDeferSelect = fDeferSelect; 

    if (!fDeferSelect && _eDeferSelType != TRACKER_TYPE_None)
    {
        BOOL fTypedSinceLastUrlDetect = HaveTypedSinceLastUrlDetect();

        // We only get called if undo is restoring the selection state.  In this 
        // case, don't autodetect while restoring the selection.
        SetHaveTypedSinceLastUrlDetect( FALSE );
        hr = THR(Select(_pDeferStart, _pDeferEnd, _eDeferSelType));
        if (!_fDontScrollIntoView)
        {
            SP_IDisplayPointer  spDispPointer;

            IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
            IFC( spDispPointer->MoveToMarkupPointer(_pDeferStart, NULL) );

            IGNORE_HR(spDispPointer->ScrollIntoView());
        }
        SetHaveTypedSinceLastUrlDetect( fTypedSinceLastUrlDetect );
    }
    _eDeferSelType = SELECTION_TYPE_None;  // clear deferred selection type

Cleanup:
    RRETURN(hr);
}

#ifdef FORMSMODE
BOOL 
CSelectionManager::IsInFormsSelectionMode()
{
    return (IsContextEditable() &&  (_eSelectionMode == SELMODE_FORMS));
}

BOOL 
CSelectionManager::IsInFormsSelectionMode(IHTMLElement* pIElement)
{
    BOOL fFormsMode = FALSE;

    if (IsContextEditable())
    {
        IGNORE_HR( CheckFormSelectionMode( pIElement, & fFormsMode ));
    }
    return fFormsMode ;
}
        
HRESULT 
CSelectionManager::CheckFormSelectionMode(IHTMLElement* pElement,BOOL *pfFormSelMode)
{
    HRESULT hr = S_OK;
    SP_IHTMLElement spCheckElement;
    BOOL    fMixedSelectionMode = FALSE;
    BSTR    bstrSelectionMode      = SysAllocString(_T("selectionMode"));
    BSTR    bstrFormsSelectionMode = SysAllocString(_T("forms"));
    BSTR    bstrMixedSelectionMode = SysAllocString(_T("mixed"));

    Assert (pfFormSelMode);
    
    *pfFormSelMode = FALSE;
        
    if (bstrSelectionMode == NULL || bstrFormsSelectionMode == NULL || bstrMixedSelectionMode == NULL )
    {
        hr = E_FAIL;
        goto Cleanup;
    }    

    ReplaceInterface( &spCheckElement , pElement );
    while (1)
    {
        SP_IHTMLElement spParentElement;
        IFC(CheckAttribute( spCheckElement, pfFormSelMode, bstrSelectionMode, bstrFormsSelectionMode));
        
        if (*pfFormSelMode)
            break;
    
        IFC(CheckAttribute( spCheckElement, &fMixedSelectionMode, bstrSelectionMode, bstrMixedSelectionMode));
        
        if (fMixedSelectionMode)
            break;
    
        IFC(GetParentElement(GetMarkupServices(), spCheckElement, &spParentElement));
        if (spParentElement == NULL)
        {
            break;
        }
        ReplaceInterface( &spCheckElement , (IHTMLElement*)spParentElement );
   }

Cleanup:
    if (fMixedSelectionMode)
        *pfFormSelMode = FALSE;

    SysFreeString(bstrSelectionMode);
    SysFreeString(bstrFormsSelectionMode);
    SysFreeString(bstrMixedSelectionMode);
    RRETURN (hr);
}

HRESULT 
CSelectionManager::SetSelectionMode(IHTMLElement* pElement)
{
    HRESULT hr = S_OK;
    BOOL fFormsSelMode = FALSE;

    IFC( CheckFormSelectionMode(pElement, &fFormsSelMode));
     _eSelectionMode = (fFormsSelMode ?  SELMODE_FORMS : SELMODE_MIXED);
    
Cleanup:
    RRETURN (hr);
}
#endif

//+---------------------------------------------------------------------
//
// Method: SelectFromShift
//
// Synopsis: Start a select tracker given 2 pointers 
//           Equivalent to old TN_END_POS_SELECT
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::SelectFromShift( IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr = S_OK ;
    
#if DBG ==1
    Assert( pDispStart && pDispEnd);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned));
    Assert( fPositioned );
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned));
    Assert( fPositioned );
#endif

    if ( ! pDispStart || ! pDispEnd )
    {
        return E_FAIL;
    }

    pDispStart->AddRef();
    pDispEnd->AddRef();

    // NOTE: - correct for all the places POS_SELECT is used.
    DWORD dwCode = TRACKER_CREATE_STARTFROMSHIFTKEY | TRACKER_CREATE_STARTFROMSHIFTMOUSE;

    if ( pDispStart && pDispEnd )
    {
        hr = THR( SetCurrentTracker( TRACKER_TYPE_Selection,
                                     pDispStart,
                                     pDispEnd,
                                     dwCode ));
    }            

    pDispStart->Release();
    pDispEnd->Release();
    RRETURN( hr );
}

HRESULT
CSelectionManager::StartAtomicSelectionFromCaret( IDisplayPointer *pPosition )
{
    HRESULT hr = S_OK ;
    
#if DBG ==1
    Assert( pPosition );
    BOOL fPositioned = FALSE;
    IGNORE_HR( pPosition->IsPositioned( & fPositioned));
    Assert( fPositioned );
#endif

    if ( ! pPosition )
    {
        return E_FAIL;
    }

    pPosition->AddRef();
    hr = THR( SetCurrentTracker( TRACKER_TYPE_Selection,
                                 pPosition,
                                 pPosition,
                                 0 ));
    _fEnsureAtomicSelection = TRUE;
    pPosition->Release();

    CSelectionChangeCounter selCounter(this);
    selCounter.SelectionChanged();

    RRETURN( hr );
}


HRESULT
CSelectionManager::PositionCaret( CEditEvent* pEvent )
{
    RRETURN (SetCurrentTracker( 
                        TRACKER_TYPE_Caret,
                        pEvent,
                        0,
                        CARET_MOVE_NONE ) );
}

HRESULT
CSelectionManager::PositionControl( IDisplayPointer* pDispStart, IDisplayPointer* pDispEnd )
{
    HRESULT hr = S_OK;
    CSelectionChangeCounter selCounter(this);
#if DBG ==1
    Assert( pDispStart);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispStart->IsPositioned( & fPositioned));
    Assert( fPositioned );

    Assert( pDispEnd);
    IGNORE_HR( pDispEnd->IsPositioned( & fPositioned));
    Assert( fPositioned );    
#endif
    if ( ! pDispStart || ! pDispEnd )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pDispStart->AddRef();
    pDispEnd->AddRef();

    selCounter.BeginSelectionChange();
    
    hr = THR(SetCurrentTracker( TRACKER_TYPE_Control, 
                                pDispStart, 
                                pDispEnd ));

    // fire the selectionchange event
    selCounter.EndSelectionChange();
    
    pDispStart->Release();
    pDispEnd->Release();

Cleanup:
    RRETURN( hr );
}

//+---------------------------------------------------------------------
//
// Method: PositionCaret
//
// Synopsis: Place the caret at the given locaiton. Replacement for TN_END_TRACKER_POS_CARET
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::PositionCaret( IDisplayPointer * pDispPointer, CEditEvent* pEvent /*=NULL*/ )
{
    HRESULT hr;
    

    Assert( pDispPointer);
    BOOL fPositioned = FALSE;
    IGNORE_HR( pDispPointer->IsPositioned( & fPositioned));

    if ( !pDispPointer || ! fPositioned)
    {
        return E_FAIL;
    }
    
    pDispPointer->AddRef();      
    IFC( SetCurrentTracker( TRACKER_TYPE_Caret,
                            pDispPointer,
                            pDispPointer ));

    IFC( EnsureAdornment());
 
    if ( pEvent )
    {
        CSelectionChangeCounter selCounter(this);
        selCounter.BeginSelectionChange();
    
        Assert( _pActiveTracker );
        IFC( _pActiveTracker->HandleEvent( pEvent));

        selCounter.EndSelectionChange();
    }

    
Cleanup:
    pDispPointer->Release();
        
    RRETURN( hr );
}           

//+---------------------------------------------------------------------
//
// Method: DeleteRebubble
//
// Synopsis: Delete the selection - bubble event to new tracker
//           Used for typing into selection. Equivalent to TN_FIRE_DELETE_REBUBBLE
//
//+---------------------------------------------------------------------

HRESULT
CSelectionManager::DeleteRebubble( CEditEvent* pEvent )
{
    HRESULT             hr;            
    CEdUndoHelper       undoUnit(GetEditor());
    SP_IDisplayPointer  spDispSelectionStart;

    // To be word2k compat, we need to start a new undo unit on delete rebubble and group
    // it with typing

    IFC( _pCaretTracker->TerminateTypingBatch() );
    IFC( _pCaretTracker->BeginTypingUndo(&undoUnit, IDS_EDUNDOTYPING) )

    // Springload formats at start of selection (Word behavior).
    if ( _pActiveTracker->GetTrackerType() == TRACKER_TYPE_Selection)
    {
        CSelectTracker  * pSelectTrack = DYNCAST( CSelectTracker, _pActiveTracker );
        IFC( pSelectTrack->AdjustPointersForChar() );
        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispSelectionStart) );
        IFC( spDispSelectionStart->MoveToPointer(pSelectTrack->GetStartSelection()) );
    }

    IFC( DeleteSelection( FALSE ));

    // Make sure we move into an adjacent url
    Assert( GetTrackerType() == TRACKER_TYPE_Caret && spDispSelectionStart != NULL);
    if (GetTrackerType() == TRACKER_TYPE_Caret && spDispSelectionStart != NULL)
    {
        CEditPointer        epTest(GetEditor());
        DWORD               dwSearch = DWORD(BREAK_CONDITION_OMIT_PHRASE);
        DWORD               dwFound;
        CCaretTracker       *pCaretTracker = DYNCAST(CCaretTracker, _pActiveTracker);
        SP_IDisplayPointer  spDispPointer;
        
        IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );

        IFC( epTest.Scan(LEFT, dwSearch, &dwFound) );
        if (!epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );
        }

        IFC( GetDisplayServices()->CreateDisplayPointer(&spDispPointer) );
        IFC( spDispPointer->MoveToMarkupPointer(epTest, NULL) );
        IFC( spDispPointer->SetDisplayGravity(DISPLAY_GRAVITY_NextLine) );

        if (epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterAnchor))
        {
            IFC( pCaretTracker->PositionCaretAt( spDispPointer, 
                                                CARET_DIRECTION_INDETERMINATE, 
                                                POSCARETOPT_None, 
                                                ADJPTROPT_None ));
        }                   
        else 
        {
            BOOL fAdjust;

            //
            // Only adjust if we can possibly be in the an ambiguous position.
            // This is necessary to preserve compat with outlook.  We can't
            // adjust if there are just phrase elements.
            //
        
            IFC( spDispSelectionStart->PositionMarkupPointer(epTest) );
            IFC( epTest.Scan(RIGHT, dwSearch, &dwFound) );
            
            fAdjust = epTest.CheckFlag(dwFound, BREAK_CONDITION_EnterBlock 
                                       | BREAK_CONDITION_EnterSite 
                                       | BREAK_CONDITION_EnterTextSite
                                       | BREAK_CONDITION_NoScopeBlock);
                                       
            IFC( pCaretTracker->PositionCaretAt( 
                    spDispPointer, 
                    CARET_DIRECTION_INDETERMINATE, 
                    fAdjust ? POSCARETOPT_None : POSCARETOPT_DoNotAdjust, 
                    ADJPTROPT_DontExitPhrase | ADJPTROPT_AdjustIntoURL));
        }
    }

    hr = THR( HandleEvent( pEvent ));
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CSelectionManager::DeleteNoBubble()
{
    HRESULT hr;

    IFC( DeleteSelection( TRUE ));
    if ( IsPendingUndo())
    {
        IFC( GetMarkupServices()->EndUndoUnit());
        SetPendingUndo( FALSE );
    }

Cleanup:
