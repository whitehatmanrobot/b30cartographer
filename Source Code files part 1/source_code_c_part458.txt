
            // build a new peer list
            if (pRecord->is_enrolled_actively)
            {
                DBG_SAVE_FILE_LINE
                CPeerData *lpPeer = new CPeerData( 
                            pRecord->node_id, 
                            pRecord->application_user_id, 
                            IsLocalNode, 
                            IsProshareNode,
                            pRecord->is_conducting_capable,
                            bEOFAcknowledgment,
                            lpszAppKey,
                            (DWORD)((pRecord->node_id == m_nidMyself)?((VER_PRODUCTVERSION_DW&0xffff0000)>>16):
                            T120_GetNodeVersion(m_nConfID, pRecord->node_id)));
                if (NULL == lpPeer)
                {
                    ASSERT(0);
                    return;
                }
                NewPeerList.Append(lpPeer);
                pOldPeer = m_PeerList.FindSamePeer(lpPeer);
                if (NULL != pOldPeer)
                {
                    // we already new about this peer
                    m_PeerList.Delete(pOldPeer);
                }
                else 
                {
                    // this is a new peer
                    AddPeerNotification(
                        pRecord->node_id,
                        pRecord->application_user_id,
                        IsLocalNode,
                        IsProshareNode,
                        TRUE,
                        lpszAppKey ? lpszAppKey : "", // TODO: address appkey issue here; needed?
                        pRoster->session_key.session_id );
                }
            }
        }
    }

#ifdef ENABLE_CONDUCTORSHIP
    //If we are on the conducting node, we need no privileges...
    if (m_bInConductedMode && (m_ConductorNodeID != m_nidMyself))
    {
        //MBFT 8.11.1
        //If the previously assigned conductor is not present in the roster report, 
        //all privileges are revoked and we should abort all sends...
        if( !fConductorFound )
        {
            AbortAllSends();
        }
    }
#endif // ENABLE_CONDUCTORSHIP

    while (NULL != (pOldPeer = m_PeerList.Get()))
    {
        AddPeerNotification( 
            pOldPeer->GetNodeID(),
            pOldPeer->GetUserID(),
            pOldPeer->GetIsLocalNode(),
            pOldPeer->GetIsProshareNode(),
            FALSE,
            MY_APP_STR, 
            m_SessionID );

        DBG_SAVE_FILE_LINE
        CPeerData *p = new CPeerData(
                        pOldPeer->GetNodeID(),
                        pOldPeer->GetUserID(),
                        pOldPeer->GetIsLocalNode(),
                        pOldPeer->GetIsProshareNode(),
                        pOldPeer->GetCanConduct(),
                        pOldPeer->GetEOFAcknowledge(),
                        pOldPeer->GetAppKey(),
                        pOldPeer->GetVersion());
        ASSERT(NULL != p);
        if (p)
        {
            DBG_SAVE_FILE_LINE
            SafePostMessage(new PeerDeletedMsg(p));
        }
        TRACEGCC("Peer Removed: Node [%u], UserID [%u]\n", pOldPeer->GetNodeID(), pOldPeer->GetUserID() );
        delete pOldPeer;
    }

    while (NULL != (pOldPeer = NewPeerList.Get()))
    {
        m_PeerList.Append(pOldPeer);
    }

    // notify UI of new rosters
    if (NULL != m_pWindow)
    {
        m_pWindow->UpdateUI();
    }
}


void MBFTEngine::OnChannelAdmitIndication
(
    T120ChannelID               nChannelID,
    T120UserID                  nManagerID
)
{
    if (IsValidPeerID(nManagerID) && m_State == IdleInitialized)
    {
        DBG_SAVE_FILE_LINE
        SafePostMessage(new MCSChannelAdmitIndicationMsg(nChannelID, nManagerID));
    }
}



void CALLBACK T120Callback
(
    T120AppletSessionMsg   *pMsg
)
{
    MBFTEngine *pEngine = (MBFTEngine *) pMsg->pSessionContext;
    ASSERT(NULL != pEngine);

    BOOL fSuccess;
    T120ChannelID nChannelID;

    switch (pMsg->eMsgType)
    {
    case T120_JOIN_SESSION_CONFIRM:
        pEngine->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
        break;

    case GCC_APP_ROSTER_REPORT_INDICATION:
        pEngine->OnRosterReportIndication(pMsg->AppRosterReportInd.cRosters,
                                          pMsg->AppRosterReportInd.apAppRosters);
        break;

    // case GCC_APPLICATION_INVOKE_CONFIRM:
        // break;

    case MCS_SEND_DATA_INDICATION:
    case MCS_UNIFORM_SEND_DATA_INDICATION: 
        pEngine->OnSendDataIndication(
            (pMsg->eMsgType == MCS_UNIFORM_SEND_DATA_INDICATION),
            pMsg->SendDataInd.initiator,
            pMsg->SendDataInd.channel_id,
            (T120Priority) pMsg->SendDataInd.data_priority,
            pMsg->SendDataInd.user_data.length,
            pMsg->SendDataInd.user_data.value);
        break;

    case MCS_CHANNEL_JOIN_CONFIRM:
        fSuccess = (T120_RESULT_SUCCESSFUL == pMsg->ChannelConfirm.eResult);
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelJoinConfirmMsg(pMsg->ChannelConfirm.nChannelID, fSuccess));
        break;

    case MCS_CHANNEL_CONVENE_CONFIRM:
        fSuccess = (T120_RESULT_SUCCESSFUL == pMsg->ChannelConfirm.eResult);
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelConveneConfirmMsg(pMsg->ChannelConfirm.nChannelID, fSuccess));
        break;

    // case MCS_CHANNEL_LEAVE_INDICATION:
    //     break;

    // case MCS_CHANNEL_DISBAND_INDICATION:
    //    break;

    case MCS_CHANNEL_ADMIT_INDICATION:
        pEngine->OnChannelAdmitIndication(pMsg->ChannelInd.nChannelID, pMsg->ChannelInd.nManagerID);
        break;

    case MCS_CHANNEL_EXPEL_INDICATION:
        DBG_SAVE_FILE_LINE
        pEngine->SafePostMessage(new MCSChannelExpelIndicationMsg(pMsg->ChannelInd.nChannelID, pMsg->ChannelInd.eReason));
        break;

    // case MCS_TOKEN_GRAB_CONFIRM:
    // case MCS_TOKEN_INHIBIT_CONFIRM:
    // case MCS_TOKEN_GIVE_CONFIRM:
    // case MCS_TOKEN_RELEASE_CONFIRM:
    // case MCS_TOKEN_TEST_CONFIRM:
    //    break;

    // case MCS_TOKEN_GIVE_INDICATION:
    // case MCS_TOKEN_PLEASE_INDICATION:
    // case MCS_TOKEN_RELEASE_INDICATION:
    //     break;

    case MCS_DETACH_USER_INDICATION:
        pEngine->OnDetachUserIndication(pMsg->DetachUserInd.nUserID, pMsg->DetachUserInd.eReason);
        break;

    case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
                g_fWaitingForBufferAvailable = FALSE;
        ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), 
                                                MBFTMSG_HEART_BEAT, 0, (LPARAM) pEngine);
                break;
    }
}


BOOL MBFTEngine::SimpleChannelRequest
(
    AppletChannelCommand    eCommand,
    T120ChannelID           nChannelID
)
{
    T120ChannelRequest req;
    ::ZeroMemory(&req, sizeof(req));
    req.eCommand = eCommand;
    req.nChannelID = nChannelID;
    T120Error rc = m_pAppletSession->ChannelRequest(&req);
    return (T120_NO_ERROR == rc);
}

T120NodeID MBFTEngine::GetNodeIdByUserID(T120UserID nUserID)
{
        CPeerData *p;
        m_PeerList.Reset();
        while (NULL != (p = m_PeerList.Iterate()))
        {
                if (nUserID == p->GetUserID())
                {
                        return p->GetNodeID();
                }
        }
        return 0;
}

BOOL MBFTEngine::MCSChannelAdmitRequest
(
    T120ChannelID       nChannelID,
    T120UserID         *aUsers,
    ULONG               cUsers
)
{
    T120ChannelRequest req;
    ::ZeroMemory(&req, sizeof(req));
    req.eCommand = APPLET_ADMIT_CHANNEL;
    req.nChannelID = nChannelID;
    req.cUsers = cUsers;
    req.aUsers = aUsers;
    T120Error rc = m_pAppletSession->ChannelRequest(&req);
    return (T120_NO_ERROR == rc);
}

BOOL MBFTEngine::SendDataRequest
(
    T120ChannelID       nChannelID,
    T120Priority        ePriority,
    LPBYTE              pBuffer,
    ULONG               cbBufSize
)
{
    if (m_eLastSendDataError == MCS_TRANSMIT_BUFFER_FULL)
    {
        if (g_fWaitingForBufferAvailable == FALSE)
        {
            m_eLastSendDataError = MCS_NO_ERROR;
        }
        else
        {
            TRACEMCS("MBFTEngine::SendDataReques still waiting for a MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION");
            return FALSE;
        }
    }

    m_eLastSendDataError = m_pAppletSession->SendData(
                        NORMAL_SEND_DATA, nChannelID, ePriority,
                        pBuffer, cbBufSize, APP_ALLOCATION);
    //
    // T120 is busy and can't allocate data
    //
    if (m_eLastSendDataError == MCS_TRANSMIT_BUFFER_FULL)
    {
        g_fWaitingForBufferAvailable = TRUE;
        TRACEMCS("MCSSendDataRequest failed we will not send data until we get a MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION");
    }

    return (T120_NO_ERROR == m_eLastSendDataError);
}


//
// CPeerList
//

CPeerData * CPeerList::Find(T120NodeID nNodeID)
{
    CPeerData *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->GetUserID() == nNodeID)
        {
            return p;
        }
    }
    return NULL;
}

CPeerData * CPeerList::FindSamePeer(CPeerData *pPeer)
{
    CPeerData *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (pPeer->GetNodeID() == p->GetNodeID() && pPeer->GetUserID() == p->GetUserID())
        {
            return p;
        }
    }
    return NULL;
}

void CPeerList::Delete(CPeerData *p)
{
    if (Remove(p))
    {
        delete p;
    }
}

void CPeerList::DeleteAll(void)
{
    CPeerData *p;
    while (NULL != (p = Get()))
    {
        delete p;
    }
}


void CSessionList::Delete(MBFTSession *p)
{
    if (Remove(p))
    {
        delete p;
    }
}


// thought it is a pure virtual, we still need a destructor
MBFTSession::~MBFTSession(void) { }


HRESULT MBFTEngine::SafePostNotifyMessage(MBFTMsg *p)
{
    // notify applet UI if it exists
    if (NULL != m_pWindow)
    {
        m_pWindow->OnEngineNotify(p);
    }

    if (NULL != m_pMBFTIntf)
    {
        return m_pMBFTIntf->SafePostNotifyMessage(p);
    }

    delete p;
    return S_OK;
}



MBFTEVENTHANDLE GetNewEventHandle(void)
{
    static ULONG s_nEventHandle = 0x55AA;
    ULONG nEvtHdl;

    ::EnterCriticalSection(&g_csWorkThread);
    if (s_nEventHandle > 0xFFFF)
    {
        s_nEventHandle = 0x55AA;
    }
    nEvtHdl = s_nEventHandle++;
    ::LeaveCriticalSection(&g_csWorkThread);

    return nEvtHdl;
}


MBFTFILEHANDLE GetNewFileHandle(void)
{
    static ULONG s_nFileHandle = 1;
    ULONG nFileHdl;

    ::EnterCriticalSection(&g_csWorkThread);
    if (s_nFileHandle > 0xFFFF)
    {
        s_nFileHandle = 0x1;
    }
    nFileHdl = s_nFileHandle++;
    ::LeaveCriticalSection(&g_csWorkThread);

    return nFileHdl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ftui.h ===
#ifndef _FT_MAIN_UI_H_
#define _FT_MAIN_UI_H_

#include "ftres.h"
#include "combotb.h"
#if defined(TEST_PLUGABLE) && defined(_DEBUG)
#include "plugable.h"
#endif


#define WM_SEND_NEXT            (WM_APP + 0x201)
#define WM_BRING_TO_FRONT       (WM_APP + 0x202)


#define NUM_STATUS_BAR_PARTS    3
#define SBP_TRANSFER_FILE		0
#define SBP_PROGRESS			1
#define SBP_SBICON				2

typedef struct
{
    ULONG   idString;
    ULONG   idCommand;
    UINT    nFlags;
}
    UI_MENU_INFO;

typedef enum
{
	FTUIMODE_SHOWUI = 0,
	FTUIMODE_UIHIDDEN,
	FTUIMODE_NOUI,
}	
	FTUIMode;

class CAppletWindow;

class CUiSendFileInfo
{
public:

    CUiSendFileInfo(CAppletWindow *, TCHAR szDir[], TCHAR szFile[], BOOL *pfRet);
    ~CUiSendFileInfo(void);

    // name
    LPTSTR GetFullName(void) { return m_pszFullName; }
    LPTSTR GetName(void) { return m_pszFileName; }

    // numbers
    ULONG GetSize(void) { return m_FileInfo.nFileSizeLow; }
    DWORD GetFileAttribute(void) { return m_FileInfo.dwFileAttributes; }
	FILETIME GetLastWrite(void) { return m_FileInfo.ftLastWriteTime; }
    ULONG GetTotalSend(void) { return m_cbTotalSend; }
    void SetTotalSend(ULONG cb) { m_cbTotalSend = cb; }
	void SetPercentSent(long percentSent){ m_percentSent = percentSent;}
	long GetPercentSent(){return m_percentSent;}

    // time
    FILETIME *GetLastWriteTime(void) { return &m_FileInfo.ftLastWriteTime; }
    FILETIME *GetLastAccessTime(void) { return &m_FileInfo.ftLastAccessTime; }
    FILETIME *GetCreationTime(void) { return &m_FileInfo.ftCreationTime; }

    // file handle
    MBFTFILEHANDLE GetFileHandle(void) { return m_nFileHandle; }
    void SetFileHandle(MBFTFILEHANDLE nFileHandle) { m_nFileHandle = nFileHandle; }

    // error code
    MBFT_ERROR_CODE GetErrorCode(void) { return m_eSendErrorCode; }
    void SetErrorCode(MBFT_ERROR_CODE err) { m_eSendErrorCode = err; }

    void SetShowUI(void) { m_fAlreadyShowUI = TRUE; }
    BOOL HasShownUI(void) { return m_fAlreadyShowUI; }

private:
	HANDLE GetOpenFile(CAppletWindow *, TCHAR szDir[], TCHAR szFile[], BOOL fResolve);
	long			m_percentSent;

    LPTSTR          m_pszFullName; // allocated
    LPTSTR          m_pszFileName; // handy shortcut

    ULONG           m_cbTotalSend;
    MBFTFILEHANDLE  m_nFileHandle;

    MBFT_ERROR_CODE m_eSendErrorCode;

    BOOL            m_fAlreadyShowUI;

    BY_HANDLE_FILE_INFORMATION  m_FileInfo;
};


class CUiRecvFileInfo
{
public:

    CUiRecvFileInfo(FileOfferNotifyMsg *pMsg, HRESULT *pHr);
    ~CUiRecvFileInfo(void);

    // name
    LPTSTR GetFullName(void) { return m_pszFullName; }
    LPTSTR GetName(void) { return m_pszFileName; }
    LPTSTR GetRecvFolder(void) { return m_pszRecvFolder; }

    // numbers
    ULONG GetSize(void) { return m_cbFileSize; }
    ULONG GetTotalRecvSize(void) { return m_cbTotalRecvSize; }
    void SetTotalRecvSize(ULONG cbTotalRecvSize) { m_cbTotalRecvSize = cbTotalRecvSize; }

    // file handle
    MBFTFILEHANDLE GetFileHandle(void) { return m_nFileHandle; }
    void SetFileHandle(MBFTFILEHANDLE nFileHandle) { m_nFileHandle = nFileHandle; }

private:

    LPTSTR          m_pszFullName; // allocated
    LPTSTR          m_pszFileName; // handy shortcut

    MBFTFILEHANDLE  m_nFileHandle;
    time_t          m_FileDateTime;

    ULONG           m_cbFileSize;
    ULONG           m_cbTotalRecvSize;

    LPTSTR          m_pszRecvFolder;
};


class CRecvDlg : public CRefCount
{
public:

    CRecvDlg(CAppletWindow*, T120ConfID, T120NodeID, MBFTEVENTHANDLE, CUiRecvFileInfo *, HRESULT *);
    ~CRecvDlg(void);

    void OnOpen(void);
    void OnDelete(void);
    void OnAccept(void);

    void StopAnimation(void);

    ULONG GetPercent(void);
    void OnProgressUpdate(FileTransmitMsg *pMsg = NULL);

    void OnCanceled(void);
    void OnRejectedFile(void);

    CUiRecvFileInfo *GetRecvFileInfo(void) { return m_pRecvFileInfo; }
    MBFTEVENTHANDLE GetEventHandle(void) { return m_nEventHandle; }
    MBFTFILEHANDLE GetFileHandle(void) { return m_pRecvFileInfo->GetFileHandle(); }

    HWND GetHwnd(void) { return m_hwndRecvDlg; }

    T120ConfID GetConfID(void) { return m_nConfID; }
    T120NodeID GetSenderID(void) { return m_nidSender; }

    ULONG GetTotalRecvSize(void) { return m_pRecvFileInfo->GetTotalRecvSize(); }

    BOOL IsRecvComplete(void) { return m_fRecvComplete; }

private:

    HWND                m_hwndRecvDlg;
    UINT                m_idResult;

    CAppletWindow      *m_pWindow;
    T120ConfID          m_nConfID;
    T120NodeID          m_nidSender;
    MBFTEVENTHANDLE     m_nEventHandle;

    CUiRecvFileInfo    *m_pRecvFileInfo;

    BOOL                m_fRecvComplete;
    BOOL                m_fShownRecvCompleteUI;
    HRESULT             m_hr;

    DWORD               m_dwEstTimeLeft;
	DWORD               m_dwPreviousTime;
	DWORD               m_dwPreviousTransferred;
	DWORD               m_dwBytesPerSec;
	DWORD               m_dwStartTime;
};


class CRecvDlgList : public CQueue
{
    DEFINE_CQUEUE(CRecvDlgList, CRecvDlg*)
};

class CErrorDlgList : public CList
{
	DEFINE_CLIST(CErrorDlgList, HWND);
};

class CAppletWindow : public CRefCount
{
    friend LRESULT OnCreate(HWND hwnd, WPARAM wParam, LPARAM lParam);

public:

    CAppletWindow(BOOL fNoUI, HRESULT *);
    ~CAppletWindow(void);

public:
	BOOL FilterMessage(MSG *msg);
    //
    // Applet operation
    //
    void RegisterEngine(MBFTEngine *);
    void UnregisterEngine(void);
    void RegisterRecvDlg(CRecvDlg *);
    void UnregisterRecvDlg(CRecvDlg *);
    CRecvDlg *FindDlgByHandles(MBFTEVENTHANDLE, MBFTFILEHANDLE);

    BOOL IsInConference(void) { return (NULL != m_pEngine); }
    HWND GetHwnd(void) { return m_hwndMainUI; }
    HWND GetListView(void) { return m_hwndListView; }
    MBFTEngine *GetEngine(void) { return m_pEngine; }

    void OnEngineNotify(MBFTMsg *);
    BOOL QueryShutdown(BOOL fShutdown = TRUE);

    //
    // Windows message derivatives
    //
    // WM_CREATE
    BOOL CreateToolBar(void);
    BOOL CreateStatusBar(void);
    BOOL CreateListView(void);
	BOOL CreateProgressBar(void);


    // WM_NOTIFY
    void OnNotifyListView(LPARAM);
    // WM_DROPFILES
    LRESULT OnDropFiles(HANDLE hDrop);
    // WM_CONTEXTMENU
    void SetContextMenuStates(void);
    void OnContextMenuForMainUI(LPARAM lParam);
    void OnContextMenuForListView(LPARAM lParam);
    void CreateMenu(LPARAM lParam, ULONG cItems, UI_MENU_INFO aMenuInfo[]);
    // WM_SIZE
    void OnSizeToolBar(void);
    void OnSizeStatusBar(void);
    void OnSizeListView(void);
    // WM_GETMINMAXINFO
    void OnGetMinMaxInfo(LPMINMAXINFO);
	// WM_DRAWITEM
	void OnDrawItem(void);

    //
    // OnCommand
    //
    void OnAddFiles(void);
    void OnRemoveFiles(void);
    void OnRemoveAllFiles(void);
    void OnSendAll(void);
	void OnSendOne(void);
    void OnStopSending(void);
    void OnOpenRecvFolder(void);
    void OnExit(BOOL fNoQuery = FALSE); // exit point
    void OnHelp(void);
    void OnAbout(void);
	void OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);

    //
    // OnEngineNotify
    //
    void HandleFileOfferNotify(FileOfferNotifyMsg *);
    void HandleProgressNotify(FileTransmitMsg *);
    void HandleErrorNotify(FileErrorMsg *);
    void HandleInitUninitNotification(InitUnInitNotifyMsg *);
    void HandleFileEventEndNotification(FileEventEndNotifyMsg *);
	void HandlePeerNotification(PeerMsg  *pMdg);

    //
    // Other methods
    //
    void BringToFront(void);
    void ClearSendInfo(BOOL fUpdateMenu);
    void ClearRecvInfo(void);

    void UpdateUI(void); // UpdateMenu && UpdateToolBar
    void UpdateTitle(void);
    void UpdateMenu(void);
    void UpdateToolBar(void);
    void UpdateStatusBar(void);
    void UpdateListView(CUiSendFileInfo *);

    void ResolveShortcut(LPTSTR pszFile, LPTSTR pszFileDest);
	BOOL DrawItem(LPDRAWITEMSTRUCT);
	void OnCommand(WORD wId, HWND hwndCtl, WORD codeNotify);
	void SetSendMode(BOOL fSendALL)  { m_fSendALL = fSendALL; };
	void FocusNextRecvDlg(void);
	void FocusNextErrorDlg(void);
	CUiSendFileInfo *ChooseFirstUnSentFile(void);
	CUiSendFileInfo *ChooseSelectedFile(void);
	BOOL UIHidden(void) { return m_UIMode != FTUIMODE_SHOWUI; }
	FTUIMode GetUIMode(void) { return m_UIMode; }
	void AddErrorDlg(HWND hwndErrorDlg) { m_ErrorDlgList.Prepend(hwndErrorDlg); }
	void RemoveErrorDlg(HWND hwndErrorDlg) { m_ErrorDlgList.Remove(hwndErrorDlg);	}
	void SetListViewFocus(void){ListView_SetItemState(m_hwndListView, 0, LVIS_SELECTED | LVIS_FOCUSED,LVIS_SELECTED | LVIS_FOCUSED);}

protected:

    void SetHwnd(HWND hwnd) { ASSERT(NULL == m_hwndMainUI); m_hwndMainUI = hwnd; }
	void SaveWindowPosition(void);
	BOOL HasUnSentFiles(BOOL fUnSentOnly = TRUE);
	BOOL SendNow(CUiSendFileInfo *pFileInfo);
	BOOL FBrowseForFolder(LPTSTR pszFolder, UINT cchMax, LPCTSTR pszTitle);
	BOOL IsReceiving(void);

private:
    HWND            m_hwndMainUI;
    HWND            m_hwndStatusBar;
    HWND            m_hwndListView;	
	HWND			m_hwndProgressBar;		// progress bar
	CComboToolbar	*m_pToolbar;

	HACCEL			m_hAccel;
	HACCEL			m_hLVAccel;
	TCHAR			m_szDefaultDir[MAX_PATH];

	HICON			m_hIconInCall;          // Incall icon
	HICON			m_hIconNotInCall;		// Not incall icon

    MBFTEngine     *m_pEngine;

    CRecvDlgList    m_RecvDlgList;
	CErrorDlgList   m_ErrorDlgList;

    BOOL            m_fInFileOpenDialog;
	BOOL			m_fSendALL;				// flag indicating whether to send one file only
    FTUIMode        m_UIMode;	            // whether the UI is hidden
	
    CUiSendFileInfo*m_pCurrSendFileInfo;
    MBFTEVENTHANDLE m_nCurrSendEventHandle;

    TCHAR           m_szFtMainWndClassName[32];
};

HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);

#endif // _FT_MAIN_UI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftper.h ===
/**************************************************************/
/* Copyright (c) 1995 Intel Corporation.  All rights reserved.*/
/**************************************************************/
/* Abstract syntax: mbft */
/* Created: Mon Mar 18 11:56:58 1996 */
/* ASN.1 compiler version: 4.1 */
/* Target operating system: MS-DOS 5.0/Windows 3.1 or later */
/* Target machine type: Intel x86 */
/* C compiler options required: -Zp8 (Microsoft) or equivalent */
/* ASN.1 compiler options specified:
 * -noshortennames -prefix -c++ -per
 */

#ifndef OSS_mbft
#define OSS_mbft

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#include "asn1hdr.h"

#define          ASNEntity_Reference_PDU 1
#define          ASNMBFTPDU_PDU 2

typedef struct ASN_ObjectID_ {
    struct ASN_ObjectID_ *next;
    unsigned short  value;
} *ASN_ObjectID;

typedef struct ASNABSTRACT_SYNTAX {
    struct ASN_ObjectID_ *id;
    unsigned short  Type;
} ASNABSTRACT_SYNTAX;

typedef struct ASN_choice1 {
    unsigned short  choice;
#       define      ASNsingle_ASN1_type_chosen 1
#       define      ASNoctet_aligned_chosen 2
#       define      ASNarbitrary_chosen 3
    union _union {
	OpenType        ASNsingle_ASN1_type;
	struct ASNExternal_octet_aligned {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNoctet_aligned;
	struct ASNExternal_arbitrary {
	    unsigned int    length;  /* number of significant bits */
	    unsigned char   *value;
	} ASNarbitrary;
    } u;
} ASN_choice1;

typedef struct ASN_External {
    unsigned char   bit_mask;
#       define      ASNdirect_reference_present 0x80
#       define      ASNindirect_reference_present 0x40
    struct ASN_ObjectID_ *ASNdirect_reference;  /* optional */
    int             ASNindirect_reference;  /* optional */
    char            *data_value_descriptor;  /* NULL for not present */
    ASN_choice1     encoding;
} ASN_External;

typedef unsigned short  ASNChannelID;

typedef unsigned short  ASNDynamicChannelID;

typedef ASNDynamicChannelID ASNUserID;

typedef unsigned short  ASNTokenID;

typedef struct ASNObjectID_ {
    struct ASNObjectID_ *next;
    unsigned long   value;
} *ASNObjectID;

typedef struct ASNH221NonStandardIdentifier {
    unsigned short  length;
    unsigned char   value[255];
} ASNH221NonStandardIdentifier;

typedef struct ASNKey {
    unsigned short  choice;
#       define      ASNobject_chosen 1
#       define      ASNh221NonStandard_chosen 2
    union _union {
	struct ASNObjectID_ *ASNobject;
	ASNH221NonStandardIdentifier ASNh221NonStandard;
    } u;
} ASNKey;

typedef struct ASNNonStandardParameter {
    ASNKey          key;
    struct {
	unsigned int    length;
	unsigned char   *value;
    } data;
} ASNNonStandardParameter;

typedef struct ASNTextString {
    unsigned short  length;
    unsigned short  *value;
} ASNTextString;

typedef unsigned short  ASNHandle;

typedef struct ASN_ObjectID_ *ASNDocument_Type_Name;

typedef struct ASNISO_8571_2_Parameters {
    unsigned char   bit_mask;
#       define      ASNuniversal_class_number_present 0x80
#       define      ASNmaximum_string_length_present 0x40
#       define      ASNstring_significance_present 0x20
    int             ASNuniversal_class_number;  /* optional */
    int             ASNmaximum_string_length;  /* optional */
    int             ASNstring_significance;  /* optional */
#       define      ASNvariable 0
#       define      ASNfixed 1
#       define      ASNnot_significant 2
} ASNISO_8571_2_Parameters;

typedef struct ASNContents_Type_Attribute {
    unsigned short  choice;
#       define      ASNdocument_type_chosen 1
    union _union {
	struct ASN_seq1 {
	    unsigned char   bit_mask;
#               define      ASNparameter_present 0x80
	    struct ASN_ObjectID_ *document_type_name;
	    ASNISO_8571_2_Parameters ASNparameter;  /* optional */
	} ASNdocument_type;
    } u;
} ASNContents_Type_Attribute;

typedef int             ASNEntity_Reference;
#define                     ASNno_categorisation_possible 0
#define                     ASNinitiating_file_service_user 1
#define                     ASNinitiating_file_protocol_machine 2
#define                     ASNservice_supporting_the_file_protocol_machine 3
#define                     ASNresponding_file_protocol_machine 4
#define                     ASNresponding_file_service_user 5

typedef struct ASNFilename_Attribute_ {
    struct ASNFilename_Attribute_ *next;
    char            *value;
} *ASNFilename_Attribute;

typedef unsigned char   ASNAccess_Request;
#define                     ASNAccess_Request_read 0x80
#define                     ASNAccess_Request_insert 0x40
#define                     ASNAccess_Request_replace 0x20
#define                     ASNAccess_Request_extend 0x10
#define                     ASNAccess_Request_erase 0x08
#define                     ASNread_attribute 0x04
#define                     ASNchange_attribute 0x02
#define                     ASNdelete_file 0x01

typedef unsigned char   ASNConcurrency_Key;
#define                     ASNnot_required 0x80
#define                     ASNshared 0x40
#define                     ASNexclusive 0x20
#define                     ASNno_access 0x10

typedef struct ASNConcurrency_Access {
    ASNConcurrency_Key read;
    ASNConcurrency_Key insert;
    ASNConcurrency_Key replace;
    ASNConcurrency_Key extend;
    ASNConcurrency_Key erase;
    ASNConcurrency_Key read_attribute;
    ASNConcurrency_Key change_attribute;
    ASNConcurrency_Key delete_file;
} ASNConcurrency_Access;

typedef char            *ASNUser_Identity;

typedef struct ASNPassword {
    unsigned short  choice;
#       define      ASNgraphic_string_chosen 1
#       define      ASNoctet_string_chosen 2
    union _union {
	char            *ASNgraphic_string;
	struct ASN_octet1 {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNoctet_string;
    } u;
} ASNPassword;

typedef struct ASNAccess_Passwords {
    ASNPassword     read_password;
    ASNPassword     insert_password;
    ASNPassword     replace_password;
    ASNPassword     extend_password;
    ASNPassword     erase_password;
    ASNPassword     read_attribute_password;
    ASNPassword     change_attribute_password;
    ASNPassword     delete_password;
} ASNAccess_Passwords;

typedef struct ASNAccess_Control_Element {
    unsigned char   bit_mask;
#       define      ASNconcurrency_access_present 0x80
#       define      ASNpasswords_present 0x40
    ASNAccess_Request action_list;
    ASNConcurrency_Access ASNconcurrency_access;  /* optional */
    ASNUser_Identity identity;  /* NULL for not present */
    ASNAccess_Passwords ASNpasswords;  /* optional */
} ASNAccess_Control_Element;

typedef struct ASNAccess_Control_Attribute {
    unsigned short  choice;
#       define      ASNsimple_password_chosen 1
#       define      ASNactual_values_chosen 2
    union _union {
	struct ASN_octet2 {
	    unsigned int    length;
	    unsigned char   *value;
	} ASNsimple_password;
	struct ASN_setof1 {
	    struct ASN_setof1 *next;
	    ASNAccess_Control_Element value;
	} *ASNactual_values;
    } u;
} ASNAccess_Control_Attribute;

typedef unsigned char   ASNPermitted_Actions_Attribute;
#define                     ASNPermitted_Actions_Attribute_read 0x80
#define                     ASNPermitted_Actions_Attribute_insert 0x40
#define                     ASNPermitted_Actions_Attribute_replace 0x20
#define                     ASNPermitted_Actions_Attribute_extend 0x10
#define                     ASNPermitted_Actions_Attribute_erase 0x08

typedef struct ASNPrivate_Use_Attribute {
    unsigned char   bit_mask;
#       define      ASNmanufacturer_values_present 0x80
    ASN_External    ASNmanufacturer_values;  /* optional */
} ASNPrivate_Use_Attribute;

typedef unsigned char   ASNProtocol_Version;
#define                     ASNversion_1 0x80

typedef struct ASNFileHeader {
    unsigned int    bit_mask;
#       define      ASNprotocol_version_present 0x80000000
#       define      ASNfilename_present 0x40000000
#       define      ASNpermitted_actions_present 0x20000000
#       define      ASNcontents_type_present 0x10000000
#       define      ASNdate_and_time_of_creation_present 0x08000000
#       define      ASNdate_and_time_of_last_modification_present 0x04000000
#       define      ASNdate_and_time_of_last_read_access_present 0x02000000
#       define      ASNfilesize_present 0x01000000
#       define      ASNfuture_filesize_present 0x00800000
#       define      ASNaccess_control_present 0x00400000
#       define      ASNprivate_use_present 0x00200000
#       define      ASNstructure_present 0x00100000
#       define      ASNapplication_reference_present 0x00080000
#       define      ASNmachine_present 0x00040000
#       define      ASNoperating_system_present 0x00020000
#       define      ASNrecipient_present 0x00010000
#       define      ASNcharacter_set_present 0x00008000
#       define      ASNcompression_present 0x00004000
#       define      ASNenvironment_present 0x00002000
#       define      ASNFileHeader_pathname_present 0x00001000
#       define      ASNuser_visible_string_present 0x00000800
    ASNProtocol_Version ASNprotocol_version;  /* default assumed if omitted */
    struct ASNFilename_Attribute_ *ASNfilename;  /* optional */
    ASNPermitted_Actions_Attribute ASNpermitted_actions;  /* optional */
    ASNContents_Type_Attribute ASNcontents_type;  /* optional */
    char            *storage_account;  /* NULL for not present */
    GeneralizedTime ASNdate_and_time_of_creation;  /* optional */
    GeneralizedTime ASNdate_and_time_of_last_modification;  /* optional */
    GeneralizedTime ASNdate_and_time_of_last_read_access;  /* optional */
    char            *identity_of_creator;  /* NULL for not present */
    char            *identity_of_last_modifier;  /* NULL for not present */
    char            *identity_of_last_reader;  /* NULL for not present */
    long            ASNfilesize;  /* optional */
    long            ASNfuture_filesize;  /* optional */
    ASNAccess_Control_Attribute ASNaccess_control;  /* optional */
    char            *legal_qualifications;  /* NULL for not present */
    ASNPrivate_Use_Attribute ASNprivate_use;  /* optional */
    struct ASN_ObjectID_ *ASNstructure;  /* optional */
    struct ASN_seqof1 {
	struct ASN_seqof1 *next;
	char            *value;
    } *ASNapplication_reference;  /* optional */
    struct ASN_seqof2 {
	struct ASN_seqof2 *next;
	char            *value;
    } *ASNmachine;  /* optional */
    struct ASN_ObjectID_ *ASNoperating_system;  /* optional */
    struct ASN_seqof3 {
	struct ASN_seqof3 *next;
	char            *value;
    } *ASNrecipient;  /* optional */
    struct ASN_ObjectID_ *ASNcharacter_set;  /* optional */
    struct ASN_seqof4 {
	struct ASN_seqof4 *next;
	char            *value;
    } *ASNcompression;  /* optional */
    struct ASN_seqof5 {
	struct ASN_seqof5 *next;
	char            *value;
    } *ASNenvironment;  /* optional */
    struct ASN_seqof6 {
	struct ASN_seqof6 *next;
	char            *value;
    } *ASNFileHeader_pathname;  /* optional */
    struct ASN_seqof7 {
	struct ASN_seqof7 *next;
	char            *value;
    } *ASNuser_visible_string;  /* optional */
} ASNFileHeader;

typedef struct ASNV42bis_Parameter_List {
    unsigned short  p1;
    unsigned short  p2;
} ASNV42bis_Parameter_List;

typedef struct ASNCompressionSpecifier {
    unsigned short  choice;
#       define      ASNv42bis_parameters_chosen 1
#       define      ASNnonstandard_compression_parameters_chosen 2
    union _union {
	ASNV42bis_Parameter_List ASNv42bis_parameters;
	struct ASN_setof2 {
	    struct ASN_setof2 *next;
	    ASNNonStandardParameter value;
	} *ASNnonstandard_compression_parameters;
    } u;
} ASNCompressionSpecifier;

typedef enum ASNMBFTPrivilege {
    ASNfile_transmit_privilege = 0,
    ASNfile_request_privilege = 1,
    ASNcreate_private_privilege = 2,
    ASNmedium_priority_privilege = 3,
    ASNabort_privilege = 4,
    ASNnonstandard_privilege = 5
} ASNMBFTPrivilege;

typedef struct ASNDirectoryEntry {
    ossBoolean      subdirectory_flag;
    ASNFileHeader   attributes;
} ASNDirectoryEntry;

typedef enum ASNErrorType {
    ASNinformative = 0,
    ASNtransient_error = 1,
    ASNpermanent_error = 2
} ASNErrorType;

typedef int             ASNErrorID;
#define                     ASNno_reason 0
#define                     ASNresponder_error 1
#define                     ASNsystem_shutdown 2
#define                     ASNbft_management_problem 3
#define                     ASNbft_management_bad_account 4
#define                     ASNbft_management_security_not_passed 5
#define                     ASNdelay_may_be_encountered 6
#define                     ASNinitiator_error 7
#define                     ASNsubsequent_error 8
#define                     ASNtemporal_insufficiency_of_resources 9
#define                     ASNaccess_request_violates_VFS_security 10
#define                     ASNaccess_request_violates_local_security 11
#define                     ASNconflicting_parameter_values 1000
#define                     ASNunsupported_parameter_values 1001
#define                     ASNmandatory_parameter_not_set 1002
#define                     ASNunsupported_parameter 1003
#define                     ASNduplicated_parameter 1004
#define                     ASNillegal_parameter_type 1005
#define                     ASNunsupported_parameter_types 1006
#define                     ASNbft_protocol_error 1007
#define                     ASNbft_protocol_error_procedure_error 1008
#define                     ASNbft_protocol_error_functional_unit_error 1009
#define                     ASNbft_protocol_error_corruption_error 1010
#define                     ASNlower_layer_failure 1011
#define                     ASNtimeout 1013
#define                     ASNinvalid_filestore_password 2020
#define                     ASNfilename_not_found 3000
#define                     ASNinitial_attributes_not_possible 3002
#define                     ASNnon_existent_file 3004
#define                     ASNfile_already_exists 3005
#define                     ASNfile_cannot_be_created 3006
#define                     ASNfile_busy 3012
#define                     ASNfile_not_available 3013
#define                     ASNfilename_truncated 3017
#define                     ASNinitial_attributes_altered 3018
#define                     ASNbad_account 3019
#define                     ASNambiguous_file_specification 3024
#define                     ASNattribute_non_existent 4000
#define                     ASNattribute_not_supported 4003
#define                     ASNbad_attribute_name 4004
#define                     ASNbad_attribute_value 4005
#define                     ASNattribute_partially_supported 4006
#define                     ASNbad_data_element_type 5014
#define                     ASNoperation_not_available 5015
#define                     ASNoperation_not_supported 5016
#define                     ASNoperation_inconsistent 5017
#define                     ASNbad_write 5026
#define                     ASNbad_read 5027
#define                     ASNlocal_failure 5028
#define                     ASNlocal_failure_filespace_exhausted 5029
#define                     ASNlocal_failure_data_corrupted 5030
#define                     ASNlocal_failure_device_failure 5031
#define                     ASNfuture_filesize_exceeded 5032
#define                     ASNfuture_filesize_increased 5034

typedef struct ASNFile_OfferPDU {
    unsigned char   bit_mask;
#       define      ASNroster_instance_present 0x80
#       define      ASNfile_transmit_token_present 0x40
#       define      ASNFile_OfferPDU_file_request_token_present 0x20
#       define      ASNfile_request_handle_present 0x10
#       define      ASNmbft_ID_present 0x08
#       define      ASNFile_OfferPDU_compression_specifier_present 0x04
#       define      ASNcompressed_filesize_present 0x02
    ASNFileHeader   file_header;
    ASNChannelID    data_channel_id;
    ASNHandle       file_handle;
    unsigned short  ASNroster_instance;  /* optional */
    ASNTokenID      ASNfile_transmit_token;  /* optional */
    ASNTokenID      ASNFile_OfferPDU_file_request_token;  /* optional */
    ASNHandle       ASNfile_request_handle;  /* optional */
    ASNUserID       ASNmbft_ID;  /* optional */
    ASNCompressionSpecifier ASNFile_OfferPDU_compression_specifier;  /* optional */
    int             ASNcompressed_filesize;  /* optional */
    ossBoolean      ack_flag;
} ASNFile_OfferPDU;

typedef struct ASNFile_AcceptPDU {
    ASNHandle       file_handle;
} ASNFile_AcceptPDU;

typedef enum ASN_enum1 {
    ASNFile_RejectPDU_reason_unspecified = 0,
    ASNfile_exists = 1,
    ASNfile_not_required = 2,
    ASNinsufficient_resources = 3,
    ASNtransfer_limit = 4,
    ASNcompression_unsupported = 5,
    ASNreason_unable_to_join_channel = 6,
    ASNparameter_not_supported = 7
} ASN_enum1;

typedef struct ASNFile_RejectPDU {
    ASNHandle       file_handle;
    ASN_enum1       reason;
} ASNFile_RejectPDU;

typedef struct ASNFile_RequestPDU {
    unsigned char   bit_mask;
#       define      ASNFile_RequestPDU_file_request_token_present 0x80
    ASNFileHeader   file_header;
    ASNChannelID    data_channel_id;
    ASNHandle       request_handle;
    unsigned short  roster_instance;
    ASNTokenID      file_transmit_token;
    ASNTokenID      ASNFile_RequestPDU_file_request_token;  /* optional */
    int             data_offset;
} ASNFile_RequestPDU;

typedef enum ASN_enum2 {
    ASNFile_DenyPDU_reason_unspecified = 0,
    ASNfile_not_present = 1,
    ASNinsufficient_privilege = 2,
    ASNfile_already_offered = 3,
    ASNambiguous = 4,
    ASNno_channel = 5
} ASN_enum2;

typedef struct ASNFile_DenyPDU {
    ASNHandle       request_handle;
    ASN_enum2       reason;
} ASNFile_DenyPDU;

typedef enum ASN_enum3 {
    ASNreason_unspecified = 0,
    ASNbandwidth_required = 1,
    ASNtokens_required = 2,
    ASNchannels_required = 3,
    ASNpriority_required = 4
} ASN_enum3;

typedef struct ASNFile_AbortPDU {
    unsigned char   bit_mask;
#       define      ASNdata_channel_id_present 0x80
#       define      ASNtransmitter_user_id_present 0x40
#       define      ASNFile_AbortPDU_file_handle_present 0x20
    ASN_enum3       reason;
    ASNChannelID    ASNdata_channel_id;  /* optional */
    ASNUserID       ASNtransmitter_user_id;  /* optional */
    ASNHandle       ASNFile_AbortPDU_file_handle;  /* optional */
} ASNFile_AbortPDU;

typedef struct ASNFile_StartPDU {
    unsigned char   bit_mask;
#       define      ASNFile_StartPDU_compression_specifier_present 0x80
#       define      ASNcomp_filesize_present 0x40
#       define      ASNFile_StartPDU_crc_check_present 0x20
    ASNFileHeader   file_header;
    ASNHandle       file_handle;
    ossBoolean      eof_flag;
    ossBoolean      crc_flag;
    ASNCompressionSpecifier ASNFile_StartPDU_compression_specifier;  /* optional */
    int             ASNcomp_filesize;  /* optional */
    int             data_offset;
    struct {
	unsigned short  length;
	unsigned char   *value;
    } data;
    unsigned int    ASNFile_StartPDU_crc_check;  /* optional */
} ASNFile_StartPDU;

typedef struct ASNFile_DataPDU {
    unsigned char   bit_mask;
#       define      ASNFile_DataPDU_crc_check_present 0x80
    ASNHandle       file_handle;
    ossBoolean      eof_flag;
    ossBoolean      abort_flag;
    struct {
	unsigned short  length;
	unsigned char   *value;
    } data;
    unsigned int    ASNFile_DataPDU_crc_check;  /* optional */
} ASNFile_DataPDU;

typedef struct ASNDirectory_RequestPDU {
    unsigned char   bit_mask;
#       define      ASNDirectory_RequestPDU_pathname_present 0x80
    struct ASN_seqof8 {
	struct ASN_seqof8 *next;
	char            *value;
    } *ASNDirectory_RequestPDU_pathname;  /* optional */
} ASNDirectory_RequestPDU;

typedef enum ASN_enum4 {
    ASNDirectory_ResponsePDU_result_unspecified = 0,
    ASNpermission_denied = 1,
    ASNfunction_not_supported = 2,
    ASNDirectory_ResponsePDU_result_successful = 3
} ASN_enum4;

typedef struct ASNDirectory_ResponsePDU {
    unsigned char   bit_mask;
#       define      ASNDirectory_ResponsePDU_pathname_present 0x80
    ASN_enum4       result;
    struct ASN_seqof9 {
	struct ASN_seqof9 *next;
	char            *value;
    } *ASNDirectory_ResponsePDU_pathname;  /* optional */
    struct ASN_seqof10 {
	struct ASN_seqof10 *next;
	ASNDirectoryEntry value;
    } *directory_list;
} ASNDirectory_ResponsePDU;

typedef struct ASNMBFT_Privilege_RequestPDU {
    struct ASN_setof3 {
	struct ASN_setof3 *next;
	ASNMBFTPrivilege value;
    } *mbft_privilege;
} ASNMBFT_Privilege_RequestPDU;

typedef struct ASNMBFT_Privilege_AssignPDU {
    struct ASN_setof5 {
	struct ASN_setof5 *next;
	struct temptag {
	    ASNUserID       mbftID;
	    struct ASN_setof4 {
		struct ASN_setof4 *next;
		ASNMBFTPrivilege value;
	    } *mbft_privilege;
	} value;
    } *privilege_list;
} ASNMBFT_Privilege_AssignPDU;

typedef struct ASNPrivate_Channel_Join_InvitePDU {
    ASNDynamicChannelID control_channel_id;
    ASNDynamicChannelID data_channel_id;
    ossBoolean      mode;
} ASNPrivate_Channel_Join_InvitePDU;

typedef enum ASN_enum5 {
    ASNPrivate_Channel_Join_ResponsePDU_result_unspecified = 0,
    ASNresult_unable_to_join_channel = 1,
    ASNinvitation_rejected = 2,
    ASNPrivate_Channel_Join_ResponsePDU_result_successful = 3
} ASN_enum5;

typedef struct ASNPrivate_Channel_Join_ResponsePDU {
    ASNDynamicChannelID control_channel_id;
    ASN_enum5       result;
} ASNPrivate_Channel_Join_ResponsePDU;

typedef struct ASNFile_ErrorPDU {
    unsigned char   bit_mask;
#       define      ASNFile_ErrorPDU_file_handle_present 0x80
#       define      ASNerror_text_present 0x40
    ASNHandle       ASNFile_ErrorPDU_file_handle;  /* optional */
    ASNErrorType    error_type;
    ASNErrorID      error_id;
    ASNTextString   ASNerror_text;  /* optional */
} ASNFile_ErrorPDU;

typedef struct ASNMBFT_NonStandardPDU {
    ASNNonStandardParameter data;
} ASNMBFT_NonStandardPDU;

typedef struct ASNMBFTPDU {
    unsigned short  choice;
#       define      ASNfile_OfferPDU_chosen 1
#       define      ASNfile_AcceptPDU_chosen 2
#       define      ASNfile_RejectPDU_chosen 3
#       define      ASNfile_RequestPDU_chosen 4
#       define      ASNfile_DenyPDU_chosen 5
#       define      ASNfile_ErrorPDU_chosen 6
#       define      ASNfile_AbortPDU_chosen 7
#       define      ASNfile_StartPDU_chosen 8
#       define      ASNfile_DataPDU_chosen 9
#       define      ASNdirectory_RequestPDU_chosen 10
#       define      ASNdirectory_ResponsePDU_chosen 11
#       define      ASNmbft_Privilege_RequestPDU_chosen 12
#       define      ASNmbft_Privilege_AssignPDU_chosen 13
#       define      ASNmbft_NonStandardPDU_chosen 14
#       define      ASNprivate_Channel_Join_InvitePDU_chosen 15
#       define      ASNprivate_Channel_Join_ResponsePDU_chosen 16
    union _union {
	ASNFile_OfferPDU ASNfile_OfferPDU;
	ASNFile_AcceptPDU ASNfile_AcceptPDU;
	ASNFile_RejectPDU ASNfile_RejectPDU;
	ASNFile_RequestPDU ASNfile_RequestPDU;
	ASNFile_DenyPDU ASNfile_DenyPDU;
	ASNFile_ErrorPDU ASNfile_ErrorPDU;
	ASNFile_AbortPDU ASNfile_AbortPDU;
	ASNFile_StartPDU ASNfile_StartPDU;
	ASNFile_DataPDU ASNfile_DataPDU;
	ASNDirectory_RequestPDU ASNdirectory_RequestPDU;
	ASNDirectory_ResponsePDU ASNdirectory_ResponsePDU;
	ASNMBFT_Privilege_RequestPDU ASNmbft_Privilege_RequestPDU;
	ASNMBFT_Privilege_AssignPDU ASNmbft_Privilege_AssignPDU;
	ASNMBFT_NonStandardPDU ASNmbft_NonStandardPDU;
	ASNPrivate_Channel_Join_InvitePDU ASNprivate_Channel_Join_InvitePDU;
	ASNPrivate_Channel_Join_ResponsePDU ASNprivate_Channel_Join_ResponsePDU;
    } u;
} ASNMBFTPDU;

extern ASNKey ASNt127Identifier;


extern void *mbft;    /* encoder-decoder control table */
#ifdef __cplusplus
}       /* extern "C" */
#endif /* __cplusplus */
#endif /* OSS_mbft */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftapi.cpp ===
/* file: mbftApi.cpp */

#include "mbftpch.h"

#include "messages.hpp"
#include "mbftapi.hpp"


MBFT_SEND_FILE_INFO *AllocateSendFileInfo(LPSTR pszPathName);
void FreeSendFileInfo(MBFT_SEND_FILE_INFO *);


MBFTInterface::MBFTInterface
(
    IMbftEvents     *pEvents,
    HRESULT         *pHr
)
:
    CRefCount(MAKE_STAMP_ID('I','F','T','I')),
    m_pEvents(pEvents),
    m_pEngine(NULL),
    m_FileHandle(0),
    m_InStateMachine(FALSE),
    m_bFileOfferOK(TRUE),
    m_MBFTUserID(0),
    m_SendEventHandle(0),
    m_ReceiveEventHandle(0)
{
    // register window class first
    WNDCLASS wc;
    ::ZeroMemory(&wc, sizeof(wc));
    // wc.style         = 0;
    wc.lpfnWndProc      = MBFTNotifyWndProc;
    // wc.cbClsExtra    = 0;
    // wc.cbWndExtra    = 0;
    wc.hInstance        = g_hDllInst;
    // wc.hIcon         = NULL;
    // wc.hbrBackground = NULL;
    // wc.hCursor       = NULL;
    // wc.lpszMenuName  = NULL;
    wc.lpszClassName    = g_szMBFTWndClassName;

    ::RegisterClass(&wc);

    // Create a hidden window for notification
    m_hwndNotify = ::CreateWindowA(g_szMBFTWndClassName, NULL, WS_POPUP,
                        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                        NULL, NULL, g_hDllInst, NULL);
    if (NULL != m_hwndNotify)
    {
        HANDLE hEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hEvent)
        {
            if (::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_CREATE_ENGINE, (WPARAM) hEvent, (LPARAM) this))
            {
				DWORD dwRet = ::WaitForSingleObject(hEvent, 1000);
				ASSERT(WAIT_OBJECT_0 == dwRet);
            }
			else
			{
				WARNING_OUT(("MBFTInterface::MBFTInterface: PostMessage failed, err=%d", ::GetLastError()));
			}
           *pHr = (NULL != m_pEngine) ? S_OK : E_FAIL;
            ::CloseHandle(hEvent);
            return;
        }
    }
    *pHr = E_FAIL;
}


MBFTInterface::~MBFTInterface(void)
{
    if (NULL != m_pEngine)
    {
        m_pEngine->ClearInterfacePointer();
        m_pEngine = NULL;
    }

    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
    }
}


void MBFTInterface::ReleaseInterface(void)
{
    Release();
}


void MBFTInterface::Update(void)
{
//    DoStateMachine();
}


HRESULT MBFTInterface::AcceptFileOffer
(
    MBFT_FILE_OFFER    *pOffer,
    LPCSTR              pszRecDir,
    LPCSTR              pszFileName
)
{
    BOOL bAcceptFile = (NULL != pszRecDir) && FEnsureDirExists(pszRecDir);

    DBG_SAVE_FILE_LINE
    return m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                                pOffer->hEvent,
                                pOffer->lpFileInfoList->hFile,
                                pszRecDir,
                                pszFileName,
                                bAcceptFile ? FileTransferControlMsg::EnumAcceptFile 
                                            : FileTransferControlMsg::EnumRejectFile));
}


void MBFTInterface::RejectFileOffer
(
    MBFT_FILE_OFFER     *pOffer
)
{
    DBG_SAVE_FILE_LINE
    m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                            pOffer->hEvent,
                            pOffer->lpFileInfoList->hFile,
                            NULL,
                            NULL,
                            FileTransferControlMsg::EnumRejectFile));
}


void MBFTInterface::CancelFt
(
    MBFTEVENTHANDLE     hEvent,
    MBFTFILEHANDLE      hFile
)
{
    DBG_SAVE_FILE_LINE
    m_pEngine->SafePostMessage(
                new FileTransferControlMsg(
                                        hEvent,
                                        hFile,
                                        NULL,
                                        NULL,
                                        FileTransferControlMsg::EnumAbortFile));
}


HRESULT MBFTInterface::SendFile
(
    LPCSTR              lpszFilePath,
	T120NodeID			nidReceiver,
    MBFTEVENTHANDLE    *lpEventHandle,
    MBFTFILEHANDLE     *lpFileHandle
)
{
    if (NULL != m_SendEventHandle)
    {
        // We are waiting for a timeout in a file sent to a 3rd party FT
        // that does not support our file end notification
        return E_PENDING;
    }

#ifdef ENABLE_CONDUCTORSHIP
    if( !m_pEngine->ConductedModeOK() )
    {
        return E_ACCESSDENIED;
    }
#endif

    ::EnterCriticalSection(&g_csWorkThread);

    // set event handle
    *lpEventHandle = ::GetNewEventHandle();

    ::LeaveCriticalSection(&g_csWorkThread);

    DBG_SAVE_FILE_LINE
    HRESULT hr = m_pEngine->SafePostMessage(
                                new CreateSessionMsg(MBFT_PRIVATE_SEND_TYPE, *lpEventHandle));
    if (S_OK == hr)
    {
        *lpFileHandle = ::GetNewFileHandle();

        ULONG cbSize = ::lstrlenA(lpszFilePath)+1;
        DBG_SAVE_FILE_LINE
        LPSTR pszPath = new char[cbSize];
        if (NULL != pszPath)
        {
            ::CopyMemory(pszPath, lpszFilePath, cbSize);

            DBG_SAVE_FILE_LINE
            hr = m_pEngine->SafePostMessage(
                                new SubmitFileSendMsg(
											0, // SDK only knows node ID
											nidReceiver,
                                            pszPath,
                                            *lpFileHandle,
                                            *lpEventHandle,
                                            FALSE));
            if (S_OK == hr)
            {
                m_SendEventHandle = *lpEventHandle;
            }
            else
            {
                delete [] pszPath;
            }
        }
    }

    return hr;
}


void MBFTInterface::DoStateMachine(MBFTMsg *pMsg)
{
    if(!m_InStateMachine)
    {
        BOOL fHeartBeat = FALSE;

        m_InStateMachine = TRUE;

        switch(pMsg->GetMsgType())
        {
        case EnumFileOfferNotifyMsg:
            HandleFileOfferNotify((FileOfferNotifyMsg *) pMsg);
            break;

        case EnumFileTransmitMsg:
            HandleProgressNotify((FileTransmitMsg *) pMsg);
            fHeartBeat = TRUE;
            break;

        case EnumFileErrorMsg:
            HandleErrorNotify((FileErrorMsg *) pMsg);
            break;

        case EnumPeerMsg:
            HandlePeerNotification((PeerMsg *) pMsg);
            break;

        case EnumInitUnInitNotifyMsg:
            HandleInitUninitNotification((InitUnInitNotifyMsg *) pMsg);
            break;

        case EnumFileEventEndNotifyMsg:
            HandleGenericNotification((FileEventEndNotifyMsg *) pMsg);
            break;

        default:
            ASSERT(0);
            break;
        } // switch

        m_InStateMachine = FALSE;

        if (fHeartBeat)
        {
            ::PostMessage(g_pFileXferApplet->GetHiddenWnd(), MBFTMSG_HEART_BEAT, 0, (LPARAM) m_pEngine);
        }
    }
}



void MBFTInterface::HandleFileOfferNotify(FileOfferNotifyMsg * lpNotifyMessage)
{
    if((m_ReceiveEventHandle == 0) || (m_ReceiveEventHandle != lpNotifyMessage->m_EventHandle))
    {
        TRACEAPI(" File Offer Notification for [%s], Event: [%ld], Size: [%ld], Handle [%Fp]\n",
                 lpNotifyMessage->m_szFileName,lpNotifyMessage->m_EventHandle,
                 lpNotifyMessage->m_FileSize,lpNotifyMessage->m_hFile);        

        MBFT_FILE_OFFER NewFileOffer;
        MBFT_RECEIVE_FILE_INFO FileData;
                                
        NewFileOffer.hEvent          = lpNotifyMessage->m_EventHandle;
        NewFileOffer.SenderID        = lpNotifyMessage->m_SenderID;
		NewFileOffer.NodeID          = lpNotifyMessage->m_NodeID;
        NewFileOffer.uNumFiles       = 1;
        NewFileOffer.lpFileInfoList  = &FileData;  
        NewFileOffer.bIsBroadcastEvent   = !lpNotifyMessage->m_bAckNeeded;  
                                
        ::lstrcpynA(FileData.szFileName, lpNotifyMessage->m_szFileName, sizeof(FileData.szFileName));
        FileData.hFile               = lpNotifyMessage->m_hFile;
        FileData.lFileSize           = lpNotifyMessage->m_FileSize;  
        FileData.FileDateTime        = lpNotifyMessage->m_FileDateTime;

        m_pEvents->OnFileOffer(&NewFileOffer);
    }
}                            

void MBFTInterface::HandleProgressNotify(FileTransmitMsg * lpProgressMessage)
{
    MBFT_NOTIFICATION wMBFTCode = (MBFT_NOTIFICATION)lpProgressMessage->m_TransmitStatus;

    TRACEAPI(" Notification [%x] from Event [%ld], Handle: [%ld] FileSize: [%ld], Bytes Xfered[%ld]\n",
             wMBFTCode,lpProgressMessage->m_EventHandle,
             lpProgressMessage->m_hFile,
             lpProgressMessage->m_FileSize,
             lpProgressMessage->m_BytesTransmitted);

    switch (wMBFTCode)
    {
    case iMBFT_FILE_RECEIVE_BEGIN:
        if(!m_ReceiveEventHandle)
        {
            m_ReceiveEventHandle = lpProgressMessage->m_EventHandle;
        }            
        //m_bFileOfferOK = FALSE;
        break;

    case iMBFT_FILE_RECEIVE_PROGRESS:
    case iMBFT_FILE_SEND_PROGRESS:
        {
            MBFT_FILE_PROGRESS Progress;
            Progress.hEvent             = lpProgressMessage->m_EventHandle;
            Progress.hFile              = lpProgressMessage->m_hFile;
            Progress.lFileSize          = lpProgressMessage->m_FileSize;
            Progress.lBytesTransmitted  = lpProgressMessage->m_BytesTransmitted;
            Progress.bIsBroadcastEvent  = lpProgressMessage->m_bIsBroadcastEvent;

            m_pEvents->OnFileProgress(&Progress);
        }
        break;

    case iMBFT_FILE_RECEIVE_END:
        //m_bFileOfferOK = TRUE;   
        if(m_ReceiveEventHandle == lpProgressMessage->m_EventHandle)
        {
            m_ReceiveEventHandle = 0;
        }
        // fall through
    case iMBFT_FILE_SEND_END:
        m_pEvents->OnFileEnd(lpProgressMessage->m_hFile);
        break;

    default:
        ASSERT(iMBFT_FILE_SEND_BEGIN == wMBFTCode);
        break;
    }
}    
    
void MBFTInterface::HandleErrorNotify(FileErrorMsg * lpErrorMessage) 
{

    TRACEAPI(" Error Notification, Event: [%ld], Handle [%ld], IsLocal = [%d]\n",
             lpErrorMessage->m_EventHandle,lpErrorMessage->m_hFile,
             lpErrorMessage->m_bIsLocalError);        

    
    MBFT_EVENT_ERROR Error;
        
    Error.hEvent         = lpErrorMessage->m_EventHandle;
    Error.bIsLocalError  = lpErrorMessage->m_bIsLocalError;
    Error.UserID         = lpErrorMessage->m_UserID;                            
    Error.hFile          = lpErrorMessage->m_hFile;      
    Error.bIsBroadcastEvent = lpErrorMessage->m_bIsBroadcastEvent;
    
    if(LOWORD(Error.hFile) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        Error.hFile = _iMBFT_PROSHARE_ALL_FILES;
    }

    Error.eErrorType     = (MBFT_ERROR_TYPES)lpErrorMessage->m_ErrorType;
    Error.eErrorCode     = (MBFT_ERROR_CODE)lpErrorMessage->m_ErrorCode;  
    
    m_pEvents->OnFileError(&Error);
}                            

void MBFTInterface::HandlePeerNotification(PeerMsg * lpNewMessage)
{

    TRACEAPI(" Peer Notification, Node [%u], UserID [%u], IsProshare = [%u], Added = [%u]\n",
             lpNewMessage->m_NodeID,
             lpNewMessage->m_MBFTPeerID,lpNewMessage->m_bIsProsharePeer,
             lpNewMessage->m_bPeerAdded);        

    
    MBFT_PEER_INFO PeerInfo;

    PeerInfo.NodeID          = lpNewMessage->m_NodeID;  
    PeerInfo.MBFTPeerID      = lpNewMessage->m_MBFTPeerID;  
    PeerInfo.bIsProShareApp  = lpNewMessage->m_bIsProsharePeer;
    PeerInfo.MBFTSessionID   = lpNewMessage->m_MBFTSessionID;
    
    //PeerInfo.bIsLocalPeer    = lpNewMessage->m_bIsLocalPeer;
    
    ::lstrcpynA(PeerInfo.szAppKey,lpNewMessage->m_szAppKey, sizeof(PeerInfo.szAppKey));

    //lstrcpyn(PeerInfo.szProtocolKey,lpNewMessage->m_szProtocolKey, sizeof(PeerInfo.szProtocolKey));

    if(!lpNewMessage->m_bIsLocalPeer)
    {
        TRACEAPI("Delivering PEER Notification\n");
        if (lpNewMessage->m_bPeerAdded)
        {
            m_pEvents->OnPeerAdded(&PeerInfo);
        }
        else
        {
            m_pEvents->OnPeerRemoved(&PeerInfo);
        }
    }  
    
    if(lpNewMessage->m_bIsLocalPeer) 
    {
        if(lpNewMessage->m_bPeerAdded)
        {
            m_MBFTUserID    = PeerInfo.MBFTPeerID;
                
            m_pEvents->OnInitializeComplete();
        }
    }
}


void MBFTInterface::HandleInitUninitNotification(InitUnInitNotifyMsg * lpNewMessage)
{
    if (lpNewMessage->m_iNotifyMessage == EnumInvoluntaryUnInit)
    {
        if (NULL != m_pEvents)
        {
            m_pEvents->OnSessionEnd();
        }
    }
}

void MBFTInterface::HandleGenericNotification(FileEventEndNotifyMsg * lpNewMessage)
{
    if (m_SendEventHandle == lpNewMessage->m_EventHandle)
    {
        m_SendEventHandle  = 0;
    }
    m_pEvents->OnFileEventEnd(lpNewMessage->m_EventHandle);
}



MBFT_SEND_FILE_INFO *AllocateSendFileInfo(LPSTR pszPathName)
{
    MBFT_SEND_FILE_INFO *p = new MBFT_SEND_FILE_INFO;
    if (NULL != p)
    {
        ::ZeroMemory(p, sizeof(*p));
        ULONG cb = ::lstrlenA(pszPathName) + 1;
        p->lpszFilePath = new char[cb];
        if (NULL != p->lpszFilePath)
        {
            ::CopyMemory(p->lpszFilePath, pszPathName, cb);
#ifdef BUG_INTL
            ::AnsiToOem(p->lpszFilePath, p->lpszFilePath);
#endif /* BUG_INTL */
        }
        else
        {
            delete p;
            p = NULL;
        }
    }
    return p;
}

void FreeSendFileInfo(MBFT_SEND_FILE_INFO *p)
{
    if (NULL != p)
    {
        delete p->lpszFilePath;
        delete p;
    }
}


HRESULT MBFTInterface::SafePostNotifyMessage(MBFTMsg *pMsg)
{
    if (NULL != pMsg)
    {
        AddRef();
        if( !::PostMessage(m_hwndNotify, MBFTNOTIFY_BASIC, (WPARAM) pMsg, (LPARAM) this) )
        {
            Release();
            delete pMsg;
            pMsg = NULL;
        }
        return S_OK;
    }
    ERROR_OUT(("MBFTInterface::SafePostNotifyMessage: null msg ptr"));
    return E_OUTOFMEMORY;
}


LRESULT CALLBACK
MBFTNotifyWndProc
(
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam
)
{
    switch (uMsg)
    {
    case MBFTNOTIFY_BASIC:
        {
            MBFTInterface *pIntf = (MBFTInterface *) lParam;
            MBFTMsg *pMsg = (MBFTMsg *) wParam;
            ASSERT(NULL != pIntf);
            ASSERT(NULL != pMsg);
            pIntf->DoStateMachine(pMsg);
            delete pMsg;
            pIntf->Release();
        }
        break;

    case WM_CLOSE:
        ::DestroyWindow(hwnd);
        break;

    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftdbg.h ===
/* file: mbftdbg.h */

#ifndef __MBFTDBG_H__
#define __MBFTDBG_H__

#ifdef  __cplusplus
extern "C"
{
#endif


#ifdef _DEBUG
    VOID  InitDebug(void);
    VOID  DeInitDebugMbft(void);
    PCSTR FAR PASCAL GetMbftRcString(DWORD dwRc);
    LPCTSTR GetMcsErrorString(MCSError mcsError);
#else
    #define InitDebug()
    #define DeInitDebugMbft()
#endif


#ifdef _DEBUG

VOID DbgMsgMbft(PCHAR psz,...);

extern HDBGZONE ghZoneMbft;

#define ZONE_MBFT_SEND          0x0000
#define ZONE_MBFT_MCS           0x0001
#define ZONE_MBFT_RECEIVE       0x0002
#define ZONE_MBFT_STATE         0x0003
#define ZONE_MBFT_INIT          0x0004
#define ZONE_MBFT_GCC           0x0005
#define ZONE_MBFT_PDU           0x0006
#define ZONE_MBFT_DELETE        0x0007
#define ZONE_MBFT_API           0x0008
#define ZONE_MBFT_COMPRESS      0x0009
#define ZONE_MBFT_OTHER         0x000A

#define _TRACE_SEND             0x0001
#define _TRACE_MCS              0x0002
#define _TRACE_RECEIVE          0x0004
#define _TRACE_STATE            0x0008
#define _TRACE_INIT             0x0010
#define _TRACE_GCC              0x0020
#define _TRACE_PDU              0x0040
#define _TRACE_DELETE           0x0080
#define _TRACE_API              0x0100
#define _TRACE_COMPRESS         0x0200

#define TRACE           DBGMSG(ghZoneMbft, ZONE_MBFT_OTHER, ("Mbft Trace"));\
                        DbgMsgMbft
     
#define TRACESEND       DBGMSG(ghZoneMbft, ZONE_MBFT_SEND, ("SEND(%Fp,%ld): ",m_lpParentEngine,m_EventHandle));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_SEND) \
                        DbgMsgMbft

#define TRACEMCS        DBGMSG(ghZoneMbft, ZONE_MBFT_MCS, ("MCS(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_MCS) \
                        DbgMsgMbft

#define TRACERECEIVE    DBGMSG(ghZoneMbft, ZONE_MBFT_RECEIVE, ("RECEIVE(%Fp,%ld): ",m_lpParentEngine,m_EventHandle));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_RECEIVE) \
                        DbgMsgMbft

#define TRACEAPI        DBGMSG(ghZoneMbft, ZONE_MBFT_API, ("API(%Fp): ",m_pEngine));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_API) \
                        DbgMsgMbft
 
#define TRACESTATE      DBGMSG(ghZoneMbft, ZONE_MBFT_STATE, ("STATE(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_STATE) \
			DbgMsgMbft
                        
#define TRACEINIT       DBGMSG(ghZoneMbft, ZONE_MBFT_INIT, ("INIT(%Fp): ",m_lpParentEngine));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_INIT) \
			DbgMsgMbft
                        
#define TRACEGCC        DBGMSG(ghZoneMbft, ZONE_MBFT_GCC, ("GCC(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_GCC) \
			DbgMsgMbft

#define TRACEPDU        DBGMSG(ghZoneMbft, ZONE_MBFT_PDU, ("PDU(%Fp): ",this));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_PDU) \
			DbgMsgMbft
                        
#define TRACEDELETE     DBGMSG(ghZoneMbft, ZONE_MBFT_DELETE, ("Mbft Delete"));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_DELETE) \
			DbgMsgMbft

#define TRACECOMPRESS   DBGMSG(ghZoneMbft, ZONE_MBFT_COMPRESS, ("Compression: "));\
                        if(GETZONEMASK(ghZoneMbft) & _TRACE_COMPRESS) \
			DbgMsgMbft

#else

#define TRACE           
     
#define TRACESEND       

#define TRACEMCS        

#define TRACERECEIVE    

#define TRACEAPI        
 
#define TRACESTATE      
                        
#define TRACEINIT       
                        
#define TRACEGCC        

#define TRACEPDU        
                        
#define TRACEDELETE     

#define TRACECOMPRESS   

#endif	// _TRACE


#ifdef  __cplusplus
}
#endif

#endif  //__MBFTDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftapi.hpp ===
#ifndef __MBFTAPI_HPP__
#define __MBFTAPI_HPP__


class MBFTEngine;

class FileOfferNotifyMsg;
class FileTransmitMsg;   
class FileErrorMsg;
class PeerMsg;
class InitUnInitNotifyMsg;
class FileEventEndNotifyMsg;

enum
{
    MBFTNOTIFY_BASIC        = WM_APP + 0x101,
};


class MBFTInterface : public IMbftControl, public CRefCount
{
public:

    STDMETHOD_(void, ReleaseInterface)( THIS);
    STDMETHOD_(void, Update)(           THIS);
    STDMETHOD_(void, CancelFt)(         THIS_
                                        MBFTEVENTHANDLE hEvent,
                                        MBFTFILEHANDLE  hFile);
    STDMETHOD(AcceptFileOffer)(         THIS_
                                        MBFT_FILE_OFFER *pOffer,
                                        LPCSTR pszRecDir,
                                        LPCSTR pszFileName);
    STDMETHOD_(void, RejectFileOffer)(  THIS_
                                        MBFT_FILE_OFFER *pOffer);
    STDMETHOD(SendFile)(                THIS_
                                        LPCSTR pszFileName,
                                        T120NodeID nidReceiver,
                                        MBFTEVENTHANDLE *phEvent,
                                        MBFTFILEHANDLE *phFile);
private:
	
    IMbftEvents        *m_pEvents;

    MBFTEngine  *       m_pEngine;
    HWND                m_hwndNotify;
    BOOL                m_bFileOfferOK;
    LPARAM              m_lpUserDefined;
    MBFTFILEHANDLE      m_FileHandle;
    BOOL                m_InStateMachine;
    T120UserID          m_MBFTUserID;    
    MBFTEVENTHANDLE     m_SendEventHandle;
    MBFTEVENTHANDLE     m_ReceiveEventHandle;

    //Sigh..., the CTK people don't give you a choice...

    static LRESULT PASCAL CTKCallBackFunction(HWND hWnd,UINT Message,
                                                           WPARAM wParam,LPARAM lParam);  
public:
        
    MBFTInterface(IMbftEvents *, HRESULT *);
    ~MBFTInterface(void);

    void SetEngine(MBFTEngine *p) { m_pEngine = p; }

    HRESULT SafePostNotifyMessage(MBFTMsg *pMsg);

    void DoStateMachine(MBFTMsg *pMsg);
    void HandlePeerNotification(PeerMsg * lpNewMessage);
    void HandleFileOfferNotify(FileOfferNotifyMsg * lpNotifyMessage);
    void HandleProgressNotify(FileTransmitMsg * lpProgressMessage);    
    void HandleErrorNotify(FileErrorMsg * lpErrorMessage); 
    void HandleInitUninitNotification(InitUnInitNotifyMsg * lpNewMessage);
    void HandleGenericNotification(FileEventEndNotifyMsg * lpNewMessage);
};

#endif  //__MBFTAPI_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftpch.h ===
/* ----------------------------------------------------------------------

	Copyright (c) 1996, Microsoft Corporation
	All rights reserved

	mbftpch.h

  ---------------------------------------------------------------------- */

#define _WINDOWS

// System Include files
#include <windows.h>
#include <windowsx.h>
#include <objbase.h>
#include <commdlg.h>
#include <shellapi.h>
#include <time.h>

// Oprah files
#include <oprahcom.h>
#include <confdbg.h>
#include <cstring.hpp>

// Local Include files
#include <ConfDbg.h>
#include <debspew.h>
#include <confreg.h>

// MBFT include files

extern "C"
{
#include "t120.h"
}

#include <imcsapp.h>
#include <igccapp.h>
#include <imbft.h>
#include <dllutil.h>

#include "mbftdbg.h"

#include "ms_util.h"
#include "cntlist.h"

const USHORT _MBFT_CONTROL_CHANNEL                   = 9;
const USHORT _MBFT_DATA_CHANNEL                      = 10;

const ULONG _iMBFT_PROSHARE_ALL_FILES = 0xFFFFFFFF;
const UINT  _iMBFT_DEFAULT_SESSION    = _MBFT_CONTROL_CHANNEL; // 9
const UINT  _iMBFT_CREATE_NEW_SESSION = 0;
const UINT  _iMBFT_MAX_PATH           = MAX_PATH;    //Max chars in file pathname


typedef enum
{
    MBFT_STATIC_MODE,
    MBFT_MULTICAST_MODE,
    // MBFT_PRIVATE_MODE, // not used at all
}
    MBFT_MODE;

typedef enum
{
    MBFT_PRIVATE_SEND_TYPE,
    MBFT_PRIVATE_RECV_TYPE,
    MBFT_BROADCAST_RECV_TYPE,
}
    MBFT_SESSION_TYPE;


// A list of the notification callbacks to the app
typedef enum
{
    iMBFT_FILE_OFFER,
    iMBFT_FILE_SEND_BEGIN,
    iMBFT_FILE_SEND_END,
    iMBFT_FILE_SEND_PROGRESS,
    iMBFT_FILE_RECEIVE_PROGRESS,
    iMBFT_FILE_RECEIVE_BEGIN,
    iMBFT_FILE_RECEIVE_END,
}
    MBFT_NOTIFICATION;


// Prototype of callback function that MBFT client apps must implement
typedef void (CALLBACK * MBFTCALLBACK)(
    MBFT_NOTIFICATION eNotificationCode,
    WPARAM wParam,                      // error code if appropriate
    LPARAM lParam,                      // Ptr to struct with event info
    LPARAM lpCallerDefined);            // Client defined - see MBFTInitialize


// #define MAX_APP_KEY_SIZE 100
#define MAX_APP_KEY_SIZE        16   // applet name

// global strings that should not be localized
#define MY_APP_STR                      "_MSCONFFT"
#define PROSHARE_STRING                 "NetMeeting 1 MBFT"
#define PROSHARE_FILE_END_STRING        "NetMeeting 1 FileEnd"
#define PROSHARE_CHANNEL_LEAVE_STRING   "NetMeeting 1 ChannelLeave"
#define DATA_CHANNEL_RESOURCE_ID        "D0"

// capabilities
extern const GCCAppCap* g_aAppletCaps[4];
extern const GCCNonCollCap* g_aAppletNonCollCaps[2];

// applet session key
extern GCCSessionKey g_AppletSessionKey;

// work thread ID
extern HINSTANCE g_hDllInst;
extern DWORD g_dwWorkThreadID;
extern CRITICAL_SECTION g_csWorkThread;
extern TCHAR g_szMBFTWndClassName[32];

LRESULT CALLBACK MBFTNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

#include "osshelp.hpp"
#include "messages.hpp"
#include "applet.hpp"
#include "mbft.hpp"
#include "mbftapi.hpp"

#include "ftui.h"
#include "ftldr.h"

#include "t127pdus.h"


#define GetFileNameFromPath ExtractFileName

// from mbftsend.cpp
VOID MbftInitDelay(void);

#define ClearStruct(lpv)     ZeroMemory((LPVOID) (lpv), sizeof(*(lpv)))

// nPeerID is actually nUserID of file transfer
typedef DWORD MEMBER_ID;
#define MAKE_MEMBER_ID(nPeerID,nNodeID)         MAKELONG((nPeerID), (nNodeID))
#define GET_PEER_ID_FROM_MEMBER_ID(nMemberID)   LOWORD((nMemberID))
#define GET_NODE_ID_FROM_MEMBER_ID(nMemberID)   HIWORD((nMemberID))


extern ULONG    g_nSendDisbandDelay;
extern ULONG    g_nChannelResponseDelay;

extern BOOL     g_fSendAllowed;
extern BOOL     g_fRecvAllowed;
extern UINT_PTR     g_cbMaxSendFileSize;

extern BOOL     g_fNoUI;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftrecv.hpp ===
#ifndef __MBFTRECV_HPP__
#define __MBFTRECV_HPP__


class CMBFTFile;
class MBFTReceiveSubEvent;


class CT120ChannelList : public CList
{
    DEFINE_CLIST_(CT120ChannelList, T120ChannelID)
};

class CRecvSubEventList : public CList
{
    DEFINE_CLIST(CRecvSubEventList, MBFTReceiveSubEvent*)
    MBFTReceiveSubEvent * FindEquiv(MBFTReceiveSubEvent *);
    void Delete(MBFTReceiveSubEvent *);
    void DeleteAll(void);
};

class CChannelUidQueue : public CQueue
{
    DEFINE_CQUEUE_(CChannelUidQueue, UINT_PTR)
    BOOL RemoveByChannelID(T120ChannelID nChannelID);
    UINT_PTR FindByChannelID(T120ChannelID nChannelID);
};

class MBFTPrivateReceive : public MBFTSession
{
public:

    enum  MBFTPrivateReceiveState
    {
        EnumIdleNotInitialized,
        EnumIdleInitialized,
        EnumInitializationFailed,
        EnumWaitJoinControlChannel,
        EnumWaitRequestJoinControl,
        EnumWaitRequestControlConvene,
        EnumWaitRequestDataConvene,
        EnumWaitAdmitControlChannelIndication,
        EnumWaitAdmitDataChannelIndication,
        EnumWaitSendChannelResponsePDU,
        EnumWaitUserConfirmation,
        EnumWaitSendFileAcceptPDU,
        EnumWaitSendFileRejectPDU,
        EnumWaitFileOfferPDU,
        EnumWaitFileStartPDU,
        EnumWaitFileDataPDU,
        EnumWaitSendFileEndAcknowledgePDU,
        EnumWaitSendChannelLeavePDU,
        EnumWaitJoinDataChannel,
        EnumWaitRejoinDataChannel,
        EnumWaitRequestJoinData,
        EnumWaitAdmitControlChannel,
        EnumWaitChannelDisband,
        EnumWaitForTermination
    };

    MBFTPrivateReceive(LPMBFTENGINE, MBFTFILEHANDLE, T120ChannelID chidControl, T120ChannelID chidData);
    ~MBFTPrivateReceive(void);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnMCSChannelAdmitIndication(T120ChannelID, T120UserID uidManager);
    BOOL OnMCSChannelExpelIndication(T120ChannelID, Reason);

    virtual BOOL OnReceivedFileOfferPDU(T120ChannelID, T120Priority, T120UserID uidSender, T120NodeID uidNode, LPFILEOFFERPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileStartPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILESTARTPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileDataPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILEDATAPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILEERRORPDU lpNewPDU, BOOL IsUniformSendData);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void OnControlNotification(MBFTFILEHANDLE hFile, FileTransferControlMsg::FileTransferControl iControlCommand, LPCSTR lpszDirectory, LPCSTR lpszFileName);
    void DoStateMachine(void);
    void UnInitialize(BOOL bIsShutDown = FALSE);


protected:

    T120UserID              m_LocalMBFTUserID;
    T120ChannelID           m_PrivateMBFTControlChannel;
	CT120ChannelList        m_PrivateMBFTDataChannelList;
    T120ChannelID           m_PrivateMBFTDataChannel;
    T120UserID              m_MBFTControlSenderID;
    T120UserID              m_MBFTDataSenderID;
    T120UserID              m_ProshareSenderID;
    MBFTFILEHANDLE          m_CurrentAcceptHandle; // ???
    MBFTFILEHANDLE          m_CurrentRejectHandle; // ???
    MBFTFILEHANDLE          m_CurrentFileEndHandle;

    MBFTPrivateReceiveState m_State;
    MBFTPrivateReceiveState m_PreviousRejectState;
    BOOL                    m_bProshareTransfer;
    CRecvSubEventList       m_ReceiveList;
    MBFTReceiveSubEvent    *m_CurrentReceiveEvent;
    BOOL                    m_JoinedToDataChannel;
    BOOL                    m_bOKToLeaveDataChannel;
    BOOL                    m_bEventEndPosted;
    CChannelUidQueue        m_AdmittedChannelQueue;

    void JoinControlChannel(void);
    void JoinDataChannel(void);
    void LeaveDataChannel(void);

    void SendChannelResponsePDU(void);
    BOOL SendFileAcceptPDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendFileRejectPDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendFileEndAcknowledgePDU(MBFTFILEHANDLE iFileHandle = 0);
    void SendChannelLeavePDU(void);

    void DeleteReceiveEvent(MBFTReceiveSubEvent * lpReceive,BOOL bNotifyUser);
    void TerminateReceiveSession(void);

    void ReportError(MBFTReceiveSubEvent * lpReceiveEvent,
                     int iErrorType,
                     int iErrorCode,
                     BOOL bIsLocalError = TRUE,
                     T120UserID SenderID    = 0,
					 const char* pFileName = NULL,
					 ULONG lFileSize = 0);

    void ReportReceiverError(MBFTReceiveSubEvent * lpReceiveEvent,
                             int iErrorType,
                             int iErrorCode,
                             MBFTFILEHANDLE iFileHandle = 0);

    void DeleteNotificationMessages(MBFT_NOTIFICATION iNotificationType);

    int DecompressAndWrite(MBFTReceiveSubEvent * lpReceiveEvent,
                           LPCSTR lpBuffer,LONG BufferLength,LPINT lpDecompressedSize);
};


#ifdef USE_BROADCAST_RECEIVE
class MBFTBroadcastReceive : public MBFTPrivateReceive
{
private:

    T120UserID        m_SenderID;
    MBFTFILEHANDLE    m_FileHandle;

public:

    MBFTBroadcastReceive(LPMBFTENGINE lpParentEngine,
                         MBFTEVENTHANDLE EventHandle,
                         T120ChannelID wControlChannel,
                         T120ChannelID wDataChannel,
                         T120UserID SenderID,
                         MBFTFILEHANDLE FileHandle);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnReceivedFileOfferPDU(T120ChannelID, T120Priority, T120UserID uidSender, T120NodeID uidNode, LPFILEOFFERPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileStartPDU(T120ChannelID, T120Priority, T120UserID uidSender, LPFILESTARTPDU lpNewPDU, BOOL IsUniformSendData);
    BOOL OnReceivedFileDataPDU(T120ChannelID, T120Priority, T120UserID, LPFILEDATAPDU lpNewPDU, BOOL IsUniformSendData);
    void OnControlNotification(MBFTFILEHANDLE hFile, FileTransferControlMsg::FileTransferControl iControlCommand, LPCSTR lpszDirectory, LPCSTR lpszFileName);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void DoStateMachine(void);
    void UnInitialize(BOOL bIsShutDown = FALSE);
};

#endif	// USE_BROADCAST_RECEIVE

typedef class MBFTPrivateReceive FAR * LPMBFTPRIVATESUBSESSIONRECEIVE;

class MBFTReceiveSubEvent
{
private:

    friend class MBFTPrivateReceive;
#ifdef USE_BROADCAST_RECEIVE
    friend class MBFTBroadcastReceive;
#endif	// USE_BROADCAST_RECEIVE

    MBFTPrivateReceive::MBFTPrivateReceiveState  m_State;

    BOOL            m_bIsBroadcast;
    MBFTFILEHANDLE  m_hFile;
    ULONG           m_FileSize;
    ULONG           m_TotalBytesReceived;
    ULONG           m_cbRecvLastNotify;
    T120UserID      m_SenderID;
    CMBFTFile      *m_lpFile;
    BOOL            m_UserAccepted;
    BOOL            m_bFileCompressed;
    BOOL            m_bEOFAcknowledge;
    time_t          m_FileDateTime;
    LPVOID          m_lpV42bisPointer;
    char            m_szFileName[_MAX_FNAME];
    char            m_szFileDirectory[_MAX_PATH];

public:

    MBFTReceiveSubEvent(MBFTFILEHANDLE FileHandle,
                        LONG FileSize,
                        LPCSTR lpszFileName,
                        time_t FileDateTime,
                        T120UserID SenderID,
                        BOOL bIsBroadcast,
                        BOOL bIsCompressed,
                        BOOL bEOFAcknowledge);
    ~MBFTReceiveSubEvent(void);

    BOOL Init(void);
    BOOL IsEqual(MBFTReceiveSubEvent *lpObject);
    void InitV42DeCompression(int v42bisP1,int v42bisP2);
};


#endif      //__MBFTRECV_HPP__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftrecv.cpp ===
/* file: mbftRecv.cpp */

#include "mbftpch.h"

#include "mbftrecv.hpp"
#include "fileio.hpp"
#include "messages.hpp"
#include "mbftper.h"

extern TCHAR s_szMSFT[64];

extern HRESULT GetRecvFolder(LPTSTR pszInFldr, LPTSTR pszOutFldr);
extern void OnChangeFolder(void);
extern int MyLoadString(UINT idStr, LPTSTR pszDstStr, LPTSTR pszElement);

LPTSTR GetRootDirPath(LPTSTR pszDirPath, LPTSTR pszRootDirPath, int nSize);

MBFTPrivateReceive::MBFTPrivateReceive
(
    LPMBFTENGINE            lpParentEngine,
    MBFTEVENTHANDLE         EventHandle,
    T120ChannelID           wControlChannel,
    T120ChannelID           wDataChannel
)
:
    MBFTSession(lpParentEngine, EventHandle, MBFT_PRIVATE_RECV_TYPE),
    m_PrivateMBFTControlChannel(wControlChannel),
    m_PrivateMBFTDataChannel(wDataChannel),

    m_MBFTControlSenderID(0),
    m_MBFTDataSenderID(0),
    m_ProshareSenderID(0),
    m_LocalMBFTUserID(0),

    m_bProshareTransfer(FALSE),
    m_JoinedToDataChannel(FALSE),
    m_bOKToLeaveDataChannel(FALSE),
    m_CurrentReceiveEvent(NULL),

    m_bEventEndPosted(FALSE),
    m_CurrentAcceptHandle(0),
    m_CurrentRejectHandle(0),
    m_CurrentFileEndHandle(0),

    m_PreviousRejectState(EnumIdleNotInitialized),

    m_State(EnumWaitAdmitControlChannel)
{
	m_PrivateMBFTDataChannelList.Append(m_PrivateMBFTDataChannel);
}

MBFTPrivateReceive::~MBFTPrivateReceive(void)
{
    m_ReceiveList.DeleteAll();
}

void MBFTPrivateReceive::JoinControlChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTControlChannel))
    {
        m_State = EnumWaitJoinControlChannel;
    }
    else
    {
        m_State = EnumInitializationFailed;
    }
}

void MBFTPrivateReceive::JoinDataChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTDataChannel))
    {
        if(m_State == EnumWaitAdmitDataChannelIndication)
        {
            m_State = EnumWaitJoinDataChannel;
        }
    }
    else
    {
        m_State = EnumInitializationFailed;
    }
}

BOOL MBFTPrivateReceive::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelID,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitJoinControlChannel)
    {
        if(wChannelID == m_PrivateMBFTControlChannel)
        {
            bReturn = TRUE;

            m_State = bSuccess ? EnumWaitAdmitDataChannelIndication :
                                 EnumInitializationFailed;

            // data channel admit indication may come earlier than this state change.
            // look for unserviced channel admit indication
            if (EnumWaitAdmitDataChannelIndication == m_State)
            {
                UINT_PTR chid_uid;
                m_AdmittedChannelQueue.Reset();
                while (0 != (chid_uid = m_AdmittedChannelQueue.Iterate()))
                {
                    if (m_PrivateMBFTDataChannelList.Find(LOWORD(chid_uid)))
                    {
                        OnMCSChannelAdmitIndication(LOWORD(chid_uid), HIWORD(chid_uid));
                        m_AdmittedChannelQueue.Remove(chid_uid);
                        break;
                    }
                }
            }
        }
    }
    else if(m_State == EnumWaitJoinDataChannel || m_State == EnumWaitRejoinDataChannel)
    {
        if(m_PrivateMBFTDataChannelList.Find(wChannelID))
        {
            bReturn = TRUE;

            if(bSuccess)
            {
                m_JoinedToDataChannel = TRUE;

                if(m_State == EnumWaitJoinDataChannel)
                {
                    m_State = EnumWaitSendChannelResponsePDU;
                }
                else if(m_State == EnumWaitRejoinDataChannel)
                {
                    TRACERECEIVE(" Rejoined Data Channel [%u]\n",wChannelID);

                    if(m_CurrentReceiveEvent)
                    {
                        SendFileAcceptPDU((unsigned)m_CurrentReceiveEvent->m_hFile);
                        m_CurrentReceiveEvent->m_State = EnumWaitFileStartPDU;
                    }
                    else
                    {
                        TRACE(" *** WARNING: Receive Event deleted before Data Channel was rejoined! ***\n");
                    }

                    //m_State = EnumWaitFileOfferPDU;
                }
            }
            else
            {
                m_State = EnumInitializationFailed;
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateReceive::UnInitialize
(
    BOOL            bIsShutDown
)
{
    if(m_State != EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        MBFTReceiveSubEvent * lpReceive;
        m_ReceiveList.Reset();
        while (NULL != (lpReceive = m_ReceiveList.Iterate()))
        {
            if(!lpReceive->m_UserAccepted)
            {
                lpReceive->m_lpFile->DeleteFile();
            }
        }

        m_PrivateMBFTDataChannelList.Clear();

        if(!bIsShutDown)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));

            if(!m_bEventEndPosted)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostNotifyMessage(
                                    new FileEventEndNotifyMsg(m_EventHandle));
                m_bEventEndPosted   =   TRUE;
            }
        }
    }
}



MBFTReceiveSubEvent::MBFTReceiveSubEvent
(
    MBFTFILEHANDLE          hFile,
    LONG                    FileSize,
    LPCSTR                  lpszFileName,
    time_t                  FileDateTime,
    T120UserID              SenderID,
    BOOL                    bIsBroadcast,
    BOOL                    bIsCompressed,
    BOOL                    bEOFAcknowledge
)
:
    m_bIsBroadcast(bIsBroadcast),
    m_hFile(MAKELONG(hFile,SenderID)),
    m_FileSize(FileSize),
    m_FileDateTime(FileDateTime),
    m_TotalBytesReceived(0),
    m_cbRecvLastNotify(0),
    m_bFileCompressed(bIsCompressed),
    m_bEOFAcknowledge(bEOFAcknowledge),
    m_SenderID(SenderID),
    m_lpFile(NULL),
    m_UserAccepted(FALSE)
{
    if(lpszFileName)
    {
        ::lstrcpynA(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        m_szFileName[0] = '\0';
    }

    m_szFileDirectory[0] = '\0';

    m_State = (! bIsBroadcast) ? MBFTPrivateReceive::EnumWaitUserConfirmation :
                                 MBFTPrivateReceive::EnumWaitFileStartPDU;
}


BOOL MBFTReceiveSubEvent::Init(void)
{
    DBG_SAVE_FILE_LINE
	m_lpFile = new CMBFTFile;
	return(m_lpFile != NULL);
}


MBFTReceiveSubEvent::~MBFTReceiveSubEvent(void)
{
    if(m_lpFile)
    {
		// if the file wasn't completely received, delete it
		if (m_TotalBytesReceived < m_FileSize)
			m_lpFile->Close(FALSE);

        delete m_lpFile;
    }
}

BOOL MBFTReceiveSubEvent::IsEqual
(
    MBFTReceiveSubEvent         *lpObject
)
{
    BOOL bReturn = FALSE;

    if(!lpObject->m_SenderID || !m_SenderID)
    {
        bReturn = (lpObject->m_hFile == (MBFTFILEHANDLE)MAKELONG(m_hFile, lpObject->m_SenderID));
    }
    else
    {
        bReturn = (lpObject->m_hFile == m_hFile) && (lpObject->m_SenderID == m_SenderID);
    }

    return(bReturn);
}

BOOL MBFTPrivateReceive::OnReceivedFileOfferPDU
(
    T120ChannelID           wChannelID,
    T120Priority            iPriority,
    T120UserID              SenderID,
	T120NodeID				NodeID,
    LPFILEOFFERPDU          lpFileOfferPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;

    if(wChannelID == m_PrivateMBFTControlChannel)
    {
        bReturn     =   TRUE;

        if(m_State == EnumWaitFileOfferPDU)
        {
			// Sanity checking
			DWORD res;
			// Windows 95 can't take NULL pointers for these
			DWORD SecPerCluster, BytePerSector, FreeCluster, TotalFreeCluster;
			TCHAR  szDirPath[MAX_PATH];
            TCHAR  szRootDirPath[MAX_PATH], *pszRootDir;

			::GetRecvFolder(NULL, szDirPath);

			res = GetFileAttributes(szDirPath);
			if ((0xffffffff == res)||!(res | FILE_ATTRIBUTE_DIRECTORY))
			{   // invalid directory name
				iErrorCode = iMBFT_INVALID_PATH;
				goto ERRORPROCESS;
			}

			pszRootDir = GetRootDirPath(szDirPath, szRootDirPath, MAX_PATH);
			if (GetDiskFreeSpace(pszRootDir, &SecPerCluster,
								&BytePerSector, &FreeCluster, &TotalFreeCluster))
			{
				if (!(BytePerSector && SecPerCluster))
				{
					WARNING_OUT(("BytePerSector %d, SecPerCluster %d\n", BytePerSector,
						SecPerCluster));
				}
				else if ((ULONG)lpFileOfferPDU->GetFileSize()/BytePerSector/SecPerCluster + 1 > FreeCluster)
				{   // not enough space to save the file
					iErrorCode = iMBFT_DIRECTORY_FULL_ERROR;
					goto ERRORPROCESS;
				}
			}
			else
			{
				ERROR_OUT(("GetDiskSpace Failed, error %d\n", GetLastError()));
			}

            BOOL bAckRequired = lpFileOfferPDU->GetAcknowledge();

            m_bOKToLeaveDataChannel = bAckRequired;

            //Change compression handling later -- for now, we assume that a Proshare send is
            //always compressed....

            BOOL bEOFAcknowledge = FALSE;
            CPeerList *pPeerList = m_lpParentEngine->GetPeerList();
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if(lpPeer->GetUserID() == SenderID)
                {
                    bEOFAcknowledge = lpPeer->GetEOFAcknowledge();
                    break;
                }
            }

            DBG_SAVE_FILE_LINE
            MBFTReceiveSubEvent * lpNewReceive = new MBFTReceiveSubEvent(lpFileOfferPDU->GetFileHandle(),
                                                                         lpFileOfferPDU->GetFileSize(),
                                                                         lpFileOfferPDU->GetFileName(),
                                                                         lpFileOfferPDU->GetFileDateTime(),
                                                                         SenderID,
                                                                         !bAckRequired,
                                                                         lpFileOfferPDU->GetCompressionFlags() & _MBFT_FILE_COMPRESSED,
                                                                         bEOFAcknowledge);
            if(lpNewReceive)
            {
                if(lpNewReceive->Init())
                {
                    m_ReceiveList.Append(lpNewReceive);
	
                    // lonchanc: how can you use static char szTemp[] here???
					char szRecvDir[MAX_PATH];
					::GetRecvFolder(NULL, szRecvDir);

                    if(lpNewReceive->m_lpFile->Create(szRecvDir, lpNewReceive->m_szFileName))
					{
						DBG_SAVE_FILE_LINE
						m_lpParentEngine->SafePostNotifyMessage(
									   new FileOfferNotifyMsg(m_EventHandle,
															  SenderID,
															  NodeID,
															  lpNewReceive->m_hFile,
															  lpNewReceive->m_lpFile->GetFileName(),
															  lpNewReceive->m_FileSize,
															  lpNewReceive->m_FileDateTime,
															  bAckRequired));
					}
					else
					{
						iErrorCode = iMBFT_FILE_ACCESS_DENIED;
						goto ERRORPROCESS;
					}
                }
                else
                {
                    delete  lpNewReceive;
                }
            }
         }
         else if(m_State == EnumWaitChannelDisband)
         {
			SendFileRejectPDU(lpFileOfferPDU->GetFileHandle());
         }
    }

    return(bReturn);


ERRORPROCESS:
	ReportError(NULL,iErrorType,iErrorCode, TRUE, 0,
			    lpFileOfferPDU->GetFileName(),
				lpFileOfferPDU->GetFileSize());
	SendFileRejectPDU(lpFileOfferPDU->GetFileHandle());
	return (bReturn);
}

BOOL MBFTPrivateReceive::OnReceivedFileStartPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILESTARTPDU          lpFileStartPDU,
    BOOL                    IsUniformSendData
)
{
     BOOL bReturn = FALSE;
     MBFTReceiveSubEvent * lpReceiveEvent;
     MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
     MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;

    if (m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        if(m_State != EnumWaitForTermination && m_State != EnumWaitChannelDisband)
        {
            bReturn     =   TRUE;

            MBFTReceiveSubEvent TempReceive(lpFileStartPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,m_bProshareTransfer,FALSE);

            lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
            if(lpReceiveEvent)
            {
                if(lpReceiveEvent->m_State == EnumWaitFileStartPDU)
                {
                    //Double check to make sure....
                    lpReceiveEvent->m_bFileCompressed = lpFileStartPDU->GetCompressionFlags() & _MBFT_FILE_COMPRESSED;
                    if(lpReceiveEvent->m_bFileCompressed)
                    {
    					// We don't handle compressed files
    					iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                    }

                    BOOL bSuccess = FALSE;
                    int BytesWritten = 0;

                    if(lpReceiveEvent->m_bFileCompressed)
    				{
    					// We don't handle compressed files
    					iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    				}
    				else
                    {
                        BytesWritten = lpFileStartPDU->GetDataSize();
                        if(BytesWritten)
                        {
                            if(!lpReceiveEvent->m_lpFile->Write(lpFileStartPDU->GetDataBuffer(),
                                                                lpFileStartPDU->GetDataSize()))
                            {
                                iErrorCode = (MBFT_ERROR_CODE)lpReceiveEvent->m_lpFile->GetLastErrorCode();

                                //iMBFT_FILE_IO_ERROR;
                            }
                        }
                    }

                    //lpReceiveEvent->m_TotalBytesReceived += BytesWritten;

                    lpReceiveEvent->m_TotalBytesReceived   =  lpReceiveEvent->m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
                    lpReceiveEvent->m_FileSize = lpFileStartPDU->GetFileSize();

                    if(iErrorCode == iMBFT_OK)
                    {
                        if(m_State != EnumWaitForTermination)
                        {
                            FileTransmitMsg *pFileTransmitMsg;
                            
                            DBG_SAVE_FILE_LINE
                            pFileTransmitMsg = new FileTransmitMsg(
                                                        m_EventHandle,
                                                        lpReceiveEvent->m_hFile,
                                                        lpReceiveEvent->m_FileSize,
                                                        lpReceiveEvent->m_TotalBytesReceived,
                                                        iMBFT_FILE_RECEIVE_BEGIN,
                                                        lpReceiveEvent->m_SenderID,
                                                        lpReceiveEvent->m_bIsBroadcast);
                            
                            if(NULL != pFileTransmitMsg)
                            {
                                m_lpParentEngine->SafePostNotifyMessage(pFileTransmitMsg);
                            }
                            else
                            {
                                ERROR_OUT(("Failed to allocate file transmit message"));
                            }
                        }

                        if(lpFileStartPDU->GetIsEOF())
                        {
                            lpReceiveEvent->m_lpFile->SetFileDateTime(lpReceiveEvent->m_FileDateTime);

                            lpReceiveEvent->m_lpFile->Close();
                            lpReceiveEvent->m_State = EnumWaitForTermination;

        					if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
        					{
        						SendFileEndAcknowledgePDU(lpReceiveEvent->m_hFile);
        					}
        					DeleteReceiveEvent(lpReceiveEvent,TRUE);
                        }
                        else
                        {
                            lpReceiveEvent->m_State = EnumWaitFileDataPDU;
                        }
                    }

                }
            }    //lpReceiveEvent
        }   //m_State != EnumWaitForTermination

        if(iErrorCode != iMBFT_OK)
        {
            BOOL bSendChannelLeave  =   lpReceiveEvent->m_bEOFAcknowledge;

            ReportError(lpReceiveEvent,iErrorType,iErrorCode);
            ReportReceiverError(lpReceiveEvent,iErrorType,iErrorCode);
            lpReceiveEvent->m_lpFile->Close(FALSE);
            DeleteReceiveEvent(lpReceiveEvent,TRUE);

            if(m_bOKToLeaveDataChannel)
            {
                if(bSendChannelLeave && m_JoinedToDataChannel)
                {
                    SendChannelLeavePDU();
                }
                LeaveDataChannel();
            }
        }

    }        //wChannelId == m_PrivateMBFTDataChannel

    return(bReturn);
}



void MBFTPrivateReceive::ReportError
(
    MBFTReceiveSubEvent    *lpReceiveEvent,
    int                     iErrorType,
    int                     iErrorCode,
    BOOL                    bIsLocalError,
    T120UserID              SenderID,
	const char*				pFileName,
	ULONG					lFileSize
)
{
    if(m_State != EnumWaitForTermination)
    {
        MBFTMsg * lpNewMessage;
		T120UserID id = SenderID ? SenderID : m_LocalMBFTUserID;

        DBG_SAVE_FILE_LINE
        m_lpParentEngine->SafePostNotifyMessage(
                        		new FileErrorMsg(m_EventHandle,
                        			(lpReceiveEvent) ? lpReceiveEvent->m_hFile : 0, iErrorType,
                        			iErrorCode,
                        			bIsLocalError,
                        			id,
                        			(lpReceiveEvent) ?  lpReceiveEvent->m_bIsBroadcast : 0,
									pFileName, lFileSize));
    }
    else
    {
        TRACERECEIVE(" Waiting for termination, not reporting error");
    }
}

void MBFTPrivateReceive::ReportReceiverError
(
    MBFTReceiveSubEvent    *lpReceive,
    int                     iErrorType,
    int                     iErrorCode,
    MBFTFILEHANDLE          iFileHandle
)
{
    if(m_State != EnumWaitForTermination)
    {
        if(lpReceive)
        {
            DBG_SAVE_FILE_LINE
            FileErrorPDU * lpNewPDU = new FileErrorPDU(iFileHandle ? iFileHandle : lpReceive->m_hFile,
                                                       iErrorType,iErrorCode);
			if(lpNewPDU)
			{
	            if(lpNewPDU->Encode())
    	        {
        	        m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
        	                                          APPLET_HIGH_PRIORITY,
              	                                      (LPBYTE)lpNewPDU->GetBuffer(),
                   	                                  lpNewPDU->GetBufferLength());
	            }
	            delete lpNewPDU;
			}
        }
    }
    else
    {
        TRACERECEIVE(" Waiting for termination, not reporting receiver error");
    }
}

void MBFTPrivateReceive::DeleteReceiveEvent
(
    MBFTReceiveSubEvent    *lpReceive,
    BOOL                    bNotifyUser
)
{

    if(lpReceive)
    {
        if(bNotifyUser)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostNotifyMessage(
                                     new FileTransmitMsg(m_EventHandle,
                                                         lpReceive->m_hFile,
                                                         lpReceive->m_FileSize,
                                                         lpReceive->m_TotalBytesReceived,
                                                         iMBFT_FILE_RECEIVE_END,
                                                         lpReceive->m_SenderID,
                                                         lpReceive->m_bIsBroadcast));
        }

        m_ReceiveList.Delete(lpReceive);

        if(m_CurrentReceiveEvent == lpReceive)
        {
            m_CurrentReceiveEvent = NULL;
        }
    }
}

BOOL MBFTPrivateReceive::OnReceivedFileDataPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEDATAPDU           lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFTReceiveSubEvent * lpReceiveEvent;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_INFORMATIVE_ERROR;
    BOOL bLocalError = TRUE;

    if(m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
            if(m_State != EnumWaitForTermination && m_State != EnumWaitChannelDisband)
            {
                bReturn     =   TRUE;

                MBFTReceiveSubEvent TempReceive(lpNewPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,FALSE,FALSE);

                lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
                if(lpReceiveEvent)
                {
                    if(lpReceiveEvent->m_State == EnumWaitFileDataPDU)
                    {
                        MBFTMsg * lpNewMessage;

                        if(!lpNewPDU->GetIsAbort())
                        {
                            BOOL bSuccess = FALSE;
                            int  BytesWritten = 0;

                            if(lpReceiveEvent->m_bFileCompressed)
							{
								// We don't handle compressed files
								iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
							}
							else
                            {
                                BytesWritten = lpNewPDU->GetDataSize();

                                if(BytesWritten)
                                {
                                    if(!lpReceiveEvent->m_lpFile->Write(lpNewPDU->GetDataBuffer(),
                                                                        lpNewPDU->GetDataSize()))
                                    {
                                        iErrorCode = (MBFT_ERROR_CODE) lpReceiveEvent->m_lpFile->GetLastErrorCode();

                                        //iMBFT_FILE_IO_ERROR;
                                    }
                                }
                            }

                            //lpReceiveEvent->m_TotalBytesReceived += BytesWritten;

                            lpReceiveEvent->m_TotalBytesReceived   =  lpReceiveEvent->m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);

                            if(m_State != EnumWaitForTermination)
                            {
                                ASSERT(lpReceiveEvent->m_TotalBytesReceived >= lpReceiveEvent->m_cbRecvLastNotify);
                                ULONG nNotifyDelta = lpReceiveEvent->m_TotalBytesReceived - lpReceiveEvent->m_cbRecvLastNotify;
                                ULONG nNotifyThreshold = lpReceiveEvent->m_FileSize / 100; // 1%
                                if (nNotifyDelta >= nNotifyThreshold ||
                                    lpReceiveEvent->m_TotalBytesReceived >= lpReceiveEvent->m_FileSize)
                                {
                                    DBG_SAVE_FILE_LINE
                                    if (S_OK == m_lpParentEngine->SafePostNotifyMessage(
                                                    new FileTransmitMsg(m_EventHandle,
                                                                       lpReceiveEvent->m_hFile,
                                                                       lpReceiveEvent->m_FileSize,
                                                                       lpReceiveEvent->m_TotalBytesReceived,
                                                                       iMBFT_FILE_RECEIVE_PROGRESS,
                                                                       lpReceiveEvent->m_SenderID,
                                                                       lpReceiveEvent->m_bIsBroadcast)))
                                    {
                                        lpReceiveEvent->m_cbRecvLastNotify = lpReceiveEvent->m_TotalBytesReceived;
                                    }
                                }
                            }

                            if(iErrorCode == iMBFT_OK)
                            {
                                if(lpNewPDU->GetIsEOF())
                                {
                                    lpReceiveEvent->m_lpFile->SetFileDateTime(lpReceiveEvent->m_FileDateTime);

                                    lpReceiveEvent->m_lpFile->Close();
                                    lpReceiveEvent->m_State = EnumWaitForTermination;

									if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
									{
										SendFileEndAcknowledgePDU(lpReceiveEvent->m_hFile);
									}
									DeleteReceiveEvent(lpReceiveEvent,TRUE);
                                }
                            }
                        }
                        else
                        {
                            ReportError(lpReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                                        FALSE,SenderID);

                            if(!lpReceiveEvent->m_bFileCompressed)
                            {
                                lpReceiveEvent->m_lpFile->Write(lpNewPDU->GetDataBuffer(),
                                                                lpNewPDU->GetDataSize());
                            }
                            else
                            {
								// We don't handle compressed files
								iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                            }

                            lpReceiveEvent->m_lpFile->Close(FALSE);
                            lpReceiveEvent->m_State = EnumWaitForTermination;

                            DeleteReceiveEvent(lpReceiveEvent,TRUE);
                        }
                    }
                }   //lpReceiveEvent
            } //m_State != EnumWaitForTermination

        if(iErrorCode != iMBFT_OK)
        {
			T120UserID id = bLocalError ? m_LocalMBFTUserID : SenderID;
			ReportError(lpReceiveEvent, iErrorType, iErrorCode, bLocalError, id);

            if(bLocalError)
            {
                ReportReceiverError(lpReceiveEvent,iErrorType,iErrorCode);
            }

            if(m_bOKToLeaveDataChannel)
            {
                if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
                {
                    SendChannelLeavePDU();
                }
                LeaveDataChannel();
            }

            DeleteReceiveEvent(lpReceiveEvent,TRUE);
        }
    }   //wChannelId == m_PrivateMBFTDataChannel

    return(bReturn);
}

int MBFTPrivateReceive::DecompressAndWrite
(
    MBFTReceiveSubEvent    *lpReceiveEvent,
    LPCSTR                  lpBuffer,
    LONG                    BufferLength,
    LPINT                   lpDecompressedSize
)
{
    return(iMBFT_MEMORY_ALLOCATION_ERROR);
}



BOOL MBFTPrivateReceive::OnReceivedFileErrorPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEERRORPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    MBFTReceiveSubEvent TempReceive(lpNewPDU->GetFileHandle(),0,NULL,0,SenderID,FALSE,FALSE,FALSE);
    MBFTReceiveSubEvent *lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
    if(lpReceiveEvent)
    {
        bReturn = TRUE;

        ReportError(lpReceiveEvent,lpNewPDU->GetErrorType(),
                    lpNewPDU->GetErrorCode(),
                    FALSE,SenderID);
    }
    else if(m_bProshareTransfer && m_ProshareSenderID == SenderID &&
            lpNewPDU->GetFileHandle() == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
    {
        ReportError(&TempReceive,lpNewPDU->GetErrorType(),
                    lpNewPDU->GetErrorCode(),
                    FALSE,SenderID);

        bReturn = TRUE;
    }

    return(bReturn);
}

void MBFTPrivateReceive::DoStateMachine(void)
{
    switch(m_State)
    {
    case EnumWaitSendChannelResponsePDU:
        SendChannelResponsePDU();
        break;

    case EnumWaitSendFileAcceptPDU:
        SendFileAcceptPDU();
        break;

    case EnumWaitSendFileRejectPDU:
        SendFileRejectPDU();
        break;

    case EnumWaitSendFileEndAcknowledgePDU:
        SendFileEndAcknowledgePDU();
        break;

    case EnumWaitSendChannelLeavePDU:
        SendChannelLeavePDU();
        break;

    // caseEnumInitializationFailed:
    default:
        break;
    }
}

BOOL MBFTPrivateReceive::OnMCSChannelAdmitIndication
(
    T120ChannelID           wChannelId,
    T120UserID              ManagerID
)
{
    BOOL fHandled = FALSE;
 	//
	// More data channels
	//
	if(m_State == EnumWaitFileOfferPDU)
	{
		if(m_MBFTDataSenderID == ManagerID)
		{
			//
			// Add the data channel to the list
			//
			m_PrivateMBFTDataChannelList.Append(wChannelId);
			T120ChannelID oldChannel = m_PrivateMBFTDataChannel;
			m_PrivateMBFTDataChannel = wChannelId;
			JoinDataChannel();
			m_PrivateMBFTDataChannel = oldChannel;
			fHandled = TRUE;
		}
	}
    else
    if(m_State == EnumWaitAdmitControlChannel)
    {
        if(m_PrivateMBFTControlChannel == wChannelId)
        {
            m_MBFTControlSenderID = ManagerID;

            JoinControlChannel();
            fHandled = TRUE;
        }
    }
    else if(m_State == EnumWaitAdmitDataChannelIndication)
    {
        if (m_PrivateMBFTDataChannelList.Find(wChannelId))
        {
            m_MBFTDataSenderID = ManagerID;

			T120ChannelID oldChannel = m_PrivateMBFTDataChannel;
			m_PrivateMBFTDataChannel = wChannelId;
			JoinDataChannel();
			m_PrivateMBFTDataChannel = oldChannel;
			fHandled = TRUE;
        }
    }

    if (! fHandled)
    {
        UINT chid_uid = MAKELONG(wChannelId, ManagerID);
        m_AdmittedChannelQueue.Append(chid_uid);
    }

    return fHandled;
}

BOOL MBFTPrivateReceive::OnMCSChannelExpelIndication
(
    T120ChannelID           wChannelId,
    Reason                  iReason
)
{
    BOOL bReturn = FALSE;

    if(/*(wChannelId == m_PrivateMBFTControlChannel) ||*/
       m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        TRACERECEIVE(" Channel [%u] disbanded, terminating receive session\n",wChannelId);

        //Added by Atul to fix this problem:
        //If the sender aborts all files, or the send is aborted when the
        //last file is being sent, the sender sends a FileDataPDU with the
        ///AbortFlag set to TRUE and proceeds to disband the channel. However,
        //on account of a MCS bug, the receiver never sees the PDU (sic).
        //Therefore, when we receive a channel expel indication, we check to
        //see if we were receiving a file and post a iMBFT_SENDER_ABORTED if necessary...

        if(m_CurrentReceiveEvent /* && m_bProshareTransfer */ )
        {
            if(m_CurrentReceiveEvent->m_State == EnumWaitFileDataPDU ||
               m_CurrentReceiveEvent->m_State == EnumWaitFileStartPDU)
            {
                TRACE(" Unexpected channel disband encountered, posting SENDER_ABORTED message\n");

                ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                            FALSE,m_ProshareSenderID);

                m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                m_CurrentReceiveEvent->m_State = EnumWaitForTermination;
                DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
            }
        }

        UnInitialize();

        bReturn = TRUE;
    }

    m_AdmittedChannelQueue.RemoveByChannelID(wChannelId);

    return(bReturn);
}


void MBFTPrivateReceive::SendChannelResponsePDU(void)
{
		if(m_PrivateMBFTControlChannel >= MIN_ASNDynamicChannelID &&
			m_PrivateMBFTControlChannel <= MAX_ASNDynamicChannelID)
		{
			T127_PRIVATE_CHANNEL_RESPONSE ChannelJoinResponsePDU;
			ChannelJoinResponsePDU.pduType = T127_PRIVATE_CHANNEL_JOIN_RESPONSE;
			ChannelJoinResponsePDU.ControlChannel = SWAPWORD(m_PrivateMBFTControlChannel - MIN_ASNDynamicChannelID);
			ChannelJoinResponsePDU.Response = (ASNPrivate_Channel_Join_ResponsePDU_result_successful << 5);
            // if the Mode is FALSE we should use ASNinvitation_rejected
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)&ChannelJoinResponsePDU,
                                                 4))
            {
                TRACERECEIVE(" Sent Channel response PDU on [%u]\n",m_MBFTControlSenderID);
                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            TRACE(" Receive: Fatal Encoding Failure\n");
            m_State = EnumInitializationFailed;
            //Encoding failed....
        }
}

BOOL MBFTPrivateReceive::SendFileAcceptPDU
(
    MBFTFILEHANDLE          iFileHandle
)
{
    m_State     =   EnumWaitSendFileAcceptPDU;

    if(iFileHandle)
    {
        m_CurrentAcceptHandle   =   iFileHandle;
    }

    BOOL bReturn = FALSE;

    DBG_SAVE_FILE_LINE
    LPFILEACCEPTPDU lpNewPDU = new FileAcceptPDU(m_CurrentAcceptHandle);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                bReturn = TRUE;
                TRACERECEIVE(" Sent file accept PDU on [%u]\n",m_MBFTControlSenderID);
                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete lpNewPDU;
    }

    return(bReturn);
}

void MBFTPrivateReceive::OnControlNotification
(
    MBFTFILEHANDLE  hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR          lpszDirectory,
    LPCSTR          lpszFileName
)
{
    MBFTReceiveSubEvent * lpReceiveEvent = NULL;
    MBFTFILEHANDLE iFileHandle;
    BOOL bAbortHack =   FALSE;

    if(m_State  !=  EnumWaitChannelDisband && m_State  !=  EnumWaitForTermination)
    {
		MBFTReceiveSubEvent TempReceive(hFile,0,NULL,0,0,FALSE,FALSE,FALSE);

		lpReceiveEvent = m_ReceiveList.FindEquiv(&TempReceive);
        if(lpReceiveEvent)
        {
            iFileHandle = (MBFTFILEHANDLE)lpReceiveEvent->m_hFile;

            if(iControlCommand == FileTransferControlMsg::EnumAcceptFile)
            {
                if(lpReceiveEvent->m_State == EnumWaitUserConfirmation)
                {
                    ::lstrcpynA(lpReceiveEvent->m_szFileDirectory,lpszDirectory,
                             sizeof(lpReceiveEvent->m_szFileDirectory));

                    int Length = ::lstrlenA(lpReceiveEvent->m_szFileDirectory);

                    if(Length >= 3)
                    {
                    	PCHAR pch = SzFindLastCh(lpReceiveEvent->m_szFileDirectory, '\\');
                    	if ('\0' == *(pch+1))
                        {
                            lpReceiveEvent->m_szFileDirectory[Length - 1] = '\0';
                        }
                    }

                    if (::lstrlenA(lpszFileName))
                    {
                        ::lstrcpynA(lpReceiveEvent->m_szFileName, lpszFileName, sizeof(lpReceiveEvent->m_szFileName));
                    }

                    TRACERECEIVE(" File accept notification for [%u]\n",iFileHandle);
                    lpReceiveEvent->m_UserAccepted = TRUE;
                    m_CurrentReceiveEvent = lpReceiveEvent;

                    if(m_JoinedToDataChannel)
                    {
                        SendFileAcceptPDU(iFileHandle);
                        lpReceiveEvent->m_State = EnumWaitFileStartPDU;
                    }
                    else
                    {
                        m_State = EnumWaitRejoinDataChannel;
                        //m_CurrentReceiveEvent = lpReceiveEvent;
                        JoinDataChannel();
                    }
                }
            }
            else if(iControlCommand == FileTransferControlMsg::EnumRejectFile)
            {
                if((lpReceiveEvent->m_State == EnumWaitUserConfirmation) ||
                   (lpReceiveEvent->m_bIsBroadcast && lpReceiveEvent->m_State == EnumWaitFileStartPDU))
                {
                    if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                    {
                        iFileHandle = LOWORD(_iMBFT_PROSHARE_ALL_FILES);
                    }

                    TRACERECEIVE(" Rejecting file [%u]\n",lpReceiveEvent->m_hFile);

                    if(m_bOKToLeaveDataChannel)
                    {
                        LeaveDataChannel();
                    }

                    SendFileRejectPDU(iFileHandle);

                    if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                    {
                        TerminateReceiveSession();
                    }
                    else
                    {
                        DeleteReceiveEvent(lpReceiveEvent,FALSE);
                    }
                }
            }
            else if(iControlCommand == FileTransferControlMsg::EnumAbortFile)
            {
                if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                {
                    iFileHandle = LOWORD(_iMBFT_PROSHARE_ALL_FILES);
                }

                if((lpReceiveEvent->m_State == EnumWaitFileDataPDU) ||
                   (lpReceiveEvent->m_State == EnumWaitFileStartPDU) ||
                   (hFile == _iMBFT_PROSHARE_ALL_FILES))
                {
                    TRACERECEIVE(" Aborting file [%u]\n",iFileHandle);
                    if(lpReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                    {
                        TRACERECEIVE(" Rejecting file [%u]\n",lpReceiveEvent->m_hFile);
                        SendFileRejectPDU(iFileHandle);
                    }
                    else
                    {
                        if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                        {
                            //If the AbortHack flag is set, we are on a sticky wicket.
                            //We have already aborted the current file and are waiting
                            //for another file offer. Therefore we don't inform the sender
                            //about this one...
                            if(!bAbortHack)
                            {
                                ReportReceiverError(lpReceiveEvent,
                                                    MBFT_PERMANENT_ERROR,
                                                    iMBFT_RECEIVER_ABORTED,
                                                    iFileHandle);
                            }
                        }
                        else
                        {
                            ReportReceiverError(lpReceiveEvent,
                                                MBFT_PERMANENT_ERROR,
                                                iMBFT_RECEIVER_ABORTED);
                        }
                    }

                    ReportError(lpReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_RECEIVER_ABORTED);

                    if(m_bOKToLeaveDataChannel)
                    {
                        if(lpReceiveEvent->m_bEOFAcknowledge && m_JoinedToDataChannel)
                        {
                            SendChannelLeavePDU();
                        }
                        LeaveDataChannel();
                    }

                    if(hFile != _iMBFT_PROSHARE_ALL_FILES)
                    {
                        DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);

                        lpReceiveEvent->m_lpFile->Close(FALSE);
    //                    lpReceiveEvent->m_lpFile->DeleteFile();
                        DeleteReceiveEvent(lpReceiveEvent,TRUE);
                    }
                    else if(m_CurrentReceiveEvent)
                    {
                        m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
    //                    m_CurrentReceiveEvent->m_lpFile->DeleteFile();
                        DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                    }
                }

                if(hFile == _iMBFT_PROSHARE_ALL_FILES)
                {
                    DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
                    DeleteNotificationMessages(iMBFT_FILE_OFFER);
                    TerminateReceiveSession();
                }
            }
        }
    }
}

void MBFTPrivateReceive::DeleteNotificationMessages
(
    MBFT_NOTIFICATION       iNotificationType
)
{
#if 0 // lonchanc: no way we can delete notify messages which are already in the queue
    MBFTMsg * lpNewMessage;
    CMsgQueue *pNotifyMsgList = m_lpParentEngine->GetNotificationMsgList();
    CMsgQueue DeleteList;

    pNotifyMsgList->Reset();
    while (NULL != (lpNewMessage = pNotifyMsgList->Iterate()))
    {
        switch (lpNewMessage->GetMsgType())
        {
        case EnumFileTransmitMsg:
            {
                FileTransmitMsg *lpFileMsg = (FileTransmitMsg *)lpNewMessage;
                if(lpFileMsg->m_EventHandle == m_EventHandle)
                {
                    if(iNotificationType == lpFileMsg->m_TransmitStatus)
                    {
                        TRACERECEIVE(" NUKING Notification [%x] from Event [%ld], Handle: [%ld] FileSize: [%ld], Bytes Xfered[%ld]\n",
                                     lpFileMsg->m_TransmitStatus,lpFileMsg->m_EventHandle,
                                     lpFileMsg->m_hFile,
                                     lpFileMsg->m_FileSize,
                                     lpFileMsg->m_BytesTransmitted);
                        DeleteList.Append(lpNewMessage);
                    }
                }
            }
            break;

        case EnumFileOfferNotifyMsg:
            {
                FileOfferNotifyMsg *lpFileOfferMsg = (FileOfferNotifyMsg *)lpNewMessage;
                if(lpFileOfferMsg->m_EventHandle == m_EventHandle)
                {
                    if(iNotificationType == iMBFT_FILE_OFFER)
                    {
                        TRACERECEIVE(" NUKING File Offer Notification for [%s], Event: [%ld], Size: [%ld], Handle [%Fp]\n",
                                     lpFileOfferMsg->m_szFileName,lpFileOfferMsg->m_EventHandle,
                                     lpFileOfferMsg->m_FileSize,lpFileOfferMsg->m_hFile);
                        DeleteList.Append(lpNewMessage);
                    }
                }
            }
            break;

        default:
            ASSERT(0);
            break;
        } // switch
    } //for loop

    // remove handled messages
    pNotifyMsgList->DeleteSubset(&DeleteList);
#endif // 0
}

void MBFTPrivateReceive::SendFileRejectPDU
(
    MBFTFILEHANDLE      iFileHandle
)
{
    if(m_State !=  EnumWaitSendFileRejectPDU)
    {
        m_PreviousRejectState     =   m_State;
        m_State                   =   EnumWaitSendFileRejectPDU;
    }

    if(iFileHandle)
    {
        m_CurrentRejectHandle   =   iFileHandle;
    }

    FileRejectPDU * lpNewPDU = NULL;

    DBG_SAVE_FILE_LINE
    lpNewPDU = new FileRejectPDU(m_CurrentRejectHandle);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_MBFTControlSenderID,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                m_State = (m_PreviousRejectState != EnumWaitChannelDisband) ?
                          EnumWaitFileOfferPDU : EnumWaitChannelDisband;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }
    }

    delete lpNewPDU;
}

void MBFTPrivateReceive::SendFileEndAcknowledgePDU
(
    MBFTFILEHANDLE      iFileHandle
)
{
    if(iFileHandle)
    {
        m_CurrentFileEndHandle =   LOWORD(iFileHandle);
    }

    m_State =  EnumWaitSendFileEndAcknowledgePDU;

    DBG_SAVE_FILE_LINE
    FileEndAcknowledgeStruct * lpNewStruct  =   new FileEndAcknowledgeStruct;

    lpNewStruct->m_FileHandle   =  m_CurrentFileEndHandle;

    DBG_SAVE_FILE_LINE
    NonStandardPDU * lpNewPDU = new NonStandardPDU(NULL,
                                                   PROSHARE_FILE_END_STRING,
                                                   lpNewStruct,
                                                   sizeof(FileEndAcknowledgeStruct));
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                TRACERECEIVE( " Sent FileEndAcknowledgePDU for [%u] on [%u]\n",m_CurrentFileEndHandle,m_PrivateMBFTControlChannel);

                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete  lpNewPDU;
    }

    delete  lpNewStruct;
}

void MBFTPrivateReceive::SendChannelLeavePDU(void)
{
    m_State =  EnumWaitSendChannelLeavePDU;

    DBG_SAVE_FILE_LINE
    ChannelLeaveStruct * lpNewStruct  =   new ChannelLeaveStruct;

    lpNewStruct->m_ChannelID   =    m_PrivateMBFTDataChannel;
    lpNewStruct->m_ErrorCode   =    iMBFT_RECEIVER_ABORTED;

    DBG_SAVE_FILE_LINE
    NonStandardPDU * lpNewPDU = new NonStandardPDU(NULL,
                                                   PROSHARE_CHANNEL_LEAVE_STRING,
                                                   lpNewStruct,
                                                   sizeof(ChannelLeaveStruct));
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                 APPLET_HIGH_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                TRACERECEIVE( " Sent ChannelLeavePDU for [%u] on [%u]\n",m_PrivateMBFTDataChannel,m_PrivateMBFTControlChannel);

                m_State = EnumWaitFileOfferPDU;
            }
        }
        else
        {
            ReportError(m_CurrentReceiveEvent,MBFT_PERMANENT_ERROR,iMBFT_ASN1_ENCODING_ERROR);
        }

        delete  lpNewPDU;
    }

    delete  lpNewStruct;
}

void MBFTPrivateReceive::LeaveDataChannel(void)
{
    if(m_JoinedToDataChannel)
    {
        if(m_lpParentEngine->MCSChannelLeaveRequest(m_PrivateMBFTDataChannel))
        {
            TRACERECEIVE(" Left data channel\n");
            m_JoinedToDataChannel = FALSE;
        }
    }
}

void MBFTPrivateReceive::TerminateReceiveSession(void)
{
    //if(m_lpParentEngine->MCSChannelLeaveRequest(m_PrivateMBFTControlChannel))
    //{
        //TRACERECEIVE(" Left control channel\n");
    //}

    //Keep the clients happy....

    if(!m_bEventEndPosted)
    {
        DBG_SAVE_FILE_LINE
        m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
        m_bEventEndPosted   =   TRUE;
    }

    LeaveDataChannel();

    m_State     =   EnumWaitChannelDisband;

    //UnInitialize();
}


void MBFTPrivateReceive::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(m_bProshareTransfer)
    {
        if(m_ProshareSenderID == lpPeerData->GetUserID())
        {
            if(m_CurrentReceiveEvent)
            {
                if((m_CurrentReceiveEvent->m_State == EnumWaitFileDataPDU) ||
                  (m_CurrentReceiveEvent->m_State == EnumWaitFileStartPDU))
                {
                    ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                                FALSE,m_ProshareSenderID);

                    m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                    m_CurrentReceiveEvent->m_State = EnumWaitForTermination;
                    DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                }
            }

            DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
            DeleteNotificationMessages(iMBFT_FILE_OFFER);
            TerminateReceiveSession();
        }
    }
}




#ifdef USE_BROADCAST_RECEIVE
MBFTBroadcastReceive::MBFTBroadcastReceive
(
    LPMBFTENGINE            lpParentEngine,
    MBFTEVENTHANDLE         EventHandle,
    T120ChannelID           wControlChannel,
    T120ChannelID           wDataChannel,
    T120UserID              SenderID,
    MBFTFILEHANDLE          FileHandle
)
:
    MBFTPrivateReceive(lpParentEngine, EventHandle, wControlChannel, wDataChannel),
    m_SenderID(SenderID),
    m_FileHandle(FileHandle)
{
    m_MBFTControlSenderID = m_SenderID;
    m_State = MBFTPrivateReceive::EnumWaitFileOfferPDU;
}

BOOL MBFTBroadcastReceive::OnReceivedFileOfferPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
	T120NodeID				NodeID,
    LPFILEOFFERPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileOfferPDU)
    {
        bReturn = (wChannelId == m_PrivateMBFTControlChannel) &&
                  (lpNewPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            MBFTPrivateReceive::OnReceivedFileOfferPDU(wChannelId,
                                                       iPriority,
                                                       SenderID,
													   NodeID,
                                                       lpNewPDU,
                                                       IsUniformSendData);

            m_CurrentReceiveEvent = m_ReceiveList.PeekHead();
            if(m_CurrentReceiveEvent)
            {
                ::lstrcpyA(m_CurrentReceiveEvent->m_szFileName,lpNewPDU->GetFileName());
                if(!lpNewPDU->GetAcknowledge())
                {
                    m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileStartPDU;
                }
                else
                {
                    m_State  =  m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitUserConfirmation;
                }
            }
            else
            {
                UnInitialize();
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;
            }
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelId,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitJoinDataChannel &&
    	m_PrivateMBFTDataChannelList.Find(wChannelId))
    {
        bReturn                 = TRUE;
        m_JoinedToDataChannel   = TRUE;

        if(bSuccess && m_CurrentReceiveEvent)
        {
            m_State = MBFTPrivateReceive::EnumWaitSendFileAcceptPDU;
        }
        else
        {
            //m_State  =   MBFTPrivateReceive::EnumWaitForTermination;

            LeaveDataChannel();
            UnInitialize();
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnReceivedFileStartPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILESTARTPDU          lpFileStartPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileStartPDU && m_CurrentReceiveEvent)
    {
        bReturn = m_PrivateMBFTDataChannelList.Find(wChannelId) &&
                  (lpFileStartPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            if(!lstrlen(m_CurrentReceiveEvent->m_szFileName))
            {
                lstrcpy(m_CurrentReceiveEvent->m_szFileName,lpFileStartPDU->GetFileName());
            }

            if(!lstrlen(m_CurrentReceiveEvent->m_szFileDirectory))
            {
                lstrcpy(m_CurrentReceiveEvent->m_szFileDirectory,m_CurrentReceiveEvent->m_lpFile->GetTempDirectory());
            }

            MBFTPrivateReceive::OnReceivedFileStartPDU(wChannelId,
                                                       iPriority,
                                                       SenderID,
                                                       lpFileStartPDU,
                                                       IsUniformSendData);

            //Assumption: m_CurrentReceiveEvent == NULL indicates an error.

            if(!m_CurrentReceiveEvent || lpFileStartPDU->GetIsEOF())
            {
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;
                UnInitialize();
            }
            else
            {
                m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileDataPDU;
            }
        }
    }

    return(bReturn);
}

BOOL MBFTBroadcastReceive::OnReceivedFileDataPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEDATAPDU           lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == MBFTPrivateReceive::EnumWaitFileDataPDU && m_CurrentReceiveEvent)
    {
        bReturn = m_PrivateMBFTDataChannelList.Find(wChannelId) &&
                  (lpNewPDU->GetFileHandle() ==  m_FileHandle) &&
                  (SenderID == m_SenderID);

        if(bReturn)
        {
            MBFTPrivateReceive::OnReceivedFileDataPDU(wChannelId,
                                                      iPriority,
                                                      SenderID,
                                                      lpNewPDU,
                                                      IsUniformSendData);

            if(!m_CurrentReceiveEvent || lpNewPDU->GetIsEOF())
            {
                //m_State = MBFTPrivateReceive::EnumWaitForTermination;

                //LeaveDataChannel();

                UnInitialize();
            }
        }
    }

    return(bReturn);
}

void MBFTBroadcastReceive::UnInitialize
(
    BOOL        bIsShutDown
)
{
    if(m_State != EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        if(!bIsShutDown)
        {
            DBG_SAVE_FILE_LINE
            m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));
            if(!m_bEventEndPosted)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
                m_bEventEndPosted   =   TRUE;
            }
        }
    }
}

void MBFTBroadcastReceive::DoStateMachine(void)
{
    if(m_State == MBFTPrivateReceive::EnumWaitSendFileAcceptPDU)
    {
        if(m_CurrentReceiveEvent)
        {
            if(SendFileAcceptPDU(m_FileHandle))
            {
                m_State = m_CurrentReceiveEvent->m_State = MBFTPrivateReceive::EnumWaitFileStartPDU;
            }
        }
        else
        {
            //m_State = MBFTPrivateReceive::EnumWaitForTermination;
            UnInitialize();
        }
    }
}

void MBFTBroadcastReceive::OnControlNotification
(
    MBFTFILEHANDLE          hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR                  lpszDirectory,
    LPCSTR                  lpszFileName
)
{
    if(m_State != MBFTPrivateReceive::EnumWaitForTermination)
    {
        if(m_CurrentReceiveEvent)
        {
            MBFTFILEHANDLE iFileHandle = (MBFTFILEHANDLE) m_CurrentReceiveEvent->m_hFile;

            if(iControlCommand == FileTransferControlMsg::EnumAcceptFile)
            {
                if(m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                {
                    ::lstrcpynA(m_CurrentReceiveEvent->m_szFileDirectory,lpszDirectory,
                             sizeof(m_CurrentReceiveEvent->m_szFileDirectory));

                    int Length = ::lstrlenA(m_CurrentReceiveEvent->m_szFileDirectory);

                    if(Length >= 3)
                    {
                    	PCHAR pch = SzFindLastCh(m_CurrentReceiveEvent->m_szFileDirectory, '\\');
                    	if ('\0' == *(pch+1))
                        {
                            m_CurrentReceiveEvent->m_szFileDirectory[Length - 1] = '\0';
                        }
                    }

                    if (::lstrlenA(lpszFileName))
                    {
                        ::lstrcpynA(m_CurrentReceiveEvent->m_szFileName, lpszFileName, sizeof(m_CurrentReceiveEvent->m_szFileName));
                    }

                    TRACERECEIVE(" File accept notification for [%u]\n",iFileHandle);

                    m_CurrentReceiveEvent->m_UserAccepted = TRUE;

                    JoinDataChannel();

                    m_State     =   MBFTPrivateReceive::EnumWaitJoinDataChannel;
                }
            }
#if 0
            else if(iControlCommand == FileTransferControlMsg::EnumRejectFile)
            {
                if((m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation))
                {
                    LeaveDataChannel();
                    SendFileRejectPDU(iFileHandle);
                    DeleteReceiveEvent(m_CurrentReceiveEvent,FALSE);
                    UnInitialize();
                }
            }
#endif
            else if((iControlCommand == FileTransferControlMsg::EnumAbortFile)
                    || (iControlCommand == FileTransferControlMsg::EnumRejectFile))
            {
                if((m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitFileDataPDU) ||
                   (m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitFileStartPDU) ||
                   (m_CurrentReceiveEvent->m_State == EnumWaitUserConfirmation))
                {
                    TRACERECEIVE(" Aborting file [%u]\n",iFileHandle);

                    if(m_CurrentReceiveEvent->m_State == MBFTPrivateReceive::EnumWaitUserConfirmation)
                    {
                        //LeaveDataChannel();

                        SendFileRejectPDU(iFileHandle);

                        //DeleteReceiveEvent(m_CurrentReceiveEvent,FALSE);
                        //UnInitialize();
                    }
                    else
                    {
                        ReportReceiverError(m_CurrentReceiveEvent,
                                            MBFT_PERMANENT_ERROR,
                                            iMBFT_RECEIVER_ABORTED);
                    }

                    ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_RECEIVER_ABORTED);

                    LeaveDataChannel();

                    DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);
                    m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                    DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
                    UnInitialize();
                 }
            }
        }
    }
}

void MBFTBroadcastReceive::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(lpPeerData->GetUserID() == m_SenderID)
    {
        if(m_CurrentReceiveEvent)
        {
            if(m_State == MBFTPrivateReceive::EnumWaitFileStartPDU ||
               m_State == MBFTPrivateReceive::EnumWaitFileDataPDU)
            {
                ReportError(m_CurrentReceiveEvent,MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,
                            FALSE,m_ProshareSenderID);

                m_CurrentReceiveEvent->m_lpFile->Close(FALSE);
                DeleteReceiveEvent(m_CurrentReceiveEvent,TRUE);
            }

            DeleteNotificationMessages(iMBFT_FILE_RECEIVE_PROGRESS);

            UnInitialize();
        }
    }
}

#endif	// USE_BROADCAST_RECEIVE


MBFTReceiveSubEvent * CRecvSubEventList::FindEquiv
(
    MBFTReceiveSubEvent         *pEvent
)
{
    MBFTReceiveSubEvent *p;
    Reset();
    while (NULL != (p = Iterate()))
    {
        if (p->IsEqual(pEvent))
        {
            return p;
        }
    }
    return NULL;
}

void CRecvSubEventList::Delete
(
    MBFTReceiveSubEvent         *pEvent
)
{
    if (Remove(pEvent))
    {
        delete pEvent;
    }
}

void CRecvSubEventList::DeleteAll(void)
{
    MBFTReceiveSubEvent *p;
    while (NULL != (p = Get()))
    {
        delete p;
    }
}



BOOL CChannelUidQueue::RemoveByChannelID(T120ChannelID nChannelID)
{
    UINT_PTR chid_uid;
    Reset();
    while (0 != (chid_uid = Iterate()))
    {
        if (LOWORD(chid_uid) == nChannelID)
        {
            return Remove(chid_uid);
        }
    }
    return FALSE;
}

UINT_PTR CChannelUidQueue::FindByChannelID(T120ChannelID nChannelID)
{
    UINT_PTR chid_uid;
    Reset();
    while (0 != (chid_uid = Iterate()))
    {
        if (LOWORD(chid_uid) == nChannelID)
        {
            return chid_uid;
        }
   }
   return 0;
}

LPTSTR GetRootDirPath(LPTSTR pszDirPath, LPTSTR pszRootDirPath, int nSize)
{
	::lstrcpy(pszRootDirPath, pszDirPath);
	if (pszRootDirPath[0] == TEXT('\\'))
	{
		if (pszRootDirPath[1] != TEXT('\\'))
		{
			return NULL;
		}

		// the path starts with two '\\'
		BOOL fFirstSlash = FALSE;
		LPTSTR psz = pszRootDirPath + 2;
		while (*psz && !(fFirstSlash && *psz == TEXT('\\')))
		{
			if (*psz == TEXT('\\'))
			{
				fFirstSlash = TRUE;
			}
			psz = ::CharNext(psz);
		}

		*psz++ = '\\';
		*psz = '\0';
		return pszRootDirPath;
	}

	// the first char is not a '\\', it could be driver letter followed by ':'
	if (pszRootDirPath[1] == TEXT(':'))
	{
		pszRootDirPath[2] = TEXT('\\');
		pszRootDirPath[3] = TEXT('\0');
		return pszRootDirPath;
	}

	// the second char is not a ':' , must be a sub directory
	return NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\messages.hpp ===
#ifndef __MESSAGES_HPP__
#define __MESSAGES_HPP__


enum
{
    MBFTMSG_CREATE_ENGINE               = WM_APP +  1,
    MBFTMSG_DELETE_ENGINE               = WM_APP +  2,
    MBFTMSG_HEART_BEAT                  = WM_APP +  3,
    MBFTMSG_BASIC                       = WM_APP +  4,
};


typedef enum
{
    EnumMCSChannelAdmitIndicationMsg,
    EnumMCSChannelExpelIndicationMsg,
    EnumMCSChannelJoinConfirmMsg,
    EnumMCSChannelConveneConfirmMsg,
    EnumMCSSendDataIndicationMsg,
    EnumGenericMBFTPDUMsg,
    EnumCreateSessionMsg,
    EnumDeleteSessionMsg,
    EnumPeerDeletedMsg,
    EnumSubmitFileSendMsg,
    EnumFileOfferNotifyMsg,
    EnumFileTransferControlMsg,
    EnumFileTransmitMsg,
    EnumFileErrorMsg,
    EnumPeerMsg,
    EnumInitUnInitNotifyMsg,
    EnumFileEventEndNotifyMsg,
}
    MBFT_MSG_TYPE;


class MBFTMsg
{
public:

    MBFTMsg(MBFT_MSG_TYPE eMsgType) : m_eMsgType(eMsgType) { }
    virtual ~MBFTMsg(void);

    MBFT_MSG_TYPE GetMsgType(void) { return m_eMsgType; }

protected:

    MBFT_MSG_TYPE     m_eMsgType;
};


class MCSChannelAdmitIndicationMsg : public MBFTMsg
{
public:

    MCSChannelAdmitIndicationMsg(T120ChannelID wChannelId, T120UserID ManagerID) :
        MBFTMsg(EnumMCSChannelAdmitIndicationMsg),
        m_wChannelId(wChannelId),
        m_ManagerID(ManagerID)
    {
    }

    T120ChannelID       m_wChannelId;
    T120UserID          m_ManagerID;
};

class MCSChannelExpelIndicationMsg : public MBFTMsg
{
public:

    MCSChannelExpelIndicationMsg(T120ChannelID wChannelId, Reason iReason) :
        MBFTMsg(EnumMCSChannelExpelIndicationMsg),
        m_wChannelId(wChannelId),
        m_iReason(iReason)
    {
    }

    T120ChannelID       m_wChannelId;
    Reason              m_iReason;
};

class  MCSChannelJoinConfirmMsg : public MBFTMsg
{
public:

    MCSChannelJoinConfirmMsg(T120ChannelID wChannelId, BOOL bSuccess) :
        MBFTMsg(EnumMCSChannelJoinConfirmMsg),
        m_wChannelId(wChannelId),
        m_bSuccess(bSuccess)
    {
    }

    T120ChannelID       m_wChannelId;
    BOOL                m_bSuccess;
};

class MCSChannelConveneConfirmMsg : public MBFTMsg
{
public:

    MCSChannelConveneConfirmMsg(T120ChannelID wChannelId, BOOL bSuccess) :
        MBFTMsg(EnumMCSChannelConveneConfirmMsg),
        m_wChannelId(wChannelId),
        m_bSuccess(bSuccess)
    {
    }

    T120ChannelID       m_wChannelId;
    BOOL                m_bSuccess;
};

class MCSSendDataIndicationMsg : public MBFTMsg
{
public:

    MCSSendDataIndicationMsg(T120ChannelID wChannelId,
                             T120Priority iPriority,
                             T120UserID SenderID,
                             LPBYTE lpBuffer,
                             ULONG ulDataLength,
                             BOOL IsUniformSendData);

    T120ChannelID       m_wChannelId;
    T120Priority        m_iPriority;
    T120UserID          m_SenderID;
    LPBYTE              m_lpBuffer;
    ULONG               m_ulDataLength;
    BOOL                m_IsUniformSendData;
};

class MBFTPDUMsg : public MBFTMsg
{
public:

    MBFTPDUMsg(T120ChannelID wChannelId,
               T120Priority iPriority,
               T120UserID SenderID,
               LPGENERICPDU lpNewPDU,
               BOOL IsUniformSendData,
               MBFTPDUType PDUType,
               LPSTR lpDecodedBuffer);

    ~MBFTPDUMsg(void);

    T120ChannelID       m_wChannelId;
    T120Priority        m_iPriority;
    T120UserID          m_SenderID;
    LPGENERICPDU        m_lpNewPDU;
    BOOL                m_IsUniformSendData;
    MBFTPDUType         m_PDUType;
    LPSTR               m_lpDecodedBuffer;
};

class CreateSessionMsg : public MBFTMsg
{
public:

    CreateSessionMsg(MBFT_SESSION_TYPE iSessionType,
                     MBFTEVENTHANDLE EventHandle,
                     T120SessionID SessionID = 0,
                     T120ChannelID wControlChannel = 0,
                     T120ChannelID wDataChannel = 0,
                     T120UserID SenderID = 0,
                     MBFTFILEHANDLE FileHandle = 0);

    MBFT_SESSION_TYPE   m_iSessionType;
    MBFTEVENTHANDLE     m_EventHandle;
    T120SessionID       m_SessionID;
    T120ChannelID       m_ControlChannel;
    T120ChannelID       m_DataChannel;
    T120UserID          m_SenderID;
    MBFTFILEHANDLE      m_FileHandle;
};

class MBFTSession;
class DeleteSessionMsg : public MBFTMsg
{
public:

    DeleteSessionMsg(MBFTSession * lpDeleteSession) :
        MBFTMsg(EnumDeleteSessionMsg),
        m_lpDeleteSession(lpDeleteSession)
    {
    }

    MBFTSession * m_lpDeleteSession;
};

class CPeerData;
class PeerDeletedMsg : public MBFTMsg
{
public:

    PeerDeletedMsg(CPeerData * lpPeerData) :
        MBFTMsg(EnumPeerDeletedMsg),
        m_lpPeerData(lpPeerData)
    {
    }
    ~PeerDeletedMsg(void);

    CPeerData * m_lpPeerData;
};


class SubmitFileSendMsg  :  public MBFTMsg
{
public:

    SubmitFileSendMsg::SubmitFileSendMsg(T120UserID	uidReceiver,
										 T120NodeID nidReceiver,
										 LPCSTR pszFilePath,
                                         MBFTFILEHANDLE nFileHandle,
                                         MBFTEVENTHANDLE EventHandle,
                                         BOOL bCompressFiles);

    ~SubmitFileSendMsg(void);

	T120UserID		m_nUserID;
	T120NodeID		m_nNodeID;
    LPSTR           m_pszFilePath;
    MBFTFILEHANDLE  m_nFileHandle;
    MBFTEVENTHANDLE m_EventHandle;
    BOOL            m_bCompressFiles;
};

class FileOfferNotifyMsg : public MBFTMsg
{
public:

    FileOfferNotifyMsg(MBFTEVENTHANDLE EventHandle,
                       T120UserID SenderID,
					   T120NodeID NodeID,
                       MBFTFILEHANDLE hFile,
                       LPCSTR lpszFilename,
                       ULONG FileSize,
                       time_t FileDateTime,
                       BOOL bAckNeeded);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    ULONG               m_FileSize;
    time_t              m_FileDateTime;
    BOOL                m_bAckNeeded;
    T120UserID          m_SenderID;
	T120NodeID          m_NodeID;
    char                m_szFileName[_MAX_PATH];
};

class FileTransferControlMsg :  public MBFTMsg
{
public:

    enum FileTransferControl
    {
        EnumAcceptFile,
        EnumRejectFile,
        EnumAbortFile,
        EnumConductorAbortFile
    };

    FileTransferControlMsg(MBFTEVENTHANDLE EventHandle,
                           MBFTFILEHANDLE hFile,
                           LPCSTR lpszDirectory,
                           LPCSTR lpszFileName,
                           FileTransferControl iControlCommand);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    FileTransferControl m_ControlCommand;
    char                m_szDirectory[_MAX_PATH];
    char                m_szFileName[_MAX_FNAME];
};

class FileTransmitMsg :  public MBFTMsg
{
public:

    FileTransmitMsg(MBFTEVENTHANDLE EventHandle,
                    MBFTFILEHANDLE hFile,
                    ULONG FileSize,
                    ULONG BytesTransmitted,
                    int      iTransmitStatus,
                    T120UserID   iUserID = 0,
                    BOOL     bIsBroadcastEvent = FALSE);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    ULONG               m_FileSize;
    ULONG               m_BytesTransmitted;
    T120UserID          m_UserID;
    int                 m_TransmitStatus;
    BOOL                m_bIsBroadcastEvent;
};

class FileErrorMsg :   public MBFTMsg
{
public:

    FileErrorMsg(MBFTEVENTHANDLE EventHandle,
                 MBFTFILEHANDLE hFile,
                 int  iErrorType,
                 int  iErrorCode,
                 BOOL bIsLocalError,
                 T120UserID iUserID = 0,
                 BOOL   bIsBroadcastEvent = FALSE,
				 const char* pFileName = NULL,
				 ULONG nFileSize = 0);

    MBFTEVENTHANDLE     m_EventHandle;
    MBFTFILEHANDLE      m_hFile;
    int                 m_ErrorCode;
    int                 m_ErrorType;
    BOOL                m_bIsLocalError;
    T120UserID          m_UserID;
    BOOL                m_bIsBroadcastEvent;
	MBFT_RECEIVE_FILE_INFO m_stFileInfo;
};

class PeerMsg    :  public MBFTMsg
{
public:

    enum    PeerChange
    {
        EnumPeerAdded,
        EnumPeerRemoved
    };

    PeerMsg(T120NodeID NodeID,
            T120UserID MBFTPeerID,
            BOOL bIsLocalPeer,
            BOOL IsProsharePeer,
            LPCSTR   lpszAppKey,
            BOOL bPeerAdded,
            T120SessionID MBFTSessionID);

    T120NodeID          m_NodeID;
    T120UserID          m_MBFTPeerID;
    BOOL                m_bIsLocalPeer;
    BOOL                m_bIsProsharePeer;
    T120SessionID       m_MBFTSessionID;
    BOOL                m_bPeerAdded;
    char                m_szAppKey[MAX_APP_KEY_SIZE];
};


enum  InitUnInitNotifyType
{
    EnumInitFailed,
    EnumUnInitComplete,
    EnumInvoluntaryUnInit
};

class InitUnInitNotifyMsg   : public MBFTMsg
{
public:

    InitUnInitNotifyMsg(InitUnInitNotifyType iNotifyMessage) :
        MBFTMsg(EnumInitUnInitNotifyMsg),
        m_iNotifyMessage(iNotifyMessage)
    {
    }

    InitUnInitNotifyType    m_iNotifyMessage;
};

class FileEventEndNotifyMsg    :   public MBFTMsg
{
public:

    FileEventEndNotifyMsg(MBFTEVENTHANDLE EventHandle) :
        MBFTMsg(EnumFileEventEndNotifyMsg),
        m_EventHandle(EventHandle)
    {
    }

    MBFTEVENTHANDLE  m_EventHandle;
};

#endif  //__MESSAGES_HPP__


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftsend.hpp ===
#ifndef __MBFTSEND_HPP__
#define __MBFTSEND_HPP__


class CMBFTFile;

class MBFTPrivateSend : public MBFTSession
{
private:
    
    enum  MBFTPrivateSendState
    {
        EnumIdleInitialized,
        EnumInitializationFailed,
        EnumIdleNotInitialized,
        EnumWaitConveneControlChannel,
        EnumWaitConveneDataChannel,
        EnumWaitRequestControlConvene,
        EnumWaitRequestDataConvene,
        EnumWaitJoinControlChannel,
        EnumWaitRequestJoinControl,
        EnumFileSendPending,
        EnumSendNonStandardPDU,
        EnumSendFileOfferPDU,
        EnumSendFileStartPDU,
        EnumSendFileDataPDU,
        EnumWaitJoinDataChannel,
        EnumWaitRequestJoinData,
        EnumWaitSendChannelInvitePDU,
        EnumWaitChannelResponsePDU,    
        EnumWaitFileAcceptPDU,
        EnumWaitFileEndAcknowledgePDU,
        EnumTerminateCurrentSend,
        EnumWaitForTermination,
        EnumHackWaitFileOffer
    };
    
    CMBFTFile      *m_lpFile;    
    T120ChannelID   m_MBFTChannelID;
    T120ChannelID   m_PrivateMBFTControlChannel;
    T120ChannelID   m_PrivateMBFTDataChannel;    
    T120UserID     *m_lpUserArray;
    T120UserID     *m_lpAcceptedUsersArray;
    T120NodeID     *m_lpNodeArray;
    ULONG           m_iUserCount;
    ULONG           m_AcceptedIndex;
    unsigned        m_MaxDataLength;
    BOOL            m_SentFileStartPDU;
    DWORD           m_TimeOutValue;

    LPSTR           m_pszCurrentFilePath;
    MBFTFILEHANDLE  m_CurrentFileHandle;
    time_t          m_CurrentDateTime;
    LONG            m_CurrentFileSize;

    MBFTPrivateSendState   m_State;    
    BOOL            m_bProshareTransfer;
    BOOL            m_bEOFAcknowledge;
    BOOL            m_bCompressFiles;
    ULONG           m_LastUserCount;
    ULONG           m_ResponseCount;   
    ULONG           m_AcceptCount;
    ULONG           m_RejectCount;
    ULONG           m_AbortedCount;
    ULONG           m_AcknowledgeCount;
    LONG            m_lTotalBytesRead;
    LPSTR           m_lpDataBuffer;

    BOOL            m_bAbortAllFiles;
    BOOL            m_bSendingFile;
    BOOL            m_bAbortFileSend;
    BOOL            m_bUnInitializing;
    BOOL            m_bSentFileOfferPDU;
    BOOL            m_bOKToDisbandChannel;
    LPVOID          m_lpV42bisPointer;
    BOOL            m_bFlushv42Compression;
    BOOL            m_bEventEndPosted;
    
    int             m_v42bisP1;
    int             m_v42bisP2;
        
    void    ConveneControlChannel(void);
    void    ConveneDataChannel(void);
    
    void    JoinControlChannel(void);
    void    AdmitControlChannel(void);
    void    AdmitDataChannel(void);
    
    void    SendChannelInvitePDU(void);
    void    SendFileOfferPDU(void);
    void    SendFileStartPDU(void);
    void    SendFileDataPDU(void);
    void    SendNextFile(void);
    void    AbortAllFiles(void);
    void    AbortCurrentFile(void);
    
    void    RemoveFileFromList(MBFTFILEHANDLE);
    BOOL    RemoveUserFromList(T120UserID);
    BOOL    RemoveUserFromAcceptedList(T120UserID);
    void    SendNotificationMessage(int iProgress, T120UserID uid = 0, MBFTFILEHANDLE h = 0);
    void    ReportError(int iErrorType,int iTransmitError,
                  BOOL bIsLocalError = TRUE, T120UserID uidSender = 0, MBFTFILEHANDLE h = 0);
    void    ReportSenderError(int iErrorType,int iErrorCode, MBFTFILEHANDLE h = 0);
    void    TerminateCurrentSend(void);
    void    TerminateSendSession(void);
    LPSTR   StripFilePath(LPSTR lpszFileName);
    void    Initv42Compression(void);
    void    Flushv42Compression(void);

public:

    MBFTPrivateSend(LPMBFTENGINE lpParentEngine, MBFTEVENTHANDLE EventHandle,
                    T120UserID wMBFTUserID, ULONG MaxDataLength);
    ~MBFTPrivateSend(void);

    BOOL OnMCSChannelJoinConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnMCSChannelConveneConfirm(T120ChannelID, BOOL bSuccess);
    BOOL OnReceivedPrivateChannelResponsePDU(T120ChannelID, T120Priority,
                                             T120UserID SenderID,
                                             LPPRIVATECHANNELRESPONSEPDU lpNewPDU,
                                             BOOL IsUniformSendData);
    BOOL OnReceivedFileAcceptPDU(T120ChannelID, T120Priority,
                                 T120UserID SenderID,
                                 LPFILEACCEPTPDU lpNewPDU,
                                 BOOL IsUniformSendData);
    BOOL OnReceivedFileRejectPDU(T120ChannelID, T120Priority,
                                 T120UserID SenderID,
                                 LPFILEREJECTPDU lpNewPDU,
                                 BOOL IsUniformSendData);                                 
    BOOL OnReceivedFileAbortPDU(T120ChannelID, T120Priority,
                                T120UserID SenderID,
                                LPFILEABORTPDU lpNewPDU,
                                BOOL IsUniformSendData);
    BOOL OnReceivedFileErrorPDU(T120ChannelID, T120Priority,
                                T120UserID SenderID,
                                LPFILEERRORPDU lpNewPDU,
                                BOOL IsUniformSendData);
    BOOL OnReceivedNonStandardPDU(T120ChannelID, T120Priority,
                                  T120UserID SenderID,
                                  LPNONSTANDARDPDU lpNewPDU,
                                  BOOL IsUniformSendData);
    BOOL OnReceivedFileEndAcknowledgePDU(T120ChannelID, T120Priority,
                                        T120UserID SenderID,
                                        LPFILEENDACKNOWLEDGEPDU lpNewPDU,
                                        BOOL IsUniformSendData);
    BOOL OnReceivedChannelLeavePDU(T120ChannelID, T120Priority,
                                   T120UserID SenderID,
                                   LPCHANNELLEAVEPDU lpNewPDU,
                                   BOOL IsUniformSendData);                                        
    void OnControlNotification(MBFTFILEHANDLE hFile,
                               FileTransferControlMsg::FileTransferControl iControlCommand,
                               LPCSTR lpszDirectory,
                               LPCSTR lpszFileName);                            
    BOOL SubmitFileSendRequest(SubmitFileSendMsg *);
    void OnPeerDeletedNotification(CPeerData * lpPeerData);
    void DoStateMachine(void);                                        
    void UnInitialize(BOOL bShutDown = FALSE);  
};

#endif  //__MBFTSEND_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\mbftsend.cpp ===
/* file: mbftsend.cpp */

#include "mbftpch.h"

#include "mbftsend.hpp"
#include "fileio.hpp"
#include "messages.hpp"
#include "mbftapi.hpp"

#define     _MAX_SEND_PACKETS           1

ULONG g_nSendDisbandDelay = 5000; // Previous: Twenty seconds!
ULONG g_nChannelResponseDelay = 60000;


MBFTPrivateSend::MBFTPrivateSend
(
    LPMBFTENGINE        lpParentEngine,
    MBFTEVENTHANDLE     EventHandle,
	T120ChannelID       wMBFTUserID,
    ULONG               MaxDataLength
)
:  
	MBFTSession(lpParentEngine, EventHandle, MBFT_PRIVATE_SEND_TYPE),
    m_PrivateMBFTControlChannel(0),
    m_PrivateMBFTDataChannel(0),    

    m_lpUserArray(NULL),
    m_lpAcceptedUsersArray(NULL),

    m_iUserCount(0),

    m_MBFTChannelID(wMBFTUserID),
    m_MaxDataLength(MaxDataLength),

    m_LastUserCount(0),
    m_ResponseCount(0),
    m_AcceptCount(0),
    m_RejectCount(0),
    m_AbortedCount(0),
    m_AcknowledgeCount(0),

    m_CurrentFileSize(0),
    m_lTotalBytesRead(0),
    m_lpDataBuffer(NULL),

    m_bProshareTransfer(FALSE),
    m_bEOFAcknowledge(FALSE), 

    m_lpFile(NULL),
    m_pszCurrentFilePath(NULL),
    m_CurrentFileHandle(0),
    m_AcceptedIndex(0),
    
    m_bSentFileOfferPDU(FALSE),
    m_bUnInitializing(FALSE),   
    m_bAbortAllFiles(FALSE),
    m_bSendingFile(FALSE),
    m_bAbortFileSend(FALSE),
    m_SentFileStartPDU(FALSE),
    m_TimeOutValue(0),
    m_bCompressFiles(FALSE),
    m_bOKToDisbandChannel(TRUE),

    m_lpV42bisPointer(NULL),
    m_bFlushv42Compression(FALSE),
    m_bEventEndPosted(FALSE),

    m_State(EnumIdleNotInitialized)
{
}

MBFTPrivateSend::~MBFTPrivateSend(void)
{
    delete m_pszCurrentFilePath;
    delete m_lpUserArray;
    delete m_lpAcceptedUsersArray;
    delete m_lpDataBuffer;
    delete m_lpFile;
}

void MBFTPrivateSend::ConveneControlChannel(void)    
{
    if(m_lpParentEngine->MCSChannelConveneRequest())
    {
        m_State = EnumWaitConveneControlChannel;        
    }
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

void MBFTPrivateSend::ConveneDataChannel(void)    
{
    if(m_lpParentEngine->MCSChannelConveneRequest())
    {
        m_State = EnumWaitConveneDataChannel;        
    }        
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

void MBFTPrivateSend::JoinControlChannel(void)
{
    if(m_lpParentEngine->MCSChannelJoinRequest(m_PrivateMBFTControlChannel))
    {
        m_State = EnumWaitJoinControlChannel;                
    }                
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}
    
BOOL MBFTPrivateSend::OnMCSChannelJoinConfirm
(
    T120ChannelID           wChannelId,
    BOOL                    bSuccess
)
{
    BOOL bReturn = FALSE;
 
    if(wChannelId == m_PrivateMBFTControlChannel)
    {
        if(m_State == EnumWaitJoinControlChannel)
        {
            if(bSuccess)
            {
                TRACESEND(" Control channel joined [%u]\n",wChannelId);

                ConveneDataChannel();
            }
            else
            {
                ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
                UnInitialize();
            }

            bReturn = TRUE;        
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::AdmitControlChannel(void)
{
   if(m_lpParentEngine->MCSChannelAdmitRequest(m_PrivateMBFTControlChannel,
                                              m_lpUserArray,
                                              m_iUserCount))
    {
        TRACESEND(" Admit Control Channel Successful [%u]\n",m_PrivateMBFTControlChannel);
    }                                                      
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }

    if(m_lpParentEngine->MCSChannelAdmitRequest(m_PrivateMBFTDataChannel,
                                                m_lpUserArray,
                                                m_iUserCount))
    {
        TRACESEND(" Admit Data Channel Successful [%u]\n",m_PrivateMBFTDataChannel);            

        m_State = EnumWaitChannelResponsePDU;

        m_TimeOutValue  = GetTickCount() + g_nChannelResponseDelay;
    }                                                      
    else
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
        UnInitialize();
    }
}

BOOL MBFTPrivateSend::OnMCSChannelConveneConfirm
(
    T120ChannelID       wChannelId,
    BOOL                bSuccess
)
{
    BOOL bReturn = FALSE;    

    if(m_State == EnumWaitConveneControlChannel)
    {
        if(bSuccess)
        {
            TRACESEND(" Control channel convened [%u]\n",wChannelId);
            m_PrivateMBFTControlChannel = wChannelId;
            JoinControlChannel();
        }
        else
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
            UnInitialize();
        }        

        bReturn = TRUE;
    }
    else if(m_State == EnumWaitConveneDataChannel)        
    {
        if(bSuccess)
        {                               
            TRACESEND(" Data channel convened [%u]\n",wChannelId);
            m_PrivateMBFTDataChannel = wChannelId;
            m_State = EnumWaitSendChannelInvitePDU;
        }
        else
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_UNKNOWN_ERROR,TRUE);
            UnInitialize();
        }

        bReturn = TRUE;
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::SubmitFileSendRequest
(
    SubmitFileSendMsg       *pMsg
)
{
    BOOL bCompressFiles = pMsg->m_bCompressFiles;

    delete m_pszCurrentFilePath; // clean up any possible left over
    m_pszCurrentFilePath = pMsg->m_pszFilePath;
    m_CurrentFileHandle = pMsg->m_nFileHandle;
    pMsg->m_pszFilePath = NULL; // keep this pointer for furure use

    MBFT_ERROR_CODE iErrorCode = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_PERMANENT_ERROR;

	//NOTE: Merely turning this flag to TRUE will NOT
	//enable compression.  I have set it to FALSE here
	//so that certain stubbed routines will not be
	//entered.  If you turn this flag to TRUE....
	//then...have your finger ready on the reset button!!
	//If you want to turn compression on, Then you have
	//to include a bunch of v42.bis compression files etc.
	bCompressFiles = FALSE;

    // get the peer list
    CPeerList *pPeerList = m_lpParentEngine->GetPeerList();

	ASSERT(! (pMsg->m_nUserID && pMsg->m_nNodeID));
    BOOL fBroadcast = (0 == pMsg->m_nUserID && 0 == pMsg->m_nNodeID);
    ULONG iNumNodes = 1;
    if (fBroadcast)
    {
        iNumNodes = pPeerList->GetCount();
        ASSERT(iNumNodes);
    }

    DBG_SAVE_FILE_LINE
	m_lpDataBuffer          =   new char[m_MaxDataLength + MAX_PATH + _iMBFT_FILEDATA_PDU_SUBTRACT]; // enough space for the largest PDU
    DBG_SAVE_FILE_LINE
    m_lpUserArray           =   new UserID[iNumNodes];
    DBG_SAVE_FILE_LINE
    m_lpAcceptedUsersArray  =   new UserID[iNumNodes];

    if (NULL == m_lpDataBuffer || NULL == m_lpUserArray || NULL == m_lpAcceptedUsersArray)
    {
        ERROR_OUT(("MBFTPrivateSend::SubmitFileSendRequest: allocation failure"));
        delete m_lpDataBuffer;          m_lpDataBuffer = NULL;
        delete m_lpUserArray;           m_lpUserArray = NULL;
        delete m_lpAcceptedUsersArray;  m_lpAcceptedUsersArray = NULL;
        iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    }    

    if(iErrorCode == iMBFT_OK)
    {
        m_iUserCount    = 0;

        ZeroMemory(m_lpUserArray, sizeof(UserID) * iNumNodes);
        ZeroMemory(m_lpAcceptedUsersArray, sizeof(UserID) * iNumNodes);

        m_bProshareTransfer =  TRUE;
        m_bEOFAcknowledge   =  TRUE; 
        if (fBroadcast)
        {
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if (lpPeer->GetUserID() != m_lpParentEngine->GetUserID())
                {
                    m_lpUserArray[m_iUserCount++] = lpPeer->GetUserID();

                    if(m_bProshareTransfer)
                    {
                        m_bProshareTransfer = lpPeer->GetIsProshareNode();  
                    }
                    if(m_bEOFAcknowledge)
                    {                                                            
                        m_bEOFAcknowledge  =  lpPeer->GetEOFAcknowledge();
                    }
                }
            } // while
        }
        else
        {
            CPeerData *lpPeer;
            pPeerList->Reset();
            while (NULL != (lpPeer = pPeerList->Iterate()))
            {
                if ((pMsg->m_nUserID && pMsg->m_nUserID == lpPeer->GetUserID())
					||
					(pMsg->m_nNodeID && pMsg->m_nNodeID == lpPeer->GetNodeID()))
                {
                    m_lpUserArray[m_iUserCount++] = lpPeer->GetUserID();

                    if(m_bProshareTransfer)
                    {
                        m_bProshareTransfer = lpPeer->GetIsProshareNode();  
                    }
                    if(m_bEOFAcknowledge)
                    {                                                            
                        m_bEOFAcknowledge  =  lpPeer->GetEOFAcknowledge();
                    }
                    break;
                }
            } // while
            if (NULL == lpPeer)
            {
                iErrorCode = iMBFT_RECIPIENT_NOT_FOUND;
            }
        }

        if(m_bCompressFiles)
        {
			iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
        }            
        else
        {
            DBG_SAVE_FILE_LINE
            m_lpFile  =   new CMBFTFile;
        }

        if(!m_lpFile)
        {
            iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;    
        }

        if(iErrorCode == iMBFT_OK)
        { 
            m_State = EnumFileSendPending;
        }
    }

    if(iErrorCode != iMBFT_OK)    
    {
//        LOGERROR(iErrorCode,0,0);
            
        ReportError(iErrorType,iErrorCode,TRUE);
        TerminateSendSession();
    }

    return(iErrorCode == iMBFT_OK);    
}

void MBFTPrivateSend::ReportSenderError
(
    int             iErrorType,
    int             iErrorCode,
    MBFTFILEHANDLE  hFile
)
{
    DBG_SAVE_FILE_LINE
    FileErrorPDU * lpNewPDU = new FileErrorPDU((hFile) ?
                                               LOWORD(hFile) :  
                                               LOWORD(m_CurrentFileHandle),
                                               iErrorType,iErrorCode); 
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            for (ULONG Index = 0; Index < m_iUserCount; Index++)
            {
                m_lpParentEngine->SendDataRequest(m_lpUserArray[Index],
                                                  APPLET_HIGH_PRIORITY,
                                                  (LPBYTE)lpNewPDU->GetBuffer(),
                                                  lpNewPDU->GetBufferLength());       
            }
        }

        delete  lpNewPDU;
    }
}

void MBFTPrivateSend::ReportError
(
    int                 iErrorType,
    int                 iErrorCode,
    BOOL                bIsLocalError,
    T120UserID          SenderID,
    MBFTFILEHANDLE      FileHandle)
{
	T120UserID id = SenderID ? SenderID : m_MBFTChannelID;

    DBG_SAVE_FILE_LINE
	m_lpParentEngine->SafePostNotifyMessage(
	                    new FileErrorMsg(
                        		m_EventHandle,
                        		FileHandle ? FileHandle : m_CurrentFileHandle, 
                        		iErrorType,
                        		iErrorCode,
                        		bIsLocalError,
                        		id));
}

void MBFTPrivateSend::TerminateSendSession(void)
{
	UnInitialize();
}
        
       
void MBFTPrivateSend::UnInitialize
(
    BOOL        bShutDown
)
{
    BOOL bDataChannelDisbanded      =   FALSE;
    BOOL bControlChannelDisbanded   =   FALSE;

    if(m_State  !=  EnumWaitForTermination)
    {
        m_State = EnumWaitForTermination;

        TRACESEND(" Uninit begin\n");

		if (m_bEOFAcknowledge)
		{
			m_TimeOutValue = 0;
		}
		else
		{
			m_TimeOutValue = GetTickCount() + g_nSendDisbandDelay;
		}
		TRACESEND(" Using TimeOutValue of %d\n", m_TimeOutValue);
    }

    m_bUnInitializing = TRUE;

    if(GetTickCount() >= m_TimeOutValue)
    {
        if(m_PrivateMBFTDataChannel)
        {
            if(m_lpParentEngine->MCSChannelDisbandRequest(m_PrivateMBFTDataChannel))
            {
                TRACESEND(" Uninit: Data Channel disbanded [%u]\n",m_PrivateMBFTDataChannel);
                bDataChannelDisbanded       =   TRUE;
                m_PrivateMBFTDataChannel    =   0;
            }   
            else if(m_lpParentEngine->GetLastSendDataError() ==  MCS_TRANSMIT_BUFFER_FULL)
            {
                TRACESEND("Transmit buffer for [%u] full, data channel disband failed\n",m_PrivateMBFTDataChannel);    
            }
            else
            {
                TRACESEND("Unexpected error [%u] while disbanding data channel [%u]\n",
                           m_lpParentEngine->GetLastSendDataError(),m_PrivateMBFTDataChannel);    
            }
        }
        else
        {
            bDataChannelDisbanded   =   TRUE;
        }

        if(bDataChannelDisbanded)
        {
            if(m_PrivateMBFTControlChannel)
            {
                if(m_lpParentEngine->MCSChannelDisbandRequest(m_PrivateMBFTControlChannel))
                {
                    TRACESEND(" Uninit: Control Channel disbanded [%u]\n",m_PrivateMBFTControlChannel);
                    bControlChannelDisbanded        =   TRUE;
                    m_PrivateMBFTControlChannel     =   0;
                }
                else if(m_lpParentEngine->GetLastSendDataError() ==  MCS_TRANSMIT_BUFFER_FULL)
                {
                    TRACESEND("Transmit buffer for [%u] full, control channel disband failed\n",m_PrivateMBFTDataChannel);    
                }
                else
                {
                    TRACESEND("Unexpected error [%u] while disbanding control channel [%u]\n",
                               m_lpParentEngine->GetLastSendDataError(),m_PrivateMBFTDataChannel);    
                }
            }
            else
            {
                bControlChannelDisbanded    =   TRUE;
            }
        }

        if(!bShutDown)
        {
            if(bDataChannelDisbanded && bControlChannelDisbanded)
            {
                DBG_SAVE_FILE_LINE
                m_lpParentEngine->SafePostMessage(new DeleteSessionMsg(this));

                if(!m_bEventEndPosted)
                {        
                    DBG_SAVE_FILE_LINE
                    m_lpParentEngine->SafePostNotifyMessage(new FileEventEndNotifyMsg(m_EventHandle));
                    m_bEventEndPosted   =   TRUE;
                }
                TRACESEND(" Uninit complete\n");                
            }
        }
        else
        {
            TRACESEND(" Uninit complete\n");
        }
    }
}    

void MBFTPrivateSend::SendChannelInvitePDU(void)
{
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_PERMANENT_ERROR;

    DBG_SAVE_FILE_LINE
    LPPRIVATECHANNELINVITEPDU lpNewPDU = new PrivateChannelInvitePDU(m_PrivateMBFTControlChannel,
                                                                     m_PrivateMBFTDataChannel,
                                                                     FALSE);
    if(lpNewPDU)
    {
        if(lpNewPDU->Encode())
        {
            for (ULONG Index = m_LastUserCount;Index < m_iUserCount;Index++)
            {
                if(m_lpParentEngine->SendDataRequest(m_lpUserArray[Index],
                                                     APPLET_HIGH_PRIORITY,
                                                     (LPBYTE)lpNewPDU->GetBuffer(),
                                                     lpNewPDU->GetBufferLength()))       
                {
                    TRACESEND(" Sent Channel invite PDU, Control Channel [%u], Data Channel [%u] to [%u]\n",m_PrivateMBFTControlChannel,m_PrivateMBFTDataChannel,m_lpUserArray[Index]);
                              
                    m_LastUserCount++; 
                }                                                             
                else
                {
                    m_State = EnumWaitSendChannelInvitePDU;    
                    break;
                }
            }    

            if(Index >= m_iUserCount)
            {
                AdmitControlChannel();
            }
        }
        else
        {
            iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
        }

        delete lpNewPDU;
    }
    else
    {
        iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);    
        UnInitialize();
    }
    
}
    
BOOL MBFTPrivateSend::OnReceivedFileAbortPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEABORTPDU          lpFileAbortPDU, 
    BOOL                    IsUniformSendData
)
{
    MBFTFILEHANDLE hFile = lpFileAbortPDU->GetFileHandle();

    if (hFile && hFile == m_CurrentFileHandle)
    {
        if (m_bUnInitializing)
        {
            OnControlNotification(hFile,
                                  FileTransferControlMsg::EnumConductorAbortFile,
                                  NULL,
                                  NULL);  
        }
        return TRUE; // handled
    }

    return FALSE; // not handled
}                                                                                                                                                                       
                                       

void MBFTPrivateSend::DoStateMachine(void)
{
    if(m_State == EnumFileSendPending)
    {
        ConveneControlChannel();    
    }
    else if(m_State == EnumWaitRequestControlConvene)
    {
        ConveneControlChannel();    
    }
    else if(m_State == EnumWaitRequestJoinControl)
    {
        JoinControlChannel();
    }
    else if(m_State == EnumWaitRequestDataConvene)
    {
        ConveneDataChannel();    
    }
    else if(m_State == EnumWaitSendChannelInvitePDU)
    {
        SendChannelInvitePDU();    
    }
    else if(m_State == EnumSendNonStandardPDU)
    {
	    TRACESEND(" Not Sending a NonStandardPDU");
	    m_State = EnumSendFileOfferPDU;
        SendFileOfferPDU();
    }
    else if(m_State == EnumSendFileOfferPDU)
    {
        SendFileOfferPDU();
    }
    else if(m_State == EnumSendFileStartPDU)
    {
        SendFileStartPDU();        
    }
    else if(m_State == EnumSendFileDataPDU)
    {
        SendFileDataPDU();
    }
    else if(m_State == EnumTerminateCurrentSend)                
    {
        TerminateCurrentSend();
    }
    else if(m_State == EnumWaitForTermination)
    {
		UnInitialize();
    }
    else if(m_State == EnumWaitChannelResponsePDU)
    {
        if(GetTickCount() >= m_TimeOutValue)
        {
//            LOGERROR(iMBFT_TIMEOUT_ERROR,0,0);
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_TIMEOUT_ERROR,TRUE);
            UnInitialize();                
        }
    }

    return;
}                                                                                                                                                                                             
BOOL MBFTPrivateSend::OnReceivedPrivateChannelResponsePDU
(
    T120ChannelID               wChannelId,
    T120Priority                iPriority,
    T120UserID                  SenderID,
    LPPRIVATECHANNELRESPONSEPDU lpNewPDU,
    BOOL                        IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitChannelResponsePDU)
    {
        if(wChannelId == m_MBFTChannelID && 
           lpNewPDU->GetControlChannel() == m_PrivateMBFTControlChannel)
        {
            bReturn = TRUE;

            TRACESEND(" Received Channel response PDU from [%u]\n",SenderID); 

            for (ULONG Index = 0; Index < m_iUserCount; Index++)
            {    
                if(m_lpUserArray[Index] == SenderID)
                {
                    m_ResponseCount++;
                }
            }

            if(!lpNewPDU->GetWasChannelJoined())
            {
                ReportError(MBFT_INFORMATIVE_ERROR,
                            iMBFT_RECEIVER_ABORTED,
                            FALSE,
                            SenderID, 
                            _iMBFT_PROSHARE_ALL_FILES);

                RemoveUserFromList(SenderID);
            }

            if(m_iUserCount)
            {
                if(m_ResponseCount >= m_iUserCount)
                {
                    m_State = (! m_bProshareTransfer) ? EnumSendFileOfferPDU :   
                                                        EnumSendNonStandardPDU;
                }
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::SendFileOfferPDU(void)
{
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

    m_AcceptCount       = 0;
    m_RejectCount       = 0;
    m_ResponseCount     = 0;
    m_AcknowledgeCount  = 0;
    m_lTotalBytesRead   = 0;
    m_SentFileStartPDU  = FALSE;
    m_AbortedCount      = 0;
    m_bSentFileOfferPDU = FALSE;
    m_AcceptedIndex     = 0;

    ::ZeroMemory(m_lpAcceptedUsersArray, sizeof(UserID) * m_iUserCount);

    if (m_lpFile->Open(m_pszCurrentFilePath, CMBFTFile::OpenReadOnly | CMBFTFile::OpenBinary))
    {
        m_CurrentFileSize   = m_lpFile->GetFileSize();
        m_CurrentDateTime   = m_lpFile->GetFileDateTime();

        DBG_SAVE_FILE_LINE
        LPFILEOFFERPDU lpNewPDU = new FileOfferPDU(GetFileNameFromPath(m_pszCurrentFilePath),
                                                   LOWORD(m_CurrentFileHandle),
                                                   m_CurrentFileSize,
                                                   m_CurrentDateTime,
                                                   m_PrivateMBFTDataChannel,TRUE,
                                                   m_lpParentEngine->GetRosterInstance(),
                                                   0, NULL, 0, 0);
        if(lpNewPDU)
        {
            if(lpNewPDU->Encode())
            {
                if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTControlChannel,
                                                     APPLET_HIGH_PRIORITY,
                                                     (LPBYTE)lpNewPDU->GetBuffer(),
                                                     lpNewPDU->GetBufferLength()))
                {
                    TRACESEND(" Transmitted File Offer PDU for [%u] on [%u]\n",LOWORD(m_CurrentFileHandle),m_PrivateMBFTControlChannel);

                    //Now that we have sent a FileOfferPDU, we can't disband the channel
                    //without notice....

                    m_bOKToDisbandChannel   = FALSE;

                    m_bSentFileOfferPDU     = TRUE;
                    m_State = EnumWaitFileAcceptPDU;
                }
            }
            else
            {
                iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
            }

            delete lpNewPDU;
        }                                
        else
        {
             iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
        }
    }
    else
    {
        iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

        //iMBFT_FILE_IO_ERROR;
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);

        if(m_bSentFileOfferPDU)
        {
            //If a FileOffer has been sent out, we need to send a FileStartPDU with 
            //EOF = TRUE...

            TerminateCurrentSend();
        }            
        else
        {
            ReportError(MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,TRUE,
                        m_MBFTChannelID,m_CurrentFileHandle);    

            SendNextFile();
        }
    }
}

BOOL MBFTPrivateSend::OnReceivedFileAcceptPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEACCEPTPDU         lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitFileAcceptPDU)
    {
        if(wChannelId == m_MBFTChannelID)
        {
            if(lpNewPDU->GetFileHandle() == m_CurrentFileHandle)
            {
                TRACESEND(" Received file accept PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                bReturn = TRUE;

                for (ULONG Index = 0; Index < m_iUserCount; Index++)
                {    
                    if(m_lpUserArray[Index] == SenderID)
                    {
                        if(m_AcceptedIndex < m_iUserCount)
                        {
                            m_lpAcceptedUsersArray[m_AcceptedIndex++] = SenderID;
                        }

                        m_AcceptCount++;
                        m_ResponseCount++;
                    }
                }

                if(m_ResponseCount >= m_iUserCount)
                {
                    m_State = EnumSendFileStartPDU;
                }                
            }
        }
    }

    return(bReturn);
}
                             
BOOL MBFTPrivateSend::OnReceivedFileRejectPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEREJECTPDU         lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State == EnumWaitFileAcceptPDU)
    {
        if(wChannelId == m_MBFTChannelID)
        {
            MBFTFILEHANDLE iFileHandle = lpNewPDU->GetFileHandle();

            if((iFileHandle == m_CurrentFileHandle) ||
               ((iFileHandle == LOWORD(_iMBFT_PROSHARE_ALL_FILES)) && m_bProshareTransfer))
            {
                TRACESEND(" Received file reject PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                for(ULONG Index = 0;Index < m_iUserCount;Index++)
                {    
                    if(m_lpUserArray[Index] == SenderID)
                    {
                        bReturn = TRUE;
                    }                        
                }

                if(bReturn)
                {                                
                    if(iFileHandle == m_CurrentFileHandle)
                    {
                      m_RejectCount++;
                      m_ResponseCount++;
                      
                    }                  
                    else if((iFileHandle == LOWORD(_iMBFT_PROSHARE_ALL_FILES)) && m_bProshareTransfer)
                    {

                        RemoveUserFromList(SenderID);
                    }

                    if(m_iUserCount)
                    {
                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                m_lpFile->Close();
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }   //if bReturn
            }
        }   //wChannelId == m_MBFTChannelID
    }       //m_State == EnumWaitFileAcceptPDU

    return(bReturn);    
}

BOOL MBFTPrivateSend::OnReceivedFileErrorPDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEERRORPDU          lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;
    MBFTFILEHANDLE FileHandle = lpNewPDU->GetFileHandle();

    if ((m_CurrentFileHandle == FileHandle) ||
        (m_bProshareTransfer && (LOWORD(FileHandle) == LOWORD(_iMBFT_PROSHARE_ALL_FILES))))
    {
        TRACERECEIVE(" FileErrorPDU from [%u] for [%u], ErrorCode: [%u]\n",SenderID,lpNewPDU->GetFileHandle(),lpNewPDU->GetErrorCode());

        if(m_bProshareTransfer)
        {
            if(m_State != EnumWaitForTermination)
            {
                if(lpNewPDU->GetErrorCode() == iMBFT_RECEIVER_ABORTED && 
                   lpNewPDU->GetFileHandle() == LOWORD(_iMBFT_PROSHARE_ALL_FILES))
                {
                    m_AbortedCount++;

                    RemoveUserFromList(SenderID);

                    //If the state is EnumWaitFileAcceptPDU, we don't
                    //have an exact count of the number of recipients who accepted
                    //the file. Therefore, we cannot make a decision on whether or not
                    //to abort the file based on AcceptCount and AbortedCount....

                    if(m_State != EnumWaitFileAcceptPDU)
                    {
                        if(m_iUserCount)
                        {
                            if(m_AbortedCount >= m_AcceptCount)
                            {
		                        m_lpFile->Close();
                                SendNextFile();
                            }
		                }
                        else
                        {
                            m_lpFile->Close();
                        }
                    }
                    else if(m_iUserCount)
                    {
                        //In this case, the FileErrorPDU acts as a FileRejectPDU...

                        TRACERECEIVE(" Treating FileErrorPDU for [%u] as FileRejectPDU\n",lpNewPDU->GetFileHandle());

                        //m_RejectCount++;
                        //m_ResponseCount++;

                        //In this case, response count has to be greater 
                        //because a user was just deleted!!!

                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }
                else if (FileHandle == m_CurrentFileHandle)
                {
                    m_AbortedCount++;

                    //If the state is EnumWaitFileAcceptPDU, we don't
                    //have an exact count of the number of recipients who accepted
                    //the file. Therefore, we cannot make a decision on whether or not
                    //to abort the file based on AcceptCount and AbortedCount....

                    if(m_State != EnumWaitFileAcceptPDU)
                    {
                        if(m_AbortedCount >= m_AcceptCount)
                        {
                            m_lpFile->Close();
                            SendNextFile();
                        }
                    }
                    else
                    {
                        //In this case, the FileErrorPDU acts as a FileRejectPDU...
                        TRACERECEIVE(" Treating FileErrorPDU for [%u] as FileRejectPDU\n",lpNewPDU->GetFileHandle());

                        m_RejectCount++;
                        m_ResponseCount++;

                        if(m_ResponseCount >= m_iUserCount)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }                
                    }
                }
            }   //EnumWaitForTermination
        }       //IsProshare
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::OnReceivedNonStandardPDU
(
    T120ChannelID           wChannelID,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPNONSTANDARDPDU        lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL bReturn = FALSE;

    if(m_State != EnumWaitForTermination)
    {
        if(wChannelID == m_PrivateMBFTControlChannel)
        {
            if (! ::lstrcmpA(lpNewPDU->GetKey(), PROSHARE_FILE_END_STRING)) 
            {    
                TRACESEND(" Received Non Standard PDU (File End Acknowledge) from  [%u]\n",SenderID);
                FileEndAcknowledgeStruct  * lpStruct  =   (FileEndAcknowledgeStruct *)lpNewPDU->GetDataBuffer();

                DBG_SAVE_FILE_LINE
				LPFILEENDACKNOWLEDGEPDU lpEndAckNewPDU = new FileEndAcknowledgePDU(lpStruct->m_FileHandle);
				if (NULL != lpEndAckNewPDU)
				{
                    bReturn = OnReceivedFileEndAcknowledgePDU(wChannelID,
                                                          iPriority,
                                                           SenderID,
                                                           lpEndAckNewPDU,
                                                           IsUniformSendData);
				    delete lpEndAckNewPDU;
				}
            }
            else if (! ::lstrcmpA(lpNewPDU->GetKey(), PROSHARE_CHANNEL_LEAVE_STRING))
            {
                TRACESEND(" Received Non Standard PDU (Channel Leave) from  [%u]\n",SenderID);

                ChannelLeaveStruct * lpStruct = (ChannelLeaveStruct *)lpNewPDU->GetDataBuffer();

                DBG_SAVE_FILE_LINE
                LPCHANNELLEAVEPDU lpLeaveNewPDU = new ChannelLeavePDU(lpStruct->m_ChannelID,lpStruct->m_ErrorCode);
				if (NULL != lpLeaveNewPDU)
				{
                    bReturn = OnReceivedChannelLeavePDU(wChannelID,
                                                    iPriority,
                                                    SenderID,
                                                    lpLeaveNewPDU,
                                                    IsUniformSendData);
                    delete lpLeaveNewPDU;
                }
            }
            else
            {
                TRACE("*** Unknown Non Standard PDU received on [%u] *** \n",wChannelID);
            }
        }
    }

    return(bReturn);
}

BOOL MBFTPrivateSend::OnReceivedFileEndAcknowledgePDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPFILEENDACKNOWLEDGEPDU lpNewPDU,
    BOOL                    IsUniformSendData
)
{
    BOOL  bReturn   =   FALSE;

    if(m_State == EnumWaitFileEndAcknowledgePDU)
    {
        if(wChannelId == m_PrivateMBFTControlChannel)
        {
            if(lpNewPDU->GetFileHandle() == m_CurrentFileHandle)
            {
                TRACESEND(" Received file end acknowledge PDU from [%u] for [%u]\n",SenderID,lpNewPDU->GetFileHandle());

                bReturn = TRUE;

                for (ULONG Index = 0; Index < m_AcceptedIndex; Index++)
                {    
                    if(m_lpAcceptedUsersArray[Index] == SenderID)
                    {
                        m_AcknowledgeCount++;
                    }
                }

                if(m_AcknowledgeCount >= m_AcceptCount)
                {
                    SendNextFile();
                }                
            }
        }
    }

    return(bReturn);
}                                    
    
BOOL MBFTPrivateSend::OnReceivedChannelLeavePDU
(
    T120ChannelID           wChannelId,
    T120Priority            iPriority,
    T120UserID              SenderID,
    LPCHANNELLEAVEPDU       lpNewPDU,
    BOOL                    IsUniformSendData
)
{               
    BOOL  bReturn  =  FALSE;

    if(m_State == EnumSendFileStartPDU || m_State == EnumSendFileDataPDU ||
       m_State == EnumWaitFileEndAcknowledgePDU)
    {
        if(lpNewPDU->GetChannelID() == m_PrivateMBFTDataChannel)
        {
            bReturn     =   TRUE;

            TRACESEND(" Received Channel Leave PDU from [%u] for [%u], CurrentFile [%u]\n",
                      SenderID,lpNewPDU->GetChannelID(),m_CurrentFileHandle);

            for (ULONG Index = 0; Index < m_AcceptedIndex; Index++)
            {    
                if(m_lpAcceptedUsersArray[Index] == SenderID)
                {
                    m_AcknowledgeCount++;
                }
            }

            if(m_State == EnumWaitFileEndAcknowledgePDU)
            {
                if(m_AcknowledgeCount >= m_AcceptCount)
                {
                    SendNextFile();
                }                
            }
        }
    }

    return(bReturn);
}

void MBFTPrivateSend::SendFileStartPDU(void)
{
    if(!m_bAbortAllFiles)
    {        
        MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
        MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

        LONG lCurrentPosition = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
		FILE_HEADER_INFO fileHeaderInfo;
		fileHeaderInfo.fileName = (LPSTR)GetFileNameFromPath(m_pszCurrentFilePath);
		fileHeaderInfo.fileSize = m_CurrentFileSize;
		fileHeaderInfo.pduType = T127_FILE_START;
		GetFileHeaderSize(&fileHeaderInfo);

		int iSizeofFileHeader = fileHeaderInfo.pduSize  + sizeof(T127_FILE_START_DATA_BLOCK_HEADER);
		int iBytesRead = m_lpFile->Read(m_lpDataBuffer + iSizeofFileHeader ,m_MaxDataLength);
        m_bSendingFile = TRUE;

        if(iBytesRead != -1)
        {
            BOOL bIsEOF =  (m_lTotalBytesRead + iBytesRead) >= m_CurrentFileSize;
            LPFILESTARTPDU lpNewPDU = NULL;

            if(!iBytesRead)
            {
                DBG_SAVE_FILE_LINE
                lpNewPDU = new FileStartPDU(m_lpDataBuffer,
                                            fileHeaderInfo.fileName, // GetFileNameFromPath(m_pszCurrentFilePath),
                                            LOWORD(m_CurrentFileHandle),
                                            m_CurrentFileSize,
                                            m_CurrentDateTime,
                                            m_lpDataBuffer,
                                            0,
                                            bIsEOF);          
            }
            else
            {
                if(!m_bCompressFiles)
                {
                    DBG_SAVE_FILE_LINE
                    lpNewPDU = new FileStartPDU(m_lpDataBuffer,
                                                fileHeaderInfo.fileName, // GetFileNameFromPath(m_pszCurrentFilePath),
                                                LOWORD(m_CurrentFileHandle),
                                                m_CurrentFileSize,
                                                m_CurrentDateTime,
                                                m_lpDataBuffer,
                                                iBytesRead,
                                                bIsEOF);   
                }                                                
                else
                {
                    iErrorCode  = iMBFT_MEMORY_ALLOCATION_ERROR;
                }
            }        

            if(iErrorCode == iMBFT_OK)
            {
                if(lpNewPDU)
                {                 
                    if(lpNewPDU->Encode())
                    {
                        if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                             APPLET_LOW_PRIORITY,
                                                             (LPBYTE)lpNewPDU->GetBuffer(),
                                                             lpNewPDU->GetBufferLength()))
                        {
                            TRACESEND(" Sent file start PDU for [%ld] on [%u], EOF = [%d]\n",
                                m_CurrentFileHandle, m_PrivateMBFTDataChannel, bIsEOF);

                            m_lTotalBytesRead   += iBytesRead;
                            m_SentFileStartPDU  =  TRUE;

                            SendNotificationMessage(iMBFT_FILE_SEND_BEGIN);

                            if(bIsEOF)
                            {
                                m_lpFile->Close();
								if(!m_bEOFAcknowledge)
								{
									SendNextFile();
								}
								else
								{
									TRACESEND(" Waiting for End of File ack PDU\n");
									m_State  =  EnumWaitFileEndAcknowledgePDU;
								}
                            }
                            else
                            {
                                m_State = EnumSendFileDataPDU;
                            }
                        }   
                        else
                        {
                            m_lpFile->Seek(lCurrentPosition,CMBFTFile::SeekMode::SeekFromBegin);
                        }
                    }
                    else
                    {
                        iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
                    }
                }   //if(lpNewPDU)
                else
                {
                    iErrorCode  = iMBFT_MEMORY_ALLOCATION_ERROR;
                }
            }   //if iErrorCode == iMBFT_OK

            if(lpNewPDU)
            {
				lpNewPDU->NULLDataBuffer();
                delete lpNewPDU;
            }
        }    //If bytes read...
        else
        {
            iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

            //iMBFT_FILE_IO_ERROR;
        }

        if(iErrorCode != iMBFT_OK)
        {
            ReportError(iErrorType,iErrorCode,TRUE);
            ReportSenderError(iErrorType,iErrorCode);
            TerminateCurrentSend();
        }
    }    
    else
    {
        TerminateCurrentSend();
    }
}                         
    
void MBFTPrivateSend::SendNotificationMessage
(
    int             iProgress,
    T120UserID      iUserID,
    MBFTFILEHANDLE  hFileHandle
)
{
	T120UserID id = iUserID ? iUserID : m_MBFTChannelID;

    DBG_SAVE_FILE_LINE
    m_lpParentEngine->SafePostNotifyMessage(
                new FileTransmitMsg(m_EventHandle,
            				hFileHandle ?  hFileHandle : m_CurrentFileHandle,
            				m_CurrentFileSize,
            				m_lTotalBytesRead,
            				iProgress,
            				id));
}

void MBFTPrivateSend::TerminateCurrentSend(void)
{
    m_State = EnumTerminateCurrentSend;

    ReportError(MBFT_INFORMATIVE_ERROR,iMBFT_SENDER_ABORTED,TRUE,
                m_MBFTChannelID,m_CurrentFileHandle);    

    //We don't care about compression in this case because the buffer is NULL....
    DBG_SAVE_FILE_LINE
    LPFILEDATAPDU lpNewPDU = new FileDataPDU(m_lpDataBuffer,LOWORD(m_CurrentFileHandle),m_lpDataBuffer,0, FALSE, TRUE);
    if(lpNewPDU)
    {    
        if(lpNewPDU->Encode())
        {
            if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                 APPLET_LOW_PRIORITY,
                                                 (LPBYTE)lpNewPDU->GetBuffer(),
                                                 lpNewPDU->GetBufferLength()))
            {
                m_lpFile->Close();
                SendNextFile();
            }                                                            
        }
		lpNewPDU->NULLDataBuffer();
        delete lpNewPDU;
    }
}


void MBFTPrivateSend::SendFileDataPDU(void)
{
    LONG lCurrentPosition = -1;
    LPFILEDATAPDU lpNewPDU = NULL;
    int iBytesRead,Index;
    BOOL bIsEOF = FALSE,bTerminate = FALSE;
    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

    if(!m_bAbortFileSend)
    {
        for(Index = 0;(Index < _MAX_SEND_PACKETS) && !bTerminate;Index++)
        {
            lCurrentPosition = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);
            iBytesRead = m_lpFile->Read(m_lpDataBuffer + sizeof(T127_FILE_DATA_HEADER),m_MaxDataLength);
            if(iBytesRead != -1)
            {
                BOOL bDataSent = FALSE;
                bIsEOF = m_lpFile->GetIsEOF();

                if(!m_bCompressFiles)
                {
                    DBG_SAVE_FILE_LINE
                    lpNewPDU = new FileDataPDU(m_lpDataBuffer,
                                               LOWORD(m_CurrentFileHandle),
                                               m_lpDataBuffer,iBytesRead,bIsEOF,
                                               FALSE);
                }
                else
                {
					// MSFT error - no compression
                }

                if(lpNewPDU)
                {
                    if(lpNewPDU->Encode())
                    {
                        if(m_lpParentEngine->SendDataRequest(m_PrivateMBFTDataChannel,
                                                             APPLET_LOW_PRIORITY,
                                                             (LPBYTE)lpNewPDU->GetBuffer(),
                                                             lpNewPDU->GetBufferLength()))
                        {
                            TRACESEND(" Sent file data PDU on [%u], EOF = [%d], BufferSize = [%d]\n",m_PrivateMBFTDataChannel,bIsEOF,lpNewPDU->GetBufferLength());

                            //m_lTotalBytesRead += iBytesRead;

                            m_lTotalBytesRead = m_lpFile->Seek(0L,CMBFTFile::SeekMode::SeekFromCurrent);

                            bDataSent = TRUE;    

                            SendNotificationMessage(iMBFT_FILE_SEND_PROGRESS);

                            if(bIsEOF)
                            {
                                m_lpFile->Close();

                                if(!m_bEOFAcknowledge)
                                {
                                    SendNextFile();
                                }
                                else
                                {
									TRACESEND(" Waiting for End of File ack PDU\n");
                                    m_State  =  EnumWaitFileEndAcknowledgePDU;
                                }

                                bTerminate = TRUE;
                            }
                        }

                        if(!bDataSent)
                        {
                            m_lpFile->Seek(lCurrentPosition,CMBFTFile::SeekMode::SeekFromBegin);
                            bTerminate = TRUE;
                        }
                    }
                    else
                    {
                        iErrorCode = iMBFT_ASN1_ENCODING_ERROR;
                        break;
                    }
					lpNewPDU->NULLDataBuffer();
                    delete lpNewPDU;
                }
                else
                {
                    iErrorCode = iMBFT_MEMORY_ALLOCATION_ERROR;
                    break;
                }
            }
            else
            {
                iErrorCode = (MBFT_ERROR_CODE)m_lpFile->GetLastErrorCode();

                //iMBFT_FILE_IO_ERROR;

                break;
            }
        }   //for loop
    }
    else
    {
        TerminateCurrentSend();
    }

    if(iErrorCode != iMBFT_OK)
    {
        ReportError(iErrorType,iErrorCode,TRUE);
        ReportSenderError(iErrorType,iErrorCode);
        TerminateCurrentSend();
    }
}

void MBFTPrivateSend::RemoveFileFromList
(
    MBFTFILEHANDLE      hFile
)
{
    if (hFile == m_CurrentFileHandle)
    {
        ReportError(MBFT_PERMANENT_ERROR,iMBFT_NO_MORE_FILES,TRUE);
        TerminateSendSession();
    }
}

BOOL MBFTPrivateSend::RemoveUserFromAcceptedList
(
    T120UserID          iUserID
)
{
    BOOL bUserRemoved = FALSE;

    for (ULONG Index = 1; Index <= m_AcceptedIndex; Index++)
    {
        if(m_lpAcceptedUsersArray[Index - 1] == iUserID)
        {
            bUserRemoved = TRUE;

            if(Index != m_AcceptedIndex)
            {
                CopyMemory(&m_lpAcceptedUsersArray[Index - 1],&m_lpAcceptedUsersArray[Index],
                         (m_AcceptedIndex - Index) * sizeof(UserID));
            }

            m_AcceptedIndex--;
        }
    }

    return(bUserRemoved);
}

BOOL MBFTPrivateSend::RemoveUserFromList
(
    T120UserID          iUserID
)
{
    BOOL bUserRemoved = FALSE;

    for (ULONG Index = 1; Index <= m_iUserCount; Index++)
    {
        if(m_lpUserArray[Index - 1] == iUserID)
        {
            bUserRemoved = TRUE;

            if(Index != m_iUserCount)
            {
                CopyMemory(&m_lpUserArray[Index - 1],&m_lpUserArray[Index],
                         (m_iUserCount - Index) * sizeof(UserID));
            }

            m_iUserCount--;
        }
    }

    if(bUserRemoved)
    {
        if(!m_iUserCount)
        {
            ReportError(MBFT_PERMANENT_ERROR,iMBFT_NO_MORE_RECIPIENTS,TRUE);

            if(m_State == EnumSendFileDataPDU || m_State == EnumSendFileOfferPDU ||
               m_State == EnumWaitFileAcceptPDU)
            {
                if(m_lpFile)
                {
                    m_lpFile->Close();
                }

                if(m_State == EnumSendFileDataPDU)
                {
                    SendNotificationMessage(iMBFT_FILE_SEND_END);
                }                 
            }

            TerminateSendSession();
        }
    }

    return(bUserRemoved);
}

void MBFTPrivateSend::OnControlNotification
(
    MBFTFILEHANDLE          hFile,
    FileTransferControlMsg::FileTransferControl iControlCommand,
    LPCSTR                  lpszDirectory,
    LPCSTR                  lpszFileName
)
{
    if(iControlCommand == FileTransferControlMsg::EnumAbortFile ||
       iControlCommand == FileTransferControlMsg::EnumConductorAbortFile)
    {
        if(m_bOKToDisbandChannel)
        {
            if(hFile == _iMBFT_PROSHARE_ALL_FILES /*&& m_bProshareTransfer*/)
            {
                //Fix to ensure a iMBFT_SENDER_ABORTED notification if sender aborts way too early...
                ReportError(MBFT_INFORMATIVE_ERROR,
                            (iControlCommand == FileTransferControlMsg::EnumAbortFile) ?
                            iMBFT_SENDER_ABORTED :
                            iMBFT_CONDUCTOR_ABORTED,
                            TRUE,
                            m_MBFTChannelID,
                            _iMBFT_PROSHARE_ALL_FILES);    

                UnInitialize();
            }
            else
            {
                RemoveFileFromList(hFile);
            }
        }
        else if(!m_bUnInitializing)
        {
            if(hFile == _iMBFT_PROSHARE_ALL_FILES)
            {
                AbortAllFiles();
            }
            else if(hFile == m_CurrentFileHandle)
            {
                AbortCurrentFile();
            }
        }
    }
}

void MBFTPrivateSend::AbortAllFiles(void)
{
    AbortCurrentFile();
    
    m_bAbortAllFiles = TRUE;
}

void MBFTPrivateSend::AbortCurrentFile(void)
{
    if(m_bSendingFile)
    {
        m_bAbortFileSend = TRUE;
    }
}
    
void MBFTPrivateSend::SendNextFile(void)
{
	// Notify the ui if some receivers didn't accept the previous file
    if(m_AbortedCount)
	{
		// All the receivers aborted the FT, this is the same as the sender canceling FT
		ReportError(MBFT_PERMANENT_ERROR,
		            m_AbortedCount >= m_AcceptCount ? iMBFT_SENDER_ABORTED : iMBFT_MULT_RECEIVER_ABORTED,
		            TRUE);
	}
    if(m_RejectCount)
	{
		// If we just had one FT an it rejected we say that there was a problem sending the file
		// If we had more receivers we will use the receiver aborted message
		ReportError(MBFT_PERMANENT_ERROR,
					m_AcceptCount == 0 ? iMBFT_RECEIVER_REJECTED : iMBFT_MULT_RECEIVER_ABORTED,
		            TRUE);
	}

    // We are sending or the receiver Rejected before we start sending
	if(m_bSendingFile || m_RejectCount)
    {
        SendNotificationMessage(iMBFT_FILE_SEND_END);
    }

    m_bSendingFile      = FALSE;
    m_bAbortFileSend    = FALSE;                               

    TerminateSendSession();
}

void MBFTPrivateSend::OnPeerDeletedNotification
(
    CPeerData           *lpPeerData
)
{
    if(m_State != EnumWaitForTermination)
    {
        if(RemoveUserFromList(lpPeerData->GetUserID()))
        {
            if(m_iUserCount)
            {
                if(m_State == EnumWaitFileAcceptPDU ||
                   m_State == EnumWaitChannelResponsePDU)
                {
                    //m_RejectCount++;
                    //m_ResponseCount++;
                    
                    if(m_ResponseCount >= m_iUserCount)
                    {
                        if(m_State == EnumWaitFileAcceptPDU)
                        {
                            if(m_ResponseCount != m_RejectCount)
                            {
                                m_State = EnumSendFileStartPDU;
                            }
                            else
                            {
                                SendNextFile();                                         
                            }                        
                        }
                        else if(m_State == EnumWaitChannelResponsePDU)
                        {
                            if(!m_bProshareTransfer)
                            {
                                m_State = EnumSendFileOfferPDU;    
                            }
                            else
                            {
                                m_State = EnumSendNonStandardPDU;
                            }                       
                        }
                    }  //m_ResponseCount >= m_iUserCount              
                }
                else if ((m_State == EnumWaitFileEndAcknowledgePDU) || (m_State == EnumSendFileDataPDU))
                {
                    if(RemoveUserFromAcceptedList(lpPeerData->GetUserID()))
                    {
                        m_AcknowledgeCount++;
                    }
            
                    if(m_AcknowledgeCount >= m_AcceptCount)
                    {
                        SendNextFile();
                    }                
                }
            } //UserCount
        } //RemoveUserFromList
    } //EnumWaitForTermination
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ms_util.cpp ===
#include "mbftpch.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}


void CRefCount::ReleaseNow(void)
{
    m_cRefs = 0;
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

    void ReleaseNow(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\nullmdm.cpp ===
#include "mbftpch.h"
#include "nullmdm.h"


// #undef TRACE_OUT
// #define TRACE_OUT   WARNING_OUT


BYTE    g_szNULLMStartString[] = "NULLMDM";
ULONG   g_nConnID = 0;

DWORD __stdcall TPhysWorkerThreadProc(void *lpv);



CNullModem::CNullModem(HINSTANCE hDllInst)
:
    m_fInitialized(FALSE),
    m_hDllInst(hDllInst),
    m_pfnCallback(NULL),
    m_fListening(FALSE),
    m_hwnd(NULL),
    m_nTransportID(0),
    m_nConnectionID(0),
    m_dwThreadID(0),
    m_hThread(NULL),
    m_hevtOverlapped(NULL),
    m_dwEventMask(0),
    m_fCommPortInUse(FALSE)
{
    ::ZeroMemory(&m_Line, sizeof(m_Line));
    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    ::ZeroMemory(&m_DefaultTimeouts, sizeof(m_DefaultTimeouts));

    m_hevtOverlapped = ::CreateEvent(NULL, TRUE, FALSE, NULL); // manual reset
    ASSERT(NULL != m_hevtOverlapped);
}


CNullModem::~CNullModem(void)
{
    if (m_fInitialized)
    {
        TPhysTerminate();
    }

    if (NULL != m_hevtOverlapped)
    {
        ::CloseHandle(m_hevtOverlapped);
    }
}


//////////////////////////////////////////////////////////////////////////////
// TPhysInitialize
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysInitialize
(
    TPhysCallback   callback,
    UINT            nTransportID
)
{
    const char *pszNULLMClassName = "COMMWndClass";
    TPhysicalError rc = TPHYS_SUCCESS;

    TRACE_OUT(("TPhysInitialize"));

    //
    // If we have already been initialized then this is a reinit call from
    // the node controller so just do nothing.
    //
    if (! m_fInitialized)
    {
        //
        // zero out the SESSION INFO structure
        //
        ::ZeroMemory(&m_Line, sizeof(m_Line));

        //
        // Store control information
        //
        m_pfnCallback = callback;
        m_nTransportID  = nTransportID;
        m_fInitialized = TRUE;
        m_nConnectionID = ++g_nConnID;

        //
        // Create a window so we can decouple to the node controller context                                                          
        // Register the main window class.  Since it is invisible, leave
        // the wndclass structure sparse.
        //
        WNDCLASS  wc;
        ::ZeroMemory(&wc, sizeof(wc));
        wc.style         = 0;
        wc.lpfnWndProc   = TPhysWndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = 0;
        wc.hInstance     = m_hDllInst;
        wc.hIcon         = NULL;
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName  =  NULL;
        wc.lpszClassName = pszNULLMClassName;
        ::RegisterClass(&wc);

        //
        // Create the main window.
        //
        m_hwnd = ::CreateWindow(
            pszNULLMClassName,    // See RegisterClass() call.    
            NULL,                // It's invisible!                  
            0,                    // Window style.                
            0,                    // Default horizontal position.
            0,                    // Default vertical position.      
            0,                    // Default width.                  
            0,                    // Default height.                  
            NULL,                // No parent.                      
            NULL,                // No menu.
            m_hDllInst,            // This instance owns this window.
            NULL                // Pointer not needed.              
        );
        if (NULL == m_hwnd)
        {
            ERROR_OUT(( "Failed to create wnd"));
            return(TPHYS_RESULT_FAIL);
        }

        // rc = g_lpfnPTPhysicalInit(TPhysDriverCallback, NULL);
        ASSERT(TPHYS_SUCCESS == rc);
    }
   
    return rc;
}

//////////////////////////////////////////////////////////////////////////////////
// TPhysTerminate                                                                
//                                                                                
// The node controller is shutting down                                            
// Destroy our window and clean up transports.                                    
//////////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysTerminate(void)
{
    TRACE_OUT(("TPhysTerminate"));

    if (! m_fInitialized)
    {
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    //
    // Clean up the PSTN transport
    //
    // g_lpfnPTPhysicalCleanup();

    //
    // Destroy the window
    //
    if (NULL != m_hwnd)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    m_pfnCallback = NULL;
    m_nTransportID = 0;
    m_fInitialized = FALSE;
    
    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysConnectRequest                                                        
//                                                                            
// The node controller wants to place a call and has determined that it        
// first needs a physical modem connection.  Make a call and flag an        
// outgoing call so that when the call comes active we can tell the modem    
// transport to begin negotiation.                                            
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysConnectRequest(LPSTR pszComPort)
{
    TPhysicalError  rc = TPHYS_SUCCESS;
    HANDLE          hCommLink;
    DCB             dcb;
    DWORD           dwWritten;

    TRACE_OUT(("TPhysConnectRequest"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("NULL MODEM OOB not initialized"));
        return TPHYS_RESULT_NOT_INITIALIZED;
    }

    //
    // Select a comm port for the call.
    //
    if (CALL_STATE_IDLE == m_Line.eCallState || CALL_STATE_DROP == m_Line.eCallState)
    {
        //
        // Also prime our local copy of the conninfo structure for use in callbacks
        //
        m_Line.connInfo.resultCode   = 0;
        m_Line.connInfo.connectionID = m_nConnectionID;
    }
    else
    {
        ERROR_OUT(("No comm port is available"));
        return TPHYS_RESULT_COMM_PORT_BUSY;
    }

    // lonchanc: From now on, we can bail out thru the common exit point
    // because the cleanup checks for m_fCommPortInUse.

    //
    // Only alow one at at time
    //
    // lonchanc: g_COMM_Thread_Users is starting from -1
    // why can we simply use a flag???
    if (m_fCommPortInUse)
    {
        ERROR_OUT(("TPhysConnectRequest: Waiting for a previous null mode connection"));
        rc = TPHYS_RESULT_WAITING_FOR_CONNECTION;
        goto bail;
    }
    m_fCommPortInUse = TRUE;

    //
    // Open the comm port
    //
    hCommLink = ::CreateFile(pszComPort,
                             GENERIC_READ | GENERIC_WRITE,
                             0,                    // exclusive access
                             NULL,                 // no security attrs
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, // overlapped I/O
                             NULL );
    if (hCommLink == INVALID_HANDLE_VALUE)
    {
        ERROR_OUT(("TPhysConnectRequest: CreateFile failed. err=%d", ::GetLastError()));
        rc = TPHYS_RESULT_COMM_PORT_BUSY;
        goto bail;
    }

    m_Line.hCommLink = hCommLink;

    //
    // remember the default timeouts
    //
    ::GetCommTimeouts(hCommLink, &m_DefaultTimeouts);


    //
    // Let the other side know that we are trying to connect
    //
    if (! ::EscapeCommFunction(hCommLink, SETDTR))
    {
        ERROR_OUT(("TPhysConnectRequest: Unable to Set DTR: err=%d", ::GetLastError()));
    }

    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    m_Overlapped.hEvent = m_hevtOverlapped;
    m_dwEventMask = 0;

    ::ResetEvent(m_hevtOverlapped);

    if (! ::WriteFile(hCommLink, g_szNULLMStartString, sizeof(g_szNULLMStartString),
                      &dwWritten, &m_Overlapped))
    {
        DWORD dwErr = ::GetLastError();
        if (ERROR_IO_PENDING != dwErr)
        {
            ERROR_OUT(("TPhysConnectRequest: WriteFile failed. err=%d", dwErr));
            ::ResetEvent(m_hevtOverlapped);
            rc = TPHYS_RESULT_COMM_PORT_BUSY;
            goto bail;
        }
        else
        {
            DWORD dwWait = ::WaitForSingleObject(m_hevtOverlapped, INFINITE);
            BOOL fRet = ::GetOverlappedResult(hCommLink, &m_Overlapped, &dwWritten, TRUE);
            ASSERT(fRet);
            ASSERT(dwWritten == sizeof(g_szNULLMStartString));
        }
    }
    else
    {
        ASSERT(dwWritten == sizeof(g_szNULLMStartString));
    }

    ::ResetEvent(m_hevtOverlapped);

    //
    // Get the default dcb
    //
    ::ZeroMemory(&dcb, sizeof(dcb));
    ::GetCommState(hCommLink, &dcb);
    dcb.BaudRate = 19200;    // Default: BaudRate

    //
    // Set our state so we can get notification in the comm port
    //
    dcb.DCBlength = sizeof(DCB);
    dcb.fBinary = 1;                        // binary mode, no EOF check 
    dcb.fParity = 0;                        // enable parity checking 
    dcb.fOutxCtsFlow = 1;                   // CTS output flow control 
    dcb.fOutxDsrFlow = 0;                   // DSR output flow control 
    dcb.fDtrControl = DTR_CONTROL_ENABLE;   // DTR flow control type 
    dcb.fDsrSensitivity = 0;                // DSR sensitivity 
    dcb.fTXContinueOnXoff = 0;              // XOFF continues Tx 
    dcb.fOutX = 0;                          // XON/XOFF out flow control 
    dcb.fInX = 0;                           // XON/XOFF in flow control 
    dcb.fErrorChar = 0;                     // enable error replacement 
    dcb.fNull = 0;                          // enable null stripping 
    dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;// RTS flow control 
    dcb.XonLim = 0;                         // transmit XON threshold 
    dcb.XoffLim = 0;                        // transmit XOFF threshold 
    dcb.fErrorChar = 0;                     // enable error replacement 
    dcb.fNull = 0;                          // enable null stripping 
    dcb.fAbortOnError = 0;                  // abort reads/writes on error 
    ::SetCommState(hCommLink, &dcb);

    ::PurgeComm(hCommLink, PURGE_TXABORT | PURGE_RXABORT | PURGE_TXCLEAR | PURGE_RXCLEAR);

    m_Line.eCallState = CALL_STATE_MAKE;
    m_Line.hevtCall = m_hevtOverlapped;
    m_Line.pstnHandle = (PHYSICAL_HANDLE) hCommLink;
    m_Line.fCaller = TRUE;

    if (! ::SetCommMask(hCommLink,
                EV_RXCHAR |         // Any Character received
                EV_CTS |            // CTS changed state
                EV_DSR |            // DSR changed state
                EV_RLSD|            // RLSD changed state
                EV_RXFLAG))         // Certain character
    {
        ERROR_OUT(("TPhysConnectRequest:  Unable to SetCommMask: err=%d", ::GetLastError()));
    }

    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
    m_Overlapped.hEvent = m_hevtOverlapped;
    m_dwEventMask = 0;

    ::ResetEvent(m_hevtOverlapped);

    if (! ::WaitCommEvent(hCommLink, &m_dwEventMask, &m_Overlapped))
    {
        DWORD dwErr = ::GetLastError();
        if (ERROR_IO_PENDING != dwErr)
        {
            ERROR_OUT(("TPhysConnectRequest: WaitCommEvent failed, err=%d", dwErr));
            m_fCommPortInUse = FALSE;
        }
    }

#if 1
    WorkerThreadProc();
#else
    //
    // If the comm thread doesn't exist, create it now.
    //
    // lonchanc: I am not sure that the thread will exist, because
    // the while loop inside the thread will exit if m_fCommPortInUse is false.
    // If m_fCommPortInUse is true, then we should bail out already.
    //
    ASSERT(NULL == m_hThread);

    //
    // We need to create another thread that will wait on comm events.
    //
    m_hThread = ::CreateThread(NULL, 0, TPhysWorkerThreadProc, this, 0, &m_dwThreadID);
    ASSERT(NULL != m_hThread);
#endif

bail:

    return(rc);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysDisconnect                                                                                                                      
//                                                                              
// The node controller wants us to bring the call down now. We must first   
// ask the transports to close down their physicall connection.                 
//                                                                              
// Note that in the case of the PSTN transport we use a NOWAIT call which   
// completes syncronously.  Because we will not get a follow on confirm         
// we simulate one from here.  If we switch to using WAIT mode then             
// take the event generation code out!                                          
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysDisconnect(void)
{
    TRACE_OUT(("TPhysDisconnect"));

    if (! m_fInitialized)
    {
        ERROR_OUT(( "Not initialised"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    TRACE_OUT(("Disconnect call, state %u", m_Line.eCallState));

    //
    // Otherwise it must be a pstn call in progress so end that.  Note  
    // that NC may still think it is MODEM, but we still need to close  
    // PSTN.                                                            
    //
    // g_lpfnPTPhysicalDisconnectRequest(m_aLines[lineID].pstnHandle, TPHYSICAL_NO_WAIT);
    ::PostMessage(m_hwnd, WM_TPHYS_DISCONNECT_CONFIRM, (WPARAM) this, m_Line.pstnHandle);

    //
    // close the comport
    //
    DropCall();

    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// TPhysListen/TPhysUnlisten                                                
//                                                                              
// NULLMMAN does very little with listen/unlisten, just sets a state variable 
// that is interrogated to see if we should accept incoming calls.              
//                                                                            
// NOTE - This is different from the Listen/Unlisten that is used to tell   
// the PSTN transport about the presence of an incoming call.                   
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CNullModem::TPhysListen(void)
{
    TRACE_OUT(("TPhysListen"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("TPhysListen: not initialized"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    m_fListening = TRUE;

    return(TPHYS_SUCCESS);
}

TPhysicalError CNullModem::TPhysUnlisten(void)
{
    TRACE_OUT(("TPhysUnlisten"));

    if (! m_fInitialized)
    {
        ERROR_OUT(("TPhysUnlisten: not initialized"));
        return(TPHYS_RESULT_NOT_INITIALIZED);
    }

    m_fListening = FALSE;

    return(TPHYS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
// DropCall - close the comm port
/////////////////////////////////////////////////////////////////////////////
void CNullModem::DropCall(void)
{
    TRACE_OUT(("DropCall"));

    //
    // close the device handle                                              
    //
    if (NULL != m_Line.hCommLink)
    {
        CALL_STATE eCallState = m_Line.eCallState;
        m_Line.eCallState = CALL_STATE_IDLE;

        //
        // If this call is connected it is not using the comm thread
        //
        if (eCallState != CALL_STATE_CONNECTED)
        {
            m_fCommPortInUse = FALSE;
        }

        //
        // restore comm timeouts
        //
        SetCommTimeouts(m_Line.hCommLink, &m_DefaultTimeouts);

        TRACE_OUT(("Closing device handle %x", m_Line.hCommLink));
        ::CloseHandle(m_Line.hCommLink);
        m_Line.hCommLink = NULL;
    }
}


//////////////////////////////////////////////////////////////////////////////
//                                                                              
// FUNCTION: PSTNCallback                                                       
//                                                                              
// DESCRIPTION:                                                                 
//                                                                              
// PSTN callback function, called by the PSTN driver with the resuts of         
// TPhysical operations                                                         
//                                                                              
// See MCATTPRT.H for definitions of the parameters                             
//                                                                              
//////////////////////////////////////////////////////////////////////////////
TPhysicalError CALLBACK TPhysDriverCallback(USHORT msg, ULONG lParam, void *userData)
{
    TRACE_OUT(("NULLM_PSTNCallback"));
    TRACE_OUT(("Hit TPhysical callback, %x %lx %lx", msg, lParam, userData));

    CNullModem *p = (CNullModem *) userData;
    BOOL fRet = ::PostMessage(p->GetHwnd(), msg, (WPARAM) p, lParam);
    ASSERT(fRet);

    return TPHYS_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          
// FUNCTION:TPhysWndProc                                                      
//                                                                          
// Window procedure used to decouple callback requests                      
//                                                                          
//////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK TPhysWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNullModem *p = (CNullModem *) wParam;
    if (uMsg >= WM_APP)
    {
        return p->TPhysProcessMessage(uMsg, lParam);
    }
    return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
}


LRESULT CNullModem::TPhysProcessMessage(UINT uMsg, LPARAM lParam)
{
    USHORT      rc;
    USHORT      reason;
    ULONG       status;
    LINE_INFO  *pLine;

    if (WM_TPHYS_STATUS_INDICATION == uMsg)
    {
        return 0;
    }
    
    ASSERT(lParam == (LPARAM) m_Line.pstnHandle);

    switch (uMsg)
    {
    case WM_TPHYS_CONNECT_INDICATION:
        TRACE_OUT(("got a WM_TPHYS_CONNECT_INDICATION"));

        m_Line.connInfo.resultCode = TPHYS_RESULT_INUSE;
        m_Line.eCallState = CALL_STATE_CONNECTED;

        if (NULL != m_pfnCallback)
        {
            (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
        }
        break;

    case WM_TPHYS_CONNECT_CONFIRM:
        //
        // The transport has connected OK!  We will take the line   
        // back when the transport pulls DTR down                   
        //
        TRACE_OUT(("got a WM_TPHYS_CONNECT_CONFIRM"));
        m_Line.connInfo.resultCode = TPHYS_RESULT_SUCCESS_ALTERNATE;
        m_Line.eCallState = CALL_STATE_CONNECTED;

        if (NULL != m_pfnCallback)
        {
            (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
        }
        break;

    case WM_TPHYS_DISCONNECT_INDICATION:
    case WM_TPHYS_DISCONNECT_CONFIRM:
        //
        // If the disconnect is the result of a failed connect request  
        // then tell the NC of the failure (Otherwise it is a           
        // successful disconnect)                                       
        //
        if (WM_TPHYS_DISCONNECT_INDICATION == uMsg)
        {
            TRACE_OUT(("WM_TPHYS_DISCONNECT_INDICATION, %ld", lParam));
        }
        else
        {
            TRACE_OUT(("WM_TPHYS_DISCONNECT_CONFIRM, %ld", lParam));
        }
        if ((m_Line.eCallState == CALL_STATE_MAKE)   ||
            (m_Line.eCallState == CALL_STATE_ANSWER) ||
            (m_Line.eCallState == CALL_STATE_CONNECTED))
        {
            TRACE_OUT(( "T120 connection attempt has failed"));
            if (m_Line.fCaller)
            {
                m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;
                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
                }
            }
            DropCall();
        }
        else
        {
            //
            // The transport has disconnected OK.  We can take the line 
            // back as soon as the unlisten returns                     
            //
            TRACE_OUT(("T120 has disconnected - unlistening"));
            if (! m_Line.fCaller)
            {
                // g_lpfnPTPhysicalUnlisten(m_Line.pstnHandle);
            }
            else
            {
                //
                // We only drop the call for outgoing requests - leave  
                // incoming calls to drop when the line goes down       
                //
                DropCall();
            }
        }
        break;
    }
    
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
// SetConnectedPort                                                        
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
void CNullModem::SetConnectedPort(void)
{
    DCB     dcb;

    TRACE_OUT(("SetConnectedPort"));

    ::ZeroMemory(&dcb, sizeof(dcb));

    //
    //  Set comm mask and state
    //
    ::SetCommMask(m_Line.hCommLink, 0);    // RLSD changed state

    ::GetCommState(m_Line.hCommLink, &dcb);
    dcb.DCBlength = sizeof(DCB);
    dcb.fBinary = 1;           // binary mode, no EOF check 
    dcb.fOutxDsrFlow = 0;      // DSR output flow control 
    dcb.fDsrSensitivity = 0;   // DSR sensitivity 
    dcb.fTXContinueOnXoff = 0; // XOFF continues Tx 
    dcb.fOutX = 0;             // XON/XOFF out flow control 
    dcb.fInX = 0;              // XON/XOFF in flow control 
    dcb.fErrorChar = 0;        // enable error replacement 
    dcb.fNull = 0;             // enable null stripping 
    dcb.XonLim = 0;            // transmit XON threshold 
    dcb.XoffLim = 0;           // transmit XOFF threshold 
    ::SetCommState(m_Line.hCommLink, &dcb);
}

//////////////////////////////////////////////////////////////////////////////
// WaitForConnection                                                    
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
BOOL CNullModem::WaitForConnection(void)
{
    BOOL fRet = FALSE;

    TRACE_OUT(("WaitForConnection"));

    while (TRUE)
    {
        DWORD dwWait = ::WaitForSingleObject(m_hevtOverlapped, COMM_PORT_TIMEOUT);
        TRACE_OUT(("WaitForConnection: WaitForSingleObject returns %d", dwWait));

        ::ResetEvent(m_hevtOverlapped);

        if (dwWait == WAIT_ABANDONED || dwWait == WAIT_TIMEOUT || dwWait == WAIT_FAILED)
        {
            DropCall();
            m_fCommPortInUse = FALSE;
            ERROR_OUT(("WaitForConnection: Unable to WaitCommEvent: error = %d", ::GetLastError()));
            goto Failure;
        }

        ASSERT(m_hevtOverlapped == m_Line.hevtCall);
        if (CALL_STATE_MAKE != m_Line.eCallState && CALL_STATE_ANSWER != m_Line.eCallState)
        {
            ERROR_OUT(("WaitForConnection: Got a bad event = %d", m_hevtOverlapped));
            goto Failure;
        }

        TRACE_OUT(("WaitForConnection: m_dwEventMask = %d", m_dwEventMask));
        switch (m_Line.eCallState)
        {
        case CALL_STATE_MAKE:
            {
                //
                // The other side was connected and cleared DTR
                //
                if (m_dwEventMask & (EV_RXCHAR))
                {
                    ::EscapeCommFunction(m_Line.hCommLink, CLRDTR);
                    ::EscapeCommFunction(m_Line.hCommLink, SETDTR);
                    SetConnectedPort();
                    m_Line.fCaller = FALSE;
                    goto Success;
                }
                //
                // The other side just connected
                //
                else
                if(m_dwEventMask & (EV_DSR | EV_RLSD | EV_CTS))
                {
                    //
                    // Change the state of this connection so we dont get here again
                    //
                    m_Line.eCallState = CALL_STATE_ANSWER;

                    //
                    // Wait sometime so the other side can transition to the wait state
                    //
                    ::Sleep(2000);
                    
                    //
                    // Tell the other side we connected before
                    //
                    ::EscapeCommFunction(m_Line.hCommLink, SETBREAK);

                    ::ZeroMemory(&m_Overlapped, sizeof(m_Overlapped));
                    m_Overlapped.hEvent = m_Line.hevtCall;
                    m_dwEventMask = 0;

                    ::ResetEvent(m_Overlapped.hEvent);

                    if (! ::WaitCommEvent(m_Line.hCommLink, &m_dwEventMask, &m_Overlapped))
                    {
                        DWORD dwErr = ::GetLastError();
                        if (ERROR_IO_PENDING != dwErr)
                        {
                            ERROR_OUT(("TPhysConnectRequest:  Unable to WaitCommEvent: error = %d", dwErr));
                            DropCall();
                            goto Failure;
                        }
                    }
                }
            }
            break;
            
        case CALL_STATE_ANSWER:
            {
                ::EscapeCommFunction(m_Line.hCommLink, CLRBREAK);
                SetConnectedPort();
                goto Success;
            }
            break;
        }
    } // while

Success:

    fRet = TRUE;

Failure:

    return fRet;
}

//////////////////////////////////////////////////////////////////////////////
// COMMThread                                                            
//                                                                        
// Waits for comm port changes                                            
//////////////////////////////////////////////////////////////////////////////
DWORD __stdcall TPhysWorkerThreadProc(void *lParam)
{
    return ((CNullModem *) lParam)->WorkerThreadProc();
}


DWORD CNullModem::WorkerThreadProc(void)
{
    ULONG    rc = 0;
    ULONG    dwResult;

    TRACE_OUT(("TPhysWorkerThreadProc"));

    while (m_fCommPortInUse)
    {
        //
        // Wait for connection to happen
        //
        if (WaitForConnection())
        {
            SetBuffers();
            SetTimeouts();

            //
            // Call T120 physicall request
            //
            if (m_Line.fCaller)
            {
                // rc = g_lpfnPTPhysicalConnectRequest(0, // CALL_CONTROL_MANUAL
                //                        &m_Line.hCommLink, NULL, &m_Line.pstnHandle);
            }
            else
            {
                m_Line.connInfo.connectionID = m_nConnectionID;
                m_Line.connInfo.resultCode = TPHYS_SUCCESS;

                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_INDICATION, &m_Line.connInfo, m_nTransportID);
                }

                // rc = g_lpfnPTPhysicalListen(0, // CALL_CONTROL_MANUAL
                //                        &m_Line.hCommLink, NULL, &m_Line.pstnHandle);
            }
            
            if (rc != 0)
            {
                TRACE_OUT(( "Failed COMM connect, rc %d",rc));
                m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;

                if (NULL != m_pfnCallback)
                {
                    (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
                }

                DropCall();
            }
            else
            {
                m_Line.eCallState = CALL_STATE_CONNECTED;
                m_Line.connInfo.resultCode = TPHYS_SUCCESS;

                //
                // This comm port doesn't need the thread anymore
                //
                m_fCommPortInUse = FALSE;
            }
        }
        else
        {
            TRACE_OUT(( "Failed COMM connect, rc %d",rc));
            m_Line.connInfo.resultCode = TPHYS_RESULT_CONNECT_FAILED;

            if (NULL != m_pfnCallback)
            {
                (*m_pfnCallback)(WM_TPHYS_CONNECT_CONFIRM, &m_Line.connInfo, m_nTransportID);
            }
            
            //
            // Something went wrong in the wait, get out of the loop
            //
            break;
        }
    }        

    //
    // We are going down.
    //
    if (NULL != m_hThread)
    {
        ::CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    return 0;
}


void CNullModem::SetBuffers(void)
{
    BOOL fRet = ::SetupComm(m_Line.hCommLink, /* rx */ 10240, /* tx */ 1024);
    ASSERT(fRet);
}


void CNullModem::SetTimeouts(void)
{
    COMMTIMEOUTS    com_timeouts;
    ::ZeroMemory(&com_timeouts, sizeof(com_timeouts));
    com_timeouts.ReadIntervalTimeout = 10;
    com_timeouts.ReadTotalTimeoutMultiplier = 0;
    com_timeouts.ReadTotalTimeoutConstant = 100;
    com_timeouts.WriteTotalTimeoutMultiplier = 0;
    com_timeouts.WriteTotalTimeoutConstant = 10000;
    BOOL fRet = ::SetCommTimeouts(m_Line.hCommLink, &com_timeouts);
    ASSERT(fRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\messages.cpp ===
/* file: messages.cpp */

#include "mbftpch.h"

#include "osshelp.hpp"
#include "mbft.hpp"
#include "messages.hpp"
#include "mbftapi.hpp"


MBFTMsg::~MBFTMsg(void)
{
}


MCSSendDataIndicationMsg::MCSSendDataIndicationMsg
(
    T120ChannelID       wChannelId,
    T120Priority        iPriority,
    T120UserID          SenderID,
    LPBYTE              lpBuffer,
    ULONG               ulDataLength,
    BOOL                IsUniformSendData
)
:
    MBFTMsg(EnumMCSSendDataIndicationMsg),
    m_wChannelId(wChannelId),
    m_iPriority(iPriority),
    m_SenderID(SenderID),
    m_lpBuffer(lpBuffer),
    m_ulDataLength(ulDataLength),
    m_IsUniformSendData(IsUniformSendData)
{
}

MBFTPDUMsg::MBFTPDUMsg
(
    T120ChannelID       wChannelId,
    T120Priority        iPriority,
    T120UserID          SenderID,
    LPGENERICPDU        lpNewPDU,
    BOOL                IsUniformSendData,
    MBFTPDUType         PDUType,
    LPSTR               lpDecodedBuffer
)
:
    MBFTMsg(EnumGenericMBFTPDUMsg),
    m_wChannelId(wChannelId),
    m_iPriority(iPriority),
    m_SenderID(SenderID),
    m_lpNewPDU(lpNewPDU),
    m_IsUniformSendData(IsUniformSendData),
    m_PDUType(PDUType),
    m_lpDecodedBuffer(lpDecodedBuffer)
{
}

MBFTPDUMsg::~MBFTPDUMsg(void)
{
    delete m_lpDecodedBuffer;
    delete m_lpNewPDU;
}


CreateSessionMsg::CreateSessionMsg
(
    MBFT_SESSION_TYPE   iSessionType,
    MBFTEVENTHANDLE     EventHandle,
    T120SessionID       SessionID,
    T120ChannelID       wControlChannel,
    T120ChannelID       wDataChannel,
    T120UserID          SenderID,
    MBFTFILEHANDLE      FileHandle
)
:
    MBFTMsg(EnumCreateSessionMsg),
    m_iSessionType(iSessionType),
    m_SessionID(SessionID),
    m_EventHandle(EventHandle),
    m_ControlChannel(wControlChannel),
    m_DataChannel(wDataChannel),
    m_SenderID(SenderID),
    m_FileHandle(FileHandle)
{
}


SubmitFileSendMsg::SubmitFileSendMsg
(
	T120UserID			uidReceiver,
	T120NodeID			nidReceiver,
    LPCSTR              pszFilePath,
    MBFTFILEHANDLE      nFileHandle,
    MBFTEVENTHANDLE     EventHandle,
    BOOL                bCompressFiles
)
:
    MBFTMsg(EnumSubmitFileSendMsg),
	m_nUserID(uidReceiver),
	m_nNodeID(nidReceiver),
    m_pszFilePath((LPSTR) pszFilePath),
    m_nFileHandle(nFileHandle),
    m_EventHandle(EventHandle),
    m_bCompressFiles(bCompressFiles)
{
}

SubmitFileSendMsg::~SubmitFileSendMsg(void)
{
    delete  m_pszFilePath;
}

FileOfferNotifyMsg::FileOfferNotifyMsg
(
    MBFTEVENTHANDLE     EventHandle,
    T120UserID          SenderID,
	T120NodeID			NodeID,
    MBFTFILEHANDLE      hFile,
    LPCSTR              lpszFilename,
    ULONG               FileSize,
    time_t              FileDateTime,
    BOOL                bAckNeeded
)
:
    MBFTMsg(EnumFileOfferNotifyMsg),
    m_SenderID(SenderID),
	m_NodeID(NodeID),
    m_EventHandle(EventHandle),
    m_FileSize(FileSize),
    m_hFile(hFile),
    m_FileDateTime(FileDateTime),
    m_bAckNeeded(bAckNeeded)
{
    ::lstrcpynA(m_szFileName, lpszFilename, sizeof(m_szFileName));
}


FileTransferControlMsg::FileTransferControlMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    LPCSTR              lpszDirectory,
    LPCSTR              lpszFileName,
    FileTransferControl iControlCommand
)
:
    MBFTMsg(EnumFileTransferControlMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_ControlCommand(iControlCommand)
{
    if(lpszDirectory)
    {
        ::lstrcpynA(m_szDirectory, lpszDirectory, sizeof(m_szDirectory));
#ifdef BUG_INTL
        ::AnsiToOem(m_szDirectory, m_szDirectory);
#endif
    }
    else
    {
        m_szDirectory[0] = '\0';
    }

    if(lpszFileName)
    {
        ::lstrcpynA(m_szFileName, lpszFileName, sizeof(m_szFileName));
#ifdef BUG_INTL
        ::AnsiToOem(m_szFileName, m_szFileName);
#endif
    }
    else
    {
        m_szFileName[0] = '\0';
    }
}

FileTransmitMsg::FileTransmitMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    ULONG               FileSize,
    ULONG               BytesTransmitted,
    int                 iTransmitStatus,
    T120UserID          iUserID,
    BOOL                bIsBroadcastEvent
)
:
    MBFTMsg(EnumFileTransmitMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_FileSize(FileSize),
    m_BytesTransmitted(BytesTransmitted),
    m_TransmitStatus(iTransmitStatus),
    m_UserID(iUserID),
    m_bIsBroadcastEvent(bIsBroadcastEvent)
{
}

FileErrorMsg::FileErrorMsg
(
    MBFTEVENTHANDLE     EventHandle,
    MBFTFILEHANDLE      hFile,
    int                 iErrorType,
    int                 iErrorCode,
    BOOL                bIsLocalError,
    T120UserID          iUserID,
    BOOL                bIsBroadcastEvent,
	const char*			pFileName,
	ULONG				nFileSize
)
:
    MBFTMsg(EnumFileErrorMsg),
    m_EventHandle(EventHandle),
    m_hFile(hFile),
    m_ErrorCode(iErrorCode),
    m_ErrorType(iErrorType),
    m_bIsLocalError(bIsLocalError),
    m_UserID(iUserID),
    m_bIsBroadcastEvent(bIsBroadcastEvent)
{
		::ZeroMemory(&m_stFileInfo, sizeof(m_stFileInfo));
		if (pFileName)
		{
			::lstrcpyn(m_stFileInfo.szFileName, pFileName, sizeof(m_stFileInfo.szFileName));
			m_stFileInfo.lFileSize = nFileSize;
		}
}

PeerMsg::PeerMsg
(
    T120UserID          NodeID,
    T120UserID          MBFTPeerID,
    BOOL                bIsLocalPeer,
    BOOL                bIsProsharePeer,
    LPCSTR              lpszAppKey,
    BOOL                bPeerAdded,
    T120SessionID       SessionID
)
:
    MBFTMsg(EnumPeerMsg),
    m_NodeID(NodeID),
    m_MBFTPeerID(MBFTPeerID),
    m_bIsProsharePeer(bIsProsharePeer),
    m_bIsLocalPeer(bIsLocalPeer),
    m_MBFTSessionID(SessionID),
    m_bPeerAdded(bPeerAdded)
{
    if(lpszAppKey)
    {
        ::lstrcpynA(m_szAppKey, lpszAppKey, sizeof(m_szAppKey));
    }
    else
    {
        m_szAppKey[0] = '\0';
    }
}


PeerDeletedMsg::~PeerDeletedMsg(void)
{
    delete m_lpPeerData;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\nullmdm.h ===
///////////////////////////////////////////////////////////////////////////////
//
// Header defining Null Modem structures and prototypes                       
//                                                                          
// Copyright(c) Microsoft 1999
//                                                                          
///////////////////////////////////////////////////////////////////////////////

#ifndef _NULL_MODEM_H_
#define _NULL_MODEM_H_


/****************************************************************************/
/* These are valid return codes from TPhys API functions                    */
/*                                                                          */
/*  TPHYS_SUCCESS                                                           */
/*          The function executed properly, without error.                  */
/*  TPHYS_RESULT_INUSE                                                      */
/*          The TPhysInitialize() function failed because the transport     */
/*          is already initialized                                          */
/*  TPHYS_RESULT_FAIL                                                       */
/*          A general failure, such as a memory allocation error has        */
/*          caused the function to fail                                     */
/*  TPHYS_RESULT_NOT_INITIALIZED                                            */
/*          The user is attempting to use a function even though the        */
/*          TPhysInitialize() function failed.                              */
/*  TPHYS_RESULT_CONNECT_FAILED                                             */
/*          The TPhysConnectRequest() function failed.                      */
/*  TPHYS_CONNECT_RESPONSE_FAILED                                           */
/*          The TPhysConnectResponse() function failed.                     */
/*  TPHYS_RESULT_NOT_LISTENING                                              */
/*          The transport is not currently in a listening state             */
/*  TPHYS_RESULT_INVALID_CONNECTION                                         */
/*          The disconnect references an invalid connection handle          */
/*  TPHYS_RESULT_INVALID_ADDRESS                                            */
/*          The supplied address is invalid                                 */
/*  TPHYS_RESULT_CONNECT_REJECTED                                           */
/*          The node controller has successfully rejected ain incoming      */
/*          connection request.                                             */
/*  TPHYS_RESULT_SUCCESS_ALTERNATE                                          */
/*          The TPHYSICAL driver has connected, but with an alternate       */
/*          ADDRESS_TYPE as indicated in the connect_info in the response   */
/****************************************************************************/
typedef enum tagTPhysicalError
{
    TPHYS_SUCCESS                       =   0,
    TPHYS_RESULT_INUSE                  = 100,
    TPHYS_RESULT_FAIL                   = 101,
    TPHYS_RESULT_NOT_INITIALIZED        = 102,
    TPHYS_RESULT_CONNECT_FAILED         = 103,
    TPHYS_CONNECT_RESPONSE_FAILED       = 104,
    TPHYS_RESULT_NOT_LISTENING          = 105,
    TPHYS_RESULT_INVALID_CONNECTION     = 106,
    TPHYS_RESULT_INVALID_ADDRESS        = 107,
    TPHYS_RESULT_CONNECT_REJECTED       = 108,
    TPHYS_RESULT_SUCCESS_ALTERNATE      = 109,
    TPHYS_RESULT_COMM_PORT_BUSY         = 110,
    TPHYS_RESULT_WAITING_FOR_CONNECTION = 111,
}
    TPhysicalError;

/****************************************************************************/
/* Structure TPHYS_CALLBACK_INFO                                            */
/*                                                                          */
/* This structure is passed back as the second parameter to                 */
/* TPhysCallback for CONNECT notifications.  It contains all the            */
/* information necessary for the node controller to establish a logical     */
/* connection over the physical connection                                  */
/*                                                                          */
/* It is the responsibility of the node controller to format and present    */
/* this information to the transport driver during the in-band portion of   */
/* the physical connection establishment.                                   */
/*                                                                          */
/****************************************************************************/

#define TPHYS_MAX_ADDRESS_INFO  64

typedef struct tphys_connect_info
{
    UINT       connectionID;
    UINT       resultCode;
}
    TPHYS_CONNECT_INFO, * PTPHYS_CONNECT_INFO;

typedef UINT        PHYSICAL_HANDLE;

typedef void (CALLBACK *TPhysCallback) (WORD, PTPHYS_CONNECT_INFO, UINT);


// OOB compatible
#define WM_TPHYS_CONNECT_CONFIRM                   (WM_APP + 1)
#define WM_TPHYS_CONNECT_INDICATION                (WM_APP + 2)
#define WM_TPHYS_DISCONNECT_CONFIRM                (WM_APP + 3)
#define WM_TPHYS_DISCONNECT_INDICATION             (WM_APP + 4)
#define WM_TPHYS_STATUS_INDICATION                 (WM_APP + 5)



///////////////////////////////////////////////////////////////////////////////
// Structure containing state information for each NULLMODEM line
///////////////////////////////////////////////////////////////////////////////
typedef enum tagCALL_STATE
{
    CALL_STATE_IDLE         = 0,    // Call is idle
    CALL_STATE_MAKE         = 1,    // Establishing phone connection
    CALL_STATE_ANSWER       = 2,    // Answering a new call
    CALL_STATE_DROP         = 3,    // Dropping the phone connection
    CALL_STATE_CONNECTED    = 4,    // Phone connection established and passed onto TDD.
}
    CALL_STATE;

typedef struct tagLINE_INFO
{
    HANDLE              hevtCall;       // handle to the call
    HANDLE              hCommLink;      // handle to COM device - call
    BOOL                fCaller;        // FALSE = incoming call
    CALL_STATE          eCallState;     // one of the following states
    PHYSICAL_HANDLE     pstnHandle;
    TPHYS_CONNECT_INFO  connInfo;
}
    LINE_INFO;


#define MAX_NULLMODEM_LINES  4


class CNullModem
{
public:

    CNullModem(HINSTANCE);
    ~CNullModem(void);

    TPhysicalError TPhysInitialize(TPhysCallback callback, UINT transport_id);
    TPhysicalError TPhysTerminate(void);
    TPhysicalError TPhysListen(void);
    TPhysicalError TPhysUnlisten(void);
    TPhysicalError TPhysConnectRequest(LPSTR pszComPort);
    TPhysicalError TPhysDisconnect(void);

    DWORD WorkerThreadProc(void);
    HWND GetHwnd(void) { return m_hwnd; }
    LRESULT TPhysProcessMessage(UINT uMsg, LPARAM lParam);
    HANDLE GetCommLink(void) { return m_Line.hCommLink; }

    void SetBuffers(void);
    void SetTimeouts(void);

private:

    void DropCall(void);
    BOOL WaitForConnection(void);
    void SetConnectedPort(void);

private:

    BOOL            m_fInitialized;
    HINSTANCE       m_hDllInst;
    TPhysCallback   m_pfnCallback;
    BOOL            m_fListening;
    HWND            m_hwnd;
    UINT            m_nTransportID;          // ID required by RNC
    UINT            m_nConnectionID;         // next conn ID to allocate   
    LINE_INFO       m_Line;

    HANDLE          m_hThread;
    DWORD           m_dwThreadID;
    HANDLE          m_hevtOverlapped;
    DWORD           m_dwEventMask;
    BOOL            m_fCommPortInUse;
    OVERLAPPED      m_Overlapped;

    COMMTIMEOUTS    m_DefaultTimeouts;
};



LRESULT CALLBACK TPhysWndProc(HWND, UINT, WPARAM, LPARAM);
TPhysicalError CALLBACK TPhysDriverCallback(USHORT msg, ULONG parm, void *userData);

#define COMM_PORT_TIMEOUT 60000    //  60 seconds

#endif // _NULL_MODEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\osshelp.cpp ===
/* file: ossHelp.cpp */

#include "mbftpch.h"

#include "mbftper.h"
#include "osshelp.hpp"
#include "strutil.h"
#include <imcsapp.h>

static int  nInvalidNameCount = 0;
static char szProshareError[] = "ProshareError#";   /*Localization OK*/
static char szNonStandardCompression[] = "NonStandardCompression";  /*Localization OK*/

LONG CreateFileHeader(LPSTR pFileHeader, WORD pduType, ASNMBFTPDU* GenericPDUStruct);

    typedef struct
    {
        unsigned Second : 5;
        unsigned Minute : 6;
        unsigned Hour   : 5;
    } _DOS_Time;

    typedef struct
    {
        unsigned    Day     :   5;
        unsigned    Month   :   4;
        unsigned    Year    :   7;
    } _DOS_Date;



void GenericPDU::FreeMCSBuffer ()
{
        if (m_lpEncodedBuffer != NULL)
        {
                m_pAppletSession->FreeSendDataBuffer((void *) m_lpEncodedBuffer);
                m_lpEncodedBuffer = NULL;
        }
}

GenericPDU::~GenericPDU()
{
    if (m_pAppletSession != NULL)
    {
                FreeMCSBuffer();
    }
        else
        {
                delete m_lpEncodedBuffer;
                m_lpEncodedBuffer = NULL;
        }
}

FileOfferPDU::FileOfferPDU(LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                           LONG FileSize,time_t FileDateTime,
                           ChannelID wChannelID,BOOL bAcknowledge,int RosterInstance,
                           unsigned CompressionFlags,
                           LPCSTR lpszCompressionFormat,
                           int v42bisP1,
                           int v42bisP2) : GenericPDU()
{
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_FileHandle        = iFileHandle;
    m_FileSize          = FileSize;
    m_FileDateTime      = FileDateTime;
    m_DataChannelID     = wChannelID;
    m_bAcknowledge      = bAcknowledge;
    m_RosterInstance    = RosterInstance;
    m_CompressionFlags  = CompressionFlags;
    m_v42bisP1          = v42bisP1;
    m_v42bisP2          = v42bisP2;

    if(lpszCompressionFormat)
    {
        lstrcpyn(m_szCompressionFormat,lpszCompressionFormat,sizeof(m_szCompressionFormat));
    }
    else
    {
        lstrcpy(m_szCompressionFormat,"");
    }
}

unsigned long DecodeTimeDate(GeneralizedTime & ASNDateTime)
{
    _DOS_Time DecodeTime;
    _DOS_Date DecodeDate;

    if(ASNDateTime.utc)
    {
        //GMDateTime.tm_year  = ASNDateTime.year;

        DecodeDate.Year = ASNDateTime.year - 80;
    }
    else
    {

    }

    DecodeDate.Month        = ASNDateTime.month;
    DecodeDate.Day          = ASNDateTime.day;
    DecodeTime.Hour         = ASNDateTime.hour;
    DecodeTime.Minute       = ASNDateTime.minute;
    DecodeTime.Second       = ASNDateTime.second / 2;

    //DecodeTime.tm_isdst     = -1;                  //Make best guess about daylight savings...
    unsigned * Time, * Date;

    Time   =  (unsigned *)&DecodeTime;
    Date   =  (unsigned *)&DecodeDate;

    return(MAKELONG(*Time,*Date));
}





BOOL FileOfferPDU::Encode(void)
{

    ASNMBFTPDU GenericPDUStruct;
    ASNFilename_Attribute_ FileName;
    BOOL bReturn = FALSE;
        //struct tm * lpGMDateTime;

    ClearStruct(&GenericPDUStruct);
    ClearStruct(&FileName);

    GenericPDUStruct.choice = ASNfile_OfferPDU_chosen;

    FileName.value  = m_szFileName;

    //lpGMDateTime =  localtime(&m_FileDateTime);

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNfilesize = m_FileSize;

    unsigned Date = HIWORD(m_FileDateTime);
    unsigned Time = LOWORD(m_FileDateTime);

    _DOS_Date * lpDate  =  (_DOS_Date *)&Date;
    _DOS_Time * lpTime  =  (_DOS_Time *)&Time;

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.year   = lpDate->Year + 80;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.month  = lpDate->Month;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.day    = lpDate->Day;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.hour   = lpTime->Hour;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.minute = lpTime->Minute;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.second = lpTime->Second * 2;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNdate_and_time_of_creation.utc    = TRUE;


    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNfilename_present;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNdate_and_time_of_creation_present;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.bit_mask |= ASNfilesize_present;

    GenericPDUStruct.u.ASNfile_OfferPDU.file_header.ASNfilename     = &FileName;
    GenericPDUStruct.u.ASNfile_OfferPDU.file_handle     = (ASNHandle)m_FileHandle;
    GenericPDUStruct.u.ASNfile_OfferPDU.data_channel_id = m_DataChannelID;
    GenericPDUStruct.u.ASNfile_OfferPDU.ack_flag        = (ossBoolean)m_bAcknowledge;

    if(m_CompressionFlags & _MBFT_FILE_COMPRESSED)
    {
        if(m_CompressionFlags & _MBFT_STANDARD_COMPRESSSION)
        {
            GenericPDUStruct.u.ASNfile_OfferPDU.bit_mask |= ASNFile_OfferPDU_compression_specifier_present;

            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.choice = ASNv42bis_parameters_chosen;
            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.u.ASNv42bis_parameters.p1 = (unsigned short)m_v42bisP1;
            GenericPDUStruct.u.ASNfile_OfferPDU.ASNFile_OfferPDU_compression_specifier.u.ASNv42bis_parameters.p2 = (unsigned short)m_v42bisP2;
        }
    }

        //Specifying a non standard compression format is simply too complex and not worth the effort


    if(m_RosterInstance)
    {
        GenericPDUStruct.u.ASNfile_OfferPDU.bit_mask  |= ASNroster_instance_present;
        GenericPDUStruct.u.ASNfile_OfferPDU.ASNroster_instance = (unsigned short)m_RosterInstance;
    }

        // Get the needed size for the fileHeader                       
        LONG fileOfferPDUSize = CreateFileHeader(NULL, T127_FILE_OFFER << 8, &GenericPDUStruct);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[fileOfferPDUSize];
        if(m_lpEncodedBuffer)
        {
                m_lEncodedDataLength = CreateFileHeader(m_lpEncodedBuffer, (T127_FILE_OFFER << 8 | ASNroster_instance_present << 2), &GenericPDUStruct);
                bReturn = TRUE;
        }

    return(bReturn);
}


FileAcceptPDU::FileAcceptPDU(MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_FileHandle    = iFileHandle;
}

BOOL FileAcceptPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_PDU_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new  char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_PDU_HEADER* pBuff = (T127_FILE_PDU_HEADER*)m_lpEncodedBuffer;

        pBuff->pduType = T127_FILE_ACCEPT;
        pBuff->fileHandle = SWAPWORD(m_FileHandle);
        return TRUE;
        }
        return FALSE;
}

FileRejectPDU::FileRejectPDU(MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_FileHandle    = iFileHandle;
}

BOOL FileRejectPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_FileHandle);
        pBuff->errorCode = (ASNfile_not_required << 4);
        return(TRUE);
        }
        return FALSE;
}


FileAbortPDU::FileAbortPDU(ChannelID wDataChannelID,
                           ChannelID wTransmitterID,
                           MBFTFILEHANDLE iFileHandle) : GenericPDU()
{
    m_DataChannelID = wDataChannelID;
    m_TransmitterID = wTransmitterID;
    m_FileHandle    = iFileHandle;
}

BOOL FileAbortPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ABORT_PDU);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ABORT_PDU* pBuff = (T127_FILE_ABORT_PDU*)m_lpEncodedBuffer;
        pBuff->pduType_PresentFields = T127_FILE_ABORT |
                                                                                                                                        (WORD)((ASNdata_channel_id_present |
                                                                                                                                         ASNtransmitter_user_id_present |
                                                                                                                                         ASNFile_AbortPDU_file_handle_present |
                                                                                                                                         ASNreason_unspecified) << 10) ;
        pBuff->dataChannel = SWAPWORD(m_DataChannelID - 1);
        pBuff->transmitterUserId = SWAPWORD(m_TransmitterID - MIN_ASNDynamicChannelID);
        pBuff->fileHandle = SWAPWORD(m_FileHandle);

        return(TRUE);
    }
    return FALSE;
}

FileStartPDU::FileStartPDU(
                                                   LPCSTR lpszEncodedDataBuffer,
                                                   LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                           LONG FileSize,time_t FileDateTime,
                           LPCSTR lpszDataBuffer,int iDataLength,
                           BOOL bIsEOF,
                           unsigned CompressionFlags,
                           LPCSTR lpszCompressionFormat,
                           int v42bisP1,
                           int v42bisP2,
                                                   IT120AppletSession *pAppletSession)
:
    GenericPDU()
{
        m_pAppletSession = pAppletSession;
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_FileHandle    = iFileHandle;
    m_FileSize      = FileSize;
    m_FileDateTime  = FileDateTime;
    m_lpszDataBuffer= lpszDataBuffer;
    m_bIsEOF        = bIsEOF;
    m_DataLength    = iDataLength;
    m_lpEncodedBuffer = (LPSTR)lpszEncodedDataBuffer;
    m_CompressionFlags  = CompressionFlags;

    if(lpszCompressionFormat)
    {
        lstrcpyn(m_szCompressionFormat,lpszCompressionFormat,sizeof(m_szCompressionFormat));
    }
    else
    {
        lstrcpy(m_szCompressionFormat,"");
    }

    m_v42bisP1    = v42bisP1;
    m_v42bisP2    = v42bisP2;
}

BOOL FileStartPDU::Encode(void)
{
    ASNMBFTPDU GenericPDUStruct;
    ASNFilename_Attribute_ FileName;

    BOOL bReturn = FALSE;

    ClearStruct(&GenericPDUStruct);
    ClearStruct(&FileName);


    GenericPDUStruct.choice = ASNfile_StartPDU_chosen;

    FileName.value  = m_szFileName;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNfilesize = m_FileSize;

    //struct tm * lpGMDateTime =  localtime(&m_FileDateTime);

    unsigned Date = HIWORD(m_FileDateTime);
    unsigned Time = LOWORD(m_FileDateTime);

    _DOS_Date * lpDate  =  (_DOS_Date *)&Date;
    _DOS_Time * lpTime  =  (_DOS_Time *)&Time;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.year   = lpDate->Year + 80;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.month  = lpDate->Month;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.day    = lpDate->Day;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.hour   = lpTime->Hour;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.minute = lpTime->Minute;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.second = lpTime->Second * 2;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNdate_and_time_of_creation.utc    = TRUE;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNfilename_present;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNdate_and_time_of_creation_present;
    GenericPDUStruct.u.ASNfile_StartPDU.file_header.bit_mask |= ASNfilesize_present;

    GenericPDUStruct.u.ASNfile_StartPDU.file_header.ASNfilename     = &FileName;
    GenericPDUStruct.u.ASNfile_StartPDU.file_handle     = (ASNHandle)m_FileHandle;
    GenericPDUStruct.u.ASNfile_StartPDU.eof_flag        = (ossBoolean)m_bIsEOF;
    GenericPDUStruct.u.ASNfile_StartPDU.data.length     = (unsigned)m_DataLength;
    GenericPDUStruct.u.ASNfile_StartPDU.data.value      = (unsigned char FAR *)m_lpszDataBuffer;

    if(m_CompressionFlags & _MBFT_FILE_COMPRESSED)
    {
        if(m_CompressionFlags & _MBFT_STANDARD_COMPRESSSION)
        {
            GenericPDUStruct.u.ASNfile_StartPDU.bit_mask |= ASNFile_StartPDU_compression_specifier_present;

            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.choice = ASNv42bis_parameters_chosen;
            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.u.ASNv42bis_parameters.p1 = (unsigned short)m_v42bisP1;
            GenericPDUStruct.u.ASNfile_StartPDU.ASNFile_StartPDU_compression_specifier.u.ASNv42bis_parameters.p2 = (unsigned short)m_v42bisP2;
        }
    }

        //Specifying a non standard compression format is simply too complex!!!


        LPSTR pBuff = (LPSTR)GetDataBuffer();

        m_lpEncodedBuffer = pBuff;
        m_lEncodedDataLength = CreateFileHeader(pBuff, T127_FILE_START << 8, &GenericPDUStruct);

        pBuff += m_lEncodedDataLength;

        m_lEncodedDataLength += m_DataLength + sizeof(T127_FILE_START_DATA_BLOCK_HEADER);
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->EOFFlag = m_bIsEOF << 7;
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->CompressionFormat = 1;
        ((T127_FILE_START_DATA_BLOCK_HEADER*)pBuff)->FileDataSize = SWAPWORD((unsigned)m_DataLength);   // File size in bytes

        bReturn = TRUE;
                                
 return(bReturn);
}

FileDataPDU::FileDataPDU(
                                                LPCSTR lpszEncodedDataBuffer,
                                                MBFTFILEHANDLE iFileHandle,LPCSTR lpszDataBuffer,
                        int iDataLength,
                        BOOL bIsEOF,BOOL bAbort,
                                                IT120AppletSession *pAppletSession)
:
    GenericPDU(pAppletSession, (LPSTR)lpszEncodedDataBuffer),
    m_FileHandle (iFileHandle),
    m_lpszDataBuffer (lpszDataBuffer),
    m_bIsEOF (bIsEOF),
    m_DataLength (iDataLength),
    m_bAbort (bAbort)
{
}

BOOL FileDataPDU::Encode(void)
{
        m_lpEncodedBuffer = (LPSTR)GetDataBuffer();

        if(m_lpEncodedBuffer)
        {       T127_FILE_DATA_HEADER* pBuff = (T127_FILE_DATA_HEADER*)m_lpEncodedBuffer;
                pBuff->PDUHeader.pduType = T127_FILE_DATA;
                pBuff->PDUHeader.fileHandle =  SWAPWORD(m_FileHandle);
                pBuff->DataHeader.EOFFlag = (m_bIsEOF << 7) | (m_bAbort << 6);
                pBuff->DataHeader.FileDataSize =  SWAPWORD((unsigned)m_DataLength);
        }
        m_lEncodedDataLength = m_DataLength + sizeof(T127_FILE_DATA_HEADER);
        return (TRUE);
}


PrivateChannelInvitePDU::PrivateChannelInvitePDU(ChannelID wControlChannelID,
                                                 ChannelID wDataChannelID,
                                                 BOOL bIsBroadcast)  : GenericPDU()
{
    m_ControlChannelID  = wControlChannelID;
    m_DataChannelID     = wDataChannelID;
    m_bIsBroadcast = bIsBroadcast;
}

BOOL PrivateChannelInvitePDU::Encode(void)
{
    BOOL bReturn = FALSE;
        if(m_ControlChannelID >= MIN_ASNDynamicChannelID &&
                m_ControlChannelID <= MAX_ASNDynamicChannelID &&
                m_DataChannelID  >= MIN_ASNDynamicChannelID &&
                m_DataChannelID  <= MAX_ASNDynamicChannelID)
        {
                m_lEncodedDataLength = sizeof(T127_PRIVATE_CHANNEL_INVITE);
        DBG_SAVE_FILE_LINE
                m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
                T127_PRIVATE_CHANNEL_INVITE * pBuff = (T127_PRIVATE_CHANNEL_INVITE *)&m_lpEncodedBuffer[0];
                pBuff->pduType = T127_PRIVATE_CHANNEL_JOIN_INVITE;
                pBuff->ControlChannel = SWAPWORD(m_ControlChannelID - MIN_ASNDynamicChannelID);
                pBuff->DataChannel =  SWAPWORD(m_DataChannelID - MIN_ASNDynamicChannelID);
                pBuff->EncodingMode =   0;      // Encoding for acknowledge mode (FALSE) = 0
                                                                        // Encoding for broadcast mode (TRUE) = 0x80 10000000b

                bReturn = TRUE;
        }
        }

    return(bReturn);
}


PrivateChannelResponsePDU::PrivateChannelResponsePDU(ChannelID wControlChannelID,
                                                     BOOL bJoinedChannel)  : GenericPDU()
{
    m_ControlChannelID  = wControlChannelID;
    m_bJoinedChannel    = bJoinedChannel;
}

BOOL PrivateChannelResponsePDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_ControlChannelID - MIN_ASNDynamicChannelID);
        pBuff->errorCode = m_bJoinedChannel ?
                                           static_cast<BYTE>(ASNPrivate_Channel_Join_ResponsePDU_result_successful << 5) :
                                           static_cast<BYTE>(ASNinvitation_rejected << 5);
        return(TRUE);
    }
    return FALSE;
}


NonStandardPDU::NonStandardPDU(LPCSTR lpszEncodedDataBuffer,
                                                                LPCSTR lpszKey,LPVOID lpBuffer,
                                                                unsigned BufferLength,
                                                                IT120AppletSession *pAppletSession)
:
    GenericPDU()
{
        m_pAppletSession = pAppletSession;
    m_lpEncodedBuffer = (LPSTR)lpszEncodedDataBuffer;
        m_szKey = lpszKey;
    m_lpBuffer      = lpBuffer;
    m_BufferLength  = BufferLength;
}

BOOL NonStandardPDU::Encode(void)
{
        BOOL bReturn = FALSE;
        BYTE nonStandardPDUlenght = lstrlen(m_szKey) + 1;
        m_lEncodedDataLength = nonStandardPDUlenght + m_BufferLength + 4;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        LPSTR pBuff = m_lpEncodedBuffer;
        if(m_lpEncodedBuffer)
        {

                *pBuff++ = T127_MBFT_NONSTANDARD | ASNh221NonStandard_chosen;
                *pBuff++ = (BYTE)((nonStandardPDUlenght - 4) << 1);
            memcpy(pBuff,m_szKey,nonStandardPDUlenght);
                pBuff += nonStandardPDUlenght;
                if(m_BufferLength > 0x7F)
                {
                        *pBuff++ = LOBYTE(m_BufferLength) & 0x80;       // List of fields
                }
            *pBuff++ = (m_BufferLength &0x7F);
            memcpy(pBuff,m_lpBuffer,m_BufferLength);
            bReturn = TRUE;
        }
    }
    return(bReturn);
}

FileErrorPDU::FileErrorPDU(unsigned iFileHandle,int ErrorType,int ErrorCode)
{
    m_FileHandle        = iFileHandle;
    m_ErrorType         = ErrorType;
    m_ErrorCode         = ErrorCode;
}

BOOL FileErrorPDU::Encode(void)
{
        BYTE sizeOfErrorID = GetLengthFieldSize(m_ErrorCode);

        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER) + sizeOfErrorID;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_ERROR |(ASNFile_ErrorPDU_file_handle_present >> 6);
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_FileHandle);
        pBuff->errorCode = ((m_ErrorType == MBFT_INFORMATIVE_ERROR) ?
                                                                                                                                        ASNinformative :
                                                                                                                                        (m_ErrorType == MBFT_PERMANENT_ERROR) ?
                                                                                                                                        ASNpermanent_error : ASNtransient_error) << 5;
        return(TRUE);
    }
    return FALSE;
}

MBFTPDUType GenericPDU::DecodePDU
(
    LPSTR               lpEncodedBuffer,
    LONG                lBufferSize,
    class GenericPDU  **lplpGenericPDU,
    LPCSTR             *lpDecodedPDU,
    UserID              MBFTUserID,
    IT120AppletSession *pAppletSession
)
{
    MBFTPDUType ReturnPDUType = EnumUnknownPDU;
    int PDUNumber = ASNMBFTPDU_PDU;
    LPSTR lpDecodedBuffer = NULL;

    *lplpGenericPDU = NULL;

        // Filter the pdu, they are allways in 8 increments 0x0,0x8,0x10....
        if(lpEncodedBuffer)
        {
                switch((BYTE)*lpEncodedBuffer & 0xF8)
                {

                        case T127_FILE_DATA:
                        {
                                TRACE("DecodePDU: T127_FILE_DATA");

                                T127_FILE_DATA_HEADER* pBuff = (T127_FILE_DATA_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileDataPDU(      lpEncodedBuffer,
                                                                                                        SWAPWORD(pBuff->PDUHeader.fileHandle),
                                                                                                        (LPCSTR)lpEncodedBuffer + sizeof(T127_FILE_DATA_HEADER),
                                                                                                        SWAPWORD(pBuff->DataHeader.FileDataSize),
                                                                                                        pBuff->DataHeader.EOFFlag & 0x80 ? TRUE : FALSE,
                                                                                                        pBuff->DataHeader.EOFFlag & 0x40 ? TRUE : FALSE,
                                                                                                        pAppletSession);                                                        
                                ReturnPDUType  = EnumFileDataPDU;
                        }
                        break;
                
                        case T127_FILE_ACCEPT:
                        {
                                TRACE("DecodePDU: T127_FILE_ACCEPT");

                                T127_FILE_PDU_HEADER* pBuff = (T127_FILE_PDU_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileAcceptPDU(SWAPWORD(pBuff->fileHandle));

                                ReturnPDUType  = EnumFileAcceptPDU;

                        }
                        break;

                        case T127_FILE_REJECT:
                        {
                                TRACE("DecodePDU: T127_FILE_REJECT");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileRejectPDU(SWAPWORD(pBuff->PDUHeader.fileHandle));
                        
                                ReturnPDUType  = EnumFileRejectPDU;
                        }
                        break;

                        case T127_FILE_DENY:
                        {
                                TRACE("DecodePDU: T127_FILE_DENY");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileDenyPDU(SWAPWORD(pBuff->PDUHeader.fileHandle), pBuff->errorCode >> 4);
                                ReturnPDUType   = EnumFileDenyPDU;
                        }
                        break;

                        case T127_FILE_ERROR:
                        {
                                TRACE("DecodePDU: T127_FILE_ERROR");

                                T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)lpEncodedBuffer;
                                
                                int ErrorType = (pBuff->errorCode >> 5 == ASNpermanent_error) ?
                                                                        MBFT_PERMANENT_ERROR :
                                                                        (pBuff->errorCode >> 5 == ASNtransient_error) ?
                                                                        MBFT_TRANSIENT_ERROR : MBFT_INFORMATIVE_ERROR;


                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileErrorPDU(SWAPWORD(pBuff->PDUHeader.fileHandle), ErrorType, NULL);

                                ReturnPDUType  = EnumFileErrorPDU;
                        }
                        break;

                        case T127_FILE_ABORT:
                        {
                                TRACE("DecodePDU: T127_FILE_ABORT");
                                
                                T127_FILE_ABORT_PDU* pBuff = (T127_FILE_ABORT_PDU*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileAbortPDU(SWAPWORD(pBuff->dataChannel) + 1,
                                                                                           SWAPWORD(pBuff->transmitterUserId)+ MIN_ASNDynamicChannelID,
                                                                                           SWAPWORD(pBuff->fileHandle));

                                ReturnPDUType  = EnumFileAbortPDU;
                        }
                        break;


                        case T127_MBFT_NONSTANDARD:
                        {
                                TRACE("DecodePDU: T127_MBFT_NONSTANDARD");
                                LPSTR pBuff = lpEncodedBuffer + 1;
                                unsigned int  KeyLength = (((BYTE)*pBuff++) >> 1) + 4;
                                LPCSTR lpszKey  = pBuff;

                                pBuff += KeyLength;

                                unsigned int Length = 0;
                                if((BYTE)*pBuff & 0x80)
                                {
                                        Length = (*pBuff++ & 0x7F) << 8;        // List of fields
                                }
                                Length += *pBuff++;

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new NonStandardPDU(lpEncodedBuffer,lpszKey,pBuff,Length, pAppletSession);

                                ReturnPDUType  = EnumNonStandardPDU;
                        }
                        break;

                        case T127_FILE_OFFER:
                        {
                                TRACE("DecodePDU: T127_FILE_OFFER");
                                
                                BYTE lpszFileName[2*MAX_PATH];

                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                T127_FILE_OFFER_PDU * pFileOfferPDU = (T127_FILE_OFFER_PDU * )GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);
                                
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileOfferPDU(     (LPCSTR)lpszFileName,
                                                                                                        SWAPWORD(pFileOfferPDU->FileHandle),
                                                                                                        FileSize,
                                                                                                        FileDateTime,
                                                                                                        SWAPWORD(pFileOfferPDU->ChannelID) + 1,
                                                                                                        pFileOfferPDU->AckFlag ? TRUE : FALSE,
                                                                                                        SWAPWORD(pFileOfferPDU->RosterInstance),
                                                                                                        0,      // CompressionFlags,
                                                                                                        NULL,// lpszCompressionFormat,
                                                                                                        0,      // v42bisP1,
                                                                                                        0);     // v42bisP2

                                ReturnPDUType  = EnumFileOfferPDU;
                }
                        break;

                        case T127_FILE_START:
                        {
                                TRACE("DecodePDU: T127_FILE_START");

                                BYTE lpszFileName[2*MAX_PATH];
                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                BYTE * pBuff =  GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);
                                
                                T127_FILE_START_PDU * pFileStartPDU = (T127_FILE_START_PDU * ) pBuff;
                                T127_FILE_START_DATA_BLOCK_HEADER *pFileDataHeader = (T127_FILE_START_DATA_BLOCK_HEADER*)(pBuff + sizeof(T127_FILE_START_PDU));
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileStartPDU(lpEncodedBuffer,
                                                                                                (LPCSTR)lpszFileName,
                                                                                                SWAPWORD(pFileStartPDU->FileHandle),
                                                                                                FileSize,
                                                                                                FileDateTime,
                                                                                                (LPCSTR)pBuff + sizeof(T127_FILE_START_PDU)+sizeof(T127_FILE_START_DATA_BLOCK_HEADER),
                                                                                                SWAPWORD(pFileDataHeader->FileDataSize),
                                                                                                pFileDataHeader->EOFFlag ? TRUE : FALSE,
                                                                                                0,      // CompressionFlags,
                                                                                                NULL,// lpszCompressionFormat,
                                                                                                0,      // v42bisP1,
                                                                                                0,
                                                                                                pAppletSession);        // v42bisP2
                                ReturnPDUType  = EnumFileStartPDU;
                        }
                        break;

                        case T127_FILE_REQUEST:
                        {
                                TRACE("DecodePDU: T127_FILE_REQUEST");

                                BYTE lpszFileName[2*MAX_PATH];

                                LONG FileSize        = 0;
                                unsigned long FileDateTime  = (unsigned long)-1;
                                BYTE * pBuff =  GetFileInfo(lpEncodedBuffer, &lpszFileName[0], &FileSize, &FileDateTime);

                                T127_FILE_OFFER_PDU * pFileRequestPDU = (T127_FILE_OFFER_PDU * ) pBuff;

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new FileRequestPDU(NULL,
                                                                                        SWAPWORD(pFileRequestPDU->ChannelID) + 1,
                                                                                        SWAPWORD(pFileRequestPDU->FileHandle));

                                ReturnPDUType   = EnumFileRequestPDU;
                        }
                        break;

                        case T127_DIRECTORY_REQUEST:
                        {
                                TRACE("DecodePDU: T127_FILE_REQUEST");
                LPCSTR lpszPathName = NULL;

                DBG_SAVE_FILE_LINE
                *lplpGenericPDU = new DirectoryRequestPDU(lpszPathName);

                ReturnPDUType   = EnumDirectoryRequestPDU;
                        }
                        break;

                        case T127_MBFT_PRIVILEGE_ASSIGN:
                        {
                                TRACE("DecodePDU: T127_MBFT_PRIVILEGE_ASSIGN");

                                T127_PRIVILEGE_REQUEST_PDU *pBuff = (T127_PRIVILEGE_REQUEST_PDU*)lpEncodedBuffer;

                                unsigned PrivilegeWord = 0;
                                int Index;

                                for(Index = 0;Index < pBuff->nPrivileges; Index++)
                                {
                                        if(!(Index & 0x01))
                                        {
                                                PrivilegeWord <<=4;
                                                PrivilegeWord |= ((pBuff->privileges[Index >> 1] & 0xF0) >> 4);
                                        }
                                        else
                                        {
                                                PrivilegeWord |= (pBuff->privileges[Index >> 1] & 0x0F);
                                        }
                                }

                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU        = new PrivilegeAssignPDU(PrivilegeWord);

                                ReturnPDUType          = EnumPrivilegeAssignPDU;
                        }
                        break;

                        case T127_PRIVATE_CHANNEL_JOIN_INVITE:
                        {
                                TRACE("DecodePDU: T127_PRIVATE_CHANNEL_JOIN_INVITE");

                                T127_PRIVATE_CHANNEL_INVITE * pBuff = (T127_PRIVATE_CHANNEL_INVITE *)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new PrivateChannelInvitePDU(  SWAPWORD(pBuff->ControlChannel) + MIN_ASNDynamicChannelID,
                                                                                                                                SWAPWORD(pBuff->DataChannel) + MIN_ASNDynamicChannelID,
                                                                                                                                pBuff->EncodingMode);

                                ReturnPDUType  = EnumPrivateChannelInvitePDU;
                        }
                        break;

                        case T127_PRIVATE_CHANNEL_JOIN_RESPONSE:
                        {
                                TRACE("DecodePDU: T127_PRIVATE_CHANNEL_JOIN_RESPONSE");

                                T127_PRIVATE_CHANNEL_RESPONSE* pBuff = (T127_PRIVATE_CHANNEL_RESPONSE*)lpEncodedBuffer;
                DBG_SAVE_FILE_LINE
                                *lplpGenericPDU = new PrivateChannelResponsePDU(SWAPWORD(pBuff->ControlChannel) + MIN_ASNDynamicChannelID,
                                                                                        pBuff->Response >> 5 == ASNPrivate_Channel_Join_ResponsePDU_result_successful);

                                ReturnPDUType  = EnumPrivateChannelResponsePDU;
                        }
                        break;

                        case T127_DIRECTORY_RESPONSE:
                        case T127_MBFT_PRIVILEGE_REQUEST:
                        default:
                                TRACE("WARNING DecodePDU: Unknown PDU");

                        break;
                }
        }

 return(ReturnPDUType);
}

BOOL FileErrorPDU::ExtractErrorCode(LPCSTR lpszString,
                                    int iLength,
                                    int * lpAPIErrorCode)
{
    BOOL bCodeExtracted = FALSE;

    if(iLength > sizeof(szProshareError))
    {
        if(!_fmemcmp(lpszString,szProshareError,sizeof(szProshareError) - 1))
        {
            bCodeExtracted = TRUE;
            *lpAPIErrorCode = (int) DecimalStringToUINT(&lpszString[sizeof(szProshareError) - 1]);
        }
    }

    return(bCodeExtracted);
}

BOOL FileErrorPDU::XlatErrorCode(int * lpAPIErrorCode,int * lpMBFTErrorCode,
                                 BOOL bXlatToAPI)
{
 BOOL bMatchFound = FALSE;

 static struct
 {
 ASNErrorID         iMBFTErrorCode;
 MBFT_ERROR_CODE    iAPIErrorCode;
 } ErrorXlat[] =  {
   /*{ASNno_reason,                              iMBFT_UNKNOWN_ERROR},*/
   {ASNresponder_error,                        iMBFT_UNKNOWN_ERROR},
   {ASNsystem_shutdown,                        iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_problem,                 iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_bad_account,             iMBFT_UNKNOWN_ERROR},
   {ASNbft_management_security_not_passed,     iMBFT_UNKNOWN_ERROR},
   {ASNdelay_may_be_encountered,               iMBFT_UNKNOWN_ERROR},
   {ASNinitiator_error,                        iMBFT_UNKNOWN_ERROR},
   {ASNsubsequent_error,                       iMBFT_UNKNOWN_ERROR},
   {ASNtemporal_insufficiency_of_resources,    iMBFT_UNKNOWN_ERROR},
   {ASNaccess_request_violates_VFS_security,   iMBFT_UNKNOWN_ERROR},
   {ASNaccess_request_violates_local_security, iMBFT_UNKNOWN_ERROR},
   {ASNconflicting_parameter_values,           iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter_values,           iMBFT_UNKNOWN_ERROR},
   {ASNmandatory_parameter_not_set,            iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter,                  iMBFT_UNKNOWN_ERROR},
   {ASNduplicated_parameter,                   iMBFT_UNKNOWN_ERROR},
   {ASNillegal_parameter_type,                 iMBFT_UNKNOWN_ERROR},
   {ASNunsupported_parameter_types,            iMBFT_UNKNOWN_ERROR},
   {ASNbft_protocol_error,                     iMBFT_UNKNOWN_ERROR},
   {ASNbft_protocol_error_procedure_error,     iMBFT_UNKNOWN_ERROR},
   /*{ASNbft_protocol_error_functional_unit_err, iMBFT_UNKNOWN_ERROR},*/
   {ASNbft_protocol_error_corruption_error,    iMBFT_UNKNOWN_ERROR},
   {ASNlower_layer_failure,                    iMBFT_UNKNOWN_ERROR},
   {ASNtimeout,                                iMBFT_UNKNOWN_ERROR},
   {ASNbad_account,                            iMBFT_UNKNOWN_ERROR},
   {ASNinvalid_filestore_password,             iMBFT_UNKNOWN_ERROR},
   {ASNfilename_not_found,                     iMBFT_UNKNOWN_ERROR},
   {ASNinitial_attributes_not_possible,        iMBFT_UNKNOWN_ERROR},
   {ASNbad_attribute_name,                     iMBFT_UNKNOWN_ERROR},
   {ASNnon_existent_file,                      iMBFT_UNKNOWN_ERROR},
   {ASNfile_already_exists,                    iMBFT_UNKNOWN_ERROR},
   {ASNfile_cannot_be_created,                 iMBFT_FILE_ACCESS_DENIED},
   {ASNfile_busy,                              iMBFT_FILE_SHARING_VIOLATION},
   {ASNfile_not_available,                     iMBFT_FILE_SHARING_VIOLATION},
   {ASNfilename_truncated,                     iMBFT_UNKNOWN_ERROR},
   {ASNinitial_attributes_altered,             iMBFT_UNKNOWN_ERROR},
   {ASNambiguous_file_specification,           iMBFT_UNKNOWN_ERROR},
   {ASNattribute_non_existent,                 iMBFT_UNKNOWN_ERROR},
   {ASNattribute_not_supported,                iMBFT_UNKNOWN_ERROR},
   {ASNbad_attribute_value,                    iMBFT_UNKNOWN_ERROR},
   {ASNattribute_partially_supported,          iMBFT_UNKNOWN_ERROR},
   {ASNbad_data_element_type,                  iMBFT_UNKNOWN_ERROR},
   {ASNoperation_not_available,                iMBFT_UNKNOWN_ERROR},
   {ASNoperation_not_supported,                iMBFT_UNKNOWN_ERROR},
   {ASNoperation_inconsistent,                 iMBFT_UNKNOWN_ERROR},
   {ASNbad_write,                              iMBFT_FILE_IO_ERROR},
   {ASNbad_read,                               iMBFT_FILE_IO_ERROR},
   {ASNlocal_failure,                          iMBFT_UNKNOWN_ERROR},
   {ASNlocal_failure_filespace_exhausted,      iMBFT_INSUFFICIENT_DISK_SPACE},
   {ASNlocal_failure_data_corrupted,           iMBFT_UNKNOWN_ERROR},
   {ASNlocal_failure_device_failure,           iMBFT_UNKNOWN_ERROR},
   {ASNfuture_filesize_increased,              iMBFT_UNKNOWN_ERROR}};

    int Index;

    for(Index = 0;Index < (sizeof(ErrorXlat) / sizeof(ErrorXlat[0]));Index++)
    {
        if(bXlatToAPI)
        {
            if(ErrorXlat[Index].iMBFTErrorCode == *lpMBFTErrorCode)
            {
                *lpAPIErrorCode = ErrorXlat[Index].iAPIErrorCode;
                bMatchFound = TRUE;
            }
        }
        else
        {
            if(ErrorXlat[Index].iAPIErrorCode == *lpAPIErrorCode)
            {
                *lpMBFTErrorCode = ErrorXlat[Index].iMBFTErrorCode;
                bMatchFound = TRUE;
            }
        }

        if(bMatchFound)
        {
            break;
        }
    }

    if(!bMatchFound)
    {
        if(!bXlatToAPI)
        {
            *lpMBFTErrorCode = ASNno_reason;
        }
    }

    return(bMatchFound);
}

FileRequestPDU::FileRequestPDU(LPCSTR lpszFileName,ChannelID wDataChannelID,
                               unsigned uRequestHandle)
{
    if(lpszFileName)
    {
        lstrcpyn(m_szFileName,lpszFileName,sizeof(m_szFileName));
    }
    else
    {
        lstrcpy(m_szFileName,"");
    }

    m_DataChannelID     = wDataChannelID;
    m_uRequestHandle    = uRequestHandle;
}

BOOL FileRequestPDU::Encode(void)
{
    TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented FileRequestPDU::Encode***\n");
    return(FALSE);
}

FileDenyPDU::FileDenyPDU(unsigned uRequestHandle,unsigned uReason)
{
    m_uRequestHandle =     uRequestHandle;
    m_uReason        =     uReason;
}

BOOL FileDenyPDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(T127_FILE_ERROR_HEADER);
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
        if (NULL != m_lpEncodedBuffer)
        {
        T127_FILE_ERROR_HEADER* pBuff = (T127_FILE_ERROR_HEADER*)m_lpEncodedBuffer;
        pBuff->PDUHeader.pduType = T127_FILE_REJECT;
        pBuff->PDUHeader.fileHandle = SWAPWORD(m_uRequestHandle);
        pBuff->errorCode = m_uReason ?
                                                                 static_cast<BYTE>((ASN_enum2)m_uReason << 4) :
                                                                 static_cast<BYTE>(ASNFile_DenyPDU_reason_unspecified << 4);
        return(TRUE);
    }
    return FALSE;
}

DirectoryRequestPDU::DirectoryRequestPDU(LPCSTR lpszPathName)
{
    if(lpszPathName)
    {
        lstrcpyn(m_szPathName,lpszPathName,sizeof(m_szPathName));
    }
    else
    {
        lstrcpy(m_szPathName,"");
    }
}

BOOL DirectoryRequestPDU::Encode(void)
{
    TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented DirectoryRequestPDU::Encode***\n");
    return(FALSE);
}

DirectoryResponsePDU::DirectoryResponsePDU(unsigned uResult)
{
    m_uResult  =  uResult;
}

BOOL DirectoryResponsePDU::Encode(void)
{
        m_lEncodedDataLength = sizeof(BYTE)*2;
    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[m_lEncodedDataLength];
    if (NULL != m_lpEncodedBuffer)
    {
        m_lpEncodedBuffer[0] = T127_DIRECTORY_RESPONSE;
        m_lpEncodedBuffer[1] = m_uResult << 6;
        return(TRUE);
    }
    return FALSE;
}

PrivilegeRequestPDU::PrivilegeRequestPDU(unsigned wPrivilege)
{
    m_PrivilegeWord   =  wPrivilege;
}

BOOL PrivilegeRequestPDU::Encode(void)
{
    struct
    {
        MBFTPrivilege       iMBFTPrivilege;
        ASNMBFTPrivilege    iASNPrivilege;
    } static PrivilegeArray[] = {{EnumFileTransfer,ASNfile_transmit_privilege},
                                 {EnumFileRequest,ASNfile_request_privilege},
                               {EnumPrivateChannel,ASNcreate_private_privilege},
                               {EnumPriority,ASNmedium_priority_privilege},
                               {EnumAbort,ASNabort_privilege},
                               {EnumNonStandard,ASNnonstandard_privilege}};
        
        int Index;
    BYTE nPrivileges = 0;
        T127_PRIVILEGE_REQUEST_PDU * pBuff;
        BYTE privilege;

    DBG_SAVE_FILE_LINE
        m_lpEncodedBuffer = new char[sizeof(T127_PRIVILEGE_REQUEST_PDU)];
    if (NULL != m_lpEncodedBuffer)
    {
        pBuff = (T127_PRIVILEGE_REQUEST_PDU*)m_lpEncodedBuffer;

        for(Index = 0;Index < sizeof(PrivilegeArray) / sizeof(PrivilegeArray[0]);
            Index++)
        {
            if(m_PrivilegeWord & PrivilegeArray[Index].iMBFTPrivilege)
            {
                        privilege = PrivilegeArray[Index].iASNPrivilege;
                        if(!(nPrivileges & 0x01))
                        {
                                pBuff->privileges[nPrivileges >> 1] = 0;
                                privilege <<=4;
                        }
                pBuff->privileges[(nPrivileges >> 1)] |= privilege;
                nPrivileges++;
            }
        }

        pBuff->pduType = T127_MBFT_PRIVILEGE_REQUEST;
        pBuff->nPrivileges = nPrivileges;
        m_lEncodedDataLength = (LONG)(2 * sizeof(BYTE) +
                                                ((nPrivileges >> 1) * sizeof(BYTE)) +
                                                ((nPrivileges & 0x1) ? 1 : 0));

        return(TRUE);
    }
    return FALSE;
}

PrivilegeAssignPDU::PrivilegeAssignPDU(unsigned wPrivilege,UserID MBFTUserID)
{
    m_PrivilegeWord   =  wPrivilege;
    m_MBFTUserID      =  MBFTUserID;
}

BOOL PrivilegeAssignPDU::Encode(void)
{
        TRACE("*** WARNING (OSSHELP): Attempt to call unimplemented PrivilegeRequestPDU::Encode***\n");
    return(FALSE);
}

BOOL PrivilegeAssignPDU::XlatPrivilegeCode(unsigned iPrivilegeCode,unsigned * lpMBFTCode)
{
    BOOL bReturn = FALSE;

    struct
    {
        MBFTPrivilege       iMBFTPrivilege;
        ASNMBFTPrivilege    iASNPrivilege;
    } static PrivilegeArray[] = {{EnumFileTransfer,ASNfile_transmit_privilege},
                                 {EnumFileRequest,ASNfile_request_privilege},
                                 {EnumPrivateChannel,ASNcreate_private_privilege},
                                 {EnumPriority,ASNmedium_priority_privilege},
                                 {EnumAbort,ASNabort_privilege},
                                 {EnumNonStandard,ASNnonstandard_privilege}};

    int Index;

    for(Index = 0;Index < sizeof(PrivilegeArray) / sizeof(PrivilegeArray[0]);
        Index++)
    {
        if((unsigned)PrivilegeArray[Index].iASNPrivilege == iPrivilegeCode)
        {
            *lpMBFTCode = PrivilegeArray[Index].iMBFTPrivilege;
            bReturn = TRUE;
            break;
        }
    }

    return(bReturn);
}

unsigned PrivilegeAssignPDU::ConstructPrivilegeWord(LPVOID lpPrivilegeStruct,
                                                     ChannelID MBFTUserID)
{
    struct ASNMBFT_Privilege_AssignPDU::ASN_setof5 * lpNextSet = (struct ASNMBFT_Privilege_AssignPDU::ASN_setof5 *)lpPrivilegeStruct;
    struct ASNMBFT_Privilege_AssignPDU::ASN_setof5::temptag::ASN_setof4 * lpNextPrivilege;

    unsigned Temp,wPrivilegeWord;

    wPrivilegeWord = 0;

    while(lpNextSet)
    {
        if(lpNextSet->value.mbftID == MBFTUserID)
        {
            lpNextPrivilege = lpNextSet->value.mbft_privilege;

            while(lpNextPrivilege)
            {
                Temp = 0;
                XlatPrivilegeCode(lpNextPrivilege->value,&Temp);
                wPrivilegeWord |= Temp;
                lpNextPrivilege = lpNextPrivilege->next;
            }

            break;
        }

        lpNextSet = lpNextSet->next;
    }


    return(wPrivilegeWord);
}

FileEndAcknowledgePDU::FileEndAcknowledgePDU(int iFileHandle)
{
    m_FileHandle    =   iFileHandle;
}

BOOL FileEndAcknowledgePDU::Encode(void)
{
    TRACE("OSSHELP: Invalid attempt to encode FileEndAcknowledgePDU\n");
    return(FALSE);
}

ChannelLeavePDU::ChannelLeavePDU(ChannelID wControlChannelID,int iErrorCode)
{
    m_ChannelID =   wControlChannelID;
    m_ErrorCode        =   iErrorCode;
}

BOOL ChannelLeavePDU::Encode(void)
{
    TRACE("OSSHELP:Invalid attempt to encode ChannelLeavePDU\n");
    return(FALSE);
}





BYTE GetLengthFieldSize (ULONG length)
{
        BYTE size = 0;
        BOOL bLastBitSet = FALSE;
        do
        {
                bLastBitSet = ((BYTE)length & 0x80 ? TRUE : FALSE);
                size++;
        }while(length >>=8);

        if(bLastBitSet)
        {
                size++;
        }

        return (size);
}


BYTE * GetFirstField (BYTE * pBuff, WORD * bufferLength)
{
        BYTE * pFirstField = NULL;
        WORD fieldSize;
        BYTE * pBuffStart = pBuff;
        BYTE numberOfItems = *pBuff++;  
        
        while(numberOfItems --)
        {
                fieldSize = *pBuff++;
                if(fieldSize & 0x80)
                {
                        fieldSize = ((fieldSize & 0x7F) << 8) + *pBuff++;
                }
                if(!pFirstField)
                {
                        pFirstField = pBuff;
                }
                pBuff += fieldSize;
        }
        *bufferLength = (WORD)(pBuff - pBuffStart);
        return ( pFirstField);
}



VOID SetLengthField(BYTE * pBuff, BYTE sizeOfLength, ULONG lengthOfField)
{

        *pBuff = sizeOfLength;
        pBuff += sizeOfLength;
        
        while(sizeOfLength--)
        {
                *pBuff-- = LOBYTE(lengthOfField);
                lengthOfField >>=8;
        }
        
}

VOID GetFileHeaderSize (FILE_HEADER_INFO* fileHeader)
{

        // File Size
        fileHeader->nBytesForFileSize = GetLengthFieldSize(fileHeader->fileSize);

        // File Name
    fileHeader->fileNameSize = lstrlen(fileHeader->fileName);

        // Pdu Size
        fileHeader->pduSize = 1 +       // PDU type
                                        4 +             // File Header bitmask
                                        ((fileHeader->fileNameSize) > 0x7F ? 2 : 1) + // Number of bytes needed to express the size of the file name
                                        1 +             // File name size, if the file name is size is > 0x80, use the first four bits of the previous byte
                                        fileHeader->fileNameSize +
                                        1 +             // Size of data time info
                                        15 +    // yyyymmddhhmmss[utc]
                                        1 +             // number of bytes to hold filesize
                                        fileHeader->nBytesForFileSize + // file size
                                        (fileHeader->pduType == T127_FILE_START ? sizeof(T127_FILE_START_PDU) : sizeof(T127_FILE_OFFER_PDU) );

}


#define DEFAULT_LOCALE_LANGAUGE  (MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
BOOL  IsEnglishLocale(void)
{
        TCHAR szTemp[16];
        TCHAR szLang[16];

        ::LoadString(g_hDllInst, IDS_LANGNAME, szLang, 16);
    if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT,
                                        LOCALE_ILANGUAGE, szTemp, 16))
    {
                // Compare with Englist language
                return (!_StrCmpN(szLang, szTemp, 4));
    }
    return FALSE;
}

BOOL  HasDBCSCharacter(LPSTR pszStr)
{
        while (*pszStr)
        {
                if (IsDBCSLeadByte((BYTE)*pszStr))
                        return TRUE;
                pszStr = ::CharNext(pszStr);
        }
        return FALSE;
}

BYTE* GetFileInfo (LPSTR lpEncodedBuffer, BYTE * lpszFileName, LONG * FileSize, ULONG* FileDateTime )
{
        WORD fieldSize;
        BYTE * pFields;
        DWORD presentFields;
        T127_FILE_OFFER_PRESENT_FIELDS * ppresentFields;

        pFields =  (BYTE*)(lpEncodedBuffer + 1);

        // Present fields
        presentFields  = *pFields++ << 24;
        presentFields |= *pFields++ << 16;
        presentFields |= *pFields++ << 8;
        presentFields |= *pFields++;
        
        if(*lpEncodedBuffer == T127_FILE_START)
        {
                presentFields >>=4;
        }
        
        ppresentFields = (T127_FILE_OFFER_PRESENT_FIELDS *)&presentFields;
        
        // Skip version
        if ((*ppresentFields).wASNprotocol_version_present)
        {
                pFields += 2;   
        }

        // Get the File Name
        if ((*ppresentFields).wASNfilename_present)
        {
                BYTE * pOldField = pFields;
                BYTE * pFileName = GetFirstField(pFields, &fieldSize);
                BYTE fileNameSize = fieldSize - (BYTE)(pFileName - pOldField);
	            memcpy (lpszFileName, pFileName, fileNameSize);
                lpszFileName[fileNameSize] = 0;
                pFields += fieldSize;
        }

        // Skip actions
        if ((*ppresentFields).wASNpermitted_actions_present)
        {
                pFields += 2;
        }

        // Skip contents
        if ((*ppresentFields).wASNcontents_type_present)
        {
                pFields += 4;
        }

        // Get time of Creation
        if ((*ppresentFields).wASNdate_and_time_of_creation_present)
        {

                GeneralizedTime ASNDateTime;

                BYTE dateTime [SIZE_OF_DATE_TIME_STRING + 1];

                memcpy(dateTime,pFields, SIZE_OF_DATE_TIME_STRING + 1);
                
                // Get UTC
                fieldSize = *pFields;
                if(fieldSize == SIZE_OF_DATE_TIME_STRING + 1)
                {
                        ASNDateTime.utc = TRUE;
                        dateTime[fieldSize] = 0;
                }

                // Null terminate the date,time
                ASNDateTime.second = (short)DecimalStringToUINT((LPCTSTR)&dateTime[13]);
                dateTime[13] = 0;
                ASNDateTime.minute = (short)DecimalStringToUINT((LPCTSTR)&dateTime[11]);
                dateTime[11] = 0;
                ASNDateTime.hour = (short)DecimalStringToUINT((LPCTSTR)&dateTime[9]);
                dateTime[9] = 0;
                ASNDateTime.day = (short)DecimalStringToUINT((LPCTSTR)&dateTime[7]);
                dateTime[7] = 0;
                ASNDateTime.month = (short)DecimalStringToUINT((LPCTSTR)&dateTime[5]);
                dateTime[5] = 0;
                ASNDateTime.year = (short)DecimalStringToUINT((LPCTSTR)&dateTime[1]);
                *FileDateTime = DecodeTimeDate(ASNDateTime);

                pFields += fieldSize + 1;
        
        }

        // Skip time of last modification
        if ((*ppresentFields).wASNdate_and_time_of_last_modification_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
                
        }
        // Skip time of last read access
        if ((*ppresentFields).wASNdate_and_time_of_last_read_access_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Get File Size
        if((*ppresentFields).wASNfilesize_present)
        {
                fieldSize = *pFields++;
                while(fieldSize--)
                {
                        *FileSize <<= 8;
                        *FileSize += LOBYTE(*pFields++);
                }
        }

        // Skip Future File Size
        if((*ppresentFields).wASNfuture_filesize_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }


        // Skip ASNaccess_control_present
        if((*ppresentFields).wASNaccess_control_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;

        }

        // Skip private use itemns
        if((*ppresentFields).wASNprivate_use_present)
        {       
                if(*pFields & ASNdirect_reference_present)
                {       pFields++;
                        pFields += *pFields + 1;
                }
                if(*pFields & ASNindirect_reference_present)
                {       pFields++;
                        pFields += *pFields + 1;
                }
        }

        // Skip ASNstructure_present
        if((*ppresentFields).wASNstructure_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNapplication_reference_present
        if((*ppresentFields).wASNapplication_reference_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNmachine_present
        if((*ppresentFields).wASNmachine_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNoperating_system_present
        if((*ppresentFields).wASNoperating_system_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNrecipient_present
        if((*ppresentFields).wASNrecipient_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNcharacter_set_present
        if((*ppresentFields).wASNcharacter_set_present)
        {
                fieldSize = *pFields++;
                pFields += fieldSize;
        }

        // Skip ASNcompression_present
        if((*ppresentFields).wASNcompression_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNenvironment_present
        if((*ppresentFields).wASNenvironment_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip pathname
        if((*ppresentFields).wASNFileHeader_pathname_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        // Skip ASNuser_visible_string_present
        if((*ppresentFields).wASNuser_visible_string_present)
        {
                GetFirstField(pFields, &fieldSize);
                pFields += fieldSize;
        }

        return pFields;
}

LONG   CreateFileHeader(LPSTR pFileHeader, WORD pduType, ASNMBFTPDU* GenericPDUStruct)
{

        FILE_HEADER_INFO fileHeaderInfo;
        fileHeaderInfo.fileName = (((((*GenericPDUStruct).u).ASNfile_StartPDU).file_header).ASNfilename)->value;
        fileHeaderInfo.fileSize = ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNfilesize;
        fileHeaderInfo.pduType = HIBYTE(pduType);
        
        GetFileHeaderSize(&fileHeaderInfo);

        //
        // If we don't have a pointer to return the header, just return the size
        //
        if(pFileHeader == NULL)
        {
                return(fileHeaderInfo.pduSize);
        }


    MBFT_ERROR_CODE iErrorCode  = iMBFT_OK;
    MBFT_ERROR_TYPES iErrorType = MBFT_TRANSIENT_ERROR;

        
        LPSTR pFileOfferPDU = pFileHeader;


        // PDU Type
        *pFileOfferPDU++ = HIBYTE(pduType);

        DWORD fieldsInHeader = filename_present|date_and_time_of_creation_present|filesize_present;
        if(HIBYTE(pduType) == T127_FILE_START)
        {
                fieldsInHeader <<=4;
        }

        // Swap Dword
        fieldsInHeader =        ((fieldsInHeader & 0xFF000000) >> 24) +
                                                ((fieldsInHeader & 0x00FF0000) >> 8) +                                          
                                                ((fieldsInHeader & 0x0000FF00) << 8) +
                                                ((fieldsInHeader & 0x000000FF) << 24) |
                                                LOBYTE(pduType);
                                        
        // Present Fields in file header
        ((T127_FILE_HEADER*)pFileOfferPDU)->presentFields = fieldsInHeader;
        pFileOfferPDU +=sizeof(DWORD);

        // File Name
        *pFileOfferPDU++ = 0x01;
        if(fileHeaderInfo.fileNameSize > 0x7F)
        {
                *pFileOfferPDU++ = 0x80 | HIBYTE(fileHeaderInfo.fileNameSize);
                *pFileOfferPDU++ = LOBYTE(fileHeaderInfo.fileNameSize);
                
        }
        else
        {
                *pFileOfferPDU++ = (BYTE)fileHeaderInfo.fileNameSize;
        }
        lstrcpy((CHAR*)pFileOfferPDU, fileHeaderInfo.fileName);
        pFileOfferPDU += fileHeaderInfo.fileNameSize;
                

        // Date and time
        *pFileOfferPDU++ = SIZE_OF_DATE_TIME_STRING + 1;


        wsprintf((CHAR*)pFileOfferPDU, "%04d%02d%02d%02d%02d%02d",
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.year,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.month,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.day,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.hour,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.minute,
                                ((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_header).ASNdate_and_time_of_creation.second);

        ASSERT(SIZE_OF_DATE_TIME_STRING == lstrlen(pFileOfferPDU));
        pFileOfferPDU += SIZE_OF_DATE_TIME_STRING;
        *pFileOfferPDU++ = 90; // Base year

        // File size
        SetLengthField((BYTE*)pFileOfferPDU, fileHeaderInfo.nBytesForFileSize, fileHeaderInfo.fileSize);
        pFileOfferPDU += fileHeaderInfo.nBytesForFileSize + sizeof(BYTE);

        if(HIBYTE(pduType) == T127_FILE_START)
        {
                ((T127_FILE_START_PDU*)pFileOfferPDU)->FileHandle =     SWAPWORD((((*GenericPDUStruct).u).ASNfile_StartPDU).file_handle);
        }
        else
        {
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->RosterInstance = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).ASNroster_instance);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->ChannelID = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).data_channel_id - 1);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->FileHandle = SWAPWORD((((*GenericPDUStruct).u).ASNfile_OfferPDU).file_handle);
                ((T127_FILE_OFFER_PDU*)pFileOfferPDU)->AckFlag = 0x80;
        }
        
        return(fileHeaderInfo.pduSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\plugable.cpp ===
#include "mbftpch.h"

#if defined(TEST_PLUGABLE) && defined(_DEBUG)

#include "plugable.h"
#include "iplgxprt.h"
#include "it120xprt.h"
#include "nullmdm.h"

extern HINSTANCE g_hDllInst;

#define PLUGABLE_PORT_NUMBER    522  // ULS server port number

IT120PluggableTransport *g_pPluggableTransport = NULL;

#ifdef USE_SOCKET
SOCKET g_hListenSocket = INVALID_SOCKET;
#endif


typedef struct
{
    LPSTR   pszHostName;
#ifdef USE_SOCKET
    SOCKET  hSocket;
#else
    CNullModem *pModem;
#endif
    HANDLE  hevtRead;
    HANDLE  hevtWrite;
    HANDLE  hevtClose;
    char    szConnID[64];
}
    HOST_INFO;

#define NUM_HOSTS           2
#define TOP_PROVIDER_ID     0

ULONG g_nMyHostID = (ULONG) -1;
HOST_INFO g_aHostInfo[NUM_HOSTS];

char g_szMyHostName[64];

PLUGXPRT_PARAMETERS g_PluggableParams;

#ifdef USE_SOCKET
SOCKET CreateListenSocket(HWND hwnd);
SOCKET CreateConnectSocket(HWND hwnd, LPSTR pszHostName);
#else
CNullModem * CreateListenModem(void);
void CloseListenModem(CNullModem *p);
CNullModem * CreateConnectModem(LPSTR pszHostName);
void CloseConnectModem(CNullModem *p);
#endif


void OnPluggableBegin(HWND hwnd)
{
#ifdef USE_SOCKET
    WSADATA wsa_data;
    WORD version_requested = MAKEWORD (1,1);
    int error = ::WSAStartup(version_requested, &wsa_data);
    ASSERT(error == 0);
    g_hListenSocket = INVALID_SOCKET;
#endif

    ::ZeroMemory(g_aHostInfo, sizeof(g_aHostInfo));
    g_aHostInfo[0].pszHostName = "lonchanc";
    g_aHostInfo[1].pszHostName = "lon1";
    // g_aHostInfo[2].pszHostName = "lonchanc_nt";
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        g_aHostInfo[i].szConnID[0] = '\0';
#ifdef USE_SOCKET
        g_aHostInfo[i].hSocket = INVALID_SOCKET;
#else
        g_aHostInfo[i].pModem = NULL;
#endif
        g_aHostInfo[i].hevtRead = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        g_aHostInfo[i].hevtWrite = ::CreateEvent(NULL, FALSE, FALSE, NULL);;
        g_aHostInfo[i].hevtClose = ::CreateEvent(NULL, FALSE, FALSE, NULL);;
        ASSERT(g_aHostInfo[i].hevtRead && g_aHostInfo[i].hevtWrite && g_aHostInfo[i].hevtClose);
    }

    T120Error rc = ::T120_CreatePluggableTransport(&g_pPluggableTransport);
    ASSERT(T120_NO_ERROR == rc);

    g_pPluggableTransport->ResetConnCounter();
    g_pPluggableTransport->DisableWinsock();

    gethostname(g_szMyHostName, 64);
    TRACE_OUT(("OnPluggableScript: HostName=%s", g_szMyHostName));
    for (i = 0; i < NUM_HOSTS; i++)
    {
        if (! ::lstrcmpi(g_aHostInfo[i].pszHostName, g_szMyHostName))
        {
            g_nMyHostID = i;
            break;
        }
    }
    ASSERT(i < NUM_HOSTS);
    ASSERT(g_nMyHostID < NUM_HOSTS);

    ::ZeroMemory(&g_PluggableParams, sizeof(g_PluggableParams));
    g_PluggableParams.cbStructSize = sizeof(g_PluggableParams);
    g_PluggableParams.dwFlags = PSTN_PARAM__CALL_CONTROL |
                                PSTN_PARAM__READ_FILE_BUFFER_SIZE |
                                PSTN_PARAM__PHYSICAL_LAYER_SEND_BUFFER_SIZE |
                                PSTN_PARAM__PHSYICAL_LAYER_RECV_BUFFER_SIZE |
                                PSTN_PARAM__MAX_T200_TIMEOUT_COUNT_IN_Q922 |
                                PSTN_PARAM__T203_TIMEOUT_IN_Q922;
    g_PluggableParams.eCallControl = PLUGXPRT_PSTN_CALL_CONTROL_MANUAL;
    g_PluggableParams.cbReadFileBufferSize = 10240; // 10K
    g_PluggableParams.cbPhysicalLayerSendBufferSize = 1024; // 1K
    g_PluggableParams.cbPhysicalLayerReceiveBufferSize = 10240; // 10K
    g_PluggableParams.cMaximumT200TimeoutsInQ922 = 5;
    g_PluggableParams.nT203TimeoutInQ922 = 600;

    if (TOP_PROVIDER_ID == g_nMyHostID)
    {
        for (i = 0; i < NUM_HOSTS; i++)
        {
            if (i != g_nMyHostID)
            {
#ifdef USE_SOCKET
                g_aHostInfo[i].hSocket = ::CreateConnectSocket(hwnd, g_aHostInfo[i].pszHostName);
                ASSERT(INVALID_SOCKET != g_aHostInfo[i].hSocket);
#else
                g_aHostInfo[i].pModem = ::CreateConnectModem(g_aHostInfo[i].pszHostName);
                ASSERT(NULL != g_aHostInfo[i].pModem);
#endif

                HANDLE hCommLink = NULL;
#ifdef USE_SOCKET
                BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), (HANDLE) g_aHostInfo[i].hSocket,
#else
                BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), g_aHostInfo[i].pModem->GetCommLink(),
#endif
                                              ::GetCurrentProcess(), &hCommLink,
                                              0, FALSE, DUPLICATE_SAME_ACCESS);
                ASSERT(fRet);

                rc = g_pPluggableTransport->CreateConnection(
                            g_aHostInfo[i].szConnID,
                            PLUGXPRT_CALLER, // caller
                            hCommLink,
                            g_aHostInfo[i].hevtRead,
                            g_aHostInfo[i].hevtWrite,
                            g_aHostInfo[i].hevtClose,
                            FRAMING_LEGACY_PSTN,
                            &g_PluggableParams);
                ASSERT(T120_NO_ERROR == rc);
            }
        }
    }
    else
    {
#ifdef USE_SOCKET
        g_hListenSocket = ::CreateListenSocket(hwnd);
#else
        g_aHostInfo[i].pModem = ::CreateListenModem();
        ASSERT(NULL != g_aHostInfo[i].pModem);

        HANDLE hCommLink = NULL;
        BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), g_aHostInfo[i].pModem->GetCommLink(),
                                      ::GetCurrentProcess(), &hCommLink,
                                      0, FALSE, DUPLICATE_SAME_ACCESS);
        ASSERT(fRet);

        T120Error rc = g_pPluggableTransport->CreateConnection(
                                    g_aHostInfo[i].szConnID,
                                    PLUGXPRT_CALLEE, // callee
                                    hCommLink,
                                    g_aHostInfo[i].hevtRead,
                                    g_aHostInfo[i].hevtWrite,
                                    g_aHostInfo[i].hevtClose,
                                    FRAMING_LEGACY_PSTN,
                                    &g_PluggableParams);
        ASSERT(T120_NO_ERROR == rc);
#endif
    }
}


void OnPluggableEnd(void)
{
#ifdef USE_SOCKET
    if (INVALID_SOCKET != g_hListenSocket)
    {
        ::closesocket(g_hListenSocket);
    }
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        if (INVALID_SOCKET != g_aHostInfo[i].hSocket)
        {
            ::closesocket(g_aHostInfo[i].hSocket);
        }
    }
#else
    for (ULONG i = 0; i < NUM_HOSTS; i++)
    {
        if (i != g_nMyHostID)
        {
            CloseConnectModem(g_aHostInfo[i].pModem);
        }
        else
        {
            CloseListenModem(g_aHostInfo[i].pModem);
        }
        g_aHostInfo[i].pModem = NULL;
    }
    
#endif

    g_pPluggableTransport->EnableWinsock();
    g_pPluggableTransport->ReleaseInterface();
    g_pPluggableTransport = NULL;

#ifdef USE_SOCKET
    ::WSACleanup();
#endif
}


LRESULT OnPluggableSocket(HWND hwnd, WPARAM wParam, LPARAM lParam)
{
#ifdef USE_SOCKET
	/* This message is generated by WinSock */
	SOCKET hSocket = (SOCKET) wParam;
	ULONG event = WSAGETSELECTEVENT(lParam);
	ULONG error = WSAGETSELECTERROR(lParam);
    ULONG nIdx = (ULONG) -1;

    if (hSocket != g_hListenSocket)
    {
        for (ULONG i = 0; i < NUM_HOSTS; i++)
        {
            if (hSocket == g_aHostInfo[i].hSocket)
            {
                nIdx = i;
                break;
            }
        }
        ASSERT(nIdx < NUM_HOSTS);
    }
    else
    {
        nIdx = TOP_PROVIDER_ID;
    }

	/* We disconnect whenever a socket command generates an error message */
	if (error)
	{
		TRACE_OUT(("OnPluggableSocket: error %d on socket (%d). Event: %d", error, hSocket, event));	
	}
	
	/* We get FD_CLOSE when the socket is closed by the remote site. */
	if (event & FD_CLOSE)
	{
		TRACE_OUT(("OnPluggableSocket FD_CLOSE(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtClose);
	}
	
	/* We get FD_READ when there is data available for us to read. */
	if (event & FD_READ)
	{
		TRACE_OUT(("OnPluggableSocket FD_READ(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtRead);
	}

	/* We get FD_WRITE when there is space available to write data to WinSock */
	if (event & FD_WRITE)
	{
		TRACE_OUT(("OnPluggableSocket FD_WRITE(%d)", hSocket));
	    ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
	}

	/* We get FD_CONNECT when connecting to a remote site */
	if (event & FD_CONNECT)
	{
		TRACE_OUT(("OnPluggableSocket FD_CONNECT(%d)", hSocket));
        // ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
	}

	/* We get FD_ACCEPT when a remote site is connecting with us */
	if (event & FD_ACCEPT)
	{
		TRACE_OUT(("OnPluggableSocket FD_ACCEPT(%d)", hSocket));
        ASSERT(nIdx == TOP_PROVIDER_ID);

        SOCKADDR_IN socket_control;
        int size = sizeof(socket_control);
        g_aHostInfo[nIdx].hSocket = ::accept(g_hListenSocket, (struct sockaddr *) &socket_control, &size);
        ASSERT(INVALID_SOCKET != g_aHostInfo[nIdx].hSocket);

        int nRet = ::WSAAsyncSelect(g_aHostInfo[nIdx].hSocket, hwnd,
                                    WM_PLUGABLE_SOCKET, 
                                    FD_READ | FD_WRITE | FD_CLOSE | FD_CONNECT);
        ASSERT(SOCKET_ERROR != nRet);

        HANDLE hCommLink = NULL;
        BOOL fRet = ::DuplicateHandle(::GetCurrentProcess(), (HANDLE) g_aHostInfo[nIdx].hSocket,
                                      ::GetCurrentProcess(), &hCommLink,
                                      0, FALSE, DUPLICATE_SAME_ACCESS);
        ASSERT(fRet);

        T120Error rc = g_pPluggableTransport->CreateConnection(
                                    g_aHostInfo[nIdx].szConnID,
                                    PLUGXPRT_CALLEE, // callee
                                    hCommLink,
                                    g_aHostInfo[nIdx].hevtRead,
                                    g_aHostInfo[nIdx].hevtWrite,
                                    g_aHostInfo[nIdx].hevtClose,
                                    FRAMING_LEGACY_PSTN,
                                    &g_PluggableParams);
        ASSERT(T120_NO_ERROR == rc);

        // ::SetEvent(g_aHostInfo[nIdx].hevtWrite);
    }
#endif

    return 0;
}


/*	
 *	void CreateListenSocket (VOID)
 *	
 *	Functional Description
 *		This function sets up a listening socket.
 *	returns INVALID_SOCKET if there is any error.
 */
#ifdef USE_SOCKET
SOCKET CreateListenSocket(HWND hwnd)
{
	SOCKADDR_IN		socket_control;
	SOCKET          socket_number;

	// Create the listening socket.
	socket_number = ::socket(AF_INET, SOCK_STREAM, 0);
	ASSERT(INVALID_SOCKET != socket_number);

	// The listen socket only waits for FD_ACCEPT msgs.
	int nRet = ::WSAAsyncSelect(socket_number, hwnd, WM_PLUGABLE_SOCKET, FD_ACCEPT);
	ASSERT(SOCKET_ERROR != nRet);
	
	/*
	 * Load the socket control structure with the parameters necessary.
	 *	- Internet socket
	 *	- Let it assign any address to this socket
	 *	- Assign our port number
	 */
	socket_control.sin_family = AF_INET;
	socket_control.sin_addr.s_addr = INADDR_ANY;
	socket_control.sin_port = htons ( PLUGABLE_PORT_NUMBER );

	/* Issue the bind call */
	nRet = ::bind(socket_number, (LPSOCKADDR) &socket_control, sizeof(SOCKADDR_IN));
	ASSERT(SOCKET_ERROR != nRet);

	/*
	 * Issue a listen to WinSock to tell it we are willing to accept calls.
	 * This is a non-blocking listen, therefore we will receive FD_ACCEPT
	 * if someone is trying to call us.
	 */
	nRet =::listen(socket_number, 3 /* LISTEN_QUEUE_SIZE */);
	ASSERT(SOCKET_ERROR != nRet);

	return socket_number;
}
#else
CNullModem * CreateListenModem(void)
{
    DBG_SAVE_FILE_LINE
    CNullModem *p = new CNullModem(g_hDllInst);
    ASSERT(NULL != p);

    TPhysicalError rc;

    rc = p->TPhysInitialize(NULL, 1);
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysConnectRequest("COM1");
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysListen();
    ASSERT(TPHYS_SUCCESS == rc);

    return p;
}
void CloseListenModem(CNullModem *p)
{
    if (NULL != p)
    {
        TPhysicalError rc;

        rc = p->TPhysUnlisten();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysDisconnect();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysTerminate();
        ASSERT(TPHYS_SUCCESS == rc);

        delete p;
    }
}
#endif


#ifdef USE_SOCKET
SOCKET CreateConnectSocket(HWND hwnd, LPSTR pszHostName)
{
    SOCKET  socket_number;
	u_short uPort = PLUGABLE_PORT_NUMBER;
    PHOSTENT phe = NULL;
    SOCKADDR_IN socket_control;
    DWORD dwIPAddress;

    socket_number = ::socket(AF_INET, SOCK_STREAM, 0);
    ASSERT(INVALID_SOCKET != socket_number);

    /* Enable Tx and Rx messages to the window */
    int nRet = ::WSAAsyncSelect(socket_number, hwnd, WM_PLUGABLE_SOCKET,
                           FD_READ | FD_WRITE | FD_CLOSE);
    ASSERT(SOCKET_ERROR != nRet);

    // fill in other info in SockAddr
    ::ZeroMemory(&socket_control, sizeof(socket_control));
    socket_control.sin_family = AF_INET;
    socket_control.sin_port = htons (PLUGABLE_PORT_NUMBER);

    // get server's IP address
    dwIPAddress = ::inet_addr(pszHostName);
    if (dwIPAddress != INADDR_NONE)
    {
        *((PDWORD) &socket_control.sin_addr) = dwIPAddress;
    }
    else
    {
        phe = ::gethostbyname(pszHostName);
        ASSERT(NULL != phe);

        ::CopyMemory(&socket_control.sin_addr, phe->h_addr, phe->h_length);
    }

	/* Attempt a connection to the remote site */
	nRet = ::connect(socket_number, (const struct sockaddr *) &socket_control, sizeof(socket_control));
	ASSERT(SOCKET_ERROR != nRet || WSAEWOULDBLOCK == ::WSAGetLastError());

	return socket_number;
}
#else
CNullModem * CreateConnectModem(LPSTR pszHostName)
{
    DBG_SAVE_FILE_LINE
    CNullModem *p = new CNullModem(g_hDllInst);
    ASSERT(NULL != p);

    TPhysicalError rc;

    rc = p->TPhysInitialize(NULL, 1);
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysConnectRequest("COM1");
    ASSERT(TPHYS_SUCCESS == rc);

    rc = p->TPhysListen();
    ASSERT(TPHYS_SUCCESS == rc);

    return p;
}
void CloseConnectModem(CNullModem *p)
{
    if (NULL != p)
    {
        TPhysicalError rc;

        rc = p->TPhysUnlisten();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysDisconnect();
        ASSERT(TPHYS_SUCCESS == rc);

        rc = p->TPhysTerminate();
        ASSERT(TPHYS_SUCCESS == rc);

        delete p;
    }
}
#endif



#endif // TEST_PLUGABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\osshelp.hpp ===
#ifndef __OSSHELP_HPP__
#define __OSSHELP_HPP__

#include <windows.h>
#include <stdlib.h>
#include <it120app.h>


typedef enum tagMBFTPDUType
{
    EnumUnknownPDU,
    EnumFileOfferPDU,
    EnumFileAcceptPDU,
    EnumFileRejectPDU,
    EnumFileAbortPDU,
    EnumFileStartPDU,
    EnumFileDataPDU,
    EnumPrivateChannelInvitePDU,
    EnumPrivateChannelResponsePDU,
    EnumNonStandardPDU,
    EnumFileErrorPDU,
    EnumFileRequestPDU,
    EnumFileDenyPDU,
    EnumDirectoryRequestPDU,
    EnumDirectoryResponsePDU,
    EnumPrivilegeRequestPDU,
    EnumPrivilegeAssignPDU,
    EnumFileEndAcknowledgePDU,
    EnumChannelLeavePDU
}
    MBFTPDUType;


class GenericPDU
{
protected:

    LPSTR m_lpEncodedBuffer;
    LONG m_lEncodedDataLength;
    IT120AppletSession     *m_pAppletSession;

public:

    GenericPDU(IT120AppletSession *pAppletSession = NULL, LPCSTR lpszEncodedDataBuffer = NULL)
    :
        m_lpEncodedBuffer((LPSTR) lpszEncodedDataBuffer),
        m_lEncodedDataLength(0),
        m_pAppletSession(pAppletSession)
    {
    }
    ~GenericPDU(void);

    static MBFTPDUType GenericPDU::DecodePDU(LPSTR lpEncodedBuffer,LONG lBufferSize,
                                         class GenericPDU ** lplplpGenericPDU,
                                         LPCSTR * lpDecodedPDU,UserID MBFTUserID,
                                         IT120AppletSession *pAppletSession = NULL);

    void NULLDataBuffer(void) { m_lpEncodedBuffer = NULL; }
    LPCSTR GetBuffer(void) { return m_lpEncodedBuffer; }
    LONG GetBufferLength(void) { return m_lEncodedDataLength; }
    void FreeMCSBuffer (void);
    BOOL Encode(void);
};

typedef class GenericPDU FAR * LPGENERICPDU;

const unsigned  _MBFT_FILE_COMPRESSED           =   0x0001;
const unsigned  _MBFT_STANDARD_COMPRESSSION     =   0x0002;

class FileOfferPDU  :   public GenericPDU
{

 private:
    MBFTFILEHANDLE         m_FileHandle;
    LONG        m_FileSize;
    time_t      m_FileDateTime;
    ChannelID   m_DataChannelID;
    BOOL        m_bAcknowledge;
    int         m_RosterInstance;
    unsigned    m_CompressionFlags;
    int         m_v42bisP1;
    int         m_v42bisP2;
    char        m_szFileName[_MAX_PATH];
    char        m_szCompressionFormat[255];

 public:

    FileOfferPDU(LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                 LONG FileSize,time_t FileDateTime,
                 ChannelID wChannelID,
                 BOOL bAcknowledge,
                 int RosterInstance = 0,
                 unsigned CompressionFlags = 0,
                 LPCSTR lpszCompressionFormat = NULL,
                 int v42bisP1 = 0,
                 int v42bisP2 = 0);

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetFileName(void) { return m_szFileName; }
    BOOL GetAcknowledge(void) { return m_bAcknowledge; }
    LONG GetFileSize(void) { return m_FileSize; }
    time_t GetFileDateTime(void) { return m_FileDateTime; }
    int GetRosterInstance(void) { return m_RosterInstance; }
    unsigned GetCompressionFlags(void) { return m_CompressionFlags; }
    LPCSTR GetCompressionFormat(void) { return m_szCompressionFormat; }
    ChannelID   GetDataChannelID(void) { return m_DataChannelID; }
    int Getv42bisP1(void) { return m_v42bisP1; }
    int Getv42bisP2(void) { return m_v42bisP2; }
    BOOL Encode(void);
};

typedef class FileOfferPDU FAR * LPFILEOFFERPDU;

class FileAcceptPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    ChannelID m_DataChannelID;
    BOOL m_bAcknowledge;

 public:

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    FileAcceptPDU(MBFTFILEHANDLE iFileHandle);
    BOOL Encode(void);
};

typedef class FileAcceptPDU FAR * LPFILEACCEPTPDU;

class FileRejectPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;

 public:

    FileRejectPDU(MBFTFILEHANDLE iFileHandle);
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    BOOL Encode(void);
};

typedef class FileRejectPDU FAR * LPFILEREJECTPDU;

class FileAbortPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    ChannelID m_DataChannelID;
    ChannelID m_TransmitterID;

 public:

    FileAbortPDU(ChannelID wDataChannelID,
                 ChannelID wTransmitterID,
                 MBFTFILEHANDLE iFileHandle);

    MBFTFILEHANDLE    GetFileHandle(void) { return m_FileHandle; }
    ChannelID   GetDataChannelID(void) { return m_DataChannelID; }
    ChannelID   GetTransmitterID(void) { return m_TransmitterID; }

    BOOL Encode(void);
};

typedef class FileAbortPDU FAR * LPFILEABORTPDU;

class FileStartPDU   :   public GenericPDU
{
    MBFTFILEHANDLE    m_FileHandle;
    LONG        m_FileSize;
    time_t      m_FileDateTime;
    LPCSTR	m_lpszDataBuffer;
    BOOL        m_bIsEOF;
    LONG        m_DataLength;
    unsigned    m_CompressionFlags;
    int         m_v42bisP1;
    int         m_v42bisP2;
    char        m_szFileName[_MAX_PATH];
    char        m_szCompressionFormat[255];

public:

    FileStartPDU(LPCSTR lpszEncodedDataBuffer,
    		 LPCSTR lpszFileName, MBFTFILEHANDLE iFileHandle,
                 LONG FileSize,time_t FileDateTime,
                 LPCSTR lpszDataBuffer,int iDataLength,
                 BOOL bIsEOF,
                 unsigned CompressionFlags = 0,
                 LPCSTR lpszCompressionFormat = NULL,
                 int v42bisP1 = 0,
                 int v42bisP2 = 0,
                 IT120AppletSession *pAppletSession = NULL);

    LPCSTR GetFileName(void) { return m_szFileName; }
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetDataBuffer(void) { return m_lpszDataBuffer; }
    ULONG GetDataSize(void) { return (ULONG) m_DataLength; }
    BOOL GetIsEOF(void) { return m_bIsEOF; }
    LONG GetFileSize(void) { return m_FileSize; }
    unsigned GetCompressionFlags(void) { return m_CompressionFlags; }
    LPCSTR GetCompressionFormat(void) { return m_szCompressionFormat; }
    int Getv42bisP1(void) { return m_v42bisP1; }
    int Getv42bisP2(void) { return m_v42bisP2; }
    BOOL Encode(void);
};

typedef class FileStartPDU FAR * LPFILESTARTPDU;


class FileDataPDU   :   public GenericPDU
{
    MBFTFILEHANDLE m_FileHandle;
    BOOL     m_bIsEOF;
    BOOL     m_bAbort;
    LPCSTR	 m_lpszDataBuffer;
    LONG     m_DataLength;
    int      m_TotalFiles;
    int      m_FileIndex;

 public:

    FileDataPDU(LPCSTR lpszEncodedDataBuffer,
    			MBFTFILEHANDLE iFileHandle,
    			LPCSTR lpszDataBuffer,
                int iDataLength,
                BOOL bIsEOF,
                BOOL bAbort,
                IT120AppletSession *pAppletSession = NULL);

    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    LPCSTR GetDataBuffer(void) { return (LPCSTR) m_lpszDataBuffer; }
    ULONG GetDataSize(void) { return (ULONG) m_DataLength; }
    BOOL GetIsEOF(void) { return m_bIsEOF; }
    BOOL GetIsAbort(void) { return m_bAbort; }
    BOOL Encode(void);
};

typedef class FileDataPDU FAR * LPFILEDATAPDU;

class PrivateChannelInvitePDU   :   public GenericPDU
{
    ChannelID   m_ControlChannelID;
    ChannelID   m_DataChannelID;
    BOOL        m_bIsBroadcast;

 public:

    PrivateChannelInvitePDU(ChannelID wControlChannelID,
                            ChannelID wDataChannelID,
                            BOOL bIsBroadcast);

    ChannelID GetControlChannel(void) { return m_ControlChannelID; }
    ChannelID GetDataChannel(void) { return m_DataChannelID; }
    BOOL Encode(void);
};

typedef class PrivateChannelInvitePDU FAR * LPPRIVATECHANNELINVITEPDU;

class PrivateChannelResponsePDU   :   public GenericPDU
{
    ChannelID   m_ControlChannelID;
    BOOL        m_bJoinedChannel;

 public:

    PrivateChannelResponsePDU(ChannelID wControlChannelID,BOOL bJoinedChannel);
    ChannelID GetControlChannel(void) { return m_ControlChannelID; }
    BOOL GetWasChannelJoined(void) { return m_bJoinedChannel; }
    BOOL Encode(void);
};

typedef class PrivateChannelResponsePDU FAR * LPPRIVATECHANNELRESPONSEPDU;


class NonStandardPDU   :   public GenericPDU
{
	LPCSTR 		m_szKey;
    LPVOID      m_lpBuffer;
    unsigned    m_BufferLength;

public:

    NonStandardPDU(LPCSTR lpszEncodedDataBuffer,
    				LPCSTR lpszKey,
    				LPVOID lpBuffer,
    				unsigned BufferLength,
    				IT120AppletSession *pAppletSession = NULL);
    LPCSTR GetKey(void) { return m_szKey; }
    LPCSTR GetDataBuffer(void) { return (LPCSTR) m_lpBuffer; }
    ULONG GetDataSize(void) { return m_BufferLength; }
    BOOL Encode(void);
};

typedef class NonStandardPDU FAR * LPNONSTANDARDPDU;

class FileErrorPDU     :    public GenericPDU
{

private:

    MBFTFILEHANDLE    m_FileHandle;
    int         m_ErrorType;
    int         m_ErrorCode;

public:

    FileErrorPDU(unsigned iFileHandle,int iErrorType,int iErrorCode);
    MBFTFILEHANDLE GetFileHandle(void) { return m_FileHandle; }
    unsigned GetErrorType(void) { return m_ErrorType; }
    unsigned GetErrorCode(void) { return m_ErrorCode; }
    BOOL Encode(void);

    static BOOL ExtractErrorCode(LPCSTR lpszString,int iLength,
                                 int * lpAPIErrorCode);

    static BOOL XlatErrorCode(int * lpAPIErrorCode,
                              int * lpMBFTErrorCode,
                              BOOL bXlatToAPI);
};

typedef class FileErrorPDU FAR * LPFILEERRORPDU;


class FileRequestPDU    :       public GenericPDU
{

private:

    ChannelID   m_DataChannelID;
    unsigned    m_uRequestHandle;
    char        m_szFileName[_MAX_PATH];

public:

    FileRequestPDU(LPCSTR lpszFileName,ChannelID wDataChannelID,
                   unsigned uRequestHandle);

    unsigned GetRequestHandle(void) { return m_uRequestHandle; }
    BOOL Encode(void);
};

typedef class FileRequestPDU FAR * LPFILEREQUESTPDU;

class FileDenyPDU   :       public GenericPDU
{

private:

    unsigned    m_uRequestHandle;
    unsigned    m_uReason;

public:

    FileDenyPDU(unsigned uRequestHandle,unsigned uReason = 0);
    BOOL Encode(void);
};

typedef class FileDenyPDU FAR * LPFILEDENYPDU;

class DirectoryRequestPDU   :       public GenericPDU
{

private:

    char    m_szPathName[_MAX_PATH];

public:

    DirectoryRequestPDU(LPCSTR lpszPathName);
    BOOL Encode(void);
};

typedef class DirectoryRequestPDU FAR * LPDIRECTORYREQUESTPDU;

class DirectoryResponsePDU   :       public GenericPDU
{

private:

    unsigned    m_uResult;

public:

    DirectoryResponsePDU(unsigned uResult = 0);
    BOOL Encode(void);
};

typedef class DirectoryResponsePDU FAR * LPDIRECTORYRESPONSEPDU;

class PrivilegeRequestPDU   :       public GenericPDU
{

private:

    unsigned    m_PrivilegeWord;

public:

    enum MBFTPrivilege
    {
        EnumFileTransfer   = 0x0001,
        EnumFileRequest    = 0x0002,
        EnumPrivateChannel = 0x0004,
        EnumPriority       = 0x0008,
        EnumAbort          = 0x0010,
        EnumNonStandard    = 0x0020
    };

    PrivilegeRequestPDU(unsigned wPrivilege);
    BOOL Encode(void);
};

class PrivilegeAssignPDU   :       public GenericPDU
{

private:

    unsigned    m_PrivilegeWord;
    UserID      m_MBFTUserID;

public:

    enum MBFTPrivilege
    {
        EnumFileTransfer   = 0x0001,
        EnumFileRequest    = 0x0002,
        EnumPrivateChannel = 0x0004,
        EnumPriority       = 0x0008,
        EnumAbort          = 0x0010,
        EnumNonStandard    = 0x0020
    };

    PrivilegeAssignPDU(unsigned wPrivilege,UserID MBFTUserID = 0);
    BOOL Encode(void);

    static BOOL XlatPrivilegeCode(unsigned iPrivilegeCode,unsigned * lpMBFTCode);

    static unsigned ConstructPrivilegeWord(LPVOID lpStruct,
                                           ChannelID MBFTUserID);
    unsigned    GetPrivilegeWord(void) { return m_PrivilegeWord; }
};

typedef class PrivilegeAssignPDU FAR * LPPRIVILEGEASSIGNPDU;

class   FileEndAcknowledgePDU    :  public GenericPDU
{
private:

    MBFTFILEHANDLE     m_FileHandle;

public:

    FileEndAcknowledgePDU(int iFileHandle);
    BOOL Encode(void);

    MBFTFILEHANDLE    GetFileHandle(void) { return m_FileHandle; }
};

typedef class FileEndAcknowledgePDU FAR * LPFILEENDACKNOWLEDGEPDU;

class   ChannelLeavePDU   :  public GenericPDU
{
private:

    ChannelID   m_ChannelID;
    int         m_ErrorCode;

public:

    ChannelLeavePDU(ChannelID wControlChannelID,int iErrorCode);
    BOOL Encode(void);

    ChannelID   GetChannelID(void) { return m_ChannelID; }
    int         GetErrorCode(void) { return m_ErrorCode; }
};

typedef class ChannelLeavePDU FAR * LPCHANNELLEAVEPDU;

struct FileEndAcknowledgeStruct
{
    MBFTFILEHANDLE     m_FileHandle;
};

struct ChannelLeaveStruct
{
    ChannelID   m_ChannelID;
    int         m_ErrorCode;
};

#endif //__OSSHELP_HPP__



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\plugable.h ===
#if defined(TEST_PLUGABLE) && defined(_DEBUG)

#ifndef _FT_PLUGABLE_H_
#define _FT_PLUGABLE_H_

#define WM_PLUGABLE_SOCKET      (WM_APP + 0x601)


void OnPluggableBegin(HWND hwnd);
void OnPluggableEnd(void);

LRESULT OnPluggableSocket(HWND, WPARAM, LPARAM);



#endif // _FT_PLUGABLE_H_

#endif // TEST_PLUGABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ftapp.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\agrp.cpp ===
//
// AGRP.CPP
// Tool Attributes Display Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


// Class name
static const TCHAR szAGClassName[] = "WB_AGRP";

//
// Page Control child IDs
// Index is PGC_ value
//
static UINT_PTR g_uPageIds[NUM_PAGE_CONTROLS] =
{
    IDM_PAGE_FIRST,
    IDM_PAGE_PREV,
    IDM_PAGE_ANY,
    IDM_PAGE_NEXT,
    IDM_PAGE_LAST,
    IDM_PAGE_INSERT_AFTER
};



//
// WbAttributesGroup()
//
WbAttributesGroup::WbAttributesGroup(void)
{
    int             i;

    m_hwnd = NULL;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        m_uPageCtrls[i].hbmp = NULL;
        m_uPageCtrls[i].hwnd = NULL;
    }

    m_hPageCtrlFont = NULL;
    m_cxPageCtrls = DEFAULT_PGC_WIDTH;

    m_hwndFontButton = NULL;
}


//
// ~WbAttibutesGroup()
//
WbAttributesGroup::~WbAttributesGroup(void)
{
    int i;

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szAGClassName, g_hInstance);

    //
    // Delete control bitmaps
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        if (m_uPageCtrls[i].hbmp)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
            m_uPageCtrls[i].hbmp = NULL;
        }
    }

    if (m_hPageCtrlFont != NULL)
    {
        ::DeleteFont(m_hPageCtrlFont);
        m_hPageCtrlFont = NULL;
    }

}



//
// Create()
//
BOOL WbAttributesGroup::Create
(
    HWND    hwndParent,
    LPCRECT lpRect
)
{
    SIZE    size;
    RECT    rectCG;
    RECT    rectFSG;
    TCHAR   szFOBStr[256];
    HFONT   hOldFont;
    HDC     hdc;
    int     i;
    BITMAP  bmpInfo;
    int     x, cx;
    int     yLogPix;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = AGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName    = szAGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbAttributesGroup::Create register class failed"));
        return(FALSE);
    }

    // Create the window
    if (!::CreateWindowEx(0, szAGClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
        lpRect->left, lpRect->top,
        lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Couldn't create WbAttributesGroup window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Create the page control button bitmaps
    //
    if (!RecolorButtonImages())
    {
        ERROR_OUT(("Error getting page button bitmaps"));
        return(FALSE);
    }

    hdc = ::CreateCompatibleDC(NULL);
    yLogPix = ::GetDeviceCaps(hdc, LOGPIXELSY);
    ::DeleteDC(hdc);

    //
    // Create the font for the edit field and buttons
    //
    ::GetObject(m_uPageCtrls[PGC_LAST].hbmp, sizeof(BITMAP), &bmpInfo);
    m_hPageCtrlFont = ::CreateFont(-bmpInfo.bmHeight,
                                0, 0, 0,
                                FW_NORMAL, 0, 0, 0,
                                DEFAULT_CHARSET,
                                OUT_TT_PRECIS,
                                CLIP_DFA_OVERRIDE,
                                DEFAULT_QUALITY,
                                VARIABLE_PITCH | FF_SWISS,
                                "Arial" );
    if (!m_hPageCtrlFont)
    {
        ERROR_OUT(("WbPagesGroup::Create - couldn't create font"));
        return(FALSE);
    }

    //
    // Create the child controls in inverse order, right to left
    //
    x = lpRect->right;

    for (i = NUM_PAGE_CONTROLS - 1; i >= 0; i--)
    {
        x -= BORDER_SIZE_X;

        switch (i)
        {
            case PGC_ANY:
                cx = (3*PAGEBTN_WIDTH)/2;
                break;

            case PGC_FIRST:
            case PGC_LAST:
                // make button fit bitmap width + standard border
                ::GetObject(m_uPageCtrls[i].hbmp, sizeof(BITMAP), &bmpInfo);
                cx = bmpInfo.bmWidth + 2*::GetSystemMetrics(SM_CXFIXEDFRAME); // standard button border
                break;

            default:
                cx = PAGEBTN_WIDTH;
                break;

        }

        x -= cx;

        if (i == PGC_ANY)
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(WS_EX_CLIENTEDGE,
                _T("EDIT"), NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE |
                ES_NUMBER | ES_CENTER | ES_MULTILINE,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP edit field"));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, EM_LIMITTEXT, MAX_NUMCHARS, 0);
            ::SendMessage(m_uPageCtrls[i].hwnd, WM_SETFONT, (WPARAM)m_hPageCtrlFont, 0);
        }
        else
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(0, _T("BUTTON"),
                NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_BITMAP,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP button ID %x", g_uPageIds[i]));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_uPageCtrls[i].hbmp);
        }
    }

    m_cxPageCtrls = lpRect->right - x;

    SetPageButtonNo(PGC_FIRST, 1);
    SetPageButtonNo(PGC_LAST, 1);

    //
    // Create the color palette
    //

    m_colorsGroup.GetNaturalSize(&size);
    rectCG.left = BORDER_SIZE_X;
    rectCG.right = rectCG.left + size.cx;
    rectCG.top = BORDER_SIZE_Y;
    rectCG.bottom = rectCG.top + size.cy;

    if (!m_colorsGroup.Create(m_hwnd, &rectCG))
    {
        ERROR_OUT(("Couldn't create CGRP window"));
        return(FALSE);
    }

    //
    // Create the font button.
    // Now calculate the real size of the button
    //

    hdc = ::GetDC(m_hwnd);
    if (!hdc)
        return(FALSE);

    hOldFont = SelectFont(hdc, (HFONT)::GetStockObject(DEFAULT_GUI_FONT));

    ::LoadString(g_hInstance, IDS_FONTOPTIONS, szFOBStr, 256);
    ::GetTextExtentPoint(hdc, szFOBStr, lstrlen(szFOBStr), &size);

    SelectFont(hdc, hOldFont);
    ::ReleaseDC(m_hwnd, hdc);

    size.cx += 4 * BORDER_SIZE_X;
    size.cy += 4 * BORDER_SIZE_Y;

    m_hwndFontButton = ::CreateWindowEx(0, _T("BUTTON"), szFOBStr,
        WS_CHILD | WS_CLIPSIBLINGS | BS_PUSHBUTTON,
        rectCG.right + SEPARATOR_SIZE_X, 2*BORDER_SIZE_Y,
        max(size.cx, FONTBUTTONWIDTH), max(size.cy, FONTBUTTONHEIGHT),
        m_hwnd, (HMENU)IDM_FONT, g_hInstance, NULL);

    if (!m_hwndFontButton)
    {
        ERROR_OUT(("Couldn't create FONT button"));
        return(FALSE);
    }

    ::SendMessage(m_hwndFontButton, WM_SETFONT, (WPARAM)::GetStockObject(DEFAULT_GUI_FONT),
        FALSE);

    return(TRUE);
}



//
// RecolorButtonImages()
//
BOOL WbAttributesGroup::RecolorButtonImages(void)
{
    int         i;
    HBITMAP     hbmpNew;

    //
    // This creates button bitmaps tied to the 3D colors, and clears the old
    // ones/sets the new ones if the buttons are around.
    //

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // No bitmaps for the edit field
        if (i == PGC_ANY)
            continue;

        hbmpNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(g_uPageIds[i]),
            IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
        if (!hbmpNew)
        {
            ERROR_OUT(("AG::RecolorButtonImages faile to load bitmap ID %d",
                g_uPageIds[i]));
            return(FALSE);
        }

        // Set the new one
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP,
                (LPARAM)hbmpNew);
        }

        // Delete the old one
        if (m_uPageCtrls[i].hbmp != NULL)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
        }

        // Save this one
        m_uPageCtrls[i].hbmp = hbmpNew;

        // Put the page number on top
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            if (i == PGC_FIRST)
            {
                SetPageButtonNo(i, 1);
            }
            else if (i == PGC_LAST)
            {
                SetPageButtonNo(i, g_pwbCore->WBP_ContentsCountPages());
            }
        }
    }

    return(TRUE);
}




//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the attributes group
//
//
void WbAttributesGroup::GetNaturalSize(LPSIZE lpsize)
{
    SIZE    sizeCG;
    SIZE    sizeFSG;
    RECT    rc;

    m_colorsGroup.GetNaturalSize(&sizeCG);

    if (!m_hwndFontButton)
    {
        sizeFSG.cx = FONTBUTTONWIDTH;
        sizeFSG.cy = FONTBUTTONHEIGHT;
    }
    else
    {
        ::GetWindowRect(m_hwndFontButton, &rc);
        sizeFSG.cx = rc.right - rc.left;
        sizeFSG.cy = rc.bottom - rc.top;
    }

    // m_cxPageCtrls includes BORDER_SIZE_X on right side
    lpsize->cx = BORDER_SIZE_X
               + sizeCG.cx
               + SEPARATOR_SIZE_X
               + sizeFSG.cx
               + SEPARATOR_SIZE_X
               + m_cxPageCtrls;

    sizeFSG.cy = max(sizeFSG.cy, PAGEBTN_HEIGHT) + BORDER_SIZE_Y;
    lpsize->cy = BORDER_SIZE_Y
                + max(sizeCG.cy, sizeFSG.cy)
                + BORDER_SIZE_Y;
}


//
// IsChildEditField()
//
BOOL WbAttributesGroup::IsChildEditField(HWND hwnd)
{
    return(hwnd == m_uPageCtrls[PGC_ANY].hwnd);
}


//
// GetCurrentPageNumber()
//
UINT WbAttributesGroup::GetCurrentPageNumber(void)
{
    return(::GetDlgItemInt(m_hwnd, IDM_PAGE_ANY, NULL, FALSE));
}


//
// SetCurrentPageNumber()
//
void WbAttributesGroup::SetCurrentPageNumber(UINT number)
{
    ::SetDlgItemInt(m_hwnd, IDM_PAGE_ANY, number, FALSE);
}


//
// SetLastPageNumber()
//
void WbAttributesGroup::SetLastPageNumber(UINT number)
{
    SetPageButtonNo(PGC_LAST, number);
}


//
// EnablePageCtrls()
//
void WbAttributesGroup::EnablePageCtrls(BOOL bEnable)
{
    int i;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        ::EnableWindow(m_uPageCtrls[i].hwnd, bEnable);
    }
}


//
// EnableInsert()
//
void WbAttributesGroup::EnableInsert(BOOL bEnable)
{
    ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, bEnable);
}


//
// AGWndProc()
//
LRESULT CALLBACK AGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbAttributesGroup * pag = (WbAttributesGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pag = (WbAttributesGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pag);

            pag->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pag);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pag);
            pag->m_hwnd = NULL;
            break;

        case WM_SIZE:
            ASSERT(pag);
            pag->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_COMMAND:
            ASSERT(pag);
            pag->OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam),
                    GET_WM_COMMAND_HWND(wParam, lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    OnSize
//
// Purpose:     The tool window has been resized
//
//
void WbAttributesGroup::OnSize(UINT, int, int)
{
    RECT    rc;
    int     i;
    int     x;
    RECT    rcT;

    //
    // We haven't created our children yet.
    //
    if (!m_uPageCtrls[0].hwnd)
        return;

    ::GetClientRect(m_hwnd, &rc);
    x = rc.right - m_cxPageCtrls;

    //
    // Move the page controls to be right justified.
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // Get width of control
        ::GetWindowRect(m_uPageCtrls[i].hwnd, &rcT);
        rcT.right -= rcT.left;

        ::MoveWindow(m_uPageCtrls[i].hwnd, x, 2*BORDER_SIZE_Y,
            rcT.right, PAGEBTN_HEIGHT, TRUE);

        //
        // Move to the next one
        //
        x += rcT.right + BORDER_SIZE_X;
    }

    //
    // The color palette and font button are left justified, no need to
    // move them.
    //
}



//
// SetPageButtonNo()
//
// Updates the page text in the first/last button
//
void WbAttributesGroup::SetPageButtonNo(UINT pgcIndex, UINT uiPageNumber )
{
    HDC     hdc;
    BITMAP  bmpInfo;
    HBITMAP hbmp;
    HFONT   hOldFont;
    HBITMAP hOldBitmap;
    RECT    rectNumBox;
    TCHAR   NumStr[16];
    TEXTMETRIC tm;
    HWND    hwndButton;

    MLZ_EntryOut(ZONE_FUNCTION, "WbAttributesGroup::SetPageButtonNo");

    hwndButton = m_uPageCtrls[pgcIndex].hwnd;
    hbmp = m_uPageCtrls[pgcIndex].hbmp;

    ASSERT(hwndButton);
    ASSERT(hbmp);
    ASSERT(m_hPageCtrlFont);

    ::GetObject(hbmp, sizeof (BITMAP), (LPVOID)&bmpInfo);

    hdc = ::CreateCompatibleDC(NULL);
    hOldFont = SelectFont(hdc, m_hPageCtrlFont);
    hOldBitmap = SelectBitmap(hdc, hbmp);
    ::GetTextMetrics(hdc, &tm);

    rectNumBox.left = 10;
    rectNumBox.top = -(tm.tmInternalLeading/2);
    rectNumBox.right = bmpInfo.bmWidth;
    rectNumBox.bottom = bmpInfo.bmHeight;

    SelectBrush(hdc, ::GetSysColorBrush( COLOR_3DFACE ) );
    ::SetTextColor(hdc, ::GetSysColor( COLOR_BTNTEXT ) );
    ::SetBkColor(hdc, ::GetSysColor( COLOR_3DFACE ) );

    ::PatBlt(hdc, rectNumBox.left, rectNumBox.top,
        rectNumBox.right - rectNumBox.left, rectNumBox.bottom - rectNumBox.top,
        PATCOPY);

    wsprintf(NumStr, "%d", uiPageNumber);
    ::DrawText(hdc, NumStr, -1, &rectNumBox, DT_CENTER);

    SelectFont(hdc, hOldFont);
    SelectBitmap(hdc, hOldBitmap);

    ::DeleteDC(hdc);

    ::InvalidateRect(hwndButton, NULL, TRUE);
    ::UpdateWindow(hwndButton);
}



//
//
// Function:    DisplayTool
//
// Purpose:     Display a tool in the attributes group
//
//
void WbAttributesGroup::DisplayTool(WbTool* pTool)
{
    SIZE    size;

    // make width bar, etc, obey locks (bug 433)
    if (WB_Locked())
    {
        if (g_pMain->m_WG.m_hwnd != NULL)
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
        }
        Hide();
        return;
    }

    // Display the colors group if necessary
    if (!pTool->HasColor())
    {
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);
    }
    else
    {
        // Change the color button to match the tool
        m_colorsGroup.SetCurColor(pTool->GetColor());

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(m_colorsGroup.m_hwnd))
        {
            ::ShowWindow(m_colorsGroup.m_hwnd, SW_SHOW);
        }
    }

    // Display the widths group if necessary
    if( (!pTool->HasWidth()) || (!g_pMain->IsToolBarOn()) )
    {
        ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
    }
    else
    {
        UINT uiWidthIndex = pTool->GetWidthIndex();

        // If the width index isn't valid, then pop up all the buttons
        if (uiWidthIndex < NUM_OF_WIDTHS)
        {
            // Tell the widths group of the new selection
            g_pMain->m_WG.PushDown(uiWidthIndex);
        }

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(g_pMain->m_WG.m_hwnd))
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_SHOW);
        }
    }

    // The font sample group is visible for text and select tools
    if (!pTool->HasFont())
    {
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
    }
    else
    {
        if (!::IsWindowVisible(m_hwndFontButton))
        {
            ::ShowWindow(m_hwndFontButton, SW_SHOW);
        }
    }
}


//
//
// Function:    Hide.
//
// Purpose:     Hide the tool attributes bar.
//
//
void WbAttributesGroup::Hide(void)
{
    if (m_colorsGroup.m_hwnd != NULL)
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);

    if (m_hwndFontButton != NULL)
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
}

//
//
// Function:    SelectColor
//
// Purpose:     Set the current color
//
//
void WbAttributesGroup::SelectColor(WbTool* pTool)
{
    if (pTool != NULL)
    {
        pTool->SetColor(m_colorsGroup.GetCurColor());
    }
}




//
// This forwards all button commands to our main window
//
void WbAttributesGroup::OnCommand(UINT id, UINT cmd, HWND hwndCtl)
{
    switch (id)
    {
        case IDM_PAGE_FIRST:
        case IDM_PAGE_PREV:
        case IDM_PAGE_NEXT:
        case IDM_PAGE_LAST:
        case IDM_PAGE_INSERT_AFTER:
        case IDM_FONT:
            if (cmd == BN_CLICKED)
            {
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
            }
            break;

        case IDM_PAGE_ANY:
            if (cmd == EN_SETFOCUS)
            {
                ::SendMessage(hwndCtl, EM_SETSEL, 0, (LPARAM)-1);
                ::SendMessage(hwndCtl, EM_SCROLLCARET, 0, 0);
            }
            break;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfft\t127pdus.h ===
//=============================================================================
// T127 PDU Types
//=============================================================================

typedef enum T127_PDU_TYPES
{
T127_FILE_OFFER = 0x0,
T127_FILE_ACCEPT = 0x8,
T127_FILE_REJECT = 0x10,
T127_FILE_REQUEST = 0x18,
T127_FILE_DENY = 0x20,
T127_FILE_ERROR = 0x28,
T127_FILE_ABORT = 0x30,
T127_FILE_START = 0x38,
T127_FILE_DATA = 0x40,
T127_DIRECTORY_REQUEST = 0x48,
T127_DIRECTORY_RESPONSE = 0x50,
T127_MBFT_PRIVILEGE_REQUEST = 0x58,
T127_MBFT_PRIVILEGE_ASSIGN = 0x60,
T127_MBFT_NONSTANDARD = 0x68,
T127_PRIVATE_CHANNEL_JOIN_INVITE = 0x70,
T127_PRIVATE_CHANNEL_JOIN_RESPONSE = 0x78
} T127_PDUS;

#pragma pack(1)

typedef struct _T_T127_FILE_PDU_HEADER
{
    BYTE	pduType;
    WORD    fileHandle;          // File size in bytes
} T127_FILE_PDU_HEADER;

typedef struct _T_T127_FILE_DATA_BLOCK_HEADER
{
    BYTE	EOFFlag;
    WORD    FileDataSize;          // File size in bytes
}T127_FILE_DATA_BLOCK_HEADER;


typedef struct _T_T127_PRIVATE_CHANNEL_INVITE
{
	BYTE	pduType;
    WORD	ControlChannel;
    WORD    DataChannel;
    BYTE	EncodingMode;
}T127_PRIVATE_CHANNEL_INVITE;

typedef struct _T_T127_PRIVATE_CHANNEL_RESPONSE
{
	BYTE	pduType;
    WORD	ControlChannel;
    BYTE	Response;
}T127_PRIVATE_CHANNEL_RESPONSE;

typedef struct _T_T127_FILE_START_DATA_BLOCK_HEADER
{
    BYTE	EOFFlag;
    WORD	CompressionFormat;
    WORD    FileDataSize;          // File size in bytes
}T127_FILE_START_DATA_BLOCK_HEADER;

typedef struct _T_T127_FILE_DATA_HEADER
{
	T127_FILE_PDU_HEADER		PDUHeader;	
	T127_FILE_DATA_BLOCK_HEADER	DataHeader;          // File size in bytes
} T127_FILE_DATA_HEADER;

typedef struct _T_127_FILE_ERROR_HEADER
{
	T127_FILE_PDU_HEADER		PDUHeader;	
	BYTE						errorCode;
} T127_FILE_ERROR_HEADER;

typedef struct _T_T127_FILE_HEADER
{
	DWORD	presentFields;
	BYTE	FileHeader;
} T127_FILE_HEADER;

typedef struct _T_T127_FILE_START_PDU
{
	WORD	FileHandle;
}T127_FILE_START_PDU;

typedef struct _T_T127_FILE_ABORT_PDU
{
	WORD	pduType_PresentFields;
	WORD	dataChannel;
	WORD	transmitterUserId;
	WORD	fileHandle;
} T127_FILE_ABORT_PDU;

typedef struct _T_T127_PRIVILEGE_REQUEST_PDU
{
	BYTE	pduType;
	BYTE	nPrivileges;
	BYTE	privileges[3];	// 6/2 privileges.
} T127_PRIVILEGE_REQUEST_PDU;

typedef struct _T_T127_FILE_OFFER_PDU
{
	WORD	ChannelID;
	WORD	FileHandle;
	WORD	RosterInstance;
	BYTE	AckFlag;
} T127_FILE_OFFER_PDU;

typedef struct _T_FILE_HEADER_INFO
{
	BYTE	pduType;
	PSTR	fileName;
	LONG	fileNameSize;
	LONG	fileSize;
	LONG	pduSize;
	BYTE	nBytesForFileSize;
	
} FILE_HEADER_INFO;
typedef struct
{

	unsigned	wASNuser_visible_string_present					:1;	// 00000000 00000000 00000000 0000000? 0000 0001
	unsigned	wASNFileHeader_pathname_present					:1;	// 00000000 00000000 00000000 000000?0 0000 0002
	unsigned	wASNenvironment_present							:1;	// 00000000 00000000 00000000 00000?00 0000 0004
	unsigned	wASNcompression_present							:1;	// 00000000 00000000 00000000 0000?000 0000 0008
	unsigned	wASNcharacter_set_present						:1;	// 00000000 00000000 00000000 000?0000 0000 0010
	unsigned	wASNrecipient_present							:1;	// 00000000 00000000 00000000 00?00000 0000 0020
	unsigned	wASNoperating_system_present					:1;	// 00000000 00000000 00000000 0?000000 0000 0040
	unsigned	wASNmachine_present								:1;	// 00000000 00000000 00000000 ?0000000 0000 0080
	unsigned	wASNapplication_reference_present				:1;	// 00000000 00000000 0000000? 00000000 0000 0100
	unsigned	wASNstructure_present							:1;	// 00000000 00000000 000000?0 00000000 0000 0200
	unsigned	wASNprivate_use_present							:1;	// 00000000 00000000 00000?00 00000000 0000 0400
	unsigned													:1;	// 00000000 00000000 0000X000 00000000 0000 0800
	unsigned	wASNaccess_control_present						:1;	// 00000000 00000000 000?0000 00000000 0000 1000
	unsigned	wASNfuture_filesize_present						:1;	// 00000000 00000000 00?00000 00000000 0000 2000
	unsigned	wASNfilesize_present							:1;	// 00000000 00000000 0?000000 00000000 0000 4000
	unsigned													:3;	// 00000000 000000XX X0000000 00000000 0003 8000
	unsigned	wASNdate_and_time_of_last_read_access_present	:1;	// 00000000 00000?00 00000000 00000000 0004 0000
	unsigned	wASNdate_and_time_of_last_modification_present	:1;	// 00000000 0000?000 00000000 00000000 0008 0000
	unsigned	wASNdate_and_time_of_creation_present			:1;	// 00000000 000?0000 00000000 00000000 0010 0000
	unsigned													:1;	// 00000000 00X00000 00000000 00000000 0020 0000
	unsigned	wASNcontents_type_present						:1;	// 00000000 0?000000 00000000 00000000 0040 0000
	unsigned	wASNpermitted_actions_present					:1;	// 00000000 ?0000000 00000000 00000000 0080 0000
	unsigned	wASNfilename_present							:1;	// 0000000? 00000000 00000000 00000000 0100 0000
	unsigned	wASNprotocol_version_present					:1;	// 000000?0 00000000 00000000 00000000 0200 0000
	
}T127_FILE_OFFER_PRESENT_FIELDS;

#pragma pack()

typedef enum T127_file_header_fields
{
	user_visible_string_present				=	0x00000001,//0x00010000,	//0x00000001
	FileHeader_pathname_present				=	0x00000002,//0x00020000,	//0x00000002
	environment_present						=	0x00000004,//0x00040000,	//0x00000004
	compression_present						=	0x00000008,//0x00080000,	//0x00000008
	character_set_present					=	0x00000010,//0x00100000,	//0x00000010
	recipient_present						=	0x00000020,//0x00200000,	//0x00000020
	operating_system_present				=	0x00000040,//0x00400000,	//0x00000040
	machine_present							=	0x00000080,//0x00800000,	//0x00000080
	application_reference_present			=	0x00000100,//0x00010000,	//0x00000100
	structure_present						=	0x00000200,//0x00020000,	//0x00000200
	private_use_present						=	0x00000400,//0x00040000,	//0x00000400
	access_control_present					=	0x00001000,//0x00100000,	//0x00001000
	future_filesize_present					=	0x00002000,//0x00200000,	//0x00002000
	filesize_present						=	0x00004000,//0x00400000,	//0x00004000
	date_and_time_of_last_read_access_present=	0x00040000,//0x00000400,	//0x00040000
	date_and_time_of_last_modification_present=	0x00080000,//0x00000800,	//0x00080000
	date_and_time_of_creation_present		=	0x00100000,//0x00001000,	//0x00100000
	contents_type_present					=	0x00400000,//0x00004000,	//0x00400000
	permitted_actions_present				=	0x00800000,//0x00000800,	//0x00800000
	filename_present						=	0x01000000,//0x00000001,	//0x01000000
	protocol_version_present				=	0x02000000 //0x00000002 	//0x02000000
}T127_FILE_HEADER_FIELDS;


VOID GetFileHeaderSize (FILE_HEADER_INFO* fileHeader);
BYTE GetLengthFieldSize (ULONG length);
VOID SetLengthField(BYTE * pBuff, BYTE sizeOfLength, ULONG lengthOfField);
BYTE* GetFileInfo (LPSTR lpEncodedBuffer, BYTE * lpszFileName, LONG * FileSize, ULONG* FileDateTime );

#define SWAPWORD(a)      (WORD)(HIBYTE(LOWORD(a)) | (LOBYTE(LOWORD(a)) << 8))

#define MIN_ASNDynamicChannelID 1001
#define MAX_ASNDynamicChannelID 65535
#define SIZE_OF_DATE_TIME_STRING 14	// yyyymmddhhmmss
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\agrp.hpp ===
//
// AGRP.HPP
// WbAttributesGroup
//
// Copyright Microsoft 1998-
//

#ifndef __AGRP_HPP_
#define __AGRP_HPP_


#define FONTBUTTONWIDTH        100
#define FONTBUTTONHEIGHT        23


#define PAGEBTN_WIDTH	23
#define PAGEBTN_HEIGHT	23
#define MAX_NUMCHARS	3


//
// Local defines
//
#define BORDER_SIZE_X        ::GetSystemMetrics(SM_CXEDGE)
#define BORDER_SIZE_Y        ::GetSystemMetrics(SM_CYEDGE)
#define SEPARATOR_SIZE_X     6
#define SEPARATOR_SIZE_Y     6

#define DEFAULT_PGC_WIDTH   (8*24)

enum
{
    PGC_FIRST = 0,
    PGC_PREV,
    PGC_ANY,
    PGC_NEXT,
    PGC_LAST,
    PGC_INSERT,
    NUM_PAGE_CONTROLS
};


//
// Indexedby PGC_ value
//
typedef struct tagPAGECTRL
{
    HBITMAP     hbmp;
    HWND        hwnd;
}
PAGECTRL;


//
// The buttons are all BS_BITMAP
// The edit field is ES_CENTER | ES_MULTILINE | ES_NUMBER | WS_BORDER
//



class WbTool;

//
//
// Class:   WbAttributesGroup
//
// Purpose: Define Whiteboard tool attributes display group
//
//
class WbAttributesGroup
{
public:
    WbAttributesGroup();
    ~WbAttributesGroup();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent, LPCRECT lprc);

    //
    // Display the attributes of the tool passed as parameter
    //
    void DisplayTool(WbTool* pTool);

    //
    // Hide the tool attributes bar.
    //
    void Hide(void);

    //
    // Resizing functions
    //
    void GetNaturalSize(LPSIZE lpsize);


    //
    // Colors
    //
    void SelectColor(WbTool* pTool);
	
    void SetChoiceColor(COLORREF clr)
		{m_colorsGroup.SetCurColor(clr);}

	void OnEditColors( void )
		{m_colorsGroup.OnEditColors();}

    void SaveSettings( void )
        {m_colorsGroup.SaveSettings();}

    //
    // Page Controls
    //
    BOOL IsChildEditField(HWND hwnd);

    UINT GetCurrentPageNumber(void);
    void SetCurrentPageNumber(UINT number);
    void SetLastPageNumber(UINT number);

    void EnablePageCtrls(BOOL bEnable);
    void EnableInsert(BOOL bEnable);

    BOOL RecolorButtonImages();

    HWND    m_hwnd;

    friend LRESULT CALLBACK AGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void OnSize(UINT nType, int cx, int cy);
    void OnCommand(UINT id, UINT code, HWND hwndCtl);

    //
    // Color palette
    //
	WbColorsGroup     m_colorsGroup;

    //
    // Font Button
    //
    HWND        m_hwndFontButton;

    //
    // Page controls
    //
    PAGECTRL    m_uPageCtrls[NUM_PAGE_CONTROLS];
    HFONT       m_hPageCtrlFont;
    int         m_cxPageCtrls;

    void        SetPageButtonNo(UINT pgcCtrl, UINT uiPageNumber);
};


#endif // __AGRP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\cgrp.hpp ===
//
// CGRP.HPP
// WbColorsGroup
//
// Copyright Microsoft 1998-
//

#ifndef CGRP_HPP
#define CGRP_HPP



#define NUMROWS			2
#define NUMCOLS			14
#define NUMCLRPANES		(NUMROWS*NUMCOLS + 1) // palette + current one
#define INDEX_CHOICE    (NUMCLRPANES-1)     // last one
#define NUMCUSTCOLORS	16

#define CLRPANE_HEIGHT	16
#define CLRPANE_WIDTH	CLRPANE_HEIGHT
#define CLRPANE_BLACK	RGB( 0,0,0 )
#define CLRPANE_WHITE	RGB( 255,255,255 )


#define CLRCHOICE_HEIGHT    (NUMROWS * CLRPANE_HEIGHT)
#define CLRCHOICE_WIDTH     CLRCHOICE_HEIGHT


//
// Colors window proc
//
class WbColorsGroup
{
public:
	WbColorsGroup();
	~WbColorsGroup();
	virtual BOOL Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

	void SaveSettings( void );

    COLORREF GetCurColor(void);
    void    SetCurColor(COLORREF clr);
	void    OnEditColors( void );

    HWND    m_hwnd;

    friend  LRESULT CALLBACK CGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void     OnPaint(void);
    void     OnLButtonDown(UINT nFlags, int x, int y);
    void     OnLButtonDblClk(UINT nFlags, int x, int y);

	int      m_nLastColor;
	COLORREF m_crColors[ NUMCLRPANES ];
	HBRUSH   m_hBrushes[ NUMCLRPANES ];
	COLORREF m_crCustomColors[ NUMCUSTCOLORS ];

	COLORREF GetColorOfBrush( int nColor );
	void     SetColorOfBrush( int nColor, COLORREF crNewColor );
    void     SetColorOfPane(int nColor, COLORREF clr);

	COLORREF DoColorDialog( int nColor );
	void     ClickOwner( void );
};



#endif // CGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\ccl32.hpp ===
//
// CCL32.HPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

#ifndef CCL32_HPP
#define CCL32_HPP


#define HLP_MENU_ITEM_OFFSET	0x10000

	
#define HLP_BASE				600
enum
{
    IDH_CONTENTS = HLP_BASE + 1,
    IDH_SEARCH,
    IDH_ABOUT,
    IDH_HELPHELP,
    HLP_PROCESSED
};



#define HELPID_WBSAVEASDLG      4070
#define HELPID_WBFILEMENU       4140
#define HELPID_WBEDITMENU       4150
#define HELPID_WBVIEWMENU       4160
#define HELPID_WBTOOLSMENU      4170
#define HELPID_WBOPTIONSMENU    4180
#define HELPID_WBHELPMENU       4190
#define HELPID_WBWIDTHMENU      4210
#define HELPID_WBSYSTEMMENU     4300


//
// IMM32 stuff
//
typedef HIMC (WINAPI * IGC_PROC)(HWND);
typedef BOOL (WINAPI * INI_PROC)(HIMC, DWORD, DWORD, DWORD);


extern void  UT_CaptureMouse( HWND   hwnd );
extern void  UT_ReleaseMouse( HWND  hwnd );



//
// Option entry names
//

#define OPT_MAIN_TOOLBARVISIBLE         "ToolBarVisible"
#define OPT_MAIN_STATUSBARVISIBLE       "StatusBarVisible"
#define OPT_MAIN_MAXIMIZED              "Maximized"
#define OPT_MAIN_MINIMIZED              "Minimized"
#define OPT_MAIN_MAINWINDOWRECT         "MainWindowPosition"
#define OPT_MAIN_SELECTWINDOW_NOTAGAIN  "GrabWindow_dontwarn"
#define OPT_MAIN_SELECTAREA_NOTAGAIN    "GrabArea_dontwarn"
#define OPT_MAIN_COLORPALETTE		    "ColorPalette"
#define OPT_MAIN_CUSTOMCOLORS		    "CustomColors"

#define DFLT_MAIN_TOOLBARVISIBLE        TRUE
#define DFLT_MAIN_STATUSBARVISIBLE      TRUE			
#define DFLT_MAIN_MAXIMIZED             FALSE			
#define DFLT_MAIN_MINIMIZED             FALSE			
#define DFLT_MAIN_SELECTWINDOW_NOTAGAIN FALSE			
#define DFLT_MAIN_SELECTAREA_NOTAGAIN   FALSE			



//
// Settings routines
//

//
// GetIntegerOption retrieves and converts an option string to a long.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
LONG OPT_GetIntegerOption(LPCSTR cstrOptionName,
                          LONG lDefault = 0L);

//
// GetBooleanOption retrieves and converts an option string to a boolean
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_GetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bDefault = FALSE);

//
// GetStringOption  retrieves a string option (no conversion).
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetStringOption(LPCSTR cstrOptionName,
                            LPSTR pcDefault,
                            UINT size);

//
// GetDataOption    retrieves an option string and parses it into an
//                  array of hex bytes.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
int OPT_GetDataOption(LPCSTR optionName,
                      int   iBufferLength,
                      BYTE* pbBuffer);

//
// GetWindowRectOption  retrieves a option string and parses it into a
//                      rectangle representing the corners of the
//                  window.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetWindowRectOption(LPCSTR optionName, LPRECT lprc, LPCRECT lprcDefault);

//
// SetStringOption  writes a string option (no conversion).
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetStringOption(LPCSTR cstrOptionName,
                         LPCSTR cstrValue);

//
// SetBooleanOption writes a boolean option
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bValue);

//
// SetIntegerOption write an integer option
//                  Returns TRUE if the option was successfully written.
	
//
BOOL OPT_SetIntegerOption(LPCSTR cstrOptionName,
                          LONG  lValue);

//
// SetWindowRectOption  write a window rectangle option.
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetWindowRectOption(LPCSTR optionName,
                             LPCRECT lpwindowRect);

//
// SetDataOption    writes a data option.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_SetDataOption(LPCSTR optionName,
                       int   iBufferLength,
                       BYTE* pbBuffer);

BOOL OPT_Lookup(LPCSTR cstrOptionName,
                          LPCSTR cstrResult,
                          UINT size);




//
//
// Class:   WbPrinter
//
// Purpose: Printer class including cancellation dialog
//
//
class WbPrinter
{
public:
    //
    // Constructor
    //
    // The parameter specifies the printer to be used. Under Windows this
    // value can be obtained from the Common Print Dialog.
    //
    WbPrinter(LPCTSTR szDeviceName);
    ~WbPrinter(void);

    void    SetPrintPageNumber(int nPageNumber);

    // Return TRUE if an error has occurred
    BOOL    Error(void)       { return (m_bAborted || (m_nPrintResult < 0)); };

    // Return TRUE if the user has aborted the print
    BOOL    Aborted(void)     { return m_bAborted; };

    // Return the last result code from a print function call
    int     PrintResult(void) { return m_nPrintResult; };

    //
    // Document manipulation functions
    //

    // Start a new print job
    int StartDoc(HDC hdc, LPCTSTR cstrDocName, int nStartPage);

    // Start a new page
    int StartPage(HDC hdc, int nPageNumber);

    // Indicate that the page is now complete
    int EndPage(HDC hdc);

    // Indicate that the document is complete
    int EndDoc(HDC hdc);

    // Abort the print job
    int AbortDoc(void);

protected:
    HWND    m_hwndDialog;

    //
    // Device and port name for this printer
    //
    LPCTSTR m_szDeviceName;
    TCHAR   m_szPrintPageText[_MAX_PATH];

    //
    // Internal state variables
    //
    int     m_nPrintResult;
    BOOL    m_bAborted;

    void    StopDialog(void);

    //
    // Friend callback routine
    //
    friend BOOL CALLBACK AbortProc(HDC, int);
    friend INT_PTR CALLBACK CancelPrintDlgProc(HWND, UINT, WPARAM, LPARAM);
};




//
// Defines for palettes
//
#define PALVERSION  0x300
#define MAXPALETTE  256     

HPALETTE CreateSystemPalette(void);
HPALETTE CreateColorPalette(void);


HBITMAP FromScreenAreaBmp(LPCRECT lprc);


UINT        DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi);
UINT        DIB_PaletteLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_DataLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_TotalLength(LPBITMAPINFOHEADER lpbi);

HPALETTE    DIB_CreatePalette(LPBITMAPINFOHEADER lpbi);
LPSTR       DIB_Bits(LPBITMAPINFOHEADER lpbi);

LPBITMAPINFOHEADER  DIB_FromBitmap(HBITMAP hBitmap, HPALETTE hPalette, BOOL fGHandle);
LPBITMAPINFOHEADER  DIB_FromScreenArea(LPCRECT lprc);
LPBITMAPINFOHEADER  DIB_Copy(LPBITMAPINFOHEADER lpbi);



//
// Extra windows messages for the Whiteboard
//
enum
{
    WM_USER_GOTO_USER_POSITION  =   WM_USER,
    WM_USER_GOTO_USER_POINTER,
    WM_USER_JOIN_CALL,
    WM_USER_DISPLAY_ERROR,
    WM_USER_UPDATE_ATTRIBUTES,
    WM_USER_JOIN_PENDING_CALL,
    WM_USER_PRIVATE_PARENTNOTIFY
};


//
// Internal error codes
//

#define WBFE_RC_BASE       (WB_LAST_RC - 20)

enum
{
    WBFE_RC_WINDOWS = WBFE_RC_BASE,
    WBFE_RC_WB,
    WBFE_RC_JOIN_CALL_FAILED,
    WBFE_RC_CM,
    WBFE_RC_AL,
    WBFE_RC_PRINTER
};

//
// The following functions can be found in wwbapp.cpp
//

//
// Functions displaying a message box from the string resources specified
//
int Message(HWND hwndOwner,
            UINT uiCaption,
            UINT uiMessage,
            UINT uiStyle = (MB_OK | MB_ICONEXCLAMATION));

//
// Functions displaying a message box from return codes
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
// Default exception handler
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
//
// Class:   DCWbPointerColorMap
//
// Purpose: Map from pointer color to pointer structures
//
//
class DCWbColorToIconMap : public COBLIST
{

  public:
    //
    // Destructor
    //
    ~DCWbColorToIconMap(void);
};




//
// BOGUS LAURABU TEMP!
// StrArray
//

#define ALLOC_CHUNK     8

class StrArray
{
public:
	StrArray();
	~StrArray();

	int GetSize() const { return(m_nSize); }
	void SetSize(int nNewSize);

	// Clean up
	void RemoveAll() { SetSize(0); }

	// Adding elements
	void SetAt(int nIndex, LPCTSTR newElement);
	void SetAtGrow(int nIndex, LPCTSTR newElement);
	void Add(LPCTSTR newElement);

	// overloaded operator helpers
	LPCTSTR operator[](int nIndex) const;

// Implementation
protected:
    void ClearOut();

	LPCTSTR * m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
};

char *  StrTok (
        char * string,
        char * control
        );

#endif // CCL32_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\ccl32.cpp ===
//
// CCL32.CPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>

LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam );



HHOOK   g_utMouseHookHandle = NULL;
HWND    g_utCaptureWindow = NULL;





void UT_CaptureMouse( HWND   hwnd )
{
	// disable asynchronous input so we don't lose capture because the
	// left button isn't down
    g_utMouseHookHandle = SetWindowsHookEx( WH_JOURNALRECORD,
                                              DummyMouseHookProc,
                                              g_hInstance,
                                              NULL );

    if( g_utMouseHookHandle == NULL )
    {
        WARNING_OUT(("Failed to insert JournalRecord hook"));
	}

	// grap mouse
    ::SetCapture(hwnd);
    g_utCaptureWindow = hwnd;
}


void UT_ReleaseMouse( HWND  hwnd )
{
    ::ReleaseCapture();
    g_utCaptureWindow = NULL;

    if (g_utMouseHookHandle != NULL )
	{
		// le go my lego
        ::UnhookWindowsHookEx( g_utMouseHookHandle );
        g_utMouseHookHandle = NULL;
	}
}


LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam )
{
    return( CallNextHookEx( g_utMouseHookHandle, code, wParam, lParam ) );
}




//
// General definitions
//
#define MAX_OPTIONS_LINE_LENGTH         255
#define MAX_SECTION_LEN                 200


//
//
// Function: HexDigitToByte
//
// Purpose:  Helper function to convert a single hex digit to a byte value.
//
//
BOOL HexDigitToByte(char cHexDigit, BYTE& byte);

BOOL HexDigitToByte(char cHexDigit, BYTE& byte)
{
  // Decimal digits
  if (   (cHexDigit >= '0')
      && (cHexDigit <= '9'))
  {
    byte = (BYTE) (cHexDigit - '0');
    return(TRUE);
  }

  // Uppercase characters
  if (   (cHexDigit >= 'A')
      && (cHexDigit <= 'F'))
  {
    byte = (BYTE) ((cHexDigit - 'A') + 10);
    return(TRUE);
  }

  // Lowercase characters
  if (   (cHexDigit >= 'a')
      && (cHexDigit <= 'f'))
  {
    byte = (BYTE) ((cHexDigit - 'a') + 10);
    return(TRUE);
  }

  // The character is not a valid hex digit
  return(FALSE);
}




//
//
// Function: GetIntegerOption
//
// Purpose:  Retrieve a named option from the dictionary and convert the
//           option string to a long integer value.
//
//
LONG OPT_GetIntegerOption
(
    LPCSTR  cstrOptionName,
    LONG    lDefault
)
{
    LONG    lResult;
    TCHAR   cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(cstrOptionName, cstrValue, MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, convert it to a long
        lResult = RtStrToInt(cstrValue);
    }
    else
    {
        // The option is not in the dictionary, return the default
        lResult = lDefault;
    }

    return lResult;
}



//
//
// Function: GetBooleanOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a boolean value.
//
//
BOOL OPT_GetBooleanOption
(
    LPCSTR  cstrOptionName,
    BOOL    bDefault
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];

    // Lookup the option
    if (OPT_Lookup(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        return(cstrValue[0] == 'y' || cstrValue[0] =='Y') ;
    }

    return bDefault;
}



//
//
// Function: GetStringOption
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it. No conversion of the string is performed.
//
//
void OPT_GetStringOption
(
    LPCSTR  cstrOptionName,
    LPSTR   cstrValue,
    UINT	size
)
{
    if (!OPT_Lookup(cstrOptionName, cstrValue, size) || !(lstrlen(cstrValue)))
    {
        *cstrValue = _T('\0');
    }
}


//
//
// Function: Lookup
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it in the CString object passed. No conversion is performed.
//
//
BOOL OPT_Lookup
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrResult,
    UINT		size
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    read_hkey = NULL;
	DWORD	    read_type;
	DWORD	    read_bufsize;

	// open key
	if (RegOpenKeyEx( HKEY_CURRENT_USER,
					  WHITEBOARD_KEY,
					  0,
					  KEY_EXECUTE,
					  &read_hkey )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not open key"));
        goto bail_out;
    }


	// read key's value
	read_bufsize = size;
	if (RegQueryValueEx( read_hkey,
					     cstrOptionName,
						 NULL,
						 &read_type,
						 (LPBYTE)cstrResult,
						 &read_bufsize )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not read key"));
        goto bail_out;
    }


	// check for valid type
	if (read_type != REG_SZ)
    {
        WARNING_OUT(("Bad key data"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (read_hkey != NULL)
		RegCloseKey(read_hkey);

	return (fSuccess);
}




//
//
// Function: GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void OPT_GetWindowRectOption
(
    LPCSTR      optionName,
    LPRECT      lprc,
    LPCRECT     lprcDefault
)
{
    int      iLeft;
    int      iTop;
    int      iRight;
    int      iBottom;
    TCHAR    cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(optionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, parse it to a rectangle
        iLeft   = RtStrToInt(StrTok(cstrValue, " ,"));
        iTop    = RtStrToInt(StrTok(NULL, " ,"));
        iRight  = RtStrToInt(StrTok(NULL, " ,"));
        iBottom = RtStrToInt(StrTok(NULL, " ,"));

        // Check for non-zero size
        if ((iRight <= iLeft) || (iBottom <= iTop))
        {
            *lprc = *lprcDefault;
        }
        else
        {
            // Make sure that the window rectangle is (at least partially) on
            // screen, and not too large.  First get the screen size
            int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
            int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);

            // Check the window size
            if ((iRight - iLeft) > screenWidth)
            {
                iRight = iLeft + screenWidth;
            }

            if ((iBottom - iTop) > screenHeight)
            {
                iTop = screenHeight;
            }

            // Check the window position
            if (iLeft >= screenWidth)
            {
                // Off screen to the right - keep the width the same
                iLeft  = screenWidth - (iRight - iLeft);
                iRight = screenWidth;
            }

            if (iRight < 0)
            {
                // Off screen to the left - keep the width the same
                iRight = iRight - iLeft;
                iLeft  = 0;
            }

            if (iTop >= screenHeight)
            {
                // Off screen to the bottom - keep the height the same
                iTop    = screenHeight - (iBottom - iTop);
                iBottom = screenHeight;
            }

            if (iBottom < 0)
            {
                // Off screen to the top - keep the height the same
                iBottom = (iBottom - iTop);
                iTop    = 0;
            }

            lprc->left = iLeft;
            lprc->top = iTop;
            lprc->right = iRight;
            lprc->bottom = iBottom;
        }
    }
    else
    {
        // The option is not in the dictionary, return the default
        *lprc = *lprcDefault;
    }
}


//
//
// Function: GetDataOption
//
// Purpose:  Retrieve a named option from the dictionary and parse it as
//           an ASCII representation of a string of hex bytes.
//
//
int OPT_GetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbResult
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];
    BYTE* pbSaveResult = pbResult;

    // Lookup the option
    OPT_GetStringOption(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH);
    if (lstrlen(cstrValue))
    {
        // Calculate the maximum number of characters to convert
        int iMaxChars = min(2 * iBufferLength, lstrlen(cstrValue));

        // Option found, convert the string to hex bytes
        for (int iIndex = 0; iIndex < iMaxChars; iIndex += 2)
        {
            BYTE bByteHigh = 0;
            BYTE bByteLow  = 0;

            if (   (HexDigitToByte(cstrValue[iIndex], bByteHigh) == FALSE)
                || (HexDigitToByte(cstrValue[iIndex + 1], bByteLow) == FALSE))
            {
                // The character was not a valid hex digit
                break;
            }

            // Build the result byte
            *pbResult++ = (BYTE) ((bByteHigh << 4) | bByteLow);
        }
    }

    // Return the length of data in the buffer
    return (int)(pbResult - pbSaveResult);
}



//
//
// Function: SetStringOption
//
// Purpose:  Set the value of an option in the dictionary.
//

//
BOOL OPT_SetStringOption
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrValue
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    write_hkey = NULL;
	DWORD       disposition;

    // open or create the key
	if (RegCreateKeyEx( HKEY_CURRENT_USER,
						WHITEBOARD_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&write_hkey,
						&disposition) != ERROR_SUCCESS)
    {
        WARNING_OUT(("Could not write key"));
        goto bail_out;
    }

    // got data, write the value
    if (RegSetValueEx( write_hkey,
                       cstrOptionName,
					   0,
					   REG_SZ,
					   (LPBYTE)cstrValue,
                       _tcsclen(cstrValue) + sizeof(TCHAR)) != ERROR_SUCCESS )
    {
        WARNING_OUT(("Could not write key value"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (write_hkey != NULL)
		RegCloseKey(write_hkey);

    return(fSuccess);
}



//
//
// Function: SetIntegerOption
//
// Purpose:  Write an integer option
//
//
BOOL OPT_SetIntegerOption
(
    LPCSTR      cstrOptionName,
    LONG        lValue
)
{
    char cBuffer[20];

    // Convert the integer value to ASCII decimal
    wsprintf(cBuffer, "%ld", lValue);

	// Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}


//
//
// Function: SetBooleanOption
//
// Purpose:  Write a boolean option
//
//
BOOL OPT_SetBooleanOption
(
    LPCSTR      cstrOptionName,
    BOOL        bValue
)
{
    char        cBuffer[8];

    wsprintf(cBuffer, "%c", (bValue ? 'Y' : 'N'));

    // Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}



//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
BOOL OPT_SetWindowRectOption
(
    LPCSTR      optionName,
    LPCRECT     lpwindowRect
)
{
    char cBuffer[64];

    // Convert the integer values to ASCII decimal
	wsprintf(cBuffer, "%d,%d,%d,%d",
        lpwindowRect->left, lpwindowRect->top, lpwindowRect->right,
        lpwindowRect->bottom);

	  // Write the option
    return OPT_SetStringOption(optionName, cBuffer);
}

//
//
// Function: SetDataOption
//
// Purpose:  Write a data option to the options file
//
//
BOOL OPT_SetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbBuffer
)
{
    char        cBuffer[1024];
    LPSTR       cTmp;

    ASSERT(iBufferLength*2 < sizeof(cBuffer));

    // Loop through the data array converting a byte at a time
    cTmp = cBuffer;
    for (int iIndex = 0; iIndex < iBufferLength; iIndex++)
    {
        // Convert the next byte to ASCII hex
        wsprintf(cTmp, "%02x", pbBuffer[iIndex]);

        // add it to the string to be written
        cTmp += lstrlen(cTmp);
    }

    // Write the option
    return OPT_SetStringOption(cstrOptionName, cBuffer);
}





//
//
// Function:    CreateSystemPalette
//
// Purpose:     Get a palette representing the system palette
//
//
HPALETTE CreateSystemPalette(void)
{
    LPLOGPALETTE    lpLogPal;
    HDC             hdc;
    HPALETTE        hPal = NULL;
    int             nColors;

    MLZ_EntryOut(ZONE_FUNCTION, "CreateSystemPalette");

    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);

    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

    nColors = ::GetDeviceCaps(hdc, SIZEPALETTE);

    ::DeleteDC(hdc);

    if (nColors == 0)
    {
        TRACE_MSG(("CreateSystemPalette: device has no palette"));
        return(NULL);
    }

    // Allocate room for the palette and lock it.
    lpLogPal = (LPLOGPALETTE)::GlobalAlloc(GPTR, sizeof(LOGPALETTE) +
                                    nColors * sizeof(PALETTEENTRY));

    if (lpLogPal != NULL)
    {
        lpLogPal->palVersion    = PALVERSION;
        lpLogPal->palNumEntries = (WORD) nColors;

        for (int iIndex = 0;  iIndex < nColors;  iIndex++)
        {
            lpLogPal->palPalEntry[iIndex].peBlue  = 0;
            *((LPWORD) (&lpLogPal->palPalEntry[iIndex].peRed)) = (WORD) iIndex;
            lpLogPal->palPalEntry[iIndex].peFlags = PC_EXPLICIT;
        }

        hPal = ::CreatePalette(lpLogPal);

        // Free the logical palette structure
        ::GlobalFree((HGLOBAL)lpLogPal);
    }

    return(hPal);
}


//
//
// Function:    CreateColorPalette
//
// Purpose:     Get a 256-color palette
//
//
HPALETTE CreateColorPalette(void)
{
    HDC hdc;
    HPALETTE hPal = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "CreateColorPalette");

	// Find out how many colors are reserved
    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

	UINT uiSystemUse  = ::GetSystemPaletteUse(hdc);

    // Get the number of static colors
    int  iCountStatic = 20;
    int  iHalfCountStatic = 10;
	if (uiSystemUse == SYSPAL_NOSTATIC)
	{
        iCountStatic = 2;
        iHalfCountStatic = 1;
    }

	LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;

    // put system colors in correct lower and upper pal entries (bug NM4db:817)
    ::GetSystemPaletteEntries(hdc,
							  0,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[0]) );

    ::GetSystemPaletteEntries(hdc,
							  MAXPALETTE - iHalfCountStatic,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[MAXPALETTE - iHalfCountStatic]) );

    // Create the windows object for this palette
    // from the logical palette
    hPal = CreatePalette( (LOGPALETTE *)&gIndeoPalette );

	// Delete the display DC
	::DeleteDC(hdc);

	return(hPal);
}





//
//
// Function:    FromScreenAreaBmp
//
// Purpose:     Create a bitmap from an area of the screen
//
//
HBITMAP FromScreenAreaBmp(LPCRECT lprect)
{
    RECT    rcScreen;
    HBITMAP hBitMap = NULL;

    //
    // Get screen boundaries, in a way that works for single and multiple
    // monitor scenarios.
    //
    if (rcScreen.right = ::GetSystemMetrics(SM_CXVIRTUALSCREEN))
    {
        //
        // This is Win98, NT 4.0 SP-3, or NT5
        //
        rcScreen.bottom  = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
        rcScreen.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
        rcScreen.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    }
    else
    {
        //
        // The VIRTUALSCREEN size metrics are zero on older platforms
        // which don't support them.
        //
        rcScreen.right  = ::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = ::GetSystemMetrics(SM_CYSCREEN);
        rcScreen.left   = 0;
        rcScreen.top    = 0;
    }

    rcScreen.right += rcScreen.left;
    rcScreen.bottom += rcScreen.top;

    //
    // Clip bitmap rectangle to the screen.
    //
    if (IntersectRect(&rcScreen, &rcScreen, lprect))
    {
        // Create a DC for the screen and create
        // a memory DC compatible to screen DC
        HDC     hdisplayDC;
        hdisplayDC = ::CreateDC("DISPLAY", NULL, NULL, NULL);

        HDC hmemDC;
        hmemDC = ::CreateCompatibleDC(hdisplayDC);

        // Create a bitmap compatible with the screen DC
        hBitMap =  ::CreateCompatibleBitmap(hdisplayDC,
            rcScreen.right - rcScreen.left,
            rcScreen.bottom - rcScreen.top);
        if (hBitMap != NULL)
        {
            // Select new bitmap into memory DC
            HBITMAP  hOldBitmap = SelectBitmap(hmemDC, hBitMap);

            // BitBlt screen DC to memory DC
            ::BitBlt(hmemDC, 0, 0, rcScreen.right - rcScreen.left,
                rcScreen.bottom - rcScreen.top, hdisplayDC,
                rcScreen.left, rcScreen.top, SRCCOPY);

            // Select old bitmap back into memory DC and get handle to
            // bitmap of the screen
            SelectBitmap(hmemDC, hOldBitmap);
        }

        ::DeleteDC(hmemDC);

        ::DeleteDC(hdisplayDC);
    }

    // return handle to the bitmap
    return hBitMap;
}





// Macro to round off the given value to the closest byte
#define WIDTHBYTES(i)   (((i+31)/32)*4)


//
//
// Function:    DIB_NumberOfColors
//
// Purpose:     Calculates the number of colours in the DIB
//
//
UINT DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi)
{
    UINT                numColors;
    int                 bits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_NumberOfColors");

    ASSERT(lpbi != NULL);

    //  With the BITMAPINFO format headers, the size of the palette
    //  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
    //  is dependent on the bits per pixel ( = 2 raised to the power of
    //  bits/pixel).
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        // Old DIB format, some apps still put this on the clipboard
        numColors = 0;
        bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
        numColors = lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }

    if ((numColors == 0) && (bits <= 8))
    {
        numColors = (1 << bits);
    }

    return numColors;
}


//
//
// Function:    DIB_PaletteLength
//
// Purpose:     Calculates the palette size in bytes
//
//
UINT DIB_PaletteLength(LPBITMAPINFOHEADER lpbi)
{
    UINT size;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_PaletteLength");

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBTRIPLE);
    }
    else
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBQUAD);
    }

    TRACE_MSG(("Palette length %d", size));
    return(size);
}

//
//
// Function:    DIB_DataLength
//
// Purpose:     Return the length of the DIB data (after the header and the
//              color table.
//
//
UINT DIB_DataLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_DataLength");

    ASSERT(lpbi);

    UINT dwLength = 0;

    // If the image is not compressed, calculate the length of the data
    if (lpbi->biCompression == BI_RGB)
    {
        // Image is not compressed, the size can be given as zero in the header

        // Calculate the width in bytes of the image
        DWORD dwByteWidth = ( ((DWORD) lpbi->biWidth) * (DWORD) lpbi->biBitCount);
        TRACE_MSG(("Data byte width is %ld",dwByteWidth));

        // Round the width to a multiple of 4 bytes
        dwByteWidth = WIDTHBYTES(dwByteWidth);
        TRACE_MSG(("Rounded up to %ld",dwByteWidth));

        dwLength = (dwByteWidth * ((DWORD) lpbi->biHeight));
    }
    else
    {
        // Image is compressed, the length should be correct in the header
        dwLength = lpbi->biSizeImage;
    }

    TRACE_MSG(("Total data length is %d",dwLength));

    return(dwLength);
}


//
//
// Function:    DIB_TotalLength
//
// Purpose:     Return the total length of the DIB (header + colors + data).
//
//
UINT DIB_TotalLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_TotalLength");

    ASSERT(lpbi);

    // Header + Palette + Bits
    return(lpbi->biSize + DIB_PaletteLength(lpbi) + DIB_DataLength(lpbi));
}


//
//
// Function:    DIB_CreatePalette
//
// Purpose:     Create a palette object from the bitmap info color table
//
//
HPALETTE DIB_CreatePalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE    *pPal;
    HPALETTE      hpal = NULL;
    WORD          nNumColors;
    BYTE          red;
    BYTE          green;
    BYTE          blue;
    WORD          i;
    RGBQUAD FAR * pRgb;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_CreatePalette");

    if (!lpbi)
        return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    // Get a pointer to the color table and the number of colors in it
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = (WORD)DIB_NumberOfColors(lpbi);

    if (nNumColors)
    {
        TRACE_MSG(("There are %d colors in the palette",nNumColors));

        // Allocate for the logical palette structure
        pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR, sizeof(LOGPALETTE)
                                    + (nNumColors * sizeof(PALETTEENTRY)));
        if (!pPal)
        {
            ERROR_OUT(("Couldn't allocate palette memory"));
            return(NULL);
        }

        pPal->palNumEntries = nNumColors;
        pPal->palVersion    = PALVERSION;

        // Fill in the palette entries from the DIB color table and
        // create a logical color palette.
        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;
        }

        hpal = ::CreatePalette(pPal);

        ::GlobalFree((HGLOBAL)pPal);
    }
    else
    {
        if (lpbi->biBitCount == 24)
        {
            // A 24 bitcount DIB has no color table entries so, set the number
            // of to the maximum value (256).
            nNumColors = MAXPALETTE;

            pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR,  sizeof(LOGPALETTE)
                    + (nNumColors * sizeof(PALETTEENTRY)));
            if (!pPal)
            {
                ERROR_OUT(("Couldn't allocate palette memory"));
                return NULL;
            }

            pPal->palNumEntries = nNumColors;
            pPal->palVersion    = PALVERSION;

            red = green = blue = 0;

            // Generate 256 (= 8*8*4) RGB combinations to fill the palette
            // entries.

            for (i = 0; i < pPal->palNumEntries; i++)
            {
                pPal->palPalEntry[i].peRed   = red;
                pPal->palPalEntry[i].peGreen = green;
                pPal->palPalEntry[i].peBlue  = blue;
                pPal->palPalEntry[i].peFlags = (BYTE) 0;

                if (!(red += 32))
                    if (!(green += 32))
                        blue += 64;
            }

            hpal = ::CreatePalette(pPal);
            ::GlobalFree((HGLOBAL)pPal);
        }
    }

    return hpal;
}


//
//
// Function:    DIB_Bits
//
// Purpose:     Return a pointer to the bitmap bits data (from a pointer
//              to the bitmap info header).
//
//
LPSTR DIB_Bits(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Bits");
    ASSERT(lpbi);

    return ((LPSTR) (((char *) lpbi)
                   + lpbi->biSize
                   + DIB_PaletteLength(lpbi)));
}



//
//
// Function:    DIB_FromScreenArea
//
// Purpose:     Create a DIB from an area of the screen
//
//
LPBITMAPINFOHEADER DIB_FromScreenArea(LPCRECT lprect)
{
    HBITMAP     hBitmap     = NULL;
    HPALETTE    hPalette    = NULL;
    LPBITMAPINFOHEADER lpbi = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromScreenArea");

    //  Get the device-dependent bitmap from the screen area
    hBitmap = FromScreenAreaBmp(lprect);
    if (hBitmap != NULL)
    {
        // Get the current system palette
        hPalette = CreateSystemPalette();
        lpbi = DIB_FromBitmap(hBitmap, hPalette, FALSE);
    }

    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    return(lpbi);
}


//
//
// Function:    DIB_Copy
//
// Purpose:     Make a copy of the DIB memory
//
//
LPBITMAPINFOHEADER DIB_Copy(LPBITMAPINFOHEADER lpbi)
{
    LPBITMAPINFOHEADER  lpbiNew = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Copy");

    ASSERT(lpbi);

    // Get the length of memory
    DWORD dwLen = DIB_TotalLength(lpbi);

    lpbiNew = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
    if (lpbiNew != NULL)
    {
        // Copy the data
        memcpy(lpbiNew, lpbi, dwLen);
    }

    return(lpbiNew);
}

//
//
// Function:    DIB_FromBitmap
//
// Purpose:     Creates a DIB from a bitmap and palette
//
//
LPBITMAPINFOHEADER DIB_FromBitmap
(
    HBITMAP     hBitmap,
    HPALETTE    hPalette,
    BOOL        fGHandle
)
{
    LPBITMAPINFOHEADER  lpbi = NULL;
    HGLOBAL             hmem = NULL;
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    DWORD               dwLen;
    WORD                biBits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromBitmap");

    // If the bitmap handle given is null, do nothing
    if (hBitmap != NULL)
    {
        if (hPalette == NULL)
            hPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);

        // Get the bitmap information
        ::GetObject(hBitmap, sizeof(bm), (LPSTR) &bm);

        biBits =  (WORD) (bm.bmPlanes * bm.bmBitsPixel);

        if (biBits > 8)
        {
            // If > 8, make life easy and use plain R-G-B 24-bits
            biBits = 24;
        }

        bi.biSize               = sizeof(BITMAPINFOHEADER);
        bi.biWidth              = bm.bmWidth;
        bi.biHeight             = bm.bmHeight;
        bi.biPlanes             = 1;
        bi.biBitCount           = biBits;
        bi.biCompression        = 0;
        bi.biSizeImage          = 0;
        bi.biXPelsPerMeter      = 0;
        bi.biYPelsPerMeter      = 0;
        bi.biClrUsed            = 0;
        bi.biClrImportant       = 0;

        dwLen  = bi.biSize + DIB_PaletteLength(&bi);

        HDC         hdc;
        HPALETTE    hPalOld;

        hdc = ::CreateDC("DISPLAY", NULL, NULL, NULL);
        hPalOld = ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);

        // Allocate memory for the DIB
        if (fGHandle)
        {
            // For the clipboard, we MUST use GHND
            hmem = ::GlobalAlloc(GHND, dwLen);
            lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
        }
        else
        {
            lpbi = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
        }

        if (lpbi != NULL)
        {
            *lpbi = bi;

            // Call GetDIBits with a NULL lpBits param, so it will calculate the
            // biSizeImage field for us
            ::GetDIBits(hdc, hBitmap, 0, (WORD) bi.biHeight, NULL,
                  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

            bi = *lpbi;

            // If the driver did not fill in the biSizeImage field, make one up
            if (bi.biSizeImage == 0)
            {
                bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
            }

            // Realloc the buffer big enough to hold all the bits
            dwLen = bi.biSize + DIB_PaletteLength(&bi) + bi.biSizeImage;

            if (fGHandle)
            {
                HGLOBAL hT;

                ::GlobalUnlock(hmem);
                hT = ::GlobalReAlloc(hmem, dwLen, GHND);
                if (!hT)
                {
                    ERROR_OUT(("Can't reallocate DIB handle"));
                    ::GlobalFree(hmem);
                    hmem = NULL;
                    lpbi = NULL;
                }
                else
                {
                    hmem = hT;
                    lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
                }
            }
            else
            {
                LPBITMAPINFOHEADER lpbiT;

                lpbiT = (LPBITMAPINFOHEADER)::GlobalReAlloc((HGLOBAL)lpbi, dwLen, GMEM_MOVEABLE);
                if (!lpbiT)
                {
                    ERROR_OUT(("Can't reallocate DIB ptr"));

                    ::GlobalFree((HGLOBAL)lpbi);
                    lpbi = NULL;
                }
                else
                {
                    lpbi = lpbiT;
                }
            }
        }

        if (lpbi != NULL)
        {
            ::GetDIBits(hdc, hBitmap, 0,
                    (WORD)bi.biHeight,
                    DIB_Bits(lpbi),
                    (LPBITMAPINFO)lpbi,
                    DIB_RGB_COLORS);

            if (fGHandle)
            {
                // We want to return the HANDLE, not the POINTER
                ::GlobalUnlock(hmem);
                lpbi = (LPBITMAPINFOHEADER)hmem;
            }
        }

        // Restore the old palette and give back the device context
        ::SelectPalette(hdc, hPalOld, FALSE);
        ::DeleteDC(hdc);
    }

    return(lpbi);
}





//
// AbortProc()
// Process messages during printing
//
//
BOOL CALLBACK AbortProc(HDC, int)
{
    MSG msg;

    ASSERT(g_pPrinter);

    // Message pump in case user wants to cancel printing
    while (!g_pPrinter->Aborted()
        && PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        if ( (g_pPrinter->m_hwndDialog == NULL) ||
            !::IsDialogMessage(g_pPrinter->m_hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return !g_pPrinter->Aborted();
}

//
//
// Function:    WbPrinter
//
// Purpose:     Constructor for a printer object
//
//
WbPrinter::WbPrinter(LPCTSTR szDeviceName)
{
    m_szDeviceName = szDeviceName;
    m_szPrintPageText[0] = 0;

    // Set up the global pointer for the abort procedure
    g_pPrinter = this;

    // Create the dialog window
    m_hwndDialog = ::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(PRINTCANCEL),
        g_pMain->m_hwnd, CancelPrintDlgProc, 0);

    // Save the original text for the page number area
    ::GetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, m_szPrintPageText, _MAX_PATH);
}


//
//
// Function:    ~WbPrinter
//
// Purpose:     Destructor for a printer object
//
//
WbPrinter::~WbPrinter(void)
{
    // Kill off the dialog etc. if still around
    StopDialog();

    ASSERT(m_hwndDialog == NULL);

    g_pPrinter = NULL;
}


//
// StopDialog()
// If the dialog is up, ends it.
//
void WbPrinter::StopDialog(void)
{
    ::EnableWindow(g_pMain->m_hwnd, TRUE);

    // Close and destroy the dialog
    if (m_hwndDialog != NULL)
    {
        ::DestroyWindow(m_hwndDialog);
        m_hwndDialog = NULL;
    }

}

//
//
// Function:    StartDoc
//
// Purpose:     Tell the printer we are starting a new document
//
//
int WbPrinter::StartDoc
(
    HDC     hdc,
    LPCTSTR szJobName,
    int     nStartPage
)
{
    // Initialize the result codes and page number
    m_bAborted  = FALSE;         // Not aborted
    m_nPrintResult = 1;        // Greater than 0 implies all is well

    // Disable the main window
    ::EnableWindow(g_pMain->m_hwnd, FALSE);

    // Attach the printer DC
    SetPrintPageNumber(nStartPage);

    // Set up the abort routine for the print
    if (SetAbortProc(hdc, AbortProc) >= 0)
    {
        // Abort routine successfully set
        ::ShowWindow(m_hwndDialog, SW_SHOW);
        ::UpdateWindow(m_hwndDialog);

	    DOCINFO docinfo;

        docinfo.cbSize = sizeof(DOCINFO);
        docinfo.lpszDocName = szJobName;
        docinfo.lpszOutput = NULL;
        docinfo.lpszDatatype = NULL;   // Windows 95 only; ignored on Windows NT
        docinfo.fwType = 0;         // Windows 95 only; ignored on Windows NT

        // Initialize the document.
        m_nPrintResult = ::StartDoc(hdc, &docinfo);
    }

    return m_nPrintResult;
}

//
//
// Function:    StartPage
//
// Purpose:     Tell the printer we are starting a new page
//
//
int WbPrinter::StartPage(HDC hdc, int nPageNumber)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::StartPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        SetPrintPageNumber(nPageNumber);

        // Tell the printer of the new page number
        m_nPrintResult = ::StartPage(hdc);
    }

    return(m_nPrintResult);
}


//
//
// Function:    EndPage
//
// Purpose:     Tell the printer we are finishing a page
//
//
int WbPrinter::EndPage(HDC hdc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::EndPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        // Tell the printer of the new page number
        m_nPrintResult = ::EndPage(hdc);
    }

    return(m_nPrintResult);
}

//
//
// Function:    EndDoc
//
// Purpose:     Tell the printer we have completed a document
//
//
int WbPrinter::EndDoc(HDC hdc)
{
    // If an error has occurred the driver will already have aborted the print
    if (m_nPrintResult > 0)
    {
        if (!m_bAborted)
        {
            // If we have not been aborted, and no error has occurred
            //   end the document
            m_nPrintResult = ::EndDoc(hdc);
        }
        else
        {
            m_nPrintResult = ::AbortDoc(hdc);
        }
    }

    StopDialog();

    // Return an the error indicator
    return m_nPrintResult;
}

//
//
// Function:    AbortDoc
//
// Purpose:     Abort the document currently in progress
//
//
int WbPrinter::AbortDoc()
{
    // Show that we have been aborted, the actual abort is
    // done by the EndDoc call.
    m_bAborted = TRUE;

    //
    // Renable the application window.
    //
    StopDialog();

    // Return a positive value indicating "aborted OK"
    return 1;
}


//
//
// Function:    SetPrintPageNumber
//
// Purpose:     Set the number of the page currently being printed
//
//
void WbPrinter::SetPrintPageNumber(int nPageNumber)
{
	// Display the number of the page currently being printed
	TCHAR szPageNumber [10 + _MAX_PATH];

    wsprintf(szPageNumber, m_szPrintPageText, nPageNumber);
    ::SetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, szPageNumber);
}


//
// CancelPrintDlgProc()
// Dialog message handler for the cancel printing dialog
//
INT_PTR CALLBACK CancelPrintDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ASSERT(g_pPrinter != NULL);
            ::SetDlgItemText(hwnd, IDD_DEVICE_NAME, g_pPrinter->m_szDeviceName);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ASSERT(g_pPrinter != NULL);
                            g_pPrinter->AbortDoc();
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// Bogus Bogus LAURABU
// STRING ARRAY (TEMP!)
//

StrArray::StrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = 0;
}

StrArray::~StrArray()
{
    ClearOut();
}


void StrArray::ClearOut(void)
{
    int iItem;

    for (iItem = 0; iItem < m_nSize; iItem++)
    {
        if (m_pData[iItem] != NULL)
        {
            delete (LPTSTR)m_pData[iItem];
            m_pData[iItem] = NULL;
        }
    }

    m_nSize = 0;
    m_nMaxSize = 0;

    if (m_pData != NULL)
    {
        delete[] m_pData;
        m_pData = NULL;
    }

}


void StrArray::SetSize(int nNewSize)
{
	if (nNewSize == 0)
	{
		// shrink to nothing
        ClearOut();
	}
    else if (nNewSize <= m_nMaxSize)
    {
        // No shrinking allowed.
        ASSERT(nNewSize >= m_nSize);

        // We're still within the alloced block range
        m_nSize = nNewSize;
    }
	else
	{
        //
		// Make a larger array (isn't this lovely if you already have an
        // array, we alloc a new one and free the old one)
        //
		int nNewMax;

        nNewMax = (nNewSize + (ALLOC_CHUNK -1)) & ~(ALLOC_CHUNK-1);
		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

		LPCTSTR* pNewData = new LPCTSTR[nNewMax];
        if (!pNewData)
        {
            ERROR_OUT(("StrArray::SetSize failed, couldn't allocate larger array"));
        }
        else
        {
            // Zero out the memory
            ZeroMemory(pNewData, nNewMax * sizeof(LPCTSTR));

            // If an old array exists, copy the existing string ptrs.
            if (m_pData != NULL)
            {
                CopyMemory(pNewData, m_pData, m_nSize * sizeof(LPCTSTR));

                //
                // Delete the old array, but not the strings inside, we're
                // keeping them around in the new array
                //
                delete[] m_pData;
            }

    		m_pData = pNewData;
	    	m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
	}
}


void StrArray::SetAtGrow(int nIndex, LPCTSTR newElement)
{
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);

    SetAt(nIndex, newElement);
}


LPCTSTR StrArray::operator[](int nIndex) const
{
    ASSERT(nIndex >= 0);

    if (nIndex < m_nSize)
    {
        ASSERT(m_pData != NULL);
        return(m_pData[nIndex]);
    }
    else
    {
        WARNING_OUT(("StrArray[] got index outside of bounds"));
        return(NULL);
    }
}


void StrArray::SetAt(int nIndex, LPCTSTR newElement)
{
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        WARNING_OUT(("StrArray::SetAt got index outside of bounds"));
        return;
    }

    ASSERT(m_pData != NULL);

    m_pData[nIndex] = new TCHAR[lstrlen(newElement) + 1];
    if (!m_pData[nIndex])
    {
        ERROR_OUT(("StrArray::SetAt failed to allocate string %s at pos %d",
            newElement, nIndex));
    }
    else
    {
        lstrcpy((LPTSTR)m_pData[nIndex], newElement);
    }
}


void StrArray::Add(LPCTSTR newElement)
{
	SetAtGrow(m_nSize, newElement);
}


//
//char *StrTok(string, control) - tokenize string with delimiter in control
//
char *  StrTok (char * string, char * control)
{
        char *str;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last StrTok call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\clpbd.cpp ===
//
// CLPBD.CPP
// Clipboard Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



//
// NFC, SFR 5921.  Maximum length of a string pasted from the clipboard.
// We impose this limit as our graphic object code cant
// handle more then this number of chars.
//
#define WB_MAX_TEXT_PASTE_LEN  (INT_MAX-1)

//
//
// Function:    Paste
//
// Purpose:     Paste a format from the clipboard
//
//
DCWbGraphic* WbMainWindow::CLP_Paste(void)
{
    UINT        length = 0;
    HANDLE      handle = NULL;
    DCWbGraphic* pGraphic = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Paste");

    // Get the highest priority acceptable format in the clipboard
    int iFormat = CLP_AcceptableClipboardFormat();
    if (!iFormat)
        goto NoOpenClip;

    TRACE_MSG(("Found acceptable format %d", iFormat));

    // Open the clipboard

    if (!::OpenClipboard(m_hwnd))
    {
        WARNING_OUT(("CLP_Paste: can't open clipboard"));
        goto NoOpenClip;
    }

    handle = ::GetClipboardData(iFormat);
    if (!handle)
    {
        WARNING_OUT(("CLP_Paste: can't get data for format %d", iFormat));
        goto NoFormatData;
    }

    switch (iFormat)
    {
        //
        // Check the standard formats
        //
        case CF_DIB:
        {
            TRACE_MSG(("Pasting CF_DIB"));

            // Lock the handle to get a pointer to the DIB
            LPBITMAPINFOHEADER lpbi;
            lpbi = (LPBITMAPINFOHEADER) ::GlobalLock(handle);
            if (lpbi != NULL)
            {
                LPBITMAPINFOHEADER lpbiNew;

                // Make a copy of the clipboard data
                lpbiNew = DIB_Copy(lpbi);
                if (lpbiNew != NULL)
                {
                    // Create a graphic object
                    DCWbGraphicDIB* pDIB = new DCWbGraphicDIB();
                    if (!pDIB)
                    {
                        ERROR_OUT(("CF_DIB clipboard handling; couldn't create new DCWbGraphicDIB object"));
                    }
                    else
                    {
                        pDIB->SetImage(lpbiNew);
                    }

                    TRACE_MSG(("Set DIB into graphic object %lx",pDIB));
                    pGraphic = pDIB;
                }

                // Release the memory
                ::GlobalUnlock(handle);
            }
        }
        break;

        //
        // We have a metafile. Play it into a bitmap and then use the
        // data.
        //
        case CF_ENHMETAFILE:
        {
            TRACE_MSG(("Pasting CF_ENHMETAFILE"));

            HDC         hDrawingDC;
            ENHMETAHEADER meta_header;
            HBITMAP     hBitmap = NULL;
            HDC         meta_dc = NULL;
            HBITMAP     hSaveBitmap;
            HPEN        hSavePen;
            HPALETTE    hPalette;
            RECT        meta_rect;
            LPBITMAPINFOHEADER lpbiNew;
            int         tmp;

            // We just need a DC compatible with the drawing area wnd
            hDrawingDC = m_drawingArea.GetCachedDC();

            // make a dc
            meta_dc = ::CreateCompatibleDC(hDrawingDC);
            if (!meta_dc)
                goto CleanupMetaFile;

            // figure out image size.
            ::GetEnhMetaFileHeader( (HENHMETAFILE)handle,
                                      sizeof( ENHMETAHEADER ),
                                      &meta_header );
            meta_rect.left = meta_rect.top = 0;

            meta_rect.right = ((meta_header.rclFrame.right - meta_header.rclFrame.left)
                * ::GetDeviceCaps(hDrawingDC, LOGPIXELSX ))/2540;

            meta_rect.bottom = ((meta_header.rclFrame.bottom - meta_header.rclFrame.top)
                * ::GetDeviceCaps(hDrawingDC, LOGPIXELSY ))/2540;

            // Normalize coords
            if (meta_rect.right < meta_rect.left)
            {
                tmp = meta_rect.left;
                meta_rect.left = meta_rect.right;
                meta_rect.right = tmp;
            }
            if (meta_rect.bottom < meta_rect.top)
            {
                tmp = meta_rect.top;
                meta_rect.top = meta_rect.bottom;
                meta_rect.bottom = tmp;
            }

            // make a place to play meta in
            hBitmap = ::CreateCompatibleBitmap(hDrawingDC,
                meta_rect.right - meta_rect.left,
                meta_rect.bottom - meta_rect.top);
            if (!hBitmap)
                goto CleanupMetaFile;

            hSaveBitmap = SelectBitmap(meta_dc, hBitmap);

            // erase our paper
            hSavePen = SelectPen(meta_dc, GetStockObject(NULL_PEN));

            ::Rectangle(meta_dc, meta_rect.left, meta_rect.top,
                meta_rect.right + 1, meta_rect.bottom + 1);

            SelectPen(meta_dc, hSavePen);

            // play the tape
            ::PlayEnhMetaFile(meta_dc, (HENHMETAFILE)handle, &meta_rect);

            // unplug our new bitmap
            SelectBitmap(meta_dc, hSaveBitmap);

            // Check for a palette object in the clipboard
            hPalette = (HPALETTE)::GetClipboardData(CF_PALETTE);

            // Create a new DIB from the bitmap
            lpbiNew = DIB_FromBitmap(hBitmap, hPalette, FALSE);
            if (lpbiNew != NULL)
            {
                // Create a DIB graphic from the DIB
                DCWbGraphicDIB* pDIB = new DCWbGraphicDIB();
                if (!pDIB)
                {
                    ERROR_OUT(("CF_ENHMETAFILE handling; couldn't allocate DCWbGraphicDIB object"));
                }
                else
                {
                    pDIB->SetImage(lpbiNew);
                }

                TRACE_MSG(("Set bitmap DIB into graphic object %lx",pDIB));
                pGraphic = pDIB;
            }

CleanupMetaFile:
            // Free our temp intermediate bitmap
            if (hBitmap != NULL)
            {
                DeleteBitmap(hBitmap);
            }

            if (meta_dc != NULL)
            {
                ::DeleteDC(meta_dc);
            }
        }
        break;

        case CF_TEXT:
        {
            LPSTR   pData;

            TRACE_DEBUG(("Pasting text"));

            // Get a handle to the clipboard contents
            pData = (LPSTR)::GlobalLock(handle);

			if(pData)
			{
	            // Create a text object to hold the data - get the font to
	            // use from the tool attributes group.
	            DCWbGraphicText* pPasteText = new DCWbGraphicText();

    	        // Use the current font attributes
                if (!pPasteText)
                {
                    ERROR_OUT(("CF_TEXT handling; failed to allocate DCWbGraphicText object"));
                }
                else
                {
                    pPasteText->SetFont(m_pCurrentTool->GetFont());
    	            pPasteText->SetText(pData);
                }

        	    pGraphic = pPasteText;
            }

            // Release the handle
            ::GlobalUnlock(handle);
        }
        break;

        default:
        {
            if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
            {
                // There is a Whiteboard private format object in the clipboard.
                // The format of this object is exactly as stored in the page, we
                // can therefore use it immediately.
                TRACE_DEBUG(("Pasting a private Whiteboard object"));

                // Get a handle to the clipboard contents
                PWB_GRAPHIC pHeader;
                if (pHeader = (PWB_GRAPHIC) ::GlobalLock(handle))
                {
                    // Add the object to the page
                    pGraphic = DCWbGraphic::CopyGraphic(pHeader);

                    // Release the handle
                    ::GlobalUnlock(handle);
                }
            }
            else if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ])
            {
                DCWbGraphicMarker * pMarker = m_drawingArea.GetMarker();
                if (!pMarker)
                {
                    ERROR_OUT(("Couldn't get marker from drawing area"));
                }
                else
                {
                    pMarker->Paste(handle);
                }

                pGraphic = pMarker;
            }
        }
        break;
    }

NoFormatData:
    ::CloseClipboard();

NoOpenClip:
    return pGraphic;
}


//
//
// Function:    Copy
//
// Purpose:     Copy a graphic to the clipboard. The second parameter
//              indicates whether immediate rendering is required.
//
//
BOOL WbMainWindow::CLP_Copy(DCWbGraphic* pGraphic, BOOL bRenderNow)
{
    BOOL bResult = FALSE;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Copy");
    ASSERT(pGraphic != NULL);

    //
    // We act according to the format of the selected graphic.
    //
    // For all formats we supply the Whiteboard private format (which is
    // just a copy of the flat representation of the graphic).
    //
    // We supply standard formats as follows.
    //
    // For bitmaps and all others we supply CF_DIB.
    //
    // For text graphics we supply CF_TEXT.
    //

    // Free up the saved delayed rendering graphic since we are about to
    // replace it in the clipboard
    CLP_FreeDelayedGraphic();

    // Save the page and handle of the new graphic, since they'll be used 
    // for/ rendering it, either now or later
    m_hPageClip = pGraphic->Page();
    m_hGraphicClip = pGraphic->Handle();

    if (bRenderNow)
    {
        TRACE_MSG(("Rendering the graphic now"));

        // Have to empty the clipboard before rendering the formats.
        if (::OpenClipboard(m_hwnd))
        {
            // Get ownership of the clipboard
            ::EmptyClipboard();
            ::CloseClipboard();

            // Render the graphic
            bResult = CLP_RenderAllFormats(pGraphic);
        }

        // We can forget about this object now.
        ASSERT(m_pDelayedGraphicClip == NULL);

        m_hPageClip = WB_PAGE_HANDLE_NULL;
        m_hGraphicClip = NULL;
    }
    else
    {
        TRACE_MSG(("Delaying rendering"));

        // For delayed rendering we insist that the graphic has been saved
        // to external storage. It must therefore have a valid page and graphic
        // handle.
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        // Give formats (but no data) to the clipboard
        bResult = CLP_DelayAllFormats(pGraphic);
    }

    return bResult;
}

//
//
// Function:    DelayAllFormats
//
// Purpose:     Copy a graphic to the clipboard with delayed rendering
//
//
BOOL WbMainWindow::CLP_DelayAllFormats(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_DelayAllFormats");
    BOOL bResult = FALSE;

    if (::OpenClipboard(m_hwnd))
    {
        // Empty / get ownership of the clipboard
        bResult = ::EmptyClipboard();

        // Add the private format
        HANDLE hResult;
        hResult = 
            ::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ], NULL);
        TRACE_DEBUG(("Adding Whiteboard object to clipboard"));

        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            // Text graphic
            hResult = ::SetClipboardData(CF_TEXT, NULL);
            TRACE_DEBUG(("Adding text to clipboard"));
        }
        else
        {
            // All other graphics
            hResult = ::SetClipboardData(CF_DIB, NULL);
            TRACE_DEBUG(("Adding DIB to clipboard"));
        }

        ::CloseClipboard();
    }

    return bResult;
}


//
//
// Function:    RenderAllFormats
//
// Purpose:     Render a graphic to the clipboard
//
//
BOOL WbMainWindow::CLP_RenderAllFormats(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");
    BOOL bResult = FALSE;

    // Open the clipboard
    if (bResult = ::OpenClipboard(m_hwnd))
    {
        TRACE_DEBUG(("Rendering all formats of graphic"));

        // Render the private format
        bResult &= CLP_RenderPrivateFormat(pGraphic);

        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            // Text graphic
            bResult &= CLP_RenderAsText(pGraphic);
        }
        else if (pGraphic->IsGraphicTool() == enumGraphicDIB)
        {
            // DIBs
            bResult &= CLP_RenderAsImage(pGraphic);
        }
        else
        {
            bResult &= CLP_RenderAsBitmap(pGraphic);
        }

        // Close the clipboard
        ::CloseClipboard();
    }

    return bResult;
}



BOOL WbMainWindow::CLP_RenderPrivateFormat(DCWbGraphic* pGraphic)
{
    if (pGraphic->IsGraphicTool() == enumGraphicMarker)
        return( ((DCWbGraphicMarker*)pGraphic)->RenderPrivateMarkerFormat() );
    else
        return(CLP_RenderPrivateSingleFormat(pGraphic));
}


//
//
// Function:    RenderPrivateSingleFormat
//
// Purpose:     Render the private format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//
//
BOOL WbMainWindow::CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderPrivateFormat");
    ASSERT(pGraphic != NULL);

    BOOL bResult = FALSE;

    // Get a pointer to the graphic data
    PWB_GRAPHIC pHeader = CLP_GetGraphicData();
    if (pHeader != NULL)
    {
        // Allocate memory for the clipboard data
        HANDLE hMem = ::GlobalAlloc(GHND, pHeader->length);
        if (hMem != NULL)
        {
            // Get a pointer to the memory
            LPBYTE pDest = (LPBYTE)::GlobalLock(hMem);
            if (pDest != NULL)
            {
                // Copy the graphic data to the allocated memory
                memcpy(pDest, pHeader, pHeader->length);
                TRACE_MSG(("Copied data %d bytes into %lx",pHeader->length,pDest));

                // make sure copy isn't "locked" (bug 474)
                ((PWB_GRAPHIC)pDest)->locked = WB_GRAPHIC_LOCK_NONE;

                // Release the memory
                ::GlobalUnlock(hMem);

                // Pass the data to the clipboard
                if (::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ], hMem))
                {
                    TRACE_DEBUG(("Rendered data in Whiteboard format"));
                    bResult = TRUE;
                }
            }

            // If we failed to put the data into the clipboard, free the memory.
            // (If we did put it into the clipboard we must not free it).
            if (bResult == FALSE)
            {
                WARNING_OUT(("Render failed"));
                ::GlobalFree(hMem);
            }
        }

        // Release the graphic data
        CLP_ReleaseGraphicData(pHeader);
    }

    return bResult;
}

//
//
// Function:    RenderAsText
//
// Purpose:     Render the text format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//              This member should only be called for text graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsText
(
    DCWbGraphic* pGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsText");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() == enumGraphicText);

    BOOL bResult = FALSE;

    // Get the total length of the clipboard format of the text
    StrArray& strText = ((DCWbGraphicText*) pGraphic)->strTextArray;
    int   iCount = strText.GetSize();
    int   iIndex;
    DWORD dwLength = 0;

    for (iIndex = 0; iIndex < iCount; iIndex++)
    {
        // Length of string plus 2 for carriage return and line feed
        dwLength += lstrlen(strText[iIndex]) + 2;
    }

    // One more for the terminating NULL
    dwLength += 1;

    // Allocate memory for the clipboard data
    HANDLE hMem = ::GlobalAlloc(GHND, dwLength);
    if (hMem != NULL)
    {
        // Get a pointer to the memory
        LPSTR pDest = (LPSTR) ::GlobalLock(hMem);
        if (pDest != NULL)
        {
            // Write the graphic data to the allocated memory
            for (iIndex = 0; iIndex < iCount; iIndex++)
            {
                _tcscpy(pDest, strText[iIndex]);
                pDest += lstrlen(strText[iIndex]);

                // Add the carriage return and line feed
                *pDest++ = '\r';
                *pDest++ = '\n';
            }

            // Add the final NULL
            *pDest = '\0';

            // Release the memory
            ::GlobalUnlock(hMem);

            // Pass the data to the clipboard
            if (::SetClipboardData(CF_TEXT, hMem))
            {
                TRACE_DEBUG(("Rendered data in text format"));
                bResult = TRUE;
            }
        }

        // If we failed to put the data into the clipboard, free the memory
        if (bResult == FALSE)
        {
            ::GlobalFree(hMem);
        }
    }

    return bResult;
}

//
//
// Function:    RenderAsImage
//
// Purpose:     Render the bitmap format of a graphic to the clipboard.
//              The clipboard should be open before this call is made.
//              This member should only be called for DIB graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsImage
(
    DCWbGraphic* pGraphic
)
{
    BOOL bResult = FALSE;
    HANDLE hMem = NULL;
    BYTE*  pDest = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsImage");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() == enumGraphicDIB);

    // Get a pointer to the graphic data
    PWB_GRAPHIC pHeader = CLP_GetGraphicData();
    if (pHeader != NULL)
    {
        LPBITMAPINFOHEADER lpbi;

        TRACE_MSG(("Getting a DIB image from %lx",pHeader));
        lpbi = (LPBITMAPINFOHEADER) (((LPBYTE) pHeader) + pHeader->dataOffset);
        DWORD dwLength = pHeader->length - pHeader->dataOffset;

        // Allocate the memory
        hMem = ::GlobalAlloc(GHND, dwLength);
        if (hMem != NULL)
        {
            pDest = (LPBYTE)::GlobalLock(hMem);
            if (pDest != NULL)
            {
                TRACE_MSG(("Building DIB at %lx length %ld",pDest, dwLength));
                memcpy(pDest, lpbi, dwLength);
                ::GlobalUnlock(hMem);

                if (::SetClipboardData(CF_DIB, hMem))
                {
                    TRACE_DEBUG(("Rendered data in DIB format"));
                    bResult = TRUE;
                }

                // If we failed to put the data into the clipboard, free the memory
                if (!bResult)
                {
                    ERROR_OUT(("Error putting DIB into clipboard"));
                    ::GlobalFree(hMem);
                }
            }
        }
        else
        {
            ERROR_OUT(("Could not allocate memory for DIB"));
        }

        // Release the data
        CLP_ReleaseGraphicData(pHeader);
    }

    return bResult;
}


//
// CLP_RenderAsBitmap()
//
// This draws all other graphics into a bitmap and pastes the DIB contents
// onto the clipboard.
//
BOOL WbMainWindow::CLP_RenderAsBitmap(DCWbGraphic* pGraphic)
{
    BOOL    bResult = FALSE;
    HDC     hdcDisplay = NULL;
    HDC     hdcMem = NULL;
    HBITMAP hBitmap = NULL;
    HBITMAP hOldBitmap = NULL;
    HPALETTE hPalette;
    RECT    rcBounds;
    POINT   pt;
    LPBITMAPINFOHEADER lpbi;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsBitmap");

    ASSERT(pGraphic != NULL);
    ASSERT(pGraphic->IsGraphicTool() != enumGraphicText);
    ASSERT(pGraphic->IsGraphicTool() != enumGraphicDIB);

    //
    // First, draw it into a bitmap
    // Second, get the DIB bits of the bitmap
    //

    hdcDisplay = ::CreateDC("DISPLAY", NULL, NULL, NULL);
    if (!hdcDisplay)
    {
        ERROR_OUT(("Can't create DISPLAY dc"));
        goto AsBitmapDone;
    }

    hdcMem = ::CreateCompatibleDC(hdcDisplay);
    if (!hdcMem)
    {
        ERROR_OUT(("Can't create DISPLAY compatible dc"));
        goto AsBitmapDone;
    }

    pGraphic->GetBoundsRect(&rcBounds);

    hBitmap = ::CreateCompatibleBitmap(hdcDisplay,
        (rcBounds.right - rcBounds.left), (rcBounds.bottom - rcBounds.top));
    if (!hBitmap)
    {
        ERROR_OUT(("Can't create compatible bitmap"));
        goto AsBitmapDone;
    }

    hOldBitmap = SelectBitmap(hdcMem, hBitmap);
    if (!hOldBitmap)
    {
        ERROR_OUT(("Failed to select compatible bitmap"));
        goto AsBitmapDone;
    }

    ::SetMapMode(hdcMem, MM_ANISOTROPIC);
    pGraphic->GetPosition(&pt);
    ::SetWindowOrgEx(hdcMem, pt.x, pt.y, NULL);

    // Clear out bitmap with white background -- now that origin has been
    // altered, we can use drawing area coors.
    ::PatBlt(hdcMem, rcBounds.left, rcBounds.top, rcBounds.right - rcBounds.left,
        rcBounds.bottom - rcBounds.top, WHITENESS);

    if (pGraphic->IsGraphicTool() == enumGraphicMarker)
    {
        ((DCWbGraphicMarker *)pGraphic)->Draw(hdcMem, TRUE);
    }
    else
    {
        pGraphic->Draw(hdcMem);
    }

    SelectBitmap(hdcMem, hOldBitmap);

    // Now get the dib bits...
    hPalette = CreateSystemPalette();
    lpbi = DIB_FromBitmap(hBitmap, hPalette, TRUE);
    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    // And put the handle on the clipboard
    if (lpbi != NULL)
    {
        if (::SetClipboardData(CF_DIB, (HGLOBAL)lpbi))
        {
            bResult = TRUE;
        }
        else
        {
            ::GlobalFree((HGLOBAL)lpbi);
        }
    }

AsBitmapDone:
    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    if (hdcMem != NULL)
        ::DeleteDC(hdcMem);

    if (hdcDisplay != NULL)
        ::DeleteDC(hdcDisplay);

    return(bResult);
}



//
//
// Function:    RenderFormat
//
// Purpose:     Render the specified format of the graphic in the clipboard.
//
//
BOOL WbMainWindow::CLP_RenderFormat(int iFormat)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderFormat");

    BOOL bResult = FALSE;

    // Get a graphic from the handle
    DCWbGraphic* pGraphic = CLP_GetGraphic();

    if (pGraphic != NULL)
    {
        // Check if it is the private format that is wanted
        switch (iFormat)
        {
            default:
            {
                if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
                {
                    bResult = CLP_RenderPrivateFormat(pGraphic);
                }
                else
                {
                    ERROR_OUT(("Unrecognized CLP format %d", iFormat));
                }
            }
            break;

            case CF_TEXT:
            {
                bResult = CLP_RenderAsText(pGraphic);
            }
            break;

            case CF_DIB:
            {
                if (pGraphic->IsGraphicTool() == enumGraphicDIB)
                    bResult = CLP_RenderAsImage(pGraphic);
                else
                    bResult = CLP_RenderAsBitmap(pGraphic);
            }
            break;
        }
    }

    return bResult;
}

//
//
// Function:    RenderAllFormats
//
// Purpose:     Render all formats of the graphic in the clipboard.
//
//
BOOL WbMainWindow::CLP_RenderAllFormats(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");

    BOOL bResult = FALSE;

    // Get a graphic from the handle
    DCWbGraphic* pGraphic = CLP_GetGraphic();

    if (pGraphic != NULL)
    {
        bResult = CLP_RenderAllFormats(pGraphic);
    }

     return bResult;
}

//
//
// Function:    AcceptableClipboardFormat
//
// Purpose:     Return highest priority clipboard format if an acceptable
//              one is available, else return NULL.
//
//
int WbMainWindow::CLP_AcceptableClipboardFormat(void)
{
    // Look for any of the supported formats being available
    int iFormat = ::GetPriorityClipboardFormat((UINT *)g_ClipboardFormats, CLIPBOARD_ACCEPTABLE_FORMATS);
    if (iFormat == -1)
    {
        iFormat = 0;
    }

    // the following is a performance enhancement: if we have found at some
    // point that the object on the clipboard does not have whiteboard
    // private format, then we can discard the delayed graphic because we
    // know we'll never be asked to render it.
    if (iFormat != g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ])
    {
        CLP_FreeDelayedGraphic();
    }

    return iFormat;
}

//
//
// Function:    LastCopiedPage
//
// Purpose:     Return the handle of the page on which the last graphic
//              copied to the clipboard was located.
//
//
WB_PAGE_HANDLE WbMainWindow::CLP_LastCopiedPage(void) const
{
    // If there's no graphic, there shouldn't be a page either
    ASSERT((m_hGraphicClip != NULL) == (m_hPageClip != WB_PAGE_HANDLE_NULL));
    return(m_hPageClip);
}

WB_GRAPHIC_HANDLE WbMainWindow::CLP_LastCopiedGraphic(void) const
{
    return(m_hGraphicClip);
}

//
//
// Function:    GetGraphic
//
// Purpose:     Retrieve the graphic object for copying to the clipboard. If
//              the object has been saved, then use the local copy,
//              otherwise get the page to construct it now.
//
//
DCWbGraphic* WbMainWindow::CLP_GetGraphic(void)
{
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_GetGraphic");

    // if we have not saved the graphic's contents, then we must have a
    // valid page and graphic handle, since we construct the graphic now
    if (m_pDelayedGraphicClip == NULL)
    {
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        pGraphic = DCWbGraphic::ConstructGraphic(m_hPageClip, m_hGraphicClip);
    }
    else
    {
        pGraphic = m_pDelayedGraphicClip;
        TRACE_MSG(("returning delayed graphic %lx",pGraphic));
    }

    return(pGraphic);
}

//
//
// Function:    GetGraphicData
//
// Purpose:     Retrieve the graphic data for copying to the clipboard. If
//              the data has been saved, then get a pointer to the copy (in
//              global memory), otherwise get it from the page.
//
//              The memory must be released with ReleaseGraphicData as soon
//              as possible.
//
//
PWB_GRAPHIC WbMainWindow::CLP_GetGraphicData(void)
{
    PWB_GRAPHIC pHeader;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_GetGraphicData");

    // if we have not saved the graphic's contents, then we must have a
    // valid page and graphic handle, since we get the graphic data now
    pHeader = m_pDelayedDataClip;
    if (pHeader == NULL)
    {
        ASSERT(m_hPageClip != WB_PAGE_HANDLE_NULL);
        ASSERT(m_hGraphicClip != NULL);

        pHeader = PG_GetData(m_hPageClip, m_hGraphicClip);
    }

    return(pHeader);
}

//
//
// Function:    ReleaseGraphicData
//
// Purpose:     Release the data which was accessed by an earlier call to
//              GetGraphicData.
//
//
void WbMainWindow::CLP_ReleaseGraphicData(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_ReleaseGraphicData");

    // release it in the right way, depending on whether we got the data
    // from the page, or just got a pointer to existing global data in
    // CLP_GetGraphicData
    if (m_pDelayedDataClip == NULL)
    {
        g_pwbCore->WBP_GraphicRelease(m_hPageClip, m_hGraphicClip, pHeader);
    }
}

//
//
// Function:    SaveDelayedGraphic
//
// Purpose:     Create a copy of the graphic which was copied to the
//              clipboard with delayed rendering.
//
//
void WbMainWindow::CLP_SaveDelayedGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_SaveDelayedGraphic");

    // Free any previously-held delayed graphic
    CLP_FreeDelayedGraphic();

    // Get the new delayed graphic object and a pointer to its data
    DCWbGraphic* pGraphic = CLP_GetGraphic();
    TRACE_MSG(("Got graphic at address %lx",pGraphic));

    m_pDelayedGraphicClip = pGraphic->Copy();
    TRACE_MSG(("Copied to %lx",m_pDelayedGraphicClip));
    delete pGraphic;

    PWB_GRAPHIC pHeader = PG_GetData(m_hPageClip, m_hGraphicClip);
    TRACE_MSG(("Graphic header %lx",pHeader));

    // Copy the graphic's data into global memory, and save the handle
    m_pDelayedDataClip = (PWB_GRAPHIC)::GlobalAlloc(GPTR, pHeader->length);
    if (m_pDelayedDataClip != NULL)
    {
        // Copy the graphic data to the allocated memory
        memcpy(m_pDelayedDataClip, pHeader, pHeader->length);
    }

    // Release the graphic's data (now we have our own copy)
    g_pwbCore->WBP_GraphicRelease(m_hPageClip, m_hGraphicClip, pHeader);

    // set the graphic handle to NULL because we won't be using it
    // any more
    m_hPageClip = WB_PAGE_HANDLE_NULL;
    m_hGraphicClip = NULL;
}


//
//
// Function:    FreeDelayedGraphic
//
// Purpose:     Free the copy of the delayed graphic (if any).
//
//
void WbMainWindow::CLP_FreeDelayedGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_FreeDelayedGraphic");

    if (m_pDelayedGraphicClip != NULL)
    {
        // free the graphic object
        TRACE_MSG(("Freeing delayed graphic"));

        delete m_pDelayedGraphicClip;
        m_pDelayedGraphicClip = NULL;
    }

    if (m_pDelayedDataClip != NULL)
    {
        // free the associated data
        TRACE_MSG(("Freeing delayed memory %x", m_pDelayedDataClip));

        ::GlobalFree((HGLOBAL)m_pDelayedDataClip);
        m_pDelayedDataClip = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\cgrp.cpp ===
//
// CGRP.CPP
// Color Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szCGClassName[] = "WB_CGRP";

// These default colors are the same as MSPaint
COLORREF g_crDefaultColors[NUMCLRPANES] =
{
        PALETTERGB(   0,  0,  0 ),
        PALETTERGB( 128,128,128 ),
        PALETTERGB( 128,  0,  0 ),
        PALETTERGB( 128,128,  0 ),
        PALETTERGB(   0,128,  0 ),
        PALETTERGB(   0,128,128 ),
        PALETTERGB(   0,  0,128 ),
        PALETTERGB( 128,  0,128 ),
        PALETTERGB( 128,128, 64 ),
        PALETTERGB(   0, 64, 64 ),
        PALETTERGB(   0,128,255 ),
        PALETTERGB(   0, 64,128 ),
        PALETTERGB(  64,  0,255 ),
        PALETTERGB( 128, 64,  0 ),

        PALETTERGB( 255,255,255 ),
        PALETTERGB( 192,192,192 ),
        PALETTERGB( 255,  0,  0 ),
        PALETTERGB( 255,255,  0 ),
        PALETTERGB(   0,255,  0 ),
        PALETTERGB(   0,255,255 ),
        PALETTERGB(   0,  0,255 ),
        PALETTERGB( 255,  0,255 ),
        PALETTERGB( 255,255,128 ),
        PALETTERGB(   0,255,128 ),
        PALETTERGB( 128,255,255 ),
        PALETTERGB( 128,128,255 ),
        PALETTERGB( 255,  0,128 ),
        PALETTERGB( 255,128, 64 ),

        PALETTERGB(   0,  0,  0 )    // Current color
};



//
// WbColorsGroup()
//
WbColorsGroup::WbColorsGroup()
{
    int         i;

    m_hwnd = NULL;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        m_crColors[i] = g_crDefaultColors[i];
        m_hBrushes[i] = NULL;
    }


    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        m_crCustomColors[i] = CLRPANE_WHITE;
    }

    m_nLastColor = 0;
}



WbColorsGroup::~WbColorsGroup(void)
{
    int i;

    // clean up
    for (i = 0; i < NUMCLRPANES; i++)
    {
        if (m_hBrushes[i] != NULL)
        {
            ::DeleteBrush(m_hBrushes[i]);
            m_hBrushes[i] = NULL;
        }
    }

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    // Unregister our class
    ::UnregisterClass(szCGClassName, g_hInstance);
}



BOOL WbColorsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    int         i;
    HDC         hdc;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS;
    wc.lpfnWndProc      = CGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szCGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbColorsGroup::Create register class failed"));
        return(FALSE);
    }

    //
    // We should be created the right siez
    //
    ASSERT(lprect->right - lprect->left == CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH);
    ASSERT(lprect->bottom - lprect->top == CLRCHOICE_HEIGHT);

    //
    // Calculate our item colors, then figure out our size.
    //

    hdc = ::GetDC(hwndParent);
    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(hdc, hPal, FALSE);
        ::RealizePalette(hdc);
    }

    // load the colors from last time
    OPT_GetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_GetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

    // make brushes.
    for (i = 0; i < NUMCLRPANES; i++)
    {
        // force color matching
        m_crColors[i] = SET_PALETTERGB( m_crColors[i] );
        m_hBrushes[i] = ::CreateSolidBrush(m_crColors[i]);
    }

    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        // force color matching
        m_crCustomColors[i] = SET_PALETTERGB( m_crCustomColors[i] );
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hdc, hOldPal, TRUE);
    }
    ::ReleaseDC(hwndParent, hdc);

    //
    // Here's our layout:
    //      * The colors window is CHOICEFRAME_HEIGHT pixels high
    //      * The current choice is a rect of CHOICEFRAME_WIDTH by
    //          CHOICEFRAME_HEIGHT pixels, on the left side.  This includes
    //          a sunken EDGE.
    //      * There is no gap horizontally or vertically among panes.

    //
    // Create our window -- we're always visible.  The attribute group
    // shows/hides colors by showing/hiding itself.
    //
    if (!::CreateWindowEx(0, szCGClassName, NULL, WS_CHILD | WS_VISIBLE,
        lprect->left, lprect->top,
        lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbColorsGroup"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);
    return(TRUE);
}


LRESULT CALLBACK CGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbColorsGroup * pcg;

    pcg = (WbColorsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pcg = (WbColorsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pcg);

            pcg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pcg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pcg);
            pcg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pcg);
            pcg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            pcg->OnLButtonDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONDBLCLK:
            pcg->OnLButtonDblClk((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbColorsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cx = CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH;
    lpsize->cy = CLRCHOICE_HEIGHT;
}



COLORREF WbColorsGroup::GetCurColor(void)
{
    return(GetColorOfBrush(INDEX_CHOICE));
}



void WbColorsGroup::SetCurColor(COLORREF clr)
{
    SetColorOfPane(INDEX_CHOICE, clr);
}






//
// OnPaint()
//
// MFC message handler for WM_PAINT
//
void WbColorsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    int         dx, dy;
    int         i;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    ::BeginPaint(m_hwnd, &ps);

    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(ps.hdc, hPal, FALSE);
        ::RealizePalette(ps.hdc);
    }

    dx = ::GetSystemMetrics(SM_CXEDGE);
    dy = ::GetSystemMetrics(SM_CYEDGE);
    ::GetClientRect(m_hwnd, &rcClient);

    // Draw the current choice
    rc = rcClient;
    rc.right = rc.left + CLRCHOICE_WIDTH;
    ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_RECT);
    ::FillRect(ps.hdc, &rc, m_hBrushes[INDEX_CHOICE]);

    // Draw the colors
    rcClient.left += CLRCHOICE_WIDTH;

    rc = rcClient;
    rc.right = rc.left + CLRPANE_WIDTH;
    rc.bottom = rc.top + CLRPANE_HEIGHT;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        ::FillRect(ps.hdc, &rc, m_hBrushes[i]);
        ::InflateRect(&rc, dx, dy);

        if (i == NUMCOLS - 1)
        {
            ::OffsetRect(&rc, - (NUMCOLS-1)*CLRPANE_WIDTH, CLRPANE_HEIGHT);
        }
        else
        {
            ::OffsetRect(&rc, CLRPANE_WIDTH, 0);
        }

    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(ps.hdc, hOldPal, TRUE);
    }

    ::EndPaint(m_hwnd, &ps);

}

//
// OnLButtonDown()
//
void WbColorsGroup::OnLButtonDown(UINT nFlags, int x, int y)
{
    //
    // If this is the current choice, do nothing.  Otherwise, change the
    // current color.
    //
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        // Set the current color
        SetColorOfPane(INDEX_CHOICE, GetColorOfBrush(pane));
        m_nLastColor = pane;

        // tell Whiteboard about it.
        ClickOwner();
    }
}



//
// OnLButtonDblClk()
//
void  WbColorsGroup::OnLButtonDblClk(UINT nFlags, int x, int y)
// Invoke color dialog to edit this color
{
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        DoColorDialog(pane);
    }
}



// Returns COLORREF of Brushes[] or BLACK if no brush
COLORREF WbColorsGroup::GetColorOfBrush( int nColor )
{
    ASSERT(nColor >= 0);
    ASSERT(nColor < NUMCLRPANES);

    if (m_hBrushes[nColor] != NULL)
    {
        return(m_crColors[nColor]);
    }
    else
    {
        return(CLRPANE_BLACK);
    }
}


// Recreates the nColor-th brush, using the new color
void WbColorsGroup::SetColorOfBrush( int nColor, COLORREF crNewColor )
{
    HBRUSH  hNewBrush;

    // force color matching
    crNewColor = SET_PALETTERGB( crNewColor );

    // check if we need to do anything
    if ((nColor > -1) && (crNewColor != GetColorOfBrush(nColor)))
    {
        // new color is different from old color, make a new brush

        hNewBrush = ::CreateSolidBrush(crNewColor);
        if (hNewBrush != NULL)
        {
            // We managed to create the new brush.  Delete the old one
            if (m_hBrushes[nColor] != NULL)
            {
                ::DeleteBrush(m_hBrushes[nColor]);
            }

            m_hBrushes[nColor] = hNewBrush;
            m_crColors[nColor] = crNewColor;
        }
    }
}



//
// SetColorOfPane()
//
// Replaces brush associated with nPaneId.
//
void WbColorsGroup::SetColorOfPane(int pane, COLORREF crNewColor )
{
    RECT    rcClient;

    // make a new brush
    SetColorOfBrush(pane, crNewColor);

    // update pane
    ::GetClientRect(m_hwnd, &rcClient);
    if (pane == INDEX_CHOICE)
    {
        rcClient.right = rcClient.left + CLRCHOICE_WIDTH;
    }
    else
    {
        rcClient.left += CLRCHOICE_WIDTH;

        rcClient.top += (pane / NUMCOLS) * CLRPANE_HEIGHT;
        rcClient.bottom = rcClient.top + CLRPANE_HEIGHT;
        rcClient.left += (pane % NUMCOLS) * CLRPANE_WIDTH;
        rcClient.right = rcClient.left + CLRPANE_WIDTH;
    }
    ::InvalidateRect(m_hwnd, &rcClient, FALSE);
}




void WbColorsGroup::SaveSettings( void )
    // Saves stuff in registry because we're shutting down
{
    // load the colors from last time
    OPT_SetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_SetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

}



void WbColorsGroup::OnEditColors( void )
{
    DoColorDialog( m_nLastColor );
}



//
// DoColorDialog()
// Put up ComDlg color picker to edit the pane's color value
//
COLORREF WbColorsGroup::DoColorDialog( int nColor )
{
    CHOOSECOLOR cc;

    memset(&cc, 0, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.lpCustColors = m_crCustomColors;
    cc.Flags = CC_RGBINIT;
    cc.rgbResult = GetColorOfBrush(nColor);
    cc.hwndOwner = m_hwnd;

    ::ChooseColor(&cc);

    // force color matching
    cc.rgbResult = SET_PALETTERGB(cc.rgbResult);

    // use the new color
    SetColorOfPane(nColor, cc.rgbResult );

    // set choice pane
    SetColorOfPane(INDEX_CHOICE,  cc.rgbResult );
    m_nLastColor = nColor;

    // tell Whiteboard about it.
    ClickOwner();

    return(cc.rgbResult );
}





void WbColorsGroup::ClickOwner( void )
{
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                    (LPARAM)m_hwnd);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\draw.cpp ===
//
// DRAW.CPP
// Main Drawing Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szDrawClassName[] = "WB_DRAW";

//
//
// Function:    Constructor
//
// Purpose:     Initialize the drawing area object
//
//
WbDrawingArea::WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::WbDrawingArea");

    g_pDraw = this;

    m_hwnd = NULL;

    m_hDCWindow = NULL;
    m_hDCCached = NULL;

    m_originOffset.cx = 0;
    m_originOffset.cy = 0;

    m_posScroll.x     = 0;
    m_posScroll.y     = 0;

    // Show that the drawing area is not zoomed
    m_iZoomFactor = 1;
    m_iZoomOption = 1;

    // Show that the left mouse button is up
    m_bLButtonDown = FALSE;
    m_bIgnoreNextLClick = FALSE;
    m_bBusy = FALSE;
    m_bLocked = FALSE;
    m_HourGlass = FALSE;

    // Indicate that the cached zoom scroll position is invalid
    m_zoomRestoreScroll = FALSE;

    // Show that we are not currently editing text
    m_bGotCaret = FALSE;
    m_bTextEditorActive = FALSE;
    m_pActiveText = NULL;


    // Show that no graphic object is in progress
    m_pGraphicTracker = NULL;

    // Show that the marker is not present.
    m_bMarkerPresent = FALSE;
    m_bNewMarkedGraphic = FALSE;
    m_pSelectedGraphic = NULL;
    m_bTrackingSelectRect = FALSE;

    // Show that no area is currently marked
    ::SetRectEmpty(&m_rcMarkedArea);

    // Show we haven't got a tool yet
    m_pToolCur = NULL;

    // Show that we dont have a page attached yet
    m_hPage = WB_PAGE_HANDLE_NULL;

    m_hStartPaintGraphic = NULL;

    m_pMarker = new DCWbGraphicMarker;
    if (!m_pMarker)
    {
        ERROR_OUT(("Failed to create m_pMarker in WbDrawingArea object constructor"));
    }
}


//
//
// Function:    Destructor
//
// Purpose:     Close down the drawing area
//
//
WbDrawingArea::~WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::~WbDrawingArea");

    if (m_pActiveText != NULL)
    {
        delete m_pActiveText;
        m_pActiveText = NULL;
    }

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;

    if (m_pMarker != NULL)
    {
		delete m_pMarker;
		m_pMarker = NULL;
	}

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szDrawClassName, g_hInstance);

	g_pDraw = NULL;

    //
    // Clean the pointer lists
    //
    m_allPointers.EmptyList();
    m_undrawnPointers.EmptyList();
}

//
// WbDrawingArea::Create()
//
BOOL WbDrawingArea::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Create");

    if (!m_pMarker)
    {
        ERROR_OUT(("Failing WbDrawingArea::Create; couldn't allocate m_pMarker"));
        return(FALSE);
    }

    // Get our cursor
    m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENFREEHANDCURSOR));

    //
    // Register the window class
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_OWNDC;
    wc.lpfnWndProc      = DrawWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = m_hCursor;
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName    = szDrawClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbDraw::Create register class failed"));
        return(FALSE);
    }

    //
    // Create our window
    //
    ASSERT(m_hwnd == NULL);

    if (!::CreateWindowEx(WS_EX_CLIENTEDGE, szDrawClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
        WS_CLIPCHILDREN,
        lprect->left, lprect->top, lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Initialize remaining data members
    //
    ASSERT(!m_bBusy);
    ASSERT(!m_bLocked);
    ASSERT(!m_HourGlass);

    // Start and end points of the last drawing operation
    m_ptStart.x = m_originOffset.cx;
    m_ptStart.y = m_originOffset.cy;
    m_ptEnd = m_ptStart;

    // Set the width to be used for marker handles.
    ASSERT(m_pMarker);
    m_pMarker->SetPenWidth(DRAW_HANDLESIZE);

    // Get the zoom factor to be used
    m_iZoomOption = DRAW_ZOOMFACTOR;

    m_hDCWindow = ::GetDC(m_hwnd);
    m_hDCCached = m_hDCWindow;

    PrimeDC(m_hDCCached);
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);
    return(TRUE);
}



//
// DrawWndProc()
// Message handler for the drawing area
//
LRESULT CALLBACK DrawWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbDrawingArea * pDraw = (WbDrawingArea *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pDraw = (WbDrawingArea *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pDraw);

            pDraw->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDraw);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pDraw);
            pDraw->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pDraw);
            pDraw->OnPaint();
            break;

        case WM_MOUSEMOVE:
            ASSERT(pDraw);
            pDraw->OnMouseMove((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pDraw);
            pDraw->OnLButtonDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            ASSERT(pDraw);
            pDraw->OnLButtonUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            ASSERT(pDraw);
            pDraw->OnContextMenu(LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SIZE:
            ASSERT(pDraw);
            pDraw->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_HSCROLL:
            ASSERT(pDraw);
            pDraw->OnHScroll(GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam));
            break;

        case WM_VSCROLL:
            ASSERT(pDraw);
            pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_CTLCOLOREDIT:
            ASSERT(pDraw);
            lResult = pDraw->OnEditColor((HDC)wParam);
            break;

        case WM_SETFOCUS:
            ASSERT(pDraw);
            pDraw->OnSetFocus();
            break;

        case WM_ACTIVATE:
            ASSERT(pDraw);
            pDraw->OnActivate(GET_WM_ACTIVATE_STATE(wParam, lParam));
            break;

        case WM_SETCURSOR:
            ASSERT(pDraw);
            lResult = pDraw->OnCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CANCELMODE:
            ASSERT(pDraw);
            pDraw->OnCancelMode();
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    RealizePalette
//
// Purpose:     Realize the drawing area palette
//
//
void WbDrawingArea::RealizePalette( BOOL bBackground )
{
    UINT entriesChanged;
    HDC hdc = m_hDCCached;

    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        HPALETTE    hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            // get our 2cents in
            m_hOldPalette = ::SelectPalette(hdc, hPalette, bBackground);
            entriesChanged = ::RealizePalette(hdc);

            // if mapping changes go repaint
            if (entriesChanged > 0)
                ::InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }
}


LRESULT WbDrawingArea::OnEditColor(HDC hdc)
{
    HPALETTE    hPalette = PG_GetPalette();

    if (hPalette != NULL)
    {
        ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);
    }

    ::SetTextColor(hdc, SET_PALETTERGB( m_textEditor.m_clrPenColor ) );

    return((LRESULT)::GetSysColorBrush(COLOR_WINDOW));
}

//
//
// Function:    OnPaint
//
// Purpose:     Paint the window. This routine is called whenever Windows
//              issues a WM_PAINT message for the Whiteboard window.
//
//
void WbDrawingArea::OnPaint(void)
{
    RECT        rcUpdate;
    RECT        rcTmp;
    RECT        rcBounds;
    HDC         hSavedDC;
    HPEN        hSavedPen;
    HBRUSH      hSavedBrush;
    HPALETTE    hSavedPalette;
    HPALETTE    hPalette;
    HFONT       hSavedFont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnPaint");

    // Get the update rectangle
    ::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

    if (Zoomed())
    {
        ::InflateRect(&rcUpdate, 1, 1);
        InvalidateSurfaceRect(&rcUpdate);
    }

    // Can only do any painting if we have a valid page
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // Determine whether any of the remote pointers are to be redrawn.
        // If they are they must be added to the update region to allow them
        // to redraw correctly. This is because they save the bits underneath
        // them and blit them back onto the screen as they are moved.
        if (m_allPointers.IsEmpty() == FALSE)
        {
            TRACE_MSG(("Remote pointer is dispayed"));
            POSITION pos = m_allPointers.GetHeadPosition();
            while (pos != NULL)
            {
                DCWbGraphicPointer* pPointer
                    = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

                pPointer->GetBoundsRect(&rcBounds);
                if (::IntersectRect(&rcTmp, &rcBounds, &rcUpdate))
                {
                    TRACE_MSG(("Invalidating remote pointer"));
                    InvalidateSurfaceRect(&rcBounds);
                }
            }
        }
    }

    // Start painting
    PAINTSTRUCT     ps;

    ::BeginPaint(m_hwnd, &ps);

    hSavedDC      =   m_hDCCached;
    hSavedFont    =   m_hOldFont;
    hSavedPen     =   m_hOldPen;
    hSavedBrush   =   m_hOldBrush;
    hSavedPalette =   m_hOldPalette;

    TRACE_MSG(("Flipping cache to paint DC"));
    m_hDCCached   =   ps.hdc;
    PrimeDC(m_hDCCached);

    // Only draw anything if we have a valid page attached
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // set palette
        hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            m_hOldPalette = ::SelectPalette(m_hDCCached, hPalette, FALSE );
            ::RealizePalette(m_hDCCached);
        }

        //
        // Draw the graphic objects
        //
        DCWbGraphic* pGraphic;
        WB_GRAPHIC_HANDLE hStart;

        if( m_hStartPaintGraphic != NULL )
        {
            hStart = m_hStartPaintGraphic;
            m_hStartPaintGraphic = NULL;

            pGraphic = DCWbGraphic::ConstructGraphic(m_hPage, hStart);
        }
        else
        {
            pGraphic = PG_First(m_hPage, &hStart, &rcUpdate);
        }

        while (pGraphic != NULL)
        {
            ASSERT(pGraphic->Handle() == hStart);

            // Do not draw the active text graphic yet (it is drawn topmost)
            if (!m_bTextEditorActive || (hStart != m_textEditor.Handle()))
            {
                TRACE_MSG(("Drawing a normal graphic"));
                pGraphic->Draw(m_hDCCached, this);
            }

            // Release the current graphic
            delete pGraphic;

            // Get the next one
            pGraphic = PG_Next(m_hPage, &hStart, &rcUpdate);
        }

        //
        // Draw the marker
        //
        if (GraphicSelected() == TRUE)
        {
            TRACE_MSG(("Drawing the marker"));
            DrawMarker(m_hDCCached);
        }

        //
        // Draw the remote pointers that are on this page
        //
        if (m_allPointers.IsEmpty() == FALSE)
        {
            POSITION pos = m_allPointers.GetHeadPosition();
            while (pos != NULL)
            {
                DCWbGraphicPointer* pPointer
                    = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

                pPointer->GetBoundsRect(&rcTmp);
                if (::IntersectRect(&rcTmp, &rcTmp, &rcUpdate))
                {
                    TRACE_MSG(("Drawing remote pointer"));
                    pPointer->DrawSave(m_hDCCached, this);
                }
            }
        }

        //
        // Draw the tracking graphic
        // But not if it is a remote pointer since this has already been done
        // above and Draw() is not the correct function to use for Rem Ptr
        //
        if ((m_pGraphicTracker != NULL)   &&
            !EqualPoint(m_ptStart, m_ptEnd) &&
            !(m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer))
        {
            TRACE_MSG(("Drawing the tracking graphic"));
            m_pGraphicTracker->Draw(m_hDCCached, this);
        }

        if (hPalette != NULL)
        {
            ::SelectPalette(m_hDCCached, m_hOldPalette, TRUE);
        }

        // fixes painting problems for bug 2185
        if( TextEditActive() )
        {
            RedrawTextEditbox();
        }
    }

    //
    // Restore the DC to its original state
    //
    UnPrimeDC(m_hDCCached);

    m_hOldFont      = hSavedFont;
    m_hOldPen       = hSavedPen;
    m_hOldBrush     = hSavedBrush;
    m_hOldPalette   = hSavedPalette;
    m_hDCCached     = hSavedDC;

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}


//
// Selects all graphic objs contained in rectSelect. If rectSelect is
// NULL then ALL objs are selected
//
void WbDrawingArea::SelectMarkerFromRect(LPCRECT lprcSelect)
{
    BOOL bSomethingWasPicked = FALSE;
    DCWbGraphic* pGraphic;
    WB_GRAPHIC_HANDLE hStart;
    RECT    rc;

    if (g_pwbCore->WBP_PageCountGraphics(m_hPage) <= 0 )
        return;

    m_HourGlass = TRUE;
    SetCursorForState();

    RemoveMarker( NULL );

    pGraphic = PG_First(m_hPage, &hStart, lprcSelect, TRUE);
    while (pGraphic != NULL)
    {
        // add obj to marker list if its not locked - bug 2185
        pGraphic->GetBoundsRect(&rc);

        ASSERT(m_pMarker);
        if (m_pMarker->SetRect(&rc, pGraphic, FALSE))
        {
            m_pSelectedGraphic = pGraphic;
            bSomethingWasPicked = TRUE;
        }

        // Get the next one
        pGraphic = PG_Next(m_hPage, &hStart, lprcSelect, TRUE );
    }

    if( bSomethingWasPicked )
        PutMarker( NULL );

    m_HourGlass = FALSE;
    SetCursorForState();
}



//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update freehand and
//              text objects while they are being drawn/edited and to
//              update the remote pointer position when the mouse stops.
//
//
void WbDrawingArea::OnTimer(UINT idTimer)
{
    TRACE_TIMER(("WbDrawingArea::OnTimer"));

    // We are only interested if the user is drawing something or editing
    if (m_bLButtonDown == TRUE)
    {
        // If the user is dragging an object or drawing a freehand line
        if (m_pGraphicTracker != NULL)
        {
            // If the user is drawing a freehand line
            if (m_pGraphicTracker->IsGraphicTool() == enumGraphicFreeHand)
            {

                // The update only writes the new version if changes have been made
                if (m_pGraphicTracker->Handle() == NULL)
                {
                    m_pGraphicTracker->AddToPageLast(m_hPage);
                }
                else
                {
                    m_pGraphicTracker->Replace();
                }
            }

            //
            // If the user is dragging a remote pointer (have to check
            // m_pGraphicTracker for NULL again in case OnLButtonUp was
            // called (bug 4685))
            //
            if ( m_pGraphicTracker != NULL )
            {
                if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
                {
                    // The update only writes the new version if changes have been made
                    m_pGraphicTracker->Update();
                }
            }
        }
    }
}



//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbDrawingArea::OnSize(UINT nType, int cx, int cy)
{
    // Only process this message if the window is not minimized
    if (   (nType == SIZEFULLSCREEN)
        || (nType == SIZENORMAL))
    {
        if (TextEditActive())
        {
            TextEditParentResize();
        }

        // Set the new scroll range (based on the new client area)
        SetScrollRange(cx, cy);

        // Ensure that the scroll position lies in the new scroll range
        ValidateScrollPos();

        // make page move if needed
        ScrollWorkspace();

        // Update the scroll bars
        ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
        ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);
    }
}


//
//
// Function:    SetScrollRange
//
// Purpose:     Set the current scroll range. The range is based on the
//              work surface size and the size of the client area.
//
//
void WbDrawingArea::SetScrollRange(int cx, int cy)
{
    SCROLLINFO scinfo;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetScrollRange");

    // If we are in zoom mode, then allow for the magnification
    ASSERT(m_iZoomFactor != 0);
    cx /= m_iZoomFactor;
    cy /= m_iZoomFactor;

    ZeroMemory( &scinfo,  sizeof (SCROLLINFO) );
    scinfo.cbSize = sizeof (SCROLLINFO);
    scinfo.fMask = SIF_PAGE    | SIF_RANGE|
                    SIF_DISABLENOSCROLL;

    // Set the horizontal scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_WIDTH - 1;
    scinfo.nPage = cx;
    ::SetScrollInfo(m_hwnd, SB_HORZ, &scinfo, FALSE);

    // Set the vertical scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_HEIGHT - 1;
    scinfo.nPage = cy;
    ::SetScrollInfo(m_hwnd, SB_VERT, &scinfo, FALSE);
}

//
//
// Function:    ValidateScrollPos
//
// Purpose:     Ensure that the current scroll position is within the bounds
//              of the current scroll range. The scroll range is set to
//              ensure that the window on the worksurface never extends
//              beyond the surface boundaries.
//
//
void WbDrawingArea::ValidateScrollPos()
{
    int iMax;
    SCROLLINFO scinfo;

    // Validate the horixontal scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_HORZ, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage + 1;
    m_posScroll.x = max(m_posScroll.x, 0);
    m_posScroll.x = min(m_posScroll.x, iMax);

    // Validate the vertical scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_VERT, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage + 1;
    m_posScroll.y = max(m_posScroll.y, 0);
    m_posScroll.y = min(m_posScroll.y, iMax);
}

//
//
// Function:    ScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::ScrollWorkspace(void)
{
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ScrollWorkspace");

    //
    // Determine whether any of the remote pointers are to be redrawn.  If
    // they are they must be added to the update region to allow them to
    // redraw correctly.  This is because they save the bits underneath them
    // and blit them back onto the screen as they are moved.
    //
    if (!m_allPointers.IsEmpty())
    {
        TRACE_MSG(("Remote pointer is dispayed - invalidate before scroll"));
        POSITION pos = m_allPointers.GetHeadPosition();

        while (pos != NULL)
        {
            DCWbGraphicPointer* pPointer
             = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);

            TRACE_MSG(("Invalidating remote pointer"));
            pPointer->GetBoundsRect(&rc);
            InvalidateSurfaceRect(&rc);
        }
    }

    // Do the scroll
    DoScrollWorkspace();

    // Tell the parent that the scroll position has changed
    HWND    hwndParent;

    hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);
    }
}

//
//
// Function:    DoScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::DoScrollWorkspace()
{
    // Validate the scroll position
    ValidateScrollPos();

    // Set the scroll box position
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Only update the screen if the scroll position has changed
    if ( (m_originOffset.cy != m_posScroll.y)
        || (m_originOffset.cx != m_posScroll.x) )
    {
        // Calculate the amount to scroll
        INT iVScrollAmount = m_originOffset.cy - m_posScroll.y;
        INT iHScrollAmount = m_originOffset.cx - m_posScroll.x;

        // Save the new position (for UpdateWindow)
        m_originOffset.cx = m_posScroll.x;
        m_originOffset.cy = m_posScroll.y;

        ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

        // Scroll and redraw the newly invalidated portion of the window
        ::ScrollWindow(m_hwnd, iHScrollAmount, iVScrollAmount, NULL, NULL);
        ::UpdateWindow(m_hwnd);
    }
}

//
//
// Function:    GotoPosition
//
// Purpose:     Move the top-left corner of the workspace to the specified
//              position in the workspace.
//
//
void WbDrawingArea::GotoPosition(int x, int y)
{
    // Set the new scroll position
    m_posScroll.x = x;
    m_posScroll.y = y;

    // Scroll to the new position
    DoScrollWorkspace();

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnVScroll
//
// Purpose:     Process a WM_VSCROLL messages.
//
//
void WbDrawingArea::OnVScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle HEIGHT
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.top == 0);
    rcClient.bottom -= rcClient.top;

    // Act on the scroll code
    switch(nSBCode)
    {
        // Scroll to bottom
        case SB_BOTTOM:
            m_posScroll.y = DRAW_HEIGHT - rcClient.bottom;
            break;

        // Scroll down a line
        case SB_LINEDOWN:
            m_posScroll.y += DRAW_LINEVSCROLL;
            break;

        // Scroll up a line
        case SB_LINEUP:
            m_posScroll.y -= DRAW_LINEVSCROLL;
            break;

        // Scroll down a page
        case SB_PAGEDOWN:
            m_posScroll.y += rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll up a page
        case SB_PAGEUP:
            m_posScroll.y -= rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll to the top
        case SB_TOP:
            m_posScroll.y = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.y = nPos; // don't round
            break;

        default:
        break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnHScroll
//
// Purpose:     Process a WM_HSCROLL messages.
//
//
void WbDrawingArea::OnHScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle WIDTH
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.left == 0);
    rcClient.right -= rcClient.left;

    switch(nSBCode)
    {
        // Scroll to the far right
        case SB_BOTTOM:
            m_posScroll.x = DRAW_WIDTH - rcClient.right;
            break;

        // Scroll right a line
        case SB_LINEDOWN:
            m_posScroll.x += DRAW_LINEHSCROLL;
            break;

        // Scroll left a line
        case SB_LINEUP:
            m_posScroll.x -= DRAW_LINEHSCROLL;
            break;

        // Scroll right a page
        case SB_PAGEDOWN:
            m_posScroll.x += rcClient.right / m_iZoomFactor;
            break;

        // Scroll left a page
        case SB_PAGEUP:
            m_posScroll.x -= rcClient.right / m_iZoomFactor;
            break;

        // Scroll to the far left
        case SB_TOP:
            m_posScroll.x = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.x = nPos; // don't round
            break;

        default:
            break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}


//
//
// Function:    AutoScroll
//
// Purpose:     Auto-scroll the window to bring the position passed as
//              parameter into view.
//
//
BOOL WbDrawingArea::AutoScroll
(
    int     xSurface,
    int     ySurface,
    BOOL    bMoveCursor,
    int     xCaret,
    int     yCaret
)
{
    int nXPSlop, nYPSlop;
    int nXMSlop, nYMSlop;
    int nDeltaHScroll, nDeltaVScroll;
    BOOL bDoScroll = FALSE;

    nXPSlop = 0;
    nYPSlop = 0;
    nXMSlop = 0;
    nYMSlop = 0;

    if( TextEditActive() )
    {
        POINT   ptDirTest;

        ptDirTest.x = xSurface - xCaret;
        ptDirTest.y = ySurface - yCaret;

        // set up for text editbox
        if( ptDirTest.x > 0 )
            nXPSlop = m_textEditor.m_textMetrics.tmMaxCharWidth;
        else
        if( ptDirTest.x < 0 )
            nXMSlop = -m_textEditor.m_textMetrics.tmMaxCharWidth;

        if( ptDirTest.y > 0 )
            nYPSlop = m_textEditor.m_textMetrics.tmHeight;
        else
        if( ptDirTest.y < 0 )
            nYMSlop = -m_textEditor.m_textMetrics.tmHeight;

        nDeltaHScroll = m_textEditor.m_textMetrics.tmMaxCharWidth;
        nDeltaVScroll = m_textEditor.m_textMetrics.tmHeight;
    }
    else
    {
        // set up for all other objects
        nDeltaHScroll = DRAW_LINEHSCROLL;
        nDeltaVScroll = DRAW_LINEVSCROLL;
    }

    // Get the current visible surface rectangle
    RECT  visibleRect;
    GetVisibleRect(&visibleRect);

    // Check for pos + slop being outside visible area
    if( (xSurface + nXPSlop) >= visibleRect.right )
    {
        bDoScroll = TRUE;
        m_posScroll.x +=
            (((xSurface + nXPSlop) - visibleRect.right) + nDeltaHScroll);
    }

    if( (xSurface + nXMSlop) < visibleRect.left )
    {
        bDoScroll = TRUE;
        m_posScroll.x -=
            ((visibleRect.left - (xSurface + nXMSlop)) + nDeltaHScroll);
    }

    if( (ySurface + nYPSlop) >= visibleRect.bottom)
    {
        bDoScroll = TRUE;
        m_posScroll.y +=
            (((ySurface + nYPSlop) - visibleRect.bottom) + nDeltaVScroll);
    }

    if( (ySurface + nYMSlop) < visibleRect.top)
    {
        bDoScroll = TRUE;
        m_posScroll.y -=
            ((visibleRect.top - (ySurface + nYMSlop)) + nDeltaVScroll);
    }

    if( !bDoScroll )
        return( FALSE );

    // Indicate that scrolling has completed (in both directions)
    ScrollWorkspace();

    // Update the mouse position (if required)
    if (bMoveCursor)
    {
        POINT   screenPos;

        screenPos.x = xSurface;
        screenPos.y = ySurface;

        SurfaceToClient(&screenPos);
        ::ClientToScreen(m_hwnd, &screenPos);
        ::SetCursorPos(screenPos.x, screenPos.y);
    }

    return( TRUE );
}

//
//
// Function:    OnCursor
//
// Purpose:     Process a WM_SETCURSOR messages.
//
//
LRESULT WbDrawingArea::OnCursor(HWND hwnd, UINT uiHit, UINT uMsg)
{
    BOOL bResult = FALSE;

    // Check that this message is for the main window
    if (hwnd == m_hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            bResult = SetCursorForState();
        }
        else
        {
            // Restore the cursor to the standard arrow. Set m_hCursor to NULL
            // to indicate that we have not set a special cursor.
            m_hCursor = NULL;
           ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
            bResult = TRUE;
        }
    }

    // Return result indicating whether we processed the message or not
    return bResult;
}

//
//
// Function:    SetCursorForState
//
// Purpose:     Set the cursor for the current state
//
//
BOOL WbDrawingArea::SetCursorForState(void)
{
    BOOL    bResult = FALSE;

    m_hCursor = NULL;

    // If the drawing area is locked, use the "locked" cursor
    if (m_HourGlass)
    {
        m_hCursor = ::LoadCursor( NULL, IDC_WAIT );
    }
    else if (m_bLocked)
    {
        // Return the cursor for the tool
        m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( LOCKCURSOR ));
    }
    else if (m_pToolCur != NULL)
    {
        // Get the cursor for the tool currently in use
        m_hCursor = m_pToolCur->GetCursorForTool();
    }

    if (m_hCursor != NULL)
    {
        ::SetCursor(m_hCursor);
        bResult = TRUE;
    }

    // Return result indicating whether we set the cursor or not
    return bResult;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the drawing area, preventing further updates
//
//
void WbDrawingArea::Lock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Lock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Stop any drawing we are doing.
    CancelDrawingMode();

    // Deselect any selected graphic
    ClearSelection();

    // Show that we are now locked
    m_bLocked = TRUE;
    TRACE_MSG(("Drawing area is now locked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the drawing area, preventing further updates
//
//
void WbDrawingArea::Unlock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Unlock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Show that we are now unlocked
    m_bLocked = FALSE;
    TRACE_MSG(("Drawing area is now UNlocked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}



//
//
// Function:    GraphicAdded
//
// Purpose:     A graphic has been added to the page - update the drawing
//              area.
//
//
void WbDrawingArea::GraphicAdded(DCWbGraphic* pAddedGraphic)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    HDC         hDC;
    RECT        rcUpdate;
    RECT        rcBounds;
    RECT        rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicAdded");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Get the current update rectangle
    ::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

    // Check if the object is the uppermost in the page,
    // if it is we can draw it onto the window without
    // playing the whole contents of the page.
    // (If there the invalid part of the window touches the rectangle of
    // the graphic which has just been added, we just invalidate the area
    // occupied by the new graphic to get it drawn.)

    pAddedGraphic->GetBoundsRect(&rcBounds);
    if ((pAddedGraphic->IsTopmost()) &&
        !::IntersectRect(&rcT, &rcUpdate, &rcBounds))
    {
        // Get a device context for drawing
        hDC = m_hDCCached;

        // set up palette
        if ( (m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
        {
            hOldPal = ::SelectPalette(hDC, hPal, FALSE);
            ::RealizePalette(hDC);
        }

        // Remove the remote pointers from the affected area
        RemovePointers(hDC, &rcBounds);

        // Remove the marker and save whether it is to be restored later
        BOOL bSaveMarkerPresent = m_bMarkerPresent;
        RemoveMarker(NULL);

        // Play the new graphic into the context
        pAddedGraphic->Draw(hDC);

        // Restore the marker (if necessary)
        if (bSaveMarkerPresent == TRUE)
        {
            PutMarker(NULL);
        }

        // Restore the remote pointers
        PutPointers(hDC);

        // If we are editting some text, make editbox redraw
        if (m_bTextEditorActive && (m_textEditor.Handle() != NULL))
        {
            RECT    rcText;

            m_textEditor.GetBoundsRect(&rcText);

            // Include the client border
            InflateRect(&rcText, ::GetSystemMetrics(SM_CXEDGE),
                ::GetSystemMetrics(SM_CYEDGE));
            InvalidateSurfaceRect(&rcText);
        }

        if (hOldPal != NULL)
        {
            ::SelectPalette(hDC, hOldPal, TRUE);
        }
    }
    else
    {
        // Update the area occupied by the object
        InvalidateSurfaceRect(&rcBounds);
    }
}


//
//
// Function:    PointerUpdated
//
// Purpose:     A remote pointer has been added, removed or updated - make
//              the change on the screen.
//
//
void WbDrawingArea::PointerUpdated
(
    DCWbGraphicPointer*     pPointer,
    BOOL                    bForcedRemove
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PointerUpdated");

    ASSERT(pPointer != NULL);

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Determine whether the pointer has been added, removed, or just updated
    DCWbGraphicPointer* pUndrawFrom = pPointer;
    POSITION posBefore = m_allPointers.Lookup(pPointer);
    POSITION posAfter = NULL;
    if (posBefore == NULL)
    {
        // The pointer is not currently drawn

        // Check whether the pointer is active
        if ((pPointer->IsActive()) && !bForcedRemove)
        {
            // Determine where the pointer should go on the drawn list
            if (   (pPointer->IsLocalPointer())
                || (m_allPointers.IsEmpty() == TRUE))
            {
                // The local pointer always goes at the end
                posAfter = m_allPointers.AddTail(pPointer);
            }
            else
            {
                // Find the next active pointer on the page (we already
                // know that allPointers is not empty from the test above).
                posAfter = m_allPointers.GetTailPosition();
                pUndrawFrom = (DCWbGraphicPointer*) m_allPointers.GetFromPosition(posAfter);
                if (!pUndrawFrom->IsLocalPointer())
                {
                    pUndrawFrom = PG_NextPointer(m_hPage, pPointer);
                }

	            posAfter = m_allPointers.AddTail(pPointer);
            }
        }
    }
    else
    {
        // The pointer is already in our list
        pUndrawFrom = pPointer;
    }

    // If we have something to do
    if ((posBefore != NULL) || (posAfter  != NULL))
    {
        if (pUndrawFrom != NULL)
        {
            // Undraw all pointers in the vicinity of the updated pointer
            RECT    rcT;
            RECT    rcBounds;

            pPointer->GetDrawnRect(&rcT);
            pPointer->GetBoundsRect(&rcBounds);
            ::UnionRect(&rcT, &rcT, &rcBounds);
            RemovePointers(NULL, pUndrawFrom, &rcT);
         }

        // If the updated pointer is no longer active we do not want
        // to redraw it, and want to remove it from the active pointer
        // list.
        POSITION posUndrawn = m_undrawnPointers.Lookup(pPointer);
        if ((pPointer->IsActive() == FALSE) || (bForcedRemove == TRUE))
        {
            // Remove it from the undrawn pointers list (so it does not
            // get drawn again).
            if (posUndrawn != NULL)
            {
                m_undrawnPointers.RemoveAt(posUndrawn);
            }

            // Remove it from the list of all active pointers on the page.
            posUndrawn = m_allPointers.Lookup(pPointer);
            if (posUndrawn != NULL)
            {
                m_allPointers.RemoveAt(posUndrawn);
            }
        }
        else
        {
            // If this pointer was not previously active it will not
            // be in the undrawn list and will therefore not get redrawn. So
            // add it to the list to get it drawn. (It goes at the head of the
            // list because we have undrawn all pointers above it.)
            if (posUndrawn == NULL)
            {
                m_undrawnPointers.AddTail(pPointer);
            }
        }

        // Restore all the remote pointers that were removed
        PutPointers(NULL);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that are above and overlap
//              the specified pointer.
//
//
void WbDrawingArea::RemovePointers
(
    HDC                 hPassedDC,
    DCWbGraphicPointer* pPointerUpdate
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Do nothing if the pointer specified is NULL
    if (pPointerUpdate != NULL)
    {
        RECT    rcUpdate;

        ::SetRectEmpty(&rcUpdate);
        RemovePointers(hPassedDC, pPointerUpdate, &rcUpdate);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that overlap a rectangle on the
//              surface.
//
//
void WbDrawingArea::RemovePointers
(
    HDC     hPassedDC,
    LPCRECT lprc
)
{
    RECT    rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Only do anything if the rectangle given is visible
    GetVisibleRect(&rcT);
    if (::IntersectRect(&rcT, &rcT, lprc))
    {
        RemovePointers(hPassedDC, NULL, lprc);
    }
}

//
//
// Function:    RemovePointers
//
// Purpose:     Remove all remote pointers that overlap a rectangle on the
//              surface.
//
//
void WbDrawingArea::RemovePointers
(
    HDC                 hDC,
    DCWbGraphicPointer* pPointerStart,
    LPCRECT             lprcOverlap
)
{
    RECT                rcT;
    RECT                rcT2;
    RECT                rcDrawn;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemovePointers");

    // Show that we have not removed any pointers yet
    m_undrawnPointers.EmptyList();

    // Get our own DC (if necessary)
    if (!hDC)
        hDC = m_hDCCached;

    // We needn't do anything if the pointer and rectangles given
    // are both off-screen.
    GetVisibleRect(&rcT);

    BOOL bNeedCheck = FALSE;
    if (pPointerStart != NULL)
    {
        pPointerStart->GetDrawnRect(&rcT2);
        if (::IntersectRect(&rcT2, &rcT2, &rcT))
        {
            bNeedCheck = TRUE;
        }
    }

    // A NULL overlap rect means empty
    if (::IntersectRect(&rcT, &rcT, lprcOverlap))
    {
        bNeedCheck = TRUE;
    }

    if (bNeedCheck)
    {
        // Get a list of all pointers on the page (with the local
        // pointer last in the list).
        POSITION allPos = m_allPointers.GetHeadPosition();

        // We must undraw pointers in decreasing Z-order.
        // With more than two pointers the effect of removing
        // a pointer can require another pointer to be removed also:
        // (pointer A overlaps pointer B, and B overlaps C without A and
        // C overlapping each other directly). To get round this we build
        // a list of pointers to be removed (and redrawn) as we go.

        // If we are starting from a pointer
        if (pPointerStart != NULL)
        {
            // Get the position of the start pointer
            POSITION startPos = m_allPointers.Lookup(pPointerStart);

            // If the pointer was not found, this is an error
            ASSERT(startPos != NULL);

            // Save the start position for the search
            m_allPointers.GetNext(startPos);
            allPos = startPos;

            // Add the updated pointer to the remove list
            m_undrawnPointers.AddTail(pPointerStart);

            // If the rectangle passed in is empty, set it to the rectangle
            // of the pointer passed in.
            if (::IsRectEmpty(lprcOverlap))
            {
                pPointerStart->GetDrawnRect(&rcDrawn);
                lprcOverlap = &rcDrawn;
            }
        }

        // For each pointer above the start, check whether it overlaps
        // any pointer in the list already built, or the rectangle passed in.

        DCWbGraphicPointer* pPointerCheck;
        while (allPos != NULL)
        {
            // Get the pointer to be tested
            pPointerCheck = (DCWbGraphicPointer*) m_allPointers.GetNext(allPos);

            // Get the rectangle it is currently occupying on the surface
            // Check for overlap with the passed rectangle
            pPointerCheck->GetDrawnRect(&rcT2);
            if (::IntersectRect(&rcT, &rcT2, lprcOverlap))
            {
                m_undrawnPointers.AddTail(pPointerCheck);
            }
        }

		// Create a reversed list
		CWBOBLIST worklist;
        DCWbGraphicPointer* pPointer;

        POSITION pos = m_undrawnPointers.GetHeadPosition();
        while (pos != NULL)
        {
            pPointer  = (DCWbGraphicPointer*) m_undrawnPointers.GetNext(pos);
			worklist.AddHead(pPointer);
		}

        // Now remove the pointers, walking through the reverde list
        pos = worklist.GetHeadPosition();
        while (pos != NULL)
        {
            // Remove it
            pPointer = (DCWbGraphicPointer*) worklist.GetNext(pos);
            pPointer->Undraw(hDC, this);
        }

		worklist.EmptyList();
    }
}

//
//
// Function:    PutPointers
//
// Purpose:     Draw all remote pointers in the pointer redraw list.
//
//
void WbDrawingArea::PutPointers
(
    HDC         hDC,
    COBLIST*    pUndrawList
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PutPointers");

    if (!hDC)
        hDC = m_hDCCached;

    // Get the start position in the list for drawing
    if (pUndrawList == NULL)
    {
        pUndrawList = &m_undrawnPointers;
    }

    // Do the redrawing
    DCWbGraphicPointer* pPointer;
    POSITION pos = pUndrawList->GetHeadPosition();
    while (pos != NULL)
    {
        // Get the next pointer
        pPointer = (DCWbGraphicPointer*) pUndrawList->GetNext(pos);
        pPointer->Redraw(hDC, this);
    }
}

//
//
// Function:    PageCleared
//
// Purpose:     The page has been cleared
//
//
void WbDrawingArea::PageCleared(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PageCleared");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Discard any text being edited
    if (m_bTextEditorActive)
    {
        if (m_bLocked)
        {
            DeactivateTextEditor();
        }
        else
        {
            EndTextEntry(FALSE);
        }
    }

    // Remove the copy of the marked graphic and the marker
    ClearSelection();

    // Invalidate the whole window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    GraphicDeleted
//
// Purpose:     A graphic has been removed from the page - update the
//              drawing area.
//
//
void WbDrawingArea::GraphicDeleted(DCWbGraphic* pDeletedGraphic)
{
    DCWbGraphic* pDeletedMarker;
    RECT rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicDeleted");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Check whether the graphic being deleted is selected
    ASSERT(m_pMarker);

    if( GraphicSelected() &&
        ((pDeletedMarker = m_pMarker->HasAMarker( pDeletedGraphic )) != NULL) )
    {
        // remove marker corresponding to the deleted graphic
        delete pDeletedMarker;

        // if deleted graphic was also the last selection, use prev selection
        // (carefull...m_pSelectedGraphic is invalid now if this is true)
        if( m_pSelectedGraphic == pDeletedMarker ) //only safe comparision
            m_pSelectedGraphic = m_pMarker->LastMarker();
    }

    // Invalidate the area occupied by the object
    pDeletedGraphic->GetBoundsRect(&rcBounds);
    InvalidateSurfaceRect(&rcBounds);
}

//
//
// Function:    GraphicUpdated
//
// Purpose:     A graphic in the page has been updated - update the
//              drawing area.
//
//
void WbDrawingArea::GraphicUpdated
(
    DCWbGraphic* pUpdatedGraphic,
    BOOL    bUpdateMarker,
    BOOL    bErase
)
{
    DCWbGraphic* pUpdatedMarker;
    BOOL    bWasEqual;
    RECT    rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicUpdated");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // If the graphic being updated is selected update marker status
    ASSERT(m_pMarker);

    if( bUpdateMarker && GraphicSelected() &&
        ((pUpdatedMarker = m_pMarker->HasAMarker( pUpdatedGraphic )) != NULL) )
    {
        // must zap lock flag for old object to prevent UnLock loops
        pUpdatedMarker->ClearLockFlag();
        delete pUpdatedMarker;

        // If the graphic is now locked    deselect it
        if (pUpdatedGraphic->Locked() == TRUE)
        {
            if( m_pSelectedGraphic == pUpdatedMarker ) //only safe comparision
                m_pSelectedGraphic = m_pMarker->LastMarker();
        }
        else
        {
            // the graphic isn't locked, re-select it
            bWasEqual = (m_pSelectedGraphic == pUpdatedMarker);
            pUpdatedMarker = DCWbGraphic::ConstructGraphic(m_hPage, pUpdatedGraphic->Handle());

            pUpdatedMarker->GetBoundsRect(&rcBounds);
            m_pMarker->SetRect(&rcBounds, pUpdatedMarker, FALSE );

            if( bWasEqual ) //only safe comparision
                m_pSelectedGraphic = pUpdatedMarker;
        }
    }


    if (TextEditActive() &&
        (m_textEditor.Handle() == pUpdatedGraphic->Handle()) )
    {
        return; // skip update if object is currently being text edited
                // (fix for bug 3059)
    }

    pUpdatedGraphic->GetBoundsRect(&rcBounds);
    InvalidateSurfaceRect(&rcBounds, bErase);
}



//
//
// Function : GraphicFreehandUpdated
//
// Purpose  : A freehand graphic has been updated
//
//
void WbDrawingArea::GraphicFreehandUpdated(DCWbGraphic* pGraphic)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    RECT        rc;

    // Draw the object
    HDC hDC = m_hDCCached;

    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Remove the remote pointers from the affected area
    pGraphic->GetBoundsRect(&rc);
    RemovePointers(hDC, &rc);

    // Play the new graphic into the context
    pGraphic->Draw(hDC);

    // Restore the remote pointers
    PutPointers(hDC);

    // Get the intersection of the graphic and any objects covering it - if
    // there are any objects over the freehand object, we have to redraw them
    PG_GetObscuringRect(m_hPage, pGraphic, &rc);
    if (!::IsRectEmpty(&rc))
    {
        // The graphic is at least partially obscured - force an update
        InvalidateSurfaceRect(&rc, TRUE);
    }

    if (hOldPal != NULL )
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    InvalidateSurfaceRect
//
// Purpose:     Invalidate the window rectangle corresponding to the given
//              drawing surface rectangle.
//
//
void WbDrawingArea::InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase)
{
    RECT    rc;

    // Convert the surface co-ordinates to client window and invalidate
    // the rectangle.
    rc = *lprc;
    SurfaceToClient(&rc);
    ::InvalidateRect(m_hwnd, &rc, bErase);
}

//
//
// Function:    UpdateRectangles
//
// Purpose:     Updates have affected a region of the drawing area - force
//              a redraw now.
//
//
void WbDrawingArea::UpdateRectangles
(
    LPCRECT     lprc1,
    LPCRECT     lprc2,
    BOOL        bRepaint
)
{
    // Remove the marker and save whether it is to be restored later
    BOOL bSaveMarkerPresent = m_bMarkerPresent;
    RemoveMarker(NULL);

    // Invalidate the bounding rectangles specifying that the background
    // is to be erased when painted.
    if (!::IsRectEmpty(lprc1))
    {
        InvalidateSurfaceRect(lprc1, bRepaint);
    }

    if (!::IsRectEmpty(lprc2))
    {
        InvalidateSurfaceRect(lprc2, bRepaint);
    }

    // Repaint the invalidated regions
    ::UpdateWindow(m_hwnd);

    // Restore the marker (if necessary)
    if (bSaveMarkerPresent)
    {
        PutMarker(NULL);
    }
}

//
//
// Function:    PrimeFont
//
// Purpose:     Insert the supplied font into our DC and return the
//              text metrics
//
//
void WbDrawingArea::PrimeFont(HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeFont");

    //
    // temporarily unzoom to get the font that we want
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
    }

    HFONT hOldFont = SelectFont(hDC, hFont);
    if (hOldFont == NULL)
    {
        WARNING_OUT(("Failed to select font into DC"));
    }

    if (pTextMetrics != NULL)
    {
        ::GetTextMetrics(hDC, pTextMetrics);
    }

    //
    // restore the zoom state
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);
    }
}

//
//
// Function:    UnPrimeFont
//
// Purpose:     Remove the specified font from the DC and clear cache
//              variable
//
//
void WbDrawingArea::UnPrimeFont(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeFont");

    if (hDC != NULL)
    {
        SelectFont(hDC, ::GetStockObject(SYSTEM_FONT));
    }
}

//
//
// Function:    PrimeDC
//
// Purpose:     Set up a DC for drawing
//
//
void WbDrawingArea::PrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeDC");

    ::SetMapMode(hDC, MM_ANISOTROPIC);

    ::SetBkMode(hDC, TRANSPARENT);

    ::SetTextAlign(hDC, TA_LEFT | TA_TOP);
}

//
//
// Function:    UnPrimeDC
//
// Purpose:     Reset the DC to default state
//
//
void WbDrawingArea::UnPrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeDC");

    SelectPen(hDC, (HPEN)::GetStockObject(BLACK_PEN));
    SelectBrush(hDC, (HBRUSH)::GetStockObject(BLACK_BRUSH));

    UnPrimeFont(hDC);
}


//
// WbDrawingArea::OnContextMenu()
//
void WbDrawingArea::OnContextMenu(int xScreen, int yScreen)
{
    POINT   pt;
    RECT    rc;

    pt.x = xScreen;
    pt.y = yScreen;
    ::ScreenToClient(m_hwnd, &pt);

    ::GetClientRect(m_hwnd, &rc);
    if (::PtInRect(&rc, pt))
    {
        // Complete drawing action, if any
        OnLButtonUp(0, pt.x, pt.y);

        // Ask main window to put up context menu
        g_pMain->PopupContextMenu(pt.x, pt.y);
    }
}


//
// WbDrawingArea::OnLButtonDown()
//
void WbDrawingArea::OnLButtonDown(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonDown");

    if( m_bIgnoreNextLClick )
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONDOWN") );
        return;
    }

    // Set the focus to this window. This is done to ensure that we trap
    // the text edit keys and the delete key when they are used.
    ::SetFocus(m_hwnd);

    // Save the operation start point (and current end point)
    // Adjust the mouse position to allow for the zoom factor
    m_ptStart.x = x;
    m_ptStart.y = y;
    ClientToSurface(&m_ptStart);
    m_ptEnd   = m_ptStart;

    // Show that the mouse button is now down
    m_bLButtonDown = TRUE;

    // Show that the drawing area is now busy
    m_bBusy = TRUE;

    // User's can drag their own remote pointer even if the drawing area
    // is locked. So we check before the test for the lock.
    if (m_pToolCur->ToolType() == TOOLTYPE_SELECT)
    {
        if (RemotePointerSelect(m_ptStart))
        {
            return;
        }
    }

    // Only allow the action to take place if the drawing area is unlocked,
    // and we have a valid tool
    if (m_bLocked || (m_pToolCur == NULL))
    {
        // Tidy up the state and leave now
        m_bLButtonDown = FALSE;
        m_bBusy        = FALSE;
        return;
    }

    // Call the relevant initialization routine
    if (m_pToolCur->ToolType() != TOOLTYPE_SELECT)
    {
        // dump selection if not select tool
        ClearSelection();
    }

    switch (m_pToolCur->ToolType())
    {
        case TOOLTYPE_SELECT:
            BeginSelectMode(m_ptStart);
            break;

        case TOOLTYPE_ERASER:
            BeginDeleteMode(m_ptStart);
            break;

        case TOOLTYPE_TEXT:
            break;

        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            BeginFreehandMode(m_ptStart);
            break;

        case TOOLTYPE_LINE:
            BeginLineMode(m_ptStart);
            break;

        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
            BeginRectangleMode(m_ptStart);
            break;

        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            BeginEllipseMode(m_ptStart);
            break;

        // Do nothing if we do not recognise the pen type
        default:
            ERROR_OUT(("Bad tool type"));
            break;
    }

    // Clamp the cursor to the drawing window
    RECT    rcClient;

    ::GetClientRect(m_hwnd, &rcClient);
    ::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcClient.left, 2);
    ::InflateRect(&rcClient, 1, 1);
    ::ClipCursor(&rcClient);
}

//
//
// Function:    RemotePointerSelect
//
// Purpose:     Check for the user clicking inside their own remote pointer.
//
//
BOOL WbDrawingArea::RemotePointerSelect
(
    POINT   surfacePos
)
{
    BOOL bResult = FALSE;
    DCWbGraphicPointer* pPointer;

    // Check we have a valid page
    if (m_hPage == WB_PAGE_HANDLE_NULL)
    {
        return(bResult);
    }

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Check if we are clicking in the local user's pointer
    pPointer = PG_LocalPointer(m_hPage);
    if (   (pPointer != NULL)
         && (pPointer->PointInBounds(surfacePos)))
    {
        // The user is clicking in their pointer
        m_pGraphicTracker = pPointer;

        // Save the current time (used to determine when to update
        // the external remote pointer information).
        m_dwTickCount = ::GetTickCount();

        // Hide the mouse (helps prevent flicker)
        ::ShowCursor(FALSE);

        // Get all mouse input directed to the this window
        ::SetCapture(m_hwnd);

        // Start the timer for updating the pointer (this is only for updating
        // the pointer position when the user stops moving the pointer but
        // keeps the mouse button down).
        ::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

        // Show that we have selected a pointer
        bResult = TRUE;
    }

    return(bResult);
}

//
//
// Function:    SelectPreviousGraphicAt
//
// Purpose:     Select the previous graphic (in the Z-order) at the position
//              specified, and starting at a specified graphic. If the
//              graphic pointer given is NULL the search starts from the
//              top. If the point specified is outside the bounding
//              rectangle of the specified graphic the search starts at the
//              top and chooses the first graphic which contains the point.
//
//              The search process will loop back to the top of the Z-order
//              if it gets to the bottom having failed to find a graphic.
//
//              Graphics which are locked are ignored by the search.
//
//
DCWbGraphic* WbDrawingArea::SelectPreviousGraphicAt
(
    DCWbGraphic* pStartGraphic,
    POINT       point
)
{
    // Set the result to "none found" initially
    DCWbGraphic* pResultGraphic = NULL;

    // If a starting point has been specified
    if (pStartGraphic != NULL)
    {
        RECT rectHit;

        MAKE_HIT_RECT(rectHit, point);

        // If the reference point is within the start graphic
        if ( pStartGraphic->PointInBounds(point) &&
            pStartGraphic->CheckReallyHit( &rectHit ) )
        {
            // Start from the specified graphic
            pResultGraphic = pStartGraphic;

            // Look for the previous one (that is not locked)
            do
            {
                pResultGraphic = PG_SelectPrevious(m_hPage, *pResultGraphic, point);
            }
            while (   (pResultGraphic != NULL)
             && (pResultGraphic->Locked()));
        }
        else
        {
            // We are not looking within the currently selected graphic.
            // Deselect the current one. The start pointer and handle are
            // left at NULL.
            ;
        }
    }

    // If we have not got a result graphic yet. (This catches two cases:
    // - where no start graphic has been given so that we want to start
    //   from the top,
    // - where we have searched back from the start graphic and reached
    //   the bottom of the Z-order without finding a suitable graphic.
    if (pResultGraphic == NULL)
    {
        // Get the topmost graphic that contains the point specified
        pResultGraphic = PG_SelectLast(m_hPage, point);

        // Ensure that we have not got a locked graphic
        while (   (pResultGraphic != NULL)
           && (pResultGraphic->Locked()))
        {
            pResultGraphic = PG_SelectPrevious(m_hPage, *pResultGraphic, point);
        }
    }

    // If we have found an object, draw the marker
    if (pResultGraphic != NULL)
    {
        // Select the new one
        SelectGraphic(pResultGraphic);
    }

    return pResultGraphic;
}

//
//
// Function:    BeginSelectMode
//
// Purpose:     Process a mouse button down in select mode
//
//

void WbDrawingArea::BeginSelectMode(POINT surfacePos, BOOL bDontDrag )
{
    RECT    rc;

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Assume that we do not mark a new graphic
    m_bNewMarkedGraphic = FALSE;

    // turn off TRACK-SELECT-RECT
    m_bTrackingSelectRect = FALSE;

    // Check whether there is currently an object marked, and
    // whether we are clicking inside the same object. If we are then
    // we do nothing here - the click will be handled by the tracking or
    // completion routines for select mode.
    ASSERT(m_pMarker);

    if (   (GraphicSelected() == FALSE)
        || (m_pMarker->PointInBounds(surfacePos) == FALSE))
    {
        // We are selecting a new object if bDontDrag == FALSE, find it.
        //  otherwise just turn on the select rect
        DCWbGraphic* pGraphic;
        if( bDontDrag )
            pGraphic = NULL;
        else
            pGraphic = SelectPreviousGraphicAt(NULL, surfacePos);

        // If we have found an object, draw the marker
        if (pGraphic != NULL)
        {
          // Show that a new graphic has now been marked.
          m_bNewMarkedGraphic = TRUE;
        }
        else
        {
            if( (GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                (GetAsyncKeyState( VK_CONTROL ) >= 0) )
            {
                // clicked on dead air, remove all selections
                ClearSelection();
            }

            //TRACK-SELECT-RECT
            m_bTrackingSelectRect = TRUE;

            BeginRectangleMode(surfacePos);

            return;
        }
    }

    // If we now have a selected graphic, and we are clicking inside it
    if (   (GraphicSelected())
        && (m_pMarker->PointInBounds(surfacePos)))
    {
        // Create a rectangle object for tracking the drag
        DCWbGraphicSelectTrackingRectangle* pRectangle
                           = new DCWbGraphicSelectTrackingRectangle();

        m_pSelectedGraphic->GetBoundsRect(&rc);

        if (!pRectangle)
        {
            ERROR_OUT(("BeginSelectMode failed; couldn't create tracking rect object"));
        }
        else
        {
            pRectangle->SetRect(&rc);
            pRectangle->SetColor(RGB(0, 0, 0));
            pRectangle->SetPenWidth(1);
        }

        m_pGraphicTracker = pRectangle;

        // We do not draw the tracking rectangle yet as the user has not yet
        // dragged it anywhere. A single click within an object will then
        // not cause a tracking rectangle to flash on the screen.
    }

    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);
}




void WbDrawingArea::BeginDeleteMode(POINT mousePos )
{
    // turn off object dragging
    BeginSelectMode( mousePos, TRUE );
}




//
//
// Function:    BeginTextMode
//
// Purpose:     Process a mouse button down in text mode
//
//
void WbDrawingArea::BeginTextMode(POINT surfacePos)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::BeginTextMode");

    //
    // Get a DC for passing into the text editor
    //
    HDC hDC = m_hDCCached;

    // If we are already editing a text object, we just move the text cursor
    if (m_bTextEditorActive)
    {
        // If the mouse has been clicked in the currently active object
        // we just move the cursor within the object, otherwise we end the
        // edit for the current object and move to a new one.
        m_textEditor.GetBoundsRect(&rc);
        if (::PtInRect(&rc, surfacePos))
        {
            // Set the new position for the cursor
            m_textEditor.SetCursorPosFromPoint(surfacePos);
        }
        else
        {
            // Complete the text entry accepting the changes
            EndTextEntry(TRUE);

            // LAURABU BOGUS:
            // It would be cooler to now return, that way you don't get
            // another text object just cuz you ended the current editing
            // session.
        }
    }

    // If we are not editing an object we check to see whether there is
    // a text object under the cursor or whether we must start a new one.
    if (!m_bTextEditorActive)
    {
        // Check whether we are clicking over a text object. If we are
        // start editing the object, otherwise we start a new text object.

        // Look back through the Z-order for a text object
        DCWbGraphic* pGraphic = PG_SelectLast(m_hPage, surfacePos);
        DCWbGraphic* pNextGraphic = NULL;
        while (   (pGraphic != NULL)
           && (pGraphic->IsGraphicTool() != enumGraphicText))
        {
            // Get the next one
            pNextGraphic = PG_SelectPrevious(m_hPage, *pGraphic, surfacePos);

            // Release the previous graphic
            delete pGraphic;

            // Use the next one
            pGraphic = pNextGraphic;
        }

        if (pGraphic != NULL)
        {
            // Check whether this graphic object is already being edited by
            // another user in the call.
            if (!pGraphic->Locked())
            {
                // We found a text object under the mouse pointer...
                // ...edit it
                m_pActiveText = (DCWbGraphicText*) pGraphic;

                // Transfer the text from the object into the text editor
                if (!m_textEditor.SetTextObject(m_pActiveText))
                {
                    DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
                    return;
                }

                // Make sure the tool reflects the new information
                if (m_pToolCur != NULL)
                {
                    m_pToolCur->SelectGraphic(pGraphic);
                }

                HWND hwndParent = ::GetParent(m_hwnd);;
                if (hwndParent != NULL)
                {
                    ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
                }

                // Lock the graphic to prevent other users editing it.
                // (This is not currently a real lock but a flag in the object
                //  header. There is a window in which two users can start editing
                //  the same text object at the same time.)
                m_textEditor.Lock();
                m_textEditor.Update();


                // Show that we are now gathering text but dont put up cursor
                // yet. Causes cursor droppings later (bug 2505)
                //ActivateTextEditor( FALSE );
                ActivateTextEditor( TRUE );

                // Set the initial cursor position for the edit
                m_textEditor.SetCursorPosFromPoint(surfacePos);

                // If this is not the topmost object we must redraw to get
                // it to the top so it is visible for editing
                if (PG_IsTopmost(m_hPage, m_pActiveText))
                {
                    m_pActiveText->GetBoundsRect(&rc);
                    InvalidateSurfaceRect(&rc);
                    ::UpdateWindow(m_hwnd);
                }
            }
            else
                delete pGraphic;
        }
        else
        {
            // There are no text objects under the mouse pointer...
            // ...start a new one

            // Clear any old text out of the editor, and reset its graphic
            // handle. This prevents us from replacing an old text object when
            // we next save the text editor contents.
            if (!m_textEditor.New())
            {
                DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
                return;
            }

            // Lock the text editor to prevent other users editing the object.
            // (The object will be added to the page when the update timer pops
            // or when the user hits space or return.)
            m_textEditor.Lock();

            // Set the attributes of the text
            m_textEditor.SetFont(m_pToolCur->GetFont());
            m_textEditor.SetColor(m_pToolCur->GetColor());
            m_textEditor.GraphicTool(m_pToolCur->ToolType());

            // We need to reselect a font now into our DC
            SelectFont(hDC, m_textEditor.GetFont());

            // Set the position of the new object
            SIZE sizeCursor;
            m_textEditor.GetCursorSize(&sizeCursor);
            m_textEditor.CalculateBoundsRect();
            m_textEditor.MoveTo(m_ptEnd.x, m_ptEnd.y - sizeCursor.cy);

            // We are not editing an active text object
            ASSERT(m_pActiveText == NULL);

            // Show that we are now gathering text
            ActivateTextEditor( TRUE );
        }
    }
}

//
//
// Function:    BeginFreehandMode
//
// Purpose:     Process a mouse button down event in draw mode
//
//
void WbDrawingArea::BeginFreehandMode(POINT surfacePos)
{
    // Tracking in draw mode is a special case. We draw directly to the client
    // area of the window and create an object to record the points on the
    // line that we are drawing.
    m_pGraphicTracker = new DCWbGraphicFreehand();

    if (!m_pGraphicTracker)
    {
        ERROR_OUT(("BeginFreehandMode failing; can't create graphic freehand object"));
    }
    else
    {
        ((DCWbGraphicFreehand*) m_pGraphicTracker)->AddPoint(surfacePos);
        m_pGraphicTracker->SetColor(m_pToolCur->GetColor());
        m_pGraphicTracker->SetPenWidth(m_pToolCur->GetWidth());
        m_pGraphicTracker->SetROP(m_pToolCur->GetROP());
        m_pGraphicTracker->GraphicTool(m_pToolCur->ToolType());
        m_pGraphicTracker->Lock();
    }

    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Start the timer for updating the graphic (this is only for updating
    // the graphic when the user stops moving the pointer but keeps the
    // mouse button down).
    ::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

    // Save the current time (used to determine when to update
    // the external graphic pointer information while the mouse is
    // being moved).
    m_dwTickCount = ::GetTickCount();
}

//
//
// Function:    BeginLineMode
//
// Purpose:     Process a mouse button down event in line mode
//
//
void WbDrawingArea::BeginLineMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingLine* pGraphicLine = new DCWbGraphicTrackingLine();
    if (!pGraphicLine)
    {
        ERROR_OUT(("BeginLineMode failing; can't create tracking line object"));
    }
    else
    {
        pGraphicLine->SetColor(m_pToolCur->GetColor());
        pGraphicLine->SetPenWidth(1);

        pGraphicLine->SetStart(surfacePos);
        pGraphicLine->SetEnd(surfacePos);
    }

    m_pGraphicTracker = pGraphicLine;
}

//
//
// Function:    BeginRectangleMode
//
// Purpose:     Process a mouse button down event in box mode
//
//
void WbDrawingArea::BeginRectangleMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingRectangle* pGraphicRectangle
                                 = new DCWbGraphicTrackingRectangle();
    if (!pGraphicRectangle)
    {
        ERROR_OUT(("BeginRectangleMode failing; can't create tracking rect object"));
    }
    else
    {
        pGraphicRectangle->SetColor( CLRPANE_BLACK );
        pGraphicRectangle->SetPenWidth(1);
        pGraphicRectangle->SetRectPts(surfacePos, surfacePos);
    }

    m_pGraphicTracker = pGraphicRectangle;
}

//
//
// Function:    BeginEllipseMode
//
// Purpose:     Process a mouse button down event in ellipse mode
//
//
void WbDrawingArea::BeginEllipseMode(POINT surfacePos)
{
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);

    // Create the object to be used for tracking
    DCWbGraphicTrackingEllipse* pGraphicEllipse
                                  = new DCWbGraphicTrackingEllipse();
    if (!pGraphicEllipse)
    {
        ERROR_OUT(("BeginEllipseMode failing; can't create tracking ellipse object"));
    }
    else
    {
        pGraphicEllipse->SetColor(m_pToolCur->GetColor());
        pGraphicEllipse->SetPenWidth(1);
        pGraphicEllipse->SetRectPts(surfacePos, surfacePos);
    }

    m_pGraphicTracker = pGraphicEllipse;
}

//
// WbDrawingArea::OnMouseMove
//
void WbDrawingArea::OnMouseMove(UINT flags, int x, int y)
{
    POINT surfacePos;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnMouseMove");

    surfacePos.x = x;
    surfacePos.y = y;

    // Check if the left mouse button is down
    if (m_bLButtonDown)
    {
        // Calculate the worksurface position
        // Adjust the mouse position to allow for the zoom factor
        ClientToSurface(&surfacePos);

        // Make sure the point is a valid surface position
        MoveOntoSurface(&surfacePos);

        // Check whether the window needs to be scrolled to get the
        // current position into view.
        AutoScroll(surfacePos.x, surfacePos.y, TRUE, 0, 0);

        // Action taken depends on the tool type
        switch(m_pToolCur->ToolType())
        {
            case TOOLTYPE_HIGHLIGHT:
            case TOOLTYPE_PEN:
                TrackFreehandMode(surfacePos);
                break;

            case TOOLTYPE_LINE:
                TrackLineMode(surfacePos);
                break;

            case TOOLTYPE_BOX:
            case TOOLTYPE_FILLEDBOX:
                TrackRectangleMode(surfacePos);
                break;

            case TOOLTYPE_ELLIPSE:
            case TOOLTYPE_FILLEDELLIPSE:
                TrackEllipseMode(surfacePos);
                break;

            case TOOLTYPE_SELECT:
                TrackSelectMode(surfacePos);
                break;

            case TOOLTYPE_ERASER:
                TrackDeleteMode(surfacePos);
                break;

            case TOOLTYPE_TEXT:
                break;

            default:
                ERROR_OUT(("Unknown tool type"));
                break;
        }
    }
}

//
//
// Function:    CancelDrawingMode
//
// Purpose:     Cancels a drawing operation after an error.
//
//
void WbDrawingArea::CancelDrawingMode(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::CancelDrawingMode");

    //
    // Quit if there's nothing to cancel.
    //
    if (!m_bBusy && !m_bTextEditorActive)
    {
        TRACE_DEBUG(("Drawing area not busy and text editor not active..."));
        return;
    }

    // The drawing area is no longer busy
    m_bBusy = FALSE;

    //
    // Redraw the object - we need to discard any local updates which we
    // weren't able to write to the object we are editing.  Ideally we should
    // just invalidate the object itself but because some of the co-ordinates
    // we have already drawn on the page may have been lost, we dont know
    // exactly how big the object is.
    //
    ::InvalidateRect(m_hwnd, NULL, TRUE);

    m_bLButtonDown = FALSE;

    // Release the mouse capture
    if (::GetCapture() == m_hwnd)
    {
        ::ReleaseCapture();
    }

    //
    // Perform any tool specific processing.
    //
    switch(m_pToolCur->ToolType())
    {
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            CompleteFreehandMode();
            break;

        case TOOLTYPE_SELECT:
            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
            break;

        case TOOLTYPE_TEXT:
            if (m_bTextEditorActive)
            {
                m_textEditor.AbortEditGently();
            }
            break;

        default:
            break;
    }

    // Show that we are no longer tracking an object
    if (m_pGraphicTracker != NULL)
    {
        delete m_pGraphicTracker;
        m_pGraphicTracker = NULL;
    }
}


//
//
// Function:    TrackSelectMode
//
// Purpose:     Process a mouse move event in select mode
//
//
void WbDrawingArea::TrackSelectMode(POINT surfacePos)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackSelectMode");

    // If an object is being dragged
    if (m_pGraphicTracker != NULL)
    {
        // Get a device context for the window
        HDC hDC = m_hDCCached;

        // Check whether the marked object is the local pointer
        if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
        {
            DCWbGraphicPointer* pPointer = (DCWbGraphicPointer*) m_pGraphicTracker;

            // Move the pointer to its new position
            pPointer->MoveBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);

            // Draw the new pointer
            pPointer->Redraw(hDC, this);

            // Save the new box end point (top right)
            m_ptEnd = surfacePos;

    		// Check whether we need to update the external remote pointer
	    	// information. (Based on the time. We will miss one update
		    // when the time wraps.)
    		DWORD dwNewTickCount = ::GetTickCount();
	    	if (dwNewTickCount > m_dwTickCount + DRAW_REMOTEPOINTERDELAY)
		    {
        	    TRACE_DEBUG(("Updating pointer - tick count exceeded"));

    	        // Update the pointer
        	    pPointer->Update();

            	// Set the saved tick count to the new count
	            m_dwTickCount = dwNewTickCount;
    		}
	    }
        else
        {
            if( m_bTrackingSelectRect )
                TrackRectangleMode(surfacePos);
      else
          {

          // In this case we must be dragging a marked object
          ASSERT(GraphicSelected());

          // We never draw the tracking rectangle in the start position of
          // the graphic. This gives the user some feedback when they have
          // positioned the graphic back at its original place.
          if (!EqualPoint(m_ptStart, m_ptEnd))
          {
            // Erase the last box (using XOR property)
            m_pGraphicTracker->Draw(hDC);
            }

          // Save the new box end point (top left)
          m_pGraphicTracker->MoveBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);
          m_ptEnd = surfacePos;

          // Draw the new rectangle (XORing it onto the display)
          if (!EqualPoint(m_ptStart, m_ptEnd))
            {
            // Draw the rectangle
            m_pGraphicTracker->Draw(hDC);
            }
          }
    }
  }
}





void  WbDrawingArea::TrackDeleteMode( POINT mousePos )
{
    TrackSelectMode( mousePos );
}




//
//
// Function:    TrackFreehandMode
//
// Purpose:     Process a mouse move event in draw mode
//
//
void WbDrawingArea::TrackFreehandMode(POINT surfacePos)
{
    HPALETTE    hPal = NULL;
    HPALETTE    hOldPal = NULL;
    HPEN        hPen = NULL;
    HPEN        hOldPen = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackFreehandMode");

    // Get a device context for the client area
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE);
        ::RealizePalette(hDC);
    }

    // Tracking in draw mode is a special case. We draw directly to the client
    // area of the window and to the recording device context.

    // Save the point, checking there aren't too many points
    if (!m_pGraphicTracker ||
        (((DCWbGraphicFreehand*) m_pGraphicTracker)->AddPoint(surfacePos) == FALSE))
    {
        // too many points so end the freehand object
        OnLButtonUp(0, surfacePos.x, surfacePos.y);
        goto TrackFreehandCleanup;
    }

    // Set the DC attributes
    ASSERT(m_pGraphicTracker != NULL);

    hPen = ::CreatePen(m_pGraphicTracker->GetPenStyle(),
           m_pGraphicTracker->GetPenWidth(),
           m_pGraphicTracker->GetColor());
    if (!hPen)
    {
        ERROR_OUT(("Couldn't create pen in track freehand mode"));
        goto TrackFreehandCleanup;
    }

    hOldPen = SelectPen(hDC, hPen);
    if (hOldPen != NULL)
    {
        int iOldROP = ::SetROP2(hDC, m_pGraphicTracker->GetROP());

        // Draw the next segment of the freehand line into the recording context
        // and the client area, and save the new start point.
        ::MoveToEx(hDC, m_ptStart.x, m_ptStart.y, NULL);
        ::LineTo(hDC, surfacePos.x, surfacePos.y);

        // Update the start point for the next line segment
        m_ptStart = surfacePos;

        // Restore the DC attributes
        ::SetROP2(hDC, iOldROP);

        // Check whether we need to update the external graphic information.
        // (Based on the time. We will miss one update when the time wraps.)
        DWORD dwNewTickCount = ::GetTickCount();
        if (dwNewTickCount > m_dwTickCount + DRAW_GRAPHICUPDATEDELAY)
        {
            TRACE_DEBUG(("Updating freehand - tick count exceeded"));

            // Update the pointer
            if (m_pGraphicTracker->Handle() == NULL)
            {
                m_pGraphicTracker->AddToPageLast(m_hPage);
            }
            else
            {
                m_pGraphicTracker->Replace();
            }

            // Set the saved tick count to the new count
            m_dwTickCount = dwNewTickCount;
        }
    }

TrackFreehandCleanup:

    if (hOldPen != NULL)
    {
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackLineMode
//
// Purpose:     Process a mouse move event in line mode
//
//
void WbDrawingArea::TrackLineMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last line drawn (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new line (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        m_ptEnd = surfacePos;

        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingLine*) m_pGraphicTracker)->SetEnd(m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackRectangleMode
//
// Purpose:     Process a mouse move event in box or filled box mode
//
//
void WbDrawingArea::TrackRectangleMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new rectangle (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        // Save the new box end point (top right)
        m_ptEnd = surfacePos;

        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingRectangle*) m_pGraphicTracker)->SetRectPts(m_ptStart, m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}

//
//
// Function:    TrackEllipseMode
//
// Purpose:     Process a mouse move event in ellipse or filled ellipse mode
//
//
void WbDrawingArea::TrackEllipseMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if( (m_hPage != WB_PAGE_HANDLE_NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE);
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }
    }

    // Draw the new ellipse (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
        // Update the end point of the operation
        m_ptEnd = surfacePos;

        if (m_pGraphicTracker != NULL)
        {
            ((DCWbGraphicTrackingEllipse*) m_pGraphicTracker)->SetRectPts(m_ptStart, m_ptEnd);
            m_pGraphicTracker->Draw(hDC);
        }
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE );
    }
}


//
// WbDrawingArea::OnLButtonUp()
//
void WbDrawingArea::OnLButtonUp(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonUp");

    if (m_bIgnoreNextLClick)
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONUP") );
        m_bIgnoreNextLClick = FALSE;
        return;
    }

    // Only process the event if we saw the button down event
    if (m_bLButtonDown)
    {
        TRACE_MSG(("End of drawing operation"));

        m_bLButtonDown = FALSE;

        // The drawing area is no longer busy
        m_bBusy = FALSE;

        if (m_pGraphicTracker == NULL)
        {
            // Calculate the work surface position
            // Adjust the mouse position to allow for the zoom factor
            POINT surfacePos;

            surfacePos.x = x;
            surfacePos.y = y;
            ClientToSurface(&surfacePos);
            MoveOntoSurface(&surfacePos);
            m_ptEnd = surfacePos;
        }

        // Release the mouse capture
        if (::GetCapture() == m_hwnd)
        {
            ::ReleaseCapture();
        }

        // Check the page is valid - might not be if it has been deleted
        // while the object was being drawn - we would not have been
        // alerted to this because m_bBusy was true.
        if (m_hPage != WB_PAGE_HANDLE_NULL)
        {
            // surround in an exception handler in case of lock errors, etc -
            // we need to remove the graphic tracker
            // Action taken depends on the current tool type
            ASSERT(m_pToolCur != NULL);

            switch(m_pToolCur->ToolType())
            {
                case TOOLTYPE_HIGHLIGHT:
                case TOOLTYPE_PEN:
                    CompleteFreehandMode();
                    break;

                case TOOLTYPE_LINE:
                    CompleteLineMode();
                    break;

                case TOOLTYPE_BOX:
                    CompleteRectangleMode();
                    break;

                case TOOLTYPE_FILLEDBOX:
                    CompleteFilledRectangleMode();
                    break;

                case TOOLTYPE_ELLIPSE:
                    CompleteEllipseMode();
                    break;

                case TOOLTYPE_FILLEDELLIPSE:
                    CompleteFilledEllipseMode();
                    break;

                case TOOLTYPE_SELECT:
                    CompleteSelectMode();
                    break;

                case TOOLTYPE_ERASER:
                    CompleteDeleteMode();
                    break;

                case TOOLTYPE_TEXT:
                    m_ptStart.x = x;
                    m_ptStart.y = y;
                    ClientToSurface(&m_ptStart);
                    BeginTextMode(m_ptStart);
                    break;

                default:
                    ERROR_OUT(("Unknown pen type"));
                    break;
            }
        }

        // Show that we are no longer tracking an object
        if (m_pGraphicTracker != NULL)
        {
            delete m_pGraphicTracker;
            m_pGraphicTracker = NULL;
        }
	}

    // unclamp cursor (bug 589)
    ClipCursor(NULL);
}

//
//
// Function:    CompleteSelectMode
//
// Purpose:     Complete a select mode operation
//
//
void WbDrawingArea::CompleteSelectMode()
{
    // If an object is being dragged
    if (m_pGraphicTracker != NULL)
    {
        // Check if we were dragging a pointer. Pointers track
        // themselves i.e. the original copy of the pointer is not
        // left on the page. We want to leave the last drawn image on
        // the page as this is the new pointer position.
        if (m_pGraphicTracker->IsGraphicTool() == enumGraphicPointer)
        {
            DCWbGraphicPointer* pPointer = (DCWbGraphicPointer*) m_pGraphicTracker;

            // Show the mouse
            ::ShowCursor(TRUE);

            // Update the object's position (if necessary)
            if (!EqualPoint(m_ptStart, m_ptEnd))
            {
                pPointer->Update();
            }

            // We do not want to delete the graphic pointer (it belongs to
            // the page object that created it). So reset the graphic tracker
            // pointer to prevent it being deleted in OnLButtonUp.
            m_pGraphicTracker = NULL;

            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
        }
        else
        {
            if( m_bTrackingSelectRect && (!EqualPoint(m_ptStart, m_ptEnd)))
            {
                CompleteMarkAreaMode();
                SelectMarkerFromRect( &m_rcMarkedArea );
            }
            else
            {
                // The select item is a real graphic - not a pointer

                // If we need to remove the rubber band box
                if (!EqualPoint(m_ptStart, m_ptEnd))
                {
                    // Erase the last box (using XOR property).
                    // Get a device context for tracking
                    HDC hDC = m_hDCCached;

                    // Draw the rectangle
                    m_pGraphicTracker->Draw(hDC);

                    // Move selection
                    m_HourGlass = TRUE;
                    SetCursorForState();

                    RemoveMarker( NULL );
                    m_pMarker->MoveBy(m_ptEnd.x - m_ptStart.x, m_ptEnd.y - m_ptStart.y);
                    m_pMarker->Update();

                    PutMarker( NULL, FALSE );

                    m_HourGlass = FALSE;
                    SetCursorForState();

                    // The tracking object will be deleted by OnLButtonUp
                }
                else
                {
                    // Start and end points were the same, in this case the object has
                    // not been moved. We treat this as a request to move the marker
                    // back through the stack of objects.
                    if (m_bNewMarkedGraphic == FALSE)
                    {
                        SelectPreviousGraphicAt(m_pSelectedGraphic, m_ptEnd);
                    }
                }
            }
        }
    }
}




void WbDrawingArea::CompleteDeleteMode()
{
    // select object(s)
    CompleteSelectMode();

    // nuke 'em
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, MAKELONG(IDM_DELETE, BN_CLICKED), 0);
}



//
//
// Function:    CompleteMarkAreaMode
//
// Purpose:     Process a mouse button up event in mark area mode
//
//
void WbDrawingArea::CompleteMarkAreaMode(void)
{
    // Get a device context for tracking
    HDC hDC = m_hDCCached;

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        if (m_pGraphicTracker != NULL)
        {
            m_pGraphicTracker->Draw(hDC);
        }

        // Use normalized coords
        if (m_ptEnd.x < m_ptStart.x)
        {
            m_rcMarkedArea.left = m_ptEnd.x;
            m_rcMarkedArea.right = m_ptStart.x;
        }
        else
        {
            m_rcMarkedArea.left = m_ptStart.x;
            m_rcMarkedArea.right = m_ptEnd.x;
        }

        if (m_ptEnd.y < m_ptStart.y)
        {
            m_rcMarkedArea.top = m_ptEnd.y;
            m_rcMarkedArea.bottom = m_ptStart.y;
        }
        else
        {
            m_rcMarkedArea.top = m_ptStart.y;
            m_rcMarkedArea.bottom = m_ptEnd.y;
        }
    }
}

//
//
// Function:    CompleteTextMode
//
// Purpose:     Complete a text mode operation
//
//
void WbDrawingArea::CompleteTextMode()
{
    // Not much to for text mode. Main text mode actions are taken
    // as a result of a WM_CHAR message and not on mouse events.
    // Just deselect our font if it is still selected
    UnPrimeFont(m_hDCCached);
}

//
//
// Function:    CompleteFreehandMode
//
// Purpose:     Complete a draw mode operation
//
//
void WbDrawingArea::CompleteFreehandMode(void)
{

    // Add the freehand object created during the drawing to the page
    if (m_pGraphicTracker != NULL)
    {
    	if (m_pGraphicTracker->Handle() == NULL)
        {
		    m_pGraphicTracker->ClearLockFlag();
    		m_pGraphicTracker->AddToPageLast(m_hPage);
	    }
    	else
	    {
		    // clear lock flag and let ForceReplace propagate it (fix
    		// for NT bug 4744(new bug#... )
	    	m_pGraphicTracker->ClearLockFlag();
	        m_pGraphicTracker->ForceReplace();
    	}
    }

    // Stop the update timer
    ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
}

//
//
// Function:    CompleteLineMode
//
// Purpose:     Complete a line mode operation
//
//
void WbDrawingArea::CompleteLineMode(void)
{
    // Only draw the line if it has non-zero length
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicLine line;
        line.SetStart(m_ptStart);
        line.SetEnd(m_ptEnd);
        line.SetColor(m_pToolCur->GetColor());
        line.SetPenWidth(m_pToolCur->GetWidth());
        line.SetROP(m_pToolCur->GetROP());
        line.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        line.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteRectangleMode
//
// Purpose:     Complete a box mode operation
//
//
void WbDrawingArea::CompleteRectangleMode(void)
{
    // Only draw the box if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicRectangle rectangle;
        rectangle.SetRectPts(m_ptStart, m_ptEnd);
        rectangle.SetPenWidth(m_pToolCur->GetWidth());
        rectangle.SetColor(m_pToolCur->GetColor());
        rectangle.SetROP(m_pToolCur->GetROP());
        rectangle.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        rectangle.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteFilledRectangleMode
//
// Purpose:     Complete a filled box mode operation
//
//
void WbDrawingArea::CompleteFilledRectangleMode(void)
{
    // Draw the new rectangle
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DCWbGraphicFilledRectangle rectangle;

        rectangle.SetRectPts(m_ptStart, m_ptEnd);
        rectangle.SetPenWidth(m_pToolCur->GetWidth());
        rectangle.SetColor(m_pToolCur->GetColor());
        rectangle.SetROP(m_pToolCur->GetROP());
        rectangle.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        rectangle.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    CompleteEllipseMode
//
// Purpose:     Complete an ellipse mode operation
//
//
void WbDrawingArea::CompleteEllipseMode(void)
{
    // Only draw the ellipse if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // The ellipse was defined by taking using start point as the center
        // but was changed to use the bounding tracking rectangle - bug 1608
        // Create the ellipse object
        DCWbGraphicEllipse ellipse;

        ellipse.SetRectPts(m_ptStart, m_ptEnd);
        ellipse.SetColor(m_pToolCur->GetColor());
        ellipse.SetPenWidth(m_pToolCur->GetWidth());
        ellipse.SetROP(m_pToolCur->GetROP());
        ellipse.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        ellipse.AddToPageLast(m_hPage);
    }
}


//
//
// Function:    CompleteFilledEllipseMode
//
// Purpose:     Complete a filled ellipse mode operation
//
//
void WbDrawingArea::CompleteFilledEllipseMode(void)
{
    // Only draw the ellipse if it is not null
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Create the ellipse object
        DCWbGraphicFilledEllipse ellipse;

        ellipse.SetRectPts(m_ptStart, m_ptEnd);
        ellipse.SetColor(m_pToolCur->GetColor());
        ellipse.SetPenWidth(m_pToolCur->GetWidth());
        ellipse.SetROP(m_pToolCur->GetROP());
        ellipse.GraphicTool(m_pToolCur->ToolType());

        // Add the object to the list of recorded graphics
        ellipse.AddToPageLast(m_hPage);
    }
}

//
//
// Function:    EndTextEntry
//
// Purpose:     The user has finished entering a text object. The parameter
//              indicates whether the changes are to be accepted or
//              discarded.
//
//
void WbDrawingArea::EndTextEntry(BOOL bAccept)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::EndTextEntry");

    // Only take action if the text editor is active
    if (m_bTextEditorActive)
    {
        RECT    rcBounds;

        // We must at least redraw the bounding rectangle of the
        // text object as it now stands (as it will not longer be
        // on top).
        m_textEditor.GetBoundsRect(&rcBounds);

        // If we are editing an existing text object
        if (m_pActiveText != NULL)
        {
            TRACE_MSG(("Editing an existing object"));

            //
            // If we are not accepting the edited text we must redraw
            // both the old and new rectangles to ensure that everything
            // is shown correctly.
            //
            if (!bAccept)
            {
                //
                // Write the active text object back to restore it. This object
                // will have the same handle as the text editor object if we have
                // written it to the page - we must not delete the text editor
                // object.
                //
                m_pActiveText->ForceReplace();
                m_textEditor.ZapHandle(); // prevent editor from stepping on m_pActiveText
            }
            else
            {
                // If the object is now empty
                if (m_textEditor.IsEmpty())
                {
                    // Remove the object from the list
                    PG_GraphicDelete(m_hPage, *m_pActiveText);
                    m_textEditor.ZapHandle(); // text object is gone now, invalidate
                }
                else
                {
                    // Do a replace to save the final version
                    m_textEditor.Replace();
                }
            }

            // We have finished with the text object now so get rid of it
            // and the fonts it holds
            TRACE_MSG(("Deleting the active object"));
            delete m_pActiveText;
            m_pActiveText = NULL;
        }
        else
        {
            // We were adding a new text object
            TRACE_MSG(("Adding a new object"));

            // If we want to discard the object, or it is empty
            if (!bAccept || (m_textEditor.IsEmpty()))
            {
                // If we have added the text editor to the page, remove it
                if (m_textEditor.Handle() != NULL)
                {
                    m_textEditor.Delete();
                }
            }
            else
            {
                // Check whether we have already added the object to the page
                if (m_textEditor.Handle() == NULL)
                {
                    // Create and add a new object to the page
                    // (No redrawing is required)
                    m_textEditor.AddToPageLast(m_hPage);
                }
                else
                {
                    // Replace the object to send the final version
                    m_textEditor.Replace();
                }
            }
        }

        // Deactivate the text editor
        DeactivateTextEditor();

        // Redraw any altered parts of the screen
        InvalidateSurfaceRect(&rcBounds);
    }
}

//
//
// Function:    Zoom
//
// Purpose:     Toggle the zoom state of the drawing area
//
//
void WbDrawingArea::Zoom(void)
{
    RECT    rcClient;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Zoom");

    // We zoom focusing on the centre of the window
    ::GetClientRect(m_hwnd, &rcClient);
    long xOffset = (rcClient.right - (rcClient.right / m_iZoomOption)) / 2;
    long yOffset = (rcClient.bottom - (rcClient.bottom / m_iZoomOption)) / 2;

    if (m_iZoomFactor != 1)
    {
        // We are already zoomed move back to unzoomed state
        // First save the scroll position in case we return to zoom immediately
        m_posZoomScroll = m_posScroll;
        m_zoomRestoreScroll  = TRUE;

        m_posScroll.x  -= xOffset;
        m_posScroll.y  -= yOffset;
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
        m_iZoomFactor = 1;
    }
    else
    {
        // We are not zoomed so do it
        if (m_zoomRestoreScroll)
        {
            m_posScroll = m_posZoomScroll;
        }
        else
        {
            m_posScroll.x += xOffset;
            m_posScroll.y += yOffset;
        }

        m_iZoomFactor = m_iZoomOption;
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);

        // ADDED BY RAND - don't allow text editing in zoom mode
        if( (m_pToolCur == NULL) || (m_pToolCur->ToolType() == TOOLTYPE_TEXT) )
            ::SendMessage(g_pMain->m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0 );
    }

    TRACE_MSG(("Set zoom factor to %d", m_iZoomFactor));

      // Update the scroll information
    SetScrollRange(rcClient.right, rcClient.bottom);
    ValidateScrollPos();

    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Update the origin offset from the scroll position
    m_originOffset.cx = m_posScroll.x;
    m_originOffset.cy = m_posScroll.y;
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

    // Tell the parent that the scroll position has changed
    ::PostMessage(g_pMain->m_hwnd, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);

    g_pMain->SetMenuStates(::GetSubMenu(::GetMenu(g_pMain->m_hwnd), 3));

    // Redraw the window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    SelectTool
//
// Purpose:     Set the current tool
//
//
void WbDrawingArea::SelectTool(WbTool* pToolNew)
{
    // If we are leaving text mode, complete the text entry
    if (m_bTextEditorActive  && (m_pToolCur->ToolType() == TOOLTYPE_TEXT)
      && (pToolNew->ToolType() != TOOLTYPE_TEXT))
    {
        // End text entry accepting the changes
        EndTextEntry(TRUE);
    }

    ASSERT(m_pMarker);

    // If we are no longer in select mode, and the marker is present,
    // then remove it and let the tool know it's no longer selected
    if (   (m_pToolCur != NULL)
        && (m_pToolCur->ToolType() == TOOLTYPE_SELECT)
        && (pToolNew->ToolType() != TOOLTYPE_SELECT))
    {
        m_pToolCur->DeselectGraphic();

        RemoveMarker(NULL);
        m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );

        delete m_pSelectedGraphic;
        m_pSelectedGraphic = NULL;
    }
    else if (   (m_pToolCur != NULL)
      && (m_pToolCur->ToolType() == TOOLTYPE_ERASER)
      && (pToolNew->ToolType() != TOOLTYPE_ERASER))
    {
        m_pToolCur->DeselectGraphic();

        RemoveMarker(NULL);
        m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );

        delete m_pSelectedGraphic;
        m_pSelectedGraphic = NULL;
    }

    // Save the new tool
    m_pToolCur = pToolNew;
}

//
//
// Function:    SetSelectionColor
//
// Purpose:     Set the color of the selected object
//
//
void WbDrawingArea::SetSelectionColor(COLORREF clr)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionColor");

    // If the text editor is active - redraw the text in the new color
    if (m_bTextEditorActive)
    {
        // Change the color being used by the editor
        m_textEditor.SetColor(clr);

        // Update the screen
        m_textEditor.GetBoundsRect(&rc);
        InvalidateSurfaceRect(&rc);
    }

    // If there is a currently marked object
    if (GraphicSelected())
    {
        // Change color of the selected objects
        ASSERT(m_pMarker);

        m_pMarker->SetColor(clr);

        // Update the objects
        m_pMarker->Update();
    }

    m_textEditor.ForceUpdate();

}

//
//
// Function:    SetSelectionWidth
//
// Purpose:     Set the nib width used to draw the currently selected object
//
//
void WbDrawingArea::SetSelectionWidth(UINT uiWidth)
{
    // If there is a currently marked object
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Change the width of the object
        m_pMarker->SetPenWidth(uiWidth);

        // Update the object
        m_pMarker->Update();
    }
}

//
//
// Function:    SetSelectionFont
//
// Purpose:     Set the font used by the currently selected object
//
//
void WbDrawingArea::SetSelectionFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionFont");

    // Define rectangles for redrawing
    RECT    rcOldBounds;
    RECT    rcNewBounds;

    m_textEditor.GetBoundsRect(&rcOldBounds);

    // Pass the font onto the text editor
    // If the text editor is active - redraw the text in the new font
    if (m_bTextEditorActive)
    {
        m_textEditor.SetFont(hFont);

        // Get the new rectangle of the text
        m_textEditor.GetBoundsRect(&rcNewBounds);

        // Remove and destroy the text cursor to ensure that it
        // gets re-drawn with the new size for the font

        // Update the screen
        InvalidateSurfaceRect(&rcOldBounds);
        InvalidateSurfaceRect(&rcNewBounds);

        // get the text cursor back
        ActivateTextEditor( TRUE );
    }

    // If there is a currently marked object
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        m_pMarker->SetSelectionFont(hFont);
    }
}

//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbDrawingArea::OnSetFocus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnSetFocus");

    //
    // If we are in text mode, we must make the text cursor visible.
    //
    if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
    {
        ActivateTextEditor(TRUE);
    }
}


//
//
// Function:    OnActivate
//
// Purpose:     The window is being activated or deactivated
//
//
void WbDrawingArea::OnActivate(UINT uiState)
{
    // Check if we are being activated or deactivated
    if (uiState)
    {
        // We are being activated, get the focus as well
        ::SetFocus(m_hwnd);

        // If we are in text mode, we must make the text cursor visible
        if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
        {
            ActivateTextEditor(TRUE);
        }
    }
    else
    {
        // We are being deactivated
        DeactivateTextEditor();
    }
}




//
//
// Function:    DeleteGraphic
//
// Purpose:     Remove an object from the page.
//
//
void WbDrawingArea::DeleteGraphic(DCWbGraphic* pObject)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeleteGraphic");

    ASSERT(pObject != NULL);

    // Delete the object from the recorded list. This is an asynchronous
    // function, completed when a WBP_EVENT_GRAPHIC_DELETED event is received.
    PG_GraphicDelete(m_hPage, *pObject);

    // The caller is responsible for deleting the graphic object.
}

//
//
// Function:    DeleteSelection
//
// Purpose:     Delete the currently selected object
//
//
void WbDrawingArea::DeleteSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // ...delete it
        m_pMarker->DeleteSelection();
        m_pSelectedGraphic = NULL;
    }
}

//
//
// Function:    GetSelection
//
// Purpose:     Return the currently selected graphic (or NULL if none).
//
//
DCWbGraphic* WbDrawingArea::GetSelection()
{
  DCWbGraphic* pGraphic = NULL;

  // If there is an object currently selected...
  if (GraphicSelected())
  {
    // ...return it
    pGraphic = m_pSelectedGraphic;
  }

  return pGraphic;
}

//
//
// Function:    BringToTopSelection
//
// Purpose:     Bring the currently selected object to the top
//
//
void WbDrawingArea::BringToTopSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Bring it to the top
        m_pMarker->BringToTopSelection();

    // The update will be made in the window from the event generated
    // by the change to the page.
  }
}

//
//
// Function:    SendToBackSelection
//
// Purpose:     Send the currently marked object to the back
//
//
void WbDrawingArea::SendToBackSelection()
{
    // If there is an object currently selected...
    if (GraphicSelected())
    {
        ASSERT(m_pMarker);

        // Send it to the back
        m_pMarker->SendToBackSelection();

    // The update will be made in the window from the event generated
    // by the change to the page.
  }
}

//
//
// Function:    Clear
//
// Purpose:     Clear the drawing area.
//
//
void WbDrawingArea::Clear()
{
    // Remove the recorded objects
    PG_Clear(m_hPage);

  // The page will be redrawn after an event generated by the clear request
}

//
//
// Function:    Attach
//
// Purpose:     Change the page the window is displaying
//
//
void WbDrawingArea::Attach(WB_PAGE_HANDLE hPage)
{
    // Remove any pointers on the current page. We are really only doing this
    // to tell the pointers they are no longer drawn as they keep a record
    // of whether they are in order to undraw correctly.
    if (m_allPointers.IsEmpty() == FALSE)
    {
        // Get a DC for drawing
        HDC hDC = m_hDCCached;

        // Remove the pointers, reversing through the list
        DCWbGraphicPointer* pPointer;
        POSITION pos = m_allPointers.GetHeadPosition();

        while (pos != NULL)
        {
            // Remove it
            pPointer = (DCWbGraphicPointer*) m_allPointers.GetNext(pos);
            pPointer->Undraw(hDC, this);
        }
    }

    m_allPointers.EmptyList();
    m_undrawnPointers.EmptyList();

    // Accept any text being edited
    if (m_bTextEditorActive)
    {
        EndTextEntry(TRUE);
    }

    // finish any drawing operation now
    if (m_bLButtonDown)
    {
        OnLButtonUp(0, m_ptStart.x, m_ptStart.y);
    }

    // Get rid of the selection
    ClearSelection();

    // Save the new page details
    m_hPage = hPage;

    // If the new page we are attaching is not the empty page, set up
    // the list of pointers for the new page.
    if (m_hPage != WB_PAGE_HANDLE_NULL)
    {
        // Get the list of active pointers on the new page. The local
        // pointer must be last in the list so that it is drawn topmost.
        POM_OBJECT  hUserNext;

        DCWbGraphicPointer* pPointer = PG_FirstPointer(m_hPage, &hUserNext);

        while (pPointer != NULL)
        {
            // Check whether we should add this pointer to the list
            if (!pPointer->IsLocalPointer())
            {
                m_allPointers.AddTail(pPointer);
            }

            // Get the next pointer
            pPointer = PG_NextPointer(m_hPage, &hUserNext);
        }

        // Check if the local pointer should also be added
        pPointer = PG_LocalPointer(m_hPage);

        if (pPointer != NULL)
        {
            m_allPointers.AddTail(pPointer);
        }
    }

    // Force a redraw of the window to show the new contents
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    DrawMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::DrawMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DrawMarker");

    ASSERT(m_pMarker);

    if (!hDC)
        hDC = m_hDCCached;

    // Draw the marker
    m_pMarker->Draw(hDC);
}

//
//
// Function:    PutMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::PutMarker(HDC hDC, BOOL bDraw)
{
    ASSERT(m_pMarker);

    // If the marker is not already present, draw it
    if (!m_bMarkerPresent)
    {
        m_pMarker->Present( TRUE );

        // Draw the marker (using XOR)
        if( bDraw )
            DrawMarker(hDC);

        // Show that the marker is present
        m_bMarkerPresent = TRUE;
    }
}

//
//
// Function:    RemoveMarker
//
// Purpose:     Remove the graphic object marker
//
//
void WbDrawingArea::RemoveMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::RemoveMarker");

    ASSERT(m_pMarker);

    if (!hDC)
        hDC = m_hDCCached;

    // If the marker is not already present, draw it
    if (m_bMarkerPresent)
    {
        // Draw the marker (it is XORed so this removes it)
        m_pMarker->Undraw(hDC, this);

        m_pMarker->Present( FALSE );

        // Show that the marker is no longer present
        m_bMarkerPresent = FALSE;
    }
}




//
//
// Function:    ActivateTextEditor
//
// Purpose:     Start a text editing session
//
//
void WbDrawingArea::ActivateTextEditor( BOOL bPutUpCusor )
{
    // Record that the editor is now active
    m_bTextEditorActive = TRUE;

    // show editbox
    m_textEditor.ShowBox( SW_SHOW );

    // reset our DBCS sync

    // Start the timer for updating the text
    m_textEditor.SetTimer( DRAW_GRAPHICUPDATEDELAY);
}

//
//
// Function:    DeactivateTextEditor
//
// Purpose:     End a text editing session
//
//
void WbDrawingArea::DeactivateTextEditor(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeactivateTextEditor");

    // Stop the update timer
    m_textEditor.KillTimer();

    // Ensure the object is unlocked, if it was ever added to the page
    if (m_textEditor.Handle() != NULL)
    {
        m_textEditor.Unlock();

        // Sync up across all connections - FIXES BUG 521
        m_textEditor.ForceReplace();

        UINT uiReturn;
        uiReturn = g_pwbCore->WBP_GraphicMove(m_hPage, m_textEditor.Handle(),
            LAST);
        if (uiReturn != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		    return;
        }
        //////////////////////////
    }

    // Show that we are not editing any text
    m_bTextEditorActive = FALSE;

    // hide editbox
    m_textEditor.ShowBox( SW_HIDE );
}



//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a point in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPPOINT lppoint)
{
    lppoint->x -= m_originOffset.cx;
    lppoint->x *= m_iZoomFactor;

    lppoint->y -= m_originOffset.cy;
    lppoint->y *= m_iZoomFactor;
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a point in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPPOINT lppoint)
{
    ASSERT(m_iZoomFactor != 0);

    lppoint->x /= m_iZoomFactor;
    lppoint->x += m_originOffset.cx;

    lppoint->y /= m_iZoomFactor;
    lppoint->y += m_originOffset.cy;
}


//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a rectangle in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPRECT lprc)
{
    SurfaceToClient((LPPOINT)&lprc->left);
    SurfaceToClient((LPPOINT)&lprc->right);
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a rectangle in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPRECT lprc)
{
    ClientToSurface((LPPOINT)&lprc->left);
    ClientToSurface((LPPOINT)&lprc->right);
}

//
//
// Function:    GraphicSelected
//
// Purpose:     Return TRUE if a graphic is currently selected
//
//
BOOL WbDrawingArea::GraphicSelected(void)
{
    ASSERT(m_pMarker);

    BOOL bSelected = (m_bMarkerPresent) && (m_pMarker->GetNumMarkers() > 0);

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::GraphicSelected");

    if( bSelected )
        {
        ASSERT(m_pSelectedGraphic != NULL);
        }

    return( bSelected );
    }

//
//
// Function:    SelectGraphic
//
// Purpose:     Select a graphic - save the pointer to the graphic and
//              draw the marker on it.
//
//
void WbDrawingArea::SelectGraphic(DCWbGraphic* pGraphic,
                                      BOOL bEnableForceAdd,
                                      BOOL bForceAdd )
{
    BOOL bZapCurrentSelection;
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SelectGraphic");

    ASSERT(m_pMarker);

  if (pGraphic->Locked() == FALSE)
  {
    // Save the pointer to the selected graphic
    m_pSelectedGraphic = pGraphic;


    if( (pGraphic = m_pMarker->HasAMarker( m_pSelectedGraphic )) != NULL )
        {
        // toggle marker (unselect pGraphic)
        delete pGraphic;
        delete m_pSelectedGraphic;
        m_pSelectedGraphic = m_pMarker->LastMarker();
        }
    else
        {

        // new selection, add to list or replace list?
        if( bEnableForceAdd )
            bZapCurrentSelection = !bForceAdd;
        else
            bZapCurrentSelection =
                ((GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                    (GetAsyncKeyState( VK_CONTROL ) >= 0));

        if( bZapCurrentSelection )
            {
            // replace list
            RemoveMarker(NULL);
            m_pMarker->DeleteAllMarkers( m_pSelectedGraphic, TRUE );
            }

        // Add the object rect to the marker rect list
        m_pSelectedGraphic->GetBoundsRect(&rc);
        m_pMarker->SetRect(&rc, m_pSelectedGraphic, FALSE );
    }

    // Draw the marker
    PutMarker(NULL);

    // Update the attributes window to show graphic is selected
    if( m_pSelectedGraphic != NULL )
        m_pToolCur->SelectGraphic(m_pSelectedGraphic);

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
    }
  }
  else
  {
    // we can delete the graphic now, because we're not selecting it
    delete pGraphic;
    m_pSelectedGraphic = NULL;
    TRACE_MSG(("Tried to select a locked graphic - ignored"));
  }
}

//
//
// Function:    DeselectGraphic
//
// Purpose:     Deselect a graphic - remove the marker and delete the
//              graphic object associated with it.
//
//
void WbDrawingArea::DeselectGraphic(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeselectGraphic");

    //
    // Quit if no graphic selected.
    //
    if( m_pSelectedGraphic == NULL )
    {
        return;
    }

    // Remove the marker
    RemoveMarker(NULL);

    // Delete the graphic object
    delete m_pSelectedGraphic;
    m_pSelectedGraphic = NULL;

    // Update the attributes window to show graphic is unselected
    m_pToolCur->DeselectGraphic();

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0L);
    }
}



//
//
// Function:    GetVisibleRect
//
// Purpose:     Return the rectangle of the surface currently visible in the
//              drawing area window.
//
//
void WbDrawingArea::GetVisibleRect(LPRECT lprc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::VisibleRect");

    // Get the client rectangle
    ::GetClientRect(m_hwnd, lprc);

    // Convert to surface co-ordinates
    ClientToSurface(lprc);
}


//
//
// Function:    MoveOntoSurface
//
// Purpose:     If a given point is outwith the surface rect, move it on
//
//
void WbDrawingArea::MoveOntoSurface(LPPOINT lppoint)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::MoveOntoSurface");

    //
    // Make sure that the position is within the surface rect
    //

    if (lppoint->x < 0)
    {
        lppoint->x = 0;
    }
    else if (lppoint->x >= DRAW_WIDTH)
    {
        lppoint->x = DRAW_WIDTH - 1;
    }

    if (lppoint->y < 0)
    {
        lppoint->y = 0;
    }
    else if (lppoint->y >= DRAW_HEIGHT)
    {
        lppoint->y = DRAW_HEIGHT - 1;
    }
}


//
//
// Function:    GetOrigin
//
// Purpose:     Provide current origin of display
//
//
void WbDrawingArea::GetOrigin(LPPOINT lppoint)
{
    lppoint->x = m_originOffset.cx;
    lppoint->y = m_originOffset.cy;
}



void WbDrawingArea::ShutDownDC(void)
{
    UnPrimeDC(m_hDCCached);

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;
}




void WbDrawingArea::ClearSelection( void )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ClearSelection");

    ASSERT(m_pMarker);

    RemoveMarker( NULL );
    m_pMarker->DeleteAllMarkers( m_pSelectedGraphic );
    DeselectGraphic();
}





void WbDrawingArea::OnCancelMode( void )
{
    // We were dragging but lost mouse control, gracefully end the drag (NM4db:573)
    POINT pt;

    ::GetCursorPos(&pt);
    ::ScreenToClient(m_hwnd, &pt);
    OnLButtonUp(0, pt.x, pt.y);
    m_bLButtonDown = FALSE;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\globals.h ===
//
// Global variables
//

extern WbMainWindow *   g_pMain;
extern HINSTANCE        g_hInstance;
extern IWbClient *      g_pwbCore;
extern UINT             g_uConfShutdown;
extern HPALETTE         g_hRainbowPaletteDisplay;
extern WbPrinter *      g_pPrinter;
extern HINSTANCE        g_hImmLib;
extern IGC_PROC         g_fnImmGetContext;
extern INI_PROC         g_fnImmNotifyIME;

enum
{
    CLIPBOARD_PRIVATE_SINGLE_OBJ = 0,
    CLIPBOARD_PRIVATE_MULTI_OBJ,
    CLIPBOARD_DIB,
    CLIPBOARD_ENHMETAFILE,
    CLIPBOARD_TEXT,
    CLIPBOARD_ACCEPTABLE_FORMATS
};
extern int         g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS];


extern BOOL         g_bPalettesInitialized;
extern BOOL         g_bUsePalettes;

extern UINT         g_PenWidths[NUM_OF_WIDTHS];
extern UINT         g_HighlightWidths[NUM_OF_WIDTHS];


#define NUM_COLOR_ENTRIES   21
extern COLORREF     g_ColorTable[NUM_COLOR_ENTRIES];


//
// Complex object globals
//
extern WbUserList *  g_pUsers;

extern WbDrawingArea *      g_pDraw;

extern DCWbColorToIconMap * g_pIcons;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\grobj.hpp ===
//
// GROBJ.CPP
// Graphic Object Classes
//
// Copyright Microsoft 1998-
//
#ifndef __GROBJ_HPP_
#define __GROBJ_HPP_


#define HIT_WINDOW	1
#define MAKE_HIT_RECT(r, p )  \
    ::SetRect(&r, p.x-HIT_WINDOW, p.y-HIT_WINDOW, p.x+HIT_WINDOW, p.y+HIT_WINDOW);
	

//
// Marker definitions
//
#define NO_HANDLE    -1
#define TOP_LEFT      0
#define TOP_MIDDLE    1
#define TOP_RIGHT     2
#define RIGHT_MIDDLE  3
#define BOTTOM_RIGHT  4
#define BOTTOM_MIDDLE 5
#define BOTTOM_LEFT   6
#define LEFT_MIDDLE   7

//
// Definitions for text objects
//
#define LAST_LINE -1
#define LAST_CHAR -2

//
// Maximum number of points in a freehand object - determined by the fact
// that pointCount is held in a TSHR_UINT16 in WB_GRAPHIC_FREEHAND (awbdef.h)
//
#define MAX_FREEHAND_POINTS     65535


BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth, LPCRECT lpHitRect );


// Class to simulate CMapPtrToPtr but based on a linked list instead of the order-jumbling
// hashing method. This is the major cause of bug 354. I'm doing this instead of just replacing 
// CMapPtrToPtr because it is used in a zillion places and I want to minimize changes to the
// multi-object select logic so that I don't break it.
class CPtrToPtrList : public COBLIST
{

public:
	CPtrToPtrList( void );
	~CPtrToPtrList(void);
	
	void SetAt( void *key, void *newValue );
	BOOL RemoveKey( void *key );
	void RemoveAll( void );

	void GetNextAssoc( POSITION &rNextPosition, void *&rKey, void *&rValue ) ;
	BOOL Lookup( void *key, void *&rValue );


protected:
struct stPtrPair
		{
		void *pMainThing;
		void *pRelatedThing;
		};

	stPtrPair *FindMainThingPair( void *pMainThing, POSITION *pPos );
};





//
//
// Class:   DCWbGraphic
//
// Purpose: Base graphic object class
//
//
class WbDrawingArea;

enum 
{
	enumGraphicMarker,
	enumGraphicFreeHand,
	enumGraphicFilledRectangle,
	enumGraphicFilledEllipse,
	enumGraphicText,
    enumGraphicDIB,
	enumGraphicPointer,
	enumNoGraphicTool
};



class DCWbGraphic
{
public:
    //
    // Static graphic construction routines - return a pointer to a graphic
    // of the relevant type given a page and graphic handle or a pointer to
    // a flat graphic representation.
    //
    static DCWbGraphic* ConstructGraphic(WB_PAGE_HANDLE hPage,
                                         WB_GRAPHIC_HANDLE hGraphic);

    static DCWbGraphic* ConstructGraphic(PWB_GRAPHIC pHeader);

    static DCWbGraphic* ConstructGraphic(WB_PAGE_HANDLE hPage,
									     WB_GRAPHIC_HANDLE hGraphic,
										 PWB_GRAPHIC pHeader);

    static DCWbGraphic* CopyGraphic(PWB_GRAPHIC pHeader);


    //
    // Constructor.
    //
    DCWbGraphic(PWB_GRAPHIC pHeader = NULL);
    DCWbGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE _hGraphic);
    virtual ~DCWbGraphic( void );


	virtual UINT IsGraphicTool(void) = 0;

    //
    // Get/set the bounding rectangle of the graphic object (in logical
    // co-ordinates).
    //
    virtual void    GetBoundsRect(LPRECT lprc) { *lprc = m_boundsRect; }
    virtual void    SetBoundsRect(LPCRECT lprc);

    //
    // Get the size of the object
    //
    virtual int   Width(void) { return(m_boundsRect.right - m_boundsRect.left); }
    virtual int   Height(void) { return(m_boundsRect.bottom - m_boundsRect.top); }

    //
    // Get/set the defining rectangle of the graphic - this is only set up
    // for some object types e.g.  rectangles and ellipses.
    //
    virtual LPCRECT GetRect(void) const { return(&m_rect); }
    virtual void   SetRect(LPCRECT lprc);
    virtual void   SetRectPts(POINT ptStart, POINT ptEnd);

    //
    // Get/set the color the object will be drawn in
    //
    virtual void     SetColor(COLORREF clr);
    virtual COLORREF GetColor(void) //CHANGED BY RAND for PALETTERGB
		{ return( SET_PALETTERGB(m_clrPenColor ) ); }

    //
    // Get/set the width of the pen used to draw the object
    //
    virtual void SetPenWidth(UINT uiWidth);
    virtual UINT GetPenWidth(void) { return m_uiPenWidth; }

    //
    // Get/set the raster op to be used to draw the object
    //
    virtual void SetROP(int iPenROP);
    virtual int  GetROP(void) { return m_iPenROP; }

    //
    // Get/set the pen style
    //
    virtual void SetPenStyle(int iPenStyle);
    virtual int  GetPenStyle(void) { return m_iPenStyle; }

    //
    // Translates the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Set the top left corner of the object's bounding rectangle to the
    // point specified as parameter.
    //
    virtual void MoveTo(int x, int y);

    //
    // Return the top left corner of the objects bounding rectangle.
    //
    virtual void GetPosition(LPPOINT lpt);

    //
    // Return TRUE if the specified point is inside the bounding rectangle
    // of the graphic object.
    //
    virtual BOOL PointInBounds(POINT pt);

    //
    // Draw the graphic object into the device context specified.
    //
    virtual void Draw(HDC hDC)
					{return;}
    virtual void Draw(HDC hDC, WbDrawingArea * pDrawingArea)
                    { Draw(hDC); }
    virtual void Draw(HDC hDC, BOOL thumbNail)
                    { Draw(hDC); }

    //
    // Return the page of the graphic object
    //
    virtual WB_PAGE_HANDLE Page(void) const { return m_hPage; }

    //
    // Return the handle of the graphic object
    //
    virtual WB_GRAPHIC_HANDLE Handle(void) const { return m_hGraphic; }
    virtual void ZapHandle(void) {m_hGraphic = NULL;}

    //
    // Return TRUE if the graphic is topmost on its page
    //
    virtual BOOL IsTopmost(void);

    //
    // Update the external version of the graphic
    //
    virtual void ForceReplace(void);
    virtual void Replace(void);
    virtual void ForceUpdate(void); 
    virtual void Update(void);
    virtual void Delete(void);

    //
    // Confirm an update or delete of the graphic
    //
    virtual void ReplaceConfirm(void);
    virtual void UpdateConfirm(void);
    virtual void DeleteConfirm(void);


	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit)
	{
        RECT    rcT;
        return(!IntersectRect(&rcT, &m_boundsRect, pRectHit));
	}


    //
    // Lock and unlock the graphic - the lock or unlock will only take
    // effect the next time the graphic is updated or replaced.
    //
    void Lock(void);
    void Unlock(void);
    BOOL Locked(void) { return (m_uiLockState == WB_GRAPHIC_LOCK_REMOTE); }
    BOOL GotLock(void) { return (m_uiLockState == WB_GRAPHIC_LOCK_LOCAL); }
    void ClearLockFlag(void) {m_uiLockState = WB_GRAPHIC_LOCK_NONE;}

	UINT GetLockState( void )
		{return( m_uiLockState );}

	void SetLockState( UINT uLock )
		{m_uiLockState = uLock;}

    //
    // Add this graphic to the specified page.  This member must only be
    // called if the graphic does not yet belong to a page (i.e.  if
    // hGraphic is NULL).
    //
    virtual void AddToPageLast(WB_PAGE_HANDLE hPage);

    //
    // Return a copy of the graphic - this is a complete copy with all
    // data read into internal memory.
    //
    virtual DCWbGraphic* Copy(void) const;

    //
    // Return TRUE if the graphic has changed since it was last read/written
    // from    external storage.
    //
    virtual BOOL Changed(void) const { return m_bChanged; }

    //
    // Get/set the type of tool which drew the graphic, or at least one
    // which can be used to manipulate it.
    //
    void GraphicTool(int toolType)
                     { m_toolType = toolType; m_bChanged = TRUE; }
    int  GraphicTool(void) { return m_toolType; }

    //
    // Return the length of the external representation of the object
    //
    DWORD ExternalLength(void) 
		{return(m_dwExternalLength );}

protected:
    //
    // Initialize the member variables
    //
    virtual void Initialize(void);

    //
    // Bounding rectangle calculation
    //
    virtual void CalculateBoundsRect(void) { m_boundsRect = m_rect; }

    //
    // Ensure that a rectangle has top left to the left of and above bottom
    // right.
    //
    void NormalizeRect(LPRECT lprc);

    //
    // Type of the graphic (used in the external representation)
    //
    virtual UINT Type(void) const { return 0; }

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void)
                                           { return sizeof(WB_GRAPHIC); }

    //
    // Convert between internal and external representations
    //
    virtual void ReadExternal(void);
    virtual void ReadHeader(PWB_GRAPHIC pHeader);
    virtual void ReadExtra(PWB_GRAPHIC) {}
    virtual void CopyExtra(PWB_GRAPHIC) {}

    virtual void WriteExternal(PWB_GRAPHIC pHeader);
    virtual void WriteHeader(PWB_GRAPHIC pHeader);
    virtual void WriteExtra(PWB_GRAPHIC) {}

    //
    // Page on which this object belongs
    //
    WB_PAGE_HANDLE m_hPage;

    //
    // Whiteboard Core handle for the object
    //
    WB_GRAPHIC_HANDLE m_hGraphic;

    //
    // Flag indicating whether the graphic has changed since it was last
    // read from external storage.
    //
    BOOL m_bChanged;

    //
    // Graphic header details
    //
    DWORD    m_dwExternalLength;  // Length of the object
    RECT     m_boundsRect;      // Bounding
    RECT     m_rect;            // Defining
    COLORREF m_clrPenColor;       // Color of pen as RGB
    UINT     m_uiPenWidth;        // Width in logical units
    int      m_iPenROP;           // Raster operation to be used for drawing
    int      m_iPenStyle;         // Pen style to be used for drawing
    UINT     m_uiLockState;       // Lock indicator
    int      m_toolType;          // Type of tool used to create the graphic
};

//
//
// Class:   DCWbGraphicMarker
//
// Purpose: Class representing an object marker. This is a set of eight
//          handles drawn at intervals round the objects bounding rectangle.
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicMarker : public DCWbGraphic
{

friend class DCWbGraphicSelectTrackingRectangle;

  public:
    //
    // Constructors
    //
    DCWbGraphicMarker(void);
    ~DCWbGraphicMarker(void);

	UINT IsGraphicTool(void) { return enumGraphicMarker;}

	
	// Rect that bounds all objs in RectList
    virtual void GetBoundsRect(LPRECT lprc);

	// Deletes all marker rects in RectList
	void DeleteAllMarkers( DCWbGraphic *pLastSelectedGraphic, 
						   BOOL bLockLastSelectedGraphic = FALSE ); 

	// Deletes one marker
	void DeleteMarker( DCWbGraphic *pGraphic ); 

	// Sees if obj is already in marker
	DCWbGraphic *HasAMarker( DCWbGraphic *pGraphic );

	// Gets last marker
    DCWbGraphic *LastMarker( void );

	// Gets number of markers in marker list
	int	GetNumMarkers( void );

	// Moves all selected objects by offset
    virtual void MoveBy(int cx, int cy);

	// Updates selected remote objects
    void Update( void );

	// Checks for point hitting any marker obj
	BOOL PointInBounds(POINT pt);

	// Changes color for selection
	void SetColor(COLORREF color);

	// Changes width of selection
	void SetPenWidth(UINT uiWidth);

	// Changes font of selection (text objs only)
	void SetSelectionFont(HFONT hFont);

	//Deletes all objs in selection
	void DeleteSelection( void );

	//Brings all objs in selection to top
	void BringToTopSelection( void );

	//Sends all objs to bottom
	void SendToBackSelection( void );

	//Renders marker objects to a multi-obj format and copies to the 
	// clipboard
	BOOL RenderPrivateMarkerFormat( void );

	//Pastes multi-obj clipboard data
	void Paste( HANDLE handle ); 


    //
    // Set the object defining rectangle - this is only set up for some
    // object types e.g. rectangles and ellipses.
    //
    BOOL    SetRect(LPCRECT lprc, DCWbGraphic *pGraphic, BOOL bRedraw,
				BOOL bLockObject = TRUE );

    //
    // Return an indication of which handle the specified point lies in.
    //
    int PointInMarker(POINT pt);

    //
    // Draw the marker
    //
    void Draw(HDC hDC, BOOL bDrawObjects = FALSE );
    void Undraw(HDC hDC, WbDrawingArea * pDrawingArea);

	void DrawRect( HDC hDC, LPCRECT pMarkerRect,
				   BOOL bDrawObject, DCWbGraphic *pGraphic );
	void UndrawRect(HDC hDC, WbDrawingArea * pDrawingArea,
					LPCRECT pMarkerRect );

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	void Present( BOOL bOn )
		{m_bMarkerPresent = bOn;}

  protected:
    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Marker rectangle calculation
    //
    void CalculateMarkerRectangles(void);

    //
    // Marker rectangle
    //
    RECT    m_markerRect;
	CPtrToPtrList MarkerList; // keys are DCWbGraphic pointers, 
							 // values are LPRECT pointers.
	BOOL m_bMarkerPresent;

	
	void UndrawMarker(LPCRECT pMarkerREct);

    //
    // Brush used to draw the marker rectangle
    //
    HBRUSH  m_hMarkerBrush;
};





//
//
// Class:   DCWbGraphicLine
//
// Purpose: Class representing straight line
//
//
class DCWbGraphicLine : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicLine(void) { }
    DCWbGraphicLine(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicLine(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicLine(void);

    //
    // Set the object start and end points
    //
    void SetStart(POINT ptStart);
    void SetEnd(POINT ptEnd);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_LINE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingLine
//
// Purpose: Class representing an XORed straight line (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingLine : public DCWbGraphicLine
{

  public:
    //
    // Constructor
    //
    DCWbGraphicTrackingLine(void) { SetROP(R2_NOTXORPEN); };
};

//
//
// Class:   DCWbGraphicFreehand
//
// Purpose: Class representing multiple line segments
//
//


class DCDWordArray
{



  public:
	DCDWordArray(void);
	~DCDWordArray(void);
	
    void Add(POINT point);
	BOOL ReallocateArray(void);
	POINT* GetBuffer(void) { return m_pData; }
    void SetSize(UINT size);
	UINT GetSize(void);

    POINT* operator[](UINT index){return &(m_pData[index]);}
	
  private:

	POINT*  m_pData;
	UINT	m_Size;
	UINT	m_MaxSize;

  
    
};
/////////////

class DCWbGraphicFreehand : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicFreehand(void);
    DCWbGraphicFreehand(PWB_GRAPHIC pHeader);
    DCWbGraphicFreehand(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

    ~DCWbGraphicFreehand(void);

	UINT IsGraphicTool(void) { return enumGraphicFreeHand;}

    //
    // Add a point to the list, returning success
    //
    BOOL AddPoint(POINT pt);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FREEHAND; }

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void ReadExtra(PWB_GRAPHIC pHeader);

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
    void AddPointToBounds(int x, int y);


    //
    // Array holding point information
    //
    DCDWordArray points;   //CHANGED BY RAND

    //
    // Spline curve smoothing drawing functions
    //
    void DrawUnsmoothed(HDC hDC);
};

//
//
// Class:   DCWbGraphicRectangle
//
// Purpose: Class representing a rectangle
//
//
class DCWbGraphicRectangle : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicRectangle(void) { }
    DCWbGraphicRectangle(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicRectangle(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicRectangle(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

    //
    // Set the defining rectangle
    //
    void   SetRect(LPCRECT lprc);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_RECTANGLE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingRectangle
//
// Purpose: Class representing an XORed rectangle (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingRectangle : public DCWbGraphicRectangle
{

  public:
        //
        // Constructor
        //
        DCWbGraphicTrackingRectangle(void) { SetROP(R2_NOTXORPEN); };
};




class DCWbGraphicSelectTrackingRectangle : public DCWbGraphicRectangle
{

  public:
    //
    // Constructor
    //
    DCWbGraphicSelectTrackingRectangle(void) 
		{SetROP(R2_NOTXORPEN); m_Offset.cx = 0; m_Offset.cy = 0; }

    void Draw( HDC hDC);
	virtual void MoveBy(int cx, int cy);

protected:
	SIZE m_Offset;
};




//
//
// Class:   DCWbGraphicFilledRectangle
//
// Purpose: Class representing a filled rectangle
//
//
class DCWbGraphicFilledRectangle : public DCWbGraphicRectangle
{

  public:
    //
    // Constructors
    //
    DCWbGraphicFilledRectangle(void) { }
    DCWbGraphicFilledRectangle(PWB_GRAPHIC pHeader)
      : DCWbGraphicRectangle(pHeader) { }
    DCWbGraphicFilledRectangle(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphicRectangle(hPage, hGraphic) { }

    ~DCWbGraphicFilledRectangle(void);

	UINT IsGraphicTool(void) { return enumGraphicFilledRectangle;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FILLED_RECTANGLE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicEllipse
//
// Purpose: Class representing an ellipse
//
//
class DCWbGraphicEllipse : public DCWbGraphic
{

  public:
    //
    // Constructor
    //
    DCWbGraphicEllipse(void) { }
    DCWbGraphicEllipse(PWB_GRAPHIC pHeader)
      : DCWbGraphic(pHeader) { }
    DCWbGraphicEllipse(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphic(hPage, hGraphic) { }

    ~DCWbGraphicEllipse(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}
	
    //
    // Set the defining rectangle
    //
    void   SetRect(LPCRECT lprc);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Translate the graphic object by the x and y values of the point
    // parameter.
    //
    virtual void MoveBy(int cx, int cy);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_ELLIPSE; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicTrackingEllipse
//
// Purpose: Class representing an XORed ellipse (for rubber banding)
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicTrackingEllipse : public DCWbGraphicEllipse
{

  public:
    //
    // Constructors
    //
    DCWbGraphicTrackingEllipse(void) { SetROP(R2_NOTXORPEN); };
};

//
//
// Class:   DCWbGraphicFilledEllipse
//
// Purpose: Class representing a filled ellipse
//
//
class DCWbGraphicFilledEllipse : public DCWbGraphicEllipse
{

  public:
    //
    // Constructor
    //
    DCWbGraphicFilledEllipse(void) { }
    DCWbGraphicFilledEllipse(PWB_GRAPHIC pHeader)
      : DCWbGraphicEllipse(pHeader) { }
    DCWbGraphicFilledEllipse(WB_PAGE_HANDLE hPage,
                 WB_GRAPHIC_HANDLE hGraphic)
      : DCWbGraphicEllipse(hPage, hGraphic) { }

    ~DCWbGraphicFilledEllipse(void);

	UINT IsGraphicTool(void) { return enumGraphicFilledEllipse;}

    //
    // Draw the object
    //
    void Draw(HDC hDC);

	
	virtual BOOL CheckReallyHit(LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_FILLED_ELLIPSE; }
    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);
};

//
//
// Class:   DCWbGraphicText
//
// Purpose: Class representing a text object
//
//
class DCWbGraphicText : public DCWbGraphic
{

  // Friend declaration for text editing
  friend class WbTextEditor;

  // Friend declaration for copying to the clipboard
  friend class WbMainWindow;

  public:
    //
    // Constructors
    //
    DCWbGraphicText(void);
    DCWbGraphicText(PWB_GRAPHIC pHeader);
    DCWbGraphicText(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

    //
    // Destructor
    //
    ~DCWbGraphicText(void);

	UINT IsGraphicTool(void) { return enumGraphicText;}
    //
    // Set the text of the object
    //
    virtual void SetText(TCHAR * strText);
    virtual void SetText(const StrArray& strTextArray);

    //
    // Get/Set the font for drawing the text
    //
    virtual void SetFont(HFONT hFont);
    virtual void SetFont(LOGFONT *pLogFont, BOOL bReCalc=TRUE );
    virtual HFONT GetFont(void) {return m_hFont;};

    //
    // Draw - draw the object
    //
    void Draw(HDC hDC) { Draw(hDC, FALSE); };
    void Draw(HDC hDC, BOOL thumbNail);

    //
    // InvalidateMetrics - flag metrics need to be reread
    //
    void InvalidateMetrics(void);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
    void SetPenWidth(UINT) { };
    void SetROP(int) { };
    void SetPenStyle(int) { };
	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

    virtual void GetPosition(LPPOINT lppt); // added for bug 469

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_TEXT; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void ReadExtra(PWB_GRAPHIC pHeader);

    //
    // Calculate the rectangle of a portion of a single line of text
    //
    ABC GetTextABC( LPCTSTR strText,
                   int iStartX,
                   int iStopX);
    void GetTextRectangle(int iStartY,
                           int iStartX,
                           int iStopX,
                           LPRECT lprc);
    void CalculateRect(int iStartX,
                        int iStartY,
                        int iStopX,
                        int iStopY,
                        LPRECT lprc);

    //
    // Array for storing text
    //
    StrArray    strTextArray;

    //
    // Font details
    //
    HFONT       m_hFont;
    HFONT       m_hFontThumb;
	BOOL		m_bFirstSetFontCall;
	LONG		m_nKerningOffset; // added for bug 469

  public:
    TEXTMETRIC   m_textMetrics;
};


//
//
// Class:   DCWbGraphicDIB
//
// Purpose: Class representing a drawn DI bitmap object
//
//
typedef struct tagHOLD_DATA
{
  PWB_GRAPHIC        pHeader;
  LPBITMAPINFOHEADER lpbi;
} 
HOLD_DATA;

class DCWbGraphicDIB : public DCWbGraphic
{

  public:
    //
    // Constructors
    //
    DCWbGraphicDIB(void);
    DCWbGraphicDIB(PWB_GRAPHIC pHeader);
    DCWbGraphicDIB(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE _hGraphic);

    UINT IsGraphicTool(void) { return enumGraphicDIB; }

    //
    // Destructor
    //
    ~DCWbGraphicDIB(void);

    //
    // Set the contents of the bitmap
    //
    void SetImage(LPBITMAPINFOHEADER lpbi);

    //
    // Set the contents of the bitmap from the screen
    //
    void FromScreenArea(LPCRECT lprcScreen);

    //
    // Draw the object
    //
    void Draw(HDC hDC);

    //
    // Delete the image currently held internally (if any)
    //
    void DeleteImage(void);

    //
    // Override the base graphic object functions that are not appropriate
    // for this graphic type.  This prevents updates being made for changes
    // to pen attributes (for instance).
    //
    void SetPenWidth(UINT) { };
    void SetColor(COLORREF) { };
    void SetROP(int) { };
    void SetPenStyle(int) { };

	
	virtual BOOL CheckReallyHit( LPCRECT pRectHit );

  protected:
    //
    // Type of the graphic (used for writing to external memory)
    //
    virtual UINT Type(void) const { return TYPE_GRAPHIC_DIB; }

    //
    // Bounding rectangle calculation
    //
    void CalculateBoundsRect(void);

    //
    // Length of the external representation of the graphic
    //
    virtual DWORD CalculateExternalLength(void);

    //
    // Convert between internal and external representations
    //
    void WriteExtra(PWB_GRAPHIC pHeader);
    void CopyExtra(PWB_GRAPHIC pHeader);

    //
    // Get the DIB data
    //
    BOOL GetDIBData(HOLD_DATA& hold);
    void ReleaseDIBData(HOLD_DATA& hold);

    // Pointer to the DIB bits
    LPBITMAPINFOHEADER  m_lpbiImage;
};






class ObjectTrashCan : public DCWbGraphic
	{

public:
    ~ObjectTrashCan(void);

	UINT IsGraphicTool(void) {return enumNoGraphicTool;}

	BOOL GotTrash( void );
	void CollectTrash( DCWbGraphic *pGObj );
	void SelectTrash( void );
	void EmptyTrash( void );
	void BurnTrash( void );
    virtual void AddToPageLast(WB_PAGE_HANDLE hPage);

protected:
	COBLIST Trash;

	};


#endif // __GROBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\grptr.cpp ===
//
// GRPTR.CPP
// More Graphic Objects
//
// Copyright Microsoft 1998-
//

//
// The remote pointer is handled by blitting to and from the screen to a
// memory bitmap rather than letting Windows draw it.  This is to get a
// reasonably continuous tracking of the pointer.
//
// In order to do this we create a memory bitmap that is the pointer size
// times 2 by 3. The top left square of the 2*3 array is used to hold the
// screen contents before the pointer is written.  It may be used at any
// time to remove the pointer from the screen.  The lower 2*2 square is
// used to hold the currently displayed pointer plus surrounding screen
// bits.  The pointer may be anywhere within the 2*2 sector, as defined by
// "offset".
//
// ------------------
// |       |        |
// |       |        |
// | saved | unused |
// |       |        |
// |       |        |
// |----------------|
// |                |
// |   --------     |
// |   |      |     |
// |   | rem  |     |
// |   | ptr  |     |
// |   |      |     |
// |   |      |     |
// |   --------     |
// |                |
// ------------------
//
// Operations consist of
//
// If there is no pointer there currently then
//
// 1. Copy lower 2*2 segment from the screen
// 2. Save the remote pointer square to the saved area
// 3. Draw the icon into rem ptr square
// 4. Blit the 2*2 back to the screen
//
// If there is an old rem ptr and the new one lies within the same 2*2 area
// then as above but copy "saved" to "old rem ptr" before step 2 to remove
// it.
//
// If the new pointer lies off the old square then copy "saved" back to the
// display before proceeding as in the no pointer case.
//
//

// PRECOMP
#include "precomp.h"



//
// Runtime class information
//

//
// Local defines
//
#define DRAW   1
#define UNDRAW 2

//
//
// Function:    ~DCWbColorToIconMap
//
// Purpose:     Destructor
//
//
DCWbColorToIconMap::~DCWbColorToIconMap(void)
{
  // Delete all the objects in the user map and release the icon handles
  HICON    hIcon;

  POSITION position = GetHeadPosition();
  COLOREDICON * pColoredIcon;
  while (position)
  {
    pColoredIcon = (COLOREDICON *)GetNext(position);

    // Destroy the icon
    if (pColoredIcon != NULL)
    {
      ::DestroyIcon(pColoredIcon->hIcon);
      delete pColoredIcon;
    }
  }
  EmptyList();
}

//
//
// Function:    DCWbGraphicPointer::DCWbGraphicPointer
//
// Purpose:     Constructor for remote pointer objects
//
//
DCWbGraphicPointer::DCWbGraphicPointer(WbUser* _pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DCWbGraphicPointer");

    // We haven't yet created our mem DC
    m_hSaveBitmap = NULL;
    m_hOldBitmap = NULL;

    // Save the user pointer
    ASSERT(_pUser != NULL);
    m_pUser        = _pUser;

    // Set the bounding rectangle of the object
    m_uiIconWidth  = ::GetSystemMetrics(SM_CXICON);
    m_uiIconHeight = ::GetSystemMetrics(SM_CYICON);

    m_boundsRect.left = 0;
    m_boundsRect.top = 0;
    m_boundsRect.right = m_uiIconWidth;
    m_boundsRect.bottom = m_uiIconHeight;

    // Show that the object is not drawn
    m_bDrawn = FALSE;
    ::SetRectEmpty(&m_rectLastDrawn);

    // Show that we do not have an icon for drawing yet
    m_hIcon = NULL;

    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);
}

//
//
// Function:    DCWbGraphicPointer::~DCWbGraphicPointer
//
// Purpose:     Destructor for remote pointer objects
//
//
DCWbGraphicPointer::~DCWbGraphicPointer(void)
{
    // Restore the original bitmap to the memory DC
    if (m_hOldBitmap != NULL)
    {
        SelectBitmap(m_hMemDC, m_hOldBitmap);
        m_hOldBitmap = NULL;
    }

    if (m_hSaveBitmap != NULL)
    {
        DeleteBitmap(m_hSaveBitmap);
        m_hSaveBitmap = NULL;
    }

    if (m_hMemDC != NULL)
    {
        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    }

	if(g_pMain)
	{
		g_pMain->RemoveGraphicPointer(this);
	}

}

//
//
// Function:    Color
//
// Purpose:     Set the color of the pointer. An icon of the appropriate
//              color is created if necessary.
//
//
void DCWbGraphicPointer::SetColor(COLORREF newColor)
{
    newColor = SET_PALETTERGB( newColor ); // make it use color matching

    // If this is a color change
    if (m_clrPenColor != newColor)
    {

	COLOREDICON* pColoredIcon;
	POSITION position = g_pUsers->GetHeadPosition();
	BOOL found = FALSE;
	while (position && !found)
	{
		pColoredIcon = (COLOREDICON *)g_pIcons->GetNext(position);
	        if (newColor == pColoredIcon->color)
	        {
                	found = TRUE;
	        }
	}

	if(!found)
	{
	        m_hIcon = CreateColoredIcon(newColor);
	}

	// Set the color
	m_clrPenColor = newColor;
    }
}

//
//
// Function:    CreateSaveBitmap
//
// Purpose:     Create a bitmap for saving the bits under the pointer.
//
//
void DCWbGraphicPointer::CreateSaveBitmap(WbDrawingArea * pDrawingArea)
{
    HBITMAP hImage = NULL;
    HBITMAP hOld = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CreateSaveBitmap");

    // If we already have a save bitmap, exit immediately
    if (m_hSaveBitmap != NULL)
    {
        TRACE_MSG(("Already have save bitmap"));
        return;
    }

    // Load the pointer bitmap
    hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
    if (!hImage)
    {
        ERROR_OUT(("Could not load pointer bitmap"));
        goto CleanupSaveBitmap;
    }

    // Select the pointer bitmap into the memory DC. We do this to
    // allow creation of a compatible bitmap (otherwise we would get
    // a default monochrome format when calling CreateCompatibleBitmap).
    hOld = SelectBitmap(m_hMemDC, hImage);
    if (hOld == NULL)
    {
        ERROR_OUT(("Could not select bitmap into DC"));
        goto CleanupSaveBitmap;
    }

    // Create a bitmap to save the bits under the icon. This bitmap is
    // created with space for building the new screen image before
    // blitting it to the screen.
    m_hSaveBitmap = ::CreateCompatibleBitmap(m_hMemDC,
            2 * m_uiIconWidth  * pDrawingArea->ZoomOption(),
            3 * m_uiIconHeight * pDrawingArea->ZoomOption());
    if (!m_hSaveBitmap)
    {
        ERROR_OUT(("Could not create save bitmap"));
        goto CleanupSaveBitmap;
    }

    // Select in the save bits bitmap
    m_hOldBitmap = hOld;
    hOld = NULL;
    SelectBitmap(m_hMemDC, m_hSaveBitmap);

    // Default zoom factor is 1
    m_iZoomSaved = 1;

CleanupSaveBitmap:
    if (hOld != NULL)
    {
        // Put back the original bitmap--we failed to create the save bmp
        SelectBitmap(m_hMemDC, hOld);
    }

    if (hImage != NULL)
    {
        ::DeleteBitmap(hImage);
    }
}

//
//
// Function:    CreateColoredIcon
//
// Purpose:     Create an icon of the correct color for this pointer. The
//              DCWbGraphicPointer class keeps a static list of icons
//              created previously. These are re-used as necessary.
//
//
HICON DCWbGraphicPointer::CreateColoredIcon(COLORREF color)
{
    HICON       hColoredIcon = NULL;
    HBRUSH      hBrush = NULL;
    HBRUSH      hOldBrush;
    HBITMAP     hImage = NULL;
    HBITMAP     hOldBitmap;
    HBITMAP     hMask = NULL;
    COLOREDICON  *pColoredIcon;
    ICONINFO    ii;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CreateColoredIcon");

    hBrush = ::CreateSolidBrush(color);
    if (!hBrush)
    {
        TRACE_MSG(("Couldn't create color brush"));
        goto CreateIconCleanup;
    }

    // Load the mask bitmap
    hMask = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERANDMASK));
    if (!hMask)
    {
        TRACE_MSG(("Could not load mask bitmap"));
        goto CreateIconCleanup;
    }

    // Load the image bitmap
    hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
    if (!hImage)
    {
        TRACE_MSG(("Could not load pointer bitmap"));
        goto CreateIconCleanup;
    }

    // Select in the icon color
    hOldBrush = SelectBrush(m_hMemDC, hBrush);

    // Select the image bitmap into the memory DC
    hOldBitmap = SelectBitmap(m_hMemDC, hImage);

    // Fill the image bitmap with color
    ::FloodFill(m_hMemDC, m_uiIconWidth / 2, m_uiIconHeight / 2, RGB(0, 0, 0));

    SelectBitmap(m_hMemDC, hOldBitmap);
    
    SelectBrush(m_hMemDC, hOldBrush);

    //
    // Now use the image and mask bitmaps to create an icon
    //
    ii.fIcon = TRUE;
    ii.xHotspot = 0;
    ii.yHotspot = 0;
    ii.hbmMask = hMask;
    ii.hbmColor = hImage;

    // Create a new icon from the data and mask
    hColoredIcon = ::CreateIconIndirect(&ii);

    // Add the new icon to the static list
    ASSERT(g_pIcons);
	pColoredIcon = new COLOREDICON;
    if (!pColoredIcon)
    {
        ERROR_OUT(("Failed to allocate COLORICON object"));
        DestroyIcon(hColoredIcon);
        hColoredIcon = NULL;
    }
    else
    {
        pColoredIcon->color = color;
        pColoredIcon->hIcon = hColoredIcon;
        g_pIcons->AddTail(pColoredIcon);
    }

CreateIconCleanup:

    // Free the image bitmap
    if (hImage != NULL)
    {
        ::DeleteBitmap(hImage);
    }

    // Free the mask bitmap
    if (hMask != NULL)
    {
        ::DeleteBitmap(hMask);
    }

    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    return(hColoredIcon);
}

//
//
// Function:    GetPage
//
// Purpose:     Return the page of the pointer. An invalid page is returned
//              if the pointer is not active.
//
//
WB_PAGE_HANDLE DCWbGraphicPointer::GetPage(void) const
{
    // If this pointer is active, return its actual page
    if (m_bActive == TRUE)
        return(m_hPage);
    else
        return(WB_PAGE_HANDLE_NULL);
}


void DCWbGraphicPointer::SetPage(WB_PAGE_HANDLE hNewPage)
{
    m_hPage = hNewPage;
}

//
//
// Function:    DrawnRect
//
// Purpose:     Return the rectangle where the pointer was last drawn
//
//
void DCWbGraphicPointer::GetDrawnRect(LPRECT lprc)
{
    ::SetRectEmpty(lprc);

    if (m_bDrawn)
    {
        *lprc = m_rectLastDrawn;
    }
}

//
//
// Function:    IsLocalPointer
//
// Purpose:     Return TRUE if this is the local user's pointer
//
//
BOOL DCWbGraphicPointer::IsLocalPointer(void) const
{
    ASSERT(m_pUser != NULL);
    return m_pUser->IsLocalUser();
}

//
//
// Function:    operator==
//
// Purpose:     Return TRUE if the specified remote pointer is the same as
//              this one.
//
//
BOOL DCWbGraphicPointer::operator==(const DCWbGraphicPointer& pointer) const
{
    return (m_pUser == pointer.m_pUser);
}

//
//
// Function:    operator!=
//
// Purpose:     Return FALSE if the specified pointer is the same as this
//
//
BOOL DCWbGraphicPointer::operator!=(const DCWbGraphicPointer& pointer) const
{
  return (!((*this) == pointer));
}

//
//
// Function:    DCWbGraphicPointer::Draw
//
// Purpose:     Draw the pointer object without saving the bits under it
//
//
void DCWbGraphicPointer::Draw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Draw");

    rcUpdate = m_boundsRect;

    // Check that we have an icon to draw
    if (m_hIcon == NULL)
    {
        WARNING_OUT(("Icon not found"));
        return;
    }

    if (pDrawingArea == NULL)
    {
        ERROR_OUT(("No drawing area passed in"));
        return;
    }

    // Create the save bitmap if necessary
    CreateSaveBitmap(pDrawingArea);

    PointerDC(hDC, pDrawingArea, &rcUpdate, pDrawingArea->ZoomFactor());

    // Draw the icon to the DC passed
    ::DrawIcon(hDC, rcUpdate.left, rcUpdate.top, m_hIcon);

    SurfaceDC(hDC, pDrawingArea);

}

//
//
// Function:    DCWbGraphicPointer::DrawSave
//
// Purpose:     Draw the pointer object after saving the bits under it
//
//
void DCWbGraphicPointer::DrawSave(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DrawSave");

    // Pretend that we are not drawn
    m_bDrawn = FALSE;

    // Call the redraw member
    Redraw(hDC, pDrawingArea);
}

//
//
// Function:    DCWbGraphicPointer::Redraw
//
// Purpose:     Draw the pointer in its current position after erasing it
//              from the DC using the saved version.
//
//
void DCWbGraphicPointer::Redraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Redraw");

    RECT    clipBox;

    ::GetClipBox(hDC, &clipBox);

    // Create the save bitmap if necessary
    CreateSaveBitmap(pDrawingArea);

    // If we are not yet drawn, we must copy data from the screen
    // to initialize the save bitmaps.
    if (!m_bDrawn)
    {
        TRACE_MSG(("Pointer not yet drawn"));

        // Only do anything if the pointer will be visible
        if (::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
        {
            // Pretend that we were drawn at the same place and copy the screen
            // bits into memory to build the image.
            GetBoundsRect(&m_rectLastDrawn);
            CopyFromScreen(hDC, pDrawingArea);

            // Save the bits under the pointer
            SaveMemory();

            // Draw the pointer
            DrawMemory();

            // Copy the new image to the screen
            CopyToScreen(hDC, pDrawingArea);

            // Show that the pointer is now drawn
            m_bDrawn = TRUE;
        }
    }
    else
    {
        TRACE_MSG(("Pointer already drawn at %d %d",
            m_rectLastDrawn.left, m_rectLastDrawn.top));

        // Calculate the update rectangle
        RECT    rcUpdate;

        GetBoundsRect(&rcUpdate);
        ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

        // Check whether any of the update is visible
        if (::IntersectRect(&clipBox, &clipBox, &rcUpdate))
        {
            // Check whether we can do better by drawing in memory before
            // going to the screen.
            GetBoundsRect(&rcUpdate);
            if (::IntersectRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn))
            {
                TRACE_MSG(("Drawing in memory first"));

                // The old and new positions of the pointers overlap. We can
                // reduce flicker by building the new image in memory and
                // blitting to the screen.

                // Copy overlap rectangle to memory
                CopyFromScreen(hDC, pDrawingArea);

                // Undraw the pointer from the overlap rectangle
                UndrawMemory();

                // Save the bits under the new pointer position (from memory)
                SaveMemory();

                // Draw the new pointer into memory
                DrawMemory();

                // Copy the new image to the screen
                CopyToScreen(hDC, pDrawingArea);
            }
            else
            {
                TRACE_MSG(("No overlap - remove and redraw"));

                // The old and new pointer positions do not overlap. We can remove
                // the old pointer and draw the new in the usual way.

                // Copy the saved bits under the pointer to the screen
                UndrawScreen(hDC, pDrawingArea);

                // Pretend that we were drawn at the same place and copy the screen
                // bits into memory to build the image.
                GetBoundsRect(&m_rectLastDrawn);
                CopyFromScreen(hDC, pDrawingArea);

                // Save the bits under the pointer
                SaveMemory();

                // Draw the pointer
                DrawMemory();

                // Copy the new image to the screen
                CopyToScreen(hDC, pDrawingArea);
            }

            // Show that the pointer is now drawn
            m_bDrawn = TRUE;
        }
    }

    // If the pointer was drawn, save the rectangle in which it was drawn
    if (m_bDrawn)
    {
        GetBoundsRect(&m_rectLastDrawn);
    }
}

//
//
// Function:    DCWbGraphicPointer::Undraw
//
// Purpose:     Draw the marker object
//
//
void DCWbGraphicPointer::Undraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
    // If we are not drawn, do nothing
    if (m_bDrawn)
    {
        // Create the save bitmap if necessary
        CreateSaveBitmap(pDrawingArea);

        // Copy the saved bits onto the screen
        UndrawScreen(hDC, pDrawingArea);

        // Show that we are no longer drawn
        m_bDrawn = FALSE;
    }
}

//
//
// Function:    CopyFromScreen
//
// Purpose:     Save the bits around the old and new pointer positions
//              to memory.
//
//
BOOL DCWbGraphicPointer::CopyFromScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CopyFromScreen");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

    PointerDC(hDC, pDrawingArea, &rcUpdate, pDrawingArea->ZoomFactor());

    // Copy the bits
    bResult = ::BitBlt(m_hMemDC, 0,
                        m_uiIconHeight * m_iZoomSaved,
                        rcUpdate.right - rcUpdate.left,
                        rcUpdate.bottom - rcUpdate.top, 
                        hDC, rcUpdate.left, rcUpdate.top, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("CopyFromScreen - Could not copy to bitmap"));
    }

    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    CopyToScreen
//
// Purpose:     Copy the saved bits around the old and new pointers back
//              to the screen.
//
//
BOOL DCWbGraphicPointer::CopyToScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::CopyToScreen");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);

    PointerDC(hDC, pDrawingArea, &rcUpdate);

    bResult = ::BitBlt(hDC, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, m_uiIconHeight * m_iZoomSaved, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("CopyToScreen - Could not copy from bitmap"));
    }


    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    UndrawMemory
//
// Purpose:     Copy the saved bits under the pointer to the memory copy of
//              the screen, thus erasing the pointer from the image.
//
//
BOOL DCWbGraphicPointer::UndrawMemory()
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;
    SIZE    offset;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawMemory");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
    offset.cx = m_rectLastDrawn.left - rcUpdate.left;
    offset.cy = m_rectLastDrawn.top - rcUpdate.top;

    bResult = ::BitBlt(m_hMemDC, offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved,
                         m_hMemDC,
                         0,
                         0,
                         SRCCOPY);
  if (bResult == FALSE)
  {
      WARNING_OUT(("UndrawMemory - Could not copy from bitmap"));
  }
  TRACE_MSG(("Copied to memory %d,%d from memory %d,%d size %d,%d",
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         0,
                         0,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved));

  return(bResult);
}

//
//
// Function:    SaveMemory
//
// Purpose:     Copy the area of the memory image that will be under the
//              pointer to the save area.
//
//
BOOL DCWbGraphicPointer::SaveMemory(void)
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;
    SIZE    offset;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SaveMemory");

    // Get the update rectangle needed
    GetBoundsRect(&rcUpdate);
    ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
    offset.cx = m_boundsRect.left - rcUpdate.left;
    offset.cy = m_boundsRect.top - rcUpdate.top;

    bResult = ::BitBlt(m_hMemDC, 0,
                         0,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved,
                         m_hMemDC,
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         SRCCOPY);
    if (bResult == FALSE)
    {
        TRACE_MSG(("SaveMemory - Could not copy from bitmap"));
    }
    TRACE_MSG(("Copied to memory %d,%d from memory %d,%d size %d,%d",
                         0,
                         0,
                         offset.cx * m_iZoomSaved,
                         (m_uiIconHeight + offset.cy) * m_iZoomSaved,
                         m_uiIconWidth * m_iZoomSaved,
                         m_uiIconHeight * m_iZoomSaved));

  return(bResult);
}

//
//
// Function:    DrawMemory
//
// Purpose:     Draw the pointer onto the memory image copy.
//
//
BOOL DCWbGraphicPointer::DrawMemory(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::DrawMemory");

    BOOL bResult = FALSE;

    // Check that we have an icon to draw
    if (m_hIcon == NULL)
    {
        WARNING_OUT(("No icon to draw"));
    }
    else
    {
        RECT    rcUpdate;
        SIZE    offset;

        // Get the update rectangle needed
        GetBoundsRect(&rcUpdate);
        ::UnionRect(&rcUpdate, &rcUpdate, &m_rectLastDrawn);
        offset.cx = m_boundsRect.left - rcUpdate.left;
        offset.cy = m_boundsRect.top - rcUpdate.top;

        // Draw the icon to the DC passed
        bResult = ::DrawIcon(m_hMemDC, offset.cx * m_iZoomSaved,
                             (m_uiIconHeight + offset.cy) * m_iZoomSaved +
                             (m_uiIconHeight * (m_iZoomSaved - 1))/2,
                             m_hIcon);

    if (bResult == FALSE)
    {
      WARNING_OUT(("DrawMemory - Could not draw icon"));
    }
    TRACE_MSG(("Write pointer to memory at %d,%d",
                           offset.cx * m_iZoomSaved,
                           (m_uiIconHeight + offset.cy) * m_iZoomSaved +
                           (m_uiIconHeight * (m_iZoomSaved - 1))/2));
  }

  return(bResult);
}

//
//
// Function:    UndrawScreen
//
// Purpose:     Copy the saved bits under the pointer to the screen.
//
//
BOOL DCWbGraphicPointer::UndrawScreen(HDC hDC, WbDrawingArea * pDrawingArea)
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawScreen");

    rcUpdate = m_rectLastDrawn;

    PointerDC(hDC, pDrawingArea, &rcUpdate);

    // We are undrawing - copy the saved bits to the DC passed
    bResult = ::BitBlt(hDC, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, 0, SRCCOPY);
    if (!bResult)
    {
        WARNING_OUT(("UndrawScreen - Could not copy from bitmap"));
    }

    SurfaceDC(hDC, pDrawingArea);

    return(bResult);
}

//
//
// Function:    Update
//
// Purpose:     Update the pointer information stored in the user
//              information.
//
//
void DCWbGraphicPointer::Update(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::Update");

    // Only do the update if we have been changed
    if (m_bChanged)
    {
        // Make the update (the pointer information is held in the associated
        // user object)
        ASSERT(m_pUser != NULL);
        m_pUser->Update();

        // Show that we have not changed since the last update
        m_bChanged = FALSE;
    }
}

//
//
// Function:    SetActive
//
// Purpose:     Update the pointer information to show that the pointer
//              is now active.
//
//
void DCWbGraphicPointer::SetActive(WB_PAGE_HANDLE hPage, POINT point)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SetActive");

    // Set the member variables
    MoveTo(point.x, point.y);
    m_hPage  = hPage;
    m_bActive = TRUE;
    m_bChanged = TRUE;

    // Distribute the update
    Update();
}

//
//
// Function:    SetInactive
//
// Purpose:     Update the pointer information to show that the pointer
//              is no longer active.
//
//
void DCWbGraphicPointer::SetInactive(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SetInactive");

  // Set the member variables
  m_bActive = FALSE;
    m_bChanged = TRUE;

  // Distribute the update
  Update();
}

//
//
// Function:    PointerDC
//
// Purpose:     Scale the DC to 1:1, set a zero origin and convert the
//              supplied rectangle into window coordinates.  This is because
//              we have to do the zoom mapping ourselves when we are doing
//              remote pointer blitting, otherwise the system does
//              stretchblits and screws up.  Note that the SurfaceToClient
//              function gives us a client rectangle (ie it is 3 * as big
//              when we are zoomed)
//
//
void DCWbGraphicPointer::PointerDC
(
    HDC         hDC,
    WbDrawingArea * pDrawingArea,
    LPRECT      lprc,
    int         zoom
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::PointerDC");

    // default zoom to be the saved value
    if (zoom == 0)
    {
        zoom = m_iZoomSaved;
    }
    else
    {
        m_iZoomSaved = zoom;
    }

    // If we are currently zoomed then do the scaling
    if (zoom != 1)
    {
        ::ScaleViewportExtEx(hDC, 1, zoom, 1, zoom, NULL);
        TRACE_MSG(("Scaled screen viewport down by %d", zoom));

        pDrawingArea->SurfaceToClient(lprc);
        ::SetWindowOrgEx(hDC, 0, 0, NULL);
    }
}

//
//
// Function:    SurfaceDC
//
// Purpose:     Scale the DC back to the correct zoom factor and reset the
//              origin to the surface offset
//
//
void DCWbGraphicPointer::SurfaceDC(HDC hDC, WbDrawingArea * pDrawingArea)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::SurfaceDC");

    if (m_iZoomSaved != 1)
    {
        POINT   pt;

        ::ScaleViewportExtEx(hDC, m_iZoomSaved, 1, m_iZoomSaved, 1, NULL);
        TRACE_MSG(("Scaled screen viewport up by %d", m_iZoomSaved));

        pDrawingArea->GetOrigin(&pt);
        ::SetWindowOrgEx(hDC, pt.x, pt.y, NULL);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\grptr.hpp ===
//
// GRPTR.HPP
// Graphic Pointer Class
//
// Copyright Microsoft 1998-
//

#ifndef __GRPTR_HPP_
#define __GRPTR_HPP_

typedef struct COLOREDICON
{
	HICON    hIcon;
 	COLORREF color;
} COLORED_ICON;


//
//
// Class:   DCWbGraphicPointer
//
// Purpose: Class representing a remote pointer.
//
//          This is an internal object only  - it is never passed to the
//          Whiteboard Core DLL.
//
//
class DCWbGraphicPointer : public DCWbGraphic
{
friend class WbUser;

public:
    //
    // Constructors
    //
    DCWbGraphicPointer(WbUser* _pUser);

    //
    // Destructor
    //
    ~DCWbGraphicPointer(void);

	UINT IsGraphicTool(void) { return enumGraphicPointer;}


    //
    // Return the rectangle in which the pointer was last drawn. The
    // rectangle will be empty if the pointer is not currently drawn. Use
    // BoundsRect to get the rectangle which will be occupied by the pointer
    // when it is next drawn.
    //
    void GetDrawnRect(LPRECT lprc);

    //
    // Activate and deactivate the pointer
    //
    BOOL IsActive(void) const { return m_bActive; }
    void SetActive(WB_PAGE_HANDLE hPage, POINT point);
    void SetInactive(void);

    //
    // Set the color of the pointer
    //
    void SetColor(COLORREF newColor);

    //
    // Get and set the current page of the pointer
    //
    WB_PAGE_HANDLE GetPage(void) const;
    void     SetPage(WB_PAGE_HANDLE hNewPage);
    WbUser * GetUser(void) const { return(m_pUser); }

    //
    // Return TRUE if this is the local user's pointer
    //
    BOOL IsLocalPointer(void) const;

    //
    // Draw the pointer
    //
    void Draw(HDC hDC) { Draw(hDC, (WbDrawingArea *)NULL); }
    void Draw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Draw the pointer after saving the bits under it to memory
    //
    void DrawSave(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Erase the pointer from its old position and redraw it in its current
    // position.
    //
    void Redraw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Undraw the pointer
    //
    void Undraw(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // Update the user information with the pointer position
    //
    virtual void Update(void);

    //
    // Operators
    //
    virtual BOOL operator!=(const DCWbGraphicPointer& pointer) const;
    virtual BOOL operator==(const DCWbGraphicPointer& pointer) const;

  protected:
    //
    // Zoom factor set from WBDRAW
    //
    int m_iZoomSaved;

    //
    // Create the icon of the correct color for this user
    //
    HICON CreateColoredIcon(COLORREF color);

    //
    // Create the bitmap for saving the screen data under the pointer
    //
    void CreateSaveBitmap(WbDrawingArea * pDrawingArea);

    //
    // Draw or undraw the pointer (screen and memory versions)
    //
    BOOL SaveScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL UndrawScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL CopyFromScreen(HDC hDC, WbDrawingArea * pDrawingArea);
    BOOL CopyToScreen(HDC hDC, WbDrawingArea * pDrawingArea);

    BOOL DrawMemory(void);
    BOOL UndrawMemory(void);
    BOOL SaveMemory(void);

    //
    // Manipulate the display DC for pointer operations
    //
    void PointerDC(HDC hDC, WbDrawingArea * pDrawingArea,
                   LPRECT lprc, int zoom = 0);
    void SurfaceDC(HDC hDC, WbDrawingArea * pDrawingArea);

    //
    // The user associated with this pointer
    //
    WbUser*     m_pUser;

    //
    // Flag indicating whether the pointer is active
    //
    BOOL        m_bActive;

    //
    // Pointer to the bitmap used to save the data under the pointer
    //
    HBITMAP     m_hSaveBitmap;

    //
    // Handle of bitmap originally supplied with memDC
    //
    HBITMAP     m_hOldBitmap;

    //
    // Device context used for drawing and undrawing the pointer
    //
    HDC         m_hMemDC;

    //
    // Handle of icon to be used for drawing
    //
    HICON       m_hIcon;

    //
    // Width and height of the pointer
    //
    UINT        m_uiIconWidth;
    UINT        m_uiIconHeight;

    //
    // Flag indicating whether the pointer is drawn
    //
    BOOL        m_bDrawn;

    //
    // Rectangle in which the pointer was last drawn
    //
    RECT        m_rectLastDrawn;
};


#endif // __GRPTR_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\draw.hpp ===
//
// DRAW.HPP
// Drawing Code
//
// Copyright Microsoft 1998-
//


#ifndef __DRAW_HPP_
#define __DRAW_HPP_


//
// Timer for periodic update of some graphic objects
//
#define TIMER_GRAPHIC_UPDATE  2

#define EqualPoint(pt1, pt2)    (((pt1).x == (pt2).x) && ((pt1).y == (pt2).y))


#define DRAW_WIDTH                      1024
#define DRAW_HEIGHT                     768
#define DRAW_LINEVSCROLL                8				
#define DRAW_LINEHSCROLL                8				
#define DRAW_HANDLESIZE                 6				
#define DRAW_ZOOMFACTOR                 2
#define DRAW_REMOTEPOINTERDELAY         250
#define DRAW_GRAPHICUPDATEDELAY         1000

//
//
// Class:   WbDrawingArea
//
// Purpose: drawing window
//
//
class WbDrawingArea
{

  friend class DCWbGraphic;
  friend class DCWbGraphicLine;
  friend class DCWbGraphicFreehand;
  friend class DCWbGraphicRectangle;
  friend class DCWbGraphicFilledRectangle;
  friend class DCWbGraphicEllipse;
  friend class DCWbGraphicFilledEllipse;
  friend class DCWbGraphicSelectTrackingRectangle;
  friend class DCWbGraphicMarker;
  friend class DCWbGraphicText;
  friend class DCWbGraphicDIB;
  friend class WbTextBox;

public:
    //
    // Constructor
    //
    WbDrawingArea(void);
    ~WbDrawingArea(void);

	void ShutDownDC(void);
  
    //
    // Create the drawing area
    //
    BOOL Create(HWND hwndParent, LPCRECT lprect);

    //
    // Return TRUE if the drawing area is busy and may be actively using
    // graphic objects in the current page.
    //
    BOOL IsBusy(void) { return m_bBusy; }

    //
    // Lock and unlock the drawing area
    //
    BOOL IsLocked (void) { return m_bLocked; }
    void Unlock   (void);
    void Lock     (void);

    //
    // Realize the drawing area's palette
    //
    void RealizePalette( BOOL bBackground );//CHANGED BY RAND

    //
    // Selection functions
    //
    void SelectTool(WbTool* pToolNew);  // Select drawing tool

    //
    // Update the selected object
    //
    void SetSelectionColor (COLORREF clr);         // Change color
    void SetSelectionWidth (UINT uiNewWidth);  // Select pen width
    void SetSelectionFont  (HFONT hFont);       // Select font

    //
    // External update functions
    //
    void PageCleared(void);

    void GraphicAdded   (DCWbGraphic* pAddedGraphic);
    void GraphicDeleted (DCWbGraphic* pDeletedGraphic);

	//CHANGED BY RAND
    void GraphicUpdated (DCWbGraphic* pUpdatedGraphic, BOOL bUpdateMarker, BOOL bErase=TRUE );

    void PointerUpdated (DCWbGraphicPointer* pPointer,
                           BOOL bForcedRemove = FALSE);
    void PointerRemoved (DCWbGraphicPointer* pPointer) { PointerUpdated(pPointer, TRUE); }

	void RemoveGraphicPointer(DCWbGraphicPointer *p)
	{
        POSITION pos = m_allPointers.Lookup(p);
        if (pos != NULL)
        {
            m_allPointers.RemoveAt(pos);
        }
	}

    //
    // Query functions
    //
    // Ask whether an object is currently selected
    BOOL GraphicSelected(void);

    // Return the currently selected graphic
    DCWbGraphic* GetSelection(void);

	// Clear current (multi object) selection
	void ClearSelection( void );

	// is pGraphic selected?
    BOOL IsSelected( DCWbGraphic *pGraphic )
		{return(m_pMarker->HasAMarker( pGraphic ) != NULL );}

	DCWbGraphic *GetHitObject( POINT surfacePos )
		{return( PG_SelectLast(m_hPage, surfacePos) );}


    // Ask whether the drawing area is zoomed
    BOOL Zoomed(void) { return (m_iZoomFactor != 1); }

    // Ask whether the drawing area is zoomed
    int ZoomOption(void) { return (m_iZoomOption); }
    int ZoomFactor(void) { return (m_iZoomFactor); }

    // Ask whether the text editor is active
    BOOL TextEditActive(void) { return m_bTextEditorActive; }

	// text editor clipboard
	void   TextEditCopy( void )	{m_textEditor.Copy();}

	void   TextEditCut( void ) 	{m_textEditor.Cut();}

	void   TextEditPaste( void ) {m_textEditor.Paste();}

	// Resets text editor for window resizing
	void TextEditParentResize( void )
		{m_textEditor.ParentResize();}

	// Redraws editbox
	void RedrawTextEditbox(void)
		{m_textEditor.RedrawEditbox();}

	// Gets editbox bounding rect
	void GetTextEditBoundsRect(LPRECT lprc)
		{ m_textEditor.GetBoundsRect(lprc); }

    // Return the rectangle currently being viewed i.e. that portion of
    // the page surface that is within the window client area.
    void    GetVisibleRect(LPRECT lprc);

    // Ask for the current page
    WB_PAGE_HANDLE Page(void) { return(m_hPage);}

	
	// Select objects inside rectSelect or ALL if rect is NULL
	void SelectMarkerFromRect(LPCRECT lprcSelect);
    DCWbGraphicMarker *GetMarker( void )
		{return( m_pMarker );}

    DCWbGraphic* SelectPreviousGraphicAt(DCWbGraphic* pGraphic, POINT point);

	void SetLClickIgnore( BOOL bIgnore )
		{m_bIgnoreNextLClick = bIgnore;}

    //
    // Delete a graphic
    //
    void DeleteGraphic(DCWbGraphic* pGraphic);

    //
    // Action members
    //
    void  Attach(WB_PAGE_HANDLE hPage);    // Attach a new page to the window
    void  Detach(void) { Attach(NULL); }   // Attach the empty page

    void  DeleteSelection(void);           // Delete selected graphic

    void  BringToTopSelection(void);       // Bring selected graphic to top
    void  SendToBackSelection(void);       // Send selected graphic to back

    void  Clear(void);                     // Clear the workspace

    void  Zoom(void);                      // Zoom the drawing area

    void GotoPosition(int x, int y); // Set scroll position

	// select an object
    void SelectGraphic(DCWbGraphic* pGraphic, 
						 BOOL bEnableForceAdd=FALSE, //CHANGED BY RAND
						 BOOL bForceAdd=FALSE );	 //CHANGED BY RAND

    //
    // A freehand graphic has been updated - redraw it
    //
    void GraphicFreehandUpdated(DCWbGraphic* pGraphic);

    //
    // Convert between surface and client co-ordinates
    //
    void SurfaceToClient(LPPOINT lppt);
    void ClientToSurface(LPPOINT lppt);
    void SurfaceToClient(LPRECT lprc);
    void ClientToSurface(LPRECT lprc);
    void MoveOntoSurface(LPPOINT lppt);
    void GetOrigin(LPPOINT lppt);

    HDC  GetCachedDC  (void) const {return(m_hDCCached); }
    void PrimeFont   (HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics);
    void UnPrimeFont (HDC hDC);

    void DrawMarker   (HDC hDC);
    void PutMarker    (HDC hDC, BOOL bDraw = TRUE );
    void RemoveMarker (HDC hDC);

    //
    // Cancel a drawing operation.
    //
    void CancelDrawingMode(void);


	void SetStartPaintGraphic( WB_GRAPHIC_HANDLE hStartPaintGraphic )
		{m_hStartPaintGraphic = PG_ZGreaterGraphic(m_hPage, m_hStartPaintGraphic, hStartPaintGraphic );}


    friend LRESULT CALLBACK DrawWndProc(HWND, UINT, WPARAM, LPARAM);

    //
    // Windows message handling
    //
    void OnPaint(void);
    void OnMouseMove(UINT flags, int x, int y);
    void OnLButtonDown(UINT flags, int x, int y);
    void OnLButtonUp(UINT flags, int x, int y);
    void OnRButtonDown(UINT flags, int x, int y);
    void OnSize(UINT flags, int cx, int cy);
    void OnHScroll(UINT code, UINT pos);
    void OnVScroll(UINT code, UINT pos);
    LRESULT OnEditColor(HDC hdc);
    void OnSetFocus(void);
    void OnActivate(UINT flags);
    LRESULT OnCursor(HWND hwnd, UINT hitTest, UINT msg);
    void OnTimer(UINT idTimer);
    void OnCancelMode(void);
    void OnContextMenu(int xScreen, int yScreen);

protected:
    //
    // Update the window after an object has changed
    //
    void UpdateRectangles(LPCRECT lprc1, LPCRECT lprc2, BOOL bRepaint);

    //
    // Set the cursor to be used in the drawing area for the current state
    //
    BOOL SetCursorForState(void);

    //
    // Add an object to the end of the recorded list and display it in the
    // window.
    //
    void AddObjectLast(DCWbGraphic* pObject);

    //
    // Invalidate the client area rectangle corresponding to the surface
    // rectangle specified.
    //
    void InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase = TRUE);

    //
    // Setup functions for the various drawing operations
    //
    BOOL RemotePointerSelect (POINT mousePos);
    void BeginSelectMode     (POINT mousePos, 
									BOOL bDontDrag=FALSE );
    void BeginDeleteMode     (POINT mousePos);
    void BeginTextMode       (POINT mousePos);
    void BeginFreehandMode   (POINT mousePos);
    void BeginHighlightMode  (POINT mousePos);
    void BeginLineMode       (POINT mousePos);
    void BeginRectangleMode  (POINT mousePos);
    void BeginEllipseMode    (POINT mousePos);

    //
    // Mouse tracking functions. These are called for each mouse move event
    // (depending on the current drawing mode).
    //
    void TrackSelectMode    (POINT mousePos);
    void TrackDeleteMode    (POINT mousePos);
    void TrackFreehandMode  (POINT mousePos);
    void TrackHighlightMode (POINT mousePos);
    void TrackLineMode      (POINT mousePos);
    void TrackRectangleMode (POINT mousePos);
    void TrackEllipseMode   (POINT mousePos);

    //
    // Completion functions for the various mode drawing operations.
    //
    void CompleteSelectMode();
    void CompleteDeleteMode();
    void CompleteMarkAreaMode();
    void CompleteTextMode();
    void CompleteFreehandMode();
    void CompleteLineMode();
    void CompleteRectangleMode();
    void CompleteFilledRectangleMode();
    void CompleteEllipseMode();
    void CompleteFilledEllipseMode();

    //
    // Complete a text object
    //
    void EndTextEntry(BOOL bAccept);

    //
    // Scroll the workspace to scrollPosition
    //
    void ScrollWorkspace   (void);
    void DoScrollWorkspace (void);
    BOOL   AutoScroll(int xPos, int yPos, BOOL bMoveCursor, int xCaret, int yCaret);

    //
    // Graphic object selection and marker manipulation
    //
    void DeselectGraphic(void);

    //
    // Remote pointer manipulation
    //
    void RemovePointers(HDC hDC, DCWbGraphicPointer* pPointerStart = NULL);
    void RemovePointers(HDC hDC, LPCRECT prcUpdate);
    void RemovePointers(HDC hDC, DCWbGraphicPointer* pPointerStart,
                          LPCRECT prcUpdate);

    //
    // Redraw the pointers in the list specified. The pointers are drawn
    // from the start of the list to the end. If a NULL pointer is
    // specified, the undrawnPointers list is used.
    //
    void PutPointers(HDC hDC, COBLIST* pDrawList = NULL);

    void PrimeDC   (HDC hDC);
    void UnPrimeDC (HDC hDC);

    //
    // List of pointers on the page
    // List of pointers that have been (temporarily undrawn). This list is
    // built by RemovePointers for use by PutPointers.
    //
    COBLIST     m_allPointers;
    COBLIST     m_undrawnPointers;

    //
    // Flag indicating that the drawing area is busy or locked
    //
    BOOL        m_bBusy;
    BOOL        m_bLocked;
	BOOL        m_HourGlass; // we're busy doing something local

    //
    // Saved drawing attributes
    //
    HPEN        m_hOldPen;
    HBRUSH      m_hOldBrush;
    HPALETTE    m_hOldPalette;
    HFONT       m_hOldFont;
    HFONT       m_hCurFont;

    //
    // Current offset of the client region of the window onto the picture
    //
    RECT        m_rcSurface;

public:
    SIZE        m_originOffset;
    HWND        m_hwnd;

    //
    // Saved drawing attributes
    //
    HDC         m_hDCCached;
    HDC         m_hDCWindow;

protected:
    //
    // Scrolling control
    //
    void   SetScrollRange(int cx, int cy);
    void   ValidateScrollPos(void);

    POINT   m_posScroll;
    POINT   m_posZoomScroll;
    BOOL    m_zoomRestoreScroll;

    //
    // Start and end points of most recent drawing operation
    //
    POINT   m_ptStart;
    POINT   m_ptEnd;

    //
    // Current drawing tool
    //
    WbTool * m_pToolCur;

    //
    // Mouse button down flag
    //
    BOOL    m_bLButtonDown;

    //
    // Current page being used
    //
    WB_PAGE_HANDLE  m_hPage;

    //
    // Graphics object pointer used for tracking object
    //
    DCWbGraphic* m_pGraphicTracker;

    //
    // Tick count used to determine when it is time to update the external
    // copy of a graphic.
    //
    DWORD   m_dwTickCount;

    //
    // Marker for selection mode
    //
    DCWbGraphicMarker   *m_pMarker;
    DCWbGraphic* m_pSelectedGraphic;
    BOOL m_bMarkerPresent;
    BOOL m_bNewMarkedGraphic;

	BOOL m_bTrackingSelectRect; 

    //
    // Text editor control
    //
    WbTextEditor m_textEditor;
    BOOL        m_bTextEditorActive;
    DCWbGraphicText* m_pActiveText;

    void ActivateTextEditor( BOOL bPutUpCusor ); 
    void DeactivateTextEditor(void);

    //
    // Text cursor control
    //
    BOOL        m_bGotCaret;

    //
    // Currently marked area
    //
    RECT    m_rcMarkedArea;

    //
    // Zoom variables
    //
    int     m_iZoomFactor;                   // Current zoom factor
    int     m_iZoomOption;                   // Zoom factor to be used


    HCURSOR m_hCursor;                    // handle of last cursor we displayed
                                        // (or null if normal arrow cursor)
	BOOL    m_bIgnoreNextLClick;

	WB_GRAPHIC_HANDLE m_hStartPaintGraphic;
};


#endif // __DRAW_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\main.cpp ===
//
// MAIN.CPP
// Whiteboard Windows App Code
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"


WbMainWindow *  g_pMain;
HINSTANCE       g_hInstance;
IWbClient*      g_pwbCore;
UINT            g_uConfShutdown;
WbPrinter *     g_pPrinter;

BOOL            g_bPalettesInitialized;
BOOL            g_bUsePalettes;
HPALETTE        g_hRainbowPaletteDisplay;

HINSTANCE       g_hImmLib;
IGC_PROC        g_fnImmGetContext;
INI_PROC        g_fnImmNotifyIME;

//
// Arrays
//
COLORREF    g_ColorTable[NUM_COLOR_ENTRIES] =
{
    RGB(  0, 255, 255),                   // Cyan
    RGB(255, 255,   0),                   // Yellow
    RGB(255,   0, 255),                   // Magenta
    RGB(  0,   0, 255),                   // Blue
    RGB(192, 192, 192),                   // Grey
    RGB(255,   0,   0),                   // Red
    RGB(  0,   0, 128),                   // Dark blue
    RGB(  0, 128, 128),                   // Dark cyan
    RGB(  0, 255,   0),                   // Green
    RGB(  0, 128,   0),                   // Dark green
    RGB(128,   0,   0),                   // Dark red
    RGB(128,   0, 128),                   // Purple
    RGB(128, 128,   0),                   // Olive
    RGB(128, 128, 128),                   // Grey
    RGB(255, 255, 255),                   // White
    RGB(  0,   0,   0),                   // Black
    RGB(255, 128,   0),                   // Orange
    RGB(128, 255, 255),                   // Turquoise
    RGB(  0, 128, 255),                   // Mid blue
    RGB(  0, 255, 128),                   // Pale green
    RGB(255,   0, 128)                    // Dark pink
};


int g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS] =
{
    0,                   // CLIPBOARD_PRIVATE_SINGLE_OBJ - Reserved for the
					   //	Whiteboard private format
    0,
    CF_DIB,              // Standard formats
    CF_ENHMETAFILE,	   // move metafiles to lower pri than bitmaps (bug NM4db:411)
    CF_TEXT
};



// Default widths for all tools except for highlighters
UINT g_PenWidths[NUM_OF_WIDTHS] = { 2, 4, 8, 16 };

// Default widths for highlight tools
UINT g_HighlightWidths[NUM_OF_WIDTHS] = { 4, 8, 16, 32 };

//
// Objects
//
WbUserList *            g_pUsers;
WbDrawingArea *         g_pDraw;
DCWbColorToIconMap *    g_pIcons;

#ifdef _DEBUG
HDBGZONE    ghZoneWb;

PTCHAR      g_rgZonesWb[] = // CHECK ZONE_WBxxx CONSTANTS IF THESE CHANGE
{
    "OldWB",
    DEFAULT_ZONES
	"DEBUG",
	"MSG",
	"TIMER",
	"EVENT"
};
#endif // _DEBUG

///////////////////////////////////////////////////////////////////////////


/*  D L L  M A I N  */
/*-------------------------------------------------------------------------
    %%Function: DllMain
    
-------------------------------------------------------------------------*/
BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &g_rgZonesWb[0],
            (sizeof(g_rgZonesWb) / sizeof(g_rgZonesWb[0])) - 1);
#endif
	    	g_hInstance = hDllInst;
    		DisableThreadLibraryCalls(g_hInstance);

            DBG_INIT_MEMORY_TRACKING(hDllInst);
		    break;
	    }

    	case DLL_PROCESS_DETACH:
        {
            g_hInstance = NULL;

            DBG_CHECK_MEMORY_TRACKING(hDllInst);
#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif
    		break;
        }

        default:
		    break;
	}

	return TRUE;
}



//
// Whiteboard's init routine
//
BOOL WINAPI InitWB(void)
{
    BOOL    fInited = FALSE;

    ASSERT(!g_pMain);
    ASSERT(!g_hImmLib);
    ASSERT(!g_fnImmGetContext);
    ASSERT(!g_fnImmNotifyIME);

    //
    // Load IMM32 if this is FE
    //
    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        g_hImmLib = NmLoadLibrary("imm32.dll",TRUE);
        if (!g_hImmLib)
        {
            ERROR_OUT(("Failed to load imm32.dll"));
        }
        else
        {
            g_fnImmGetContext = (IGC_PROC)GetProcAddress(g_hImmLib, "ImmGetContext");
            if (!g_fnImmGetContext)
            {
                ERROR_OUT(("Failed to get ImmGetContext pointer"));
            }
            g_fnImmNotifyIME = (INI_PROC)GetProcAddress(g_hImmLib, "ImmNotifyIME");
            if (!g_fnImmNotifyIME)
            {
                ERROR_OUT(("Failed to get ImmNotifyIME pointer"));
            }
        }
    }

    g_pMain = new WbMainWindow();
    if (!g_pMain)
    {
        ERROR_OUT(("Can't create WbMainWindow"));
        goto Done;
    }

    //
    // OK, now we're ready to create our HWND
    //
    if (!g_pMain->Open(SW_SHOWDEFAULT))
    {
        ERROR_OUT(("Can't create WB windows"));
        goto Done;
    }

    fInited = TRUE;

Done:
    return(fInited);
}



//
// Whiteboard's term routine
//
void WINAPI TermWB(void)
{
    if (g_pMain != NULL)
    {
        delete g_pMain;
        g_pMain = NULL;
    }

    g_fnImmNotifyIME = NULL;
    g_fnImmGetContext = NULL;

    if (g_hImmLib)
    {
        FreeLibrary(g_hImmLib);
        g_hImmLib = NULL;
    }
}


//
// Whiteboard's thread handler
//
void WINAPI RunWB(void)
{
    ASSERT(g_pMain != NULL);

    //
    // Try to join call
    //
    //
    // Find out if we're in a call and join if so.
    //
    if (!g_pMain->JoinDomain())
    {
        ERROR_OUT(("WB couldn't start up and join call"));
        return;
    }

    //
    // MESSAGE LOOP
    //
    MSG     msg;

    while (::GetMessage(&msg, NULL, NULL, NULL))
    {
        if (!g_pMain->FilterMessage(&msg))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }
}




//
// Mapping of internal return codes to string resources                     
//
typedef struct tagERROR_MAP
{
    UINT uiFEReturnCode;
    UINT uiDCGReturnCode;
    UINT uiCaption;
    UINT uiMessage;
}
ERROR_MAP;


ERROR_MAP g_ErrorStringID[] =
{
  { WBFE_RC_JOIN_CALL_FAILED,           // Registration failed
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_JOIN_CALL_FAILED
  },

  { WBFE_RC_WINDOWS,                    // A windows error has occurred
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_WINDOWS_RESOURCES
  },

  { WBFE_RC_WB,                         // Page limit exceeded
    WB_RC_TOO_MANY_PAGES,
    IDS_MSG_CAPTION,
    IDS_MSG_TOO_MANY_PAGES
  },

  { WBFE_RC_WB,          // Another user has the contents lock
    WB_RC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_LOCKED
  },

  { WBFE_RC_WB,          // Another user has the graphic locked
    WB_RC_GRAPHIC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_GRAPHIC_LOCKED,
  },

  { WBFE_RC_WB,          // The local user does not have the lock
    WB_RC_NOT_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_NOT_LOCKED
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_FILE_FORMAT,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_FILE_FORMAT
  },

  { WBFE_RC_WB,          // Whiteboard busy (exhausted page cache)
    WB_RC_BUSY,
    IDS_MSG_CAPTION,
    IDS_MSG_BUSY
  },

  { WBFE_RC_CM,          // Failed to access call manager
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_CM_ERROR
  },

  { WBFE_RC_AL,          // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_AL_ERROR
  },

  { WBFE_RC_PRINTER,     // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_PRINTER_ERROR
  },

  { 0,                   // Catch-all default
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_DEFAULT
  }
};




//
//                                                                          
// Function:    Message                                                     
//                                                                          
// Purpose:     Display an error message box with string resources specified
//              as parameters, with the WB main window as the modal window. 
//                                                                          
//
int Message
(
    HWND    hwnd,
    UINT    uiCaption,
    UINT    uiMessage,
    UINT    uiStyle
)
{
    TCHAR   message[256];
    TCHAR   caption[256];

	//make sure we're on top
    ASSERT(g_pMain);
    if (!hwnd)
        hwnd = g_pMain->m_hwnd;

    if (hwnd != NULL)
    {
		::SetForegroundWindow(hwnd);
    }

    LoadString(g_hInstance, uiMessage, message, 256);

    LoadString(g_hInstance, uiCaption, caption, 256);

    //
    // BOGUS LAURABU:
    // Make use of MessageBoxEx() and just pass the string IDs along, 
    // rather than doing the LoadString() ourself.
    //

    // Display a message box with the relevant text
	return(::MessageBox(hwnd, message, caption, uiStyle));
}



//
//                                                                          
// Function:    ErrorMessage                                                
//                                                                          
// Purpose:     Display an error based on return codes from Whiteboard      
//              processing.                                                 
//                                                                          
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "::ErrorMessage (codes)");

    TRACE_MSG(("FE return code  = %hd", uiFEReturnCode));
    TRACE_MSG(("DCG return code = %hd", uiDCGReturnCode));

    // check for special OM_RC_OBJECT_DELETED case
    if (uiDCGReturnCode == OM_RC_OBJECT_DELETED)
    {
        // don't complain, just cancel drawing
        g_pMain->m_drawingArea.CancelDrawingMode();
        return;
    }

    // Find the associated string resource IDS
    int iIndex;

    for (iIndex = 0; ; iIndex++)
    {
        // If we have come to the end of the list, stop
        if (g_ErrorStringID[iIndex].uiFEReturnCode == 0)
        {
            break;
        }

        // Check for a match
        if (g_ErrorStringID[iIndex].uiFEReturnCode == uiFEReturnCode)
        {
            if (   (g_ErrorStringID[iIndex].uiDCGReturnCode == uiDCGReturnCode)
                || (g_ErrorStringID[iIndex].uiDCGReturnCode == 0))
            {
                break;
            }
        }
    }

    // Display the message
    Message(NULL, g_ErrorStringID[iIndex].uiCaption, g_ErrorStringID[iIndex].uiMessage);
}



//
//                                                                          
// Function:    DefaultExceptionHandler                                     
//                                                                          
// Purpose:     Default exception processing. This can be called in an      
//              exception handler to get a message relevant to the          
//              exception. The message is generated by posting a message to 
//              the applications main window.                               
//                                                                          
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DefaultExceptionHandler");

    // Post a message to the main window to get the error displayed
    if (g_pMain != NULL)
    {
        // check for special OM_RC_OBJECT_DELETED case
        if (uiDCGReturnCode == OM_RC_OBJECT_DELETED)
        {
            // don't complain, just cancel drawing
            g_pMain->m_drawingArea.CancelDrawingMode();
            return;
        }

        if (g_pMain->m_hwnd)
            ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, uiFEReturnCode, uiDCGReturnCode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\grobj.cpp ===
//
// GROBJ.CPP
// Graphic Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"

#define DECIMAL_PRECISION  10000

//
// Local macros
//
#define min4(x1,x2,x3,x4) min((min((x1),(x2))),(min((x3),(x4))))
#define max4(x1,x2,x3,x4) max((max((x1),(x2))),(max((x3),(x4))))



//
// CircleHit()
//
// Checks for overlap between circle at PcxPcy with uRadius and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL CircleHit( LONG Pcx, LONG Pcy, UINT uRadius, LPCRECT lpHitRect,
					BOOL bCheckPt )
{
	RECT hr = *lpHitRect;
	RECT ellipse;
	ellipse.left = Pcx - uRadius;
	ellipse.right= Pcx + uRadius;
	ellipse.bottom = Pcy + uRadius;
	ellipse.top = Pcy - uRadius;


	// check the easy thing first (don't use PtInRect)
	if( bCheckPt &&(lpHitRect->left >= ellipse.left)&&(ellipse.right >= lpHitRect->right)&&
				   (lpHitRect->top >= ellipse.top)&&(ellipse.bottom >= lpHitRect->bottom))
	{
		return( TRUE );
	}

	//
	// The circle is just a boring ellipse
	//
	return EllipseHit(&ellipse, bCheckPt,  uRadius, lpHitRect );
}




//
// EllipseHit()
//
// Checks for overlap between ellipse defined by lpEllipseRect and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth,
					 LPCRECT lpHitRect )
{
	RECT hr = *lpHitRect;

	// Check easy thing first. If lpEllipseRect is inside lpHitRect
	// then we have a hit (no duh...)
	if( (hr.left <= lpEllipseRect->left)&&(hr.right >= lpEllipseRect->right)&&
		(hr.top <= lpEllipseRect->top)&&(hr.bottom >= lpEllipseRect->bottom) )
		return( TRUE );

	// If this is an ellipse....
	//
	//		*  *         ^
	//	 *     | b       | Y
	// *       |    a    +-------> X
	// *-------+--------
	//         |
	//
		
	
	//
	// Look for the ellipse hit. (x/a)^2 + (y/b)^2 = 1
	// If it is > 1 than the point is outside the ellipse
	// If it is < 1 it is inside
	//
	LONG a,b,aOuter, bOuter, x, y, xCenter, yCenter;
	BOOL bInsideOuter = FALSE;
	BOOL bOutsideInner = FALSE;

	//
	// Calculate a and b
	//
	a = (lpEllipseRect->right - lpEllipseRect->left)/2;
	b = (lpEllipseRect->bottom - lpEllipseRect->top)/2;

	//
	// Get the center of the ellipse
	//
	xCenter = lpEllipseRect->left + a;
	yCenter = lpEllipseRect->top + b;

	//
	// a and b generates a inner ellipse
	// aOuter and bOuter generates a outer ellipse
	//
	aOuter = a + uPenWidth + 1;
	bOuter = b + uPenWidth + 1;
	a = a - 1;
	b = b - 1;

	//
	// Make our coordinates relative to the center of the ellipse
	//
	y = abs(hr.bottom - yCenter);
	x = abs(hr.right - xCenter);

	
	//
	// Be carefull not to divide by 0
	//
	if((a && b && aOuter && bOuter) == 0)
	{
		return FALSE;
	}

	//
	// We are using LONG instead of double and we need to have some precision
	// that is why we multiply the equation of the ellipse
	// ((x/a)^2 + (y/b)^2 = 1) by DECIMAL_PRECISION
	// Note that the multiplication has to be done before the division, if we didn't do that
	// we will always get 0 or 1 for x/a
	//
	if(x*x*DECIMAL_PRECISION/(aOuter*aOuter) + y*y*DECIMAL_PRECISION/(bOuter*bOuter) <= DECIMAL_PRECISION)
	{
		bInsideOuter = TRUE;
	}

	if(x*x*DECIMAL_PRECISION/(a*a)+ y*y*DECIMAL_PRECISION/(b*b) >= DECIMAL_PRECISION)
	{
		bOutsideInner = TRUE;
	}
	
	//
	// If we are checking for border hit,
	// we need to be inside the outer ellipse and inside the inner
	//
	if( bBorderHit )
	{
			return( bInsideOuter & bOutsideInner );
	}
	// just need to be inside the outer ellipse
	else
	{
		return( bInsideOuter );
	}

}
//
// LineHit()
//
// Checks for overlap (a "hit") between lpHitRect and the line
// P1P2 accounting for line width. If bCheckP1End or bCheckP2End is
// TRUE then a circle of radius 0.5 * uPenWidth is also checked for
// a hit to account for the rounded ends of wide lines.
//
// If a hit is found TRUE is returned, otherwise FALSE.
//
BOOL LineHit( LONG P1x, LONG P1y, LONG P2x, LONG P2y, UINT uPenWidth,
				  BOOL bCheckP1End, BOOL bCheckP2End,
				  LPCRECT lpHitRect )
{

	LONG uHalfPenWidth = uPenWidth/2;

	LONG a,b,x,y;

	x = lpHitRect->left + (lpHitRect->right - lpHitRect->left)/2;
	y = lpHitRect->bottom + (lpHitRect->top - lpHitRect->bottom)/2;


	if( (P1x == P2x)&&(P1y == P2y) )
	{
		// just check one end point's circle
		return( CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, TRUE ) );
	}

	// check rounded end at P1
	if( bCheckP1End && CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );

	// check rounded end at P2
	if( bCheckP2End && CircleHit( P2x, P2y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );
	
	//
	// The function of a line is Y = a.X + b
	//
	// a = (Y1-Y2)/(X1 -X2)
	// if we found a we get b = y1 -a.X1
	//

	if(P1x == P2x)
	{
		a=0;
		b = DECIMAL_PRECISION*P1x;

	}
	else
	{
		a = (P1y - P2y)*DECIMAL_PRECISION/(P1x - P2x);
		b = DECIMAL_PRECISION*P1y - a*P1x;
	}


	//
	// Paralel to Y
	//
	if(P1x == P2x && ((x >= P1x - uHalfPenWidth) && x <= P1x + uHalfPenWidth))
	{
		return TRUE;
	}

	//
	// Paralel to X
	//
	if(P1y == P2y && ((y >= P1y - uHalfPenWidth) && y <= P1y + uHalfPenWidth))
	{
		return TRUE;
	}

	//
	// General line
	//

	return(( y*DECIMAL_PRECISION <= a*x + b + DECIMAL_PRECISION*uHalfPenWidth) &
			( y*DECIMAL_PRECISION >= a*x + b - DECIMAL_PRECISION*uHalfPenWidth));
}


//
//
// Function:    ConstructGraphic
//
// Purpose:     Construct a graphic from a page and handle
//
//
DCWbGraphic* DCWbGraphic::ConstructGraphic(WB_PAGE_HANDLE hPage,
                                           WB_GRAPHIC_HANDLE hGraphic)
{
    PWB_GRAPHIC  pHeader;
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(page, handle)");

        // Get a pointer to the external graphic data
        // (Throws an exception if any errors occur)
        pHeader = PG_GetData(hPage, hGraphic);

        // Construct the graphic
        pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

        // If we got the graphic, set its page and handle
        if (pGraphic != NULL)
        {
            pGraphic->m_hPage    = hPage;
            pGraphic->m_hGraphic = hGraphic;
        }

        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pHeader);

    return pGraphic;
}


DCWbGraphic* DCWbGraphic::ConstructGraphic(WB_PAGE_HANDLE hPage,
										   WB_GRAPHIC_HANDLE hGraphic,
										   PWB_GRAPHIC pHeader)
{
    DCWbGraphic* pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(page, pHeader)");

        pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

        // If we got the graphic, set its page and handle
        if (pGraphic != NULL)
        {
            pGraphic->m_hPage    = hPage;
            pGraphic->m_hGraphic = hGraphic;
        }
    return pGraphic;
}


DCWbGraphic* DCWbGraphic::ConstructGraphic(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ConstructGraphic(data)");

    TRACE_DEBUG(("Constructing graphic of type %hd", pHeader->type));
    TRACE_DEBUG(("Length of graphic = %ld", pHeader->length));
    TRACE_DEBUG(("Data offset = %hd", pHeader->dataOffset));

    // Construct the internal representation of the graphic
    DCWbGraphic* pGraphic = NULL;

    if (pHeader == NULL)
    {
	    return NULL;
    }

    switch (pHeader->type)
    {
        case TYPE_GRAPHIC_LINE:
            pGraphic = new DCWbGraphicLine(pHeader);
            break;

        case TYPE_GRAPHIC_FREEHAND:
            pGraphic = new DCWbGraphicFreehand(pHeader);
            break;

        case TYPE_GRAPHIC_RECTANGLE:
            pGraphic = new DCWbGraphicRectangle(pHeader);
            break;

        case TYPE_GRAPHIC_FILLED_RECTANGLE:
            pGraphic = new DCWbGraphicFilledRectangle(pHeader);
            break;

        case TYPE_GRAPHIC_ELLIPSE:
            pGraphic = new DCWbGraphicEllipse(pHeader);
            break;

        case TYPE_GRAPHIC_FILLED_ELLIPSE:
            pGraphic = new DCWbGraphicFilledEllipse(pHeader);
            break;

        case TYPE_GRAPHIC_TEXT:
            pGraphic = new DCWbGraphicText(pHeader);
            break;

        case TYPE_GRAPHIC_DIB:
            pGraphic = new DCWbGraphicDIB(pHeader);
            break;

        default:
            // Do nothing, the object pointer is already set to NULL
            break;
    }

    if (!pGraphic)
    {
        ERROR_OUT(("ConstructGraphic failing; can't allocate object of type %d",
            pHeader->type));
    }

    return pGraphic;
}

//
//
// Function:    CopyGraphic
//
// Purpose:     Construct a graphic from a pointer. This function makes a
//              complete internal copy of the graphic data.
//
//
DCWbGraphic* DCWbGraphic::CopyGraphic(PWB_GRAPHIC pHeader)
{
  MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::CopyGraphic(PWB_GRAPHIC)");

  // Construct the graphic
  DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(pHeader);

  // Copy the extra data
  if (pGraphic != NULL)
  {
    pGraphic->CopyExtra(pHeader);
  }

  return pGraphic;
}

//
//
// Function:    DCWbGraphic constructor
//
// Purpose:     Construct a new graphic object.
//
//

DCWbGraphic::DCWbGraphic(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DCWbGraphic");

    // Do basic initialization
    Initialize();

    // Convert the external data header to the internal member variables
    if (pHeader != NULL)
    {
        ReadHeader(pHeader);

        // Convert the extra data for the specific object
        // (not all objects have extra data).
        ReadExtra(pHeader);
    }
}

DCWbGraphic::DCWbGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DCWbGraphic");

    // Do the basic initialization
    Initialize();

    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage = hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    // Read the header data
    ReadExternal();
}



DCWbGraphic::~DCWbGraphic( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}


//
//
// Function:    DCWbGraphic::ReadExternal
//
// Purpose:     Read the graphic data from an externally stored graphic.
//              The external graphic to be used is specified by the
//              hGraphic member.
//
//
void DCWbGraphic::ReadExternal(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReadExternal");

    ASSERT(m_hPage != WB_PAGE_HANDLE_NULL);
    ASSERT(m_hGraphic != NULL);

    // Lock the object data in the page
    PWB_GRAPHIC pHeader = PG_GetData(m_hPage, m_hGraphic);

    // Convert the external data header to the internal member variables
    ReadHeader(pHeader);

    // Convert the extra data for the specific object
    // (not all objects have extra data).
    ReadExtra(pHeader);

    // Release the data in the page
    g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

    // Show that we are no longer changed since last read/write
    m_bChanged = FALSE;
}

//
//
// Function:    DCWbGraphic::ReadHeader
//
// Purpose:     Convert the external representation of the graphic's header
//              to the internal format.
//
//
void DCWbGraphic::ReadHeader(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReadHeader");

    // Get the length of the object
    m_dwExternalLength = pHeader->length;

    // Convert the external data header to the internal member variables
    // Bounding rectangle
    m_boundsRect.left   = pHeader->rectBounds.left;
    m_boundsRect.top    = pHeader->rectBounds.top;
    m_boundsRect.right  = pHeader->rectBounds.right;
    m_boundsRect.bottom = pHeader->rectBounds.bottom;

    // Defining rectangle
    m_rect.left   = pHeader->rect.left;
    m_rect.top    = pHeader->rect.top;
    m_rect.right  = pHeader->rect.right;
    m_rect.bottom = pHeader->rect.bottom;

    // Pen color
    m_clrPenColor = RGB(pHeader->color.red,
                    pHeader->color.green,
                    pHeader->color.blue);
    m_clrPenColor = SET_PALETTERGB( m_clrPenColor ); // make it do color matching

    // Pen width
    m_uiPenWidth = pHeader->penWidth;

    // Pen style
    m_iPenStyle = pHeader->penStyle;

    // Raster operation
    m_iPenROP = pHeader->rasterOp;

    // Get the lock indication
    m_uiLockState = pHeader->locked;

    // Get the drawing tool type
    if (pHeader->toolType == WBTOOL_TEXT)
        m_toolType = TOOLTYPE_TEXT;
    else
        m_toolType = TOOLTYPE_PEN;
}

//
//
// Function:    DCWbGraphic::WriteExternal
//
// Purpose:     Write the graphic's details to a flat WB_GRAPHIC structure
//
//
void DCWbGraphic::WriteExternal(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::WriteExternal");

    // Write the header
    WriteHeader(pHeader);

    // Write the extra data
    WriteExtra(pHeader);
}

//
//
// Function:    DCWbGraphic::WriteHeader
//
// Purpose:     Write the graphic's header details to a flat WB_GRAPHIC
//              structure.
//
//
void DCWbGraphic::WriteHeader(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::WriteHeader");

    // Convert the internal data to the external header format

    // Init struct
    FillMemory(pHeader, sizeof (WB_GRAPHIC), 0 );

    // Calculate the external length
    pHeader->length = CalculateExternalLength();

    // Set the type of graphic
    pHeader->type = (TSHR_UINT16)Type();

    // Assume that there is no extra data
    pHeader->dataOffset = sizeof(WB_GRAPHIC);

    // Bounding rectangle
    pHeader->rectBounds.left   = (short)m_boundsRect.left;	
    pHeader->rectBounds.top    = (short)m_boundsRect.top;	
    pHeader->rectBounds.right  = (short)m_boundsRect.right;	
    pHeader->rectBounds.bottom = (short)m_boundsRect.bottom;

    // Defining rectangle
    pHeader->rect.left   = (short)m_rect.left;	
    pHeader->rect.top    = (short)m_rect.top;	
    pHeader->rect.right  = (short)m_rect.right;	
    pHeader->rect.bottom = (short)m_rect.bottom;

    // Pen color
    pHeader->color.red   = GetRValue(m_clrPenColor);
    pHeader->color.green = GetGValue(m_clrPenColor);
    pHeader->color.blue  = GetBValue(m_clrPenColor);

    // Pen width
    pHeader->penWidth = (TSHR_UINT16)m_uiPenWidth;

    // Pen style
    pHeader->penStyle = (TSHR_UINT16)m_iPenStyle;

    // Raster operation
    pHeader->rasterOp = (TSHR_UINT16)m_iPenROP;

    // Set the lock indicator
    pHeader->locked = (BYTE) m_uiLockState;

    // Set the drawing method
    pHeader->smoothed = FALSE;

    // Set the drawing tool type
    if (m_toolType == TOOLTYPE_TEXT)
        pHeader->toolType = WBTOOL_TEXT;
    else
        pHeader->toolType = WBTOOL_PEN;
}

//
//
// Function:    Initialize
//
// Purpose:     Initialize the member variables
//
//
void DCWbGraphic::Initialize(void)
{
    m_hPage     = WB_PAGE_HANDLE_NULL;
    m_hGraphic  = NULL;

    m_bChanged = TRUE;

    m_uiLockState = WB_GRAPHIC_LOCK_NONE;

    //
    // Set default graphic attributes
    //
    ::SetRectEmpty(&m_boundsRect);
    ::SetRectEmpty(&m_rect);
    m_clrPenColor = RGB(0, 0, 0);           // Black pen color
    m_uiPenWidth = 1;                       // One unit width
    m_iPenROP = R2_COPYPEN;                 // Standard drawing ROP
    m_iPenStyle = PS_INSIDEFRAME;           // Solid pen to be used
    m_toolType = TOOLTYPE_PEN;
}

//
//
// Function:    Copy
//
// Purpose:     Return a copy of the graphic. The graphic returned has all
//              its data read into local memory. The returned graphic has
//              the same page as the copied graphic, but a NULL handle.
//
//
DCWbGraphic* DCWbGraphic::Copy(void) const
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Copy");

    // Get a pointer to the external graphic data
    // (Throws an exception if any errors occur)
    PWB_GRAPHIC  pHeader = PG_GetData(m_hPage, m_hGraphic);

    // Construct the graphic
    DCWbGraphic* pGraphic = DCWbGraphic::CopyGraphic(pHeader);

    // If we got the graphic, set its page and handle
    if (pGraphic != NULL)
    {
        pGraphic->m_hPage       = m_hPage;
        pGraphic->m_hGraphic    = NULL;
    }

    // Release the data
    g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

    return pGraphic;
}

//
//
// Function:    DCWbGraphic::SetBoundsRect
//
// Purpose:     Set the bounding rectangle of the object
//
//
void DCWbGraphic::SetBoundsRect(LPCRECT lprc)
{
    m_boundsRect = *lprc;
}

//
//
// Function:    DCWbGraphic::SetRect
//
// Purpose:     Set the defining rectangle of the object
//
//
void DCWbGraphic::SetRect(LPCRECT lprc)
{
    m_rect = *lprc;

    NormalizeRect(&m_rect);

    // Show that we have been changed
    m_bChanged = TRUE;
}


void DCWbGraphic::SetRectPts(POINT point1, POINT point2)
{
    RECT    rc;

    rc.left = point1.x;
    rc.top  = point1.y;
    rc.right = point2.x;
    rc.bottom = point2.y;

    SetRect(&rc);
}


//
//
// Function:    DCWbGraphic::PointInBounds
//
// Purpose:     Return TRUE if the specified point lies in the bounding
//              rectangle of the graphic object.
//
//
BOOL DCWbGraphic::PointInBounds(POINT point)
{
    return(::PtInRect(&m_boundsRect, point));
}

//
//
// Function:    DCWbGraphic::MoveBy
//
// Purpose:     Translate the object by the offset specified
//
//
void DCWbGraphic::MoveBy(int cx, int cy)
{
    // Move the bounding rectangle
    ::OffsetRect(&m_boundsRect, cx, cy);

    // Show that we have been changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphic::MoveTo
//
// Purpose:     Move the object to an absolute position
//
//
void DCWbGraphic::MoveTo(int x, int y)
{
    // Calculate the offset needed to translate the object from its current
    // position to the required position.
    x -= m_boundsRect.left;
    y -= m_boundsRect.top;

    MoveBy(x, y);
}

//
//
// Function:    DCWbGraphic::GetPosition
//
// Purpose:     Return the top left corner of the object's bounding
//              rectangle
//
//
void DCWbGraphic::GetPosition(LPPOINT lppt)
{
    lppt->x = m_boundsRect.left;
    lppt->y = m_boundsRect.top;
}

//
//
// Function:    DCWbGraphic::NormalizeRect
//
// Purpose:     Normalize a rectangle ensuring that the top left is above
//              and to the left of the bottom right.
//
//
void DCWbGraphic::NormalizeRect(LPRECT lprc)
{
    int tmp;

    if (lprc->right < lprc->left)
    {
        tmp = lprc->left;
        lprc->left = lprc->right;
        lprc->right = tmp;
    }

    if (lprc->bottom < lprc->top)
    {
        tmp = lprc->top;
        lprc->top = lprc->bottom;
        lprc->bottom = tmp;
    }
}

//
//
// Function:    DCWbGraphic::SetColor
//
// Purpose:     Set the object color.
//
//
void DCWbGraphic::SetColor(COLORREF color)
{
    color = SET_PALETTERGB( color ); // make it use color matching

    if (m_clrPenColor != color)
    {
        // Save the new color
        m_clrPenColor = color;

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}

//
//
// Function:    DCWbGraphic::SetROP
//
// Purpose:     Set the object raster operation
//
//
void DCWbGraphic::SetROP(int iPenROP)
{
    // If the new ROP is different
    if (m_iPenROP != iPenROP)
    {
        // Save the new ROP
        m_iPenROP = iPenROP;

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}

//
//
// Function:    DCWbGraphic::SetPenStyle
//
// Purpose:     Set the object pen style
//
//
void DCWbGraphic::SetPenStyle(int iPenStyle)
{
    // If the new style is different
    if (m_iPenStyle != iPenStyle)
    {
        // Save the new pen style
        m_iPenStyle = iPenStyle;

        // Show that the graphic has been changed
        m_bChanged = TRUE;
    }
}


//
//
// Function:    DCWbGraphic::SetPenWidth
//
// Purpose:     Set the pen width for the object.
//
//
void DCWbGraphic::SetPenWidth(UINT uiWidth)
{
    // If the new width is different
    if (m_uiPenWidth != uiWidth)
    {
        // Save the width given
        m_uiPenWidth = uiWidth;

        // Update the bounding rectangle
        CalculateBoundsRect();

        // Show that we have been changed
        m_bChanged = TRUE;
    }
}


//
//
// Function:    IsTopmost
//
// Purpose:     Return TRUE if this graphic is topmost on its page
//
//
BOOL DCWbGraphic::IsTopmost(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::IsTopmost");
    ASSERT(m_hGraphic != NULL);

    return PG_IsTopmost(m_hPage, this);
}

//
//
// Function:    AddToPageLast
//
// Purpose:     Add the graphic to the specified page
//
//
void DCWbGraphic::AddToPageLast(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::AddToPageLast");
    ASSERT(m_hGraphic == NULL);

  // Get the length of the flat representation
  DWORD length = CalculateExternalLength();

  // Allocate memory for the graphic
  PWB_GRAPHIC pHeader = PG_AllocateGraphic(hPage, length);

  if(pHeader == NULL)
  {
	return;
  }

  // Write the graphic details to the memory
  WriteExternal(pHeader);

    // Add the flat representation to the page
    WB_GRAPHIC_HANDLE hGraphic = NULL;
    UINT uiReturn;

    uiReturn = g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, &hGraphic);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }

    // Show that we have not changed since the last write
    m_bChanged = FALSE;

    // Save the page to which this graphic now belongs
    m_hPage     = hPage;
    m_hGraphic  = hGraphic;
}

//
//
// Function:    ForceReplace
//
// Purpose:     Write the object to external storage, replacing what is
//              already there, even if the object hasn't changed.
//
//
void DCWbGraphic::ForceReplace(void)
	{
	if( Type() != 0 )
		{
		m_bChanged = TRUE;
		this->Replace();
		}
	}

//
//
// Function:    Replace
//
// Purpose:     Write the object to external storage, replacing what is
//              already there.
//
//
void DCWbGraphic::Replace(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Replace");
    ASSERT(m_hGraphic != NULL);

  // Only do the replace if we have been changed
  if (m_bChanged == TRUE)
  {
    TRACE_MSG(("Replacing the graphic in the page"));
    // Get the length of the flat representation
    DWORD length = CalculateExternalLength();

    // Allocate memory for the graphic
    PWB_GRAPHIC pHeader = PG_AllocateGraphic(m_hPage, length);
	
	if(pHeader == NULL)
	{
		return;
	}

    // Write the graphic details to the memory
    WriteExternal(pHeader);

    // Replace the graphic
    PG_GraphicReplace(m_hPage, &m_hGraphic, pHeader);

    // Show that we have not changed since the last update
    m_bChanged = FALSE;
  }
}

//
//
// Function:    ReplaceConfirm
//
// Purpose:     Confirm the replace of the graphic
//
//
void DCWbGraphic::ReplaceConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::ReplaceConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicReplaceConfirm(m_hPage, m_hGraphic);

    // Read the new details
    ReadExternal();
}




void DCWbGraphic::ForceUpdate(void)
{
	if ((Type() != 0) && m_hGraphic)
	{
		m_bChanged = TRUE;
		this->Update();
	}
}





//
//
// Function:    Update
//
// Purpose:     Write the header of the graphic to external storage
//
//
void DCWbGraphic::Update(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Update");

    ASSERT(m_hGraphic != NULL);

    // Only make the update if the graphic has changed
    if (m_bChanged)
    {
        // Allocate memory for the update graphic
        TRACE_MSG(("Graphic has changed"));
        DWORD length = sizeof(WB_GRAPHIC);
        PWB_GRAPHIC pHeader;

        if( (pHeader = PG_AllocateGraphic(m_hPage, length)) != NULL )
		{
		    // Write the header details to the allocated memory
    		pHeader->type = (TSHR_UINT16)Type();
	    	WriteHeader(pHeader);

		    // Update the header in the page
    		PG_GraphicUpdate(m_hPage, &m_hGraphic, pHeader);
		}

        // Show that we have not changed since the last update
        m_bChanged = FALSE;
    }
}

//
//
// Function:    UpdateConfirm
//
// Purpose:     Confirm the update of the graphic
//
//
void DCWbGraphic::UpdateConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::UpdateConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicUpdateConfirm(m_hPage, m_hGraphic);

    // Read the new details
    ReadExternal();
}

//
//
// Function:    Delete
//
// Purpose:     Remove the graphic from its page
//
//
void DCWbGraphic::Delete(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Delete");

    ASSERT(m_hPage != WB_PAGE_HANDLE_NULL);
    ASSERT(m_hGraphic != NULL);

    // Delete the graphic
    PG_GraphicDelete(m_hPage, *this);

    // Reset the handles for this graphic - it is now deleted
    m_hPage     = WB_PAGE_HANDLE_NULL;
    m_hGraphic = NULL;

    // Show that we have changed (an add is required to save the graphic)
    m_bChanged = TRUE;
}

//
//
// Function:    DeleteConfirm
//
// Purpose:     Confirm the delete of the graphic
//
//
void DCWbGraphic::DeleteConfirm(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::DeleteConfirm");
    ASSERT(m_hGraphic != NULL);

    // Confirm the update
    g_pwbCore->WBP_GraphicDeleteConfirm(m_hPage, m_hGraphic);

    // Reset the graphic page and handle (they are no longer useful)
    m_hPage = WB_PAGE_HANDLE_NULL;
    m_hGraphic = NULL;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the graphic
//
//
void DCWbGraphic::Lock(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Lock");

	// If we are not already locked
	if( Type() != 0 )
		{
		if (m_uiLockState == WB_GRAPHIC_LOCK_NONE)
			{
			m_bChanged = TRUE;
			m_uiLockState = WB_GRAPHIC_LOCK_LOCAL;
			}
		}
	}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the graphic
//
//
void DCWbGraphic::Unlock(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphic::Unlock");

	// If we are currently locked
	if( Type() != 0 )
		{
		if (m_uiLockState == WB_GRAPHIC_LOCK_LOCAL)
			{
			// Lock & release
			PWB_GRAPHIC pHeader = PG_GetData(m_hPage, m_hGraphic);
			g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, pHeader);

			m_uiLockState = WB_GRAPHIC_LOCK_NONE;
            g_pwbCore->WBP_GraphicUnlock(m_hPage, m_hGraphic);
			}
		}
	}

//
//
// Function:    DCWbGraphicMarker::DCWbGraphicMarker
//
// Purpose:     Constructors for marker objects
//
//
DCWbGraphicMarker::DCWbGraphicMarker()
{
    HBITMAP hBmpMarker;
    // Set up a checked pattern to draw the marker rect with
    WORD    bits[] = {204, 204, 51, 51, 204, 204, 51, 51};

    // Create the brush to be used to draw the marker rectangle
    hBmpMarker = ::CreateBitmap(8, 8, 1, 1, bits);
    m_hMarkerBrush = ::CreatePatternBrush(hBmpMarker);
    ::DeleteBitmap(hBmpMarker);

    MarkerList.EmptyList();
    ::SetRectEmpty(&m_rect);
    m_bMarkerPresent = FALSE;
}



DCWbGraphicMarker::~DCWbGraphicMarker()
{
    if (m_hMarkerBrush != NULL)
    {
        DeleteBrush(m_hMarkerBrush);
        m_hMarkerBrush = NULL;
    }
}


//
//
// Function:    DCWbGraphicMarker::SetRect
//
// Purpose:     Set the rectangle for the object
//
//
BOOL DCWbGraphicMarker::SetRect(LPCRECT lprc,
							  DCWbGraphic *pGraphic,
							  BOOL bRedraw,
							  BOOL bLockObject )
{
	DCWbGraphic *pMarker;
	BOOL bGraphicAdded = FALSE;
    LPRECT  pmMarker;

	// Save the new rectangle
    m_rect = *lprc;
	NormalizeRect(&m_rect);

	// Calculate the new bounding rectangle of the entire marker
	CalculateBoundsRect();

	// Calculate the marker rectangles
	CalculateMarkerRectangles();

    if( (pMarker = HasAMarker( pGraphic )) != NULL )
        delete pMarker;

    // allow select only if object is not locked - bug 2185
    if( !pGraphic->Locked())
    {
    	// add/replace pGraphic|markerrect pair to list
        pmMarker = new RECT;
        if (!pmMarker)
        {
            ERROR_OUT(("Failed to create RECT object"));
        }
        else
        {
            *pmMarker = m_markerRect;

            MarkerList.SetAt( (void *)pGraphic, pmMarker);

            ASSERT(g_pDraw);
            DrawRect(g_pDraw->GetCachedDC(), pmMarker, FALSE, NULL );
            bGraphicAdded = TRUE;
        }

        if( bLockObject )
        {
		    // lock the object if we don't already have it locked
            // to keep anybody else from selecting it
            if( !pGraphic->GotLock() )
            {
					pGraphic->Lock();
					if( pGraphic->Handle() != NULL )
						pGraphic->ForceUpdate(); // if valid object force lock NOW
			}
		}
	}

	if( bRedraw &&  m_bMarkerPresent )
    {
        ASSERT(g_pDraw);
		::UpdateWindow(g_pDraw->m_hwnd);
    }

	// set m_boundsRect to real bounds
    GetBoundsRect(&m_boundsRect);

	return( bGraphicAdded );
}

//
//
// Function:    DCWbGraphicMarker::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicMarker::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    m_boundsRect = m_rect;
    NormalizeRect(&m_boundsRect);

    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicMarker::CalculateMarkerRectangles
//
// Purpose:     Calculate the rectangles for the marker handles
//
//
void DCWbGraphicMarker::CalculateMarkerRectangles(void)
{
    m_markerRect = m_boundsRect;
    ::InflateRect(&m_markerRect, 1-m_uiPenWidth, 1-m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicMarker::PointInMarker
//
// Purpose:     Calculate whether the given point is in one of the marker
//              rectangles.
//
//
int DCWbGraphicMarker::PointInMarker(POINT point)
{
    return(NO_HANDLE);
}



void DCWbGraphicMarker::DrawRect
(
    HDC             hDC,
    LPCRECT         pMarkerRect,
    BOOL            bDrawObject,
    DCWbGraphic *   pGraphic
)
{
	int			 nOldROP;
	COLORREF	 crOldTextColor;
	COLORREF	 crOldBkColor;

	nOldROP = ::SetROP2(hDC, R2_COPYPEN);
	crOldTextColor = ::SetTextColor(hDC, RGB(0, 0, 0));

    ASSERT(g_pDraw);
	crOldBkColor = ::SetBkColor(hDC, ::GetSysColor(COLOR_WINDOW));

	if (pMarkerRect != NULL)
    {
		if( bDrawObject )
			pGraphic->Draw(hDC ); // draw object instead of rect
		else
			::FrameRect(hDC, pMarkerRect, m_hMarkerBrush); // draw rect
	}

	::SetROP2(hDC, nOldROP);
	::SetTextColor(hDC, crOldTextColor);
	::SetBkColor(hDC, crOldBkColor);
}


//
//
// Function:    DCWbGraphicMarker::Draw
//
// Purpose:     Draw the marker object
//
//
void DCWbGraphicMarker::Draw(HDC hDC, BOOL bDrawObjects)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT       pMarkerRect;

	// if marker is not up, do nuthin
	if( !m_bMarkerPresent )
		return;

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );
		DrawRect(hDC, pMarkerRect, bDrawObjects, pGraphic );
	}
}


void DCWbGraphicMarker::UndrawRect
(
    HDC     hDC,
    WbDrawingArea * pDrawingArea,
    LPCRECT pMarkerRect
)
{
	int			 nOldROP;
	COLORREF	 crOldTextColor;
	COLORREF	 crOldBkColor;

	if (pMarkerRect != NULL)
	{
		// set up context to erase marker rect
		nOldROP = ::SetROP2(hDC, R2_COPYPEN);

        ASSERT(g_pDraw);
		crOldTextColor = ::SetTextColor(hDC, ::GetSysColor(COLOR_WINDOW));
		crOldBkColor = ::SetBkColor(hDC, ::GetSysColor(COLOR_WINDOW));

		::FrameRect(hDC, pMarkerRect, m_hMarkerBrush);
		UndrawMarker( pMarkerRect ); // invalidate so underlying objects will repair window

		::SetROP2(hDC, nOldROP);
		::SetTextColor(hDC, crOldTextColor);
		::SetBkColor(hDC, crOldBkColor);
	}
}




//
//
// Function:    DCWbGraphicMarker::Undraw
//
// Purpose:     Undraw the marker object
//
//
void DCWbGraphicMarker::Undraw(HDC hDC, WbDrawingArea * pDrawingArea)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT      pMarkerRect;

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );
		UndrawRect(hDC, pDrawingArea, pMarkerRect);
	}
}






void DCWbGraphicMarker::DeleteAllMarkers( DCWbGraphic *pLastSelectedGraphic,
										  BOOL bLockLastSelectedGraphic )
	{
	POSITION	 posFirst;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
	BOOL		 bAddLastBack = FALSE;

	if( MarkerList.IsEmpty() )
		return; // nuthin to do

	// let each object clean itself up
	posFirst = MarkerList.GetHeadPosition();
	while( posFirst != NULL )
		{
		MarkerList.GetNextAssoc( posFirst,
								(void *&)pGraphic, (void *&)pMarkerRect );

		if( pGraphic != NULL )
			{
  			if( pGraphic == pLastSelectedGraphic )
				{
				// have to put this one back since somebody up there needs it
				bAddLastBack = TRUE;

				// delete key but don't delete object
				DeleteMarker( pGraphic );
				}
			else
				{
				// obj will call DeleteMarker()
				delete pGraphic;
				}
			}
		else
			{
			// nobody home, remove key ourselves
			DeleteMarker( pGraphic );
			}
		}

	// put last selected object back if needed
	if( bAddLastBack && (pLastSelectedGraphic != NULL) )
    {
        RECT    rcT;

        pLastSelectedGraphic->GetBoundsRect(&rcT);
		SetRect(&rcT, pLastSelectedGraphic, FALSE, bLockLastSelectedGraphic );
    }


	// if marker is not up, don't redraw immediately
	if( !m_bMarkerPresent )
		return;

    ASSERT(g_pDraw);
	if (g_pDraw->m_hwnd != NULL )
        ::UpdateWindow(g_pDraw->m_hwnd);
}



//
// Deletes DCWbGraphic/LPRECT pair corresponding to pGraphic
//
void DCWbGraphicMarker::DeleteMarker( DCWbGraphic *pGraphic )
{
	LPRECT pMarkerRect;
	
	if( MarkerList.IsEmpty() )
		return;

	if( MarkerList.Lookup( (void *)pGraphic, (void *&)pMarkerRect )  )
	{
		if( pMarkerRect != NULL )
		{
            ASSERT(g_pDraw);
			UndrawRect(g_pDraw->GetCachedDC(), g_pDraw, pMarkerRect );
			delete pMarkerRect;
		}

		MarkerList.RemoveKey( (void *)pGraphic );

		// set m_boundsRect to real bounds
        GetBoundsRect(&m_boundsRect);

		// pGraphic should be locked by us since it was selected
		// but check to be sure since this might be coming from
		// another user that beat us to the lock.
		if( pGraphic->GotLock() )
			{
			pGraphic->Unlock();
			if( pGraphic->Handle() != NULL )
				pGraphic->ForceUpdate();
			}
		}

	// if marker is not up, don't redraw immediately
	if( !m_bMarkerPresent )
		return;
	}


//
// Sees if pGraphic->Handle() is in marker list and returns obj
//
DCWbGraphic *DCWbGraphicMarker::HasAMarker( DCWbGraphic *pGraphic )
{
	POSITION	 posNext;		
	DCWbGraphic *pSearchGraphic;
	LPRECT       pMarkerRect;

	if( MarkerList.IsEmpty()  )
		return( NULL );

	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
		{
		MarkerList.GetNextAssoc( posNext,
								 (void *&)pSearchGraphic, (void *&)pMarkerRect );

		if( (pSearchGraphic != NULL)&&
			(pSearchGraphic->Handle() == pGraphic->Handle()) )
			{
			return( pSearchGraphic );
			}
		}

	return( NULL );

	}



//
// Gets last marker
//
DCWbGraphic *DCWbGraphicMarker::LastMarker( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	pGraphic = NULL;

	if( !MarkerList.IsEmpty()  )
		{
		// this isn't eactly right, just return head of list for now
		posNext = MarkerList.GetHeadPosition();
		if( posNext != NULL )
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );
		}

	return( pGraphic );
	}



void DCWbGraphicMarker::UndrawMarker(LPCRECT pMarkerRect )
{
    RECT    rect;

    ASSERT(g_pDraw);
	if( (pMarkerRect != NULL) && (g_pDraw->m_hwnd != NULL) )
	{
        rect = *pMarkerRect;
		g_pDraw->SurfaceToClient(&rect);

        ::InvalidateRect(g_pDraw->m_hwnd, &rect, FALSE);
	}
}



int	DCWbGraphicMarker::GetNumMarkers( void )
{
	int count  = 0;		
	POSITION pos;
	pos = MarkerList.GetHeadPosition();
	while(pos)
	{
		count ++;
		MarkerList.GetNext(pos);
	}

	return count;
}




void DCWbGraphicMarker::MoveBy(int cx, int cy)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call MoveBy for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				pGraphic->MoveBy(cx, cy);
				}
			}
		}

	DCWbGraphic::MoveBy(cx, cy); // move marker too
}




void DCWbGraphicMarker::Update( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->Update();
			}
		}
	}




BOOL DCWbGraphicMarker::PointInBounds(POINT pt)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
    RECT        rectHit;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
			{
				MAKE_HIT_RECT(rectHit, pt );

				if( pGraphic->PointInBounds(pt)&&
				    pGraphic->CheckReallyHit( &rectHit )
					)
					return( TRUE );
			}
		}
	}

	return( FALSE );
}



//
// Returns a rect that is the union of all the items in the marker
//
void DCWbGraphicMarker::GetBoundsRect(LPRECT lprc)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
    LPRECT       pMarkerRect;
    RECT         rc;

    ::SetRectEmpty(lprc);

	if( !MarkerList.IsEmpty())
    {
        posNext = MarkerList.GetHeadPosition();
        while( posNext != NULL )
        {
            MarkerList.GetNextAssoc( posNext,
							(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
            {
                pGraphic->GetBoundsRect(&rc);
                ::UnionRect(lprc, lprc, &rc);
            }
		}
    }
}





void DCWbGraphicMarker::SetColor(COLORREF color)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->SetColor( color );
			}
		}
	}







void DCWbGraphicMarker::SetPenWidth(UINT uiWidth)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				pGraphic->SetPenWidth(uiWidth);
			}
		}
	}




void DCWbGraphicMarker::SetSelectionFont(HFONT hFont)
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( (pGraphic != NULL)&&
				pGraphic->IsGraphicTool() == enumGraphicText)
				{
				// Change the font of the object
				((DCWbGraphicText*)pGraphic)->SetFont(hFont);

				// Replace the object
				pGraphic->Replace();
				}
			}
		}
	}




//
// Deletes each marker obj for all connections
//
void DCWbGraphicMarker::DeleteSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	DCWbGraphic *pGraphicCopy;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty() )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				// make a copy for trash can
				pGraphicCopy = pGraphic->Copy();

				// throw in trash
				if( pGraphicCopy != NULL )
                {
					g_pMain->m_LastDeletedGraphic.CollectTrash( pGraphicCopy );
                }

				// delete obj
				g_pDraw->DeleteGraphic( pGraphic );
				}
			}

		DeleteAllMarkers( NULL );
		}
	}



//
// Brings eaach marker obj to top
//
void DCWbGraphicMarker::BringToTopSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
				{
				// move obj to top
                UINT uiReturn;

                uiReturn = g_pwbCore->WBP_GraphicMove(g_pDraw->Page(),
                    pGraphic->Handle(), LAST);
                if (uiReturn != 0)
                {
                    DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
				    return;
                }
				}
			}
		}
	}


//
// Sends each marker object to back
//
void DCWbGraphicMarker::SendToBackSelection( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;

	if( !MarkerList.IsEmpty()  )
		{
		// Call Update for each selected obj
		posNext = MarkerList.GetHeadPosition();
		while( posNext != NULL )
			{
			MarkerList.GetNextAssoc( posNext,
									(void *&)pGraphic, (void *&)pMarkerRect );

			if( pGraphic != NULL )
			{
                UINT uiReturn;

				// move obj to top
                uiReturn = g_pwbCore->WBP_GraphicMove(g_pDraw->Page(),
                    pGraphic->Handle(), FIRST);
                if (uiReturn != 0)
                {
                    DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
				    return;
                }
			}
			}
		}
	}



//
// Copy marker to clipboard using CLIPBOARD_PRIVATE_MULTI_OBJ format:
//      [ RECT		 : marker rect					]
//      [ DWORD		 : number of objects			]
//      [ DWORD		 : byte length of 1st object	]
//      [ WB_GRAPHIC : header data for first object	]
//      [ DWORD		 : byte length of 2nd object	]
//      [ WB_GRAPHIC : header data for 2nd object	]
//          :
//          :
//      [ DWORD		 : byte length of last object	]
//      [ WB_GRAPHIC : header data for last object	]
//      [ DWORD		 : 0 (marks end of object data)	]
//
BOOL DCWbGraphicMarker::RenderPrivateMarkerFormat( void )
{
	POSITION	 posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
	DWORD		 nBufSize;
	DWORD		 nObjSize;
	DWORD		 nNumObjs;
	BYTE	    *buf;
	BYTE	    *pbuf;
    HANDLE		 hbuf;
	PWB_GRAPHIC  pHeader;
	WB_GRAPHIC_HANDLE hGraphic;

	if( MarkerList.IsEmpty() )
		return( TRUE ); // nuthin to do

	// Have to make two passes. The first one figures out how much
	// data we have, the second copies the data.

	// figure out how much data we've got
	nBufSize = sizeof (RECT) + sizeof (DWORD); // marker rect and object
											  // count are first
	nNumObjs = 0;
	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
		{
		MarkerList.GetNextAssoc( posNext,
							     (void *&)pGraphic, (void *&)pMarkerRect );

		if( (pGraphic != NULL)&&
			((hGraphic = pGraphic->Handle()) != NULL)&&
			((pHeader = PG_GetData(pGraphic->Page(), hGraphic )) != NULL) )
			{
			nBufSize += (DWORD)(pHeader->length + sizeof(DWORD));
			g_pwbCore->WBP_GraphicRelease(pGraphic->Page(), hGraphic, pHeader);

			// count objects instead of using MarkerList.GetCount()
			// in case we have an error or something (bad object,
			// leaky core, who knows...)
			nNumObjs++;
			}
		}

	// Add one more DWORD at end. This will be set to 0 below
	// to mark the end of the buffer.
	nBufSize += sizeof(DWORD);


	// Make object buffer. Use GlobalDiddle instead of new so we
	// can pass a mem handle to the clipboard later.
    hbuf = ::GlobalAlloc( GHND, nBufSize );
	if( hbuf == NULL )
		return( FALSE ); // couldn't make room

    buf = (BYTE *)::GlobalLock( hbuf );
	if( buf == NULL )
		{
		::GlobalFree( hbuf );
		return( FALSE ); // couldn't find the room
		}

	pbuf = buf;


	// set marker rect
	CopyMemory(pbuf, &m_boundsRect, sizeof(RECT));
	pbuf += sizeof (RECT);


	// set number of objects
	*((DWORD *)pbuf) = nNumObjs;
	pbuf += sizeof (DWORD);


	// copy each obj to buf + a length DWORD
	posNext = MarkerList.GetHeadPosition();
	while( posNext != NULL )
	{
		MarkerList.GetNextAssoc( posNext,
							     (void *&)pGraphic, (void *&)pMarkerRect );

		if( (pGraphic != NULL)&&
			((hGraphic = pGraphic->Handle()) != NULL)&&
			((pHeader = PG_GetData(pGraphic->Page(), hGraphic )) != NULL) )
			{
			// save length of this obj first
			nObjSize = (DWORD)pHeader->length;
			*((DWORD *)pbuf) = nObjSize;
			pbuf += sizeof (DWORD);

			// copy obj to buf
			CopyMemory( pbuf, (CONST VOID *)pHeader, nObjSize );

			// make sure copy isn't "locked" (bug 474)
			((PWB_GRAPHIC)pbuf)->locked = WB_GRAPHIC_LOCK_NONE;

			// set up for next obj
			pbuf += nObjSize;

			g_pwbCore->WBP_GraphicRelease(pGraphic->Page(), hGraphic, pHeader );
			}
		}

	// cork it up
	*((DWORD *)pbuf) = 0;

	// give it to the clipboard
	::GlobalUnlock( hbuf );
	if( ::SetClipboardData(
			g_ClipboardFormats[ CLIPBOARD_PRIVATE_MULTI_OBJ ], hbuf
							)
		== NULL )
		{
		// clipboard choked, clean up mess
        ::GlobalFree( hbuf );
		return( FALSE );
		}

	// zillions of shared clipboards all over the planet are receiving this
	// thing about now...
	return( TRUE );
	}



//
// Decodes CLIPBOARD_PRIVATE_MULTI_OBJ format and pastes objects
// to Whiteboard. See DCWbGraphicMarker::RenderPrivateMarkerFormat
// for details of format.
//
void DCWbGraphicMarker::Paste( HANDLE handle )
{
	BYTE *pbuf;
	DWORD nNumObjs;
	DWORD nObjSize;
	DCWbGraphic *pGraphic;
	DCWbGraphic *pSelectedGraphic;
	SIZE   PasteOffset;
	RECT  rectMarker;

	// blow off current selection
    g_pMain->m_drawingArea.RemoveMarker(NULL);
	DeleteAllMarkers( NULL );
    pSelectedGraphic = NULL;



	// get data
	pbuf = (BYTE *)::GlobalLock( handle );
	if( pbuf == NULL )
		return; // can't get the door open


	// get marker's original coords and figure offset
	CopyMemory( &rectMarker, (CONST VOID *)pbuf, sizeof (RECT) );
	pbuf += sizeof (RECT);

    RECT    rcVis;
    g_pMain->m_drawingArea.GetVisibleRect(&rcVis);
    PasteOffset.cx = rcVis.left - rectMarker.left;
    PasteOffset.cy = rcVis.top - rectMarker.top;

	// get num objects
	nNumObjs = *((DWORD *)pbuf);
	pbuf += sizeof (DWORD);

	// get each object
	while( (nObjSize = *((DWORD *)pbuf)) != 0 )
		{
		pbuf += sizeof (DWORD);

		// Add the object to the page and current selection
		pGraphic = DCWbGraphic::CopyGraphic( (PWB_GRAPHIC)pbuf );
		pbuf += nObjSize;

		if( pGraphic != NULL )
		{
			pGraphic->MoveBy( PasteOffset.cx, PasteOffset.cy );
			pGraphic->AddToPageLast( g_pMain->GetCurrentPage() );
			g_pMain->m_drawingArea.SelectGraphic( pGraphic, TRUE, TRUE );
        }
	}

	::GlobalUnlock( handle );

    GetBoundsRect(&m_boundsRect);
}



DCWbGraphicLine::~DCWbGraphicLine( void )
{
    // Have to make sure marker is cleaned up before we vanish
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	


//
//
// Function:    DCWbGraphicLine::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the line
//
//
void DCWbGraphicLine::CalculateBoundsRect()
{
    // Create the basic bounding rectangle from the start and end points
    m_boundsRect = m_rect;
    NormalizeRect(&m_boundsRect);

    // Expand the rectangle by the pen width used for drawing
    int iInflate = (m_uiPenWidth + 1) / 2;
    ::InflateRect(&m_boundsRect, iInflate, iInflate);
}

//
//
// Function:    DCWbGraphicLine::SetStart
//
// Purpose:     Set the start point of the line
//
//
void DCWbGraphicLine::SetStart(POINT pointFrom)
{
    // Only do anything if the start point has changed
    if (!EqualPoint(*((LPPOINT)&m_rect.left), pointFrom))
    {
        // Save the new start point
        m_rect.left = pointFrom.x;
        m_rect.top = pointFrom.y;

        // Show that the graphic has changed
        m_bChanged = TRUE;
    }

    // Update the bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicLine::SetEnd
//
// Purpose:     Set the start point of the line
//
//
void DCWbGraphicLine::SetEnd(POINT pointTo)
{
    // Only do anything if the end point has changed
    if (!EqualPoint(*((LPPOINT)&m_rect.right), pointTo))
    {
        // Save the new end point
        m_rect.right = pointTo.x;
        m_rect.bottom = pointTo.y;

        // Show that the graphic has changed
        m_bChanged = TRUE;
    }

    // Update the bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicLine::Draw
//
// Purpose:     Draw the line.
//
//
void DCWbGraphicLine::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicLine::Draw");

    // Select the required pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    if (hOldPen != NULL)
    {
        // Select the raster operation
        int iOldROP = ::SetROP2(hDC, m_iPenROP);

        // Draw the line
        ::MoveToEx(hDC, m_rect.left, m_rect.top, NULL);
        ::LineTo(hDC, m_rect.right, m_rect.bottom);

        // De-select the pen and ROP
        ::SetROP2(hDC, iOldROP);
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}

//
//
// Function:    DCWbGraphicLine::MoveBy
//
// Purpose:     Move the line.
//
//
void DCWbGraphicLine::MoveBy(int cx, int cy)
{
    // Move the start and end points
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}



//
// Checks object for an actual overlap with pRectHit.  Assumes m_boundsRect
// has already been compared.
//
BOOL DCWbGraphicLine::CheckReallyHit(LPCRECT pRectHit)
{
	return(LineHit(m_rect.left, m_rect.top, m_rect.right, m_rect.bottom,
				 m_uiPenWidth, TRUE, TRUE, pRectHit));
}



//
//
// Function:    DCWbGraphicFreehand::DCWbGraphicFreehand
//
// Purpose:     Constructor
//
//
DCWbGraphicFreehand::DCWbGraphicFreehand(void) : DCWbGraphic()
{
}

DCWbGraphicFreehand::DCWbGraphicFreehand(PWB_GRAPHIC pHeader)
                    : DCWbGraphic()

{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::DCWbGraphicFreehand");

  // Note that we do everything in this constructor because of the
  // call to ReadExternal. If we let the DCWbGraphic base constructor
  // do it the wrong version of ReadExtra will be called (the one
  // in DCWbGraphic instead of the one in DCWbGraphicFreehand);

  // Do the basic initialization
  Initialize();

  // Set up the page and graphic handle
  ASSERT(pHeader != NULL);

  // Read the header data
  ReadHeader(pHeader);

  // Read the extra data
  ReadExtra(pHeader);

}

DCWbGraphicFreehand::DCWbGraphicFreehand
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic()

{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::DCWbGraphicFreehand");

  // Note that we do everything in this constructor because of the
  // call to ReadExternal. If we let the DCWbGraphic base constructor
  // do it the wrong version of ReadExtra will be called (the one
  // in DCWbGraphic instead of the one in DCWbGraphicFreehand);

  // Do the basic initialization
  Initialize();


    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage = hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    // Read the header data
    ReadExternal();
}



DCWbGraphicFreehand::~DCWbGraphicFreehand( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	


//
//
// Function:    DCWbGraphicFreehand::MoveBy
//
// Purpose:     Move the polyline.
//
//
void DCWbGraphicFreehand::MoveBy(int cx, int cy)
{
    // Move the base point of the freehand object
    m_rect.left += cx;
    m_rect.top += cy;

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicFreehand::Draw
//
// Purpose:     Draw the polyline.
//
//
void DCWbGraphicFreehand::Draw(HDC hDC)
{
    RECT    clipBox;
    int     iOldROP;
    HPEN    hPen;
    HPEN    hOldPen;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand:Draw");

    // NFC, SFR 5922.  Check the return code from GetClipBox.
    // If we fail to get it, just draw everything
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the required pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    if (hOldPen != NULL)
    {
        // All points are relative to the first point in the list.
        // We update the origin of the DC temporarily to account for this.
        POINT   origin;

        ::GetWindowOrgEx(hDC, &origin);
        ::SetWindowOrgEx(hDC, origin.x - m_rect.left, origin.y - m_rect.top, NULL);

        // Call the appropriate drawing function, according to whether
        // we're smooth or not
        DrawUnsmoothed(hDC);

        // Restore the origin
        ::SetWindowOrgEx(hDC, origin.x, origin.y, NULL);

        ::SetROP2(hDC, iOldROP);
        SelectPen(hDC, hOldPen);
    }

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}


//
//
// Function:    DCWbGraphicFreehand::DrawUnsmoothed
//
// Purpose:     Draw the complete graphic, not using smoothing.
//
//
void DCWbGraphicFreehand::DrawUnsmoothed(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehandDrawUnsmoothed");

    // Set up the count and pointer to the points data. We use the
    // external data if we have a handle, otherwise internal data is used.
	int iCount = points.GetSize();
    if (iCount < 2)
    {
    	POINT point;
    	point.x = points[0]->x;
    	point.y = points[0]->y;
        points.Add(point);

        iCount = points.GetSize();
    }

    RECT  clipBox;

    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }

    // Draw all the line segments stored
    ::MoveToEx(hDC, points[0]->x, points[0]->y, NULL);
    for ( int iIndex = 1; iIndex < iCount; iIndex++)
    {
        // Draw the line
        ::LineTo(hDC, points[iIndex]->x, points[iIndex]->y);
    }
}




//
//
// Function:    DCWbGraphicFreehand::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the line
//
//
void DCWbGraphicFreehand::CalculateBoundsRect(void)
{
    // Reset the bounds rectangle
    ::SetRectEmpty(&m_boundsRect);

    // Add each of the points in the line to the bounding rectangle
    int iCount = points.GetSize();
    for ( int iIndex = 0; iIndex < iCount; iIndex++)
    {
        AddPointToBounds(points[iIndex]->x, points[iIndex]->y);
    }

    //
    // Since the points are inclusive, we need to add one to the top &
    // bottom sides.
    //
    ::InflateRect(&m_boundsRect, 0, 1);
    ::OffsetRect(&m_boundsRect, m_rect.left, m_rect.top);
}

//
//
// Function:    DCWbGraphicFreehand::AddPointToBounds
//
// Purpose:     Add a single point into the bounding rectangle. The point is
//              expected to be in surface co-ordinates.
//
//
void DCWbGraphicFreehand::AddPointToBounds(int x, int y)
{
    // Create a rectangle containing the point just added (expanded
    // by the width of the pen being used).
    RECT  rect;

    int iInflate = (m_uiPenWidth + 1) / 2;
    rect.left   = x - iInflate;
    rect.top    = y - iInflate;
    rect.right  = x + iInflate;
    rect.bottom = y + iInflate;

    ::UnionRect(&m_boundsRect, &m_boundsRect, &rect);
}

//
//
// Function:    DCWbGraphicFreehand::AddPoint
//
// Purpose:     Add a point to the poly line, returning BOOL indicating
//              success.
//
//
BOOL DCWbGraphicFreehand::AddPoint(POINT point)
{
    BOOL bSuccess = TRUE;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::AddPoint");

    // if we've reached the maximum number of points then quit with failure
    if (points.GetSize() >= MAX_FREEHAND_POINTS)
    {
        bSuccess = FALSE;
        TRACE_MSG(("Maximum number of points for freehand object reached."));
        return(bSuccess);
    }

    // If this is the first point - all others are taken relative to it.
    if (points.GetSize() == 0)
    {
        // Save the first point here.
        m_rect.left = point.x;
        m_rect.top = point.y;
    }

    // Add the new point to the array - surround with exception handler
    // to catch memory errors
    POINT newpoint;
    newpoint.x = point.x - m_rect.left;
    newpoint.y = point.y - m_rect.top;

    points.Add((newpoint));

    // Add the new point into the accumulated bounds rectangle.
    AddPointToBounds(point.x, point.y);

    // Show that the graphic has changed
    m_bChanged = TRUE;

    return(bSuccess);
}

//
//
// Function:    DCWbGraphicFreehand::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicFreehand::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFreehand::CalculateExternalLength");

  // Calculate the total length of the flat representation of the graphic
  return (DWORD) (  sizeof(WB_GRAPHIC_FREEHAND)
                  + (points.GetSize() * sizeof(POINT)));
}

//
//
// Function:    DCWbGraphicFreehand::WriteExtra
//
// Purpose:     Write the extra (non-header) data to the flat representation
//              of the graphic.
//
//
void DCWbGraphicFreehand::WriteExtra(PWB_GRAPHIC pHeader)
{
  // Allocate the memory
  PWB_GRAPHIC_FREEHAND pFreehand = (PWB_GRAPHIC_FREEHAND) pHeader;

  // Copy the extra details into place
  pFreehand->pointCount = (TSHR_UINT16)points.GetSize();
  for ( int iIndex = 0; iIndex < pFreehand->pointCount; iIndex++)
  {
    pFreehand->points[iIndex].x = (short)points[iIndex]->x;
    pFreehand->points[iIndex].y = (short)points[iIndex]->y;
  }
}

//
//
// Function:    DCWbGraphicFreehand::ReadExtra
//
// Purpose:     Read the extra (non-header) data from the flat
//              representation of the graphic.
//
//
void DCWbGraphicFreehand::ReadExtra(PWB_GRAPHIC pHeader)
{
  // Allocate the memory
  PWB_GRAPHIC_FREEHAND pFreehand = (PWB_GRAPHIC_FREEHAND) pHeader;

  // Get the number of points
  int iCount = pFreehand->pointCount;

  // Set the size of the points array
  points.SetSize(iCount);

  // Copy the points from the external memory to internal
  int iPointIndex = 0;
  while (iPointIndex < iCount)
  {
    points[iPointIndex]->x = pFreehand->points[iPointIndex].x;
    points[iPointIndex]->y = pFreehand->points[iPointIndex].y;

    iPointIndex++;
  }
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFreehand::CheckReallyHit(LPCRECT pRectHit)
{
	POINT *lpPoints;
	int    iCount;
	int	   i;
	POINT  ptLast;
	UINT   uRadius;
	RECT   rectHit;


	iCount = points.GetSize();
	lpPoints = (POINT *)points.GetBuffer();

	if( iCount == 0 )
		return( FALSE );


	// addjust hit rect to lpPoints coord space.
	rectHit = *pRectHit;
    ::OffsetRect(&rectHit, -m_rect.left, -m_rect.top);

	if( (iCount > 0)&&(iCount < 2) )
		{
		// only one point, just hit check it
		uRadius = m_uiPenWidth >> 1; // m_uiPenWidth/2
		return(
			CircleHit( lpPoints->x, lpPoints->y, uRadius, &rectHit, TRUE )
				);
		}

	// look for a hit on each line segment body
	ptLast = *lpPoints++;
	for( i=1; i<iCount; i++ )
		{
		if( LineHit( ptLast.x, ptLast.y,
					 lpPoints->x, lpPoints->y, m_uiPenWidth,
					 FALSE, FALSE,
					 &rectHit )
			)
			return( TRUE ); // got a hit

		ptLast = *lpPoints++;
		}

	// now, look for a hit on the line endpoints if m_uiPenWidth > 1
	if( m_uiPenWidth > 1 )
		{
		uRadius = m_uiPenWidth >> 1; // m_uiPenWidth/2
		lpPoints = (POINT *)points.GetBuffer();
		for( i=0; i<iCount; i++, lpPoints++ )
			{
			if( CircleHit( lpPoints->x, lpPoints->y, uRadius, &rectHit, FALSE )
				)
				return( TRUE ); // got a hit
			}
		}

	return( FALSE ); // no hits
	}






DCWbGraphicRectangle::~DCWbGraphicRectangle( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	




//
//
// Function:    DCWbGraphicRectangle::SetRect
//
// Purpose:     Set the rectangle size/position
//
//
void DCWbGraphicRectangle::SetRect(LPCRECT lprect)
{
    DCWbGraphic::SetRect(lprect);

    // Generate the new bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicRectangle::MoveBy
//
// Purpose:     Move the rectangle
//
//
void DCWbGraphicRectangle::MoveBy(int cx, int cy)
{
    // Move the rectangle
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicRectangle::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicRectangle::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicRectangle::Draw
//
// Purpose:     Draw the rectangle
//
//
void DCWbGraphicRectangle::Draw(HDC hDC)
{
    int     iOldROP;
    RECT    clipBox;
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hOldBrush;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicRectangle::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);
    hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Rectangle(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);
    SelectPen(hDC, hOldPen);

    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}




//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicRectangle::CheckReallyHit(LPCRECT pRectHit)
{
	RECT rectEdge;
	RECT rectHit;

	// check left edge
    rectEdge.left   = m_rect.left - m_uiPenWidth;
    rectEdge.top    = m_rect.top -  m_uiPenWidth;
    rectEdge.right  = m_rect.left;
    rectEdge.bottom = m_rect.bottom + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	// check right edge
	rectEdge.left =     m_rect.right;
	rectEdge.right =    m_rect.right + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check top edge
	rectEdge.left = m_rect.left;
	rectEdge.right = m_rect.right;
	rectEdge.bottom = m_rect.top;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );


	// check bottom edge
	rectEdge.top = m_rect.bottom;
	rectEdge.bottom = m_rect.bottom + m_uiPenWidth;

    if (::IntersectRect(&rectHit, &rectEdge, pRectHit))
		return( TRUE );

	return( FALSE );
}




DCWbGraphicFilledRectangle::~DCWbGraphicFilledRectangle( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	




//
//
// Function:    DCWbGraphicFilledRectangle::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicFilledRectangle::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This is one greater than the rectangle to include the drawing rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, 1, 1);
}

//
//
// Function:    DCWbGraphicFilledRectangle::Draw
//
// Purpose:     Draw the rectangle
//
//
void DCWbGraphicFilledRectangle::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hBrush;
    HBRUSH  hOldBrush;
    int     iOldROP;
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFilledRectangle::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, 2, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    hBrush = ::CreateSolidBrush(m_clrPenColor);
    hOldBrush = SelectBrush(hDC, hBrush);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Rectangle(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    // Restore the ROP mode
    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);
    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFilledRectangle::CheckReallyHit(LPCRECT pRectHit)
{
	return( TRUE );
}



//
// Draws a tracking rect for every marker obj in marker
// (DCWbGraphicSelectTrackingRectangle is a friend of DCWbGraphicMarker
// and WbDrawingArea)
//
void DCWbGraphicSelectTrackingRectangle::Draw(HDC hDC)
{
	POSITION	posNext;		
	DCWbGraphic *pGraphic;
	LPRECT      pMarkerRect;
    RECT        rectTracker;
	CPtrToPtrList *pMList;

	// don't draw at start point or XOR will get out of sync
	if( (m_Offset.cx == 0)&&(m_Offset.cy == 0) )
		return;

    ASSERT(g_pDraw);
	pMList = &(g_pDraw->m_pMarker->MarkerList);

	if( pMList->IsEmpty() )
		return;

	posNext = pMList->GetHeadPosition();
	while( posNext != NULL )
		{
		pMList->GetNextAssoc( posNext, (void *&)pGraphic, (void *&)pMarkerRect );

		if( pMarkerRect != NULL )
		{
            rectTracker = *pMarkerRect;
            ::OffsetRect(&rectTracker, m_Offset.cx, m_Offset.cy);

			SetRect(&rectTracker);
			DCWbGraphicRectangle::Draw(hDC);
		}
	}
}




void DCWbGraphicSelectTrackingRectangle::MoveBy(int cx, int cy)
{
    m_Offset.cx += cx;
    m_Offset.cy += cy;
}





DCWbGraphicEllipse::~DCWbGraphicEllipse( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	



//
//
// Function:    DCWbGraphicEllipse::SetRect
//
// Purpose:     Set the ellipse size/position
//
//
void DCWbGraphicEllipse::SetRect(LPCRECT lprc)
{
    DCWbGraphic::SetRect(lprc);

    // Generate the new bounding rectangle
    CalculateBoundsRect();
}

//
//
// Function:    DCWbGraphicEllipse::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicEllipse::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This includes all the line, since we draw inside the bounds
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, m_uiPenWidth, m_uiPenWidth);
}

//
//
// Function:    DCWbGraphicEllipse::MoveBy
//
// Purpose:     Move the ellipse
//
//
void DCWbGraphicEllipse::MoveBy(int cx, int cy)
{
    // Move the ellipse
    ::OffsetRect(&m_rect, cx, cy);

    // Move the other object attributes
    DCWbGraphic::MoveBy(cx, cy);
}

//
//
// Function:    DCWbGraphicEllipse::Draw
//
// Purpose:     Draw the ellipse
//
//
void DCWbGraphicEllipse::Draw(HDC hDC)
{
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hOldBrush;
    int     iOldROP;
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicEllipse::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, m_uiPenWidth, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);
    hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Ellipse(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }
}




//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//	
BOOL DCWbGraphicEllipse::CheckReallyHit(LPCRECT pRectHit)
{
    return( EllipseHit( &m_rect, TRUE, m_uiPenWidth, pRectHit ) );
}





DCWbGraphicFilledEllipse::~DCWbGraphicFilledEllipse( void )
{
	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}
}
	



//
//
// Function:    DCWbGraphicFilledEllipse::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicFilledEllipse::CalculateBoundsRect(void)
{
    // Generate the new bounding rectangle
    // This is one greater than the rectangle to include the drawing rectangle
    m_boundsRect = m_rect;

    NormalizeRect(&m_boundsRect);
    ::InflateRect(&m_boundsRect, 1, 1);
}

//
//
// Function:    DCWbGraphicFilledEllipse::Draw
//
// Purpose:     Draw the ellipse
//
//
void DCWbGraphicFilledEllipse::Draw(HDC hDC)
{
    RECT    clipBox;
    HPEN    hPen;
    HPEN    hOldPen;
    HBRUSH  hBrush;
    HBRUSH  hOldBrush;
    int     iOldROP;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicFilledEllipse::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Select the pen
    hPen    = ::CreatePen(m_iPenStyle, 2, m_clrPenColor);
    hOldPen = SelectPen(hDC, hPen);

    hBrush = ::CreateSolidBrush(m_clrPenColor);
    hOldBrush = SelectBrush(hDC, hBrush);

    // Select the raster operation
    iOldROP = ::SetROP2(hDC, m_iPenROP);

    // Draw the rectangle
    ::Ellipse(hDC, m_boundsRect.left, m_boundsRect.top, m_boundsRect.right,
        m_boundsRect.bottom);

    ::SetROP2(hDC, iOldROP);

    SelectBrush(hDC, hOldBrush);
    if (hBrush != NULL)
    {
        ::DeleteBrush(hBrush);
    }

    SelectPen(hDC, hOldPen);
    if (hPen != NULL)
    {
        ::DeletePen(hPen);
    }

}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicFilledEllipse::CheckReallyHit(LPCRECT pRectHit)
{
    return( EllipseHit( &m_rect, FALSE, 0, pRectHit ) );
}



//
//
// Function:    DCWbGraphicText::DCWbGraphicText
//
// Purpose:     Initialize a new drawn text object.
//
//
DCWbGraphicText::DCWbGraphicText(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    m_hFontThumb = NULL;

	m_hFont = ::CreateFont(0,0,0,0,FW_NORMAL,0,0,0,0,OUT_TT_PRECIS,
				    CLIP_DFA_OVERRIDE,
				    DRAFT_QUALITY,
				    FF_SWISS,NULL);

	// Add an empty line to the text array
	strTextArray.Add(_T(""));

	// Show that the graphic has not changed
	m_bChanged = FALSE;

	m_nKerningOffset = 0; // added for bug 469
}

DCWbGraphicText::DCWbGraphicText(PWB_GRAPHIC pHeader)
                : DCWbGraphic()
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    ASSERT(pHeader != NULL);

    m_hFont = NULL;
    m_hFontThumb = NULL;

    // Note that we do everything in this constructor because of the
    // calls to ReadHeader and ReadExtra. If we let the DCWbGraphic base
    // constructor do it the wrong version of ReadExtra will be called
    // (the one in DCWbGraphic instead of the one in DCWbGraphicText).

    // Add an empty line to the text array
    strTextArray.Add(_T(""));

    // Read the data
    ReadHeader(pHeader);
    ReadExtra(pHeader);

    // Show that the graphic has not changed
    m_bChanged = FALSE;
}

DCWbGraphicText::DCWbGraphicText
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic()
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::DCWbGraphicText");

    // Note that we do everything in this constructor because of the
    // call to ReadExternal. If we let the DCWbGraphic base constructor
    // do it the wrong version of ReadExtra will be called (the one
    // in DCWbGraphic instead of the one in DCWbGraphicText);

    // Set up the page and graphic handle
    ASSERT(hPage != WB_PAGE_HANDLE_NULL);
    m_hPage =  hPage;

    ASSERT(hGraphic != NULL);
    m_hGraphic = hGraphic;

    m_hFont = NULL;
    m_hFontThumb = NULL;

    // Add an empty line to the text array
    strTextArray.Add(_T(""));

    // Read the data
    ReadExternal();

    // Show that the graphic has not changed
    m_bChanged = FALSE;
}

//
//
// Function:    DCWbGraphicText:: ~DCWbGraphicText
//
// Purpose:     Destruct a text object
//
//
DCWbGraphicText::~DCWbGraphicText()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::~DCWbGraphicText");

	// don't know if we are selected or not so just delete anyway
	if(g_pDraw != NULL && g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}

	// Ensure that the DC does not contain our fonts
	if(g_pDraw != NULL)
	{
		g_pDraw->UnPrimeFont(g_pDraw->GetCachedDC());
	}

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
        m_hFontThumb = NULL;
    }

    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}

StrCspn(char * string, char * control)
{
        char *str = string;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        /* Clear out bit map */
        for (count=0; count<32; count++)
                map[count] = 0;

        /* Set bits in control map */
        while (*ctrl)
        {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
                ctrl++;
        }
		count=0;
        map[0] |= 1;    /* null chars not considered */
        while (!(map[*str >> 3] & (1 << (*str & 7))))
        {
                count++;
                str++;
        }
        return(count);
}


//
//
// Function:    DCWbGraphicText::SetText
//
// Purpose:     Set the text of the object
//
//
void DCWbGraphicText::SetText(TCHAR * strText)
{
    // Remove all the current stored text
    strTextArray.RemoveAll();

    // Scan the text for carriage return and new-line characters
    int iNext = 0;
    int iLast = 0;
    int textSize = lstrlen(strText);
    TCHAR savedChar[1];

    //
    // In this case, we don't know how many lines there will be.  So we
    // use Add() from the StrArray class.
    //
    while (iNext < textSize)
    {
        // Find the next carriage return or line feed
        iNext += StrCspn(strText + iNext, "\r\n");

        // Extract the text before the terminator
        // and add it to the current list of text lines.

        savedChar[0] = strText[iNext];
        strText[iNext] = 0;
        strTextArray.Add((strText+iLast));
        strText[iNext] = savedChar[0];


        if (iNext < textSize)
        {
            // Skip the carriage return
            if (strText[iNext] == '\r')
                iNext++;

            // Skip a following new line (if there is one)
            if (strText[iNext] == '\n')
                iNext++;

            // Update the index of the start of the next line
            iLast = iNext;
        }
    }

    // Calculate the bounding rectangle for the new text
    CalculateBoundsRect();

    // Show that the graphic has not changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::SetText
//
// Purpose:     Set the text of the object
//
//
void DCWbGraphicText::SetText(const StrArray& _strTextArray)
{
    // Scan the text for carriage return and new-line characters
    int iSize = _strTextArray.GetSize();

    //
    // In this case we know how many lines, so set that # then use SetAt()
    // to stick text there.
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(iSize);

    int iNext = 0;
    for ( ; iNext < iSize; iNext++)
    {
        strTextArray.SetAt(iNext, _strTextArray[iNext]);
    }

    // Calculate the new bounding rectangle
    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::SetFont
//
// Purpose:     Set the font to be used for drawing
//
//
void DCWbGraphicText::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::SetFont");

    // Get the font details
    LOGFONT lfont;
    ::GetObject(hFont, sizeof(LOGFONT), &lfont);

    //
    // Pass the logical font into the SetFont() function
    //
    SetFont(&lfont);
}

//
//
// Function:    DCWbGraphicText::SetFont(metrics)
//
// Purpose:     Set the font to be used for drawing
//
//
void DCWbGraphicText::SetFont(LOGFONT *pLogFont, BOOL bReCalc )
{
    HFONT hOldFont;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::SetFont");

    // Ensure that the font can be resized by the zoom function
    // (proof quality prevents font scaling).
    pLogFont->lfQuality = DRAFT_QUALITY;

    //zap FontAssociation mode (bug 3258)
    pLogFont->lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Always work in cell coordinates to get scaling right
    TRACE_MSG(("Setting font height %d, width %d, face %s, family %d, precis %d",
        pLogFont->lfHeight,pLogFont->lfWidth,pLogFont->lfFaceName,
        pLogFont->lfPitchAndFamily, pLogFont->lfOutPrecision));

    hOldFont = m_hFont;

    m_hFont = ::CreateFontIndirect(pLogFont);
    if (!m_hFont)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // Calculate the line height for this font
	if(g_pDraw != NULL)
    {
		HDC     hDC = g_pDraw->GetCachedDC();

		g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}


    // We are now guaranteed to be able to delete the old font
    if (hOldFont != NULL)
    {
        ::DeleteFont(hOldFont);
    }

  // Set up the thumbnail font, forcing truetype if not currently TT
  if (!(m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE))
  {
      pLogFont->lfFaceName[0]    = 0;
      pLogFont->lfOutPrecision   = OUT_TT_PRECIS;
      TRACE_MSG(("Non-True type font"));
  }

    if (m_hFontThumb != NULL)
    {
        ::DeleteFont(m_hFontThumb);
    }
    m_hFontThumb = ::CreateFontIndirect(pLogFont);
    if (!m_hFontThumb)
    {
        // Could not create the font
        ERROR_OUT(("Failed to create thumbnail font"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
	    return;
    }

    // Calculate the bounding rectangle, accounting for the new font
    if( bReCalc )
	    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicText::GetTextABC
//
// Purpose:     Calculate the ABC numbers for a string of text
//																			
// COMMENT BY RAND: The abc returned is for the whole string, not just one
//					char. I.e, ABC.abcA is the offset to the first glyph in
//					the string, ABC.abcB is the sum of all of the glyphs and
//					ABC.abcC is the trailing space after the last glyph. 	
//					ABC.abcA + ABC.abcB + ABC.abcC is the total rendered 	
//					length including overhangs.								
//
// Note - we never use the A spacing so it is always 0
//
ABC DCWbGraphicText::GetTextABC( LPCTSTR pText,
                                int iStartX,
                                int iStopX)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::GetTextABC");
	ABC  abcResult;
    HDC  hDC;
	BOOL rc = FALSE;
	ABC  abcFirst;
	ABC  abcLast;
	BOOL zoomed = g_pDraw->Zoomed();
	int  nCharLast;
	int  i;
	LPCTSTR pScanStr;
	
	ZeroMemory( (PVOID)&abcResult, sizeof abcResult );
	ZeroMemory( (PVOID)&abcFirst, sizeof abcFirst );
	ZeroMemory( (PVOID)&abcLast, sizeof abcLast );

	// Get the standard size measure of the text
	LPCTSTR pABC = (pText + iStartX);
	int pABCLength = iStopX - iStartX;
	hDC = g_pDraw->GetCachedDC();
	g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);

	//
	// We must temporarily unzoom if we are currently zoomed since the
	// weird Windows font handling will not give us the same answer for
	// the text extent in zoomed mode for some TrueType fonts
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, 1, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), NULL);
    }

    DWORD size = ::GetTabbedTextExtent(hDC, pABC, pABCLength, 0, NULL);

	// We now have the advance width of the text
	abcResult.abcB = LOWORD(size);
	TRACE_MSG(("Basic text width is %d",abcResult.abcB));

	// Allow for C space (or overhang)
	if (iStopX > iStartX)
		{
		if (m_textMetrics.tmPitchAndFamily & TMPF_TRUETYPE)
			{
			if(GetSystemMetrics( SM_DBCSENABLED ))
				{
				// have to handle DBCS on both ends
				if( IsDBCSLeadByte( (BYTE)pABC[0] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					WORD wMultiChar = MAKEWORD( pABC[1], pABC[0] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcFirst);
					}
				else
					{
					// first char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );
					}

				// Check for DBCS as last char. Have to scan whole string to be sure
				pScanStr = pABC;
				nCharLast = 0;
				for( i=0; i<pABCLength; i++, pScanStr++ )
					{
					nCharLast = i;
					if( IsDBCSLeadByte( (BYTE)*pScanStr ) )
						{
						i++;
						pScanStr++;
						}
					}

				if( IsDBCSLeadByte( (BYTE)pABC[nCharLast] ) )
					{
					// pack multi byte char into a WORD for GetCharABCWidths
					ASSERT( (nCharLast+1) < pABCLength );
					WORD wMultiChar = MAKEWORD( pABC[nCharLast+1], pABC[nCharLast] );
					rc = ::GetCharABCWidths(hDC, wMultiChar, wMultiChar, &abcLast);
					}
				else
					{
					// last char is SBCS
					rc = ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
					}
				}
			else
				{
				// SBCS, no special fiddling, just call GetCharABCWidths()
				rc = ::GetCharABCWidths(hDC, pABC[0], pABC[0], &abcFirst );

				nCharLast = pABCLength-1;
				rc = rc && ::GetCharABCWidths(hDC, pABC[nCharLast], pABC[nCharLast], &abcLast );
				}

			TRACE_MSG(("abcFirst: rc=%d, a=%d, b=%d, c=%d",
						rc, abcFirst.abcA, abcFirst.abcB, abcFirst.abcC) );
			TRACE_MSG(("abcLast: rc=%d, a=%d, b=%d, c=%d",
						rc, abcLast.abcA, abcLast.abcB, abcLast.abcC) );
			}


		if( rc )
			{
			// The text was trutype and we got good abcwidths
			// Give the C space of the last characters from
			// the string as the C space of the text.
			abcResult.abcA = abcFirst.abcA;
			abcResult.abcC = abcLast.abcC;
			}
		else
			{
			//
			// Mock up C value for a non TT font by taking some of overhang as
			// the negative C value.
			//
			//TRACE_MSG(("Using overhang -%d as C space",m_textMetrics.tmOverhang/2));
			
			// Adjust B by -overhang to make update rect schoot
			// far enough to the left so that the toes of italic cap A's
			// don't get clipped. Ignore comment above.
			abcResult.abcB -= m_textMetrics.tmOverhang;
			}
		}

	//
	// If we temporarily unzoomed then restore it now
	//
	if (zoomed)
    {
		::ScaleViewportExtEx(hDC, g_pDraw->ZoomFactor(), 1, g_pDraw->ZoomFactor(), 1, NULL);
	}

	TRACE_MSG(("Final text width is %d, C space %d",abcResult.abcB,abcResult.abcC));

	return abcResult;
	}



//
//
// Function:    DCWbGraphicText::GetTextRectangle
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void DCWbGraphicText::GetTextRectangle(int iStartY,
                                        int iStartX,
                                        int iStopX,
                                        LPRECT lprc)
{
	// ABC structures for text sizing
	ABC abcText1;
	ABC abcText2;
	int iLeftOffset = 0;
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::GetTextRect");

	// Here we calculate the width of the text glyphs in which we
	// are interested. In case there are tabs involved we must start
	// with position 0 and get two lengths then subtract them

	abcText1 = GetTextABC(strTextArray[iStartY], 0, iStopX);

	if (iStartX > 0)
		{
		
		// The third param used to be iStartX-1 which is WRONG. It
		// has to point to the first char pos past the string
		// we are using.
		abcText2 = GetTextABC(strTextArray[iStartY], 0, iStartX);

		
		// Just use B part for offset. Adding A snd/or C to it moves the update
		// rectangle too far to the right and clips the char
		iLeftOffset = abcText2.abcB;
		}
	else
		{
		
		ZeroMemory( &abcText2, sizeof abcText2 );
		}

	//
	// We need to allow for A and C space in the bounding rectangle.  Use
	// ABS function just to make sure we get a large enough rectangle.
	//
	
	// Move A and C from original offset calc to here for width of update
	// rectangle. Add in tmOverhang (non zero for non-tt fonts) to compensate
	// for the kludge in GetTextABC()....THIS EDITBOX CODE HAS GOT TO GO...
	abcText1.abcB = abcText1.abcB - iLeftOffset +	
					  abs(abcText2.abcA) + abs(abcText2.abcC) +
					  abs(abcText1.abcA) + abs(abcText1.abcC) +
					  m_textMetrics.tmOverhang;

	TRACE_DEBUG(("Left offset %d",iLeftOffset));
	TRACE_DEBUG(("B width now %d",abcText1.abcB));

	// Build the result rectangle.
	// Note that we never return an empty rectangle. This allows for the
	// fact that the Windows rectangle functions will ignore empty
	// rectangles completely. This would cause the bounding rectangle
	// calculation (for instance) to go wrong if the top or bottom lines
	// in a text object were empty.
	int iLineHeight = m_textMetrics.tmHeight + m_textMetrics.tmExternalLeading;

    lprc->left = 0;
    lprc->top = 0;
    lprc->right = max(1, abcText1.abcB);
    lprc->bottom = iLineHeight;
    ::OffsetRect(lprc, iLeftOffset, iLineHeight * iStartY);

	// rect is the correct width at this point but it might need to be schooted to
	// the left a bit to allow for kerning of 1st letter (bug 469)
	if( abcText1.abcA < 0 )
	{
        ::OffsetRect(lprc, abcText1.abcA, 0);
		m_nKerningOffset = -abcText1.abcA;
	}
	else
		m_nKerningOffset = 0;

    POINT   pt;
    GetPosition(&pt);
    ::OffsetRect(lprc, pt.x, pt.y);
}

//
//
// Function:    DCWbGraphicText::CalculateRect
//
// Purpose:     Calculate the bounding rectangle of a portion of the object
//
//
void DCWbGraphicText::CalculateRect(int iStartX,
                                     int iStartY,
                                     int iStopX,
                                     int iStopY,
                                    LPRECT lprcResult)
{
    RECT    rcResult;
    RECT    rcT;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::CalculateRect");

    //
    // NOTE:
    // We must use an intermediate rectangle, so as not to disturb the
    // contents of the passed-in one until done.  lprcResult may be pointing
    // to the current bounds rect, and we call functions from here that
    // may need its current value.
    //

    // Initialize the result rectangle
    ::SetRectEmpty(&rcResult);

    // Allow for special limit values and ensure that the start and stop
    // character positions are in range.
    if (iStopY == LAST_LINE)
    {
        iStopY = strTextArray.GetSize() - 1;
    }
    iStopY = min(iStopY, strTextArray.GetSize() - 1);
    iStopY = max(iStopY, 0);

    if (iStopX == LAST_CHAR)
    {
        iStopX = lstrlen(strTextArray[iStopY]);
    }
    iStopX = min(iStopX, lstrlen(strTextArray[iStopY]));
    iStopX = max(iStopX, 0);

    // Loop through the text strings, adding each to the rectangle
    for (int iIndex = iStartY; iIndex <= iStopY; iIndex++)
    {
        int iLeftX = ((iIndex == iStartY) ? iStartX : 0);
        int iRightX = ((iIndex == iStopY)
                        ? iStopX : lstrlen(strTextArray[iIndex]));

        GetTextRectangle(iIndex, iLeftX, iRightX, &rcT);
        ::UnionRect(&rcResult, &rcResult, &rcT);
    }

    *lprcResult = rcResult;
}

//
//
// Function:    DCWbGraphicText::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the object
//
//
void DCWbGraphicText::CalculateBoundsRect(void)
{
    // Set the new bounding rectangle
    CalculateRect(0, 0, LAST_CHAR, LAST_LINE, &m_boundsRect);
}

//
//
// Function: DCWbGraphicText::Draw
//
// Purpose : Draw the object onto the specified DC
//
//
void DCWbGraphicText::Draw(HDC hDC, BOOL thumbNail)
{
    RECT        clipBox;
    BOOL        dbcsEnabled = GetSystemMetrics(SM_DBCSENABLED);
    INT		    *tabArray;
    UINT        ch;
    int         i,j;
    BOOL        zoomed    = g_pDraw->Zoomed();
    int		    oldBkMode = 0;
    int         iIndex    = 0;
    POINT       pointPos;
	int		    nLastTab;
	ABC		    abc;
    int		    iLength;
    TCHAR *     strLine;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::Draw");

    //
    // Only draw anything if the bounding rectangle intersects the current
    // clip box.
    //
    if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
        WARNING_OUT(("Failed to get clip box"));
	}
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    //
    // Select the font.
    //
    if (thumbNail)
	{
        TRACE_MSG(("Using thumbnail font"));
        g_pDraw->PrimeFont(hDC, m_hFontThumb, &m_textMetrics);
	}
    else
	{
        TRACE_MSG(("Using standard font"));
        g_pDraw->PrimeFont(hDC, m_hFont, &m_textMetrics);
	}

    //
    // Set the color and mode for drawing.
    //
    ::SetTextColor(hDC, m_clrPenColor);

    //
    // Set the background to be transparent
    //
    oldBkMode = ::SetBkMode(hDC, TRANSPARENT);

    //
    // Calculate the bounding rectangle, accounting for the new font.
    //
    CalculateBoundsRect();

    //
    // Get the start point for the text.
    //
    pointPos.x = m_boundsRect.left + m_nKerningOffset;
    pointPos.y = m_boundsRect.top;

    //
    // Loop through the text strings drawing each as we go.
    //
    for (iIndex = 0; iIndex < strTextArray.GetSize(); iIndex++)
	{
        //
        // Get a reference to the line to be printed for convenience.
        //
        strLine  = (LPTSTR)strTextArray[iIndex];
        iLength  = lstrlen(strLine);

        //
        // Only draw the line if there are any characters in it.
        //
        if (iLength > 0)
	  	{
            if (zoomed)
	  		{
				// if new fails just skip it
				tabArray = new INT[iLength+1];
				if( tabArray == NULL )
                {
                    ERROR_OUT(("Failed to allocate tabArray"));
					continue;
                }

				// We are zoomed. Must calculate char spacings
				// ourselfs so that they end up proportionally
				// in the right places. TabbedTextOut will not
				// do this right so we have to use ExtTextOut with
				// a tab array.

				// figure out tab array
                j = 0;
				nLastTab = 0;
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i]; //Don't worry about DBCS here...
					abc = GetTextABC(strLine, 0, i);

					if( j > 0 )
						tabArray[j-1] = abc.abcB - nLastTab;

					nLastTab = abc.abcB;
					j++;
	  			}

				// Now, strip out any tab chars so they don't interact
				// in an obnoxious manner with the tab array we just
				// made and so they don't make ugly little
				// blocks when they are drawn.
                for (i=0; i < iLength; i++)
	  			{
                    ch = strLine[(int)i];
                    if ((dbcsEnabled) && (IsDBCSLeadByte((BYTE)ch)))
						i++;
					else
                    if(strLine[(int)i] == '\t')
                        strLine[i] = ' '; // blow off tab, tab array
											   // will compensate for this
	  			}

				// do it
                ::ExtTextOut(hDC, pointPos.x,
                                pointPos.y,
                                0,
                                NULL,
                                strLine,
                                iLength,
                                tabArray);

				delete [] tabArray;
			}
            else
			{
                POINT   ptPos;

                GetPosition(&ptPos);

				// Not zoomed, just do it
				::TabbedTextOut(hDC, pointPos.x,
								 pointPos.y,
								 strLine,
								 iLength,
								 0,
								 NULL,
                                 ptPos.x);
			}
		}

        //
        // Move to the next line.
        //
        pointPos.y += (m_textMetrics.tmHeight);
	}

    //
    // Restore the old background mode.
    //
    ::SetBkMode(hDC, oldBkMode);
    g_pDraw->UnPrimeFont(hDC);
}



//
//
// Function:    DCWbGraphicText::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicText::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::CalculateExternalLength");

    // Loop through the text strings, adding the size of each as we go
    DWORD length = sizeof(WB_GRAPHIC_TEXT);
    int iCount = strTextArray.GetSize();
    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        // Allow extra bytes per string for NULL term
        length += lstrlen(strTextArray[iIndex]) + 2;
    }

    return length;
}

//
//
// Function:    DCWbGraphicText::WriteExtra
//
// Purpose:     Write the extra (non-header) data to the flat representation
//              of the graphic.
//
//
void DCWbGraphicText::WriteExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::WriteExtra");

    // Allocate the memory
    PWB_GRAPHIC_TEXT pText = (PWB_GRAPHIC_TEXT) pHeader;

    // Get the font face name
    LOGFONT lfont;

    ::GetObject(m_hFont, sizeof(LOGFONT), &lfont);

    // Copy the face name into the flat object representation
    // The other information comes from the logical font details
    TRACE_MSG(("Font details height %d, avwidth %d, family %d, face %s",
                                                  lfont.lfHeight,
                                                  lfont.lfWidth,
                                                  lfont.lfPitchAndFamily,
                                                  lfont.lfFaceName));
  _tcscpy(pText->faceName, lfont.lfFaceName);

  pText->charHeight       = (short)lfont.lfHeight;
  pText->averageCharWidth = (short)lfont.lfWidth;
  pText->strokeWeight     = (short)lfont.lfWeight;
  pText->italic           = lfont.lfItalic;
  pText->underline        = lfont.lfUnderline;
  pText->strikeout        = lfont.lfStrikeOut;
  pText->pitch            = lfont.lfPitchAndFamily;



  //COMMENT BY RAND
  // Original DCL apps ignore WB_GRAPHIC_TEXT::codePage. I am using it here
  // to pass around the fonts script (character set). This might change later.
  // Apps that ignore this have set it to 0 which will be interpreted as an
  // ANSI_CHARSET.
  pText->codePage         = lfont.lfCharSet;

    // Loop through the text strings, adding each as we go
    char* pDest = pText->text;
    int iCount = strTextArray.GetSize();
    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        _tcscpy(pDest, strTextArray[iIndex]);
        pDest += lstrlen(strTextArray[iIndex]);

        // Add the null terminator
        *pDest++ = '\0';
    }

    // Save the number of strings
    pText->stringCount = (TSHR_UINT16)iCount;
}

//
//
// Function:    DCWbGraphicText::ReadExtra
//
// Purpose:     Read the extra (non-header) data from the flat
//              representation of the graphic.
//
//
void DCWbGraphicText::ReadExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicText::ReadExtra");

  // Allocate the memory
  PWB_GRAPHIC_TEXT pText = (PWB_GRAPHIC_TEXT) pHeader;

  // Get the font details
  LOGFONT lfont;

  lfont.lfHeight            = (short)pText->charHeight;
//
  lfont.lfWidth             = pText->averageCharWidth;
  lfont.lfEscapement        = 0;
  lfont.lfOrientation       = 0;
  lfont.lfWeight            = pText->strokeWeight;
  lfont.lfItalic            = pText->italic;
  lfont.lfUnderline         = pText->underline;
  lfont.lfStrikeOut         = pText->strikeout;

  //COMMENT BY RAND
  // Original DCL apps ignore WB_GRAPHIC_TEXT::codePage. I am using it here
  // to pass around the fonts script (character set). This might change later.
  // Apps that ignore this have set it to 0 which will be interpreted as an
  // ANSI_CHARSET.
  lfont.lfCharSet			= (BYTE)pText->codePage;


  lfont.lfOutPrecision      = OUT_DEFAULT_PRECIS;
  lfont.lfClipPrecision     = CLIP_DEFAULT_PRECIS | CLIP_DFA_OVERRIDE;
  lfont.lfQuality           = DRAFT_QUALITY;
  lfont.lfPitchAndFamily    = pText->pitch;
  _tcscpy(lfont.lfFaceName, pText->faceName);
  TRACE_MSG(("Setting height to %d, width %d, pitch %d, face %s",
  pText->charHeight, pText->averageCharWidth, pText->pitch, pText->faceName));

    // Loop through the text strings, retrieving each as we go
    TCHAR* pString = pText->text;			
    int iCount = pText->stringCount;

    // Remove all the current stored text
    strTextArray.RemoveAll();
    strTextArray.SetSize(iCount);

    for (int iIndex = 0; iIndex < iCount; iIndex++)
    {
        strTextArray.SetAt(iIndex, pString);		
        pString += lstrlen(pString);

        // Skip the null terminator
        pString++;
    }

    // Set the current font
    SetFont(&lfont);

}

//
//
// Function:    InvalidateMetrics
//
// Purpose:     Mark the metrics need retrieving again
//
//
void DCWbGraphicText::InvalidateMetrics(void)
{
}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//	
BOOL DCWbGraphicText::CheckReallyHit(LPCRECT pRectHit )
{
    return( TRUE );
}




// version of Position() that compensates for kerning (bug 469)
void DCWbGraphicText::GetPosition(LPPOINT lppt)
{
    lppt->x = m_boundsRect.left + m_nKerningOffset;
    lppt->y = m_boundsRect.top;
}





//
//
// Function:    DCWbGraphicDIB::DCWbGraphicDIB
//
// Purpose:     Initialize a new drawn bitmap object.
//
//
DCWbGraphicDIB::DCWbGraphicDIB(void)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}

DCWbGraphicDIB::DCWbGraphicDIB(PWB_GRAPHIC pHeader)
               : DCWbGraphic(pHeader)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}

DCWbGraphicDIB::DCWbGraphicDIB
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
) : DCWbGraphic(hPage, hGraphic)
{
    // Show that we have no internal image
    m_lpbiImage = NULL;
}


//
//
// Function:    DCWbGraphicDIB::~DCWbGraphicDIB
//
// Purpose:     Destruct a drawn bitmap object.
//
//
DCWbGraphicDIB::~DCWbGraphicDIB(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::~DCWbGraphicDIB");

	// don't know if we are selected or not so just delete anyway
	if(g_pDraw->m_pMarker != NULL)
	{
		g_pDraw->m_pMarker->DeleteMarker( this );
	}

	DeleteImage();
}


//
//
// Function:    DCWbGraphicDIB::SetImage
//
// Purpose:     Set the image of the object
//
//
void DCWbGraphicDIB::SetImage(LPBITMAPINFOHEADER lpbi)
{
    // Delete any current bits
    DeleteImage();

    // Save the DIB bits--this is a COPY we now own
    m_lpbiImage = lpbi;

    // Update the bounds rectangle
    CalculateBoundsRect();

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicDIB::CalculateBoundsRect
//
// Purpose:     Calculate the bounding rectangle of the bitmap
//
//
void DCWbGraphicDIB::CalculateBoundsRect()
{
    // If there is no bitmap set up, the bounding rectangle is empty
    if (m_lpbiImage == NULL)
    {
        ::SetRectEmpty(&m_boundsRect);
    }
    else
    {
        // Calculate the bounding rectangle from the size of the bitmap
        m_boundsRect.right = m_boundsRect.left + m_lpbiImage->biWidth;
        m_boundsRect.bottom = m_boundsRect.top + m_lpbiImage->biHeight;
    }
}

//
//
// Function:    DCWbGraphicDIB::CalculateExternalLength
//
// Purpose:     Return the length of the external representation of the
//              graphic.
//
//
DWORD DCWbGraphicDIB::CalculateExternalLength(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::CalculateExternalLength");

    // Use the internal representation to calculate the external length.
    DWORD dwLength = sizeof(WB_GRAPHIC_DIB);

    if (m_lpbiImage != NULL)
    {
        dwLength += DIB_TotalLength(m_lpbiImage);
    }
    else
    {
        // If we have got an external form already, use its length
        if (m_hGraphic != NULL)
        {
            dwLength = m_dwExternalLength;
        }
    }

    return dwLength;
}

//
//
// Function:    DCWbGraphicDIB::WriteExtra
//
// Purpose:     Write the data above and beyond the header to the pointer
//              passed.
//
//
void DCWbGraphicDIB::WriteExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::WriteExtra");

    // Nothing more to do if we do not have an image
    if (m_lpbiImage != NULL)
    {
        // Copy the data into place
        memcpy(((BYTE *) pHeader) + pHeader->dataOffset, m_lpbiImage,
            DIB_TotalLength(m_lpbiImage));
    }
}


//
//
// Function:    DCWbGraphicDIB::ReadExtra
//
// Purpose:     Read the data above and beyond the header to the pointer
//              passed.
//
//

//
// DCWbGraphicDIB does not have a ReadExtra function.  The Draw function
// uses the external data (if there is any) and the local data if there is
// not.
//

//
//
// Function:    DCWbGraphicDIB::CopyExtra
//
// Purpose:     Copy the data above and beyond the header into this object.
//
//
void DCWbGraphicDIB::CopyExtra(PWB_GRAPHIC pHeader)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::CopyExtra");

    // Get a pointer to the DIB data
    LPBITMAPINFOHEADER lpbi;
    lpbi = (LPBITMAPINFOHEADER) (((BYTE *) pHeader) + pHeader->dataOffset);

    // Make a DIB copy
    ASSERT(m_lpbiImage == NULL);
    m_lpbiImage = DIB_Copy(lpbi);

    // Show that the graphic has changed
    m_bChanged = TRUE;
}

//
//
// Function:    DCWbGraphicDIB::FromScreenArea
//
// Purpose:     Set the content of the object from an area of the screen
//
//
void DCWbGraphicDIB::FromScreenArea(LPCRECT lprcScreen)
{
    LPBITMAPINFOHEADER lpbiNew;

    lpbiNew = DIB_FromScreenArea(lprcScreen);
    if (lpbiNew != NULL)
    {
        // Set this as our current bits
        SetImage(lpbiNew);
	}
	else
	{
        ::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
    }
}


//
//
// Function:    DCWbGraphicDIB::DeleteImage
//
// Purpose:     Delete the internal image
//
//
void DCWbGraphicDIB::DeleteImage(void)
{
    // If we have DIB bits, delete
    if (m_lpbiImage != NULL)
    {
        ::GlobalFree((HGLOBAL)m_lpbiImage);
        m_lpbiImage = NULL;
    }

    // Show our contents have changed
    m_bChanged = TRUE;
}


//
//
// Function:    DCWbGraphicDIB::GetDIBData
//
// Purpose:     Return a pointer to the DIB data
//
//
BOOL DCWbGraphicDIB::GetDIBData(HOLD_DATA& hold)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::GetDIBData");

    // Pointer to image data (set up below depending on whether
    // we have an internal or external image).
    hold.lpbi = NULL;
    hold.pHeader = NULL;

    // Draw depending on whether the DIB data is internal or external
    if (m_hGraphic == NULL)
    {
        // Do nothing if we do not have an image at all
        if (m_lpbiImage != NULL)
        {
            hold.lpbi = m_lpbiImage;
        }
    }
    else
    {
        // Lock the object data in the page
        hold.pHeader = (PWB_GRAPHIC) PG_GetData(m_hPage, m_hGraphic);
        if (hold.pHeader != NULL)
        {
            hold.lpbi = (LPBITMAPINFOHEADER) (((BYTE *) hold.pHeader)
                                              + hold.pHeader->dataOffset);
        }
    }

    return (hold.lpbi != NULL);
}

//
//
// Function:    DCWbGraphicDIB::ReleaseDIBData
//
// Purpose:     Release DIB data previously obtained with GetDIBData
//
//
void DCWbGraphicDIB::ReleaseDIBData(HOLD_DATA& hold)
{
    if ((m_hGraphic != NULL) && (hold.pHeader != NULL))
    {
        // Release external memory
        g_pwbCore->WBP_GraphicRelease(m_hPage, m_hGraphic, hold.pHeader);
        hold.pHeader = NULL;
    }

    // Reset the hold bitmap info pointer
    hold.lpbi = NULL;
}

//
//
// Function:    DCWbGraphicDIB::Draw
//
// Purpose:     Draw the object onto the specified DC
//
//
void DCWbGraphicDIB::Draw(HDC hDC)
{
    RECT    clipBox;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicDIB::Draw");

    // Only draw anything if the bounding rectangle intersects
    // the current clip box.
    if (::GetClipBox(hDC, &clipBox) == ERROR)
    {
        WARNING_OUT(("Failed to get clip box"));
    }
    else if (!::IntersectRect(&clipBox, &clipBox, &m_boundsRect))
    {
        TRACE_MSG(("No clip/bounds intersection"));
        return;
    }

    // Pointer to image data (set up below depending on whether
    // we have an internal or external image.
    HOLD_DATA hold;
    if (GetDIBData(hold))
    {
        // Set the stretch mode to be used so that scan lines are deleted
        // rather than combined. This will tend to preserve color better.
        int iOldStretchMode = ::SetStretchBltMode(hDC, STRETCH_DELETESCANS);

        // Draw the bitmap
        BOOL bResult = ::StretchDIBits(hDC,
                         m_boundsRect.left,
                         m_boundsRect.top,
                         m_boundsRect.right - m_boundsRect.left,
                         m_boundsRect.bottom - m_boundsRect.top,
                         0,
                         0,
                         (UINT) hold.lpbi->biWidth,
                         (UINT) hold.lpbi->biHeight,
                         (VOID FAR *) DIB_Bits(hold.lpbi),
                         (LPBITMAPINFO)hold.lpbi,
                         DIB_RGB_COLORS,
                         SRCCOPY);

        // Restore the stretch mode
        ::SetStretchBltMode(hDC, iOldStretchMode);

        // Release external memory
        ReleaseDIBData(hold);
    }

}



//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DCWbGraphicDIB::CheckReallyHit(LPCRECT pRectHit)
{
    return( TRUE );
}




ObjectTrashCan::~ObjectTrashCan(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::~ObjectTrashCan");

	BurnTrash();
}




BOOL ObjectTrashCan::GotTrash( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::GotTrash");

	return(!Trash.IsEmpty());
}





void ObjectTrashCan::BurnTrash( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::BurnTrash");

	int nObjects;
	int i;

	// zap objects
    POSITION pos = Trash.GetHeadPosition();
    while (pos != NULL)
    {
		delete Trash.GetNext(pos);
    }


	// zap pointers
	EmptyTrash();

	}





void ObjectTrashCan::CollectTrash( DCWbGraphic *pGObj )
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::CollectTrash");

		Trash.AddTail(pGObj); // stuff it in the sack
		m_hPage = pGObj->Page();
}





void
	ObjectTrashCan::EmptyTrash( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::EmptyTrash");

	// zap pointers but leave objects scattered about the room
	Trash.EmptyList();

	}





void ObjectTrashCan::AddToPageLast
(
    WB_PAGE_HANDLE   hPage
)
{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::AddToPageLast");

	int nObjects;
	int i;

	POSITION posNext = Trash.GetHeadPosition();
	while( posNext != NULL )
	{
		((DCWbGraphic *)(Trash.GetNext(posNext)))->AddToPageLast(hPage);
	}
}




void
	ObjectTrashCan::SelectTrash( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "ObjectTrashCan::SelectTrash");

	int nObjects;
	int i;
	BOOL bForceAdd;
	DCWbGraphic *pGObj;

		// Zap current selection with first object and then add remaining
		// objects to current selection
		bForceAdd = FALSE;
		POSITION posNext = Trash.GetHeadPosition();
		while( posNext != NULL )
		{
			pGObj = (DCWbGraphic *)(Trash.GetNext(posNext));
            g_pMain->m_drawingArea.SelectGraphic( pGObj, TRUE, bForceAdd );

			bForceAdd = TRUE;
		}

	}










CPtrToPtrList::CPtrToPtrList( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::CPtrToPtrList");

	}// CPtrToPtrList::CPtrToPtrList




CPtrToPtrList::~CPtrToPtrList( void )
{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::~CPtrToPtrList");

	RemoveAll();

}// CPtrToPtrList::~CPtrToPtrList



void
	CPtrToPtrList::RemoveAll( void )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::RemoveAll");

	POSITION   pos;
	stPtrPair *pPp;

	// clean up pairs
	pos = GetHeadPosition();
	while( pos != NULL )
	{
		pPp = (stPtrPair *)GetNext( pos );
		if( pPp != NULL )
			delete pPp;
	}
	COBLIST::EmptyList();
	}// CPtrToPtrList::~CPtrToPtrList










void
	CPtrToPtrList::SetAt( void *key, void *newValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::SetAt");

	stPtrPair *pPp;

	// see if key is already there
	pPp = FindMainThingPair( key, NULL );
	if( pPp != NULL )
		{
		// it's there, we're just updating its value
		pPp->pRelatedThing = newValue;
		}
	else
		{
		// this is a new entry
		pPp = new stPtrPair;
		if( pPp != NULL )
	    {
			pPp->pMainThing = key;
			pPp->pRelatedThing = newValue;

			AddTail(pPp);
		}
		else
		{
		    ERROR_OUT( ("CPtrToPtrList: can't alloc stPtrPair") );
		}
	}

	}// CPtrToPtrList::SetAt










BOOL
	CPtrToPtrList::RemoveKey( void *key )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::RemoveKey");

	POSITION pos;
	stPtrPair *pPp;

	pPp = FindMainThingPair( key, &pos );
	if( pPp != NULL )
		{
		RemoveAt( pos );
		delete pPp;
		return( TRUE );
		}
	else
		return( FALSE );

}// CPtrToPtrList::RemoveKey





void
	CPtrToPtrList::GetNextAssoc( POSITION &rNextPosition, void *&rKey, void *&rValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::GetNextAssoc");

	stPtrPair *pPp;

	pPp = (stPtrPair *)GetNext( rNextPosition );
	if( pPp != NULL )
		{
		rKey = pPp->pMainThing;
		rValue = pPp->pRelatedThing;
		}
	else
		{
		rKey = NULL;
		rValue = NULL;
		}

	}// CPtrToPtrList::GetNextAssoc










BOOL
	CPtrToPtrList::Lookup( void *key, void *&rValue )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::Lookup");

	stPtrPair *pPp;

	pPp = FindMainThingPair( key, NULL );
	if( pPp != NULL )
		{
		rValue = pPp->pRelatedThing;
		return( TRUE );
		}
	else
		{
		rValue = NULL;
		return( FALSE );
		}

	}// CPtrToPtrList::Lookup










CPtrToPtrList::stPtrPair *
	CPtrToPtrList::FindMainThingPair( void *pMainThing, POSITION *pPos )
	{
	MLZ_EntryOut(ZONE_FUNCTION, "CPtrToPtrList::FindMainThingPair");

	POSITION   pos;
	POSITION   lastpos;
	stPtrPair *pPp;

	if( pPos != NULL )
		*pPos = NULL;

	// look for pair containing pMainThing
	pos = GetHeadPosition();
	while( pos != NULL )
		{
		lastpos = pos;
		pPp = (stPtrPair *)GetNext( pos );
		if( pPp->pMainThing == pMainThing )
			{
			if( pPos != NULL )
				*pPos = lastpos;

			return( pPp );
			}
		}

	// didn't find it
	return( NULL );

	}// CPtrToPtrList::FindMainThingPair



#define ARRAY_INCREMENT 0x200

DCDWordArray::DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::DCDWordArray");
	m_Size = 0;
	m_MaxSize = ARRAY_INCREMENT;
	m_pData = new POINT[ARRAY_INCREMENT];
    if (!m_pData)
    {
        ERROR_OUT(("Failed to allocate m_pData POINT array"));
    }
}

DCDWordArray::~DCDWordArray()
{
	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::~DCDWordArray");

	delete[] m_pData;
}

//
// We need to increase the size of the array
//
BOOL DCDWordArray::ReallocateArray(void)
{
	POINT *pOldArray =  m_pData;
	m_pData = new POINT[m_MaxSize];
	
	if(m_pData)
	{
		TRACE_DEBUG((">>>>>Increasing size of array to hold %d points", m_MaxSize));
	
		// copy new data from old
		memcpy( m_pData, pOldArray, (m_Size) * sizeof(POINT));

		TRACE_DEBUG(("Deleting array of points %x", pOldArray));
		delete[] pOldArray;
		return TRUE;
	}
	else
	{
        ERROR_OUT(("Failed to allocate new POINT array of size %d", m_MaxSize));
		m_pData = pOldArray;
		return FALSE;
	}
}

//
// Add a new point to the array
//
void DCDWordArray::Add(POINT point)
{

	MLZ_EntryOut(ZONE_FUNCTION, "DCDWordArray::Add");
	TRACE_DEBUG(("Adding point(%d,%d) at %d", point.x, point.y, m_Size));
	TRACE_DEBUG(("Adding point at %x", &m_pData[m_Size]));

	if(m_pData == NULL)
	{
		return;
	}
	
	m_pData[m_Size].x = point.x;
	m_pData[m_Size].y = point.y;
	m_Size++;

	//
	// if we want more points, we need to re allocate the array
	//
	if(m_Size == m_MaxSize)
	{
		m_MaxSize +=ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			m_Size--;
		}
	}
}

//
// Return the number of points in the array
//
UINT DCDWordArray::GetSize(void)
{
	return m_Size;
}

//
// Sets the size of the array
//
void DCDWordArray::SetSize(UINT size)
{
	int newSize;
	//
	// if we want more points, we need to re allocate the array
	//
	if (size > m_MaxSize)
	{
		m_MaxSize= ((size/ARRAY_INCREMENT)+1)*ARRAY_INCREMENT;
		if(ReallocateArray() == FALSE)
		{
			return;
		}
	}
	m_Size = size;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\page.cpp ===
//
// PAGE.CPP
// WB Page Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
//
// Function:    GetData
//
// Purpose:     Get a pointer to the external representation of a graphic
//
//
PWB_GRAPHIC PG_GetData
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetData");

    // Get the pointer from the core
    PWB_GRAPHIC  pHeader = NULL;

    UINT uiReturn = g_pwbCore->WBP_GraphicGet(hPage, hGraphic, &pHeader);
    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
    }

    return pHeader;
}


//
//
// Function:    AllocateGraphic
//
// Purpose:     Allocate memory for a graphic
//
//
PWB_GRAPHIC PG_AllocateGraphic
(
    WB_PAGE_HANDLE      hPage,
    DWORD               length
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_AllocateGraphic");

    // Release the object (function never fails)
    PWB_GRAPHIC pHeader = NULL;

    UINT uiReturn = g_pwbCore->WBP_GraphicAllocate(hPage, length, &pHeader);
    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
    }

    return pHeader;
}


//
//
// Function:    First (crect)
//
// Purpose:     Return the first object in the page (bottommost Z-order)
//              that intersects the bounding rectangle
//
//
//CHANGED BY RAND - for object hit check
DCWbGraphic* PG_First
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    LPCRECT             pRectUpdate,
    BOOL                bCheckReallyHit
)
{
    UINT                uiReturn = 0;
    BOOL         empty = TRUE;
    PWB_GRAPHIC  pHeader = NULL;
    DCWbGraphic* pGraphic = NULL;
    RECT         rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_First");

    uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, NULL, FIRST, phGraphic);
    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(pGraphic);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    if (pRectUpdate == NULL)
    {
        // Read the graphic
        // We have got what we want
        TRACE_MSG(("Got the object we want"));
        pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);
    }
    else
    {
        pHeader = PG_GetData(hPage, *phGraphic);
		if(pHeader == NULL)
		{
			return NULL;
		}

        rc.left   = pHeader->rectBounds.left;
        rc.top    = pHeader->rectBounds.top;
        rc.right  = pHeader->rectBounds.right;
        rc.bottom = pHeader->rectBounds.bottom;
        empty = !::IntersectRect(&rc, &rc, pRectUpdate);

        g_pwbCore->WBP_GraphicRelease(hPage, *phGraphic, pHeader);

        if (empty)
        {
            TRACE_MSG(("First object not needed - go to next"));
            pGraphic = PG_Next(hPage, phGraphic, pRectUpdate, bCheckReallyHit);
        }
        else
        {
            pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);

            if( bCheckReallyHit && (pGraphic != NULL) )
            {
                // do a real object hit test since we
                // know its bounding rect has hit
                if( !pGraphic->CheckReallyHit( pRectUpdate ) )
                {
                    delete pGraphic;
                    pGraphic = PG_Next(hPage, phGraphic, pRectUpdate, TRUE); // look again
                }
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    Next
//
// Purpose:     Return the next graphic in the page (going up through the
//              Z-order).  GetFirst must have been called before this
//              member.
//
DCWbGraphic* PG_Next
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    LPCRECT     pRectUpdate,
    BOOL        bCheckReallyHit
)
{
    UINT        uiReturn = 0;
    BOOL         empty = TRUE;
    PWB_GRAPHIC  pHeader = NULL;
    DCWbGraphic* pGraphic = NULL;
    RECT        rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Next");

    while (uiReturn == 0)
    {
        uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, *phGraphic,
                AFTER, phGraphic);
        if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
        {
            return(pGraphic);
        }
        else if (uiReturn != 0)
        {
            // Throw an exception
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		    return NULL;
        }

        if (pRectUpdate == NULL)
        {
            // Read the graphic
            // We have got what we want
            TRACE_MSG(("Got the object we want"));
            pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);
            break;
        }
        else
        {
            pHeader = PG_GetData(hPage, *phGraphic);

            rc.left   = pHeader->rectBounds.left;
            rc.top    = pHeader->rectBounds.top;
            rc.right  = pHeader->rectBounds.right;
            rc.bottom = pHeader->rectBounds.bottom;
            empty = !::IntersectRect(&rc, &rc, pRectUpdate);

            g_pwbCore->WBP_GraphicRelease(hPage, *phGraphic, pHeader);
            if (!empty)
            {
                TRACE_MSG(("Found the one we want - breaking out"));
                pGraphic = DCWbGraphic::ConstructGraphic(hPage, *phGraphic);

                if( bCheckReallyHit && (pGraphic != NULL) )
                {
                    // do a real object hit test since we
                    // know its bounding rect has hit
                    if( pGraphic->CheckReallyHit( pRectUpdate ) )
                        break;
                    else
                    {
                        delete pGraphic; // look again
                        pGraphic = NULL;
                    }
                }
                else
                    break; // found it
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    After
//
// Purpose:     Return the graphic after the specified graphic (going up
//              through the Z-order).
//
//
DCWbGraphic* PG_After
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_After");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, graphic.Handle(),
            AFTER, &hGraphic);

    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(NULL);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
		return NULL;
    }

    // Read the graphic
    return(DCWbGraphic::ConstructGraphic(hPage, hGraphic));
}

//
//
// Function:    Before
//
// Purpose:     Return the graphic before the specified graphic (going down
//              through the Z-order).
//
//
DCWbGraphic* PG_Before
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_Before");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, graphic.Handle(),
            BEFORE, &hGraphic);

    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(NULL);
    }

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    // Read the graphic
    return(DCWbGraphic::ConstructGraphic(hPage, hGraphic));
}



//
//
// Function:    FirstPointer
//
// Purpose:     Return the first remote pointer object that is currently
//              active on this page.
//
//
DCWbGraphicPointer* PG_FirstPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT * ppUserNext
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_FirstPointer");

    // Get the handle of the first user
    g_pwbCore->WBP_PersonHandleFirst(ppUserNext);

    // Return the next pointer that is active on this page
    return PG_LookForPointer(hPage, *ppUserNext);
}

//
//
// Function:    LocalPointer
//
// Purpose:     Return the local user's pointer, if it is active on this
//              page.
//
//
DCWbGraphicPointer* PG_LocalPointer
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_LocalPointer");

    DCWbGraphicPointer* pResult = NULL;

    // Get the local user
    POM_OBJECT    hUser;
    g_pwbCore->WBP_PersonHandleLocal(&hUser);
    WbUser* pUser = WB_GetUser(hUser);

    // Check whether the pointer is active, and is on this page
    if ((pUser != NULL)             &&
        (pUser->IsUsingPointer())   &&
        (pUser->PointerPage() == hPage))
    {
        pResult = pUser->GetPointer();
    }

    // Return the next pointer that is active on this page
    return pResult;
}

//
//
// Function:    NextPointer
//
// Purpose:     Return the next pointer in use.
//              FirstPointer must have been called before this member.
//
//
DCWbGraphicPointer* PG_NextPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT *    ppUserNext
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_NextPointer");

    DCWbGraphicPointer* pPointer;

    // Go forward one from the current user
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext(*ppUserNext, ppUserNext);
    if (uiReturn == 0)
    {
        pPointer = PG_LookForPointer(hPage, *ppUserNext);
    }
    else
    {
        if (uiReturn != WB_RC_NO_SUCH_PERSON)
        {
            ERROR_OUT(("Error getting next user handle"));
        }

        pPointer = NULL;
    }

    return(pPointer);
}

//
//
// Function:    NextPointer
//
// Purpose:     Return the next pointer in use.
//
//
DCWbGraphicPointer* PG_NextPointer
(
    WB_PAGE_HANDLE              hPage,
    const DCWbGraphicPointer*   pStartPointer
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_NextPointer");

    DCWbGraphicPointer* pPointer;

    // Go forward one from passed pointer
    POM_OBJECT hUser;
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext((pStartPointer->GetUser())->Handle(),
                                           &hUser);

    if (uiReturn == 0)
    {
        pPointer = PG_LookForPointer(hPage, hUser);
    }
    else
    {
        if (uiReturn != WB_RC_NO_SUCH_PERSON)
        {
            ERROR_OUT(("Error from WBP_PersonHandleNext"));
        }

        pPointer = NULL;
    }

    return(pPointer);
}


//
//
// Function:    LookForPointer
//
// Purpose:     Look for the first pointer active on this page, starting
//              the serach with the user whose handle is passed in.
//
//
DCWbGraphicPointer* PG_LookForPointer
(
    WB_PAGE_HANDLE  hPage,
    POM_OBJECT      hUser
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_LookForPointer");

    DCWbGraphicPointer* pPointer = NULL;
    WbUser*             pUser;
    UINT                result = 0;

    // Scan the users (starting with the one passed in)
    for (;;)
    {
        // Check if the user has an active pointer on this page
        pUser = WB_GetUser(hUser);

        if ((pUser != NULL) &&
            (pUser->IsUsingPointer()) &&
            (pUser->PointerPage() == hPage))
        {
            pPointer = pUser->GetPointer();
            break;
        }

        // Get the next user
        result = g_pwbCore->WBP_PersonHandleNext(hUser, &hUser);
        if (result != 0)
        {
            if (result != WB_RC_NO_SUCH_PERSON)
            {
                ERROR_OUT(("Error from WBP_PersonHandleNext"));
            }
            break;
        }
    }

    return(pPointer);
}




//
//
// Function:    GraphicUpdate
//
// Purpose:     Update an existing graphic
//
//
void PG_GraphicUpdate
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    PWB_GRAPHIC         pHeader
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicUpdate");

    UINT uiReturn = g_pwbCore->WBP_GraphicUpdateRequest(hPage,
            *phGraphic, pHeader);

    if (uiReturn != 0)
    {
        if( uiReturn == OM_RC_OBJECT_DELETED )
        {
            // somebody nuked our object, try to put it back (bug 4416)
            g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, phGraphic);
        }

        // Throw exception - exception code will special case 
        // OM_RC_OBJECT_DELETED and cancel drawing
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    GraphicReplace
//
// Purpose:     Replace an existing graphic
//
//
void PG_GraphicReplace
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE * phGraphic,
    PWB_GRAPHIC         pHeader
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicReplace");

    UINT uiReturn = g_pwbCore->WBP_GraphicReplaceRequest(hPage,
        *phGraphic, pHeader);

    if (uiReturn != 0)
    {
        if (uiReturn == OM_RC_OBJECT_DELETED)
        {
            // somebody nuked our object, try to put it back (bug 4416)
            g_pwbCore->WBP_GraphicAddLast(hPage, pHeader, phGraphic);
        }

        // Throw exception - exception code will special case 
        // OM_RC_OBJECT_DELETED and cancel drawing
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    Clear
//
// Purpose:     Delete all graphics on the page
//
//
void PG_Clear
(
    WB_PAGE_HANDLE  hPage
)
{
    UINT uiReturn = g_pwbCore->WBP_PageClear(hPage);

    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    Delete
//
// Purpose:     Delete the specified graphic
//
//
void PG_GraphicDelete
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GraphicDelete");

    UINT uiReturn = g_pwbCore->WBP_GraphicDeleteRequest(hPage, graphic.Handle());
    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return;
    }
}


//
//
// Function:    SelectLast
//
// Purpose:     Select the last object whose bounding rectangle contains
//              the point specified.
//
//
DCWbGraphic* PG_SelectLast
(
    WB_PAGE_HANDLE  hPage,
    POINT           point
)
{
    RECT            rectHit;
    DCWbGraphic*    pGraphic = NULL;
    DCWbGraphic*    pGraphicPrev = NULL;
    WB_GRAPHIC_HANDLE hGraphic;

    UINT uiReturn = g_pwbCore->WBP_GraphicSelect(hPage, point, NULL, LAST,
                                              &hGraphic);
    if (uiReturn == WB_RC_NO_SUCH_GRAPHIC)
    {
        return(pGraphic);
    }

    if (uiReturn != 0)
    {
        // Throw exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return NULL;
    }

    // Get the graphic
    pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    // Check to see if its really hit
    if (pGraphic != NULL)
    {
        MAKE_HIT_RECT(rectHit, point);
        if (!pGraphic->CheckReallyHit( &rectHit ))
        {
            // have to look some more
            pGraphicPrev = PG_SelectPrevious(hPage, *pGraphic, point );
            if( pGraphic != pGraphicPrev )
            {
                delete pGraphic;
                pGraphic = pGraphicPrev;
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    SelectPrevious
//
// Purpose:     Select the previous object whose bounding rectangle contains
//              the point specified.
//
//
DCWbGraphic* PG_SelectPrevious
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic&  graphic,
    POINT               point
)
{
    RECT        rectHit;
    DCWbGraphic* pGraphic = NULL;
    WB_GRAPHIC_HANDLE hGraphic;
    WB_GRAPHIC_HANDLE hGraphicPrev;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_SelectPrevious");

    MAKE_HIT_RECT(rectHit, point );

    hGraphic = graphic.Handle();
    while ( (g_pwbCore->WBP_GraphicSelect(hPage, point,
                                       hGraphic, BEFORE, &hGraphicPrev ))
            != WB_RC_NO_SUCH_GRAPHIC )
    {
        // Get the graphic
        pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphicPrev);

        if( pGraphic == NULL )
            break;

        if( pGraphic->CheckReallyHit( &rectHit ) )
            break;

        hGraphic = hGraphicPrev;

        delete pGraphic;
        pGraphic = NULL;
    }


    return(pGraphic);
}



//
//
// Function:    IsTopmost
//
// Purpose:     Return TRUE if the specified graphic is topmost on the page
//
//
BOOL PG_IsTopmost
(
    WB_PAGE_HANDLE      hPage,
    const DCWbGraphic*  pGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_IsTopmost");

    WB_GRAPHIC_HANDLE hGraphic;
    UINT uiReturn = g_pwbCore->WBP_GraphicHandle(hPage, NULL, LAST, &hGraphic);

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
	    return FALSE;
    }

    return (pGraphic->Handle() == hGraphic);
}

//
//
// Function:    Draw
//
// Purpose:     Draw the contents of the page into the specified device
//              context.
//
//
void PG_Draw
(
    WB_PAGE_HANDLE  hPage,
    HDC             hDC,
    BOOL            thumbNail
)
{
    WB_GRAPHIC_HANDLE   hStart;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Draw");

    //
    // Draw the graphic objects
    //
    DCWbGraphic* pGraphic = PG_First(hPage, &hStart);
    while (pGraphic != NULL)
    {
        pGraphic->Draw(hDC, thumbNail);

        // Release the current graphic
        delete pGraphic;

        // Get the next one
        pGraphic = PG_Next(hPage, &hStart);
    }
}

//CHANGED BY RAND
#define WB_MIN_PRINT_MARGIN_SIZE     (30)

//
//
// Function:    Print
//
// Purpose:     Print the contents of the page to the specified printer. The
//              contents are scaled to "best fit" on the page. i.e. the
//              largest scaling factor that preserves the aspect ratio of
//              the page is used.
//
//
void PG_Print
(
    WB_PAGE_HANDLE  hPage,
    HDC             hdc,
    LPCRECT         lprcPrint
)
{
    int pageWidth;
    int pageHeight;
    int areaHeight;
    int areaWidth;
    int areaAspectRatio;
    int pageAspectRatio;
    int nPhysOffsetX;
    int nPhysOffsetY;
    int nPhysWidth;
    int nPhysHeight;
    int nVOffsetX;
    int nVOffsetY;

    // get physical printer params
    nPhysOffsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX );
    nPhysOffsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY );
    nPhysWidth   = GetDeviceCaps(hdc, PHYSICALWIDTH );
    nPhysHeight  = GetDeviceCaps(hdc, PHYSICALHEIGHT );

    // calc correct printer area (allow for bugs in some drivers...)
    if( nPhysOffsetX <= 0 )
    {
        nPhysOffsetX = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetX = nPhysOffsetX;
    }
    else
        nVOffsetX = 0;

    if( nPhysOffsetY <= 0 )
    {
        nPhysOffsetY = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetY = nPhysOffsetY;
    }
    else
        nVOffsetY = 0;


    // get and adjust printer page area
    pageWidth  = GetDeviceCaps(hdc, HORZRES );
    pageHeight = GetDeviceCaps(hdc, VERTRES );

    if( pageWidth >= (nPhysWidth - nPhysOffsetX) )
    {
        // HORZRES is lying to us, compensate
        pageWidth = nPhysWidth - 2*nPhysOffsetX;
    }

    if( pageHeight >= (nPhysHeight - nPhysOffsetY) )
    {
        // VERTRES is lying to us, compensate
        pageHeight = nPhysHeight - 2*nPhysOffsetY;
    }


    // adjust printer area to get max fit for Whiteboard page
    areaWidth  = lprcPrint->right - lprcPrint->left;
    areaHeight = lprcPrint->bottom - lprcPrint->top;
    areaAspectRatio = ((100 * areaHeight + (areaWidth/2))/(areaWidth));
    pageAspectRatio = ((100 * pageHeight + (pageWidth/2))/(pageWidth));

    if (areaAspectRatio < pageAspectRatio)
        pageHeight  = ((pageWidth * areaHeight + (areaWidth/2))/areaWidth);
    else 
    if (areaAspectRatio > pageAspectRatio)
        pageWidth = ((pageHeight * areaWidth + (areaHeight/2))/areaHeight);

    // set up xforms

   	::SetMapMode(hdc, MM_ANISOTROPIC );
    ::SetWindowExtEx(hdc, areaWidth, areaHeight,NULL );
    ::SetWindowOrgEx(hdc, 0,0, NULL );
    ::SetViewportExtEx(hdc, pageWidth, pageHeight, NULL );
    ::SetViewportOrgEx(hdc, nVOffsetX, nVOffsetY, NULL );
    
    // draw the page
    PG_Draw(hPage, hdc);
}



//
//
// Function:    AreaInUse
//
// Purpose:     Return the bounding rectangle of all graphics on the page
//
//
void PG_GetAreaInUse
(
    WB_PAGE_HANDLE      hPage,
    LPRECT              lprcArea
)
{
    WB_GRAPHIC_HANDLE   hStart;
    RECT                rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_AreaInUse");

    ::SetRectEmpty(lprcArea);

    // Union together the rects of all the graphics
    DCWbGraphic* pGraphic = PG_First(hPage, &hStart);
    while (pGraphic != NULL)
    {
        pGraphic->GetBoundsRect(&rcBounds);
        ::UnionRect(lprcArea, lprcArea, &rcBounds);

        // Release the current graphic
        delete pGraphic;

        // Get the next one
        pGraphic = PG_Next(hPage, &hStart);
    }
}

//
//
// Function:    PG_InitializePalettes
//
// Purpose:     Create palettes for display and print (if necessary)
//
//
void PG_InitializePalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_InitializePalettes");

    // If the palettes are not yet initialized - initialize them now
    if (!g_bPalettesInitialized)
    {
        ASSERT(!g_hRainbowPaletteDisplay);

        // Get the number of colors supported by the screen
        // We only need an info DC for this, not a full DC
        HDC     hdc;

        hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            return;
        }

        // Determine whether the device supports palettes
        int iBitsPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
        int iPlanes    = ::GetDeviceCaps(hdc, PLANES);
        int iNumColors = iBitsPixel * iPlanes;

        ::DeleteDC(hdc);

        // If we need the palette, create it.
        // We only need the palette on a 8bpp machine. Anything less (4bpp)
        // and there will be no palette, anything more is a pure color display.
        if ((iNumColors == 8) &&
            (g_hRainbowPaletteDisplay = CreateColorPalette()))
        {
            // Show that we want to use the palette
            g_bUsePalettes = TRUE;

        }
        else
        {
            g_bUsePalettes = FALSE;
        }

        // Show that we have now initialized the palette information
        g_bPalettesInitialized = TRUE;
    }
}

//
//
// Function:    PG_GetPalette
//
// Purpose:     Return the palette for use with this page.
//              This object is temporary and should not be stored.
//
//
HPALETTE PG_GetPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPalette");

    // If the palettes are not yet initialized - initialize them now
    PG_InitializePalettes();

    if (g_bUsePalettes)
    {
        // If we are using a non-default palette, set the return value
        return(g_hRainbowPaletteDisplay);
    }
    else
    {
        return(NULL);
    }
}


void PG_ReinitPalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ReinitPalettes");

    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }
        ::DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    PG_InitializePalettes();
}



//
//
// Function : PG_GetObscuringRect
//
// Purpose  : Return the intersection of a graphic and any objects which
//            obscure it
//
//
void PG_GetObscuringRect
(
    WB_PAGE_HANDLE  hPage,
    DCWbGraphic*    pGraphic,
    LPRECT          lprcObscuring
)
{
    DCWbGraphic* pNextGraphic;
    RECT         rc;
    RECT         rcBounds;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetObscuringRect");

    ::SetRectEmpty(lprcObscuring);
    pGraphic->GetBoundsRect(&rcBounds);

    // Loop through all the objects which are above the given one in the
    // Z-order, checking to see if they overlap the given object

    pNextGraphic = pGraphic;
    while (pNextGraphic = PG_After(hPage, *pNextGraphic))
    {
        // Get the bounding rectangle of the next object
        pNextGraphic->GetBoundsRect(&rc);

        // Check the intersection of the rectangles
        ::IntersectRect(&rc, &rc, &rcBounds);

        // Add the intersection to the obscuring rectangle
        ::UnionRect(lprcObscuring, lprcObscuring, &rc);
    }

    // check text editbox if its up - bug 2185
    if (g_pMain->m_drawingArea.TextEditActive())
    {
        g_pMain->m_drawingArea.GetTextEditBoundsRect(&rc);
        ::IntersectRect(&rc, &rc, &rcBounds);
        ::UnionRect(lprcObscuring, lprcObscuring, &rc);
    }
}



//
// ZGreaterGraphic()
//
// Determines which handle, hLastGraphic or hTestGraphic, is first in the 
// ZOrder (greater and consequently "underneath" the other graphic). If 
// hTestGraphic is NULL then the first graphic is returned.
//
WB_GRAPHIC_HANDLE PG_ZGreaterGraphic
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hLastGraphic, 
    WB_GRAPHIC_HANDLE   hTestGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ZGreaterGraphic");

    WB_GRAPHIC_HANDLE hGraphic;
    WB_GRAPHIC_HANDLE hCurrentGraphic;

    if (g_pwbCore->WBP_GraphicHandle(hPage, NULL, FIRST, &hGraphic) != 0)
        return(NULL);

    if (hTestGraphic == NULL)
        return(hGraphic);

    if (hLastGraphic == NULL)
        return(hTestGraphic);

    // search for which one is deeper
    while (hGraphic != NULL)
    {
        if ((hGraphic == hLastGraphic) ||
            (hGraphic == hTestGraphic))
            return( hGraphic );

        hCurrentGraphic = hGraphic;
        if (g_pwbCore->WBP_GraphicHandle(hPage, hCurrentGraphic, AFTER, &hGraphic) != 0)
            return( NULL );
    }

    // didn't find either one
    return( NULL );
}



//
//
// Function:    GetNextPage
//
// Purpose:     Return the next page of graphic objects
//
//
WB_PAGE_HANDLE PG_GetNextPage
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetNextPage");

    // Get the handle of the next page
    WB_PAGE_HANDLE hNextPage = NULL;
    UINT uiReturn = g_pwbCore->WBP_PageHandle(hPage, PAGE_AFTER, &hNextPage);

    switch (uiReturn)
    {
        case 0:
            // Got the previous page OK, return it
            break;

        case WB_RC_NO_SUCH_PAGE:
            // There is no previous page, return this page
            hNextPage = hPage;
            break;

        default:
            // Throw an exception recording the return code
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            break;
    }

    return(hNextPage);
}

//
//
// Function:    GetPreviousPage
//
// Purpose:     Return the previous page of graphic objects
//
//
WB_PAGE_HANDLE PG_GetPreviousPage
(
    WB_PAGE_HANDLE  hPage
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPreviousPage");

    // Get the handle of the previous page
    WB_PAGE_HANDLE hPreviousPage;
    UINT uiReturn = g_pwbCore->WBP_PageHandle(hPage, PAGE_BEFORE,
                                             &hPreviousPage);

    switch (uiReturn)
    {
        case 0:
            // Got the next page OK, return it
            break;

        case WB_RC_NO_SUCH_PAGE:
            // There is no next page, return this page
            hPreviousPage = hPage;
            break;

        default:
            // Throw an exception recording the return code
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            break;
    }

    return(hPreviousPage);
}

//
//
// Function:    GetPageNumber
//
// Purpose:     Return the page with the given page number
//
//
WB_PAGE_HANDLE PG_GetPageNumber(UINT uiPageNo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPageNumber");

    // Ensure that the requested page number is within range
    uiPageNo = min(uiPageNo, g_pwbCore->WBP_ContentsCountPages());
    uiPageNo = max(1, uiPageNo);

    // Get the handle of the page with the specified page number
    WB_PAGE_HANDLE hPage;
    UINT uiReturn = g_pwbCore->WBP_PageHandleFromNumber(uiPageNo, &hPage);

    // Since we have been careful to ensure that the page number was
    // in bounds we should always get a good return code from the core.
    ASSERT(uiReturn == 0);

    // Return a page object created from the returned handle
    return(hPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\mwnd.cpp ===
//
// MWND.CPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include <dde.h>
#include "version.h"


static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmwhiteb.chm");

// Class name
TCHAR szMainClassName[] = "Wb32MainWindowClass";


//
// Scroll accelerators
//
typedef struct tagSCROLL
{
    UINT uiMenuId;
    UINT uiMessage;
    UINT uiScrollCode;
}
SCROLL;

static const SCROLL s_MenuToScroll[] =
{
  { IDM_PAGEUP,        WM_VSCROLL, SB_PAGEUP },
  { IDM_PAGEDOWN,      WM_VSCROLL, SB_PAGEDOWN },
  { IDM_SHIFTPAGEUP,   WM_HSCROLL, SB_PAGEUP },
  { IDM_SHIFTPAGEDOWN, WM_HSCROLL, SB_PAGEDOWN },
  { IDM_HOME,          WM_HSCROLL, SB_TOP },
  { IDM_HOME,          WM_VSCROLL, SB_TOP },
  { IDM_END,           WM_HSCROLL, SB_BOTTOM },
  { IDM_END,           WM_VSCROLL, SB_BOTTOM },
  { IDM_LINEUP,        WM_VSCROLL, SB_LINEUP },
  { IDM_LINEDOWN,      WM_VSCROLL, SB_LINEDOWN },
  { IDM_SHIFTLINEUP,   WM_HSCROLL, SB_LINEUP },
  { IDM_SHIFTLINEDOWN, WM_HSCROLL, SB_LINEDOWN }
};


// tooltip data
// check codes
#define NA    0   // dont't check checked state
#define TB    1    // check toolbar for checked state
#define BT    2    // check tipped wnd (a button) for checked state

typedef struct
{
    UINT    nID;
    UINT    nCheck;
    UINT    nUpTipID;
    UINT    nDownTipID;
}
TIPIDS;

TIPIDS g_tipIDsArray[]    =
{
{IDM_SELECT,            TB, IDS_HINT_SELECT,        IDS_HINT_SELECT},
{IDM_ERASER,            TB, IDS_HINT_ERASER,        IDS_HINT_ERASER},
{IDM_TEXT,              TB, IDS_HINT_TEXT,          IDS_HINT_TEXT},
{IDM_HIGHLIGHT,         TB, IDS_HINT_HIGHLIGHT,     IDS_HINT_HIGHLIGHT},
{IDM_PEN,               TB, IDS_HINT_PEN,           IDS_HINT_PEN},
{IDM_LINE,              TB, IDS_HINT_LINE,          IDS_HINT_LINE},
{IDM_BOX,               TB, IDS_HINT_BOX,           IDS_HINT_BOX},
{IDM_FILLED_BOX,        TB, IDS_HINT_FBOX,          IDS_HINT_FBOX},
{IDM_ELLIPSE,           TB, IDS_HINT_ELLIPSE,       IDS_HINT_ELLIPSE},
{IDM_FILLED_ELLIPSE,    TB, IDS_HINT_FELLIPSE,      IDS_HINT_FELLIPSE},
{IDM_ZOOM,              TB, IDS_HINT_ZOOM_UP,       IDS_HINT_ZOOM_DOWN},
{IDM_REMOTE,            TB, IDS_HINT_REMOTE_UP,     IDS_HINT_REMOTE_DOWN},
{IDM_LOCK,              TB, IDS_HINT_LOCK_UP,       IDS_HINT_LOCK_DOWN},
{IDM_SYNC,              TB, IDS_HINT_SYNC_UP,       IDS_HINT_SYNC_DOWN},
{IDM_GRAB_AREA,         TB, IDS_HINT_GRAB_AREA,     IDS_HINT_GRAB_AREA},
{IDM_GRAB_WINDOW,       TB, IDS_HINT_GRAB_WINDOW,   IDS_HINT_GRAB_WINDOW},

{IDM_WIDTH_1,           NA, IDS_HINT_WIDTH_1,       IDS_HINT_WIDTH_1},
{IDM_WIDTH_2,           NA, IDS_HINT_WIDTH_2,       IDS_HINT_WIDTH_2},
{IDM_WIDTH_3,           NA, IDS_HINT_WIDTH_3,       IDS_HINT_WIDTH_3},
{IDM_WIDTH_4,           NA, IDS_HINT_WIDTH_4,       IDS_HINT_WIDTH_4},

{IDM_PAGE_FIRST,        BT, IDS_HINT_PAGE_FIRST,    IDS_HINT_PAGE_FIRST},
{IDM_PAGE_PREV,         BT, IDS_HINT_PAGE_PREVIOUS, IDS_HINT_PAGE_PREVIOUS},
{IDM_PAGE_ANY,          NA, IDS_HINT_PAGE_ANY,      IDS_HINT_PAGE_ANY},
{IDM_PAGE_NEXT,         BT, IDS_HINT_PAGE_NEXT,     IDS_HINT_PAGE_NEXT},
{IDM_PAGE_LAST,         BT, IDS_HINT_PAGE_LAST,     IDS_HINT_PAGE_LAST},
{IDM_PAGE_INSERT_AFTER, BT, IDS_HINT_PAGE_INSERT,   IDS_HINT_PAGE_INSERT}
    };
////////////






//
//
// Function:    WbMainWindow constructor
//
// Purpose:     Create the main Whiteboard window. An exception is thrown
//              if an error occurs during construction.
//
//
WbMainWindow::WbMainWindow(void)
{
    OSVERSIONINFO   OsData;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WbMainWindow");

    //
    // Initialize member vars first!
    //
    m_hwnd = NULL;
    ZeroMemory(m_ToolArray, sizeof(m_ToolArray));

    m_hwndToolTip = NULL;
    ZeroMemory(&m_tiLastHit, sizeof(m_tiLastHit));
    m_nLastHit = -1;

    m_bInitOk = FALSE;
    m_bDisplayingError = FALSE;

    g_pwbCore = NULL;

    m_dwDomain = 0;
    m_bTimerActive = FALSE;
    m_bSyncUpdateNeeded = FALSE;

    m_hPageClip     = WB_PAGE_HANDLE_NULL;
    m_hGraphicClip  = NULL;
    m_pDelayedGraphicClip = NULL;
    m_pDelayedDataClip = NULL;

    m_bToolBarOn    = FALSE;

    // Load the main accelerator table
    m_hAccelTable =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(MAINACCELTABLE));

    m_hwndPageSortDlg = NULL;
    m_hwndQuerySaveDlg = NULL;
    m_hwndWaitForEventDlg = NULL;
    m_hwndWaitForLockDlg = NULL;
    m_hwndInitDlg = NULL;

    m_hwndSB = NULL;
    m_bStatusBarOn = TRUE;

    m_pCurrentTool = NULL;
    m_uiSavedLockType = WB_LOCK_TYPE_NONE;
	ZeroMemory(m_strFileName, sizeof(m_strFileName));

    m_hCurrentPage = WB_PAGE_HANDLE_NULL;

    // Load the alternative accelerator table for the pages edit
    // field and text editor
    m_hAccelPagesGroup =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(PAGESGROUPACCELTABLE));
    m_hAccelTextEdit   =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(TEXTEDITACCELTABLE));

    m_pLocalUser = NULL;
    m_pLockOwner = NULL;

    // Show that we are not yet in a call
    m_uiState = STARTING;
    m_uiSubState = SUBSTATE_IDLE;

    // We are not currently displaying a menu
    m_hContextMenuBar = NULL;
    m_hContextMenu = NULL;
    m_hGrobjContextMenuBar = NULL;
    m_hGrobjContextMenu = NULL;

    m_bPromptingJoinCall = FALSE;
    m_bInSaveDialog = FALSE;
    m_bJoinCallPending = FALSE;
    m_dwPendingDomain = 0;
    m_bPendingCallKeepContents = FALSE;
    m_dwJoinDomain = 0;
    m_bCallActive = FALSE;

    m_hInitMenu = NULL;
    m_numRemoteUsers = 0;
    m_bSelectAllInProgress = FALSE;
    m_bUnlockStateSettled = TRUE;
    m_bQuerySysShutdown = FALSE;

    // figure out if we're on Win95
    m_bIsWin95 = FALSE;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
            m_bIsWin95 = TRUE;
    }

    m_cancelModeSent = FALSE;

    //
    // We only do this once for the lifetime of the DLL.  There is no
    // way really to clean up registered window messages, and each register
    // bumps up a ref count.  If we registered each time WB was started up
    // during one session of CONF, we'd overflow the refcount.
    //
    if (!g_uConfShutdown)
    {
        g_uConfShutdown = ::RegisterWindowMessage( NM_ENDSESSION_MSG_NAME );
    }
}


//
// Open()
// Do Main window initialization (stuff that can fail).  After this,
// the run code will try to join the current domain and do message loop
// stuff.
//
BOOL WbMainWindow::Open(int iCommand)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Open");

    //
    // CREATE OTHER GLOBALS
    //

    // Start the Whiteboard Core
    if (!CreateWBObject(WbMainWindowEventHandler, &g_pwbCore))
    {
        ERROR_OUT(("WBP_Start failed"));
        DefaultExceptionHandler(WBFE_RC_WB, UT_RC_NO_MEM);
        return FALSE;
    }

    if (!InitToolArray())
    {
        ERROR_OUT(("Can't create tools; failing to start up"));
        return(FALSE);
    }

    g_pUsers = new WbUserList;
    if (!g_pUsers)
    {
        ERROR_OUT(("Can't create g_pUsers"));
        return(FALSE);
    }

    g_pIcons = new DCWbColorToIconMap();
    if (!g_pIcons)
    {
        ERROR_OUT(("Can't create g_pIcons"));
        return(FALSE);
    }

    //
    // Init comon controls
    //
    InitCommonControls();

    //
    // CREATE THE MAIN FRAME WINDOW
    //
    ASSERT(!m_hwnd);

    // Get the class info for it, and change the name.
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
    wc.lpfnWndProc      = WbMainWindowProc;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APP));
    wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(MAINMENU);
    wc.lpszClassName    = szMainClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("Can't register private frame window class"));
        return(FALSE);
    }

    // Create the main drawing window.
    if (!::CreateWindowEx(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, szMainClassName,
        NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, g_hInstance, this))
    {
        // Could not create the main window
        ERROR_OUT(("Failed to create main window"));
        return(FALSE);
    }

    ASSERT(m_hwnd);

    // Create the pop-up context menu
    if (!CreateContextMenus())
    {
        ERROR_OUT(("Failed to create context menus"));
        return(FALSE);
    }

    // Register the the main window for Drag/Drop messages.
    DragAcceptFiles(m_hwnd, TRUE);


    //
    // CREATE THE CHILD WINDOWS
    //

    // Create the drawing pane
    // (the Create call throws an exception on error)
    RECT    clientRect;
    RECT    drawingAreaRect;

    ::GetClientRect(m_hwnd, &clientRect);
    drawingAreaRect = clientRect;

    // Every control in the main window has a border on it, so increase the
    // client size by 1 to force these borders to be drawn under the inside
    // black line in the window frame.  This prevents a 2 pel wide border
    // being drawn
    ::InflateRect(&clientRect, 1, 1);

    SIZE sizeAG;
    m_AG.GetNaturalSize(&sizeAG);

    //
    // The drawing area is the top part of the client.  The attributes group
    // and status bar are below it.
    //
    drawingAreaRect.bottom -= (STATUSBAR_HEIGHT
                          + GetSystemMetrics(SM_CYBORDER)
                          + sizeAG.cy);
    if (!m_drawingArea.Create(m_hwnd, &drawingAreaRect))
    {
        ERROR_OUT(("Failed to create drawing area"));
        return(FALSE);
    }


    if (!m_TB.Create(m_hwnd))
    {
        ERROR_OUT(("Failed to create tool window"));
        return(FALSE);
    }


    // Lock the drawing area initially. This prevents the user attempting
    // to make changes before we are in a call.
    LockDrawingArea();

    // disable remote pointer while we are initing (bug 4767)
    m_TB.Disable(IDM_REMOTE);


    m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
        CCS_NORESIZE | SBARS_SIZEGRIP,
        clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
        (clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
        m_hwnd, 0, g_hInstance, NULL);
    if (!m_hwndSB)
    {
        ERROR_OUT(("Failed to create status bar window"));
        return(FALSE);
    }

    //
    // Create the attributes group
    // The attributes group is on the bottom, underneath the
    // drawing area, above the status bar.
    //
    RECT    rectAG;

    rectAG.left = clientRect.left;
    rectAG.right = clientRect.right;
    rectAG.top = drawingAreaRect.bottom;
    rectAG.bottom = rectAG.top + sizeAG.cy;

    if (!m_AG.Create(m_hwnd, &rectAG))
    {
        ERROR_OUT(("Failed to create attributes group window"));
        return(FALSE);
    }

    //
    // Create the widths group.
    // The widths group is on the left side, underneath the tools group
    //
    SIZE    sizeWG;
    RECT    rectWG;


    // The widths group is on the left side, underneath the toolbar
    m_WG.GetNaturalSize(&sizeWG);
    rectWG.left = 0;
    rectWG.right = rectWG.left + sizeWG.cx;
    rectWG.bottom = rectAG.top;
    rectWG.top  = rectWG.bottom - sizeWG.cy;

    if (!m_WG.Create(m_hwnd, &rectWG))
    {
        ERROR_OUT(("Failed to create widths group window"));
        return(FALSE);
    }

    // The main window is created with the status bar visible. So make sure
    // that the relevant menu item is checked. This is subject to change
    // depending on options in the Open member function.
    CheckMenuItem(IDM_STATUS_BAR_TOGGLE);

    // Initialize the color, width and tool menus
    InitializeMenus();

    m_currentMenuTool       = IDM_SELECT;
    m_pCurrentTool          = m_ToolArray[TOOL_INDEX(IDM_SELECT)];


    m_hwndToolTip = ::CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, m_hwnd, NULL, g_hInstance, NULL);
    if (!m_hwndToolTip)
    {
        ERROR_OUT(("Unable to create tooltip window"));
        return(FALSE);
    }

    // Add a dead-area tooltip
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = m_hwnd;
    ti.uId = (UINT_PTR)m_hwnd;
    ::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    // Ensure the page buttons are disabled while starting
    UpdatePageButtons();

    // If this is the first time we have created a clipboard object,
    // register the private Whiteboard formats.
    if (g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE_SINGLE_OBJ] =
            (int) ::RegisterClipboardFormat("DCGWbClipFormat");
    }

    if (g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE_MULTI_OBJ] =
            (int) ::RegisterClipboardFormat("DCGWbMultiObjClipFormat");
    }

    // There is no deleted graphic yet
    m_LastDeletedGraphic.BurnTrash();

    m_bInitOk = TRUE;

    BOOL bSuccess = TRUE;    // indicates whether window opened successfully

    // Get the position of the window from options
    RECT    rectWindow;
    RECT    rectDefault;

    ::SetRectEmpty(&rectDefault);

    OPT_GetWindowRectOption(OPT_MAIN_MAINWINDOWRECT, &rectWindow, &rectDefault);

    if (!::IsRectEmpty(&rectWindow))
    {
        ::MoveWindow(m_hwnd, rectWindow.left, rectWindow.top,
            rectWindow.right - rectWindow.left,
            rectWindow.bottom - rectWindow.top, FALSE );
    }


    // Check whether the help bar is to be visible
    if (!OPT_GetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, DFLT_MAIN_STATUSBARVISIBLE))
    {
        // Update the window to turn the help bar off
        OnStatusBarToggle();
    }

    //
    // Position the toolbar
    //

    // Hide the tool bar before moving it (otherwise we get some
    // problems redrawing it).
    ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

    // Resize the window panes to allow room for the tools
    if (m_bToolBarOn)
    {
        ResizePanes();
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);
    }

    // Move the focus back from the tool window to the main window
    ::SetFocus(m_hwnd);

    // Check whether the tool window is to be visible
    if (OPT_GetBooleanOption(OPT_MAIN_TOOLBARVISIBLE, DFLT_MAIN_TOOLBARVISIBLE))
    {
        // Display the tool window, and check the associated menu item
        OnToolBarToggle();
    }

    // Set up the variable saving the maximized/minimized state of
    // the window and the extra style necessary for displaying the
    // window correctly initially.
    if (OPT_GetBooleanOption(OPT_MAIN_MAXIMIZED, DFLT_MAIN_MAXIMIZED))
    {
        m_uiWindowSize = SIZEFULLSCREEN;
        iCommand = SW_SHOWMAXIMIZED;
    }
    else if (OPT_GetBooleanOption(OPT_MAIN_MINIMIZED, DFLT_MAIN_MINIMIZED))
    {
        m_uiWindowSize = SIZEICONIC;
        iCommand = SW_SHOWMINIMIZED;
    }
    else
    {
        // Default
        m_uiWindowSize = SIZENORMAL;
        iCommand = SW_SHOWNORMAL;
    }

    UpdateWindowTitle();
    ::ShowWindow(m_hwnd, iCommand);
    ::UpdateWindow(m_hwnd);

    // Update the tool window
    ::UpdateWindow(m_TB.m_hwnd);

    // Select the tool
    m_currentMenuTool           = IDM_SELECT;
    m_pCurrentTool              = m_ToolArray[TOOL_INDEX(IDM_SELECT)];
    ::PostMessage(m_hwnd, WM_COMMAND, m_currentMenuTool, 0L);

    // Return value indicating success or failure
    return(bSuccess);
}


//
//
// Function:    WbMainWindow destructor
//
// Purpose:     Tidy up main window on destruction.
//
//
WbMainWindow::~WbMainWindow()
{
    //
    // Destroy the tooltip window
    //
    if (m_hwndToolTip)
    {
        ::DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }

    // Make sure the clipboard discards its saved graphic
    // before the drawingArea gets deleted.
    CLP_FreeDelayedGraphic();

    if (m_hGrobjContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hGrobjContextMenuBar);
        m_hGrobjContextMenuBar = NULL;
    }
    m_hGrobjContextMenu = NULL;

    if (m_hContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hContextMenuBar);
        m_hContextMenuBar = NULL;
    }
    m_hContextMenu = NULL;

	POSITION position = m_pageToPosition.GetHeadPosition();

	PAGE_POSITION * pPoint;

	while (position)
	{
		pPoint = (PAGE_POSITION*)m_pageToPosition.GetNext(position);
		delete pPoint;
	}

	m_pageToPosition.EmptyList();

    if (g_pwbCore)
    {
        //
        //We must call an explicit stop function, rather than 'delete'
        // because we need to pass in the event proc
        //
        g_pwbCore->WBP_Stop(WbMainWindowEventHandler);
        g_pwbCore = NULL;
    }

    DestroyToolArray();

    // Destroy our window
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }

    // Deregister our class
    ::UnregisterClass(szMainClassName, g_hInstance);

    //
    // Free the palette
    //
    if (g_hRainbowPaletteDisplay)
    {
        DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    g_bUsePalettes = FALSE;


    if (g_pIcons)
    {
        delete g_pIcons;
        g_pIcons = NULL;
    }

    if (g_pUsers)
    {
        delete g_pUsers;
        g_pUsers = NULL;
    }
}



//
// JoinDomain()
// Attach to the empty domain or current call
//
BOOL WbMainWindow::JoinDomain(void)
{
    BOOL bSuccess;

    CM_STATUS cmStatus;

    // If there is a call available - join it.
    if (CMS_GetStatus(&cmStatus))
    {
        m_bCallActive = TRUE;

        // Get the domain ID of the call
        m_dwJoinDomain = (DWORD) cmStatus.callID;

        // Join the call
        bSuccess = JoinCall(FALSE);
    }
    else
    {
        // No call available so join the local domain

        // Set the domain ID to "no call"
        m_dwJoinDomain = (DWORD) OM_NO_CALL;

        // Join the call
        bSuccess = JoinCall(FALSE);
    }

    // Wait for the call to be joined, if not abandoned
    if (bSuccess)
    {
        bSuccess = WaitForJoinCallComplete();
    }

    // take down init dlg
    KillInitDlg();

    return(bSuccess);
}




//
// KillInitDlg()
// Take down the init dialog
//
void WbMainWindow::KillInitDlg(void)
{
    if (m_hwndInitDlg != NULL )
    {
        ::DestroyWindow(m_hwndInitDlg);
        m_hwndInitDlg = NULL;

        ::EnableWindow(m_hwnd, TRUE);
    }

}



//
// OnToolHitTest()
// This handles tooltips for child windows.
//
int WbMainWindow::OnToolHitTest(POINT pt, TOOLINFO* pTI) const
{
    HWND    hwnd;
    int     status;
    int     nHit = -1;

    ASSERT(!IsBadWritePtr(pTI, sizeof(TOOLINFO)));

    hwnd = ::ChildWindowFromPointEx(m_hwnd, pt, CWP_SKIPINVISIBLE);
    if (hwnd == m_AG.m_hwnd)
    {
        ::MapWindowPoints(m_hwnd, m_AG.m_hwnd, &pt, 1);
        hwnd = ::ChildWindowFromPointEx(m_AG.m_hwnd, pt, CWP_SKIPINVISIBLE);

        if (hwnd != NULL)
        {
            nHit = ::GetDlgCtrlID(hwnd);

            pTI->hwnd = m_hwnd;
            pTI->uId = (UINT_PTR)hwnd;
            pTI->uFlags |= TTF_IDISHWND;
            pTI->lpszText = LPSTR_TEXTCALLBACK;

            return(nHit);
        }
    }
    else if (hwnd == m_WG.m_hwnd)
    {
        int iItem;

        ::MapWindowPoints(m_hwnd, m_WG.m_hwnd, &pt, 1);

        iItem = m_WG.ItemFromPoint(pt.x, pt.y);

        pTI->hwnd = m_WG.m_hwnd;
        pTI->uId  = iItem;

        // Since the area isn't a window, we must fill in the rect ourself
        m_WG.GetItemRect(iItem, &pTI->rect);
        pTI->lpszText = LPSTR_TEXTCALLBACK;

        return(iItem);
    }
    else if (hwnd == m_TB.m_hwnd)
    {
        RECT        rect;
        TBBUTTON    button;
        int         i;

        for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
        {
            if (::SendMessage(m_TB.m_hwnd, TB_GETITEMRECT, i, (LPARAM)&rect) &&
                ::PtInRect(&rect, pt) &&
                ::SendMessage(m_TB.m_hwnd, TB_GETBUTTON, i, (LPARAM)&button) &&
                !(button.fsStyle & TBSTYLE_SEP))
            {
                nHit = button.idCommand;

                pTI->hwnd = m_TB.m_hwnd;
                pTI->uId = nHit;
                pTI->rect = rect;
                pTI->lpszText = LPSTR_TEXTCALLBACK;

                // found matching rect, return the ID of the button
                return(nHit);
            }
        }
    }

    return(-1);
}


//
// WbMainWindowProc()
// Frame window message handler
//
LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbMainWindow * pMain;

    pMain = (WbMainWindow *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pMain = (WbMainWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ASSERT(pMain);

            pMain->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
            goto DefWndProc;
            break;

        case WM_DESTROY:
            ShutDownHelp();
            break;

        case WM_NCDESTROY:
            pMain->m_hwnd = NULL;
            break;

        case WM_MOVE:
            pMain->OnMove();
            break;

        case WM_SIZE:
            pMain->OnSize((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_ACTIVATE:
            if (GET_WM_ACTIVATE_STATE(wParam, lParam) == WA_INACTIVE)
            {
                // Cancel the tooltip if it's around
                if (pMain->m_hwndToolTip)
                    ::SendMessage(pMain->m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            goto DefWndProc;
            break;

        case WM_SETFOCUS:
            pMain->OnSetFocus();
            break;

        case WM_CANCELMODE:
            pMain->OnCancelMode();
            break;

        case WM_TIMER:
            pMain->OnTimer(wParam);
            break;

        case WM_INITMENUPOPUP:
            pMain->OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MENUSELECT:
            pMain->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
                GET_WM_MENUSELECT_FLAGS(wParam, lParam),
                GET_WM_MENUSELECT_HMENU(wParam, lParam));
            break;

        case WM_MEASUREITEM:
            pMain->OnMeasureItem((int)wParam, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            pMain->OnDrawItem((int)wParam, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_QUERYNEWPALETTE:
            lResult = pMain->OnQueryNewPalette();
            break;

        case WM_PALETTECHANGED:
            pMain->OnPaletteChanged((HWND)wParam);
            break;

        case WM_HELP:
            pMain->OnCommand(IDM_HELP, 0, NULL);
            break;

        case WM_CLOSE:
            pMain->OnClose();
            break;

        case WM_QUERYENDSESSION:
            lResult = pMain->OnQueryEndSession();
            break;

        case WM_ENDSESSION:
            pMain->OnEndSession((BOOL)wParam);
            break;

        case WM_SYSCOLORCHANGE:
            pMain->OnSysColorChange();
            break;

        case WM_USER_PRIVATE_PARENTNOTIFY:
            pMain->OnParentNotify(GET_WM_PARENTNOTIFY_MSG(wParam, lParam));
            break;

        case WM_GETMINMAXINFO:
            if (pMain)
                pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_RENDERALLFORMATS:
            pMain->OnRenderAllFormats();
            break;

        case WM_RENDERFORMAT:
            pMain->CLP_RenderFormat((int)wParam);
            break;

        case WM_COMMAND:
            pMain->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            pMain->OnNotify((UINT)wParam, (NMHDR *)lParam);
            break;

        case WM_DROPFILES:
            pMain->OnDropFiles((HDROP)wParam);
            break;

        case WM_USER_GOTO_USER_POSITION:
            pMain->OnGotoUserPosition(lParam);
            break;

        case WM_USER_GOTO_USER_POINTER:
            pMain->OnGotoUserPointer(lParam);
            break;

        case WM_USER_JOIN_CALL:
            pMain->OnJoinCall((BOOL)wParam, lParam);
            break;

        case WM_USER_DISPLAY_ERROR:
            pMain->OnDisplayError(wParam, lParam);
            break;

        case WM_USER_UPDATE_ATTRIBUTES:
            pMain->m_AG.DisplayTool(pMain->m_pCurrentTool);
            break;

        case WM_USER_JOIN_PENDING_CALL:
            pMain->OnJoinPendingCall();
            break;

        default:
            if (message == g_uConfShutdown)
            {
                lResult = pMain->OnConfShutdown(wParam, lParam);
            }
            else
            {
DefWndProc:
                lResult = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;
    }

    return(lResult);
}


//
// OnCommand()
// Command dispatcher for the main window
//
void WbMainWindow::OnCommand(UINT cmd, UINT code, HWND hwndCtl)
{
    switch (cmd)
    {
        //
        // FILE MENU
        //
        case IDM_NEW:
            OnNew();
            break;

        case IDM_OPEN:
            OnOpen();
            break;

        case IDM_SAVE:
            OnSave(FALSE);
            break;

        case IDM_SAVE_AS:
            OnSave(TRUE);
            break;

        case IDM_PRINT:
            OnPrint();
            break;

        case IDM_EXIT:
            ::PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            break;

        //
        // EDIT MENU
        //
        case IDM_DELETE:
            OnDelete();
            break;

        case IDM_UNDELETE:
            OnUndelete();
            break;

        case IDM_CUT:
            OnCut();
            break;

        case IDM_COPY:
            OnCopy();
            break;

        case IDM_PASTE:
            OnPaste();
            break;

        case IDM_SELECTALL:
            OnSelectAll();
            break;

        case IDM_BRING_TO_TOP:
            m_drawingArea.BringToTopSelection();
            break;

        case IDM_SEND_TO_BACK:
            m_drawingArea.SendToBackSelection();
            break;

        case IDM_CLEAR_PAGE:
            OnClearPage();
            break;

        case IDM_DELETE_PAGE:
            OnDeletePage();
            break;

        case IDM_PAGE_INSERT_BEFORE:
            OnInsertPageBefore();
            break;

        case IDM_PAGE_INSERT_AFTER:
            OnInsertPageAfter();
            break;

        case IDM_PAGE_SORTER:
            OnPageSorter();
            break;

        //
        // VIEW MENU
        //
        case IDM_TOOL_BAR_TOGGLE:
            OnToolBarToggle();
            break;

        case IDM_STATUS_BAR_TOGGLE:
            OnStatusBarToggle();
            break;

        case IDM_ZOOM:
            OnZoom();
            break;

        //
        // TOOLS MENU
        //
        case IDM_SELECT:
        case IDM_PEN:
        case IDM_HIGHLIGHT:
        case IDM_TEXT:
        case IDM_ERASER:
        case IDM_LINE:
        case IDM_BOX:
        case IDM_FILLED_BOX:
        case IDM_ELLIPSE:
        case IDM_FILLED_ELLIPSE:
            OnSelectTool(cmd);
            break;

        case IDM_REMOTE:
            OnRemotePointer();
            break;

        case IDM_GRAB_AREA:
            OnGrabArea();
            break;

        case IDM_GRAB_WINDOW:
            OnGrabWindow();
            break;

        case IDM_SYNC:
            OnSync();
            break;

        case IDM_LOCK:
            OnLock();
            break;

        //
        // OPTIONS MENU
        //
        case IDM_COLOR:
            OnSelectColor();
            break;

        case IDM_EDITCOLOR:
            m_AG.OnEditColors();
            break;

        case IDM_FONT:
            OnChooseFont();
            break;

        case IDM_WIDTH_1:
        case IDM_WIDTH_2:
        case IDM_WIDTH_3:
        case IDM_WIDTH_4:
            OnSelectWidth(cmd);
            break;

        //
        // HELP MENU
        //
        case IDM_ABOUT:
            OnAbout();
            break;

        case IDM_HELP:
            ShowHelp();
            break;

        //
        // PAGE BAR
        //
        case IDM_PAGE_FIRST:
            OnFirstPage();
            break;

        case IDM_PAGE_PREV:
            OnPrevPage();
            break;

        case IDM_PAGE_GOTO:
            OnGotoPage();
            break;

        case IDM_PAGE_NEXT:
            OnNextPage();
            break;

        case IDM_PAGE_LAST:
            OnLastPage();
            break;

        //
        // SCROLLING
        //
        case IDM_PAGEUP:
        case IDM_PAGEDOWN:
        case IDM_SHIFTPAGEUP:
        case IDM_SHIFTPAGEDOWN:
        case IDM_HOME:
        case IDM_END:
        case IDM_LINEUP:
        case IDM_LINEDOWN:
        case IDM_SHIFTLINEUP:
        case IDM_SHIFTLINEDOWN:
            OnScrollAccelerator(cmd);
            break;
    }
}


//
// WinHelp() wrapper
//
void WbMainWindow::ShowHelp(void)
{
    HWND hwndCapture;

    // Get the main window out of any mode
    ::SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);

    // Cancel any other tracking
    if (hwndCapture = ::GetCapture())
        ::SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

	// finally, run the Windows Help engine
    ShowNmHelp(s_cszHtmlHelpFile);
}

//
//
// Function:    OnJoinCall
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
void WbMainWindow::OnJoinCall(BOOL bKeep, LPARAM lParam)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnJoinCall");

    // cancel the load if there's one in progress
    if (   (m_uiState == IN_CALL)
        && (m_uiSubState == SUBSTATE_LOADING))
    {
        CancelLoad();
    }

    // Get the parameters for JoinCall
    m_dwJoinDomain = (DWORD) lParam;

    // Start the process of joining the call
    BOOL bSuccess = JoinCall(bKeep);

    // Wait for the join call to complete, if not abandoned
    if (bSuccess)
    {
        bSuccess = WaitForJoinCallComplete();

        if (bSuccess)
        {
            TRACE_MSG(("Joined call OK"));
        }
        else
        {
            // WaitForJoinCallComplete displays appropriate error message
            TRACE_MSG(("Failed to join call"));

            // get into a good state
            Recover();
        }
    }

    // take down init dlg
    KillInitDlg();
}

//
//
// Function:    JoinCall
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
BOOL WbMainWindow::JoinCall(BOOL bKeep)
{
    BOOL    bSuccess = TRUE;
    UINT    uiReturn;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::JoinCall");

    // We must not already be in a real call when we get here
    if ((m_uiState == IN_CALL) && (m_dwDomain != OM_NO_CALL))
    {
        ERROR_OUT(("In a call already"));
    }

    //
    // Prompt the user to save the current contents unless we are in
    // application start-up (when there can be no contents to save) or we
    // are keeping the contents (when there is no need to save).
    //
    if ((m_uiState != STARTING) && !bKeep)
    {
        //
        // Close the page sorter dialog if it's up.
        //
        if (m_hwndPageSortDlg != NULL)
        {
            ::SendMessage(m_hwndPageSortDlg, WM_COMMAND,
                MAKELONG(IDOK, BN_CLICKED), 0);
            ASSERT(m_hwndPageSortDlg == NULL);
        }

        TRACE_MSG(("Not in STARTING state - check whether save wanted"));

        if (m_hwndQuerySaveDlg != NULL)
        {
            ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
                MAKELONG(IDCANCEL, BN_CLICKED), 0);
            ASSERT(m_hwndQuerySaveDlg == NULL);
        }

        // flag that we are joining a call
        m_bPromptingJoinCall = TRUE;

        // ask the user whether to save changes (if required)
        int iDoNew = QuerySaveRequired(FALSE);

        // remove any save as dialog that is already up.
        if (m_bInSaveDialog)
        {
            m_bPromptingJoinCall = FALSE;
            CancelSaveDialog();
            m_bPromptingJoinCall = TRUE;
        }

        if (iDoNew == IDYES)
        {
            TRACE_MSG(("User has elected to save the changes"));

            // Save the changes
            iDoNew = OnSave(FALSE);
        }

        if (!m_bPromptingJoinCall)      // received end call notification
                                        // (during save-as or query-save)
        {
            TRACE_MSG(("Call ended - abandon JoinCall"));
            return(FALSE);
        }

        // flag we're no longer in a state where the join call can be
        // cancelled
        m_bPromptingJoinCall = FALSE;

        //
        // Reset the file name to Untitled, since we are receiving new
        // contents
        //
        ZeroMemory(m_strFileName, sizeof(m_strFileName));
		UpdateWindowTitle();
		
        // if we have the lock then release it
        if (WB_GotLock())
        {
             // Release the lock
             g_pwbCore->WBP_Unlock();

             // Set the locked check mark
             UncheckMenuItem(IDM_LOCK);

             // Pop up the lock button
             m_TB.PopUp(IDM_LOCK);
        }

        if(m_pLocalUser != NULL)
        {
            // if the remote pointer is active then turn it off
            DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();
            if (pPointer->IsActive())
            {
                OnRemotePointer();
            }
        }

        // if sync is turned on then turn it off
        Unsync();

        // If we are not keeping the contents then the only valid current
        // page is the first page.
        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &m_hCurrentPage);
    }

    //PUTBACK BY RAND - the progress timer meter is kinda the heart beat
    //                    of this thing which I ripped out when I removed the
    //                    progress meter. I put it back to fix 1476.
    if (m_bTimerActive)
    {
        ::KillTimer(m_hwnd, TIMERID_PROGRESS_METER);
        m_bTimerActive = FALSE;
    }

    //
    // lock the drawing area until the joining of the call has succeeded
    //
    TRACE_MSG(("Locking drawing area"));
    LockDrawingArea();

    //
    // Give the drawing area a null page during the joining process.  This
    // prevents the drawing area attempting to draw the objects in the page
    // during the process of joining the call.
    //
    TRACE_MSG(("Detaching drawing area"));
    m_drawingArea.Detach();

    // Show that we are no longer in a call, but joining a new one
    TRACE_MSG(("m_uiState %d", m_uiState));
    if (m_uiState != STARTING)
    {
        m_uiState = JOINING;
        UpdatePageButtons();
    }

    // put up init dlg
    if (m_bCallActive)
    {
        ::UpdateWindow(m_hwnd);

        //
        // Our init dialog doesn't have a proc, since it has no UI to
        // interact with.  We destroy it when we are done.  So, do the
        // init stuff here.
        //
        m_hwndInitDlg = ::CreateDialogParam(g_hInstance,
            MAKEINTRESOURCE(IM_INITIALIZING), m_hwnd, NULL, 0);

        if (!m_hwndInitDlg)
        {
            ERROR_OUT(("Couldn't create startup screen for WB"));
        }
        else
        {
            RECT    rcMovie;
            HWND    hwndMovieParent;
            HWND    hwndMovie;

            // Get the rectangle to create the animation control in
            hwndMovieParent = ::GetDlgItem(m_hwndInitDlg, IDC_INITIALIZING_ANIMATION);
            ::GetClientRect(hwndMovieParent, &rcMovie);

            hwndMovie = ::CreateWindowEx(0, ANIMATE_CLASS, NULL,
                WS_CHILD | WS_VISIBLE | ACS_TRANSPARENT | ACS_CENTER,
                rcMovie.left, rcMovie.top,
                rcMovie.right - rcMovie.left, rcMovie.bottom - rcMovie.top,
                hwndMovieParent, (HMENU)IDC_INITIALIZING_ANIMATION,
                g_hInstance, NULL);

            if (hwndMovie != NULL)
            {
                ::SendMessage(hwndMovie, ACM_OPEN, 0, (LPARAM)
                    MAKEINTRESOURCE(WBMOVIE));
            }

            // Disable the main window while the dialog is up.
            ::EnableWindow(m_hwnd, FALSE);

            ::ShowWindow(m_hwndInitDlg, SW_SHOW);
            ::UpdateWindow(m_hwndInitDlg);

            if (hwndMovie != NULL)
            {
                ::SendMessage(hwndMovie, ACM_PLAY, 0xFFFF,
                    MAKELPARAM(0, 0xFFFF));
            }
        }
    }

    //
    // Start joining the call.  Throws an exception on error.
    //
    ASSERT(g_pUsers);
    g_pUsers->Clear();

    uiReturn = g_pwbCore->WBP_JoinCall(bKeep, m_dwJoinDomain);
    if (uiReturn != 0)
    {
        bSuccess = FALSE;
    }

    return(bSuccess);
}




//
//
// Function:    WaitForJoinCallComplete
//
// Purpose:     Join a call - displaying a dialog informing the user of
//              progress.
//
//
BOOL WbMainWindow::WaitForJoinCallComplete(void)
{
    BOOL    bResult = FALSE;
    TMDLG   tmdlg;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WaitForJoinCallComplete");

    //
    // Bring up a dialog to wait for call joining to complete.  This turns
    // the asynchronous registration process into a synchronous process as
    // far as this routine is concerned.
    //

    //
    // Set the window title to show we're no longer registering/joining a
    // call.
    //
	UpdateWindowTitle();

    ASSERT(m_hwndWaitForEventDlg == NULL);

    //
    // This is the data we use in the timed dialog
    //
    ZeroMemory(&tmdlg, sizeof(tmdlg));
    tmdlg.bVisible = FALSE;
    tmdlg.bLockNotEvent = FALSE;
    tmdlg.uiMaxDisplay = MAIN_REGISTRATION_TIMEOUT;

    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(INVISIBLEDIALOG),
        m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);

    ASSERT(m_hwndWaitForEventDlg == NULL);

    //
    // Set the window title to show we're no longer registering/joining a
    // call.
    //
	UpdateWindowTitle();
	
    if (m_uiState != IN_CALL)
    {
        //
        // We failed to join the call
        //
        WARNING_OUT(("User cancelled or joincall failed, m_uiState %d", m_uiState));

        //
        // We must display an error inline here because we will close
        // shortly
        //
        OnDisplayError(WBFE_RC_JOIN_CALL_FAILED, 0);
    }
    else
    {
        bResult = TRUE;
    }

    return(bResult);
}


//
// TimedDlgProc()
// This puts up a visible or invisible dialog which only goes away when
// an event occurs or a certain amount of time has passed.  We store the
// DialogBoxParam parameter, a TMDLG pointer, in our user data.  That is
// from the stack of the DialogBoxParam() caller, so it is valid until that
// function returns, which won't be until a bit after the dialog has been
// destroyed.
//
INT_PTR CALLBACK TimedDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    TMDLG *     ptm;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ptm = (TMDLG *)lParam;
            ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptm);

            //
            // Set the WbMainWindow hwnd
            //
            if (ptm->bLockNotEvent)
            {
                g_pMain->m_hwndWaitForLockDlg = hwnd;
            }
            else
            {
                g_pMain->m_hwndWaitForEventDlg = hwnd;
            }

            //
            // Set max timer
            //
            ::SetTimer(hwnd, TIMERID_MAXDISPLAY, ptm->uiMaxDisplay, NULL);

            //
            // Change the cursor if invisible
            //
            if (!ptm->bVisible)
                ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            fHandled = TRUE;
            break;

        case WM_TIMER:
            ASSERT(wParam == TIMERID_MAXDISPLAY);

            // End the dialog--since we timed out, it acts like cancel
            ::SendMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED), 0);

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        ptm = (TMDLG *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
                        ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));

                        // Clear out the HWND variable
                        if (ptm->bLockNotEvent)
                        {
                            g_pMain->m_hwndWaitForLockDlg = NULL;
                        }
                        else
                        {
                            g_pMain->m_hwndWaitForEventDlg = NULL;
                        }

                        // Restore the cursor
                        if (!ptm->bVisible)
                            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));

                        ::KillTimer(hwnd, TIMERID_MAXDISPLAY);

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    break;
            }

            fHandled = TRUE;
            break;

        //
        // Don't let these dialogs be killed by any other means than our
        // getting an event or timing out.
        //
        case WM_CLOSE:
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}

//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL WbMainWindow::FilterMessage(MSG* pMsg)
{
    BOOL   bResult = FALSE;

   	if ((pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) ||
    	(pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONDBLCLK) ||
	    (pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONDBLCLK) ||
	    (pMsg->message == WM_MBUTTONDOWN || pMsg->message == WM_MBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCLBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCRBUTTONDOWN || pMsg->message == WM_NCRBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCMBUTTONDOWN || pMsg->message == WM_NCMBUTTONDBLCLK))
   	{
        // Cancel any tooltip up
        ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
   	}

	// handle tooltip messages (some messages cancel, some may cause it to popup)
	if ((pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE ||
		 pMsg->message == WM_LBUTTONUP || pMsg->message == WM_RBUTTONUP ||
		 pMsg->message == WM_MBUTTONUP) &&
		(GetKeyState(VK_LBUTTON) >= 0 && GetKeyState(VK_RBUTTON) >= 0 &&
		 GetKeyState(VK_MBUTTON) >= 0))
	{
#if 0
        //
        // If this mouse move isn't for a descendant of the main window, skip
        // it.  For example, when the tooltip is shown, it gets a mousemove
        // to itself, which if we didn't check for it, would cause us to
        // immediately dismiss this!
        //
        HWND    hwndTmp = pMsg->hwnd;

        while (hwndTmp && (::GetWindowLong(hwndTmp, GWL_STYLE) & WS_CHILD))
        {
            hwndTmp = ::GetParent(hwndTmp);
        }

        if (hwndTmp != m_hwnd)
        {
            // This is not for us, it's for another top level window in
            // our app.
            goto DoneToolTipFiltering;
        }
#endif

		// determine which tool was hit
        POINT   pt;

        pt = pMsg->pt;
		::ScreenToClient(m_hwnd, &pt);

		TOOLINFO tiHit;

        ZeroMemory(&tiHit, sizeof(tiHit));
		tiHit.cbSize = sizeof(TOOLINFO);

		int nHit = OnToolHitTest(pt, &tiHit);

		if (m_nLastHit != nHit)
		{
			if (nHit != -1)
			{
				// add new tool and activate the tip
                if (!::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&tiHit))
                {
                    ERROR_OUT(("TTM_ADDTOOL failed"));
                }

				if (::GetActiveWindow() == m_hwnd)
				{
					// allow the tooltip to popup when it should
                    ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);

					// bring the tooltip window above other popup windows
					::SetWindowPos(m_hwndToolTip, HWND_TOP, 0, 0, 0, 0,
						SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE);
				}
			}

			// relay mouse event before deleting old tool
            ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);

			// now safe to delete the old tool
            if (m_tiLastHit.cbSize != 0)
                ::SendMessage(m_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&m_tiLastHit);

            m_nLastHit = nHit;
            m_tiLastHit = tiHit;
		}
		else
		{
			// relay mouse events through the tooltip
			if (nHit != -1)
                ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);
		}
	}

#if 0
DoneToolTipFiltering:
#endif
    // Assume we will use the main accelerator table
    HACCEL hAccelTable = m_hAccelTable;

    // If this window has focus, just continue
    HWND hwndFocus = ::GetFocus();
    if (hwndFocus && (hwndFocus != m_hwnd))
    {
        // Check whether an edit field in the pages group has the focus
        if (m_AG.IsChildEditField(hwndFocus))
        {
            hAccelTable = m_hAccelPagesGroup;
        }
        // Check whether text editor has the focus and is active
        else if (   (hwndFocus == m_drawingArea.m_hwnd)
                 && (m_drawingArea.TextEditActive()))
        {
            // Let editbox do its own acceleration.
            hAccelTable = NULL;
        }
    }

    return (   (hAccelTable != NULL)
          && ::TranslateAccelerator(m_hwnd, hAccelTable, pMsg));
}




//
//
// Function:    OnDisplayError
//
// Purpose:     Display an error message
//
//
void WbMainWindow::OnDisplayError(WPARAM uiFEReturnCode, LPARAM uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDisplayError");

    // Only continue if we are not currently displaying an error
    if (!m_bDisplayingError)
    {
        // Show that we are currently displaying an error message
        m_bDisplayingError = TRUE;

        // Display the error
        ::ErrorMessage((UINT)uiFEReturnCode, (UINT)uiDCGReturnCode);

        // Show that we are no longer displaying an error
        m_bDisplayingError = FALSE;
    }
}


//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update the progress
//              meter and the sync position.
//
//
void WbMainWindow::OnTimer(UINT_PTR idTimer)
{
    TRACE_TIMER(("WbMainWindow::OnTimer"));

    //
    // Only do anything if the timer has not been switched off (this may be an
    // old timer message left in the queue when we stopped the timer).
    //
    if (m_bTimerActive)
    {
        //
        // Check for sync position update needed
        //

        // Check whether an update is flagged
        if (m_bSyncUpdateNeeded)
        {
            TRACE_TIMER(("Updating sync position"));

            // Check whether the local user is still synced
            if ((m_uiState == IN_CALL) &&
                (m_pLocalUser != NULL) &&
                (m_pLocalUser->IsSynced()) &&
                (!WB_ContentsLocked()))
            {
                RECT    rcVis;

                // Update the local user's position information
                m_drawingArea.GetVisibleRect(&rcVis);

                m_pLocalUser->SetVisibleRect(&rcVis);

                // Write the sync position from the local user's current position
                m_pLocalUser->PutSyncPosition();
            }

            // Show that the update has been done
            m_bSyncUpdateNeeded = FALSE;
        }
    }
}


//
//
// Function:    OnPaletteChanged
//
// Purpose:     The palette has changed.
//
//
void WbMainWindow::OnPaletteChanged(HWND hwndPalette)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaletteChanged");

    if ((hwndPalette != m_hwnd) &&
        (hwndPalette != m_drawingArea.m_hwnd))
    {
        // Tell the drawing area to realize its palette
        m_drawingArea.RealizePalette( TRUE );
    }
}



//
//
// Function:    OnQueryNewPalette
//
// Purpose:     We are getting focus and must realize our palette
//
//
LRESULT WbMainWindow::OnQueryNewPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnQueryNewPalette");

    // Tell the drawing area to realize its palette
    m_drawingArea.RealizePalette( FALSE );

    return TRUE;
}



//
//
// Function:    WbMainWindowEventHandler
//
// Purpose:     Event handler for WbMainWindow objects. This is a class
//              wide function. The client data passed to it is a pointer
//              to the instance of WbMainWindow for which the event is
//              intended.
//
//
BOOL CALLBACK WbMainWindowEventHandler
(
    LPVOID  utHandle,
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    if (g_pMain->m_hwnd != NULL)
    {
        return(g_pMain->EventHandler(event, param1, param2));
    }
    else
    {
        return(FALSE);
    }
}


//
//
// Function:    EventHandler
//
// Purpose:     Handler for DC-Groupware events for this object
//
//
BOOL WbMainWindow::EventHandler(UINT Event, UINT_PTR param1, UINT_PTR param2)
{
    BOOL    processed;

    switch (Event)
    {
        case CMS_NEW_CALL:
        case CMS_END_CALL:

        case ALS_LOCAL_LOAD:
        case ALS_REMOTE_LOAD_RESULT:

        case WBP_EVENT_JOIN_CALL_OK:
        case WBP_EVENT_JOIN_CALL_FAILED:
        case WBP_EVENT_NETWORK_LOST:
        case WBP_EVENT_ERROR:
        case WBP_EVENT_PAGE_CLEAR_IND:
        case WBP_EVENT_PAGE_ORDER_UPDATED:
        case WBP_EVENT_PAGE_DELETE_IND:
        case WBP_EVENT_CONTENTS_LOCKED:
        case WBP_EVENT_PAGE_ORDER_LOCKED:
        case WBP_EVENT_UNLOCKED:
        case WBP_EVENT_LOCK_FAILED:
        case WBP_EVENT_GRAPHIC_ADDED:
        case WBP_EVENT_GRAPHIC_MOVED:
        case WBP_EVENT_GRAPHIC_UPDATE_IND:
        case WBP_EVENT_GRAPHIC_REPLACE_IND:
        case WBP_EVENT_GRAPHIC_DELETE_IND:
        case WBP_EVENT_PERSON_JOINED:
        case WBP_EVENT_PERSON_LEFT:
        case WBP_EVENT_PERSON_UPDATE:
        case WBP_EVENT_PERSON_REPLACE:
        case WBP_EVENT_SYNC_POSITION_UPDATED:
        case WBP_EVENT_LOAD_COMPLETE:
        case WBP_EVENT_LOAD_FAILED:
            // Process the Event
            ProcessEvents(Event, param1, param2);
            processed = TRUE;
            break;

        default:
            processed = FALSE;
            break;
    }

    return(processed);
}


//
//
// Function:    PopupContextMenu
//
// Purpose:     Popup the context menu for the drawing area. This is called
//              by the drawing area window on a right mouse click.
//
//
void WbMainWindow::PopupContextMenu(int x, int y)
{
    POINT   surfacePos;
    RECT    clientRect;
    DCWbGraphic * pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::PopupContextMenu");

    surfacePos.x = x;
    surfacePos.y = y;

    // figure out which popup menu to use (bug 426)
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        m_drawingArea.ClientToSurface(&surfacePos);
        if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) != NULL )
        {
            // we clicked over an object, see if its already selected
            if( !m_drawingArea.IsSelected( pGraphic ) )
            {
                // object is not already selected, zap current selection and then select it
                m_drawingArea.ClearSelection();
                m_drawingArea.SelectGraphic( pGraphic );
            }
            else
            {
                // plug leak by deleteing pGraphic
                delete pGraphic;
            }
        }

        if( m_drawingArea.GraphicSelected() )
        {
            // selector tool is active, and one or more objects are selected
            m_hInitMenu = m_hGrobjContextMenu;
        }
        else
        {
            // no current selection, show drawing menu
            m_hInitMenu = m_hContextMenu;
        }
    }
    else
    {
        // no objects selected, use drawing menu
        m_hInitMenu = m_hContextMenu;
    }

    // set up current menu state
    SetMenuStates(m_hInitMenu);

    // pop it up
    ::GetClientRect(m_drawingArea.m_hwnd, &clientRect);
    ::MapWindowPoints(m_drawingArea.m_hwnd, NULL, (LPPOINT)&clientRect.left, 2);

    ::TrackPopupMenu(m_hInitMenu, TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
                                 x + clientRect.left,
                                 y + clientRect.top,
                                 0,
                                 m_hwnd,
                                 NULL);

    // reset m_hInitMenu to indicate the popup menu isn't being shown anymore
    m_hInitMenu = NULL;
}




//
//
// Function: ProcessEvents
//
// Purpose: Process events that have been queued internally
//
//
void WbMainWindow::ProcessEvents(UINT Event, UINT_PTR param1, UINT_PTR param2)
{
    HWND hwndLastPopup;

    TRACE_EVENT(("WbMainWindow::ProcessEvents"));

    //
    // If we are closing, ignore it.
    //
    if (m_uiState == CLOSING)
    {
        TRACE_EVENT(("ProcessEvents: ignored because WB is closing"));
        return;
    }

    //
    // If we are busy drawing,  we postpone it until later when we can
    // handle it.
    //
    // If the page sorter dialog is up, it gets notified by the appropriate
    // event handler after the fact.
    //
    if (m_drawingArea.IsBusy())
    {
        TRACE_EVENT(("Reposting event %x, param1 %d param2 %d", Event, param1, param2));
        g_pwbCore->WBP_PostEvent(200, Event, param1, param2);
        return;
    }

    TRACE_EVENT(("Event %x, m_uiState %d", Event, m_uiState));

    //
    // Process according to the event type.
    //
    switch (Event)
    {
        case CMS_NEW_CALL:
            OnCMSNewCall((BOOL)param1, (DWORD)param2);
            break;

        case CMS_END_CALL:
            OnCMSEndCall();
            break;

        case ALS_LOCAL_LOAD:
            switch (m_uiState)
            {
                case IN_CALL:
                case ERROR_STATE:
                    // show the main window normal/minimized as necessary
                    hwndLastPopup = ::GetLastActivePopup(m_hwnd);

                    if (::IsIconic(m_hwnd))
                        ::ShowWindow(m_hwnd, SW_RESTORE);
                    else
                        ::ShowWindow(m_hwnd, SW_SHOW);

                    ::SetForegroundWindow(hwndLastPopup);

                    if (param2)
                    {
                        if (m_uiState == IN_CALL)
                            LoadCmdLine((LPCSTR)param2);
                        ::GlobalFree((HGLOBAL)param2);
                    }
                    break;

                default:
                    TRACE_MSG(("Joining a call so try load later",
                            (LPCTSTR)param2));
                    g_pwbCore->WBP_PostEvent(400, Event, param1, param2);
                    break;
            }
            break;

        case ALS_REMOTE_LOAD_RESULT:
            OnALSLoadResult((UINT)param1);
            break;

        case WBP_EVENT_JOIN_CALL_OK:
            OnWBPJoinCallOK();
            break;

        case WBP_EVENT_JOIN_CALL_FAILED:
            OnWBPJoinCallFailed();
            break;

        case WBP_EVENT_NETWORK_LOST:
            OnWBPNetworkLost();
            break;

        case WBP_EVENT_ERROR:
            OnWBPError();
            break;

        case WBP_EVENT_PAGE_CLEAR_IND:
            OnWBPPageClearInd((WB_PAGE_HANDLE) param1);
            break;

        case WBP_EVENT_PAGE_ORDER_UPDATED:
            OnWBPPageOrderUpdated();
            break;

        case WBP_EVENT_PAGE_DELETE_IND:
            OnWBPPageDeleteInd((WB_PAGE_HANDLE) param1);
            break;

        case WBP_EVENT_CONTENTS_LOCKED:
            OnWBPContentsLocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PAGE_ORDER_LOCKED:
            OnWBPPageOrderLocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_UNLOCKED:
            OnWBPUnlocked((POM_OBJECT) param2);
            break;

        case WBP_EVENT_LOCK_FAILED:
            OnWBPLockFailed();
            break;

        case WBP_EVENT_GRAPHIC_ADDED:
            OnWBPGraphicAdded((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_MOVED:
            OnWBPGraphicMoved((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_UPDATE_IND:
            OnWBPGraphicUpdateInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_REPLACE_IND:
            OnWBPGraphicReplaceInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_GRAPHIC_DELETE_IND:
            OnWBPGraphicDeleteInd((WB_PAGE_HANDLE) param1, (WB_GRAPHIC_HANDLE) param2);
            break;

        case WBP_EVENT_PERSON_JOINED:
            OnWBPUserJoined((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PERSON_LEFT:
            OnWBPUserLeftInd((POM_OBJECT) param2);
            break;

        case WBP_EVENT_PERSON_UPDATE:
            OnWBPUserUpdateInd((POM_OBJECT) param2, FALSE);
            break;

        case WBP_EVENT_PERSON_REPLACE:
            OnWBPUserUpdateInd((POM_OBJECT) param2, TRUE);
            break;

        case WBP_EVENT_SYNC_POSITION_UPDATED:
            OnWBPSyncPositionUpdated();
            break;

        case WBP_EVENT_LOAD_COMPLETE:
            OnWBPLoadComplete();
            break;

        case WBP_EVENT_LOAD_FAILED:
            OnWBPLoadFailed();
            break;

        default:
            WARNING_OUT(("Unrecognized event %x", Event));
            break;
    }
}


//
//
// Function:    OnCMSNewCall
//
// Purpose:     Handler for CMS_NEW_CALL
//
//
void WbMainWindow::OnCMSNewCall(BOOL fTopProvider, DWORD _m_dwDomain)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCMSNewCall");

    //
    // If we created the call
    //
    if (fTopProvider)
    {
        // Join the call, keep existing contents
        if (m_uiState == IN_CALL)
        {
            //
            // Join the call but keep any existing messages.
            //
            ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, 1, (LONG) _m_dwDomain);
        }
        else
        {
            m_bJoinCallPending = TRUE;
            m_dwPendingDomain = _m_dwDomain;
            m_bPendingCallKeepContents = TRUE;
        }
    }
    else
    {
        CM_STATUS status;

        CMS_GetStatus(&status);

        if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
        {
            WARNING_OUT(("OLD WB: not joining call, not permitted"));
            return;
        }

        if (m_uiState == IN_CALL)
        {
            //
            // Join the call, throwing away our current contents (after
            // prompting the user to save them first).
            //
            ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, 0, (LONG) _m_dwDomain);
        }
        else
        {
            m_bJoinCallPending = TRUE;
            m_dwPendingDomain = _m_dwDomain;
            m_bPendingCallKeepContents = FALSE;
        }
    }

    //
    // Get the call status correct.
    //
    m_bCallActive = TRUE;
	UpdateWindowTitle();
}

//
//
// Function:    OnJoinPendingCall
//
// Purpose:     Handler for WM_USER_JOIN_PENDING_CALL
//
//
void WbMainWindow::OnJoinPendingCall(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnJoinPendingCall");

    //
    // If there's still a pending call (haven't received an end-call message
    // between posting the WM_USER_JOIN_PENDING_CALL and getting here).
    //
    if (m_bJoinCallPending)
    {
        //
        // Post a message to join the call
        //
        ::PostMessage(m_hwnd, WM_USER_JOIN_CALL,
                  m_bPendingCallKeepContents,
                  (LONG) m_dwPendingDomain);

        // cancel call-pending status
        m_bJoinCallPending = FALSE;
    }
}


//
//
// Function:    OnCMSEndCall
//
// Purpose:     Handler for CMS_END_CALL
//
//
void WbMainWindow::OnCMSEndCall(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCMSEndCall");

    //
    // Flag to cancel any current join-call processing, and destroy any
    // associated dialogs.
    //
    if (m_bPromptingJoinCall)
    {
        m_bPromptingJoinCall = FALSE;
        if (m_hwndQuerySaveDlg != NULL)
        {
            ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
                MAKELONG(IDCANCEL, BN_CLICKED), 0);
            ASSERT(m_hwndQuerySaveDlg == NULL);
        }
    }

    //
    // Show that we are no longer in a call
    //
    m_dwDomain = OM_NO_CALL;

    //
    // If currently in the process of joining a call, then set the domain
    // we're joining to NO_CALL and join the local (singleton) domain.
    // Get the call status correct.
    //
    m_bCallActive = FALSE;
    TRACE_MSG(("m_uiState %d", m_uiState));
    m_dwDomain = OM_NO_CALL;

    //
    // Show there is no call pending
    //
    m_bJoinCallPending = FALSE;

    //
    // Update the window title with "not in call"
    //
	UpdateWindowTitle();
}

//
//
// Function:    OnWBPJoinCallOK
//
// Purpose:     Handler for WBP_EVENT_JOIN_CALL_OK
//
//
void WbMainWindow::OnWBPJoinCallOK(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPJoinCallOK");

    //
    // Record that we have joined the call, but the drawing area is not yet
    // ready for input (because we have not yet attached to a page).
    //
    m_uiState = JOINED;

    //
    // Get the local user
    //
    m_pLocalUser = WB_LocalUser();
    if (!m_pLocalUser)
    {
        ERROR_OUT(("Can't join call; can't create local user object, m_pLocalUser!"));
        m_uiState = ERROR_STATE;
    }
    else
    {
        //
        // Get the first user in the call
        //
        WbUser* pUser = WB_GetFirstUser();

        //
        // Loop through all available users
        //
        while (pUser != NULL)
        {
            //
            // Make updates necessary for a user joining
            //
            UserJoined(pUser);

            //
            // Get the next user
            //
            pUser = WB_GetNextUser(pUser);
        }

        //
        // If the registration dialog is up - cancel it
        //
        m_uiState = IN_CALL; // have to set m_uiState before zapping
                                      // m_hwndWaitForEventDlg or it will
                                      // think the call failed now (the
                                      // delay has been removed from
                                      // EndDialogDelayed() (bug 3881)
    }

    if (m_hwndWaitForEventDlg != NULL)
    {
        TRACE_MSG(("Joined call OK - end dialog"));
        ::SendMessage(m_hwndWaitForEventDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForEventDlg == NULL);
    }

    if (!m_pLocalUser)
    {
        //
        // BAIL out, we can't join the call
        return;
    }

    //
    // Now complete the join call processing
    //
    TRACE_MSG(("Successfully joined the call"));
    m_dwDomain = m_dwJoinDomain;

    //
    // If we have never attached to a page before (ie at start up), attach
    // to the first available page in the drawing area.  If we are joining
    // a call then we reattach to the current page
    //
    if (m_hCurrentPage == WB_PAGE_HANDLE_NULL)
    {
        TRACE_MSG(("Attach to first page"));
        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &m_hCurrentPage);
    }
    else
    {
        TRACE_DEBUG(("Just joined new call, reattach to the current page."));
    }
    m_drawingArea.Attach(m_hCurrentPage);

    // Display the initial status
    UpdateStatus();


    ::SetTimer(m_hwnd, TIMERID_PROGRESS_METER, MAIN_PROGRESS_TIMER, NULL);
    m_bTimerActive = TRUE;

    //
    // Unlock the drawing area, allowing user updates (unless its already
    // locked by someone else)
    //
    if (!WB_ContentsLocked())
    {
        UnlockDrawingArea();
    }

    // Set the substate (also updates page buttons)
    SetSubstate(SUBSTATE_IDLE);

    //
    // If we aren't synced, then sync now.
    // Set the window title to show we're no longer registering/joining a
    // call
    //
    Sync();
	UpdateWindowTitle();

    //
    // If we were joining the local domain, and a join call message arrived
    // in the meantime, then join that call now.
    //
    if ((m_bJoinCallPending) && (m_dwJoinDomain == OM_NO_CALL))
    {
        ::PostMessage(m_hwnd, WM_USER_JOIN_PENDING_CALL, 0, 0L);
    }
}


//
//
// Function:    OnWBPJoinCallFailed
//
// Purpose:     Handler for WBP_EVENT_JOIN_CALL_FAILED
//
//
void WbMainWindow::OnWBPJoinCallFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPJoinCallFailed");

    //
    // If we have just failed to join a new call (not a single domain) it
    // may be because the call ended before we had time to join it
    // completely - try joining the single domain.
    //
    if ((m_uiState == STARTING) && (m_dwJoinDomain != OM_NO_CALL))
    {
        WARNING_OUT(("Failed to join call on startup, try local domain"));
        m_dwJoinDomain = OM_NO_CALL;
        m_bCallActive  = FALSE;
        JoinCall(FALSE);
    }
    else
    {
        //
        // Tell the registration dialog to finish
        //
        if (m_hwndWaitForEventDlg != NULL)
        {
            WARNING_OUT(("Failed to join call - end dialog"));
            ::SendMessage(m_hwndWaitForEventDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
            ASSERT(m_hwndWaitForEventDlg == NULL);
        }

        m_uiState = ERROR_STATE;
    }
}


//
//
// Function:    OnWBPNetworkLost
//
// Purpose:     Handler for WBP_EVENT_NETWORK_LOST
//
//
void WbMainWindow::OnWBPNetworkLost(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPNetworkLost");

    //
    // We have lost contact with the other people in the call.
    // Treat as if we got an end call (we should get an end call too, but
    // other intervening events might occur (such as trying to join a
    // call).
    //
    OnCMSEndCall();
}

//
//
// Function:    OnWBPError
//
// Purpose:     Handler for WBP_EVENT_ERROR
//
//
void WbMainWindow::OnWBPError(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPError");

    // Inform the user of the error.
    ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, 0);
}

//
//
// Function:    OnWBPPageClearInd
//
// Purpose:     Handler for WBP_EVENT_PAGE_CLEAR_IND
//
//
void WbMainWindow::OnWBPPageClearInd(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageClearInd");

    // Confirm the clearing of the page. This is OK even if the page being
    // cleared is the current page because we already know that the drawing
    // area is not busy (otherwise we would not be here).

    // If there's an object on the page which has been copied to the
    // clipboard with delayed rendering, then save it
    if (CLP_LastCopiedPage() == hPage)
    {
        CLP_SaveDelayedGraphic();
    }

    // If it is the current page being cleared
    if (m_hCurrentPage == hPage)
        {
        m_drawingArea.PageCleared();
        }

    // If there is a last deleted graphic
    // and it belongs to the page being cleared.
    if ((m_LastDeletedGraphic.GotTrash()) &&
        (m_LastDeletedGraphic.Page() == hPage))
    {
        // Free the last deleted graphic
        m_LastDeletedGraphic.BurnTrash();
    }

    g_pwbCore->WBP_PageClearConfirm(hPage);

    //
    // Notify the page sorter AFTER the page has been cleared
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGECLEARIND, (WPARAM)hPage, 0);
    }
}


//
//
// Function:    OnWBPPageOrderUpdated
//
// Purpose:     Handler for WBP_EVENT_PAGE_ORDER_UPDATED
//
//
void WbMainWindow::OnWBPPageOrderUpdated(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageOrderUpdated");

    m_drawingArea.CancelDrawingMode();

    // The page order has changed, we just need to update the number of the
    // current page in the pages group.
    UpdateStatus();

    //
    // Notify the page sorter AFTER the page order has been updated
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGEORDERUPD, 0, 0);
    }
}

//
//
// Function:    OnWBPPageDeleteInd
//
// Purpose:     Handler for WBP_EVENT_PAGE_DELETE_IND
//
//
void WbMainWindow::OnWBPPageDeleteInd(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageDeleteInd");

    //
    // Notify the page sorter BEFORE the page is deleted
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_PAGEDELIND, (WPARAM)hPage, 0);
    }

    m_drawingArea.CancelDrawingMode();

    // Remove it from the page-position map
    PAGE_POSITION *mapob;
    POSITION savedPos;
	POSITION position = m_pageToPosition.GetHeadPosition();
	BOOL bFound = FALSE;
	while (position && !bFound)
	{
		savedPos = position;
		mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
		if ( mapob->hPage == hPage)
		{
			bFound = TRUE;
		}
	}

	if(bFound)
	{
        m_pageToPosition.RemoveAt(savedPos);
        delete mapob;
    }

    // A page has been deleted.  If it is the current page we must attach
    // a different page to the drawing area. In any case we should confirm
    // the delete.

    // If there's an object on the page which has been copied to the
    // clipboard with delayed rendering, then save it
    if (CLP_LastCopiedPage() == hPage)
    {
        CLP_SaveDelayedGraphic();
    }

    if (hPage == m_hCurrentPage)
    {
        // Check whether we are deleting the last page
        WB_PAGE_HANDLE hNewPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_LAST, &hNewPage);
        if (hNewPage == hPage)
        {
            // We are deleting the last page, so go back one
            hNewPage = PG_GetPreviousPage(hPage);
        }
        else
        {
            // We are not deleting the last page, so go forward one
            hNewPage = PG_GetNextPage(hPage);
        }

        // Check that we got a different page to the one being deleted
        ASSERT(hNewPage != hPage);

        // Lock the drawing area - this ensures we are no longer editing
        // any text etc.
        LockDrawingArea();

        // Move to the new page
        GotoPage(hNewPage);

        // Unlock the drawing area (unless we're doing a new, in which case we
        // leave it locked - it will become unlocked when the new completes)
        if (   (!WB_ContentsLocked())
            && (m_uiState == IN_CALL)
            && (m_uiSubState != SUBSTATE_NEW_IN_PROGRESS))
        {
            UnlockDrawingArea();
        }
    }

    // If there is a last deleted graphic
    if ((m_LastDeletedGraphic.GotTrash()) &&
        (m_LastDeletedGraphic.Page() == hPage))
    {
        // Free the last deleted graphic
        m_LastDeletedGraphic.BurnTrash();
    }

    // if the remote pointer is on the deleted page then turn it off
    ASSERT(m_pLocalUser);
    DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();
    if (   (pPointer->IsActive())
        && (pPointer->Page() == hPage))
        {
        OnRemotePointer();
        }

    // Let the core delete the page
    g_pwbCore->WBP_PageDeleteConfirm(hPage);

    // if this is last page to be deleted, then the file/new is complete
    if ((m_uiSubState == SUBSTATE_NEW_IN_PROGRESS)
        && (g_pwbCore->WBP_ContentsCountPages() == 1))
        {
        SetSubstate(SUBSTATE_IDLE);

        ReleasePageOrderLock();

        if (!WB_ContentsLocked())
            {
            UnlockDrawingArea();
            }
        }

    // Update the status (there is a new number of pages)
    UpdateStatus();
}

//
//
// Function:    OnWBPContentsLocked
//
// Purpose:     Handler for WBP_EVENT_CONTENTS_LOCKED
//
//
void WbMainWindow::OnWBPContentsLocked(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPContentsLocked");

    //
    // Notify page sorter dialog that the lock status has changed
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    if (m_uiState != IN_CALL)
    {
        TRACE_MSG(("Lock indication received out of call - ignored"));
    }
    else
    {
        ASSERT(m_pLocalUser);

        if (m_pLocalUser->Handle() == hUser)
        {
            // We have acquired the lock

            // Set the locked check mark
            CheckMenuItem(IDM_LOCK);

            // Tell the tool bar of the new selection
            m_TB.PushDown(IDM_LOCK);
        }
        else
        {
            //
            // A remote user has acquired the lock:
            // If we're not synced, then sync now.
            //
            Sync();

            // Tell the drawing area it is now locked
            LockDrawingArea();

            // ensure the page button enable/disable state is correct
            UpdatePageButtons();
        }
    }

    //
    // If the lock dialog is up - cancel it.
    //
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }
}

//
//
// Function:    OnWBPPageOrderLocked
//
// Purpose:     Handler for WBP_EVENT_PAGE_ORDER_LOCKED
//
//
void WbMainWindow::OnWBPPageOrderLocked(POM_OBJECT)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPPageOrderLocked");

    // If the lock dialog is up - cancel it
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }

    // Update the page sorter
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    if (!WB_GotLock())
    {
        EnableToolbar( FALSE );
        UpdatePageButtons();
    }
}

//
//
// Function:    OnWBPUnlocked
//
// Purpose:     Handler for WBP_EVENT_UNLOCKED
//
//
void WbMainWindow::OnWBPUnlocked(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUnlocked");

    // Update the page sorter if it's around
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_LOCKCHANGE, 0, 0);
    }

    // Uncheck the lock menu item
    UncheckMenuItem(IDM_LOCK);

    // Tell the tool bar of the change
    m_TB.PopUp(IDM_LOCK);

    // If a remote user is releasing the lock, and we're in a state where
    // it's safe to unlock the drawing area...
    if ((m_pLocalUser != NULL) &&
        (m_pLocalUser->Handle() != hUser) &&
        (m_uiState == IN_CALL))
    {
        // Tell the drawing area it is no longer locked
        UnlockDrawingArea();
    }

    // ensure the page button enable/disable state is correct
    UpdatePageButtons();
    m_bUnlockStateSettled = TRUE; //Allow page operations now
}

//
//
// Function:    OnWBPLockFailed
//
// Purpose:     Handler for WBP_EVENT_LOCK_FAILED
//
//
void WbMainWindow::OnWBPLockFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLockFailed");

    // If the lock dialog is up - kill it
    if (m_hwndWaitForLockDlg != NULL)
    {
        ::SendMessage(m_hwndWaitForLockDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED), 0);
        ASSERT(m_hwndWaitForLockDlg == NULL);
    }
}

//
//
// Function:    OnWBPGraphicAdded
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_ADDED
//
//
void WbMainWindow::OnWBPGraphicAdded
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicAdded");

    // We only need to take action if the page to which the graphic has
    // been added is the current page.
    if (hPage == m_hCurrentPage && (!(hGraphic->flags & DELETED)))
    {
        // Retrieve the graphic that has been added
        DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

        // Tell the drawing area of the new graphic
        m_drawingArea.GraphicAdded(pGraphic);

        // Free the graphic
        delete pGraphic;
    }
}

//
//
// Function:    OnWBPGraphicMoved
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_MOVED
//
//
void WbMainWindow::OnWBPGraphicMoved
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicMoved");

    // We only need to take action if the graphic belongs to the current page
    if (hPage == m_hCurrentPage  && (!(hGraphic->flags & DELETED)))
    {
        // Retrieve the graphic that has been moved
        DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

        if( NULL != pGraphic )
        {
            // Tell the drawing area of the new graphic
            m_drawingArea.GraphicUpdated(pGraphic, TRUE, FALSE);

            // set paint to draw only objects above this object inclusive
            if (pGraphic->IsGraphicTool() == enumGraphicText)
            {
                m_drawingArea.SetStartPaintGraphic( NULL );
                    // this optimization screws up text
                    // so short it out if this is text
                    // (text draws transparently and background
                    //  isn't repainted properly if this is active)
            }
            else
            {
                m_drawingArea.SetStartPaintGraphic( hGraphic );
                // not text so optimize by drawing only this
                // object and everthing above it
            }

            // Free the graphic
            delete pGraphic;
        }
    }
}

//
//
// Function:    OnWBPGraphicUpdateInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_UPDATE_IND
//
//
void WbMainWindow::OnWBPGraphicUpdateInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicUpdateInd");

	if(hGraphic->flags & DELETED)
	{
		return;
	}

    PWB_GRAPHIC  pOldHeader;
    PWB_GRAPHIC  pOldHeaderCopy;
    DCWbGraphic* pOldGraphic;

    PWB_GRAPHIC  pNewHeader;
    DCWbGraphic* pNewGraphic;

    if (hPage != m_hCurrentPage)
    {
        // nothing visual has changed, confirm and we're done
        g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);
        return;
    }


    // Retrieve the original graphic and make a copy
    // Get the page of the update
    pOldHeader = PG_GetData(hPage, hGraphic);
    pOldHeaderCopy = (PWB_GRAPHIC) new BYTE[ pOldHeader->length ];

    if( pOldHeaderCopy == NULL )
    {
        ERROR_OUT( ("Can't copy pOldHeader, can't update drawing") );

        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pOldHeader );
        g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);
        return;
    }

    CopyMemory( (PVOID)pOldHeaderCopy, (CONST VOID *)pOldHeader, pOldHeader->length );

    // confirm and get the new one
    g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pOldHeader );
    g_pwbCore->WBP_GraphicUpdateConfirm(hPage, hGraphic);

    pNewHeader = PG_GetData(hPage, hGraphic);

    // This update might affect painting. See if old and new are visually different
    if( HasGraphicChanged( pOldHeaderCopy, (const PWB_GRAPHIC)pNewHeader ) )
    {
        // they're different, invalidate/erase old graphic's bounding rect
        pOldGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic, pOldHeaderCopy );
        m_drawingArea.GraphicUpdated( pOldGraphic, FALSE, TRUE );

        // draw new graphic (don't need to erase)
        pNewGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic, pNewHeader );
        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pNewHeader );
        m_drawingArea.GraphicUpdated( pNewGraphic, TRUE, FALSE );

        // If the graphic is selected, ensure the attributes bar is up to date
        if (m_drawingArea.GraphicSelected())
            {
            DCWbGraphic* pSelectedGraphic = m_drawingArea.GetSelection();
            if ((pSelectedGraphic != NULL) &&
                (pSelectedGraphic->Handle() == hGraphic))
                {
                m_pCurrentTool->SelectGraphic(pNewGraphic);
                OnUpdateAttributes();
                }
            }

        delete pOldGraphic;
        delete pNewGraphic;
    }
    else
    {
        g_pwbCore->WBP_GraphicRelease(hPage, hGraphic, pNewHeader);
    }

    delete [] pOldHeaderCopy;
}



//
//
// Function:    OnWBPGraphicReplaceInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_REPLACE_IND
//
//
void WbMainWindow::OnWBPGraphicReplaceInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicReplaceInd");

	if(hGraphic->flags & DELETED)
	{
		return;
	}

    // Retrieve the graphic that has been replaced
    DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    if (pGraphic->IsGraphicTool() == enumGraphicFreeHand)
    {
        // Confirm the replace - the graphic reads its new details
        pGraphic->ReplaceConfirm();

        // Only redraw the graphic if it is on the current page
        if (hPage == m_hCurrentPage)
        {
            // Redraw the graphic
            m_drawingArea.GraphicFreehandUpdated(pGraphic);
        }
    }
    else
    {
        // We make two updates to the drawing area - one with the graphic in its
        // current state and one after the update is confirmed. The first one
        // invalidates the rectangle that the graphic now occupies. The second one
        // invalidates the new rectangle. This ensures that the graphic is
        // correctly redrawn.

        // If the graphic is on the current page...
        if (hPage == m_hCurrentPage)
        {
            // Update the drawing area for the old version of the graphic
            m_drawingArea.GraphicUpdated(pGraphic, FALSE);
        }

        // Confirm the replace - the graphic reads its new details
        pGraphic->ReplaceConfirm();

        // If the graphic is on the current page...
        if (hPage == m_hCurrentPage)
        {
            // Update the drawing area for the new version of the graphic
            m_drawingArea.GraphicUpdated(pGraphic, TRUE);
        }
    }

    // If the graphic is selected, ensure the attributes bar is up to date
    if (m_drawingArea.GraphicSelected())
    {
        DCWbGraphic* pSelectedGraphic = m_drawingArea.GetSelection();
        if ((pSelectedGraphic != NULL) &&
            (pSelectedGraphic->Handle() == hGraphic))
        {
            m_pCurrentTool->SelectGraphic(pGraphic);
            OnUpdateAttributes();
        }
    }

    // Free the graphic
    delete pGraphic;
}

//
//
// Function:    OnWBPGraphicDeleteInd
//
// Purpose:     Handler for WBP_EVENT_GRAPHIC_DELETE_IND
//
//
void WbMainWindow::OnWBPGraphicDeleteInd
(
    WB_PAGE_HANDLE      hPage,
    WB_GRAPHIC_HANDLE   hGraphic
)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPGraphicDeleteInd");

    // if the graphic was copied into the clipboard and was delayed,
    // then save it in case we are asked to render it later
    if (   (CLP_LastCopiedPage() == hPage)
        && (CLP_LastCopiedGraphic() == hGraphic))
    {
        CLP_SaveDelayedGraphic();
    }

    // Retrieve the graphic that is to be deleted
    DCWbGraphic* pGraphic = DCWbGraphic::ConstructGraphic(hPage, hGraphic);

    // If the graphic is on the current page...
    if (hPage == m_hCurrentPage)
    {
        // Update the drawing area
        m_drawingArea.GraphicDeleted(pGraphic);
    }

    // Confirm the delete
    g_pwbCore->WBP_GraphicDeleteConfirm(hPage, hGraphic);

    // Free the graphic
    delete pGraphic;
}

//
//
// Function:    UserJoined
//
// Purpose:     Make updates necessary for a new user joining the call
//
//
void WbMainWindow::UserJoined(WbUser* pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::UserJoined");

    // Get the user's remote pointer
    ASSERT(pUser);
    DCWbGraphicPointer* pPointer = pUser->GetPointer();

    // If the pointer is active and on the current page...
    ASSERT(pPointer);

    if (   (pPointer->IsActive())
        && (pPointer->Page() == m_hCurrentPage))
    {
        // Update the drawing area
        m_drawingArea.PointerUpdated(pPointer);
    }
}

//
//
// Function:  OnWBPUserJoined
//
// Purpose:   Handler for WBP_EVENT_PERSON_JOINED
//
//
void WbMainWindow::OnWBPUserJoined(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserJoined");

    // Create a user object from the handle
    WbUser* pUser = WB_GetUser(hUser);
    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserJoined; can't create user object for 0x%08x", hUser));
    }
    else
    {
        // Make the necessary updates
        UserJoined(pUser);
    }

    // Update the title bar to reflect the number of users.  Do this here,
    // rather than in UserJoined because we go through this function for
    // remote users only, but through UserJoined for the local user too.

	UpdateWindowTitle();
}

//
//
// Function:    OnWBPUserLeftInd
//
// Purpose:     Handler for WBP_EVENT_PERSON_LEFT
//
//
void WbMainWindow::OnWBPUserLeftInd(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserLeft");

    // Create a user object from the handle
    WbUser* pUser = WB_GetUser(hUser);

    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserLeftInd; can't get user object for 0x%08x", hUser));
    }
    else
    {
        // Get the user's remote pointer
        DCWbGraphicPointer* pPointer = pUser->GetPointer();
        ASSERT(pPointer);

        // If the pointer is on the current page...
        if (pPointer->Page() == m_hCurrentPage)
        {
            // Update the drawing area
            m_drawingArea.PointerRemoved(pPointer);
        }
    }

    // Confirm the update.
    g_pwbCore->WBP_PersonLeftConfirm(hUser);

    //
    // Get this dude out of our list
    //
    if (pUser != NULL)
    {
        ASSERT(g_pUsers);

        POSITION position = g_pUsers->GetHeadPosition();

        WbUser * pRemovedUser;

        while (position)
        {
            POSITION savedPosition = position;
            pRemovedUser = (WbUser*)g_pUsers->GetNext(position);
            if (pRemovedUser == pUser)
            {
                g_pUsers->RemoveAt(savedPosition);
                position = NULL;
            }
        }

        delete pUser;
    }

    // Update the title bar to reflect the number of users
	UpdateWindowTitle();
}

//
//
// Function:    OnWBPUserUpdateInd
//
// Purpose:     Handler for WBP_EVENT_PERSON_UPDATE
//
//
void WbMainWindow::OnWBPUserUpdateInd(POM_OBJECT hUser, BOOL bReplace)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPUserUpdateInd");
    BOOL     bActiveOld, bActiveNew;
    WB_PAGE_HANDLE  hPointerPageOld, hPointerPageNew;
    POINT    pointOld, pointNew;
    WB_PAGE_HANDLE  hUserPageOld, hUserPageNew;
    BOOL     syncOld, syncNew;
    DCWbGraphicPointer * pPointer = NULL;

    // Get the user object associated with the handle, and the remote pointer
    WbUser* pUser = WB_GetUser(hUser);

    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnWBPUserUpdatedInd; can't get user object for 0x%08x", hUser));
    }
    else
    {
        pPointer = pUser->GetPointer();
        ASSERT(pPointer);

        //
        // Save the interesting bits of the user's state before the change.
        //
        bActiveOld     = pPointer->IsActive();
        hPointerPageOld = pPointer->Page();
        pPointer->GetPosition(&pointOld);
        hUserPageOld    = pUser->Page();
        syncOld        = pUser->IsSynced();
    }

    //
    // Confirm the change
    //
    if (bReplace)
    {
        g_pwbCore->WBP_PersonReplaceConfirm(hUser);
    }
    else
    {
        g_pwbCore->WBP_PersonUpdateConfirm(hUser);
    }

    if (pUser != NULL)
    {
        pUser->Refresh();

        //
        // We do nothing for the local user; since we made the updates locally,
        // we should have already accounted for them.
        //
        if (pUser == m_pLocalUser)
        {
            return;
        }

        //
        // Get the state after the change.
        //
        pPointer       = pUser->GetPointer();
        ASSERT(pPointer);

        bActiveNew     = pPointer->IsActive();
        hPointerPageNew = pPointer->Page();
        pPointer->GetPosition(&pointNew);
        hUserPageNew    = pUser->Page();
        syncNew        = pUser->IsSynced();


        // Check whether anything in the pointer has changed
        if (   (bActiveNew != bActiveOld)
            || (hPointerPageNew    != hPointerPageOld)
            || (!EqualPoint(pointNew, pointOld)))
        {
            // Check that at least one of the pages is the current page
            if (   (hPointerPageNew == m_hCurrentPage)
                || (hPointerPageOld == m_hCurrentPage))
            {
                m_drawingArea.PointerUpdated(pPointer);
            }
        }

        if (syncOld != syncNew)
        {
            // ensure the page button enable/disable state is correct
            UpdatePageButtons();
        }
    }
}

//
//
// Function:    OnWBPSyncPositionUpdated
//
// Purpose:     Handler for WBP_EVENT_SYNC_POSITION_UPDATED
//
//
void WbMainWindow::OnWBPSyncPositionUpdated(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPSyncPositionUpdated");

  //
  // Dont do anythig if we don't have a local user.
  //
  if (m_pLocalUser == NULL)
  {
      ERROR_OUT(("Got a WBP_EVENT_SYNC_POSITION_UPDATED event and pLocaUser is NULL "));
      return;
  }

    // If the local user is synced, change the current page/position
    if (m_pLocalUser->IsSynced())
    {
        GotoSyncPosition();
    }
}

//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbMainWindow::OnSize(UINT nType, int cx, int cy )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSize");


    // Only process this message if the window is not minimized
    if (nType != SIZE_MINIMIZED)
    {
        // Hide the statusbar to avoid drawing problems
	if (m_bStatusBarOn)
	{
            ::ShowWindow(m_hwndSB, SW_HIDE);
        }
	
        // Resize the subpanes of the window
        ResizePanes();

        // Show it again
        if (m_bStatusBarOn)
        {
            ::ShowWindow(m_hwndSB, SW_SHOW);
        }
    }

    // The user's view has changed
    PositionUpdated();

    // If the status has changed, set the option
    if (m_uiWindowSize != nType)
    {
        m_uiWindowSize = nType;

        // Write the new option values to file
        OPT_SetBooleanOption(OPT_MAIN_MAXIMIZED,
                             (m_uiWindowSize == SIZE_MAXIMIZED));
        OPT_SetBooleanOption(OPT_MAIN_MINIMIZED,
                             (m_uiWindowSize == SIZE_MINIMIZED));
    }

    // If this is setting the window to a new normal size,
    // save the new position.
    if (nType == SIZE_RESTORED)
    {
        SaveWindowPosition();
    }
}

//
//
// Function:    SaveWindowPosition
//
// Purpose:     Save the current window position to the options file.
//
//
void WbMainWindow::SaveWindowPosition(void)
{
    RECT    rectWindow;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveWindowPosition");

    // Get the new window rectangle
    ::GetWindowRect(m_hwnd, &rectWindow);

    // Write the new option values to file
    OPT_SetWindowRectOption(OPT_MAIN_MAINWINDOWRECT, &rectWindow);
}

//
//
// Function:    OnMove
//
// Purpose:     The window has been moved.
//
//
void WbMainWindow::OnMove(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMove");

    // If we are not maximized
    if (!::IsZoomed(m_hwnd) && !::IsIconic(m_hwnd))
    {
        // Save the new position of the window
        SaveWindowPosition();
    }
}

//
//
// Function:    ResizePanes
//
// Purpose:     Resize the subpanes of the main window.
//
//
void WbMainWindow::ResizePanes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ResizePanes");

    //
    //
    // The client area is organized as follows:
    //
    //  -------------------------------------
    //  |   |                               |
    //  | T |                               |
    //  | o |   Drawing Area                |
    //  | o |                               |
    //  | l |                               |
    //  | s |                               |
    //  |---|                               |
    //  | W |                               |
    //  | i |                               |
    //  | d |                               |
    //  | t |                               |
    //  | h |                               |
    //  | s |                               |
    //  |-----------------------------------|
    //  | Attributes (colors)   | Pages     |
    //  |-----------------------------------|
    //  |       Status                      |
    //  -------------------------------------
    //
    //

    RECT clientRect;
    RECT rectStatusBar;
    RECT rectToolBar;
    RECT rectWG;
    RECT rectAG;
    RECT rectDraw;
    SIZE size;
    SIZE sizeAG;

    // Get the client rectangle
    ::GetClientRect(m_hwnd, &clientRect);
    rectStatusBar = clientRect;

    // Resize the help bar and progress meter
    if (m_bStatusBarOn)
    {
        rectStatusBar.top = rectStatusBar.bottom - STATUSBAR_HEIGHT;

        ::MoveWindow(m_hwndSB, rectStatusBar.left, rectStatusBar.top,
            rectStatusBar.right - rectStatusBar.left,
            rectStatusBar.bottom - rectStatusBar.top, TRUE);
    }
    else
    {
        // Status bar is off - set it's height to zero
        rectStatusBar.top = rectStatusBar.bottom;
    }

    // Resize the tool and width windows
    m_TB.GetNaturalSize(&size);
    rectToolBar.left  = 0;
    rectToolBar.right = rectToolBar.left + size.cx;
    rectToolBar.top =  0;
    rectToolBar.bottom = rectToolBar.top + size.cy;

    m_WG.GetNaturalSize(&size);
    rectWG.left = rectToolBar.left;
    rectWG.top = rectToolBar.bottom;
    rectWG.bottom = rectWG.top + size.cy;

    if (!m_bToolBarOn)
    {
        // Toolbar is either off or floating - set its width to zero
        rectToolBar.right = rectToolBar.left;
    }
    rectWG.right = rectToolBar.right;

    // Position attribute group
    m_AG.GetNaturalSize(&sizeAG);

    ::MoveWindow(m_AG.m_hwnd, rectToolBar.left, rectStatusBar.top - sizeAG.cy,
        clientRect.right - rectToolBar.left, sizeAG.cy, TRUE);

    // finish fiddling with tools and widths bars
    if (m_bToolBarOn)
    {
        //
        // We make the toolbar, which includes the width bar, extend all
        // down the left side.
        //
        rectToolBar.bottom = rectStatusBar.top - sizeAG.cy;
        rectWG.left += TOOLBAR_MARGINX;
        rectWG.right -= 2*TOOLBAR_MARGINX;

        ::MoveWindow(m_TB.m_hwnd, rectToolBar.left,
            rectToolBar.top, rectToolBar.right - rectToolBar.left,
            rectToolBar.bottom - rectToolBar.top, TRUE);

        ::MoveWindow(m_WG.m_hwnd, rectWG.left, rectWG.top,
            rectWG.right - rectWG.left, rectWG.bottom - rectWG.top, TRUE);

        ::BringWindowToTop(m_WG.m_hwnd);
    }

    // Resize the drawing pane
    rectDraw = clientRect;
    rectDraw.bottom = rectStatusBar.top - sizeAG.cy;
    rectDraw.left   = rectToolBar.right;
    ::MoveWindow(m_drawingArea.m_hwnd, rectDraw.left, rectDraw.top,
        rectDraw.right - rectDraw.left, rectDraw.bottom - rectDraw.top, TRUE);

    // Check to see if Width group is overlapping Attributes group. This can happen if
    // the menu bar has wrapped because the window isn't wide enough (bug 424)
    RECT crWidthWnd;
    RECT crAttrWnd;

    ::GetWindowRect(m_WG.m_hwnd, &crWidthWnd);
    ::GetWindowRect(m_AG.m_hwnd, &crAttrWnd);

    if (crAttrWnd.top < crWidthWnd.bottom)
    {
        // the menu bar has wrapped and our height placements are wrong. Adjust window
        // by difference and try again
        RECT crMainWnd;

        ::GetWindowRect(m_hwnd, &crMainWnd);
        crMainWnd.bottom += (crWidthWnd.bottom - crAttrWnd.top + ::GetSystemMetrics(SM_CYFIXEDFRAME));

        ::MoveWindow(m_hwnd, crMainWnd.left, crMainWnd.top,
            crMainWnd.right - crMainWnd.left, crMainWnd.bottom - crMainWnd.top,
            FALSE);

        // this is going to recurse but the adjustment will happen only once.....
    }
}


//
//
// Function:    WbMainWindow::OnGetMinMaxInfo
//
// Purpose:     Set the minimum and maximum tracking sizes of the window
//
//
void WbMainWindow::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    if (m_TB.m_hwnd == NULL)
        return; // not ready to do this yet

    SIZE    csFrame;
    SIZE    csSeparator;
    SIZE    csAG;
    SIZE    csToolBar;
    SIZE    csWidthBar;
    SIZE    csStatusBar;
    RECT    rectStatusBar;
    SIZE    csMaxSize;
    SIZE    csScrollBars;

    csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

    csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
    csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

    csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
    csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

    m_AG.GetNaturalSize(&csAG);

    m_TB.GetNaturalSize(&csToolBar);
    m_WG.GetNaturalSize(&csWidthBar);

    csStatusBar.cx = 0;
    if (m_bStatusBarOn)
    {
        csStatusBar.cy = STATUSBAR_HEIGHT;
    }
    else
    {
        csStatusBar.cy = 0;
    }

    // Set the minimum width and height of the window
    lpmmi->ptMinTrackSize.x =
      csFrame.cx + csAG.cx + csFrame.cx;

    lpmmi->ptMinTrackSize.y =
      csFrame.cy +
      GetSystemMetrics( SM_CYCAPTION ) +
      GetSystemMetrics( SM_CYMENU ) +
      csToolBar.cy +
      csWidthBar.cy +
      csSeparator.cy +
      csAG.cy +
      csSeparator.cy +
      csStatusBar.cy +
      csFrame.cy ;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csMaxSize.cx;
    lpmmi->ptMaxSize.y      = csMaxSize.cy;
    lpmmi->ptMaxTrackSize.x = csMaxSize.cx;
    lpmmi->ptMaxTrackSize.y = csMaxSize.cy;
}


//
//
// Function:    WbMainWindow::CreateContextMenus
//
// Purpose:     Create the pop-up context menus: used within the application
//              drawing area.
//
//
BOOL WbMainWindow::CreateContextMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CreateContextMenus");

    m_hContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(CONTEXTMENU));
    if (!m_hContextMenuBar)
    {
        ERROR_OUT(("Failed to create context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hContextMenu = ::GetSubMenu(m_hContextMenuBar, 0);

    m_hGrobjContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(GROBJMENU));
    if (!m_hGrobjContextMenuBar)
    {
        ERROR_OUT(("Failed to create grobj context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hGrobjContextMenu = ::GetSubMenu(m_hGrobjContextMenuBar, 0);

    // make parts of m_hGrobjContextMenu be owner draw
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_1, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_1, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_2, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_2, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_3, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_3, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_4, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_4, NULL);

    return TRUE;
}




//
//
// Function:    WbMainWindow::InitializeMenus
//
// Purpose:     Initialise the menus: set up owner-drawn menu items and
//              those read from options file.
//
//
void WbMainWindow::InitializeMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::InitializeMenus");

    // Make the width menu ownerdraw
    HMENU hMenu = GetMenuWithItem(::GetMenu(m_hwnd), IDM_WIDTH_1);
    if (hMenu != NULL)
    {
        // Change each entry to be ownerdraw (loop until failure)
        int iIndex;
        UINT uiId;
        int iCount = ::GetMenuItemCount(hMenu);

        for (iIndex = 0; iIndex < iCount; iIndex++)
        {
            uiId = ::GetMenuItemID(hMenu, iIndex);
            ::ModifyMenu(hMenu, iIndex,
                        MF_BYPOSITION
                      | MF_ENABLED
                      | MF_OWNERDRAW,
                      uiId,
                      NULL);
        }
    }
}




//
//
// Function:    WbMainWindow::OnMeasureItem
//
// Purpose:     Return the size of an item in the widths menu
//
//
void WbMainWindow::OnMeasureItem
(
    int                 nIDCtl,
    LPMEASUREITEMSTRUCT measureStruct
)
{
    // Check that this is for a color menu item
    if (    (measureStruct->itemID >= IDM_WIDTHS_START)
         && (measureStruct->itemID < IDM_WIDTHS_END))
    {
        measureStruct->itemWidth  = ::GetSystemMetrics(SM_CXMENUCHECK) +
            (2 * CHECKMARK_BORDER_X) + COLOR_MENU_WIDTH;
        measureStruct->itemHeight = ::GetSystemMetrics(SM_CYMENUCHECK) +
            (2 * CHECKMARK_BORDER_Y);
    }
}

//
//
// Function:    WbMainWindow::OnDrawItem
//
// Purpose:     Draw an item in the color menu
//
//
void WbMainWindow::OnDrawItem
(
    int     nIDCtl,
    LPDRAWITEMSTRUCT drawStruct
)
{
    COLORREF crMenuBackground;
    COLORREF crMenuText;
    HPEN     hOldPen;
    HBRUSH      hOldBrush;
    COLORREF crOldBkgnd;
    COLORREF crOldText;
    int         nOldBkMode;
    HBITMAP hbmp = NULL;
    BITMAP  bitmap;
    UINT    uiCheckWidth;
    UINT    uiCheckHeight;
    RECT    rect;
    RECT    rectCheck;
    RECT    rectLine;
    HDC     hMemDC;
    UINT    uiWidthIndex;
    UINT    uiWidth;
    HPEN    hPenMenu;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDrawItem");

    // Check that this is a width menu item
    if( (drawStruct->itemID < IDM_WIDTHS_START) ||
        (drawStruct->itemID >= IDM_WIDTHS_END) )
    {
        return;
    }

    // get menu item colors
    if( (drawStruct->itemState & ODS_SELECTED) ||
        ((drawStruct->itemState & (ODS_SELECTED |ODS_CHECKED)) ==
            (ODS_SELECTED |ODS_CHECKED))
        )
    {
        crMenuBackground = COLOR_HIGHLIGHT;
        crMenuText = COLOR_HIGHLIGHTTEXT;
    }
    else if( drawStruct->itemState & ODS_GRAYED)
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_GRAYTEXT;
    }
    else
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_MENUTEXT;
    }

    hPenMenu = ::CreatePen(PS_SOLID, 0, ::GetSysColor(crMenuBackground));
    if (!hPenMenu)
    {
        TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    rect = drawStruct->rcItem;

    // Fill the whole box with current menu background color
    hOldPen     = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush   = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuBackground));

    ::Rectangle(drawStruct->hDC, rect.left, rect.top, rect.right, rect.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    if( (hbmp = (HBITMAP)LoadImage( NULL, MAKEINTRESOURCE( OBM_CHECK ), IMAGE_BITMAP,
                0,0, 0 ))
        == NULL )
    {
        TRACE_MSG(("Failed to create check image"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    // Get the width and height of the bitmap (allowing some border)
    ::GetObject(hbmp, sizeof(BITMAP), &bitmap);
    uiCheckWidth  = bitmap.bmWidth  + (2 * CHECKMARK_BORDER_X);
    uiCheckHeight = bitmap.bmHeight;

    // Draw in a checkmark (if needed)
    if (drawStruct->itemState & ODS_CHECKED)
    {
        hMemDC = ::CreateCompatibleDC(drawStruct->hDC);
        if (!hMemDC)
        {
            ERROR_OUT(("Failed to create memDC"));
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
            goto bail_out;
        }

        crOldBkgnd = ::SetBkColor(drawStruct->hDC, GetSysColor( crMenuBackground ) );
        crOldText = ::SetTextColor(drawStruct->hDC, GetSysColor( crMenuText ) );
        nOldBkMode = ::SetBkMode(drawStruct->hDC, OPAQUE );

        HBITMAP hOld = SelectBitmap(hMemDC, hbmp);

        if (hOld != NULL)
        {
            rectCheck = rect;
            rectCheck.top += ((rectCheck.bottom - rectCheck.top)/2 - uiCheckHeight/2);
            rectCheck.right  = rectCheck.left + uiCheckWidth;
            rectCheck.bottom = rectCheck.top + uiCheckHeight;

            ::BitBlt(drawStruct->hDC, rectCheck.left,
                        rectCheck.top,
                        rectCheck.right - rectCheck.left,
                        rectCheck.bottom - rectCheck.top,
                        hMemDC,
                        0,
                        0,
                        SRCCOPY);

            SelectBitmap(hMemDC, hOld);
        }

        ::SetBkMode(drawStruct->hDC, nOldBkMode);
        ::SetTextColor(drawStruct->hDC, crOldText);
        ::SetBkColor(drawStruct->hDC, crOldBkgnd);

        ::DeleteDC(hMemDC);
    }

    DeleteBitmap(hbmp);

    // Allow room for the checkmark to the left of the color
    rect.left += uiCheckWidth;

    uiWidthIndex = drawStruct->itemID - IDM_WIDTHS_START;
    uiWidth = g_PenWidths[uiWidthIndex];

    // If pens are very wide they can be larger than the allowed rectangle.
    // So we reduce the clipping rectangle here. We save the DC so that we
    // can restore it - getting the clip region back.
    if (::SaveDC(drawStruct->hDC) == 0)
    {
        ERROR_OUT(("Failed to save DC"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    if (::IntersectClipRect(drawStruct->hDC, rect.left, rect.top,
        rect.right, rect.bottom) == ERROR)
    {
        ERROR_OUT(("Failed to set clip rect"));

        ::RestoreDC(drawStruct->hDC, -1);
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    hOldPen   = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuText));

    rectLine.left = rect.left;
    rectLine.top    = rect.top + ((rect.bottom - rect.top) / 2) - uiWidth/2;
    rectLine.right= rect.right - ((rect.right - rect.left) / 6);
    rectLine.bottom = rectLine.top + uiWidth + 2;

    ::Rectangle(drawStruct->hDC, rectLine.left, rectLine.top,
        rectLine.right, rectLine.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    ::RestoreDC(drawStruct->hDC, -1);

bail_out:
    if (hPenMenu != NULL)
    {
        ::DeletePen(hPenMenu);
    }
}



//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbMainWindow::OnSetFocus(void)
{
    // We pass the focus on to the main drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    UpdateStatus
//
// Purpose:     Set the text in the status bar
//
//
void WbMainWindow::UpdateStatus()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::UpdateStatus");

    //
    // Update the current and last page numbers
    //
    m_AG.SetCurrentPageNumber(g_pwbCore->WBP_PageNumberFromHandle(m_hCurrentPage));
    m_AG.SetLastPageNumber(g_pwbCore->WBP_ContentsCountPages());

    //
    // Update the user information with the page.
    //
    if (m_pLocalUser != NULL)
    {
        m_pLocalUser->SetPage(m_hCurrentPage);
    }
}



//
//
// Function:    SetMenuState
//
// Purpose:     Sets menu contents to their correct enabled/disabled state
//
//
void WbMainWindow::SetMenuStates(HMENU hInitMenu)
{
    BOOL  bLocked;
    BOOL  bPageOrderLocked;
    BOOL  bPresentationMode;
    UINT  uiEnable;
    UINT  uiCountPages;
    BOOL  bIdle;
    BOOL  bSelected;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetMenuStates");

    //
    // Check menu exists
    //
    if (hInitMenu == NULL)
    {
        WARNING_OUT(("Menu doesn't exist"));
        return;
    }

    HMENU hMainMenu = ::GetMenu(m_hwnd);

    // Get the window's main menu and check that the menu
    // now being popped up is one on the top-level. (We do not
    // seem to be able to associate the index number passed with
    // sub-menus easily.)
    if ((hInitMenu != m_hContextMenu) && (hInitMenu != m_hGrobjContextMenu))
    {
        BOOL bTopLevel = FALSE;

        int nCount = ::GetMenuItemCount(hMainMenu);

        for (int nNext = 0; nNext < nCount; nNext++)
        {
            HMENU hNextMenu = ::GetSubMenu(hMainMenu, nNext);
            if (hNextMenu != NULL)
            {
                if (hNextMenu == hInitMenu)
                {
                    bTopLevel = TRUE;
                    break;
                }
            }
        }

        // not a top level, so leave the function now
        if (!bTopLevel)
        {
            TRACE_DEBUG(("Not top-level menu"));
            return;
        }
    }

    // Get the lock and selection states:
    // If we are joining a call, we cannot assume that the contents
    // and user/client details have been created yet, so just set the
    // locked state to true.
    bIdle     = IsIdle();
    bSelected = m_drawingArea.GraphicSelected();
    TRACE_DEBUG(("m_uiState %d", m_uiState));
    if ((m_uiState == STARTING) || (m_uiState == JOINING))
    {
        TRACE_DEBUG(("Not initilalised yet"));
        bLocked           = TRUE;
        bPageOrderLocked  = TRUE;
        bPresentationMode = TRUE;
        uiCountPages      = 1;
    }
    else
    {
        //
        // Note that bLocked and bPageOrderLocked are always true when
        // we're not in idle state.
        //
        uiCountPages      = g_pwbCore->WBP_ContentsCountPages();
        bLocked           = (WB_Locked() || !bIdle);
        bPageOrderLocked  = (WB_Locked() || !bIdle);
        bPresentationMode = (((m_uiState == IN_CALL) &&
                              (WB_PresentationMode()))
                            || (!bIdle));
    }

    //
    // Functions which are disabled when contents is locked
    //
    uiEnable = MF_BYCOMMAND | (bLocked ? MF_GRAYED : MF_ENABLED);

    ::EnableMenuItem(hInitMenu, IDM_OPEN,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE_AS, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PRINT,   uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_AREA, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_WINDOW, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SELECTALL, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_SELECT,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PEN, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_HIGHLIGHT, uiEnable);

    // Don't allow editing in zoom mode
    if( m_drawingArea.Zoomed() )
        ::EnableMenuItem(hInitMenu, IDM_TEXT, MF_GRAYED);
    else
        ::EnableMenuItem(hInitMenu, IDM_TEXT, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_CLEAR_PAGE, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_ERASER, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_LINE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ZOOM, uiEnable);


    // So toolbar will follow menu (MFC-auto-update is broken for this)
    EnableToolbar( !bLocked );


    //
    // File/New is disabled if page order is locked, or not in a call,
    // or a new is already in progress.
    //
    ::EnableMenuItem(hInitMenu, IDM_NEW, MF_BYCOMMAND |
      (bPageOrderLocked ? MF_GRAYED : MF_ENABLED));

    //
    // Paste enabled only if not locked, and there's something in the
    // clipboard
    //
    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if (   (CLP_AcceptableClipboardFormat() == NULL)
        || (bLocked))
    {
        // No acceptable format available, or the contents
        // are locked by another user - gray the Paste command.
        uiEnable = MF_BYCOMMAND | MF_GRAYED;
    }
    ::EnableMenuItem(hInitMenu, IDM_PASTE, uiEnable);

    //
    // Functions which require a graphic to be selected
    //
    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if( !m_drawingArea.TextEditActive() )
    {
        if (!bSelected || bLocked)
        {
            // No acceptable format available - gray the menu item
            uiEnable = MF_BYCOMMAND | MF_GRAYED;
        }
    }

    ::EnableMenuItem(hInitMenu, IDM_CUT, uiEnable);

    // don't do textedit delete for now
    if( m_drawingArea.TextEditActive() )
        ::EnableMenuItem(hInitMenu, IDM_DELETE, MF_BYCOMMAND | MF_GRAYED);
    else
        ::EnableMenuItem(hInitMenu, IDM_DELETE, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_BRING_TO_TOP, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SEND_TO_BACK, uiEnable);

    //
    // Can copy even if contents are locked
    //
    //COMMENT BY RAND - To fix 556 I changed !bIdle to bIdle like the current
    //                    16bit code does.
    ::EnableMenuItem(hInitMenu, IDM_COPY, MF_BYCOMMAND |
      (m_drawingArea.TextEditActive()||(bSelected && bIdle)
        ? MF_ENABLED : MF_GRAYED));    //CHANGED BY RAND for 556

    //
    // Object to undelete?
    //
    ::EnableMenuItem(hInitMenu, IDM_UNDELETE, MF_BYCOMMAND |
      ((m_LastDeletedGraphic.GotTrash() &&
        (m_LastDeletedGraphic.Page() == m_hCurrentPage) &&
        (!bLocked)) ? MF_ENABLED : MF_GRAYED));

    //
    // Page functions depend on number of pages
    //
    ::EnableMenuItem(hInitMenu, IDM_DELETE_PAGE, MF_BYCOMMAND |
      ((bPageOrderLocked ||
       (uiCountPages == 1)||
       (!m_bUnlockStateSettled))
        ? MF_GRAYED : MF_ENABLED));

    uiEnable = MF_BYCOMMAND | MF_ENABLED;
    if ((bPageOrderLocked) ||
       (uiCountPages == WB_MAX_PAGES)||
       (!m_bUnlockStateSettled))
    {
        uiEnable = MF_BYCOMMAND | MF_GRAYED;
    }
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_BEFORE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_AFTER, uiEnable);

    //
    // Can't bring up page sorter if locked
    //
    ::EnableMenuItem(hInitMenu, IDM_PAGE_SORTER, MF_BYCOMMAND |
      (bPresentationMode ? MF_GRAYED : MF_ENABLED));

    // Enable page controls
    m_AG.EnablePageCtrls(!bPresentationMode);

    //
    // Lock enabled only if not already locked
    //
    ::EnableMenuItem(hInitMenu, IDM_LOCK, MF_BYCOMMAND |
      (bPageOrderLocked ? MF_GRAYED : MF_ENABLED));

    //
    // Enable sync if not in "presentation" mode
    //
    ::EnableMenuItem(hInitMenu, IDM_SYNC, MF_BYCOMMAND |
      (((!bPresentationMode) && bIdle) ? MF_ENABLED : MF_GRAYED));

    //
    // Gray font/color/widths if inappropriate for current tool.
    //
    ::EnableMenuItem(hInitMenu, IDM_FONT, MF_BYCOMMAND |
        (!bLocked && m_pCurrentTool->HasFont() ? MF_ENABLED : MF_GRAYED));

    ::EnableMenuItem(hInitMenu, IDM_EDITCOLOR, MF_BYCOMMAND |
        (!bLocked && m_pCurrentTool->HasColor() ? MF_ENABLED : MF_GRAYED));


    // enable width menu (bug 433)
    HMENU hOptionsMenu = ::GetSubMenu(hMainMenu, MENUPOS_OPTIONS);
    uiEnable = (!bLocked && m_pCurrentTool->HasWidth())?MF_ENABLED:MF_GRAYED;

    if (hOptionsMenu == hInitMenu )
        ::EnableMenuItem(hOptionsMenu, OPTIONSPOS_WIDTH, MF_BYPOSITION | uiEnable );

    UINT i;
    UINT uIdmCurWidth = 0;
    if( uiEnable == MF_ENABLED )
        uIdmCurWidth = m_pCurrentTool->GetWidthIndex() + IDM_WIDTH_1;

    // set width state(bug 426)
    for( i=IDM_WIDTH_1; i<=IDM_WIDTH_4; i++ )
    {
        ::EnableMenuItem(hInitMenu,  i, uiEnable );

        if( uiEnable == MF_ENABLED )
        {
            if( uIdmCurWidth == i )
                ::CheckMenuItem(hInitMenu, i, MF_CHECKED );
            else
                ::CheckMenuItem(hInitMenu, i, MF_UNCHECKED );
        }
    }
}


//
//
// Function:    OnInitMenuPopup
//
// Purpose:     Process a WM_INITMENUPOPUP event
//
//
void WbMainWindow::OnInitMenuPopup
(
    HMENU   hMenu,
    UINT    uiIndex,
    BOOL    bSystemMenu
)
{

    // 1/2 of fix for strange MFC4.2 build bug that clogs up DCL's message pipe.
    // The other 1/2 and a better comment are in LoadFile().
    if( m_bIsWin95 )
    {
        if( GetSubState() == SUBSTATE_LOADING )
        {
            ::SetFocus(m_drawingArea.m_hwnd);
            return;
        }
   }


    // Ignore the event if it relates to the system menu
    if (!bSystemMenu)
    {
        if (hMenu)
        {
            SetMenuStates(hMenu);
            m_hInitMenu = hMenu;
        }
        else
        {
            m_hInitMenu = NULL;
        }

        // Save the last menu we handled, so that we can alter its state
        // if necessary whilst it is still visible
    }
}


//
//
// Function : OnMenuSelect
//
// Purpose  : Update the text in the help bar
//
//
void WbMainWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
    UINT   firstMenuId;
    UINT   statusId;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMenuSelect");

    //
    // Work out the help ID for the menu item.  We have to store this now
    // because when the user presses F1 from a menu item, we can't tell
    // which item it was.
    //
    if (uiFlags == (UINT)-1)
    {
        //
        // The menu has been dismissed
        //
        m_hInitMenu = NULL;
        statusId   = IDS_DEFAULT;

        if( hSysMenu == 0 )
            {
            // Menu was dismissed, check cursor loc.
            DCWbGraphic *pGraphic;

            POINT surfacePos;
            ::GetCursorPos( &surfacePos );
            ::ScreenToClient(m_drawingArea.m_hwnd, &surfacePos);
            m_drawingArea.ClientToSurface(&surfacePos );

            if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) == NULL )
                {
                // we clicked dead air, don't lose current selection (bug 426)
                m_drawingArea.SetLClickIgnore( TRUE );
                }
            else
                delete pGraphic; // plug leak
            }
    }
    else if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
    {
        //
        // System menu selected
        //
        statusId   = IDS_MENU_SYSTEM;
    }
    else if (uiFlags & MF_POPUP)
    {
        // get popup menu handle and first item (bug NM4db:463)
        HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
        firstMenuId = ::GetMenuItemID( hPopup, 0 );

        // figure out which popup it is so we can display the right help text
        switch (firstMenuId)
        {
            case IDM_NEW:
                statusId   = IDS_MENU_FILE;
                break;

            case IDM_DELETE:
                statusId   = IDS_MENU_EDIT;
                break;

            case IDM_TOOL_BAR_TOGGLE:
                statusId   = IDS_MENU_VIEW;
                break;

            case IDM_EDITCOLOR:
                // The first item in the options menu is the color popup
                // menu - popup menus have Id -1
                statusId   = IDS_MENU_OPTIONS;
                break;

            case IDM_TOOLS_START:
                statusId   = IDS_MENU_TOOLS;
                break;

            case IDM_HELP:
                statusId = IDS_MENU_HELP;
                break;

            case IDM_WIDTH_1: // (added for bug NM4db:463)
                statusId   = IDS_MENU_WIDTH;
                break;

            default:
                statusId   = IDS_DEFAULT;
                break;
        }
    }
    else
    {
        //
        // A normal menu item has been selected
        //
        statusId   = uiItemID;
    }

    // Set the new help text
    TCHAR   szStatus[256];

    if (::LoadString(g_hInstance, statusId, szStatus, 256))
    {
        ::SetWindowText(m_hwndSB, szStatus);
    }
}


//
//
// Function:    OnParentNotfiy
//
// Purpose:     Process a message coming from a child window
//
//
void WbMainWindow::OnParentNotify(UINT uiMessage)
{
    switch (uiMessage)
    {
        // Scroll message from the drawing area. These are sent when the user
        // scrolls the area using the scroll bars. We queue an update of the
        // current sync position.
        case WM_HSCROLL:
        case WM_VSCROLL:
            // The user's view has changed
            PositionUpdated();
            break;
    }
}


//
//
// Function:    QuerySaveRequired
//
// Purpose:     Check whether the drawing pane contents are to be saved
//              before a destructive function is performed.
//
//
int WbMainWindow::QuerySaveRequired(BOOL bCancelBtn)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::QuerySaveRequired");

    // Default the response to "no save required"
    int  iResult = IDNO;

    //
    // If we are already displaying a "Save As" dialog, dismiss it.
    //
    if (m_hwndQuerySaveDlg != NULL)
    {
        ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
            MAKELONG(IDCANCEL, BN_CLICKED), 0);
        ASSERT(m_hwndQuerySaveDlg == NULL);
    }

    // If any of the pages has changed - ask the user if they want to
    // save the contents of the Whiteboard.
    if (g_pwbCore->WBP_ContentsChanged())
    {
        ::SetForegroundWindow(m_hwnd); //bring us to the top first

        // SetForegroundWindow() does not work properly in Memphis when its called during a
        // SendMessage handler, specifically, when conf calls me to shutdown. The window activation
        // state is messed up or something and my window does not pop to the top. So I have to
        // force my window to the top using SetWindowPos. But even after that the titlebar is not
        // highlighted properly. I tried combinations of SetActiveWindow, SetFocus, etc but to no
        // avail. But, at least the dialog is visible so you can clear it thus fixing the
        // bug (NM4db:2103). SetForegroundWindow() works ok for Win95 and NT here without
        // having to use SetWindowPos (it doesn't hurt anyting to do it anyway so I didn't
        // do a platform check).
        ::SetWindowPos(m_hwnd, HWND_TOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );       // force to top
        ::SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );  // let go of topmost

        //
        // Display a dialog box with the relevant question
        //      LOWORD of user data is "cancel command is allowed"
        //      HIWORD of user data is "disable cancel button"
        //
        iResult = (int)DialogBoxParam(g_hInstance,
            bCancelBtn ? MAKEINTRESOURCE(QUERYSAVEDIALOGCANCEL)
                       : MAKEINTRESOURCE(QUERYSAVEDIALOG),
            m_hwnd,
            QuerySaveDlgProc,
            MAKELONG(bCancelBtn, FALSE));
    }

    return iResult;
}



//
// QuerySaveDlgProc()
// Handler for query save dialogs.  We save some flags in GWL_USER
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            //
            // Save away our HWND so this dialog can be cancelled if necessary
            //
            g_pMain->m_hwndQuerySaveDlg = hwnd;

            // Remember the flags we passed
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            // Should the cancel button be disabled?
            if (HIWORD(lParam))
                ::EnableWindow(::GetDlgItem(hwnd, IDCANCEL), FALSE);

            // Bring us to the front
            ::SetForegroundWindow(hwnd);

            fHandled = TRUE;
            break;

        case WM_CLOSE:
            // Even if the cancel button is disabled, kill the dialog
            ::PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDCANCEL:
                    //
                    // If a dialog doesn't have a cancel button or it's
                    // disabled and the user pressed the close btn, we can
                    // get here.
                    //
                    if (!LOWORD(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))
                        wParam = MAKELONG(IDNO, HIWORD(wParam));
                    // FALL THRU

                case IDYES:
                case IDNO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        g_pMain->m_hwndQuerySaveDlg = NULL;

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                        break;
                    }
                    break;
            }
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
//
// Function:    OnNew
//
// Purpose:     Clear the workspace and associated filenames
//
//
void WbMainWindow::OnNew(void)
{
    int iDoNew;

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return;


    // check state before proceeding - if we're already doing a new, then abort
    if (   (m_uiState != IN_CALL)
        || (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto OnNewCleanup;
    }
    // if we're currently loading, then cancel the load and proceed (don't
    // prompt to save).
    else if (m_uiSubState == SUBSTATE_LOADING)
    {
        // cancel load, not releasing the page order lock, because
        // we need it immediately afterwards
        CancelLoad(FALSE);
        iDoNew = IDNO;
    }
    // otherwise prompt to save if necessary
    else
    {
        // Get confirmation for the new
        iDoNew = QuerySaveRequired(TRUE);
    }

    if (iDoNew == IDYES)
    {
        // Save the changes
        iDoNew = OnSave(FALSE);
    }

  // If the user did not cancel the operation, clear the drawing area
  if (iDoNew != IDCANCEL)
  {
      // Go to the first page, as this won't be deleted - stops flashing
      // with locking contents for each page delete
      OnFirstPage();
      GotoPosition(0, 0);

      // lock the drawing area
      LockDrawingArea();

      // Save the current lock status
      SaveLock();

      // Get the Page Order Lock (with an invisible dialog)
      BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
      if (!bGotLock)
      {
        RestoreLock();
      }
      else
      {
            UINT    uiReturn;

            // Remove all the pages
            uiReturn = g_pwbCore->WBP_ContentsDelete();
            if (uiReturn != 0)
            {
                DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
                return;
            }

        // if there is only one page, the new is implemented just as a page-
        // clear, so we don't need to go into NEW_IN_PROGRESS substate.
        if (g_pwbCore->WBP_ContentsCountPages() > 1)
        {
          // set substate to show we're doing a new
          SetSubstate(SUBSTATE_NEW_IN_PROGRESS);
        }
        else
        {
          // Restore the lock status
          RestoreLock();
        }

        // Clear the associated file name
        ZeroMemory(m_strFileName, sizeof(m_strFileName));

        // Update the window title with no file name
		UpdateWindowTitle();
      }
  }

OnNewCleanup:

  // unlock the drawing area if the new is not asynchronous
  if (   (m_uiSubState != SUBSTATE_NEW_IN_PROGRESS)
      && (!WB_ContentsLocked()))
  {
    UnlockDrawingArea();
  }

  return;
}

//
//
// Function:    OnNextPage
//
// Purpose:     Move to the next worksheet in the pages list
//
//
void WbMainWindow::OnNextPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the next page
        GotoPage(PG_GetNextPage(m_hCurrentPage));
    }
}

//
//
// Function:    OnPrevPage
//
// Purpose:     Move to the previous worksheet in the pages list
//
//
void WbMainWindow::OnPrevPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the previous page
        GotoPage(PG_GetPreviousPage(m_hCurrentPage));
    }
}

//
//
// Function:    OnFirstPage
//
// Purpose:     Move to the first worksheet in the pages list
//
//
void WbMainWindow::OnFirstPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the first page
        WB_PAGE_HANDLE   hPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_FIRST, &hPage);
        GotoPage(hPage);
    }
}

//
//
// Function:    OnLastPage
//
// Purpose:     Move to the last worksheet in the pages list
//
//
void WbMainWindow::OnLastPage(void)
{
    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Go to the last page
        WB_PAGE_HANDLE hPage;

        g_pwbCore->WBP_PageHandle(WB_PAGE_HANDLE_NULL, PAGE_LAST, &hPage);
        GotoPage(hPage);
    }
}

//
//
// Function:    OnGotoPage
//
// Purpose:     Move to the specified page (if it exists)
//
//
void WbMainWindow::OnGotoPage(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoPage");

    // ignore this command if in presentation mode
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        // Get the requested page number from the pages group
        UINT uiPageNumber = m_AG.GetCurrentPageNumber();

        // Goto the page
        GotoPageNumber(uiPageNumber);
    }
}

//
//
// Function:    GotoPage
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GotoPage(WB_PAGE_HANDLE hPageNew)
{
    BOOL inEditField;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPage");

    inEditField = m_AG.IsChildEditField(::GetFocus());

    // If we are changing page
    if (hPageNew != m_hCurrentPage)
    {
        m_drawingArea.CancelDrawingMode();

        // Attach the new page to the drawing area
        m_hCurrentPage = hPageNew;
        m_drawingArea.Attach(m_hCurrentPage);

        // Update the local user information with the new page
        if (m_pLocalUser != NULL)
            m_pLocalUser->SetPage(m_hCurrentPage);

        // Show that we need to update the sync position
        m_bSyncUpdateNeeded = TRUE;

	    PAGE_POSITION *mapob = NULL;
		POSITION position = m_pageToPosition.GetHeadPosition();
		BOOL bFound = FALSE;
		while (position && !bFound)
		{
			mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
			if ( mapob && mapob->hPage == hPageNew)
			{
				bFound = TRUE;
			}
		}

        if (!bFound)
        {
            // page not in map, so go to the top-left
            //CHANGED BY RAND - to fix memory leak
            GotoPosition( 0, 0);
        }
        else
      	{
      		if(mapob)
		{
			GotoPosition(mapob->position.x, mapob->position.y);
		}
      	}
    }

    // Update the status display
    UpdateStatus();

    // set the focus back to the drawing area
    if (!inEditField)
    {
        ::SetFocus(m_drawingArea.m_hwnd);
    }
}

//
//
// Function:    GotoPageNumber
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GotoPageNumber(UINT uiPageNumber)
{
    GotoPage(PG_GetPageNumber(uiPageNumber));
}


//
//
// Function:    GotoPosition
//
// Purpose:     Move to the specified position within the page
//
//
void WbMainWindow::GotoPosition(int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPosition");

    // Move the drawing area to the new position
    m_drawingArea.GotoPosition(x, y);

    // The user's view has changed
    PositionUpdated();
}

//
//
// Function:    GotoSyncPosition
//
// Purpose:     Move to the the current sync position
//
//
void WbMainWindow::GotoSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoSyncPosition");

    //
    // Get the local user to determine the new position.
    //
    if (!m_pLocalUser)
    {
        ERROR_OUT(("Skipping GotoSyncPosition; no local user object"));
        return;
    }

    m_pLocalUser->GetSyncPosition();

    //
    // If the page is different to where we are currently, get the number
    // of the page and select the current page
    //
    if (m_pLocalUser->Page() != m_hCurrentPage)
    {
        GotoPageNumber(g_pwbCore->WBP_PageNumberFromHandle(m_pLocalUser->Page()));
    }

    // Get the requested position from the user
    RECT rectVisibleUser;
    m_pLocalUser->GetVisibleRect(&rectVisibleUser);

    // Scroll to the required position
    GotoPosition(rectVisibleUser.left, rectVisibleUser.top);

    // Make sure we are zoomed / not zoomed as appropriate
    if ((m_pLocalUser->GetZoom()) != m_drawingArea.Zoomed())
    {
        OnZoom();
    }

    //
    // Reset the sync position update flag that will have been turned on by
    // the calls above.  We do not want to change the current sync position
    // when we are merely changing our position to match that set by
    // another user in the call.
    //
    m_bSyncUpdateNeeded = FALSE;

    // Inform the other users that we have changed position
    m_pLocalUser->Update();
}

//
//
// Function:    OnGotoUserPosition
//
// Purpose:     Move to the the current position of the specified user
//
//
void WbMainWindow::OnGotoUserPosition(LPARAM lParam)
{
    UINT            uiPageNumber = 1;
    WB_PAGE_HANDLE  hPage;
    WbUser  *     pUser;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoUserPosition");

    //
    // If the drawing area is busy, ignore this command.  This is unlikely
    // since this command is generated by selecting a menu entry on a user
    // icon.  The user should not therefore be drawing on the page by the
    // time we get the message.
    //
    if (m_drawingArea.IsBusy())
    {
        TRACE_DEBUG(("drawing area is busy just now.."));
        return;
    }

    //
    // Get a user object (throws an exception if the handle specified is no
    // longer valid).
    //
    pUser = WB_GetUser((POM_OBJECT) lParam);
    if (!pUser)
    {
        WARNING_OUT(("Can't handle OnGotoUserPosition; can't get user object for 0x%08x", lParam));
        return;
    }

    //
    // Get the requested page from the user.
    //
    hPage = pUser->Page();

    //
    // Quit if the requested page is not valid locally.
    //
    if (hPage == WB_PAGE_HANDLE_NULL)
    {
        TRACE_DEBUG(("Page is not valid locally"));
        return;
    }

    //
    // Don't go to user's position if it's on another page and we're in
    // presentation mode (this shouldn't normally happen, since we should
    // all be on the same page, but there is a window at the start-up of
    // presentation mode.
    //
    if ( (hPage == m_hCurrentPage) ||
         (!WB_PresentationMode()) )
    {
        //
        // If the page is different to where we are currently, get the
        // number of the page and select the current page.
        //
        if (hPage != m_hCurrentPage)
        {
            uiPageNumber = g_pwbCore->WBP_PageNumberFromHandle(hPage);
            GotoPageNumber(uiPageNumber);
        }

        //
        // Get the requested position from the user and scroll to it.
        //
        RECT rectVisibleUser;
        pUser->GetVisibleRect(&rectVisibleUser);
        GotoPosition(rectVisibleUser.left, rectVisibleUser.top);

        //
        // Zoom/unzoom if the sync zoom state is different to our current
        // zoom state.
        //
        if ( (m_pLocalUser->GetZoom()) != (m_drawingArea.Zoomed()) )
        {
            TRACE_DEBUG(("Change zoom state"));
            OnZoom();
        }
    }
}

//
//
// Function:    OnGotoUserPointer
//
// Purpose:     Move to the pointer position of the specified user
//
//
void WbMainWindow::OnGotoUserPointer(LPARAM lParam)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoUserPointer");

    // If the drawing area is busy, ignore this command.
    // This is unlikely since this command is generated by selecting
    // a menu entry on a user icon. The user should not therefore be
    // drawing on the page by the time we get the message.
    if (!m_drawingArea.IsBusy())
    {
        // Get a user object (throws an exception if the
        // handle specified is no longer valid).
        WbUser* pUser = WB_GetUser((POM_OBJECT) lParam);

        if (!pUser)
        {
            WARNING_OUT(("Can't handle OnGotoUserPointer; can't get user object for 0x%08x", lParam));
            return;
        }

        DCWbGraphicPointer* pPointer = pUser->GetPointer();
        ASSERT(pPointer != NULL);

        // Continue only if the user is using the pointer
        if (pPointer->IsActive())
        {
            // Get the requested page from the user
            WB_PAGE_HANDLE hPage = pPointer->Page();

            // Check that the requested page is valid locally
            if (hPage != WB_PAGE_HANDLE_NULL)
            {
                // If the pointer is on a different page, change to the
                // correct page.
                if (hPage != m_hCurrentPage)
                {
                    GotoPageNumber(g_pwbCore->WBP_PageNumberFromHandle(hPage));
                }

                // Move within the page if the pointer is not wholly visible
                // in the drawing area window.
                RECT rectPointer;
                RECT rcVis;
                RECT rcT;

                pPointer->GetBoundsRect(&rectPointer);
                m_drawingArea.GetVisibleRect(&rcVis);

                ::IntersectRect(&rcT, &rcVis, &rectPointer);
                if (!::EqualRect(&rcT, &rectPointer))
                {
                    // Adjust the position so that the pointer is shown
                    // in the centre of the window.
                    POINT   position;
                    SIZE    size;

                    position.x = rectPointer.left;
                    position.y = rectPointer.top;

                    size.cx = (rcVis.right - rcVis.left) - (rectPointer.right - rectPointer.left);
                    size.cy = (rcVis.bottom - rcVis.top) - (rectPointer.bottom - rectPointer.top);

                    position.x += -size.cx / 2;
                    position.y += -size.cy / 2;

                    // Scroll to the required position
                    GotoPosition(position.x, position.y);
                }
            }
        }
    }
}


//
//
// Function:    LoadFile
//
// Purpose:     Load a metafile into the application. Errors are reported
//              to the caller by the return code.
//
//
void WbMainWindow::LoadFile
(
    LPCSTR szLoadFileName
)
{
    UINT    uRes;

    // Check we're in idle state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto UserPointerCleanup;
    }

    if (*szLoadFileName)
    {
        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

       // Save the current lock
       SaveLock();

       // Get the Page Order Lock (with an invisible dialog)
       BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

       if (!bGotLock)
       {
           RestoreLock();
           goto UserPointerCleanup;
       }

       // Load the file
       uRes = g_pwbCore->WBP_ContentsLoad(szLoadFileName);
       if (uRes != 0)
       {
           DefaultExceptionHandler(WBFE_RC_WB, uRes);
           return;
       }

        // Set the window title to the new file name
        lstrcpy(m_strFileName, szLoadFileName);

        // Update the window title with the new file name
		UpdateWindowTitle();

        // Set the state to say that we are loading a file
        SetSubstate(SUBSTATE_LOADING);
    }

UserPointerCleanup:

    // Restore the cursor
    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
}




//
//
// Function:    OnDropFiles
//
// Purpose:     Files have been dropped onto the Whiteboard window
//
//
void WbMainWindow::OnDropFiles(HDROP hDropInfo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDropFiles");

    UINT  uiFilesDropped = 0;
    UINT  eachfile;

    // Get the total number of files dropped
    uiFilesDropped = ::DragQueryFile(hDropInfo, (UINT) -1, NULL, (UINT) 0);

    // release mouse capture in case we report any errors (message boxes
    // won't repsond to mouse clicks if we don't)
    ReleaseCapture();

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        goto bail_out;

    // Don't prompt to save file if we're already loading
    int iOnSave;
    if( m_uiSubState != SUBSTATE_LOADING )
        {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        }
    else
        {
        goto bail_out;
        }

    if( iOnSave == IDYES )
        {
        // User wants to save the drawing area contents
        int iResult = OnSave(TRUE);

        if( iResult == IDOK )
            {
            // Update the window title with the new file name
			UpdateWindowTitle();
            }
        else
            {
            // cancelled out of save, so cancel the open operation
            goto bail_out;
            }
        }

    // see if user canceled the whole drop
    if( iOnSave == IDCANCEL )
        goto bail_out;

    for (eachfile = 0; eachfile < uiFilesDropped; eachfile++)
    {
        // Retrieve each file name
        char  szDropFileName[256];

        ::DragQueryFile(hDropInfo, eachfile,
            szDropFileName, 256);

        TRACE_MSG(("Loading file: %s", szDropFileName));

        // Load the file
        // If this is a valid whiteboard file, the action is simply to load it
        if (g_pwbCore->WBP_ValidateFile(szDropFileName, NULL) == 0)
        {
            LoadFile(szDropFileName);
        }
        else
        {
            ::Message(NULL, IDS_MSG_CAPTION,IDS_MSG_BAD_FILE_FORMAT);
        }
    }

bail_out:
    ::DragFinish(hDropInfo);
}



//
//
// Function:    OnOpen
//
// Purpose:     Load a metafile into the application.
//
//
void WbMainWindow::OnOpen(void)
{
    int iOnSave;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnOpen");

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return;

    // Check we're in idle state
    if ( (m_uiState != IN_CALL) || (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
      }

    // Don't prompt to save file if we're already loading
    if (m_uiSubState != SUBSTATE_LOADING)
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
    }
    else
    {
        iOnSave = IDNO;
    }

    if (iOnSave == IDYES)
    {
        // User wants to save the drawing area contents
        int iResult = OnSave(TRUE);

        if (iResult == IDOK)
        {
		    UpdateWindowTitle();
        }
        else
        {
            // cancelled out of Save As, so cancel the open operation
            iOnSave = IDCANCEL;
        }
    }

    // Only continue if the user has not cancelled the operation
    if (iOnSave != IDCANCEL)
    {
        OPENFILENAME    ofn;
        TCHAR           szFileName[_MAX_PATH];
        TCHAR           szFileTitle[64];
        TCHAR           strLoadFilter[2*_MAX_PATH];
        TCHAR           strDefaultExt[_MAX_PATH];
        TCHAR           strDefaultPath[2*_MAX_PATH];
        TCHAR *         pStr;
  	    UINT            strSize = 0;
      	UINT            totalSize;

        // Build the filter for loadable files
        pStr = strLoadFilter;
        totalSize = 2*_MAX_PATH;

        // These must be NULL separated, with a double NULL at the end
        strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
        pStr += strSize;
        ASSERT(totalSize > strSize);
        totalSize -= strSize;

        *pStr = 0;

        //
        // Setup the OPENFILENAME struct
        //
        ZeroMemory(&ofn, sizeof(ofn));
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = m_hwnd;

        // No file name supplied to begin with
        szFileName[0] = 0;
        ofn.lpstrFile = szFileName;
        ofn.nMaxFile = _MAX_PATH;

        // Default Extension:  .WHT
        ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
        ofn.lpstrDefExt = strDefaultExt;

        // Default file title is empty
        szFileTitle[0] = 0;
        ofn.lpstrFileTitle = szFileTitle;
        ofn.nMaxFileTitle = 64;

        // Open flags
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;
        ofn.hInstance = g_hInstance;

        // Filter
        ofn.lpstrFilter = strLoadFilter;

        // Default path
        if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
            ofn.lpstrInitialDir = strDefaultPath;

        // Get user input, continue only if the user selects the OK button
        if (::GetOpenFileName(&ofn))
        {
            // Change the cursor to "wait"
            ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            // if we're currently loading a file, cancel it, not releasing
            // the page order lock, because we need it immediately afterwards
            if (m_uiSubState == SUBSTATE_LOADING)
            {
                CancelLoad(FALSE);
            }

            // Load the file
            LoadFile(ofn.lpstrFile);
        }
    }
}




//
//
// Function:    GetFileName
//
// Purpose:     Get a file name for saving the contents
//
//
int WbMainWindow::GetFileName(void)
{
    OPENFILENAME    ofn;
    int             iResult;
    TCHAR           szFileTitle[64];
    TCHAR           strSaveFilter[2*_MAX_PATH];
    TCHAR           strDefaultExt[_MAX_PATH];
    TCHAR           strDefaultPath[2 * _MAX_PATH];
    TCHAR           szFileName[2*_MAX_PATH];
    TCHAR *         pStr;
    UINT            strSize = 0;
    UINT            totalSize;

    //
    // If we are already displaying a "Save As" dialog, dismiss it and create
    // a new one.  This can happen if Win95 shuts down whilst WB is
    // displaying the "Save As" dialog and the use selects "Yes" when asked
    // whether they want to save the contents - a second "Save As dialog
    // appears on top of the first.
    //
    if (m_bInSaveDialog)
    {
        CancelSaveDialog();
    }

    // Build the filter for save files
    pStr = strSaveFilter;
    totalSize = 2*_MAX_PATH;

    // These must be NULL separated, with a double NULL at the end
    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    *pStr = 0;

    //
    // Setup the OPENFILENAME struct
    //
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hwnd;

    lstrcpy(szFileName, m_strFileName);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = _MAX_PATH;

    // Build the default extension string
    ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
    ofn.lpstrDefExt = strDefaultExt;

    szFileTitle[0] = 0;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 64;

    // Save flags
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN |
        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.hInstance = g_hInstance;

    // Filter
    ofn.lpstrFilter = strSaveFilter;

    // Default path
    if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
        ofn.lpstrInitialDir = strDefaultPath;

    m_bInSaveDialog = TRUE;

    if (::GetSaveFileName(&ofn))
    {
        // The user selected OK
        iResult = IDOK;
        lstrcpy(m_strFileName, szFileName);
    }
    else
    {
        iResult = IDCANCEL;
    }

    m_bInSaveDialog = FALSE;

    return iResult;
}

//
//
// Function:    OnSave
//
// Purpose:     Save the contents of the Whiteboard using the current file
//              name (or prompting for a new name if there is no current).
//
//
int WbMainWindow::OnSave(BOOL bPrompt)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSave");

    int iResult = IDOK;

    // save the old file name in case there's an error
    TCHAR *strOldName;
    UINT fileNameSize = lstrlen(m_strFileName);
    strOldName = new TCHAR[fileNameSize+1];

    if (!strOldName)
    {
        ERROR_OUT(("OnSave: failed to allocate strOldName TCHAR array, fail"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }
    else
    {
        lstrcpy(strOldName, m_strFileName);
    }

    BOOL bNewName = FALSE;

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }

    // Check whether there is a filename available for use
    if (!fileNameSize || bPrompt)
    {
        // Get user input, continue only if the user selects the OK button
        iResult = GetFileName();

        if (iResult == IDOK)
        {
            // entering a blank file name is treated as cancelling the save
            if (!lstrlen(m_strFileName))
            {
                lstrcpy(m_strFileName, strOldName);
                iResult = IDCANCEL;
            }
            else
            {
                // flag that we've changed the contents file name
                bNewName = TRUE;
            }
        }
    }

    // Now save the file
    if ((iResult == IDOK) && lstrlen(m_strFileName))
    {
        WIN32_FIND_DATA findFileData;
        HANDLE          hFind;

        // Get attributes
        hFind = ::FindFirstFile(m_strFileName, &findFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            ::FindClose(hFind);

            // This is a read-only file; we can't change its contents
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                WARNING_OUT(("Dest file %s is read only", m_strFileName));
                ::Message(NULL, IDS_SAVE, IDS_SAVE_READ_ONLY);

                // If the file name was changed for this save then undo
                // the change
                if (bNewName)
                {
                    lstrcpy(m_strFileName, strOldName);
                    bNewName = FALSE;
                }

                // Change the return code to indicate no save was made
                iResult = IDCANCEL;
                return(iResult);
            }
        }

        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL,IDC_WAIT));

        // Write the file
        if (g_pwbCore->WBP_ContentsSave(m_strFileName) != 0)
        {
            // Show that an error occurred saving the file.
            WARNING_OUT(("Error saving file"));
            ::Message(NULL, IDS_SAVE, IDS_SAVE_ERROR);

            // If the file name was changed for this save then undo
            // the change
            if (bNewName)
            {
                lstrcpy(m_strFileName, strOldName);
                bNewName = FALSE;
            }

            // Change the return code to indicate no save was made
            iResult = IDCANCEL;
        }

        // Restore the cursor
        ::SetCursor(::LoadCursor(NULL,IDC_ARROW));
    }

    // if the contents file name has changed as a result of the save then
    // update the window title
    if (bNewName)
    {
		UpdateWindowTitle();
    }

	delete [] strOldName;
    return(iResult);
}



//
// CancelSaveDialog()
// This cancels the save as dialog if up and we need to kill it to continue.
// We walk back up the owner chain in case the save dialog puts up help or
// other owned windows.
//
void WbMainWindow::CancelSaveDialog(void)
{
    WBFINDDIALOG        wbf;

    ASSERT(m_bInSaveDialog);

    wbf.hwndOwner = m_hwnd;
    wbf.hwndDialog = NULL;
    EnumThreadWindows(::GetCurrentThreadId(), WbFindCurrentDialog, (LPARAM)&wbf);

    if (wbf.hwndDialog)
    {
        // Found it!
        ::SendMessage(wbf.hwndDialog, WM_COMMAND, IDCANCEL, 0);
    }

    m_bInSaveDialog = FALSE;
}



BOOL CALLBACK WbFindCurrentDialog(HWND hwndNext, LPARAM lParam)
{
    WBFINDDIALOG * pwbf = (WBFINDDIALOG *)lParam;

    // Is this a dialog, owned by the main window?
    if ((::GetClassLong(hwndNext, GCW_ATOM) == 0x8002) &&
        (::GetWindow(hwndNext, GW_OWNER) == pwbf->hwndOwner))
    {
        pwbf->hwndDialog = hwndNext;
        return(FALSE);
    }

    return(TRUE);
}



//
//
// Function:    OnClose
//
// Purpose:     Close the Whiteboard
//
//
void WbMainWindow::OnClose()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClose");

    int iOnSave = IDOK;

    KillInitDlg();

    m_drawingArea.CancelDrawingMode();
    m_drawingArea.RemoveMarker(NULL);
    m_drawingArea.GetMarker()->DeleteAllMarkers( NULL );

    m_AG.SaveSettings();

    // If we got here, by way of OnDestroy from the DCL cores or
    // by system shutdown, then assume that user responded already to the
    // save-changes dialog that would have poped up during conf's global shutdown
    // message. We don't need to ask 'em again. What tangled webs......
    if ((!m_bQuerySysShutdown) && (IsIdle()))
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            iOnSave = OnSave(TRUE);
        }
    }

    // If the exit was not cancelled, close the application
    if (iOnSave != IDCANCEL)
    {
        // Mark state as closing - stops any queued events being processed
        m_uiState = CLOSING;

        //PUTBACK BY RAND - the progress timer meter is kinda the heart beat
        //                    of this thing which I ripped out when I removed the
        //                    progress meter. I put it back to fix 1476.
        if (m_bTimerActive)
        {
            ::KillTimer(m_hwnd, TIMERID_PROGRESS_METER);
            m_bTimerActive = FALSE;
        }

        m_drawingArea.ShutDownDC();

        // Close the application
        ::PostQuitMessage(0);
    }

}


//
//
// Function:    OnClearPage
//
// Purpose:     Clear the Whiteboard drawing area. The user is prompted to
//              choose clearing of foreground, background or both.
//
//
void WbMainWindow::OnClearPage(void)
{
    int iResult;
    BOOL bWasPosted;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClearPage");

    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, IDS_CLEAR_CAPTION, IDS_CLEAR_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    if (iResult == IDYES)
    {
        TRACE_MSG(("User requested clear of page"));

        // lock the drawing area
        LockDrawingArea();

        // Save the current lock status
        SaveLock();

        // Get the Page Order Lock (with an invisible dialog)
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

        if( bGotLock  )
        {
            // clear only if we got the page lock (NM4db:470)
            m_drawingArea.Clear();
            GotoPosition(0, 0);
        }

        RestoreLock();
        UnlockDrawingArea();
    }
}




//
//
// Function:    OnDelete
//
// Purpose:     Delete the current selection
//
//
void WbMainWindow::OnDelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDelete");

    DCWbGraphic* pGraphicCopy = NULL;

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // If the user currently has a graphic selected
    if (m_drawingArea.GraphicSelected())
    {
      m_LastDeletedGraphic.BurnTrash();

      // Delete the currently selected graphic and add to m_LastDeletedGraphic
      m_drawingArea.DeleteSelection();
    }
}

//
//
// Function:    OnUndelete
//
// Purpose:     Undo the last delete operation
//
//
void WbMainWindow::OnUndelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnUndelete");

    // If there is a deleted graphic to restore
    if ( m_LastDeletedGraphic.GotTrash() )
    {
        // If the deleted graphic belongs to the current page
        if (m_LastDeletedGraphic.Page() == m_hCurrentPage)
        {
            // Add the graphic back into the current page
            m_LastDeletedGraphic.AddToPageLast(m_hCurrentPage);

            // if the current tool is a select tool then select the new
            // graphic, otherwise forget it.
            if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
            {
                m_LastDeletedGraphic.SelectTrash();
                m_LastDeletedGraphic.EmptyTrash();
            }
            else
            {
                // Free the local copy
                m_LastDeletedGraphic.BurnTrash();
            }
        }
    }
}



void WbMainWindow::OnSelectAll( void )
{
    // turn off any selections
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // inhibit normal select-tool action
    m_bSelectAllInProgress = TRUE;

    //put us in select-tool mode first
    OnSelectTool(IDM_SELECT);

    // back to normal
    m_bSelectAllInProgress = FALSE;

    // now, select everything
    m_drawingArea.SelectMarkerFromRect( NULL );
}



//
//
// Function:    DoCopy
//
// Purpose:     Copy the current selection to the clipboard
//
//
BOOL WbMainWindow::DoCopy(BOOL bRenderNow)
{
    BOOL bResult = FALSE;
    DCWbGraphicMarker *pMarker;

    DCWbGraphic* pGraphic = m_drawingArea.GetSelection();
    if (pGraphic != NULL)
        {
        pMarker = m_drawingArea.GetMarker();
        if( pMarker->GetNumMarkers() > 1 )
            {
            // more objs than just pGraphic, do a multi-object-to-clipboard
            // operation.
            pGraphic = pMarker;
            }
        //else if == 1 then pMarker contains just pGraphic already
        //    so we do a single-object-to-clipboard operation.

        // Copy the graphic (or multiple marker objects) to the clipboard
        bResult = CLP_Copy(pGraphic, bRenderNow);

        // If an error occurred during the copy, report it now
        if (!bResult)
            {
            ::Message(NULL, IDS_COPY, IDS_COPY_ERROR);
            }
        }

    return bResult;
    }

//
//
// Function:    OnCut
//
// Purpose:     Cut the current selection
//
//
void WbMainWindow::OnCut()
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if (m_drawingArea.TextEditActive())
    {
        m_drawingArea.TextEditCut();
        return;
    }

    if (DoCopy(TRUE))
    {
        // Graphic copied to the clipboard OK - delete it
        m_drawingArea.DeleteSelection();
    }
}


//
// OnCopy()
// Purpose:     Copy the current selection to the clipboard
//
//
void WbMainWindow::OnCopy(void)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if( m_drawingArea.TextEditActive() )
    {
        m_drawingArea.TextEditCopy();
        return;
    }

    DoCopy(TRUE);
}


//
//
// Function:    OnPaste
//
// Purpose:     Paste the contents of the clipboard into the drawing pane
//
//
void WbMainWindow::OnPaste()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaste");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    if (m_drawingArea.TextEditActive())
    {
        m_drawingArea.TextEditPaste();
        return;
    }

    // Get the data from the clipboard
    DCWbGraphic* pGraphic = CLP_Paste();
    if (pGraphic != NULL)
            {
            TRACE_MSG(("Got graphic object from clipboard OK"));

            //CHANGED BY RAND - have to handle marker sperately,
            //                    marker objects are already added to
            //                    m_hCurrentPage and positioned
            if( pGraphic->IsGraphicTool() == enumGraphicMarker)
            {
                ((DCWbGraphicMarker *)pGraphic)->Update();
                if( m_pCurrentTool->ToolType() == TOOLTYPE_SELECT )
                    {
                    // marker is already setup, just draw it
                    m_drawingArea.PutMarker(NULL);
                    }
                else
                    {
                    // don't select anything, dump marker
                    m_drawingArea.RemoveMarker(NULL);
                    }
                }
            else // not a marker, deal with single object
                {
                    RECT    rcVis;

                    // Position the graphic at the top left of the visible area of the
                    // drawing area
                    m_drawingArea.GetVisibleRect(&rcVis);
                pGraphic->MoveTo(rcVis.left, rcVis.top);

                // Add the graphic to the page
                pGraphic->AddToPageLast(m_hCurrentPage);

                // if the current tool is a select tool then select the new
                // object, otherwise forget it.
                if( m_pCurrentTool->ToolType() == TOOLTYPE_SELECT )
                    m_drawingArea.SelectGraphic(pGraphic);
                else
                    {
                    // Free the graphic
                    delete pGraphic;
                    }
                }
            }
        else
            {
            TRACE_MSG(("Could not get graphic from clipboard"));
            // display error message instead of throwing exception
            ::Message(NULL, IDS_PASTE, IDS_PASTE_ERROR);
            }

    }


//
//
// Function:    OnRenderAllFormats
//
// Purpose:     Render all formats of the graphic last copied to the
//              CLP_
//
//
void WbMainWindow::OnRenderAllFormats(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnRenderAllFormats");
  //
  // only render something if we have not done it already
  //
    if (CLP_LastCopiedPage() != WB_PAGE_HANDLE_NULL)
    {
        if (!CLP_RenderAllFormats())
        {
            // An error occurred rendering the formats
            ERROR_OUT(("Error rendering all formats"));
        }
    }
}

//
//
// Function:    CheckMenuItem
//
// Purpose:     Check an item on the application menus (main and context
//              menu.)
//
//
void WbMainWindow::CheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED); // bug 426
}

//
//
// Function:    UncheckMenuItem
//
// Purpose:     Uncheck an item on the application menus (main and context
//              menus.)
//
//
void WbMainWindow::UncheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED); // bug 426
}

//
//
// Function:    CheckMenuItemRecursive
//
// Purpose:     Check or uncheck an item on the any of the Whiteboard menus.
//              This function recursively searches through the menus until
//              it finds the specified item. The menu item Ids must be
//              unique for this function to work.
//
//
BOOL WbMainWindow::CheckMenuItemRecursive(HMENU hMenu,
                                            UINT uiId,
                                            BOOL bCheck)
{
    UINT uiNumItems = ::GetMenuItemCount(hMenu);

    // Attempt to check the menu item
    UINT uiCheck = MF_BYCOMMAND | (bCheck ? MF_CHECKED : MF_UNCHECKED);

    // A return code of -1 from CheckMenuItem implies that
    // the menu item was not found
    BOOL bChecked = ((::CheckMenuItem(hMenu, uiId, uiCheck) == -1) ? FALSE : TRUE);
    if (bChecked)
    {
        //
        // If this item is on the active menu, ensure it's redrawn now
        //
        if (hMenu == m_hInitMenu)
        {
            InvalidateActiveMenu();
        }
    }
    else
    {
        UINT   uiPos;
        HMENU hSubMenu;

        // Recurse through the submenus of the specified menu
        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Assume that the next item is a submenu
            // and try to get a pointer to it
            hSubMenu = ::GetSubMenu(hMenu, (int)uiPos);

            // NULL return implies the item is a not submenu
            if (hSubMenu != NULL)
            {
                // Item is a submenu, make recursive call to search it
                bChecked = CheckMenuItemRecursive(hSubMenu, uiId, bCheck);
                if (bChecked)
                {
                    // We have found the item
                    break;
                }
            }
        }
    }

    return bChecked;
}

//
//
// Function:    GetMenuWithItem
//
// Purpose:     Return the menu which contains the specified item.
//
//
HMENU WbMainWindow::GetMenuWithItem(HMENU hMenu, UINT uiID)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetMenuWithItem");

    ASSERT(hMenu != NULL);

    HMENU hMenuResult = NULL;

    // Get the number ofitems in the menu
    UINT uiNumItems = ::GetMenuItemCount(hMenu);
    UINT   uiPos;
    UINT   uiNextID;

    // Look for the item through the menu
    for (uiPos = 0; uiPos < uiNumItems; uiPos++)
    {
        // Get the ID of the item at this position
        uiNextID = ::GetMenuItemID(hMenu, uiPos);

        if (uiNextID == uiID)
        {
            // We have found the item
            hMenuResult = hMenu;
            break;
        }
    }

    // If we have not yet found the item
    if (hMenuResult == NULL)
    {
        // Look through each of the submenus of the current menu
        HMENU hSubMenu;

        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Get the ID of the item at this position
            uiNextID = ::GetMenuItemID(hMenu, uiPos);

            // If the item is a submenu
            if (uiNextID == -1)
            {
                // Get the submenu
                hSubMenu = ::GetSubMenu(hMenu, (int) uiPos);

                // Search the submenu
                hMenuResult = GetMenuWithItem(hSubMenu, uiID);
                if (hMenuResult != NULL)
                {
                    // We have found the menu with the requested item
                    break;
                }
            }
        }
    }

    return hMenuResult;
}

//
//
// Function:    OnScrollAccelerator
//
// Purpose:     Called when a scroll accelerator is used
//
//
void WbMainWindow::OnScrollAccelerator(UINT uiMenuId)
{
    int     iScroll;

    // Locate the scroll messages to be sent in the conversion table
    for (iScroll = 0; iScroll < ARRAYSIZE(s_MenuToScroll); iScroll++)
    {
        if (s_MenuToScroll[iScroll].uiMenuId == uiMenuId)
        {
            // Found it;
            break;
        }
    }

    // Send the messages
    if (iScroll < ARRAYSIZE(s_MenuToScroll))
    {
        while ((s_MenuToScroll[iScroll].uiMenuId == uiMenuId) && (iScroll < ARRAYSIZE(s_MenuToScroll)))
        {
            // Tell the drawing pane to scroll
            ::PostMessage(m_drawingArea.m_hwnd, s_MenuToScroll[iScroll].uiMessage,
                s_MenuToScroll[iScroll].uiScrollCode, 0);

            iScroll++;
        }

        // Indicate that scrolling has completed (in both directions)
        ::PostMessage(m_drawingArea.m_hwnd, WM_HSCROLL, SB_ENDSCROLL, 0L);
        ::PostMessage(m_drawingArea.m_hwnd, WM_VSCROLL, SB_ENDSCROLL, 0L);
    }
}



//
//
// Function:    OnZoom
//
// Purpose:     Zoom or unzoom the drawing area
//
//
void WbMainWindow::OnZoom()
{
    // If the drawing area is currently zoomed
    if (m_drawingArea.Zoomed())
    {
        // Remove the zoomed check mark
        UncheckMenuItem(IDM_ZOOM);

        // Tell the tool bar of the new selection
        m_TB.PopUp(IDM_ZOOM);

        // Inform the local user of the zoom state
        if (m_pLocalUser != NULL)
            m_pLocalUser->Unzoom();
    }
    else
    {
        // Set the zoomed check mark
        CheckMenuItem(IDM_ZOOM);

        // Tell the tool bar of the new selection
        m_TB.PushDown(IDM_ZOOM);

        // Inform the local user of the zoom state
        if (m_pLocalUser != NULL)
            m_pLocalUser->Zoom();
    }

    // Zoom/unzoom the drawing area
    m_drawingArea.Zoom();

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectTool
//
// Purpose:     Select the current tool
//
//
void WbMainWindow::OnSelectTool(UINT uiMenuId)
{
    UINT uiIndex;

    UncheckMenuItem(m_currentMenuTool);
    CheckMenuItem( uiMenuId);

    // Save the new menu Id
    m_currentMenuTool = uiMenuId;

    // Tell the tool bar of the new selection
    m_TB.PushDown(m_currentMenuTool);

    // Get the new tool
    m_pCurrentTool = m_ToolArray[TOOL_INDEX(m_currentMenuTool)];

    // Set the current attributes
    if( !m_bSelectAllInProgress )
    {
        m_AG.SetChoiceColor(m_pCurrentTool->GetColor() );

        ::SendMessage(m_hwnd, WM_COMMAND, IDM_COLOR, 0L);
        ::SendMessage(m_hwnd, WM_COMMAND, IDM_WIDTHS_START + m_pCurrentTool->GetWidthIndex(), 0L);//CHANGED BY RAND
    }

    // Report the change of tool to the attributes group
    m_AG.DisplayTool(m_pCurrentTool);

    // Select the new tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectColor
//
// Purpose:     Set the current color
//
//
void WbMainWindow::OnSelectColor(void)
{
    // Tell the attributes group of the new selection and get the
    // new color value selected ino the current tool.
    m_AG.SelectColor(m_pCurrentTool);

    // Select the changed tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If we are using a select tool, change the color of the selected object
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        // If there is an object marked for changing
        if (m_drawingArea.GraphicSelected())
        {
            // Update the object
            m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
        }
    }

    // if currently editing a text object then change its color
    if (   (m_pCurrentTool->ToolType() == TOOLTYPE_TEXT)
        && (m_drawingArea.TextEditActive()))
    {
        m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSelectWidth
//
// Purpose:     Set the current nib width
//
//
void WbMainWindow::OnSelectWidth(UINT uiMenuId)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // Move the check mark on the menu
    UncheckMenuItem(m_currentMenuWidth);
    CheckMenuItem(uiMenuId);

    // Save the new pen width
    m_currentMenuWidth = uiMenuId;

    // Tell the attributes display of the new selection
    m_WG.PushDown(uiMenuId - IDM_WIDTHS_START);

    if (m_pCurrentTool != NULL)
    {
        m_pCurrentTool->SetWidthIndex(uiMenuId - IDM_WIDTHS_START);
    }

    // Tell the drawing pane of the new selection
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If we are using a select tool, change the color of the selected object
    if (m_pCurrentTool->ToolType() == TOOLTYPE_SELECT)
    {
        // If there is an object marked for changing
        if (m_drawingArea.GraphicSelected())
        {
            // Update the object
            m_drawingArea.SetSelectionWidth(m_pCurrentTool->GetWidth());
        }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnChooseFont
//
// Purpose:     Let the user select a font
//
//
void WbMainWindow::OnChooseFont(void)
{
    HDC hdc;
    LOGFONT lfont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnChooseFont");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // It is only really sensible to be here when a text tool is selected.
    // This is achieved by graying the Font selection menu entry when
    // anything other than a text tool is in use.

    // Get the font details from the current tool
    ::GetObject(m_pCurrentTool->GetFont(), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    //
    // The Font dialog is passed a LOGFONT structure which it uses to
    // initialize all of its fields (face name, weight etc).
    //
    // The face name passed in the LOGFONT structure is checked by the dialog
    // against the facenames of all available fonts.  If the name does not
    // match one of the available fonts, no name is displayed.
    //
    // WB stores the LOGFONT structure specifying the font used for a text
    // object in the object.  This LOGFONT is selected into a DC where the
    // GDIs font mapper decides which physical font most closely matches the
    // required logical font.  On boxes where the original font is not
    // supported the font is substituted for the closest matching font
    // available.
    //
    // So, if we pass the LOGFONT structure for a font which is not supported
    // into the Font dialog, no facename is displayed.  To bypass this we
    //
    // - select the logical font into a DC
    //
    // - determine the textmetrics and get the face name of the physical font
    //   chosen by the Font Mapper
    //
    // - use these textmetrics to create a LOGFONT structure which matches
    //   the substituted font!
    //
    // The resulting LOGFONT will have the correct weight, dimensions and
    // facename for the substituted font.
    //
    hdc = ::CreateCompatibleDC(NULL);
    if (hdc != NULL)
    {
        TEXTMETRIC  tm;
        HFONT       hFont;
        HFONT       hOldFont;

        hFont = ::CreateFontIndirect(&lfont);

        //
        // Get the face name and text metrics of the selected font.
        //
        hOldFont = SelectFont(hdc, hFont);
        if (hOldFont == NULL)
        {
            WARNING_OUT(("Failed to select font into DC"));
        }
        else
        {
            ::GetTextMetrics(hdc, &tm);
            ::GetTextFace(hdc, LF_FACESIZE, lfont.lfFaceName);

            //
            // Restore the old font back into the DC.
            //
            SelectFont(hdc, hOldFont);

            //
            // Create a LOGFONT structure which matches the Text metrics
            // of the font used by the DC so that the font dialog manages
            // to initialise all of its fields properly, even for
            // substituted fonts...
            //
            lfont.lfHeight    =  tm.tmHeight;
            lfont.lfWidth     =  tm.tmAveCharWidth;
            lfont.lfWeight    =  tm.tmWeight;
            lfont.lfItalic    =  tm.tmItalic;
            lfont.lfUnderline =  tm.tmUnderlined;
            lfont.lfStrikeOut =  tm.tmStruckOut;
            lfont.lfCharSet   =  tm.tmCharSet;

            //ADDED BY RAND - to make lfHeight be a char height. This makes
            //                the font dlg show the same pt size that is
            //                displayed in the sample font toolbar
            if( lfont.lfHeight > 0 )
            {
                lfont.lfHeight = -(lfont.lfHeight - tm.tmInternalLeading);
            }
        }

        ::DeleteDC(hdc);

        if (hFont != NULL)
        {
            ::DeleteFont(hFont);
        }
    }
    else
    {
        WARNING_OUT(("Failed to get DC to select font into"));
    }

    CHOOSEFONT  cf;
    TCHAR       szStyleName[64];

    ZeroMemory(&cf, sizeof(cf));
    ZeroMemory(szStyleName, sizeof(szStyleName));

    cf.lStructSize = sizeof(cf);
    cf.lpszStyle = szStyleName;
    cf.rgbColors = m_pCurrentTool->GetColor() & 0x00ffffff; // blow off palette bits (NM4db:2304)
    cf.Flags = CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |
        CF_NOVERTFONTS;
    cf.lpLogFont = &lfont;
    cf.hwndOwner = m_hwnd;

    // Call up the ChooseFont dialog from COM DLG
    if (::ChooseFont(&cf))
    {
        lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

        //ADDED BY RAND - set color selected in dialog.
        m_pCurrentTool->SetColor(cf.rgbColors);
        m_AG.DisplayTool( m_pCurrentTool );

        ::SendMessage(m_hwnd, WM_COMMAND,
                (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                (LPARAM)0 );

        // Inform the drawing pane of the new selection
        HFONT   hNewFont;

        hNewFont = ::CreateFontIndirect(&lfont);
        if (!hNewFont)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return;
        }

        //
        // We need to set the text editor font after inserting it in the DC
        // and querying the metrics, otherwise we may get a font with different
        // metrics in zoomed mode
        //
        HFONT   hNewFont2;
        HDC hDC = m_drawingArea.GetCachedDC();
        TEXTMETRIC textMetrics;

        m_drawingArea.PrimeFont(hDC, hNewFont, &textMetrics);
        lfont.lfHeight            = textMetrics.tmHeight;
        lfont.lfWidth             = textMetrics.tmAveCharWidth;
        lfont.lfPitchAndFamily    = textMetrics.tmPitchAndFamily;
        ::GetTextFace(hDC, sizeof(lfont.lfFaceName),
                     lfont.lfFaceName);
        TRACE_MSG(("Font face name %s", lfont.lfFaceName));

        // Inform the drawing pane of the new selection
        hNewFont2 = ::CreateFontIndirect(&lfont);
        if (!hNewFont2)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return;
        }


		m_drawingArea.SetSelectionColor(cf.rgbColors);
		
        m_drawingArea.SetSelectionFont(hNewFont2);

        if (m_pCurrentTool != NULL)
        {
            m_pCurrentTool->SetFont(hNewFont2);
        }
        m_drawingArea.SelectTool(m_pCurrentTool);

        //
        // discard the new font
        //
        m_drawingArea.UnPrimeFont( hDC );

        // Delete the fonts we created--everybody above makes copies
        ::DeleteFont(hNewFont2);
        ::DeleteFont(hNewFont);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnToolBarToggle
//
// Purpose:     Let the user toggle the tool bar on/off
//
//
void WbMainWindow::OnToolBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bToolBarOn = !m_bToolBarOn;

    // Make the necessary updates
    if (m_bToolBarOn)
    {
        // The tool bar was hidden, so show it
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);

        // The tool window is fixed so we must resize the other panes in
        // the window to make room for it
        ResizePanes();

        // Check the associated menu item
        CheckMenuItem(IDM_TOOL_BAR_TOGGLE);
    }
    else
    {
        // The tool bar was visible, so hide it
        ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_TOOL_BAR_TOGGLE);

        ResizePanes();
    }

    // Make sure things reflect current tool
    m_AG.DisplayTool(m_pCurrentTool);

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_TOOLBARVISIBLE,
                           m_bToolBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}

//
//
// Function:    OnStatusBarToggle
//
// Purpose:     Let the user toggle the help bar on/off
//
//
void WbMainWindow::OnStatusBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bStatusBarOn = !m_bStatusBarOn;

    // Make the necessary updates
    if (m_bStatusBarOn)
    {
        // Resize the panes to give room for the help bar
        ResizePanes();

        // The help bar was hidden, so show it
        ::ShowWindow(m_hwndSB, SW_SHOW);

        // Check the associated menu item
        CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
    }
    else
    {
        // The help bar was visible, so hide it
        ::ShowWindow(m_hwndSB, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_STATUS_BAR_TOGGLE);

        // Resize the panes to take up the help bar space
        ResizePanes();
    }

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, m_bStatusBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top,
        rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}



//
//
// Function:    OnAbout
//
// Purpose:     Show the about box for the Whiteboard application. This
//              method is called whenever a WM_COMMAND with IDM_ABOUT
//              is issued by Windows.
//
//
void WbMainWindow::OnAbout()
{
    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(ABOUTBOX), m_hwnd,
        AboutDlgProc, 0);
}


INT_PTR AboutDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hwnd, IDC_ABOUTVERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hwnd, IDC_ABOUTVERSION, szVersion);

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}





//
//
// Function:    SelectWindow
//
// Purpose:     Let the user select a window for grabbing
//
//
HWND WbMainWindow::SelectWindow(void)
{
    POINT   mousePos;            // Mouse position
    HWND    hwndSelected = NULL; // Window clicked on
    MSG     msg;                 // Current message

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( GRABCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode state
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();


        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            if (msg.message == WM_LBUTTONUP)
            {
                // Get mouse position
                mousePos.x = (short)LOWORD(msg.lParam);
                mousePos.y = (short)HIWORD(msg.lParam);

                // Convert to screen coordinates
                ::ClientToScreen(m_hwnd, &mousePos);

                // Get the window under the mouse
                hwndSelected = ::WindowFromPoint(mousePos);

                // Leave the loop
                break;
            }
        }

        // Cancel if ESCAPE is pressed.
        // or if another window receives the focus
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if (msg.wParam == VK_ESCAPE)
            {
                break;
            }
        }
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    return(hwndSelected);
}

//
//
// Function:    OnGrabWindow
//
// Purpose:     Allows the user to grab a bitmap of a window
//
//
void WbMainWindow::OnGrabWindow(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabWindow");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTWINDOW),
        m_hwnd, WarnSelectWindowDlgProc, 0) != IDOK)
    {
        // User cancelled; bail out
        return;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

    // Get window selection from the user
    HWND hwndSelected = SelectWindow();

    if (hwndSelected != NULL)
    {
        // Walk back to the find the 'real' window ancestor
        HWND    hwndParent;

        // The following piece of code attempts to find the frame window
        // enclosing the selected window. This allows us to bring the
        // enclosing window to the top, bringing the child window with it.
        DWORD dwStyle;

        while ((hwndParent = ::GetParent(hwndSelected)) != NULL)
        {
            // If we have reached a stand-alone window, stop the search
            dwStyle = ::GetWindowLong(hwndSelected, GWL_STYLE);

            if (   ((dwStyle & WS_POPUP) == WS_POPUP)
                || ((dwStyle & WS_THICKFRAME) == WS_THICKFRAME)
                || ((dwStyle & WS_DLGFRAME) == WS_DLGFRAME))
            {
                break;
            }

            // Move up to the parent window
            hwndSelected = hwndParent;
        }

        // Bring the selected window to the top
        ::BringWindowToTop(hwndSelected);
        ::UpdateWindow(hwndSelected);

        // Get an image copy of the window
        RECT areaRect;

        ::GetWindowRect(hwndSelected, &areaRect);

        DCWbGraphicDIB dib;
        dib.FromScreenArea(&areaRect);

        // Add the new grabbed bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Show the windows again
    ::ShowWindow(m_hwnd, SW_SHOW);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
// WarnSelectWindowDlgProc()
// This puts up the warning/explanation dialog.  We use the default settings
// or whatever the user chose last time this dialog was up.
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            if (OPT_GetBooleanOption( OPT_MAIN_SELECTWINDOW_NOTAGAIN,
                            DFLT_MAIN_SELECTWINDOW_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SWWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTWINDOW_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    ShowAllWindows
//
// Purpose:     Show or hide the main window and associated windows
//
//
void WbMainWindow::ShowAllWindows(int iShow)
{
    // Show/hide the main window
    ::ShowWindow(m_hwnd, iShow);

    // Show/hide the tool window
    if (m_bToolBarOn)
    {
        ::ShowWindow(m_TB.m_hwnd, iShow);
    }
}

//
//
// Function:    OnGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::OnGrabArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabArea");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTAREA),
        m_hwnd, WarnSelectAreaDlgProc, 0) != IDOK)
    {
        // User cancelled, so bail out
        return;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode status
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Let the user select the area to be grabbed
    RECT rect;
    int  tmp;

    GetGrabArea(&rect);

    // Normalize coords
    if (rect.right < rect.left)
    {
        tmp = rect.left;
        rect.left = rect.right;
        rect.right = tmp;
    }

    if (rect.bottom < rect.top)
    {
        tmp = rect.top;
        rect.top = rect.bottom;
        rect.bottom = tmp;
    }

    DCWbGraphicDIB dib;
    if (!::IsRectEmpty(&rect))
    {
        // Get a bitmap copy of the screen area
        dib.FromScreenArea(&rect);
    }

    // Show the windows again now - if we do it later we get the bitmap to
    // be added re-drawn twice (once on the window show and once when the
    // graphic added indication arrives).
    ::ShowWindow(m_hwnd, SW_SHOW);
    ::UpdateWindow(m_hwnd);

    if (!::IsRectEmpty(&rect))
    {
        // Add the bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}



//
// WarnSelectArea dialog handler
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            if (OPT_GetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN,
                    DFLT_MAIN_SELECTAREA_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SAWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    GetGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::GetGrabArea(LPRECT lprect)
{
    POINT  mousePos;            // Mouse position
    MSG    msg;                 // Current message
    BOOL   tracking = FALSE;    // Flag indicating mouse button is down
    HDC    hDC = NULL;
    POINT  grabStartPoint;      // Start point (when mouse button is pressed)
    POINT  grabEndPoint;        // End point (when mouse button is released)
    POINT  grabCurrPoint;       // Current mouse position

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetGrabArea");

    // Set the result to an empty rectangle
    ::SetRectEmpty(lprect);

    // Create the rectangle to be used for tracking
    DCWbGraphicTrackingRectangle rectangle;
    rectangle.SetColor(RGB(0, 0, 0));
    rectangle.SetPenWidth(1);
    rectangle.SetPenStyle(PS_DOT);

    // Get the DC for tracking
    HWND hDesktopWnd = ::GetDesktopWindow();
    hDC = ::GetWindowDC(hDesktopWnd);
    if (hDC == NULL)
    {
        WARNING_OUT(("NULL desktop DC"));
        goto GrabAreaCleanup;
    }

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();

        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            TRACE_MSG(("canceling grab"));

            // Erase the last tracking rectangle
            if (!EqualPoint(grabStartPoint, grabEndPoint))
            {
                rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                rectangle.Draw(hDC);
            }

            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            // Get mouse position
            TRACE_MSG( ("msg = %x, lParam = %0x", msg.message, msg.lParam) );
            mousePos.x = (short)LOWORD(msg.lParam);
            mousePos.y = (short)HIWORD(msg.lParam);

            TRACE_MSG( ("mousePos = %d,%d", mousePos.x, mousePos.y) );

            // Convert to screen coordinates
            ::ClientToScreen(m_hwnd, &mousePos);
            grabCurrPoint = mousePos;

            switch (msg.message)
            {
                // Starting the grab
                case  WM_LBUTTONDOWN:
                    // Save the starting position
                    TRACE_MSG(("grabbing start position"));
                    grabStartPoint = mousePos;
                    grabEndPoint   = mousePos;
                    tracking       = TRUE;
                    break;

                // Completing the rectangle
                case WM_LBUTTONUP:
                {
                    tracking       = FALSE;
                    // Check that there is an area to capture
                    TRACE_MSG(("grabbing end position"));
                    if (EqualPoint(grabStartPoint, grabCurrPoint))
                    {
                        TRACE_MSG(("start == end, skipping grab"));
                        goto GrabAreaCleanup;
                    }

                    // Erase the last tracking rectangle
                    if (!EqualPoint(grabStartPoint, grabEndPoint))
                    {
                        rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                        rectangle.Draw(hDC);
                    }

                    // Update the rectangle object
                    rectangle.SetRectPts(grabStartPoint, grabCurrPoint);
                    *lprect = *rectangle.GetRect();

                    // We are done
                    goto GrabAreaCleanup;
                }
                break;

                // Continuing the rectangle
                case WM_MOUSEMOVE:
                    if (tracking)
                    {
                        TRACE_MSG(("tracking grab"));

                        // Erase the last tracking rectangle
                        if (!EqualPoint(grabStartPoint, grabEndPoint))
                        {
                            rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                            rectangle.Draw(hDC);
                        }

                        // Draw the new rectangle
                        if (!EqualPoint(grabStartPoint, grabCurrPoint))
                        {
                            // Save the new box end point
                            grabEndPoint = grabCurrPoint;

                            // Draw the rectangle
                            TRACE_MSG( ("grabStartPoint = %d,%d",
                                grabStartPoint.x, grabStartPoint.y) );
                            TRACE_MSG( ("grabEndPoint = %d,%d",
                                grabEndPoint.x, grabEndPoint.y) );

                            rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                            rectangle.Draw(hDC);
                        }
                    }
                    break;
            }
        }
        // Cancel if ESCAPE is pressed.
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if( ((msg.message == WM_KEYUP)||(msg.message == WM_SYSKEYUP))&&
                (msg.wParam == VK_ESCAPE) )
            {
                TRACE_MSG(("grab cancelled by ESC"));

                // Erase the last tracking rectangle
                if (!EqualPoint(grabStartPoint, grabEndPoint))
                {
                    rectangle.SetRectPts(grabStartPoint, grabEndPoint);
                    rectangle.Draw(hDC);
                }
                break;
            }
        }
    }

GrabAreaCleanup:

    // Release the device context (if we have it)
    if (hDC != NULL)
    {
        ::ReleaseDC(hDesktopWnd, hDC);
    }
}



//
//
// Function:    AddCapturedImage
//
// Purpose:     Add a bitmap to the contents (adding a new page for it
//              if necessary).
//
//
void WbMainWindow::AddCapturedImage(DCWbGraphicDIB& dib)
{
    // Position the grabbed object at the top left of the currently visible
    // area.
    RECT    rcVis;
    m_drawingArea.GetVisibleRect(&rcVis);
    dib.MoveTo(rcVis.left, rcVis.top);

    // Add the new grabbed bitmap
    dib.AddToPageLast(m_hCurrentPage);
}

//
//
// Function:    OnPrint
//
// Purpose:     Print the contents of the drawing pane
//
//
void WbMainWindow::OnPrint()
{
    BOOL        bPrintError = FALSE;
    PRINTDLG    pd;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPrint");

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    //
    // Initialize the PRINTDLG structure
    //
    ZeroMemory(&pd, sizeof(pd));
    pd.lStructSize      = sizeof(pd);
    pd.hInstance        = g_hInstance;
    pd.hwndOwner        = m_hwnd;
    pd.Flags            = PD_ALLPAGES | PD_RETURNDC | PD_PAGENUMS |
        PD_HIDEPRINTTOFILE | PD_NOSELECTION;

    pd.nMinPage         = 1;
    pd.nMaxPage         = (WORD)g_pwbCore->WBP_ContentsCountPages();
    pd.nFromPage        = pd.nMinPage;
    pd.nToPage          = pd.nMaxPage;

    // Put up the COMMDLG print dialog
    if (::PrintDlg(&pd))
    {
        int nStartPage, nEndPage;

        // Get the start and end page numbers to be printed
        if (pd.Flags & PD_PAGENUMS)
        {
            nStartPage  = pd.nFromPage;
            nEndPage    = pd.nToPage;
        }
        else
        {
            nStartPage  = pd.nMinPage;
            nEndPage    = pd.nMaxPage;
        }

        // Check whether any pages are to be printed
        if (nStartPage <= pd.nMaxPage)
        {
            // Ensure that the start and end pages lie within range.
            nStartPage = max(nStartPage, pd.nMinPage);
            nEndPage = min(nEndPage, pd.nMaxPage);

            // Get the printer and output port names.
            // These are written to the dialog for the user to see
            // in the OnInitDialog member.
            TCHAR szDeviceName[2*_MAX_PATH];
            LPDEVNAMES lpDev;

            // Device name
            if (pd.hDevNames == NULL)
            {
                szDeviceName[0] = 0;
            }
            else
            {
                lpDev = (LPDEVNAMES)::GlobalLock(pd.hDevNames);

                wsprintf(szDeviceName, "%s %s",
                    (LPCTSTR)lpDev + lpDev->wDeviceOffset,
                    (LPCTSTR)lpDev + lpDev->wOutputOffset);

                ::GlobalUnlock(pd.hDevNames);
            }

            //
            // Tell the printer we are starting the print.
            // Note that the printer object handles the cancellation dialog.
            WbPrinter printer(szDeviceName);

            TCHAR szJobName[_MAX_PATH];
            ::LoadString(g_hInstance, IDS_PRINT_NAME, szJobName, _MAX_PATH);

            int nPrintResult = printer.StartDoc(pd.hDC, szJobName, nStartPage);
            if (nPrintResult < 0)
            {
                WARNING_OUT(("Print result %d", nPrintResult));
                bPrintError = TRUE;
            }
            else
            {
                // Find out how many copies to print
                int copyNum;

                copyNum = 0;
                while ((copyNum < pd.nCopies) && !bPrintError)
                {
                    // Loop through all pages
                    int nPrintPage;
                    WB_PAGE_HANDLE hPage;

                    for (nPrintPage = nStartPage; nPrintPage <= nEndPage; nPrintPage++)
                    {
                        // Get the first page
                        hPage = PG_GetPageNumber((WORD) nPrintPage);

                        // Only print the page if there are some objects on it
                        if (g_pwbCore->WBP_PageCountGraphics(hPage) > 0)
                        {
                            // Tell the printer we are starting a new page
                            printer.StartPage(pd.hDC, nPrintPage);
                            if (!printer.Error())
                            {
                                RECT    rectArea;

                                rectArea.left = 0;
                                rectArea.top = 0;
                                rectArea.right = DRAW_WIDTH;
                                rectArea.bottom = DRAW_HEIGHT;

                                // Print the page
                                PG_Print(hPage, pd.hDC, &rectArea);

                                // Inform the printer that the page is complete
                                printer.EndPage(pd.hDC);
                            }
                            else
                            {
                                bPrintError = TRUE;
                                break;
                            }
                        }
                    }

                    copyNum++;
                }

                // The print has completed
                nPrintResult = printer.EndDoc(pd.hDC);
                if (nPrintResult < 0)
                {
                    WARNING_OUT(("Print result %d", nPrintResult));
                    bPrintError = TRUE;
                }

                // reset the error if the user cancelled the print
                if (printer.Aborted())
                {
                    WARNING_OUT(("User cancelled print"));
                    bPrintError = FALSE;
                }
            }
        }
    }

    // Inform the user if an error occurred
    if (bPrintError)
    {
        // display a message informing the user the job terminated
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_PRINTER, 0);
    }

    //
    // Cleanup the hDevMode, hDevNames, and hdc blocks if allocated
    //
    if (pd.hDevMode != NULL)
    {
        ::GlobalFree(pd.hDevMode);
        pd.hDevMode = NULL;
    }

    if (pd.hDevNames != NULL)
    {
        ::GlobalFree(pd.hDevNames);
        pd.hDevNames = NULL;
    }

    if (pd.hDC != NULL)
    {
        ::DeleteDC(pd.hDC);
        pd.hDC = NULL;
    }

}


//
//
// Function:    OnPageSorter
//
// Purpose:     Re-order the pages
//
//
void WbMainWindow::OnPageSorter()
{
    // don't call up page sorter if another user is presenting (has the contents
    // locked and sync on)
    if (   (m_uiState == IN_CALL)
        && (!WB_PresentationMode()))
    {
        PAGESORT    ps;

        m_drawingArea.CancelDrawingMode();

        // Save the lock state (in case the Page Sorter gets it)
        SaveLock();

        //
        // Fill in the initial values
        //
        ZeroMemory(&ps, sizeof(ps));
        ps.hCurPage = m_hCurrentPage;
        ps.fPageOpsAllowed = (m_uiSubState == SUBSTATE_IDLE);

        //
        // Put up the dialog
        //
        ASSERT(m_hwndPageSortDlg == NULL);

        ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(PAGESORTERDIALOG),
            m_hwnd, PageSortDlgProc, (LPARAM)&ps);

        ASSERT(m_hwndPageSortDlg == NULL);

        // Restore the lock state
        RestoreLock();

        // Set up the new current page pointer
        if ((ps.hCurPage != m_hCurrentPage) || ps.fChanged)
        {
            GotoPage((WB_PAGE_HANDLE)ps.hCurPage);
        }

        // Update the page number display,
        // the number of the current page may have changed.
        UpdateStatus();
    }
}

//
//
// Function:    OnInsertPageBefore
//
// Purpose:     Insert a new page before the current page
//
//
void WbMainWindow::OnInsertPageBefore()
{
    if (!m_bUnlockStateSettled)
    {
        // Disable insert button code so crazed users can't insert again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }

    // check state before allowing action
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Save the current lock status
    SaveLock();

    // Catch exceptions so that we can restore the lock state
        // Get the Page Order Lock (with an invisible dialog)
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
        if (bGotLock)
        {
            UINT uiRet;
        WB_PAGE_HANDLE hPage;

        // Set flag to prevent any more inserts until
        // we have completely released the page-lock
        m_bUnlockStateSettled = FALSE;

        // Add the new page to the list (throws an exception on failure)
        uiRet = g_pwbCore->WBP_PageAddBefore(m_hCurrentPage, &hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Go to the inserted page
        GotoPage(hPage);
    }

  //CHANGED BY RAND
  // Restore the lock status. This will eventually set m_bUnlockStateSettled
  // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
  // and enable this function after the conference wide lock-status
  // has settled.
  RestoreLock();

}

//
//
// Function:    InsertPageAfter
//
// Purpose:     Insert a new page after the specified page.
//
//
void WbMainWindow::InsertPageAfter(WB_PAGE_HANDLE hPageAfter)
{
    if (!m_bUnlockStateSettled)
    {
        // Disable insert button code so crazed users can't insert again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }


    // check state before allowing action
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Save the current lock status
    SaveLock();

  // Catch exceptions so that we can restore the lock state
    BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
    if (bGotLock)
    {
        UINT    uiRet;
        WB_PAGE_HANDLE  hPage;

        // Set flag to prevent any more inserts until
        // we have completely released the page-lock
        m_bUnlockStateSettled = FALSE;

        uiRet = g_pwbCore->WBP_PageAddAfter(hPageAfter, &hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Move to the added page
        GotoPage(hPage);

    }

  //CHANGED BY RAND
  // Restore the lock status. This will eventually set m_bUnlockStateSettled
  // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
  // and enable this function after the conference wide lock-status
  // has settled.
  RestoreLock();

}

//
//
// Function:    OnInsertPageAfter
//
// Purpose:     Insert a new page after the current page
//
//
void WbMainWindow::OnInsertPageAfter()
{
    // Insert the new page
    InsertPageAfter(m_hCurrentPage);
}

//
//
// Function:    OnDeletePage
//
// Purpose:     Delete the current page
//
//
void WbMainWindow::OnDeletePage()
{
    int iResult;
    BOOL bWasPosted;

    if (!m_bUnlockStateSettled)
    {
        // Disable delete button code so crazed users can't delete again before
        // the conference wide page-lock status has settled. If we ask for the
        // page-lock again before the last unlock has finished then something
        // happens to the lock-event from the cores and we hang waiting for it
        // (until our wait-timeout runs out). This arguably could be called a
        // DCL core bug but I couldn't generate any convincing proof of that
        // so I just fixed it on Whiteboard's end by preventing asking for the
        // lock too soon.
        //
        // RestoreLock() will eventually set m_bUnlockStateSettled to TRUE (in
        // OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
        MessageBeep( 0xffffffff );
        return;
    }

    // check state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return;
    }

    // Display a message box with the relevant question
    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, IDS_DELETE_PAGE, IDS_DELETE_PAGE_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    // If the user wants to continue with the delete
    if (iResult == IDYES)
        {
        // If this is the only page
        if (g_pwbCore->WBP_ContentsCountPages() == 1)
            {
            // Just clear it. The core does handle this
            // case but it is better not to get the lock unnecessarily, the
            // lock is required to call the core delete page function.
            m_drawingArea.Clear();
            }
        else
            {
            // Lock the drawing area - this ensures we cannot draw to a bad page
            // It will normally be unlocked when we get the corresponding page
            // delete indication
            // - moved until after we have got the page order lock
            //LockDrawingArea();

            // Save the current lock status
            SaveLock();

            // Catch exceptions so that we can restore the lock state
                // Get the Page Order Lock (with an invisible dialog)
                BOOL bGotLock = GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
                if (bGotLock)
                {
                    UINT    uiRet;

                    // Set flag to prevent any more inserts until
                    // we have completely released the page-lock
                    m_bUnlockStateSettled = FALSE;

                    // Lock the drawing area - this ensures we cannot draw to a bad page
                    // It will normally be unlocked when we get the corresponding page
                    // delete indication
                    LockDrawingArea();

                    // Delete the page. The page is not deleted immediately but a
                    // WBP_EVENT_PAGE_DELETED event is generated.
                    uiRet = g_pwbCore->WBP_PageDelete(m_hCurrentPage);
                    if (uiRet != 0)
                    {
                        DefaultExceptionHandler(WBFE_RC_WB, uiRet);
                        return;
                    }
                    }

            //CHANGED BY RAND
            // Restore the lock status. This will eventually set m_bUnlockStateSettled
            // to TRUE (in OnWBPUnlocked() by way of the WBP_EVENT_UNLOCKED event)
            // and enable this function after the conference wide lock-status
            // has settled.
            RestoreLock();
            }
        }

    }

//
//
// Function:    OnRemotePointer
//
// Purpose:     Create a remote pointer
//
//
void WbMainWindow::OnRemotePointer(void)
{
    if (!m_pLocalUser)
        return;

    DCWbGraphicPointer* pPointer = m_pLocalUser->GetPointer();

    // This function toggles the presence of the user's remote pointer
    ASSERT(pPointer != NULL);
    if (pPointer->IsActive())
    {
        // Turn off the pointer in the user information
        pPointer->SetInactive();

        // Tell the drawing area of the change
        m_drawingArea.PointerUpdated(pPointer);

        // Set the check mark on the menu item
        UncheckMenuItem(IDM_REMOTE);

        // Pop up the sync button
        m_TB.PopUp(IDM_REMOTE);
    }
    else
    {
        // Calculate a position at which to drop the pointer. The centre of the
        // remote pointer is placed in the centre of the currently visible
        // area of the surface (the centre of the drawing area window).
        RECT rectVisible;
        RECT rectPointer;
        POINT ptCenter;

        m_drawingArea.GetVisibleRect(&rectVisible);
        pPointer->GetBoundsRect(&rectPointer);

        ptCenter.x = (rectVisible.left + rectVisible.right)  / 2;
        ptCenter.x -= ((rectPointer.right - rectPointer.left) / 2);
        ptCenter.y = (rectVisible.top  + rectVisible.bottom) / 2;
        ptCenter.y -= ((rectPointer.bottom - rectPointer.top) / 2);

        // Turn on the pointer in the user information
        pPointer->SetActive(m_hCurrentPage, ptCenter);

        // Tell the drawing area of the change
        m_drawingArea.PointerUpdated(pPointer);

        // Set the synced check mark
        CheckMenuItem(IDM_REMOTE);

        // Pop up the sync button
        m_TB.PushDown(IDM_REMOTE);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    OnSync
//
// Purpose:     Sync or unsync the Whiteboard with other users
//
//
void WbMainWindow::OnSync(void)
{
    // disabled if in presentation mode (another user has lock & sync on)
    if (!WB_PresentationMode())
    {
        if (m_pLocalUser != NULL)
        {
            // Determine whether we are currently synced
            if (m_pLocalUser->IsSynced())
            {
                // currently synced, so unsync
                Unsync();
            }
            else
            {
                // currently unsynced, so sync
                Sync();
            }
        }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function:    Sync
//
// Purpose:     Sync the Whiteboard with other users
//
//
void WbMainWindow::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Sync");

    //
    // Dont do anything if the local user is already synced.
    //
    if (!m_pLocalUser || m_pLocalUser->IsSynced())
    {
        TRACE_DEBUG(("User already synced"));
        return;
    }

    //
    // Update the local user's position information, to make sure it's up
    // to date.
    //
    RECT rcVisDraw;
    RECT rcVisUser;

    m_drawingArea.GetVisibleRect(&rcVisDraw);

    m_pLocalUser->SetVisibleRect(&rcVisDraw);

    //
    // We are not currently synced - sync now (if we have the contents
    // lock, or are the first to sync, it will put our sync position).
    //
    m_pLocalUser->Sync();

    //
    // Set the synced check mark and pop up the sync button.
    //
    CheckMenuItem(IDM_SYNC);
    m_TB.PushDown(IDM_SYNC);

    //
    // If the sync position (or zoom state) chosen was not where we are
    // now, move to the current sync position (we are joining a set of
    // synced users).
    //
    m_drawingArea.GetVisibleRect(&rcVisDraw);

    m_pLocalUser->GetVisibleRect(&rcVisUser);

    if ( (m_pLocalUser->Page()        != m_hCurrentPage)               ||
         (!::EqualRect(&rcVisUser, &rcVisDraw)) ||
         (m_pLocalUser->GetZoom()     != m_drawingArea.Zoomed())  )    //CHANGED BY RAND
    {
        TRACE_DEBUG(("Move to new sync pos/state"));
        ::PostMessage(m_hwnd, WM_USER_GOTO_USER_POSITION, 0, (LPARAM)m_pLocalUser->Handle());
    }
} // Sync



//
//
// Function:    Unsync
//
// Purpose:     Unsync the Whiteboard with other users
//
//
void WbMainWindow::Unsync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Unsync");

    //
    // Dont do anythig if we are already unsynced.
    //
    if (!m_pLocalUser || !m_pLocalUser->IsSynced())
    {
        TRACE_DEBUG(("Already unsynced"));
        return;
    }

    //
    // Unsync.
    // Set the synced check mark and pop up the sync button.
    //
    m_pLocalUser->Unsync();
    UncheckMenuItem(IDM_SYNC);
    m_TB.PopUp(IDM_SYNC);

}  // Unsync

//
//
// Function:    SaveLock
//
// Purpose:     Save the current lock type
//
//
void WbMainWindow::SaveLock(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveLock");

  m_uiSavedLockType = WB_LOCK_TYPE_NONE;

  // If we have the contents lock
  if (WB_GotContentsLock())
  {
    TRACE_MSG(("Saved contents lock"));
    m_uiSavedLockType = WB_LOCK_TYPE_CONTENTS;
  }
  else
  {
    // If we have the page order lock
    if (WB_GotLock())
    {
      TRACE_MSG(("Saved page order lock"));
      m_uiSavedLockType = WB_LOCK_TYPE_PAGE_ORDER;
    }
  }
}

//
//
// Function:    RestoreLock
//
// Purpose:     Restore the current lock type (SaveLock must have been
//              called previously.
//
//
void WbMainWindow::RestoreLock(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::RestoreLock");

  switch(m_uiSavedLockType)
  {
    case WB_LOCK_TYPE_CONTENTS:

      // If we do not have the contents lock
      if (!WB_GotContentsLock())
      {
        // Get the contents lock (with invisible dialog)
        TRACE_MSG(("Restoring contents lock"));
        GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE);

      }

      // we really own the lock, clear settled flag so page buttons don't hang
      m_bUnlockStateSettled = TRUE;

    break;


    case WB_LOCK_TYPE_PAGE_ORDER:

      if (!WB_GotLock() || WB_GotContentsLock())
      {
        // Get the page order lock (with invisible dialog)
        TRACE_MSG(("Restoring page order lock"));
        GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);

      }

      //ADDED BY RAND- we really own the lock, clear settled flag
      //                 so page buttons don't hang
      m_bUnlockStateSettled = TRUE;

    break;


    case WB_LOCK_TYPE_NONE:

      // If we have the lock
      if (WB_GotLock())
      {
        // Release the lock
        TRACE_MSG(("Restoring no lock"));

        // Let WBP_EVENT_LOCKED handle m_bUnlockStateSettled flag
        g_pwbCore->WBP_Unlock();
      }

    break;

    default:
      // We have saved an invalid lock type
      ERROR_OUT(("Bad saved lock type"));

      //ADDED BY RAND- somethings broken, clear settled flag
      //                 so page buttons don't hang
      m_bUnlockStateSettled = TRUE;
    break;
  }
}

//
//
// Function:    GetLock
//
// Purpose:     Get the Page Order Lock (synchronously)
//
//
BOOL WbMainWindow::GetLock(UINT uiLockType, UINT uiHide)
{
    BOOL    bGotRequiredLock = FALSE;
    BOOL    bCancelled       = FALSE;
    UINT  uiDialogReturn   = 0;
    UINT  lDialogDelay     = 1;
    UINT  lTimeout         = 0;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetLock");

    switch(uiLockType)
    {
        case WB_LOCK_TYPE_PAGE_ORDER:

            TRACE_DEBUG(("WB_LOCK_TYPE_PAGE_ORDER"));
            if (WB_GotLock())
            {
                TRACE_DEBUG(("Already got it"));
                bGotRequiredLock = TRUE;
                goto RestoreLockCleanup;
            }
            break;

        case WB_LOCK_TYPE_CONTENTS:

            TRACE_DEBUG(("WB_LOCK_TYPE_CONTENTS"));
            if (WB_GotContentsLock())
            {
                TRACE_DEBUG(("Already got it"));
                bGotRequiredLock = TRUE;
                goto RestoreLockCleanup;
            }
            break;

        default:
            ERROR_OUT(("Invalid lock type requested"));
            break;
    }

    if (WB_Locked())
    {
        TRACE_DEBUG(("Contents already locked"));
        goto RestoreLockCleanup;
    }


    // check for any object locks
    BOOL bAnObjectIsLocked;
    WB_PAGE_HANDLE hPage;
    DCWbGraphic* pGraphic;

    bAnObjectIsLocked = FALSE;
    hPage = m_drawingArea.Page();
    if (hPage != WB_PAGE_HANDLE_NULL)
    {
        WB_GRAPHIC_HANDLE hStart;

        pGraphic = PG_First(hPage, &hStart);
        while (pGraphic != NULL)
        {
            // get object lock
            bAnObjectIsLocked = pGraphic->Locked();

            // Release the current graphic
            delete pGraphic;

            // check object lock
            if( bAnObjectIsLocked )
                break;

            // Get the next one
            pGraphic = PG_Next(hPage, &hStart, NULL);
        }
    }

    if( bAnObjectIsLocked )
    {
        Message(NULL, IDS_LOCK, IDS_OBJECTSARELOCKED);
        return( FALSE );
    }

    //
    // If we get this far then we need to get the lock.
    //
    if (uiLockType == WB_LOCK_TYPE_PAGE_ORDER)
    {
        g_pwbCore->WBP_PageOrderLock();
    }
    else
    {
        g_pwbCore->WBP_ContentsLock();
    }

    //
    // Bring up a dialog to wait for the response.  This dialog is
    // cancelled by the event handler code when the lock response event is
    // received.
    //
    ASSERT(m_hwndWaitForLockDlg == NULL);

    TMDLG   tmdlg;

    ZeroMemory(&tmdlg, sizeof(tmdlg));
    tmdlg.bLockNotEvent = TRUE;
    tmdlg.uiMaxDisplay = MAIN_LOCK_TIMEOUT;

    if (uiHide == SW_SHOW)
    {
        tmdlg.bVisible = TRUE;

        uiDialogReturn = (UINT)::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(LOCKDIALOG),
            m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);
    }
    else
    {
        tmdlg.bVisible = FALSE;

        uiDialogReturn = (UINT)::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(INVISIBLEDIALOG),
            m_hwnd, TimedDlgProc, (LPARAM)&tmdlg);
    }

    ASSERT(m_hwndWaitForLockDlg == NULL);

    if (uiDialogReturn == IDCANCEL)
    {
        // The user cancelled the lock request or it timed out
        TRACE_MSG(("User cancelled lock request"));
        bCancelled = TRUE;
        //
        // If we havent already got the lock then unlock here.
        //
        if (!WB_GotLock())
        {
            TRACE_DEBUG(("Havent got lock confirmation yet - cancel it"));
            g_pwbCore->WBP_Unlock();
        }

        goto RestoreLockCleanup;
    }

    switch(uiLockType)
    {
        case WB_LOCK_TYPE_PAGE_ORDER:

            if (WB_GotLock())
            {
                bGotRequiredLock = TRUE;
            }
            break;

        case WB_LOCK_TYPE_CONTENTS:

            if (WB_GotContentsLock())
            {
                bGotRequiredLock = TRUE;
            }
            break;

        default:
            // can't get here - trapped at top.
            ERROR_OUT(("Invalid lock type - internal error"));
        break;
    }

RestoreLockCleanup:

    if (!bGotRequiredLock)
    {
        if( !bCancelled )
        {
            // post error only if user didn't cancel (bug NM4db:429)
            TRACE_MSG(("Failed to get the lock"));
            // post an error message indicating the failure to get the lock
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_LOCKED);
        }
    }

    return(bGotRequiredLock);
}

//
//
// Function:    OnLock
//
// Purpose:     Lock or unlock the Whiteboard
//
//
void WbMainWindow::OnLock(void)
{
    // If we have the lock, this is an unlock request
    if (WB_GotContentsLock())
    {
        // if currently loading or doing a new, then restore page order lock
        if (!IsIdle())
        {
            GetLock(WB_LOCK_TYPE_PAGE_ORDER, SW_HIDE);
        }
        else
        {
            // Release the lock
            g_pwbCore->WBP_Unlock();
        }

        // Set the locked check mark
        UncheckMenuItem(IDM_LOCK);

        // Pop up the lock button
        m_TB.PopUp(IDM_LOCK);
    }
    else
    {
        // If another user has the lock.
        // We should not usually get here if another user has the lock because
        // the Lock menu entry (and button) will be grayed.
        if (WB_ContentsLocked())
        {
            // Display a message
            Message(NULL, IDS_LOCK, IDS_LOCK_ERROR);
        }
        else
        {
            // Save the current lock state (in case the user cancels the request)
            SaveLock();

            // Catch exceptions raised during the lock request
        // Request the lock
        BOOL bGotLock = GetLock(WB_LOCK_TYPE_CONTENTS, SW_SHOW);
        if (!bGotLock)
        {
          RestoreLock();
        }
        else
        {
          // Turn sync on and write our sync position
          Sync();
          m_pLocalUser->PutSyncPosition();
        }
      }
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}

//
//
// Function : OnWBPLoadComplete
//
// Purpose  : Finished loading a file
//
//
void WbMainWindow::OnWBPLoadComplete(void)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLoadComplete");
  if (m_uiSubState == SUBSTATE_LOADING)
  {
    TRACE_MSG(("Load has completed OK"));
    SetSubstate(SUBSTATE_IDLE);
    if (WB_GotLock())
    {
    }
    ReleasePageOrderLock();
  }
  else
  {
    TRACE_MSG(("Unexpected WBP_EVENT_LOAD_COMPLETE event ignored"));
  }
}

//
//
// Function : OnWBPLoadFailed
//
// Purpose  : Finished loading a file
//
//
void WbMainWindow::OnWBPLoadFailed(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnWBPLoadFailed");

    if (m_uiSubState == SUBSTATE_LOADING)
    {
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BAD_FILE_FORMAT);

        TRACE_MSG(("Load has failed - tell the user about it..."));
        SetSubstate(SUBSTATE_IDLE);
        ReleasePageOrderLock();
    }
    else
    {
        TRACE_MSG(("Unexpected WBP_EVENT_LOAD_FAILED event ignored"));
    }
}

//
//
// Function:    GetWindowTitle
//
// Purpose:     Return a string for the window title
//
//
TCHAR * WbMainWindow::GetWindowTitle()
{

	// Calculate the size we will need
	int strSize=0;
    if( m_pLockOwner != NULL )
    {
        strSize = lstrlen(m_pLockOwner->Name());
    }

	// This is the worst scenario, the total size would be less than 2*_MAX_FNAME
	// but we give a lot of space for localization.
	int totalSize = 2*(_MAX_FNAME)
					+ strSize + 1
					+3*(_MAX_FNAME);	// account for the following strings, the total is probably < 200
										// IDS_UNTITLED
										// IDS_TITLE_SEPARATOR
										// IDS_DEFAULT
										// IDS_IN_CALL
										// IDS_IN_CALL_OTHERS
										// IDS_JOINING
										// IDS_INITIALIZING
										// IDS_NOT_IN_CALL
										// IDS_LOCKEDTITLE


	TCHAR *pTitle = new TCHAR[totalSize];
    if (!pTitle)
    {
        ERROR_OUT(("GetWindowTitle: failed to allocate TCHAR array"));
        return(NULL);
    }
	TCHAR inUseBy[_MAX_PATH];

    TCHAR *pStartTitle = pTitle;

    // Set title to either the "Untitled" string, or the loaded file name
    if( (!lstrlen(m_strFileName))||
        (GetFileTitle( m_strFileName, pTitle, 2*_MAX_FNAME ) != 0) )
    {
        strSize = ::LoadString(g_hInstance, IDS_UNTITLED, pTitle, totalSize );
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;
    }
    else
    {
		strSize = lstrlen(pTitle);
	    pTitle +=strSize;;
		ASSERT(totalSize>strSize);
	    totalSize -=strSize;
    }

    // Get the separator from resources
    strSize = ::LoadString(g_hInstance, IDS_TITLE_SEPARATOR, pTitle, totalSize);
    pTitle+=strSize;;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    // Get the application title from options
    strSize = ::LoadString(g_hInstance, IDS_DEFAULT, pTitle, totalSize );
    pTitle+=strSize;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    // Add either "In Call" or "Not in Call", or "Initialising" or
    // "Joining a call"
    strSize = ::LoadString(g_hInstance, IDS_TITLE_SEPARATOR, pTitle, totalSize);
    pTitle+=strSize;
	ASSERT(totalSize>strSize);
    totalSize -=strSize;

    if ((m_uiState == IN_CALL) && m_bCallActive)
    {
        UINT        count;

        count = g_pwbCore->WBP_PersonCountInCall();

		strSize = ::LoadString(g_hInstance, IDS_IN_CALL, inUseBy, totalSize);

		strSize=wsprintf(pTitle, inUseBy, (count-1));
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;

    }
    else  if ((m_uiState == JOINING) ||
        ((m_uiState == JOINED) && !m_bCallActive) ||
        ((m_uiState == IN_CALL) && (m_dwDomain != OM_NO_CALL) && !m_bCallActive))
    {
		strSize = ::LoadString(g_hInstance, IDS_JOINING, pTitle, totalSize );
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
		totalSize -=strSize;
    }
    else if (m_uiState == STARTING)
    {
        strSize = ::LoadString(g_hInstance, IDS_INITIALIZING, pTitle, totalSize);
    	pTitle+=strSize;
		ASSERT(totalSize>strSize);
    	totalSize -=strSize;
    }
    else
    {
		strSize = ::LoadString(g_hInstance, IDS_NOT_IN_CALL, pTitle, totalSize);
		pTitle+=strSize;
		ASSERT(totalSize>strSize);
    	totalSize -=strSize;
    }
	

    // add lock info
    if( m_pLockOwner != NULL )
    {
	    strSize = ::LoadString(g_hInstance, IDS_LOCKEDTITLE, pTitle, totalSize);
        ASSERT(totalSize>strSize);
		pTitle+=strSize;
        lstrcpy(pTitle, m_pLockOwner->Name());
    }

    // Return the complete title string
    return pStartTitle;
}





LRESULT WbMainWindow::OnConfShutdown( WPARAM, LPARAM )
{
    if (OnQueryEndSession())
    {
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0); // do close immediately
        //    :
        // DON'T DO ANYTHING else at this point except for exit.
        return( 0 );// tell conf ok to shutdown
    }
    else
        return( (LRESULT)g_cuEndSessionAbort ); // don't shutdown
}


//
//
// Function:    OnQueryEndSession
//
// Purpose:     Ensure user is prompted to save changes when windows is
//              ended.
//
//
LRESULT WbMainWindow::OnQueryEndSession(void)
{
    HWND hwndPopup;

    if ((hwndPopup = ::GetLastActivePopup(m_hwnd)) != m_hwnd)
    {
        Message(NULL,  IDS_DEFAULT, IDS_CANTCLOSE );
        ::BringWindowToTop(hwndPopup);
        return( FALSE );
    }

    // If changes are required then prompt the user to save
    int iDoNew = IDOK;

    if (IsIdle())
    {
        iDoNew = QuerySaveRequired(TRUE);
        if (iDoNew == IDYES)
        {
            // Save the changes
            iDoNew = OnSave(FALSE);
        }
    }

    // remember what we did so OnClose can act appropriately
    m_bQuerySysShutdown = (iDoNew != IDCANCEL);

    // If the user did not cancel, let windows exit
    return( m_bQuerySysShutdown );
}


//
//
// Function:    Recover
//
// Purpose:     Ensure the whiteboard is not left partly registered.
//
//
//
void WbMainWindow::Recover()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Recover");

    // If the error occurred during start-up, then quit immediately
    if (m_uiState == STARTING)
    {
        TRACE_MSG(("error during startup - exiting"));
        ::PostMessage(m_hwnd, WM_CLOSE, FALSE, 0L);
    }
    else
    {
        // ensure the drawing area is locked while we are in a bad state
        LockDrawingArea();

        // disable remote pointer while we are handling this join failure (bug 4767)
        m_TB.Disable(IDM_REMOTE);

        // set state to starting - ensures we don't get in an infinite loop,
        // because if an error occurs then we will quit if we try to recover
        m_uiState = STARTING;
        TRACE_MSG(("Attempting to recover after join call failure - state set to STARTING"));

        // state changed: update page buttons
        UpdatePageButtons();

        // see if there is a call active
        CM_STATUS cmStatus;

        // if there's a call available, try to join it
        if (!CMS_GetStatus(&cmStatus))
            cmStatus.callID = OM_NO_CALL;

        ::PostMessage(m_hwnd, WM_USER_JOIN_CALL, FALSE, (LONG)cmStatus.callID);
    }
}

//
//
// Function:    UnlockDrawingArea
//
// Purpose:     Unlock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::UnlockDrawingArea()
{
    m_drawingArea.Unlock();

    // Enable tool-bar buttons that can now be used
    if (WB_Locked() || !IsIdle())
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }

    //
    // Show the tool attributes group.
    //
    m_AG.DisplayTool(m_pCurrentTool);
}



//
//
// Function:    LockDrawingArea
//
// Purpose:     Lock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::LockDrawingArea()
{
    m_drawingArea.Lock();

    // Disable tool-bar buttons that cannot be used while locked
    if (WB_Locked() || !IsIdle())
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }

    //
    // Hide the tool attributes
    //
    if (m_WG.m_hwnd != NULL)
    {
        ::ShowWindow(m_WG.m_hwnd, SW_HIDE);
    }
    m_AG.Hide();
}


void WbMainWindow::EnableToolbar( BOOL bEnable )
{
    if (bEnable)
    {
        m_TB.Enable(IDM_SELECT);

        // don't allow text editing in zoom mode
        if( m_drawingArea.Zoomed() )
            m_TB.Disable(IDM_TEXT);
        else
            m_TB.Enable(IDM_TEXT);

        m_TB.Enable(IDM_PEN);
        m_TB.Enable(IDM_HIGHLIGHT);

        m_TB.Enable(IDM_LINE);
        m_TB.Enable(IDM_ZOOM);
        m_TB.Enable(IDM_BOX);
        m_TB.Enable(IDM_FILLED_BOX);
        m_TB.Enable(IDM_ELLIPSE);
        m_TB.Enable(IDM_FILLED_ELLIPSE);
        m_TB.Enable(IDM_ERASER);

        m_TB.Enable(IDM_GRAB_AREA);
        m_TB.Enable(IDM_GRAB_WINDOW);
        m_TB.Enable(IDM_LOCK);
        m_TB.Enable(IDM_SYNC);

        // enable remote pointer incase it was disabled handling
        // join failures (bug 4767)
        m_TB.Enable(IDM_REMOTE);
    }
    else
    {
        m_TB.Disable(IDM_SELECT);
        m_TB.Disable(IDM_PEN);
        m_TB.Disable(IDM_HIGHLIGHT);
        m_TB.Disable(IDM_TEXT);
        m_TB.Disable(IDM_LINE);
        m_TB.Disable(IDM_ZOOM);
        m_TB.Disable(IDM_BOX);
        m_TB.Disable(IDM_FILLED_BOX);
        m_TB.Disable(IDM_ELLIPSE);
        m_TB.Disable(IDM_FILLED_ELLIPSE);
        m_TB.Disable(IDM_ERASER);

        m_TB.Disable(IDM_GRAB_AREA);
        m_TB.Disable(IDM_GRAB_WINDOW);
        m_TB.Disable(IDM_LOCK);
        m_TB.Disable(IDM_SYNC);
    }
}




//
//
// Function:    UpdatePageButtons
//
// Purpose:     Enable or disable the page buttons, according to the current
//              state.
//
//
//
void WbMainWindow::UpdatePageButtons()
{
    // Disable page buttons if not in a call, or doing a new, or another user
    // has the lock and is synced.
    if ( (m_uiState != IN_CALL) ||
       (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS) ||
       (WB_PresentationMode()))
    {
        m_AG.EnablePageCtrls(FALSE);

        // when the page buttons are disabled, we do not allow the page sorter
        // dialog to be displayed
        if (m_hwndPageSortDlg != NULL)
        {
            ::SendMessage(m_hwndPageSortDlg, WM_COMMAND, MAKELONG(IDOK, BN_CLICKED),
                0);
            ASSERT(m_hwndPageSortDlg == NULL);
        }
    }
    else
    {
        m_AG.EnablePageCtrls(TRUE);
    }

    if (WB_Locked() || !IsIdle() )
    {
        EnableToolbar( FALSE );
    }
    else
    {
        EnableToolbar( TRUE );
    }


    //
    // If the page sorter is up, inform it of the state change
    //
    if (m_hwndPageSortDlg != NULL)
    {
        ::SendMessage(m_hwndPageSortDlg, WM_PS_ENABLEPAGEOPS,
            (m_uiSubState == SUBSTATE_IDLE), 0);
    }

    //
    // Enable the insert-page button if the page order's not locked
    //
    m_AG.EnableInsert( ((m_uiState == IN_CALL) &&
      (m_uiSubState == SUBSTATE_IDLE) &&
      (g_pwbCore->WBP_ContentsCountPages() < WB_MAX_PAGES) &&
      (!WB_Locked())));

    //
    // Ensure the currently active menu (if any) is correctly enabled
    //
    InvalidateActiveMenu();
}

//
//
//  Function:  InvalidateActiveMenu
//
//  Purpose:   If a menu is currently active, gray items according to
//             the current state, and force it to redraw.
//
//
void WbMainWindow::InvalidateActiveMenu()
{
  if (m_hInitMenu != NULL)
  {
      // A menu is displayed, so set the state appropriately and force a
      // repaint to show the new state
      SetMenuStates(m_hInitMenu);

      ::RedrawWindow(::GetTopWindow(::GetDesktopWindow()),
                     NULL, NULL,
                     RDW_FRAME | RDW_INVALIDATE | RDW_ERASE |
                                   RDW_ERASENOW | RDW_ALLCHILDREN);
  }
}

//
//
// Function:    CancelLoad
//
// Purpose:     Cancel any load in progress
//
//
void WbMainWindow::CancelLoad(BOOL bReleaseLock)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CancelLoad");

    // Cancel the load
    g_pwbCore->WBP_CancelLoad();

    // reset file name to untitled
    ZeroMemory(m_strFileName, sizeof(m_strFileName));

	UpdateWindowTitle();

    // reset the whiteboard substate
    SetSubstate(SUBSTATE_IDLE);

    if (bReleaseLock)
    {
        ReleasePageOrderLock();
    }
}

//
//
// Function:    ReleasePageOrderLock
//
// Purpose:     Releases the page order lock, unless the user has got the
//              contents locked, in which case it has no effect. Called
//              after asynchronous functions requiring the page order lock
//              (file/new, file/open) have completed.
//
//
void WbMainWindow::ReleasePageOrderLock()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ReleasePageOrderLock");

    //
    // Only release the page order lock if:
    //     - the contents are not also locked (if they are then releasing
    //       the page order lock has no effect).
    //     - we actually have the page order locked in the first place.
    //
    if ( (!WB_GotContentsLock()) &&
         (WB_GotLock())   )
    {
        g_pwbCore->WBP_Unlock();
    }
}

//
//
// Function:    IsIdle
//
// Purpose:     Returns true if the main window is idle (in a call and not
//              loading a file/performing a new)
//
//
BOOL WbMainWindow::IsIdle()
{

    return((m_uiState == IN_CALL) && (m_uiSubState == SUBSTATE_IDLE));
}

//
//
// Function:    SetSubstate
//
// Purpose:     Sets the substate, informing the page sorter dialog of the
//              change, if necessary.
//
//
void WbMainWindow::SetSubstate(UINT newSubState)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetSubstate");

  // substate only valid if in a call
  if (   (m_uiState != IN_CALL)
      || (newSubState != m_uiSubState))
  {
    m_uiSubState = newSubState;

    // Trace the substate change
    switch (m_uiSubState)
    {
      case SUBSTATE_IDLE:
        TRACE_DEBUG(("set substate to IDLE"));
        break;

      case SUBSTATE_LOADING:
        TRACE_DEBUG(("set substate to LOADING"));
        break;

      case SUBSTATE_NEW_IN_PROGRESS:
        TRACE_DEBUG(("set substate to NEW_IN_PROGRESS"));
        break;

      default:
        ERROR_OUT(("Unknown substate %hd",m_uiSubState));
        break;
    }

    // update the page buttons (may have become enabled/disabled)
    UpdatePageButtons();
  }

}

//
//
// Function:    PositionUpdated
//
// Purpose:     Called when the drawing area position has changed.
//              change, if necessary.
//
//
void WbMainWindow::PositionUpdated()
{
    RECT rectDraw;

    m_drawingArea.GetVisibleRect(&rectDraw);

    if (m_pLocalUser != NULL)
    {
        // Set the new position from the drawing area
        m_pLocalUser->SetVisibleRect(&rectDraw);

        // Show that an update of the sync position is pending
        m_bSyncUpdateNeeded = TRUE;
    }

    // If the current page is a valid one then store the user's position on
    // that page.
    if (m_hCurrentPage != WB_PAGE_HANDLE_NULL)
    {
        // Store position of this page
        WORD   pageIndex = (WORD)m_hCurrentPage;


	    PAGE_POSITION *mapob;
	    POSITION position = m_pageToPosition.GetHeadPosition();
		BOOL bFound = FALSE;
		while (position && !bFound)
		{
			mapob = (PAGE_POSITION *)m_pageToPosition.GetNext(position);
			if ( mapob->hPage == pageIndex)
			{
				bFound = TRUE;
			}
		}

        // If we're replacing an existing entry, then free the old entry.
        if (bFound)
        {
			mapob->position.x = rectDraw.left;
			mapob->position.y = rectDraw.top;
        }
        else
        {
			mapob = new PAGE_POSITION;

            if (!mapob)
            {
                ERROR_OUT(("PositionUpdated failing; couldn't allocate PAGE_POSITION object"));
            }
            else
            {
    			mapob->hPage = pageIndex;
	    		mapob->position.x = rectDraw.left;
		    	mapob->position.y = rectDraw.top;
			    m_pageToPosition.AddTail(mapob);
            }
        }
    }
}

//
//
// Function : OnALSLoadResult
//
// Purpose  : Deal with an ALS_LOAD_RESULT event
//
//
void WbMainWindow::OnALSLoadResult(UINT reason)
{

    int             errorMsg = 0;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnALSLoadResult");

    switch (reason)
    {
        case AL_LOAD_FAIL_NO_FP:
            WARNING_OUT(("Remote WB load failed - no FP"));
            errorMsg = IDS_MSG_LOAD_FAIL_NO_FP;
            break;

        case AL_LOAD_FAIL_NO_EXE:
            WARNING_OUT(("Remote WB load failed - no exe"));
            errorMsg = IDS_MSG_LOAD_FAIL_NO_EXE;
            break;

        case AL_LOAD_FAIL_BAD_EXE:
            WARNING_OUT(("Remote WB load failed - bad exe"));
            errorMsg = IDS_MSG_LOAD_FAIL_BAD_EXE;
            break;

        case AL_LOAD_FAIL_LOW_MEM:
            WARNING_OUT(("Remote WB load failed - low mem"));
            errorMsg = IDS_MSG_LOAD_FAIL_LOW_MEM;
            break;

        default:
            WARNING_OUT(("Bad ALSLoadResult reason %d", reason));
            break;
    }


    if (errorMsg)
    {
        //
        // Put up an error message
        //
        Message(NULL, IDS_MSG_CAPTION, errorMsg);
    }
}

//
//
// Function : OnEndSession
//
// Purpose  : Called when Windows is exiting
//
//
void WbMainWindow::OnEndSession(BOOL bEnding)
{
    if (bEnding)
    {
        ::PostQuitMessage(0);
    }
    else
    {
        m_bQuerySysShutdown = FALSE; // never mind, cancel OnClose special handling
    }
}


//
// Function: OnCancelMode()
//
// Purpose:  Called whenever a WM_CANCELMODE message is sent to the frame
//           window.
//           WM_CANCELMODE is sent when another app or dialog receives the
//           input focus.  The frame simply records that a WM_CANCELMODE
//           message has been sent.  This fact is used by the SelectWindow
//           code to determine if it should cancel the selecting of a
//           window
//
//
void WbMainWindow::OnCancelMode()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCancelMode");

    m_cancelModeSent = TRUE;

    //
    // Note: Not passed to the default handler as the default action on
    //       WM_CANCELMODE is to release mouse capture - we shall do this
    //       explicitly.
    //


    // blow off any dragging that might be in progress (bug 573)
    POINT   pt;
    ::GetCursorPos( &pt );
    ::ScreenToClient(m_drawingArea.m_hwnd, &pt);
    ::SendMessage(m_drawingArea.m_hwnd, WM_LBUTTONUP, 0, MAKELONG( pt.x, pt.y ) );

}



void WbMainWindow::LoadCmdLine(LPCSTR szFilename)
{
    int iOnSave;

    if (szFilename && *szFilename)
    {
        if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
            return;

        // Don't prompt to save file if we're already loading
        if (m_uiSubState != SUBSTATE_LOADING )
        {
            // Check whether there are changes to be saved
            iOnSave = QuerySaveRequired(TRUE);
        }
        else
        {
            return;
        }

        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            int iResult = OnSave(TRUE);

            if( iResult == IDOK )
            {
				UpdateWindowTitle();
            }
            else
            {
                // cancelled out of save, so cancel the open operation
                return;
            }
        }

        // load filename
        if( iOnSave != IDCANCEL )
            LoadFile(szFilename);
    }
}



//
// OnNotify()
// Handles TTN_NEEDTEXTA and TTN_NEEDTEXTW
//
void WbMainWindow::OnNotify(UINT id, NMHDR * pNM)
{
    UINT    nID;
    HWND    hwnd = NULL;
    POINT ptCurPos;
    UINT  nTipStringID;

    if (!pNM)
        return;

    if (pNM->code == TTN_NEEDTEXTA)
    {
        TOOLTIPTEXTA *pTA = (TOOLTIPTEXTA *)pNM;

        // get id and hwnd
        if( pTA->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID);
        if (nTipStringID == 0)
            return;

        // give it to em
        pTA->lpszText = MAKEINTRESOURCE( nTipStringID );
        pTA->hinst = g_hInstance;
    }
    else if (pNM->code == TTN_NEEDTEXTW)
    {
        TOOLTIPTEXTW *pTW = (TOOLTIPTEXTW *)pNM;

        // get id and hwnd
        if( pTW->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID );
        if (nTipStringID == 0)
            return;

        // give it to em
        pTW->lpszText = (LPWSTR) MAKEINTRESOURCE( nTipStringID );
        pTW->hinst = g_hInstance;
    }
}




//
// GetTipId()
// Finds the tooltip for a control in Whiteboard
//
UINT WbMainWindow::GetTipId(HWND hwndTip, UINT nID)
{
    WbTool *  pTool;
    BOOL      bCheckedState;
    int       nTipID;
    int       nTipStringID;
    int       i;

    // find tip stuff relevant for nID
    nTipID = -1;
    for( i=0; i<((sizeof g_tipIDsArray)/(sizeof (TIPIDS) )); i++ )
    {
        if( g_tipIDsArray[i].nID == nID )
        {
            nTipID = i;
            break;
        }
    }

    // valid?
    if( nTipID < 0 )
        return( 0 );

    // get checked state
    switch( g_tipIDsArray[ nTipID ].nCheck )
    {
        case TB:
            bCheckedState =
                (::SendMessage(m_TB.m_hwnd, TB_ISBUTTONCHECKED, nID, 0) != 0);
            break;

        case BT:
            if (hwndTip != NULL)
            {
                bCheckedState =
                    (::SendMessage(hwndTip, BM_GETSTATE, 0, 0) & 0x0003) == 1;
            }
            else
                bCheckedState = FALSE;

            break;

        case NA:
        default:
            bCheckedState = FALSE;
            break;
    }

    // get tip string id
    if( bCheckedState )
        nTipStringID = g_tipIDsArray[ nTipID ].nDownTipID;
    else
        nTipStringID = g_tipIDsArray[ nTipID ].nUpTipID;

    // done
    return( nTipStringID );
}



// gets default path if no saves or opens have been done yet
// Returns FALSE if last default should be reused
BOOL WbMainWindow::GetDefaultPath(LPTSTR csDefaultPath , UINT size)
{
	DWORD dwType;
	DWORD dwBufLen = size;
	HKEY  hDefaultKey = NULL;
	BOOL bRet =FALSE;

	if( !lstrlen(m_strFileName) )
	{
		// a name has not been picked yet in this session, use path
		// to "My Documents"
		if( (RegOpenKeyEx( HKEY_CURRENT_USER,
			"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
			0,
			KEY_READ,
			&hDefaultKey )
			!= ERROR_SUCCESS) ||
			(RegQueryValueEx( hDefaultKey,
			"Personal",
			NULL,
			&dwType,
			(BYTE *)csDefaultPath,
			&dwBufLen )
			!= ERROR_SUCCESS))
		{
			// reg failed, use desktop
			LPITEMIDLIST pidl;
			if(SUCCEEDED (SHGetSpecialFolderLocation(GetDesktopWindow(),CSIDL_DESKTOPDIRECTORY,&pidl)))
				
			{
				bRet= SHGetPathFromIDList(pidl,csDefaultPath);
			}

			if( hDefaultKey != NULL )
				RegCloseKey( hDefaultKey );
		}
		else
		{
			bRet = TRUE;
		}
	}
	return bRet;
}





void WbMainWindow::OnSysColorChange( void )
{
    if (m_drawingArea.Page() != WB_PAGE_HANDLE_NULL)
    {
        PG_ReinitPalettes();

        ::InvalidateRect(m_hwnd, NULL, TRUE );
        ::UpdateWindow(m_hwnd);
    }

    m_TB.RecolorButtonImages();
    m_AG.RecolorButtonImages();
}



//
// posts a do-you-wana-do-that message if other users are in the conference
//
BOOL WbMainWindow::UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd )
{
    if ( (m_uiState == IN_CALL) && m_bCallActive )
    {
        UINT    count;

        count = g_pwbCore->WBP_PersonCountInCall();

        if (count > 1)
        {
            if( pbWasPosted != NULL )
                *pbWasPosted = TRUE;

            return( ::Message(hwnd,  IDS_DEFAULT, IDS_MSG_USERSMIGHTLOSE, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES );
        }
    }

    if( pbWasPosted != NULL )
        *pbWasPosted = FALSE;

    return( FALSE );
}



BOOL WbMainWindow::HasGraphicChanged( PWB_GRAPHIC pOldHeaderCopy, const PWB_GRAPHIC pNewHeader )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::HasGraphicChanged");


    // If nothing is different but the lock state and some misc in a WBP_EVENT_GRAPHIC_UPDATE_IND then
    // the graphics are visually the same.
    //
    // NOTE: This does not check ZORDER. ZORDER changes are handled by WBP_EVENT_GRAPHIC_MOVED

    // if objects aren't the same length, they are different
    if( pOldHeaderCopy->length != pNewHeader->length )
        return( TRUE );

    // temporarialy set pOldHeaderCopy's locked state + misc to same as pNewHeader so we can do an
    // object compare.
    UINT uOldLocked = pOldHeaderCopy->locked;
    pOldHeaderCopy->locked = pNewHeader->locked;

    OM_OBJECT_ID oldlockPersonID = pOldHeaderCopy->lockPersonID;
    pOldHeaderCopy->lockPersonID = pNewHeader->lockPersonID;

    UINT  oldloadedFromFile = pOldHeaderCopy->loadedFromFile;
    pOldHeaderCopy->loadedFromFile = pNewHeader->loadedFromFile;

    NET_UID   oldloadingClientID = pOldHeaderCopy->loadingClientID;
    pOldHeaderCopy->loadingClientID = pNewHeader->loadingClientID;

    // compare objects
    BOOL bChanged = FALSE;
    if( memcmp( pOldHeaderCopy, pNewHeader, pOldHeaderCopy->length ) != 0 )
        bChanged = TRUE;


    // restore lock state + misc
    pOldHeaderCopy->locked = (TSHR_UINT8)uOldLocked;
    pOldHeaderCopy->lockPersonID = oldlockPersonID;
    pOldHeaderCopy->loadedFromFile = (TSHR_UINT16)oldloadedFromFile;
    pOldHeaderCopy->loadingClientID = oldloadingClientID;

    return( bChanged );
}



void WbMainWindow::UpdateWindowTitle(void)
{
    TCHAR *pTitle = GetWindowTitle();
    if (pTitle != NULL)
    {
        ::SetWindowText(m_hwnd, pTitle);
        delete pTitle;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\resource.h ===
#define IDI_APP                           1
#define WARNSELECTWINDOW                103
#define WARNSELECTAREA                  104
#define IDR_TOOLS                       118

#define ABOUTBOX                        130
#define PRINTCANCEL                     131
#define PAGESORTERDIALOG                132
#define LOCKDIALOG                      133
#define INVISIBLEDIALOG                 134
#define QUERYSAVEDIALOG                 135
#define QUERYSAVEDIALOGCANCEL           136

#define MAINMENU                        137
#define CONTEXTMENU                     138
#define GROBJMENU                       139

#define MAINACCELTABLE                  140
#define TEXTEDITACCELTABLE              141
#define PAGESGROUPACCELTABLE            142

#define REMOTEPOINTERANDMASK            143
#define REMOTEPOINTERXORDATA            144
#define LOCKCURSOR                      145
#define TEXTCURSOR                      146
#define PENCURSOR                       147
#define PENFREEHANDCURSOR               148
#define HIGHLIGHTFREEHANDCURSOR         149
#define GRABCURSOR                      150
#define DRAGPAGECURSOR                  151
#define DELETECURSOR                    152

#define IM_INITIALIZING                 161
#define WBMOVIE                         162
#define IDS_OBJECTSARELOCKED            716
#define IDS_CANTCLOSE                   875
#define IDS_CANTGETBMP                  876
#define IDS_LOCKEDTITLE                 884
#define IDS_MSG_USERSMIGHTLOSE          885

#define IDC_SWWARN_NOTAGAIN             1001
#define IDC_SAWARN_NOTAGAIN             1002
#define IDC_TOOLBAR                     1003
#define IDS_FONTOPTIONS                 1004

//
// Page sorter dialog
//
#define IDC_PS_GOTO                     300
#define IDC_PS_DELETE                   301
#define IDC_PS_INSERT_BEFORE            302
#define IDC_PS_INSERT_AFTER             303
#define IDC_PS_THUMBNAILS               304


#define IDC_ABOUTVERSION                1041
#define IDC_INITIALIZING_ANIMATION      1042

#define IDM_EDITCOLOR                   40024
#define IDM_SELECTALL                   40025


//
// Accelerators
//
#define IDVK_HELP                       50

#define IDD_PRINT_PAGE                  101
#define IDD_DEVICE_NAME                 102

#define IDM_ABOUT                       0x3000
#define IDM_HELP                        0x3001



//
// Tools menu ids
//
#define IDM_TOOLS_START                 0x3100
#define IDM_SELECT                      IDM_TOOLS_START
#define IDM_ERASER                      0x3101
#define IDM_TEXT                        0x3102
#define IDM_HIGHLIGHT                   0x3103
#define IDM_PEN                         0x3104
#define IDM_LINE                        0x3105
#define IDM_BOX                         0x3106
#define IDM_FILLED_BOX                  0x3107
#define IDM_ELLIPSE                     0x3108
#define IDM_FILLED_ELLIPSE              0x3109
#define IDM_TOOLS_MAX                   0x310A

#define IDM_COLOR                       0x3300

#define IDM_WIDTH                      0x3400
#define IDM_WIDTH_1                    0x3401
#define IDM_WIDTHS_START               IDM_WIDTH_1
#define IDM_WIDTH_2                    0x3402
#define IDM_WIDTH_3                    0x3403
#define IDM_WIDTH_4                    0x3404
#define IDM_WIDTHS_END                 0x3405

#define IDM_PAGE_FIRST                  0x3500
#define IDM_PAGE_PREV                   0x3501
#define IDM_PAGE_ANY                    0x3502
#define IDM_PAGE_NEXT                   0x3503
#define IDM_PAGE_LAST                   0x3504
#define IDM_PAGE_GOTO                   0x3505

#define IDM_EXIT                       0x3600
#define IDM_CLEAR_PAGE                 0x3601
#define IDM_FONT                       0x3602
#define IDM_SAVE                       0x3604
#define IDM_SAVE_AS                    0x3605
#define IDM_TOOL_BAR_TOGGLE            0x3606
#define IDM_STATUS_BAR_TOGGLE          0x3608
#define IDM_OPEN                       0x360b
#define IDM_CUT                        0x360c
#define IDM_COPY                       0x360d
#define IDM_PASTE                      0x360e
#define IDM_NEW                        0x360f
#define IDM_GRAB_AREA                  0x3610
#define IDM_GRAB_WINDOW                0x3611
#define IDM_PRINT                      0x3613
#define IDM_BRING_TO_TOP               0x3614
#define IDM_SEND_TO_BACK               0x3615
#define IDM_PAGE_SORTER                0x3616
#define IDM_DELETE                     0x3617
#define IDM_UNDELETE                   0x3618
#define IDM_PAGE_INSERT_BEFORE         0x361b
#define IDM_PAGE_INSERT_AFTER          0x361c
#define IDM_DELETE_PAGE                0x361d
#define IDM_REMOTE                     0x361e
#define IDM_SYNC                       0x361f
#define IDM_LOCK                       0x3620
#define IDM_WIDTHS                     0x3622
#define IDM_PAGES                      0x3623
#define IDM_GOTO_USER_POSITION         0x3624
#define IDM_GOTO_USER_POINTER          0x3625
#define IDM_ZOOM                       0x3626

//
// Scroll accelerators
//
#define IDM_PAGEUP                     0x3700
#define IDM_PAGEDOWN                   0x3701
#define IDM_SHIFTPAGEUP                0x3702
#define IDM_SHIFTPAGEDOWN              0x3703
#define IDM_LINEUP                     0x3704
#define IDM_HOME                       0x3705
#define IDM_END                        0x3706
#define IDM_LINEDOWN                   0x3707
#define IDM_SHIFTLINEUP                0x3708
#define IDM_SHIFTLINEDOWN              0x3709
#define IDM_SCROLL_END                 0x370a
#define IDM_NEXT_SHEET                 0x370b
#define IDM_PREV_SHEET                 0x370c

//
// Text Edit accelerators
//
#define IDM_DELETECHAR                 0x3800

//
// String table entry IDs
//
#define MAKE_STRING_ID(N)              (700 + N)

#define IDS_DEFAULT                    MAKE_STRING_ID(  1)

#define IDS_MENU_SYSTEM                MAKE_STRING_ID(  2)
#define IDS_MENU_FILE                  MAKE_STRING_ID(  3)
#define IDS_MENU_EDIT                  MAKE_STRING_ID(  4)
#define IDS_MENU_VIEW                  MAKE_STRING_ID(  5)
#define IDS_MENU_TOOLS                 MAKE_STRING_ID(  6)
#define IDS_MENU_OPTIONS               MAKE_STRING_ID(  7)
#define IDS_MENU_HELP                  MAKE_STRING_ID(  8)
#define IDS_MENU_WIDTH                 MAKE_STRING_ID(  9)

#define IDS_CLEAR_CAPTION              MAKE_STRING_ID( 13)
#define IDS_CLEAR_MESSAGE              MAKE_STRING_ID( 14)
#define IDS_ERROR_CAPTION              MAKE_STRING_ID( 15)
#define IDS_WINDOW_CLOSED              MAKE_STRING_ID( 16)
#define IDS_PRINT_NAME                 MAKE_STRING_ID( 17)

#define IDS_UNTITLED                   MAKE_STRING_ID( 21)
#define IDS_IN_CALL                    MAKE_STRING_ID( 22)
#define IDS_NOT_IN_CALL                MAKE_STRING_ID( 23)
#define IDS_TITLE_SEPARATOR            MAKE_STRING_ID( 24)
#define IDS_PASTE                      MAKE_STRING_ID( 29)
#define IDS_PASTE_ERROR                MAKE_STRING_ID( 30)
#define IDS_SAVE                       MAKE_STRING_ID( 31)
#define IDS_SAVE_ERROR                 MAKE_STRING_ID( 32)
#define IDS_LOCK                       MAKE_STRING_ID( 33)
#define IDS_LOCK_ERROR                 MAKE_STRING_ID( 34)
#define IDS_DELETE_PAGE                MAKE_STRING_ID( 35)
#define IDS_DELETE_PAGE_MESSAGE        MAKE_STRING_ID( 36)

#define IDS_FONT_SAMPLE                MAKE_STRING_ID( 42)
#define IDS_COPY                       MAKE_STRING_ID( 48)
#define IDS_COPY_ERROR                 MAKE_STRING_ID( 49)
#define IDS_SAVE_READ_ONLY             MAKE_STRING_ID( 50)
#define IDS_JOINING                    MAKE_STRING_ID( 51)
#define IDS_INITIALIZING               MAKE_STRING_ID( 52)

//
// File extension filters
//
#define IDS_FILTER_ALL              MAKE_STRING_ID(100)
#define IDS_FILTER_ALL_SPEC         MAKE_STRING_ID(101)
#define IDS_FILTER_WHT              MAKE_STRING_ID(102)
#define IDS_FILTER_WHT_SPEC         MAKE_STRING_ID(103)
#define IDS_EXT_WHT                 MAKE_STRING_ID(104)


//
// Error and information messages
//
#define IDS_MSG_TOO_MANY_PAGES         MAKE_STRING_ID(150)
#define IDS_MSG_CAPTION                MAKE_STRING_ID(151)
#define IDS_MSG_DEFAULT                MAKE_STRING_ID(152)
#define IDS_MSG_JOIN_CALL_FAILED       MAKE_STRING_ID(154)
#define IDS_MSG_WINDOWS_RESOURCES      MAKE_STRING_ID(158)
#define IDS_MSG_LOCKED                 MAKE_STRING_ID(159)
#define IDS_MSG_GRAPHIC_LOCKED         MAKE_STRING_ID(160)
#define IDS_MSG_NOT_LOCKED             MAKE_STRING_ID(161)
#define IDS_MSG_BAD_FILE_FORMAT        MAKE_STRING_ID(163)
#define IDS_MSG_BUSY                   MAKE_STRING_ID(165)
#define IDS_MSG_CM_ERROR               MAKE_STRING_ID(166)
#define IDS_MSG_AL_ERROR               MAKE_STRING_ID(167)
#define IDS_MSG_PRINTER_ERROR          MAKE_STRING_ID(169)
#define IDS_MSG_LOAD_FAIL_NO_FP        MAKE_STRING_ID(171)
#define IDS_MSG_LOAD_FAIL_NO_EXE       MAKE_STRING_ID(172)
#define IDS_MSG_LOAD_FAIL_BAD_EXE      MAKE_STRING_ID(173)
#define IDS_MSG_LOAD_FAIL_LOW_MEM      MAKE_STRING_ID(174)

//
// String IDs for hint windows associated with buttons
//

// TOOLBAR
#define IDS_HINT_SELECT                 MAKE_STRING_ID(200)
#define IDS_HINT_ERASER                 MAKE_STRING_ID(201)
#define IDS_HINT_TEXT                   MAKE_STRING_ID(202)
#define IDS_HINT_HIGHLIGHT              MAKE_STRING_ID(203)
#define IDS_HINT_PEN                    MAKE_STRING_ID(204)
#define IDS_HINT_LINE                   MAKE_STRING_ID(205)
#define IDS_HINT_BOX                    MAKE_STRING_ID(206)
#define IDS_HINT_FBOX                   MAKE_STRING_ID(207)
#define IDS_HINT_ELLIPSE                MAKE_STRING_ID(208)
#define IDS_HINT_FELLIPSE               MAKE_STRING_ID(209)
#define IDS_HINT_ZOOM_UP                MAKE_STRING_ID(210)
#define IDS_HINT_ZOOM_DOWN              MAKE_STRING_ID(211)
#define IDS_HINT_REMOTE_UP              MAKE_STRING_ID(212)
#define IDS_HINT_REMOTE_DOWN            MAKE_STRING_ID(213)
#define IDS_HINT_LOCK_UP                MAKE_STRING_ID(214)
#define IDS_HINT_LOCK_DOWN              MAKE_STRING_ID(215)
#define IDS_HINT_SYNC_UP                MAKE_STRING_ID(216)
#define IDS_HINT_SYNC_DOWN              MAKE_STRING_ID(217)
#define IDS_HINT_GRAB_AREA              MAKE_STRING_ID(218)
#define IDS_HINT_GRAB_WINDOW            MAKE_STRING_ID(219)

// WIDTHBAR
#define IDS_HINT_WIDTH_1                MAKE_STRING_ID(230)
#define IDS_HINT_WIDTH_2                MAKE_STRING_ID(231)
#define IDS_HINT_WIDTH_3                MAKE_STRING_ID(232)
#define IDS_HINT_WIDTH_4                MAKE_STRING_ID(233)

// PAGEBAR
#define IDS_HINT_PAGE_FIRST             MAKE_STRING_ID(240)
#define IDS_HINT_PAGE_PREVIOUS          MAKE_STRING_ID(241)
#define IDS_HINT_PAGE_ANY               MAKE_STRING_ID(242)
#define IDS_HINT_PAGE_NEXT              MAKE_STRING_ID(243)
#define IDS_HINT_PAGE_LAST              MAKE_STRING_ID(244)
#define IDS_HINT_PAGE_INSERT            MAKE_STRING_ID(245)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\precomp.h ===
//
// Precompiled header stuff
//

#define OEMRESOURCE
#define STRICT 1

#include <windows.h>
//
// CRT headers
//
#include <ctype.h>
#include <mbctype.h>
#include <string.h>
#include <math.h>
#include <memory.h>

#include <commdlg.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>

//
// NM headers
//
#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>
#include <confreg.h>
#include <oprahcom.h>
#include <indeopal.h>
#include <help_ids.h>
#include <endsesn.h>
#include <nmhelp.h>
#include <dllutil.h>

// macro for setting "match to palette colors" bits in a COLORREF
#define SET_PALETTERGB( c )  (0x02000000 | (0x00ffffff & c))

//
// AS headers
//
#include <acpi.h>


#ifdef _DEBUG
extern HDBGZONE ghZoneWb;

// UPDATE g_rgZonesWb IF THESE CHANGE
enum
{
    ZONE_WB_DEBUG = BASE_ZONE_INDEX,
    ZONE_WB_MSG,
    ZONE_WB_TIMER,
    ZONE_WB_EVENT,
    ZONE_WB_MAX
};
		
#define TRACE_DEBUG( s )	MLZ_TraceZoneEnabled(ZONE_WB_DEBUG) ? (MLZ_TraceOut s) : 0
#define TRACE_MSG( s )		MLZ_TraceZoneEnabled(ZONE_WB_MSG) ? (MLZ_TraceOut s) : 0
#define TRACE_TIMER( s )	MLZ_TraceZoneEnabled(ZONE_WB_TIMER) ? (MLZ_TraceOut s) : 0
#define TRACE_EVENT( s )	MLZ_TraceZoneEnabled(ZONE_WB_EVENT) ? (MLZ_TraceOut s) : 0

#else

#define MLZ_EntryOut(zone, func)

#define TRACE_DEBUG( a )
#define TRACE_MSG( a )
#define TRACE_TIMER( a )
#define TRACE_EVENT( a )

#endif


#include "resource.h"
#include <oblist.h>
#include "wboblist.hpp"

#include "ccl32.hpp"

#include "page.hpp"
#include "user.hpp"

#include "cgrp.hpp"
#include "wgrp.hpp"
#include "agrp.hpp"

#include "psdlg.hpp"

#include "tool.hpp"
#include "grobj.hpp"
#include "twnd.hpp"
#include "txted.hpp"
#include "draw.hpp"
#include "grptr.hpp"
#include "mwnd.hpp"


#include "globals.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\mwnd.hpp ===
//
// MWND.HPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

#ifndef __MWND_HPP_
#define __MWND_HPP_



#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))

//
// The progress timer meter is kinda the heart beat of this thing
//
#define MAIN_PROGRESS_TIMER         1000


// Milliseconds
#define MAIN_DIALOG_DELAY           1500
#define MAIN_REGISTRATION_TIMEOUT   300000   // These are long, for modems
#define MAIN_LOCK_TIMEOUT           120000

//
// Timer IDs
//
#define TIMERID_PROGRESS_METER      4
#define TIMERID_MAXDISPLAY          10


//
// Timed dialog information
//
typedef struct tagTMDLG
{
    BOOL    bLockNotEvent;
    BOOL    bVisible;
    UINT    uiMaxDisplay;
}
TMDLG;


//				  This constant must only be defined in FAR EAST sdk
//				  since it is not in US version. In Sook Choi (Korea) says
//				  it is 40h so thats what I will use. Bug 3258.
#ifndef	CLIP_DFA_OVERRIDE
#define CLIP_DFA_OVERRIDE (0x40)
#endif


// Constants for width menu commands (bug 433)
#define MENUPOS_OPTIONS   4
#define OPTIONSPOS_WIDTH  2



//
// Main state
//  STARTING      = Whiteboard just started, not ready for user input.
//                  In this state until registration dialog is cleared.
//  IN_CALL       = Whiteboard ready for input
//  ERROR_STATE   = a serious error has occurred, Whiteboard must be closed
//  JOINING       = joining a call (join call dialog is up)
//  JOINED        = Received join call indication, waiting for 'join call'
//                  dialog to be dismissed.
//  CLOSING       = Whiteboard is shutting down. Ignore all messages.
//
//
enum
{
    STARTING    = 0,
    IN_CALL,
    ERROR_STATE,
    JOINING,
    JOINED,
    CLOSING
};


//
// Substate - valid only when in call
//  IDLE            = Normal state - user can do anything permitted by
//                    current lock status.
//  LOADING         = Currently loading a file
//  NEW_IN_PROGRESS = Currently deleting contents
//
//
#define SUBSTATE_IDLE             0
#define SUBSTATE_LOADING          1
#define SUBSTATE_NEW_IN_PROGRESS  2

//
// Capture options
//
#define CAPTURE_TO_SAME   0
#define CAPTURE_TO_NEW    1

//
// Border to be left around the checkmark in the color and width menus and
// width of items in these menus.
//
#define CHECKMARK_BORDER_X 3
#define CHECKMARK_BORDER_Y 5
#define COLOR_MENU_WIDTH   40


typedef struct tagWBFINDDIALOG
{
    HWND    hwndDialog;
    HWND    hwndOwner;
} WBFINDDIALOG;



#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))

//
//
// Class:   WbMainWindow
//
// Purpose: Main Whiteboard window
//
//
class WbMainWindow
{

    //
    // Event handler friend used for redirecting events to specific main
    // window objects.
    //
    friend BOOL CALLBACK WbMainWindowEventHandler(LPVOID utHandle,
                                                  UINT  event,
                                                  UINT_PTR param1,
                                                  UINT_PTR param2);
    friend LRESULT CALLBACK WbMainWindowProc(HWND, UINT, WPARAM, LPARAM);

    friend BOOL CALLBACK WbFindCurrentDialog(HWND hwnd, LPARAM);

    friend DCWbGraphicMarker; // needs to get at LastDeletedGraphic
    friend ObjectTrashCan; // needs to get at drawingArea

public:
    //
    // Construction and destruction
    //
    WbMainWindow(void);
    ~WbMainWindow(void);

    //
    // Initialization - display the window and its children
    //
    BOOL Open(int iCommand);
    BOOL JoinDomain(void);

    //
    // Popup context menu for drawing area
    //
    void PopupContextMenu(int x, int y);

    //
    // Check whether the application is idle (not opening or doing a new)
    //
    BOOL IsIdle(void);

	// widthbar needs access to the current tool to get the current widths
    WbTool *GetCurrentTool( void )
		{return( m_pCurrentTool );}


	BOOL IsToolBarOn( void )
		{return( m_bToolBarOn );}

	WB_PAGE_HANDLE GetCurrentPage(void) {return(m_hCurrentPage);}

	BOOL UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd );


	BOOL HasGraphicChanged( PWB_GRAPHIC pOldHeaderCopy, const PWB_GRAPHIC pNewHeader );

	void UpdateWindowTitle(void);

    //
    // Handles tool tips and accelerators
    //
    BOOL    FilterMessage(MSG* pMsg);

    //
    // Global data
    //
    HWND        m_hwnd;
    WbTool *    m_ToolArray[TOOL_COUNT];

    // Dropping files onto the window
    void	OnDropFiles(HDROP hDropInfo);

protected:

    //
    // Tooltips
    //
    HWND        m_hwndToolTip;
    TOOLINFO    m_tiLastHit;
    int         m_nLastHit;

    int     OnToolHitTest(POINT pt, TOOLINFO* pTI) const;

    // WindowProc handlers
    int     OnCreate(LPCREATESTRUCT lpcs);
    void    OnDestroy();
    void    OnClose(void);
    void    OnSize(UINT, int, int);
    void    OnMove(void);
    void    OnSetFocus(void);
    void    OnInitMenuPopup(HMENU hMenu, UINT uiIndex, BOOL bSystem);
    void    OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);
    void    OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT measureStruct);
    void    OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT drawStruct);
    void    OnGetMinMaxInfo(MINMAXINFO FAR* lpmmi);
    void    OnRenderAllFormats(void);
    void    OnPaletteChanged(HWND hwndPalette);
    LRESULT OnQueryNewPalette(void);
    void    OnTimer(UINT_PTR uiTimerId);
    LRESULT OnQueryEndSession(void);
    LRESULT OnConfShutdown( WPARAM, LPARAM );
    void    OnEndSession(BOOL bEnding);
    void    OnParentNotify(UINT msg);
    LRESULT OnToolTipText(UINT, NMHDR*);

    //
    // HELP
    //
	void    ShowHelp(void);

    // Command handlers
    void    OnCommand(UINT id, UINT code, HWND hwndCtl);
    void    OnAbout(void);
    void    OnNew(void);
    void    OnOpen(void);
    void    OnClearPage(void);
    void    OnDelete(void);
    void    OnUndelete(void);
    void    OnCut(void);
    void    OnCopy(void);
    void    OnPaste(void);
    void    OnSelectAll( void );
    void    OnChooseFont(void);
    void	OnToolBarToggle(void);
    void	OnStatusBarToggle(void);
    void	OnGrabWindow(void);
    void	OnZoom(void);
    int     OnSave(BOOL bPrompt);
    void	OnPrint(void);
    void	OnPageSorter(void);
    void	OnInsertPageBefore(void);
    void	OnInsertPageAfter(void);
    void	OnDeletePage(void);
    void	OnGrabArea(void);
    void	OnLButtonDown(void);
    void	OnLButtonUp(void);
    void	OnMouseMove(void);
    void	OnRemotePointer(void);
    void	OnSync(void);
    void	OnLock(void);

    void    OnSelectTool(UINT id);          // Select the current tool
    void    OnSelectColor(void);            // Color changed in palette
    void    OnSelectWidth(UINT id);         // Select pen width

    // Scrolling control (accessed via accelerators)
    void	OnScrollAccelerator(UINT id);

    // Moving through the pages
    void	OnFirstPage(void);
    void	OnPrevPage(void);
    void	OnNextPage(void);
    void	OnLastPage(void);
    void	OnGotoPage(void);

    void    OnGotoUserPosition(LPARAM lParam);
    void    OnGotoUserPointer(LPARAM lParam);
    void    OnJoinCall(BOOL bKeepContents, LPARAM lParam);
    void    OnDisplayError(WPARAM wParam, LPARAM lParam);
    void    OnJoinPendingCall(void);

    void    LoadCmdLine(LPCSTR szFileName);

    // CancelMode processing
    void	OnCancelMode();
    void    OnNotify(UINT id, NMHDR* pNM);
	void	OnSysColorChange( void );

	BOOL    m_bInitOk;

    //
    // Flag indicating that we are currently displaying a serious error
    // message.
    //
    BOOL    m_bDisplayingError;

    //
    // Domain ID of the call we are currently in
    //
    DWORD       m_dwDomain;

    //
    // Start registration with the necessary cores and join a call initially
    //
    BOOL JoinCall(BOOL bLocal);
    BOOL WaitForJoinCallComplete(void);

    //
    // Move to a given position in the page
    //
    void GotoPosition(int x, int y);

    //
    // Go to a specific page
    //
    void GotoPage(WB_PAGE_HANDLE hPage);
    void GotoPageNumber(UINT uiPageNumber);

    //
    // Go to a specified position
    //
    void GotoSyncPosition(void);

    //
    // Flag used to prevent processing of WM_TIMER messages. Even if the
    // timer is stopped there may be old messages in the queue. This flag
    // prevents these messages being processed.
    //
    BOOL        m_bTimerActive;

    //
    // Flag indicating whether an update to the sync position is needed. The
    // update is performed from the OnTimer member when it is next entered.
    //
    BOOL        m_bSyncUpdateNeeded;

    //
    // Event handler for DC-Groupware events
    //
    BOOL EventHandler(UINT Event, UINT_PTR param1, UINT_PTR param2);
    void ProcessEvents(UINT Event, UINT_PTR param1, UINT_PTR param2);

    //
    // Individual DC-Groupware event handlers
    //
    void OnCMSNewCall(BOOL fTopProvider, DWORD _dwDomain);
    void OnCMSEndCall(void);

    void OnALSLoadResult(UINT reason);

    void OnWBPJoinCallOK(void);
    void OnWBPJoinCallFailed(void);
    void OnWBPNetworkLost(void);
    void OnWBPError(void);
    void OnWBPPageClearInd(WB_PAGE_HANDLE hPage);
    void OnWBPPageOrderUpdated(void);
    void OnWBPPageDeleteInd(WB_PAGE_HANDLE hPage);
    void OnWBPContentsLocked(POM_OBJECT hUser);
    void OnWBPPageOrderLocked(POM_OBJECT hUser);
    void OnWBPUnlocked(POM_OBJECT hUser);
    void OnWBPLockFailed(void);
    void OnWBPGraphicAdded(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicMoved(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicUpdateInd(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicReplaceInd(WB_PAGE_HANDLE hPage,
                                WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPGraphicDeleteInd(WB_PAGE_HANDLE hPage,
                               WB_GRAPHIC_HANDLE hGraphic);
    void OnWBPUserJoined(POM_OBJECT hUser);
    void OnWBPUserLeftInd(POM_OBJECT hUser);
    void OnWBPUserUpdateInd(POM_OBJECT hUser, BOOL bReplace);
    void OnWBPSyncPositionUpdated(void);
    void OnWBPLoadComplete(void);
    void OnWBPLoadFailed(void);

    //
    // Clipboard access
    //
    BOOL            DoCopy(BOOL bRenderNow);  // Copy selection to the clipboard

    // Clipboard vars
    WB_PAGE_HANDLE      m_hPageClip;
    WB_GRAPHIC_HANDLE   m_hGraphicClip;
    DCWbGraphic *       m_pDelayedGraphicClip;
    PWB_GRAPHIC         m_pDelayedDataClip;

    // Clipboard routines
    WB_PAGE_HANDLE      CLP_LastCopiedPage(void) const;
    WB_GRAPHIC_HANDLE   CLP_LastCopiedGraphic(void) const;

    int                 CLP_AcceptableClipboardFormat(void);
    DCWbGraphic *       CLP_Paste(void);
    BOOL                CLP_Copy(DCWbGraphic * pGraphic, BOOL bRenderNow = FALSE);
    void                CLP_SaveDelayedGraphic(void);
    void                CLP_FreeDelayedGraphic(void);

    BOOL                CLP_RenderFormat(int iFormat);
    BOOL                CLP_RenderAllFormats(void);
    BOOL                CLP_RenderAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_DelayAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_RenderPrivateFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsImage(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsText(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsBitmap(DCWbGraphic* pGraphic);

#ifdef RENDER_AS_MF
    BOOL                CLP_RenderMetafileFormat(DCWbGraphic* pGraphic);
#endif

    //
    // Access functions for saved delayed graphic
    //
    PWB_GRAPHIC         CLP_GetGraphicData(void);
    DCWbGraphic*        CLP_GetGraphic(void);
    void                CLP_ReleaseGraphicData(PWB_GRAPHIC pHeader);


    //
    // Tool bar window
    //
    WbToolBar       m_TB;
    BOOL            m_bToolBarOn;

    //
    // Make updates based on a new user joining the call
    //
    void UserJoined(WbUser* pUser);

    //
    // Insert a new page after the specified page
    //
    void InsertPageAfter(WB_PAGE_HANDLE hPageAfter);

public:
    //
    // Drawing pane window
    //
    WbDrawingArea m_drawingArea;

	void RemoveGraphicPointer(DCWbGraphicPointer *p) { m_drawingArea.RemoveGraphicPointer(p); }

    UINT GetSubState( void )
		{return(m_uiSubState );}

    //
    // Get a lock on the Whiteboard contents.  The first parameter
    // determines the type of lock, the second whether a visible or
    // invisible dialog is to be used (use SW_SHOW or SW_HIDE).
    //
    BOOL GetLock(UINT uiLockType, UINT uiHide = SW_SHOW);

	void SetLockOwner( const WbUser *pLockOwner )
		{m_pLockOwner = pLockOwner;}

	const WbUser * GetLockOwner( void )
		{return(m_pLockOwner );}

    //
    // FRAME WINDOW VARS
    //
    HACCEL              m_hAccelTable;

    //
    // Get the window title
    //
    TCHAR * GetWindowTitle(void);

    WbWidthsGroup       m_WG;              // Pen Widths

	void EnableToolbar( BOOL bEnable );

    //
    // Page sorter dialog
    //
    HWND        m_hwndPageSortDlg;

    //
    // Dialog that asks whether to save changes.
    //
    HWND        m_hwndQuerySaveDlg;

    //
    // Timed dialogs that are running while the main window is waiting
    // for a specific event.
    //
    HWND        m_hwndWaitForEventDlg;
    HWND        m_hwndWaitForLockDlg;

protected:
	
	HWND                m_hwndInitDlg;
    void                KillInitDlg(void);


	
	UINT GetTipId(HWND hTipWnd, UINT nID);

    //
    // Color palette, font, page controls
    //
    WbAttributesGroup   m_AG;

    //
    // Status bar
    //
    HWND                m_hwndSB;
    BOOL                m_bStatusBarOn;
    void                UpdateStatus(void);

    //
    // Initialize the menus (color and width menu items are all ownerdraw)
    //
    void InitializeMenus(void);

    //
    // Resize function for subpanes - called when the window is resized by
    // the user.
    //
    void ResizePanes(void);

    //
    // Current window size - normal, maximized or minimized
    //
    UINT                m_uiWindowSize;

    //
    // Save the current window position to the options file
    //
    void SaveWindowPosition(void);


    //
    // Menu selection functions
    //
    UINT m_currentMenuTool;                   // Current tool menu Id
    UINT m_currentMenuWidth;                  // Current width menu Id

    //
    // Current drawing tool
    //
    WbTool*           m_pCurrentTool;

    //
    // Menu update functions
    //
    void CheckMenuItem(UINT uiId);
    void UncheckMenuItem(UINT uiId);
    BOOL CheckMenuItemRecursive(HMENU hMenu, UINT uiId, BOOL bCheck);

    HMENU GetMenuWithItem(HMENU hMenu, UINT uiId);

    //
    // Select a window for grabbing
    //
    HWND SelectWindow(void);

    //
    // Add a captured bitmap to the contents
    //
    void AddCapturedImage(DCWbGraphicDIB& dib);

    //
    // Get confirmation for destructive functions (new, clear)
    //
    int QuerySaveRequired(BOOL bCancelBtn);

    //
    // Load a file
    //
    void LoadFile(LPCSTR strLoadFileName);

    //
    // Perform a save
    //

    //
    // Get a file name for saving
    //
    int GetFileName();

    //
    // Members saving and restoring the lock state.  These can be used to
    // save the lock state before obtaining a temporary lock (e.g.  for
    // adding a new page). They cannot be nested.
    //
    void SaveLock(void);
    void RestoreLock(void);
    WB_LOCK_TYPE        m_uiSavedLockType;

    //
    // Release page order lock - this should be called after an asynchronous
    // function which requires the page order lock until it has completed.
    //
    void ReleasePageOrderLock(void);

    //
    // Display a message box for an error
    //
    void DisplayError(UINT uiCaption, UINT uiMessage);

    //
    // Current file name for saving image
    //
    TCHAR     m_strFileName[2*_MAX_PATH];

    //
    // Grab an area of the screen into a bitmap
    //
    void GetGrabArea(LPRECT lprect);

    //
    // Hide/show the main window and its associated popups
    //
    void ShowAllWindows(int iShow);
    void ShowAllWindows(void) { ShowAllWindows(SW_RESTORE); }	
    void HideAllWindows(void) { ShowAllWindows(SW_MINIMIZE); }	

    //
    // Current page of graphics
    //
    WB_PAGE_HANDLE  m_hCurrentPage;

    //
    // Handle of alternative accelerator table for page and text edit fields
    //
    HACCEL      m_hAccelPagesGroup;
    HACCEL      m_hAccelTextEdit;

    //
    // Local user
    //
    WbUser*             m_pLocalUser;

	// current lock owner
	const WbUser*       m_pLockOwner;

    //
    // Registration state variables
    //
    UINT        m_uiState;
    UINT        m_uiSubState;

    //
    // Pointer to last deleted graphic(s)
    //
    ObjectTrashCan m_LastDeletedGraphic;

    //
    // Context menu for drawing area
    //
    HMENU           m_hContextMenuBar;
    HMENU           m_hContextMenu;
    HMENU           m_hGrobjContextMenuBar;
    HMENU           m_hGrobjContextMenu;

    //
    // Member function to create pop-up context menu for the drawing area
    //
    BOOL CreateContextMenus(void);

    //
    // Flag to indicate that we are currently prompting the user to save
    // changes before joining a call
    //
    BOOL            m_bPromptingJoinCall;

    // We remember if we're in a save dialog so we can canel it on certain events
    BOOL            m_bInSaveDialog;
    void            CancelSaveDialog(void);

    //
    // Recover the whiteboard into a good state
    //
    void Recover(void);

    //
    // Lock/unlock the drawing area
    //
    void LockDrawingArea(void);
    void UnlockDrawingArea(void);

    //
    // Update the page buttons disable/enable status
    //
    void UpdatePageButtons(void);

    //
    // Sync/unsync with other users.
    //
    void Sync(void);
    void Unsync(void);

    //
    // Cancel a load in progress
    //
    void CancelLoad(BOOL bReleaseLock = TRUE);

    //
    // Set the application substate
    //
    void SetSubstate(UINT newSubState);

    //
    // Ensure the attributes window is up to date
    //
    void OnUpdateAttributes(void)
                 { m_AG.DisplayTool(m_pCurrentTool); }

    //
    // Map of page handles to positions
    //
	typedef struct PAGEPOSITION
	{
		WORD    hPage;
	 	POINT   position;
	} PAGE_POSITION;

    COBLIST    m_pageToPosition;
    void PositionUpdated(void);

    //
    // Pending call status
    //
    BOOL            m_bJoinCallPending;             // Join-call pending?
    DWORD           m_dwPendingDomain;              // domain of pending join-call
    BOOL            m_bPendingCallKeepContents;     // keep contents on pending call

    UINT            m_dwJoinDomain;              // domain that is currently being
                                        // joined
    BOOL            m_bCallActive;                // Is there a call up ?

    //
    // Menu state.
    // - SetMenuStates grays items on the specified menu
    // - InvalidateActiveMenu calls SetMenuStates and forces a re-draw of
    //   the currently active menu (if any)
    // - m_pInitMenu stores a pointer to the currently active menu.
    //
public:
    void SetMenuStates(HMENU hInitMenu);

protected:
    void InvalidateActiveMenu();

    HMENU   m_hInitMenu;

    //
    // Number of remote users
    //
    UINT m_numRemoteUsers;

	BOOL m_bSelectAllInProgress;

	BOOL GetDefaultPath( LPTSTR csDefaultPath, UINT size );

	
	BOOL m_bUnlockStateSettled;

	BOOL m_bQuerySysShutdown;

	
	BOOL m_bIsWin95;

    //
    // Interface for determining if a WM_CANCELMODE message has been sent
    //
protected:
    BOOL m_cancelModeSent;

public:
    void ResetCancelMode() { m_cancelModeSent = FALSE; };
    BOOL CancelModeSent()  { return m_cancelModeSent;  };
};


//
// Timed dialog proc
//
INT_PTR CALLBACK TimedDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// QuerySave dialog proc
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectWindow dialog proc
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectArea dialog proc
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// About Box dialog proc
//
INT_PTR CALLBACK AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // __MWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\page.hpp ===
//
// PAGE.HPP
// Page Class
//
// Copyright Microsoft 1998-
//
#ifndef __PAGE_HPP_
#define __PAGE_HPP_



//
// Purpose: Handler for page of graphic objects
//

class DCWbGraphic;
class DCWbGraphicPointer;

//
// Retrieving object data
//
PWB_GRAPHIC PG_GetData(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);

//
// Allocating space for new objects
//
PWB_GRAPHIC PG_AllocateGraphic(WB_PAGE_HANDLE hPage, DWORD length);

DCWbGraphic* PG_First(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE * phGraphic, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
DCWbGraphic* PG_Next(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE * phGraphic, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);

DCWbGraphic* PG_After(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);
DCWbGraphic* PG_Before(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);

//
// Retrieving remote pointer objects
//
DCWbGraphicPointer* PG_FirstPointer(WB_PAGE_HANDLE hPage, POM_OBJECT * ppUserNext);
DCWbGraphicPointer* PG_NextPointer(WB_PAGE_HANDLE hPage, POM_OBJECT * ppUserNext);
DCWbGraphicPointer* PG_NextPointer(WB_PAGE_HANDLE hPage, const DCWbGraphicPointer* pPointer);
DCWbGraphicPointer* PG_LocalPointer(WB_PAGE_HANDLE);

//
// Deleting all objects
//
void PG_Clear(WB_PAGE_HANDLE hPage);


//
// Selecting objects
//
DCWbGraphic* PG_SelectLast(WB_PAGE_HANDLE hPage, POINT pt);
DCWbGraphic* PG_SelectPrevious(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic,
                POINT pt);

//
// Return TRUE if the specified object is topmost in the page
//
BOOL PG_IsTopmost(WB_PAGE_HANDLE hPage, const DCWbGraphic* pGraphic);

//
// Update an existing object
//
void PG_GraphicUpdate(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE *phGraphic,
   PWB_GRAPHIC pHeader);
void PG_GraphicReplace(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE *phGraphic,
    PWB_GRAPHIC pHeader);
void PG_GraphicDelete(WB_PAGE_HANDLE hPage, const DCWbGraphic& graphic);

//
// Return the bounding rectangle of all the graphics on the page
//
void PG_GetAreaInUse(WB_PAGE_HANDLE hPage, LPRECT lprcArea);

//
// Draw the entire contents of the page into the device context
// specified.
//
void PG_Draw(WB_PAGE_HANDLE hPage, HDC hdc, BOOL thumbNail = FALSE);

//
// Print an area of the page to the specified DC
//
void PG_Print(WB_PAGE_HANDLE hPage, HDC hdcPrinter, LPCRECT lprcArea);

//
// Return the palette to be used for displaying the page
//
HPALETTE    PG_GetPalette(void);
void        PG_InitializePalettes(void);
void        PG_ReinitPalettes(void);

//
// Return the intersection of the given graphic's bounding rectangle
// and any objects which are obscuring it
//
void    PG_GetObscuringRect(WB_PAGE_HANDLE hPage, DCWbGraphic* pGraphic, LPRECT lprcObscuring);


WB_GRAPHIC_HANDLE PG_ZGreaterGraphic(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hLastGraphic, 
										WB_GRAPHIC_HANDLE hTestGraphic );

//
// Search for the next active pointer on this page
//
DCWbGraphicPointer* PG_LookForPointer(WB_PAGE_HANDLE hPage, POM_OBJECT hUser);


//
// Retrieving pages
//
WB_PAGE_HANDLE PG_GetNextPage(WB_PAGE_HANDLE hPage);
WB_PAGE_HANDLE PG_GetPreviousPage(WB_PAGE_HANDLE hPage);

//
// Getting the index of a page
//
WB_PAGE_HANDLE PG_GetPageNumber(UINT uiPageNo);



#endif // __PAGE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\psdlg.hpp ===
//
// PSDLG.HPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

#ifndef __PSDLG_HPP_
#define __PSDLG_HPP_



#define INSERT_BEFORE 1
#define INSERT_AFTER  2

#define WM_LBTRACKPOINT     0x0131

#define RENDERED_WIDTH      (DRAW_WIDTH / 16)
#define RENDERED_HEIGHT     (DRAW_HEIGHT / 16)

//
// Data we store in the GWL_USERDATA of the dialog.  Some is passed in
// by the DialogBox caller.  Some is used just by the dialog.  Some is
// returned back to the DialogBox caller.
//
typedef struct tagPAGESORT
{
    UINT        hCurPage;
    BOOL        fPageOpsAllowed;
    BOOL        fChanged;
    BOOL        fDragging;
    HWND        hwnd;
    int         iCurPageNo;
    int         iPageDragging;
    HCURSOR     hCursorCurrent;
    HCURSOR     hCursorDrag;
    HCURSOR     hCursorNoDrop;
    HCURSOR     hCursorNormal;
}
PAGESORT;


//
// Messages the caller can send to the page sort dialog
//
enum
{
    WM_PS_GETCURRENTPAGE    = WM_APP,
    WM_PS_HASCHANGED,
    WM_PS_ENABLEPAGEOPS,    // wParam == TRUE or FALSE
    WM_PS_LOCKCHANGE,
    WM_PS_PAGECLEARIND,     // wParam == hPage
    WM_PS_PAGEDELIND,       // wParam == hPage
    WM_PS_PAGEORDERUPD
};

//
// The page sorter dialog uses a horizontal listbox to display the
// thumbnail views of pages.  Each item holds a bitmap of data for the
// page.  We render this bitmap the first time the item is painted.  The
// listbox takes care of scrolling and keyboard navigation for us.
//

INT_PTR CALLBACK PageSortDlgProc(HWND, UINT, WPARAM, LPARAM);

void    OnInitDialog(HWND hwndPS, PAGESORT * pps);
void    OnMeasureItem(HWND hwndPS, UINT id, LPMEASUREITEMSTRUCT lpmi);
void    OnDeleteItem(HWND hwndPS, UINT id, LPDELETEITEMSTRUCT lpdi);
void    OnDrawItem(HWND hwndPS, UINT id, LPDRAWITEMSTRUCT lpdi);
void    OnCommand(PAGESORT * pps, UINT id, UINT code, HWND hwndCtl);
BOOL    OnSetCursor(PAGESORT * pps, HWND hwnd, UINT ht, UINT msg);
void    OnDelete(PAGESORT * pps);
void    InsertPage(PAGESORT * pps, UINT uiBeforeAfter);

void    OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage);
void    OnPageOrderUpdated(PAGESORT * pps);

void    OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y);
void    WhileDragging(PAGESORT * pps, int x, int y);
void    OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y);

void    EnableButtons(PAGESORT * pps);
void    MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo);


#endif // __PSDLG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\psdlg.cpp ===
//
// PSDLG.CPP
// Page Sorter Dialog
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



static const DWORD s_helpIds[] =
    {
    IDC_PS_THUMBNAILS,        IDH_CONF_PAGESORT_MAIN,
    IDC_PS_GOTO,            IDH_CONF_PAGESORT_GOTO,
    IDC_PS_DELETE,            IDH_CONF_PAGESORT_DEL,
    IDC_PS_INSERT_BEFORE,    IDH_CONF_PAGESORT_BEFORE,
    IDC_PS_INSERT_AFTER,    IDH_CONF_PAGESORT_AFTER,
    0,0
    };



//
// PageSortDlgProc()
// Dialog message handler for the page sort dialog.  We have to set the
// real LRESULT return value in some cases.
//
INT_PTR PageSortDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    PAGESORT *  pps = (PAGESORT *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_DROPFILES:
            g_pMain->OnDropFiles((HDROP)wParam);
            fHandled = TRUE;
            break;

        case WM_INITDIALOG:
            OnInitDialog(hwnd, (PAGESORT *)lParam);
            fHandled = TRUE;
            break;

        case WM_MEASUREITEM:
            OnMeasureItem(hwnd, (UINT)wParam, (LPMEASUREITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_DRAWITEM:
            OnDrawItem(hwnd, (UINT)wParam, (LPDRAWITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_DELETEITEM:
            OnDeleteItem(hwnd, (UINT)wParam, (LPDELETEITEMSTRUCT)lParam);
            fHandled = TRUE;
            break;

        case WM_LBTRACKPOINT:
            // This gets sent to us from the listbox; see if the user is dragging
            OnStartDragDrop(pps, (UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_MOUSEMOVE:
            WhileDragging(pps, LOWORD(lParam), HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_LBUTTONUP:
        case WM_CAPTURECHANGED:
            // If we're dragging, complete the drag/drop
            OnEndDragDrop(pps, (message == WM_LBUTTONUP),
                (short)LOWORD(lParam), (short)HIWORD(lParam));
            fHandled = TRUE;
            break;

        case WM_PALETTECHANGED:
            // Repaint the thumbnail list
            ::InvalidateRect(::GetDlgItem(hwnd, IDC_PS_THUMBNAILS), NULL, TRUE);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            OnCommand(pps, GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam));
            fHandled = TRUE;
            break;

        case WM_SETCURSOR:
            fHandled = OnSetCursor(pps, (HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            DoHelpWhatsThis(wParam, s_helpIds);
            fHandled = TRUE;
            break;

        case WM_HELP:
            DoHelp(lParam, s_helpIds);
            fHandled = TRUE;
            break;

        //
        // Private PageSortDlg messages
        //
        case WM_PS_ENABLEPAGEOPS:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

            pps->fPageOpsAllowed = (wParam != 0);
            EnableButtons(pps);

            fHandled = TRUE;
            break;

        case WM_PS_LOCKCHANGE:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            EnableButtons(pps);
            fHandled = TRUE;
            break;

        case WM_PS_PAGECLEARIND:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageClearInd(pps, (WB_PAGE_HANDLE)wParam);
            fHandled = TRUE;
            break;

        case WM_PS_PAGEDELIND:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageDeleteInd(pps, (WB_PAGE_HANDLE)wParam);
            fHandled = TRUE;
            break;

        case WM_PS_PAGEORDERUPD:
            ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));
            OnPageOrderUpdated(pps);
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// OnInitDialog()
// WM_INITDIALOG handler
//
void OnInitDialog(HWND hwnd, PAGESORT * pps)
{
    int     nCount;
    RECT    rc;
    RECT    rcWindow;
    HWND    hwndList;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnInitDialog");

    ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

    // Save this away
    ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pps);

    // Get our listbox
    pps->hwnd = hwnd;

    // Also put our HWND in WbMainWindow
    ASSERT(g_pMain);
    g_pMain->m_hwndPageSortDlg = hwnd;

    //
    // Get the drag/drop cursors we use
    //
    pps->hCursorDrag = ::LoadCursor(g_hInstance, MAKEINTRESOURCE(DRAGPAGECURSOR));
    pps->hCursorNoDrop = ::LoadCursor(NULL, IDC_NO);
    pps->hCursorNormal = ::LoadCursor(NULL, IDC_ARROW);
    pps->hCursorCurrent = pps->hCursorNormal;


    // Convert the cur page to a page number
    pps->iCurPageNo = (int) g_pwbCore->WBP_PageNumberFromHandle((WB_PAGE_HANDLE)pps->hCurPage);

    //
    // Insert items, with empty data (we render thumbnail bitmap the first
    // time we draw ite).
    //
    hwndList = ::GetDlgItem(hwnd, IDC_PS_THUMBNAILS);

    nCount = g_pwbCore->WBP_ContentsCountPages();

    // LB_SETCOUNT doesn't work on NT 4.0; must use add string
    while (nCount > 0)
    {
        ::SendMessage(hwndList, LB_ADDSTRING, 0, 0);
        nCount--;
    }

    ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) == (LRESULT)g_pwbCore->WBP_ContentsCountPages());

    // Select the current page
    ::SendMessage(hwndList, LB_SETCURSEL, pps->iCurPageNo - 1, 0);

    //
    // Set the original button page op state
    //
    EnableButtons(pps);

    //
    // We can receive dropped files
    //
    DragAcceptFiles(hwnd, TRUE);
}




//
// OnMeasureItem()
//
void OnMeasureItem(HWND hwnd, UINT id, LPMEASUREITEMSTRUCT lpmis)
{
    RECT    rcClient;

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpmis, sizeof(MEASUREITEMSTRUCT)));

    //
    // We want the slots to be square, although the page is wider than it
    // is high.
    //
    ::GetClientRect(::GetDlgItem(hwnd, id), &rcClient);
    rcClient.bottom -= rcClient.top;

    lpmis->itemWidth = rcClient.bottom;
    lpmis->itemHeight = rcClient.bottom;
}



//
// OnDeleteItem()
// We need to delete the bitmap for the item, if there is one
//
void OnDeleteItem(HWND hwnd, UINT id, LPDELETEITEMSTRUCT lpdis)
{
    HBITMAP hbmp;

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpdis, sizeof(DELETEITEMSTRUCT)));

    hbmp = (HBITMAP)lpdis->itemData;
    if (hbmp != NULL)
    {
        ASSERT(GetObjectType(hbmp) == OBJ_BITMAP);
        ::DeleteBitmap(hbmp);
    }
}



//
// OnDrawItem()
// Draws the thumbnail.  If there isn't a cached bitmap, we create one for
// the page.  The page number is the same as the item index + 1.
//
void OnDrawItem(HWND hwnd, UINT id, LPDRAWITEMSTRUCT lpdi)
{
    HWND            hwndList;
    WB_PAGE_HANDLE  hPage;
    HPALETTE        hPalette;
    HPALETTE        hOldPalette1 = NULL;
    HPALETTE        hOldPalette2 = NULL;
    HBITMAP         hBitmap = NULL;
    HBITMAP         hOldBitmap = NULL;
    HDC             hdcMem = NULL;
    HBRUSH          hbr;
    HPEN            hpen;
    TCHAR           szPageNum[8];
    COLORREF        clrOld;
    int             nMode;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnDrawItem");

    ASSERT(id == IDC_PS_THUMBNAILS);
    ASSERT(!IsBadReadPtr(lpdi, sizeof(DRAWITEMSTRUCT)));

    hwndList = ::GetDlgItem(hwnd, id);

    //
    // Is this within the proper range?
    //
    if (lpdi->itemID == -1)
    {
        WARNING_OUT(("OnDrawItem:  bogus item id"));
        goto Done;
    }

    if (g_pwbCore->WBP_PageHandleFromNumber(lpdi->itemID+1, &hPage) != 0)
    {
        ERROR_OUT(("OnDrawItem:  can't get page handle"));
        goto Done;
    }

    //
    // Account for the horizontal scroll bar; to get around whacky listbox
    // sizing bugs, we needed to fake the height out by including the scroll
    // bar in the item height.
    //
    lpdi->rcItem.bottom -= ::GetSystemMetrics(SM_CYHSCROLL);

    hdcMem = ::CreateCompatibleDC(lpdi->hDC);
    if (!hdcMem)
    {
        ERROR_OUT(("OnDrawItem:  can't create compatible dc"));
        goto Done;
    }

    //
    // Realize our palette into the DC
    //
    hPalette = PG_GetPalette();
    if (hPalette != NULL)
    {
        hOldPalette1 = ::SelectPalette(lpdi->hDC, hPalette, FALSE);
        ::RealizePalette(lpdi->hDC);

        hOldPalette2 = ::SelectPalette(hdcMem, hPalette, FALSE);
    }

    //
    // Do we have the image for this page created yet?  If not, create it
    // now.
    //
    hBitmap = (HBITMAP)lpdi->itemData;
    if (hBitmap == NULL)
    {
        hBitmap = ::CreateCompatibleBitmap(lpdi->hDC,
            RENDERED_WIDTH+2, RENDERED_HEIGHT+2);
        if (!hBitmap)
        {
            ERROR_OUT(("OnDrawItem:  can't create compatible bitmap"));
            goto Done;
        }
    }

    hOldBitmap = SelectBitmap(hdcMem, hBitmap);

    if ((HBITMAP)lpdi->itemData == NULL)
    {
        //
        // Fill the bitmap with the background color, framed so it looks
        // like a page.
        //
        hbr = SelectBrush(hdcMem, ::GetSysColorBrush(COLOR_WINDOW));
        ::Rectangle(hdcMem, 0, 0, RENDERED_WIDTH+2, RENDERED_HEIGHT+2);
        SelectBrush(hdcMem, hbr);

        //
        // Render the page
        //
        ::SaveDC(hdcMem);


        // Set the attributes to compress the whole page into a
        // thumbnail at the relevant position for the cache index.
        ::SetMapMode(hdcMem, MM_ANISOTROPIC);
        ::SetWindowExtEx(hdcMem, DRAW_WIDTH, DRAW_HEIGHT, NULL);
        ::SetViewportOrgEx(hdcMem, 1, 1, NULL);
        ::SetViewportExtEx(hdcMem, RENDERED_WIDTH, RENDERED_HEIGHT, NULL);

        // Draw the page into the cache bitmap
        ::SetStretchBltMode(hdcMem, STRETCH_DELETESCANS);
        PG_Draw(hPage, hdcMem, TRUE);

        // Restore the DC atrributes
        ::RestoreDC(hdcMem, -1);

        // Set the item data
        ::SendMessage(hwndList, LB_SETITEMDATA, lpdi->itemID, (LPARAM)hBitmap);
    }

    //
    // Fill the background with the selection or window color depending
    // on the state.
    //
    if (lpdi->itemState & ODS_SELECTED)
        ::FillRect(lpdi->hDC, &lpdi->rcItem, ::GetSysColorBrush(COLOR_HIGHLIGHT));
    else
        ::FillRect(lpdi->hDC, &lpdi->rcItem, ::GetSysColorBrush(COLOR_WINDOW));

    if (lpdi->itemState & ODS_FOCUS)
        ::DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

    //
    // Blt the page bitmap to the listbox item, centering it horizontally
    // and vertically.
    //
    ::BitBlt(lpdi->hDC,
        (lpdi->rcItem.left + lpdi->rcItem.right - (RENDERED_WIDTH + 2)) / 2,
        (lpdi->rcItem.top + lpdi->rcItem.bottom - (RENDERED_HEIGHT + 2)) / 2,
        RENDERED_WIDTH + 2, RENDERED_HEIGHT + 2,
        hdcMem, 0, 0, SRCCOPY);

    //
    // Draw number of page centered
    //
    wsprintf(szPageNum, "%d", lpdi->itemID+1);
    clrOld = ::SetTextColor(lpdi->hDC, ::GetSysColor(COLOR_GRAYTEXT));
    nMode = ::SetBkMode(lpdi->hDC, TRANSPARENT);
    ::DrawText(lpdi->hDC, szPageNum, lstrlen(szPageNum), &lpdi->rcItem,
        DT_CENTER | DT_VCENTER | DT_SINGLELINE);
    ::SetBkMode(lpdi->hDC, nMode);
    ::SetTextColor(lpdi->hDC, clrOld);


Done:
    if (hOldBitmap)
    {
        SelectBitmap(hdcMem, hOldBitmap);
    }

    if (hOldPalette2)
    {
        ::SelectPalette(hdcMem, hOldPalette2, FALSE);
    }

    if (hOldPalette1)
    {
        ::SelectPalette(lpdi->hDC, hOldPalette1, FALSE);
    }

    if (hdcMem)
    {
        ::DeleteDC(hdcMem);
    }
}



//
// OnSetCursor
// If the set is for us, handles the WM_SETCURSOR message and returns TRUE
// that we handled it, and TRUE via the window LRESULT.
//
BOOL OnSetCursor(PAGESORT * pps, HWND hwnd, UINT uiHit, UINT msg)
{
    // Check that this message is for the main window
    if (hwnd == pps->hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            ::SetCursor(pps->hCursorCurrent);
        }
        else
        {
            // Restore the cursor to the standard arrow
            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
        }

        ::SetWindowLongPtr(pps->hwnd, DWLP_MSGRESULT, TRUE);

        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


//
// OnCommand()
//
void OnCommand(PAGESORT * pps, UINT id, UINT cmd, HWND hwndCtl)
{
    switch (id)
    {
        case IDC_PS_INSERT_BEFORE:
            if (cmd == BN_CLICKED)
            {
                InsertPage(pps, INSERT_BEFORE);
            }
            break;

        case IDC_PS_INSERT_AFTER:
            if (cmd == BN_CLICKED)
            {
                InsertPage(pps, INSERT_AFTER);
            }
            break;

        case IDC_PS_GOTO:
            if (cmd == BN_CLICKED)
            {
                pps->iCurPageNo = (int)::SendDlgItemMessage(pps->hwnd,
                    IDC_PS_THUMBNAILS, LB_GETCURSEL, 0, 0) + 1;
                OnCommand(pps, IDOK, BN_CLICKED, NULL);
            }
            break;

        case IDC_PS_DELETE:
            if (cmd == BN_CLICKED)
            {
                OnDelete(pps);
            }
            break;

        case IDC_PS_THUMBNAILS:
            switch (cmd)
            {
                case LBN_DBLCLK:
                    OnCommand(pps, IDC_PS_GOTO, BN_CLICKED, NULL);
                    break;
            }
            break;

        case IDOK:
        case IDCANCEL:
            if (cmd == BN_CLICKED)
            {
                // Clear out WbMainWindow
                ASSERT(g_pMain);
                g_pMain->m_hwndPageSortDlg = NULL;

                // Get the current page
                pps->hCurPage = PG_GetPageNumber(pps->iCurPageNo);
                ::EndDialog(pps->hwnd, id);
            }
            break;
    }
}




//
// EnableButtons
// Enable (or disable) the dialog buttons appropriately
//
//
void EnableButtons(PAGESORT * pps)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::EnableButtons");

    ASSERT(!IsBadWritePtr(pps, sizeof(PAGESORT)));

    // If another user currently has a lock on the contents, disable the
    // delete and insert buttons.
    BOOL bLocked = WB_Locked();
    UINT uiCountPages = (UINT)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS,
        LB_GETCOUNT, 0, 0);

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_DELETE), (!bLocked &&
                          (uiCountPages > 1) &&
                          pps->fPageOpsAllowed));

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_INSERT_BEFORE), (!bLocked &&
                          (uiCountPages < WB_MAX_PAGES) &&
                          pps->fPageOpsAllowed));

    ::EnableWindow(::GetDlgItem(pps->hwnd, IDC_PS_INSERT_AFTER), (!bLocked &&
                         (uiCountPages < WB_MAX_PAGES) &&
                         pps->fPageOpsAllowed));
}




//
// OnDelete
// The user has clicked the Delete button
//
//
void OnDelete(PAGESORT * pps)
{
    int iResult;
    BOOL bWasPosted;
    HWND hwndList;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnDelete");

    if (!pps->fPageOpsAllowed)
        return;

    // Display a message box with the relevant question
    if (g_pMain->UsersMightLoseData( &bWasPosted, pps->hwnd ) ) // bug NM4db:418
        return;

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(pps->hwnd, IDS_DELETE_PAGE, IDS_DELETE_PAGE_MESSAGE, MB_YESNO | MB_ICONQUESTION );

    // If the user wants to continue with the delete
    if (iResult == IDYES)
    {
        UINT    uiRet;
        int iSel = (int)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);

        // Get a pointer to the current page
        WB_PAGE_HANDLE hPage = PG_GetPageNumber(iSel + 1);

        ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) > 1);

        // Ensure that we have the Page Order lock.
        if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
        {
            DefaultExceptionHandler(WBFE_RC_WB, WB_RC_LOCKED);
            return;
        }

        // Delete the page. We do not update the thumbnails yet - this
        // is done when the page deleted event is received.
        uiRet = g_pwbCore->WBP_PageDelete(hPage);
        if (uiRet != 0)
        {
            DefaultExceptionHandler(WBFE_RC_WB, uiRet);
            return;
        }

        // Show that the pages have been manipulated
        pps->fChanged = TRUE;
    }
}


//
//
// InsertPage
// Insert a new (blank) page into the Whiteboard
//
//
void InsertPage(PAGESORT * pps, UINT uiBeforeAfter)
{
    int iSel;

    MLZ_EntryOut(ZONE_FUNCTION, "InsertPage");

    if (!pps->fPageOpsAllowed)
        return;

    // Ensure that we have the Page Order lock.
    if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
        return;

    iSel = (int)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS, LB_GETCURSEL, 0, 0);

    // Add the new page to the list (throws an exception on failure)
    WB_PAGE_HANDLE hRefPage = PG_GetPageNumber(iSel + 1);
    UINT uiRet;
    WB_PAGE_HANDLE hPage;

    if (uiBeforeAfter == INSERT_BEFORE)
    {
       uiRet = g_pwbCore->WBP_PageAddBefore(hRefPage, &hPage);
    }
    else
    {
        uiRet = g_pwbCore->WBP_PageAddAfter(hRefPage, &hPage);
    }

    if (uiRet != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiRet);
        return;
    }

    // Show that the contents have been changed by the dialog
    pps->fChanged = TRUE;

    // We'll get notified in a bit when the page order has changed.
}



//
// OnPageClearInd()
// Notification passed on AFTER page has been cleared
//
void OnPageClearInd(PAGESORT * pps, WB_PAGE_HANDLE hPage)
{
    HWND    hwndList;
    int     iPageNo;
    RECT    rcItem;
    HBITMAP hbmp;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageClearInd");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    iPageNo = g_pwbCore->WBP_PageNumberFromHandle(hPage) - 1;

    // Is it in the right range?
    if ((iPageNo < 0) || (iPageNo >= ::SendMessage(hwndList, LB_GETCOUNT,
            0, 0)))
    {
        ERROR_OUT(("Bogus page number %d", iPageNo));
        return;
    }

    // Clear the item's data
    hbmp = (HBITMAP)::SendMessage(hwndList, LB_SETITEMDATA, iPageNo, 0);
    if (hbmp)
        ::DeleteBitmap(hbmp);

    // Repaint the rect
    if (::SendMessage(hwndList, LB_GETITEMRECT, iPageNo, (LPARAM)&rcItem))
    {
        ::InvalidateRect(hwndList, &rcItem, TRUE);
        ::UpdateWindow(hwndList);
    }
}


//
// OnPageDeleteInd()
// Notification passed on BEFORE page has been deleted
//
void OnPageDeleteInd(PAGESORT * pps, WB_PAGE_HANDLE hPage)
{
    HWND    hwndList;
    int     iPageNo;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageDeleteInd");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);
    iPageNo = g_pwbCore->WBP_PageNumberFromHandle(hPage) - 1;

    //
    // If this isn't in the range we know about, we don't care
    //
    if ((iPageNo < 0) || (iPageNo >= ::SendMessage(hwndList, LB_GETCOUNT, 0, 0)))
    {
        ERROR_OUT(("Bogus page number %d", iPageNo));
        return;
    }

    //
    // Delete this item from the list
    //
    ::SendMessage(hwndList, LB_DELETESTRING, iPageNo, 0);

    EnableButtons(pps);
}


//
// OnPageOrderUpdated()
//
void OnPageOrderUpdated(PAGESORT * pps)
{
    HWND    hwndList;
    int     nCount;
    int     iCurSel;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::OnPageOrderUpdated");

    hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

    // Remember the old selection
    iCurSel = (int)::SendMessage(hwndList, LB_GETCURSEL, 0, 0);

    // This is too complicated.  We're just going to wipe out all the items
    // and their bitmaps
    ::SendMessage(hwndList, WM_SETREDRAW, FALSE, 0);

    ::SendMessage(hwndList, LB_RESETCONTENT, 0, 0);
    nCount = g_pwbCore->WBP_ContentsCountPages();

    //
    // Adjust the current, and selected indeces
    //
    if (pps->iCurPageNo > nCount)
    {
        pps->iCurPageNo = nCount;
    }

    // Put back the same selected item
    if (iCurSel >= nCount)
    {
        iCurSel = nCount - 1;
    }

    // LB_SETCOUNT doesn't work on NT 4.0; must use add string
    while (nCount > 0)
    {
        ::SendMessage(hwndList, LB_ADDSTRING, 0, 0);
        nCount--;
    }

    ASSERT(::SendMessage(hwndList, LB_GETCOUNT, 0, 0) == (LRESULT)g_pwbCore->WBP_ContentsCountPages());

    ::SendMessage(hwndList, LB_SETCURSEL, iCurSel, 0);

    ::SendMessage(hwndList, WM_SETREDRAW, TRUE, 0);
    ::InvalidateRect(hwndList, NULL, TRUE);
    ::UpdateWindow(hwndList);

    EnableButtons(pps);
}



//
// OnStartDragDrop()
// This checks if the user is trying to drag & drop pages around to
// change the order via direct manipulation. We get a WM_LBTRACKPOINT
// message when someone clicks in the listbox.  We then see if they are
// dragging; if so, we tell the listbox to ignore the mouse click, and we
// ourselves capture the mouse moves.
//
void OnStartDragDrop(PAGESORT * pps, UINT iItem, int x, int y)
{
    POINT   pt;

    //
    // If no page order stuff is currently allowed, return
    //
    if (!pps->fPageOpsAllowed || WB_Locked())
    {
        WARNING_OUT(("No direct manipulation of page order allowed"));
        return;
    }

    pt.x = x;
    pt.y = y;

    if (!DragDetect(pps->hwnd, pt))
    {
        // If the mouse is no longer down, fake a button up to the listbox
        // because DragDetect() just swallowed it
        if (::GetKeyState(VK_LBUTTON) >= 0)
        {
            ::PostMessage(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS),
                WM_LBUTTONUP, MK_LBUTTON, MAKELONG(x, y));
        }
        return;
    }

    // We are dragging
    pps->fDragging = TRUE;
    pps->iPageDragging = iItem + 1;

    pps->hCursorCurrent = pps->hCursorDrag;
    ::SetCursor(pps->hCursorCurrent);
    ::SetCapture(pps->hwnd);

    // Tell the listbox to ignore the mouse-we're handling it
    // and blow off a double-click.
    ::SetWindowLongPtr(pps->hwnd, DWLP_MSGRESULT, 2);
}



//
// WhileDragging()
//
void WhileDragging(PAGESORT * pps, int x, int y)
{
    POINT   pt;
    RECT    rc;

    if (!pps->fDragging)
        return;

    pps->hCursorCurrent = pps->hCursorNoDrop;

    if (pps->fPageOpsAllowed && !WB_Locked())
    {
        //
        // Is this over the listbox client?
        //
        ::GetClientRect(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS), &rc);
        ::MapWindowPoints(::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS),
            pps->hwnd, (LPPOINT)&rc, 2);

        pt.x = x;
        pt.y = y;

        if (::PtInRect(&rc, pt))
        {
            pps->hCursorCurrent = pps->hCursorDrag;
        }
    }

    ::SetCursor(pps->hCursorCurrent);
}


//
// OnEndDragDrop
//
void OnEndDragDrop(PAGESORT * pps, BOOL fComplete, int x, int y)
{
    POINT   pt;
    RECT    rc;
    int     iItem;

    if (!pps->fDragging)
        return;

    //
    // Do this first; releasing capture will send a WM_CAPTURECHANGED
    // message.
    //
    pps->fDragging = FALSE;
    pps->hCursorCurrent = pps->hCursorNormal;
    ::SetCursor(pps->hCursorCurrent);

    // Release capture
    if (::GetCapture() == pps->hwnd)
    {
        ::ReleaseCapture();
    }

    if (fComplete && pps->fPageOpsAllowed && !WB_Locked())
    {
        HWND    hwndList;

        //
        // Is this over the listbox client?
        //
        hwndList = ::GetDlgItem(pps->hwnd, IDC_PS_THUMBNAILS);

        ::GetClientRect(hwndList, &rc);
        ::MapWindowPoints(hwndList, pps->hwnd, (LPPOINT)&rc, 2);

        pt.x = x;
        pt.y = y;

        if (::PtInRect(&rc, pt))
        {
            //
            // If there is no item at this point, use the last one
            //
            ::MapWindowPoints(pps->hwnd, hwndList, &pt, 1);

            iItem = (int)::SendMessage(hwndList, LB_ITEMFROMPOINT, 0,
                MAKELONG(pt.x, pt.y));
            if (iItem == -1)
                iItem = (int)::SendMessage(hwndList, LB_GETCOUNT, 0, 0) - 1;

            if (g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
            {
                // Move the page
                MovePage(pps, pps->iPageDragging, iItem+1);
            }
        }

    }

    pps->iPageDragging = 0;
}



//
//
// Function:    MovePage
//
// Purpose:     Move a page in the core
//
//
void MovePage(PAGESORT * pps, int iOldPageNo, int iNewPageNo)
{
    int iCountPages;

    MLZ_EntryOut(ZONE_FUNCTION, "PageSortDlgProc::MovePage");

    ASSERT(iNewPageNo > 0);
    ASSERT(iOldPageNo > 0);

    if (!pps->fPageOpsAllowed)
        return;

    // If the new page number is bigger than the number of pages, assume
    // that the last page is meant.
    iCountPages = (int)::SendDlgItemMessage(pps->hwnd, IDC_PS_THUMBNAILS, LB_GETCOUNT, 0, 0);
    if (iNewPageNo > iCountPages)
    {
        iNewPageNo = iCountPages;
    }

    // If no change will result, do nothing
    if (   (iNewPageNo != iOldPageNo)
        && (iNewPageNo != (iOldPageNo + 1)))
    {
        // If we are moving a page up the list we use move after to allow
        // the moving of a page to be the last page. If we are moving a page
        // down the list we use move before so that we can move a page to
        // be the first page.
        // it down. We check here which is meant.

        // Assume that we want to move the page up the list
        BOOL bMoveAfter = FALSE;
        if (iOldPageNo < iNewPageNo)
        {
            bMoveAfter = TRUE;
            iNewPageNo -= 1;
        }

        // Only do the move if we have requested to move the page to a new place
        if (iOldPageNo != iNewPageNo)
        {
            // get lock
            if (!g_pMain->GetLock(WB_LOCK_TYPE_CONTENTS, SW_HIDE))
                return;

            UINT uiRet;

            WB_PAGE_HANDLE hOldPage = PG_GetPageNumber((UINT) iOldPageNo);
            WB_PAGE_HANDLE hNewPage = PG_GetPageNumber((UINT) iNewPageNo);

            // Move the page
            if (bMoveAfter)
            {
                uiRet = g_pwbCore->WBP_PageMove(hNewPage, hOldPage, PAGE_AFTER);
            }
            else
            {
                uiRet = g_pwbCore->WBP_PageMove(hNewPage, hOldPage, PAGE_BEFORE);
            }

            if (uiRet != 0)
            {
                DefaultExceptionHandler(WBFE_RC_WB, uiRet);
                return;
            }

            // Show that the pages have been manipulated
            pps->fChanged = TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\twnd.hpp ===
//
// TWND.HPP
// Tool Window Class
//
// Copyright Microsoft 1998-
//
#ifndef __TWND_HPP_
#define __TWND_HPP_


//
// Our toolbar has three sections:
//      5 rows of exclusive tools 
//      SEPARATOR
//      2 rows of options
//      SEPARATOR
//      1 row of other commands (screen grabbing)
//      


#define TOOLBAR_NUMROWS			8
#define TOOLBAR_NUMSEPARATORS	2
#define TOOLBAR_NUMCOLS			2

#define TOOLBAR_FIRSTBUTTON     0
#define TOOLBAR_MAXBUTTON       18
#define TOOLBAR_LASTBUTTON      (TOOLBAR_MAXBUTTON - 1)


#define TOOLBAR_IMAGEWIDTH      16
#define TOOLBAR_IMAGEHEIGHT     15    
#define TOOLBAR_BTNEXTRA        7
#define TOOLBAR_BTNWIDTH        (TOOLBAR_IMAGEWIDTH + TOOLBAR_BTNEXTRA)
#define TOOLBAR_BTNHEIGHT       (TOOLBAR_IMAGEHEIGHT + TOOLBAR_BTNEXTRA)
#define TOOLBAR_MARGINX         (::GetSystemMetrics(SM_CXEDGE))
#define TOOLBAR_SEPARATORY      8
#define TOOLBAR_WIDTH           (2 * TOOLBAR_BTNWIDTH + 3 * TOOLBAR_MARGINX)


//
//
// Class:   WbToolBar
//
// Purpose: Define Whiteboard tool-bar window
//
//
class WbToolBar
{
public:
    //
    // Construction
    //
    WbToolBar();
    ~WbToolBar();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent);

    //
    // Button manipulation
    //
    BOOL PushDown(UINT uiId);
    BOOL PopUp(UINT uiId);

    BOOL Enable(UINT uiId);
    BOOL Disable(UINT uiId);

    //
    // Resizing functions
    //
    void    GetNaturalSize(LPSIZE lpsize);
    UINT    WidthFromHeight(UINT height);

    void    RecolorButtonImages(void);

    HWND    m_hwnd;

protected:
    HBITMAP m_hbmImages;
};


#endif // __TWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\twnd.cpp ===
//
// TWND.CPP
// ToolBar handler
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// This is the button layout for the toolbar
//
static UINT g_uToolBar[TOOLBAR_MAXBUTTON] =
{
    IDM_SELECT,
    IDM_ERASER,
    IDM_TEXT,
    IDM_HIGHLIGHT,
    IDM_PEN,
    IDM_LINE,
    IDM_BOX,
    IDM_FILLED_BOX,
    IDM_ELLIPSE,
    IDM_FILLED_ELLIPSE,
    0,
    IDM_ZOOM,
    IDM_REMOTE,
    IDM_LOCK,
    IDM_SYNC,
    0,
    IDM_GRAB_AREA,
    IDM_GRAB_WINDOW
};



//
//
// Function:    WbToolBar constructor
//
// Purpose:     Create the tool window
//
//
WbToolBar::WbToolBar()
{
    m_hwnd = NULL;
    m_hbmImages = NULL;
}


WbToolBar::~WbToolBar()
{
    if (m_hbmImages != NULL)
    {
        ::DeleteBitmap(m_hbmImages);
        m_hbmImages = NULL;
    }
}



//
//
// Function:    Create
//
// Purpose:     Create the tool window
//
//
BOOL WbToolBar::Create(HWND hwndParent)
{
    TBBUTTON    tb;
    int         iImage, i;

    //
    // Create the tool window
    //
    m_hwnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | TBSTYLE_WRAPABLE |
        CCS_NODIVIDER | CCS_NOPARENTALIGN | CCS_NOMOVEY | CCS_NORESIZE,
        0, 0, 0, 0,
        hwndParent, (HMENU)IDC_TOOLBAR, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbToolBar::Create create of window failed"));
        return(FALSE);
    }

    //
    // Tell COMCTL32 the structure size for the buttons
    //
    ::SendMessage(m_hwnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    //
    // And the margin for the buttons
    //
    ::SendMessage(m_hwnd, TB_SETINDENT, TOOLBAR_MARGINX, 0);


    //
    // Add the buttons into the toolbar
    //

    ZeroMemory(&tb, sizeof(tb));
    iImage = 0;

    for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
    {
        tb.fsState = TBSTATE_ENABLED;
        tb.idCommand = g_uToolBar[i];

        if (!tb.idCommand)
        {
            tb.fsStyle = TBSTYLE_SEP;
            tb.iBitmap = TOOLBAR_SEPARATORY;
        }
        else
        {
            tb.fsStyle = TBSTYLE_BUTTON;
            tb.iBitmap = iImage++;
        }

        if (!::SendMessage(m_hwnd, TB_ADDBUTTONS, 1, (LPARAM)&tb))
        {
            ERROR_OUT(("Failed to add button %d to toolbar", i));
            return(FALSE);
        }
    }

    //
    // Tell the toolbar the image and button sizes
    //
    ::SendMessage(m_hwnd, TB_SETBITMAPSIZE, 0,
        MAKELONG(TOOLBAR_IMAGEWIDTH, TOOLBAR_IMAGEHEIGHT));
    ::SendMessage(m_hwnd, TB_SETBUTTONSIZE, 0,
        MAKELONG(TOOLBAR_BTNWIDTH, TOOLBAR_BTNHEIGHT));

    //
    // Load the bitmap resource -- use sys color change handler
    //
    RecolorButtonImages();

    // set up rows
    ::SendMessage(m_hwnd, TB_SETROWS, MAKELPARAM(TOOLBAR_NUMROWS +
        TOOLBAR_NUMSEPARATORS, TRUE), 0);

    ::InvalidateRect(m_hwnd, NULL, TRUE);

    return(TRUE);
}



//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the tool client area
//
//
void WbToolBar::GetNaturalSize(LPSIZE lpsize)
{
    RECT rectButton;
    RECT rectButton2;

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_FIRSTBUTTON,
        (LPARAM)&rectButton))
    {
        ::SetRectEmpty(&rectButton);
    }

    if (!::SendMessage(m_hwnd, TB_GETITEMRECT, TOOLBAR_LASTBUTTON,
        (LPARAM)&rectButton2))
    {
        ::SetRectEmpty(&rectButton2);
    }

    lpsize->cx = TOOLBAR_WIDTH;
    lpsize->cy = rectButton2.bottom - rectButton.top +
        // Vertical margin
        (rectButton2.bottom - rectButton2.top);
}


//
//
// Function:    WidthFromHeight
//
// Purpose:     Calculate the width of the toolbar, given the height for
//              the fixed mode.
//
//
UINT WbToolBar::WidthFromHeight(UINT uiHeight)
{
    SIZE    size;

    GetNaturalSize(&size);
    return(size.cx);
}


//
//
// Function:    PushDown
//
// Purpose:     Push down a button in the tool window
//
//
BOOL WbToolBar::PushDown(UINT uiId)
{
    UINT butId;
    BOOL bDown;

    // If this isn't an exclusive checkable group, it's easy.
    if ((uiId < IDM_TOOLS_START) || (uiId >= IDM_TOOLS_MAX))
    {
        return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(TRUE, 0)));
    }

    // Push this one down and pop up all the others
    for (butId = IDM_TOOLS_START; butId < IDM_TOOLS_MAX; butId++)
    {
        bDown = (butId == uiId);
        ::SendMessage(m_hwnd, TB_CHECKBUTTON, butId, MAKELPARAM(bDown, 0));
    }

    return( TRUE );
}


//
//
// Function:    PopUp
//
// Purpose:     Pop up a button in the tool window
//
//
BOOL WbToolBar::PopUp(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_CHECKBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}

//
//
// Function:    Enable
//
// Purpose:     Enable a button in the tool window
//
//
BOOL WbToolBar::Enable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(TRUE, 0)));
}

//
//
// Function:    Disable
//
// Purpose:     Disable a button in the tool window
//
//
BOOL WbToolBar::Disable(UINT uiId)
{
    return (BOOL)(::SendMessage(m_hwnd, TB_ENABLEBUTTON, uiId, MAKELPARAM(FALSE, 0)));
}




void WbToolBar::RecolorButtonImages(void)
{
    // re-color bitmap for toolbar
    HBITMAP hbmNew;

    hbmNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(IDR_TOOLS),
        IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);

    if (hbmNew == NULL)
    {
        ERROR_OUT(("OnSysColorChange:  failed to load toolbar bitmap"));
    }
    else
    {
        BITMAP  bmp;

        ::GetObject(hbmNew, sizeof(bmp), &bmp);

        if (m_hbmImages == NULL)
        {
            TBADDBITMAP addBitmap;

            // First time
            addBitmap.hInst = NULL;
            addBitmap.nID   = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_ADDBITMAP,
                (bmp.bmWidth / TOOLBAR_IMAGEWIDTH), (LPARAM)&addBitmap);
        }
        else
        {
            TBREPLACEBITMAP replaceBitmap;

            replaceBitmap.hInstOld = NULL;
            replaceBitmap.nIDOld = (UINT_PTR)m_hbmImages;
            replaceBitmap.hInstNew = NULL;
            replaceBitmap.nIDNew = (UINT_PTR)hbmNew;

            ::SendMessage(m_hwnd, TB_REPLACEBITMAP, 0, (LPARAM)&replaceBitmap);
        }

        if (m_hbmImages)
        {
            ::DeleteBitmap(m_hbmImages);
        }

        m_hbmImages = hbmNew;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\txted.cpp ===
//
// TXTED.CPP
// Editor for Text Objects
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


/////////////////////////////////////////////////////////////////////////////
// WbTextBox


//
// This is a subclassed edit field
//

WbTextBox::WbTextBox(WbTextEditor * pEditor)
{
    OSVERSIONINFO OsData;

    m_hwnd = NULL;
    m_pfnEditPrev = NULL;

    m_MaxRect.left = 0;
    m_MaxRect.top = 0;
    m_MaxRect.right = INT_MAX;
    m_MaxRect.bottom = INT_MAX;

    ::SetRectEmpty(&m_rectErase);

    m_bInIME = FALSE;
    m_bDontEscapeThisTime = FALSE;

    // see if we need to make adjustments for NT.
    m_ptNTBooger.x = 0;
    m_ptNTBooger.y = 0;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // NT editboxes are offset from Win95 editboxes. We
            // have to de-booger them
            m_ptNTBooger.x = 3;
        }
    }

    m_pEditor = pEditor;
}


//
// ~WbTextBox()
//
WbTextBox::~WbTextBox()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        m_hwnd = NULL;
    }
}



//
// Create()
// Creates an edit field then subclasses it with our window procedure
//
BOOL WbTextBox::Create(HWND hwndParent)
{
    ASSERT(!m_hwnd);

    m_hwnd = ::CreateWindowEx(0, _T("EDIT"), NULL,
        WS_CHILD | WS_BORDER | ES_MULTILINE | ES_WANTRETURN |
        ES_AUTOHSCROLL | ES_AUTOVSCROLL,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
        hwndParent, NULL, g_hInstance, NULL);

    if (!m_hwnd)
    {
        ERROR_OUT(("WbTextBox::Create failed to create edit window"));
        return(FALSE);
    }

    // Init the data
    ::SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LPARAM)this);

    // Subclass the window
    m_pfnEditPrev = (WNDPROC)::SetWindowLongPtr(m_hwnd, GWLP_WNDPROC,
        (LONG_PTR)TextWndProc);

    return(TRUE);

}



//
// TextWndProc()
// Message subclass handler for edit field
//
LRESULT CALLBACK TextWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;
    WbTextBox * ptb;

    ptb = (WbTextBox *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
    ASSERT(ptb != NULL);
    ASSERT(ptb->m_pfnEditPrev != NULL);

    lResult = 0;

    switch( message )
    {
        case WM_CLEAR:
        case WM_CUT:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnClearCut();
            break;

        case WM_UNDO:
        case WM_PASTE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnUndoPaste();
            break;

        case WM_IME_STARTCOMPOSITION:
        {
            ptb->m_bInIME = TRUE;
            ptb->m_bDontEscapeThisTime = TRUE;

            // let editbox take it from here
            goto DefEditProc;
            break;
        }


        case WM_IME_CHAR:
        {
            ptb->m_bDontEscapeThisTime = FALSE;
            goto DefEditProc;
            break;
        }


        case WM_IME_ENDCOMPOSITION:
        {
            ptb->m_bInIME = FALSE;
            goto DefEditProc;
            break;
        }

        case WM_KILLFOCUS:
        {
            if (ptb->m_bInIME && g_fnImmGetContext)
            {
                HIMC hImc = g_fnImmGetContext(hwnd);
                if ((hImc != NULL) && g_fnImmNotifyIME)
                {
                    // we're loosing control, tell IME to wrap it up (bug 130)
                    g_fnImmNotifyIME( hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0 );
                }
            }
            // goto DefEditProc;
            break;
        }

        case WM_CHAR:
            ptb->OnChar((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_KEYUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnKeyUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_SYSKEYDOWN:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnSysKeyDown((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_TIMER:
            ptb->OnTimer(wParam);
            break;

        case WM_MOUSEMOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMouseMove((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnLButtonUp((UINT)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MOVE:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            ptb->OnMove(LOWORD(lParam), HIWORD(lParam));
            break;

        default:
DefEditProc:
            lResult = ::CallWindowProc(ptb->m_pfnEditPrev, hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
// OnClearCut()
//
void WbTextBox::OnClearCut()
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
    m_pEditor->m_bChanged = TRUE;

}


//
// OnUndoPaste()
//
void WbTextBox::OnUndoPaste(void)
{
    FitBox();
    AutoCaretScroll();

    m_pEditor->m_bChanged = TRUE;
}


//
// OnChar()
//
void  WbTextBox::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    int    nFirst;
    int    nLast;
    int    nPrevNumLines;
    int    nPrevNumChars;
    LRESULT dwPosChar;
    POINT  ptTop;

    // clear ignore next escape (NM4db:456)
    m_bDontEscapeThisTime = FALSE;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    dwPosChar = ::SendMessage(m_hwnd, EM_POSFROMCHAR, nFirst, 0);
    ptTop.x = (short)LOWORD(dwPosChar);
    ptTop.y = (short)HIWORD(dwPosChar);

    nPrevNumLines = (int)::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0);
    nPrevNumChars = (int)::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0);

    ::CallWindowProc(m_pfnEditPrev, m_hwnd, WM_CHAR, nChar, MAKELONG(nRepCnt, nFlags));

    SetupBackgroundRepaint( ptTop,
         (nPrevNumLines != ::SendMessage(m_hwnd, EM_GETLINECOUNT, 0, 0))||
         (nPrevNumChars > ::SendMessage(m_hwnd, EM_LINELENGTH, (WPARAM)-1, 0)));

    FitBox();

    m_pEditor->m_bChanged = TRUE;
}




void WbTextBox::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    POINT   ptCaret;
    POINT   ptPos;

    AutoCaretScroll();

    switch( nChar )
    {
        case VK_MENU:
        case VK_SHIFT:
        case VK_CONTROL:
            break;


        case VK_DELETE:
            SelectAtLeastOne();
            ::SendMessage(m_hwnd, WM_CLEAR, 0, 0);
            break;


        case VK_ESCAPE:
            if( !m_bInIME )
            {
                if( m_bDontEscapeThisTime )
                    m_bDontEscapeThisTime = FALSE;
                else
                {
                    // End the text entry abandoning the changes
                    g_pDraw->EndTextEntry(FALSE);
                    return; // we don't exist anymore, bail out
                }
            }
            break;


        default:
            break;
    }

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}





void WbTextBox::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    switch( nChar )
    {
        case VK_MENU:
            // ignore next escape (NM4db:456)
            m_bDontEscapeThisTime = TRUE;
            break;

        default:
            break;
    }
}




BOOL WbTextBox::FitBox( void )
{
    RECT rectErase;
    RECT crEditRect;
    RECT crEditBox;
    RECT crEditWnd;
    RECT crDrawWnd;
    int   nDeltaWidth, nDeltaHeight;
    HDC     hDC = NULL;
    HDC     hDrawDC = NULL;
    TCHAR *szBoxText = NULL;
    BOOL bNoChanges;
    POINT   ptDrawLoc;
    HFONT   hSaveFont = NULL;
    POINT  ptBitmapTopLeft;
    LPTSTR pszText;
    int    nTextLen;
    int textSize;

    bNoChanges = TRUE;

    hDC = ::GetDC(m_hwnd);
    if (hDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hDrawDC = g_pDraw->GetCachedDC();
    if (hDrawDC == NULL)
    {
        bNoChanges = TRUE;
        goto bail_out;
    }

    hSaveFont = SelectFont(hDC, m_pEditor->GetFont());

    textSize = ::GetWindowTextLength(m_hwnd);
    if (!textSize)
    {
        // Use a " " for a string, which is two characters.
        szBoxText = new TCHAR[2];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for empty text"));
            goto bail_out;
        }
        else
        {
            lstrcpy(szBoxText, _T(" "));
        }
    }
    else
    {
        szBoxText = new TCHAR[textSize+1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
            goto bail_out;
        }
        else
        {
            ::GetWindowText(m_hwnd, (LPTSTR)szBoxText, textSize+1);
        }
    }

    // Have to check string length for NT. crEditRect comes back from
    // DrawText    giant-positive (i.e., still equal to m_MaxRect) if szBoxText
    // is empty. This causes crEditRect to overflow to giant negative later
    // resulting in very bizare painting problems. Win95 doesn't care because
    // it returns 16bit results that look like -1 instead of giant positive.

    ::GetClientRect(g_pDraw->m_hwnd, &crDrawWnd );

    // BUG 464 -DrawText doesn't calc widths involving tabs the same way a
    //            standard edit control does so replace it with DrawTextEx
    //            using the DT_EDITCONTROL format
    crEditRect = m_MaxRect;
    pszText = szBoxText;
    nTextLen = lstrlen(szBoxText);
    ::DrawTextEx( hDC,
                  pszText, nTextLen,
                  &crEditRect,
                  DT_CALCRECT | DT_EXPANDTABS | DT_NOPREFIX | DT_EDITCONTROL,
                  NULL );

    // BUG 464 (continued) -DrawTextEx doesn't include blank-last-lines in its height
    //                        calc like DrawText does so have to add an extra line
    //                        height for blank lines to have same behavior as DrawText
    if ((nTextLen >= 2) && !IsDBCSLeadByte(pszText[nTextLen-2]) && (pszText[nTextLen-1] == _T('\n')) )
        crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    // NT sanity check if this still fails
    if ( ((crEditRect.right - crEditRect.left) == (m_MaxRect.right - m_MaxRect.left)) ||
         ((crEditRect.right - crEditRect.left) <= 0) )
    {
        crEditRect.right = crEditRect.left + crDrawWnd.right - crDrawWnd.left;
    }

    if ( ((crEditRect.bottom - crEditRect.top) == (m_MaxRect.bottom - m_MaxRect.top)) ||
         ((crEditRect.bottom - crEditRect.top) <= 0) )
    {
        crEditRect.bottom = crEditRect.top + crDrawWnd.bottom - crDrawWnd.top;
    }

    ::GetClientRect(m_hwnd, &crEditBox);
    ::GetWindowRect(m_hwnd, &crEditWnd);
    ::MapWindowPoints(NULL, g_pDraw->m_hwnd, (LPPOINT)&crEditWnd, 2);

    // do min size check for IME's.
    int nMinWidth;
    nMinWidth = MIN_FITBOX_CHARS*m_pEditor->m_textMetrics.tmMaxCharWidth;
    if ((crEditRect.right - crEditRect.left) < nMinWidth )
        crEditRect.right = crEditRect.left + nMinWidth;

    // must add some slop to prevent autoscroll from kicking in
    crEditRect.right += 2*m_pEditor->m_textMetrics.tmMaxCharWidth;
    crEditRect.bottom += m_pEditor->m_textMetrics.tmHeight;

    //pretend we had a right or bottom scroll
    ::OffsetRect(&crEditRect, -1, -1);

    nDeltaWidth = (crEditRect.right - crEditRect.left) - (crEditBox.right - crEditBox.left);
    if (nDeltaWidth > 0)
    {
        bNoChanges = FALSE;
        if ( crEditRect.left < 0 )
        {
            // right scroll, adjust right edge
            crEditWnd.right += nDeltaWidth;
        }
        else
        {
            // left scroll, adjust left edge
            crEditWnd.left -= nDeltaWidth;
        }
    }

    nDeltaHeight = (crEditRect.bottom - crEditRect.top) - (crEditBox.bottom - crEditBox.top);
    if (nDeltaHeight > 0)
    {
        bNoChanges = FALSE;
        if( crEditRect.left < 0 )
        {
            // bottom scroll, adjust bottom edge
            crEditWnd.bottom += nDeltaHeight;
        }
        else
        {
            // top scroll, adjust top edge
            crEditWnd.top -= nDeltaHeight;
        }
    }

    if( bNoChanges )
        goto bail_out;


    // resize
    ::MoveWindow(m_hwnd, crEditWnd.left, crEditWnd.top,
        crEditWnd.right - crEditWnd.left, crEditWnd.bottom - crEditWnd.top, TRUE );

    // update bounding box
    ::GetClientRect(m_hwnd, &crEditBox);
    ::MapWindowPoints(m_hwnd, g_pDraw->m_hwnd, (LPPOINT)&crEditBox, 2);

    ::OffsetRect(&crEditBox, g_pDraw->m_originOffset.cx+1 + m_ptNTBooger.x,
        g_pDraw->m_originOffset.cy + m_ptNTBooger.y );//+1 );
    m_pEditor->m_boundsRect = crEditBox;

bail_out:

    if (hDC != NULL )
    {
    	if(hSaveFont)
    	{
		   	SelectFont(hDC, hSaveFont);
    	}
        ::ReleaseDC(m_hwnd, hDC );
    }

    if(szBoxText)
    {
        delete [] szBoxText;
    }
    
    return( !bNoChanges );
}




void WbTextBox::OnTimer(UINT_PTR nIDEvent)
{
    TRACE_TIMER(("WbTextBox::OnTimer"));

    // If the text object has not been added to the page before...
    if (m_pEditor->Handle() == NULL)
    {
        // Add it now
        m_pEditor->AddToPageLast(g_pDraw->Page());
    }
    else
    {
        // Otherwise, replace the external copy
        m_pEditor->Replace();
    }
}



//
// WbTextBox::OnLButtonUp()
//
void  WbTextBox::OnLButtonUp(UINT nFlags, int x, int y)
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    m_pEditor->m_cursorXYPos.x = ptCaret.x + ptPos.x;
    m_pEditor->m_cursorXYPos.y = ptCaret.y + ptPos.y;
}




//
// WbTextBox::OnMouseMove()
//
void  WbTextBox::OnMouseMove(UINT nFlags, int x, int y)
{
    if (nFlags & MK_LBUTTON )
    {
        // we're dragging
        ::HideCaret(m_hwnd);
        AutoCaretScroll();
        ::ShowCaret(m_hwnd);
    }
}



void  WbTextBox::AutoCaretScroll( void )
{
    POINT   ptCaret;
    POINT   ptPos;

    ::GetCaretPos(&ptCaret);
    m_pEditor->GetPosition(&ptPos);

    ptCaret.x += ptPos.x;
    ptCaret.y += ptPos.y;

    g_pDraw->AutoScroll(ptCaret.x, ptCaret.y, FALSE, m_pEditor->m_cursorXYPos.x,
        m_pEditor->m_cursorXYPos.y);
    m_pEditor->m_cursorXYPos = ptCaret;
}



void WbTextBox::SetupBackgroundRepaint
(
    POINT   ptTopPaint,
    BOOL    bNumLinesChanged
)
{
    RECT    rectBox;

    ::GetClientRect(m_hwnd, &rectBox);

    if (ptTopPaint.y == -1)
    {
        ::GetCaretPos(&ptTopPaint);
    }

    rectBox.top = ptTopPaint.y;
    if( !bNumLinesChanged )
        rectBox.bottom = rectBox.top + m_pEditor->m_textMetrics.tmHeight;

    ::InvalidateRect(m_hwnd, &rectBox, TRUE );
}



//
// Selects at least one (DBCS) char if there is not a selection already.
//
void WbTextBox::SelectAtLeastOne( void )
{
    int nFirst, nLast;
    TCHAR * szBoxText;

    ::SendMessage(m_hwnd, EM_GETSEL, (WPARAM)&nFirst, (LPARAM)&nLast);
    if( nFirst == nLast )
    {
        int textSize = ::GetWindowTextLength(m_hwnd);
        szBoxText = new TCHAR[textSize + 1];
        if (!szBoxText)
        {
            ERROR_OUT(("Failed to allocate TCHAR array for object text"));
        }
        else
        {
            ::GetWindowText( m_hwnd, szBoxText, textSize+1);

            if (nFirst < textSize)
            {
                nLast++;

                if( IsDBCSLeadByte( (BYTE) szBoxText[ nFirst ] )||
                    (szBoxText[ nFirst ] == _T('\r'))
                    )
                    nLast++;

                ::SendMessage(m_hwnd, EM_SETSEL, nFirst, nLast);
            }

            delete [] szBoxText;
        }
    }
}



void WbTextBox::OnMove(int x, int y)
{
    if (m_pEditor->m_nLastShow == SW_SHOW)
    {
        FitBox();
        ::ShowCaret(m_hwnd);
    }
}


int WbTextBox::GetMaxCharHeight( void )
{
    return( m_pEditor->m_textMetrics.tmHeight );
}




int WbTextBox::GetMaxCharWidth( void )
{
    return( m_pEditor->m_textMetrics.tmMaxCharWidth );
}




//
// Aborts and shuts down text editor without hitting the cores.  Call this
// to shutdown editing during a lock condition (that we don't own)
//
void WbTextBox::AbortEditGently( void )
{
    RECT           boundsRect;

    // have to be carefull how we bail out of this so we
    // don't fall into an infinte exception loop (bugs 3550, 3556)
    if (g_pDraw->m_pActiveText != NULL)
    {
        delete g_pDraw->m_pActiveText;    // zap in memory original
        g_pDraw->m_pActiveText = NULL;  //  text object, loose any current
                                    //  edits
    }

    //
    //  NOTE:
    //      Can't reread the text object from cores to update
    //      boundsrect because the code that does that
    //      (DCWbGraphic::ReadExternal()) tries to lock
    //      the object and off we go into another exception
    //      loop. SO, the boundsrect we use below might
    //      not be the right size and the text might
    //      appear to be clipped when we redraw it. This
    //      will correct itself as soon as another graphic
    //      update notice comes in from DCL (the lock owner
    //      types another char). I think we have to live
    //      with that.
    //

    m_pEditor->GetBoundsRect(&boundsRect);

    // let go of core text object (see above)
    // don't unlock if handle is NULL or we will blow up the cores (bug 4621)
    if (g_pDraw->m_textEditor.Handle() != NULL )
    {
        if (g_pDraw->m_textEditor.GotLock() )
        {
            g_pDraw->m_textEditor.Unlock();
            g_pDraw->m_textEditor.ForceUpdate();
        }
    }

    g_pDraw->m_textEditor.ZapHandle();

    // shut down rejecting all edits
    g_pDraw->EndTextEntry(FALSE);

    // Redraw any altered parts of the screen
    g_pDraw->InvalidateSurfaceRect(&boundsRect);
}



//
//
// Function:    WbTextEditor
//
// Purpose:     Constructor
//
//
WbTextEditor::WbTextEditor(void)
{
    // Initialize the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // set parent for editbox
    m_pEditBox = NULL;

    m_cursorXYPos.x = 0;
    m_cursorXYPos.y = 0;

    m_bFirstSetFontCall = TRUE;
    m_nLastShow = -1;
}


WbTextEditor::~WbTextEditor(void)
{
    if (m_pEditBox != NULL)
    {
        delete m_pEditBox;
        m_pEditBox = NULL;
    }
}


//
//
// Function:    SetCursorPosFromPoint
//
// Purpose:     Return the character position most closely matching a
//              given co-ordinate position in the text object.
//
//
void WbTextEditor::SetCursorPosFromPoint(POINT pointXY)
{
    int    nCharPos;

    if (::PtInRect(&m_boundsRect, pointXY))
    {
        // make point relative to editbox
        pointXY.x -= g_pDraw->m_originOffset.cx;
        pointXY.y -= g_pDraw->m_originOffset.cy;

        ::MapWindowPoints(g_pDraw->m_hwnd, m_pEditBox->m_hwnd,
            &pointXY, 1);

        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONDOWN, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );
        ::SendMessage(m_pEditBox->m_hwnd, WM_LBUTTONUP, 0,
                               MAKELONG( pointXY.x, pointXY.y ) );


        // get char index in editbox
        nCharPos = (int)::SendMessage(m_pEditBox->m_hwnd, EM_CHARFROMPOS, 0,
            MAKELPARAM(pointXY.x, pointXY.y));
        if( nCharPos < 0 )
            return;

        // Set the new cursor char co-ordinates
        m_cursorCharPos.x = (short)LOWORD(nCharPos);
        m_cursorCharPos.y = (short)HIWORD(nCharPos);

        // Move the cursor to the new position
        GetXYPosition(m_cursorCharPos, &m_cursorXYPos);
    }
}

//
//
// Function:    GetCursorSize
//
// Purpose:     Return the cursor size for the current font
//
//
void WbTextEditor::GetCursorSize(LPSIZE lpsize)
{
    lpsize->cx = ::GetSystemMetrics(SM_CXBORDER);
    lpsize->cy = m_textMetrics.tmHeight;
}

//
//
// Function:    XYPosition
//
// Purpose:     Calculate the X,Y co-ordinates of a character position
//
//
void WbTextEditor::GetXYPosition(POINT pointChar, LPPOINT lpptXY)
{
    int     nCharIndex;
    LRESULT dwCharPos;

    nCharIndex = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, pointChar.y, 0)
        + pointChar.x;

    GetPosition(lpptXY);

    dwCharPos = ::SendMessage(m_pEditBox->m_hwnd, EM_POSFROMCHAR, nCharIndex, 0);

    lpptXY->x += (short)LOWORD(dwCharPos);
    lpptXY->y += (short)HIWORD(dwCharPos);
}



//
//
// Function:    Clear
//
// Purpose:     Clear the text editor
//
//
void WbTextEditor::Clear(void)
{
    RECT cEWndRect;

    // Remove all the current stored text
    strTextArray.RemoveAll();
    strTextArray.Add(_TEXT(""));

    // Reset the cursor position
    m_cursorCharPos.x = 0;
    m_cursorCharPos.y = 0;

    // clear editbox
    ::SetWindowText(m_pEditBox->m_hwnd, _TEXT(""));

    // Show that the text has not been changed
    m_bChanged = FALSE;

    // init editbox size
    m_boundsRect.right = m_boundsRect.left + 2*m_pEditBox->GetMaxCharWidth();
    m_boundsRect.bottom = m_boundsRect.top + 2*m_pEditBox->GetMaxCharHeight();

    cEWndRect = m_boundsRect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}

//
//
// Function:    New
//
// Purpose:     Clear the text editor and reset the graphic handle
//
//
BOOL WbTextEditor::New(void)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    // Clear the object
    Clear();

    // Show that the text has not been changed
    m_bChanged = FALSE;

    // Reset the graphic and page handles
    m_hGraphic = NULL;
    m_hPage = WB_PAGE_HANDLE_NULL;

    return(TRUE);
}


//
//
// Function:    SetTextObject
//
// Purpose:     Attach a text object to the editor
//
//
BOOL WbTextEditor::SetTextObject(DCWbGraphicText* ptext)
{
    // create editbox
    if (!Create())
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }


    // Clear and place the object
    Clear();

    // setup font
    DCWbGraphicText::SetFont( ptext->m_hFont );

    // Copy the text object's attributes to the editor
    SetText(ptext->strTextArray );
    ptext->GetBoundsRect(&m_boundsRect);

    SetColor(ptext->m_clrPenColor );

    MoveTo(m_boundsRect.left, m_boundsRect.top); // avoid kerning offset correction in Position()(bug 469)

    // Copy the page and handle of the graphic text object
    m_hPage    = ptext->m_hPage;
    m_hGraphic = ptext->m_hGraphic;

    // copy the text to the editbox
    GetText();

    // Say the text has changed so that all nodes will notice this thing
    // is locked - bug 2185
    m_bChanged = TRUE;

    return(TRUE);
}


//
//
// Function:    IsEmpty
//
// Purpose:     Return TRUE if there is no text in the object
//
//
BOOL WbTextEditor::IsEmpty(void)
{
    return(::GetWindowTextLength(m_pEditBox->m_hwnd) <= 0 );
}



void WbTextEditor::PutText(void)
{
    int nNumLines;
    int i;
    int nMaxLineLen, nLineLen;
    int nLine;
    TCHAR *cbuf;
    WbTextEditor *pThis;

    pThis = (WbTextEditor *)this; // overide const declaration

	if(m_pEditBox == NULL)
	{
		return;
	}

    nNumLines = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINECOUNT, 0, 0);

    // figure out buf size
    nMaxLineLen = 0;
    for (i = 0; i < nNumLines; i++)
    {
        nLine = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINEINDEX, i, 0);
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_LINELENGTH, nLine, 0);

        if (nMaxLineLen < nLineLen)
            nMaxLineLen = nLineLen;
    }

    // make buf
    nMaxLineLen += sizeof(WORD);
    cbuf = new TCHAR[nMaxLineLen];
    if( cbuf == NULL )
    {
        ERROR_OUT(("PutText failing; couldn't allocate TCHAR array"));
        return;
    }

    //
    // copy editbox innards to textbox string
    // Again, we know in advance how many lines; use SetSize/SetAt()
    //
    strTextArray.RemoveAll();
    strTextArray.SetSize(nNumLines);

    for(i = 0; i < nNumLines; i++)
    {
        *(LPWORD)cbuf = (WORD)nMaxLineLen;
        nLineLen = (int)::SendMessage(m_pEditBox->m_hwnd, EM_GETLINE, i, (LPARAM)cbuf);
        cbuf[nLineLen] = _T('\0');
        strTextArray.SetAt(i, cbuf );
    }

    // clean up
    delete [] cbuf;
}




void WbTextEditor::GetText(void)
{
    int nNumLines;
    int textSize = 0;
    int i;
    TCHAR * pText = NULL;
    TCHAR * pStartText;

    nNumLines = strTextArray.GetSize();

    //
    // Calculate the buffer size we need
    //
    for (i = 0; i < nNumLines; i++ )
    {
        textSize += lstrlen(strTextArray[i]);

        if ((i + 1) < nNumLines)
            textSize += lstrlen(_T("\r\n"));
    }

    //
    // Get the lines, with \r\n separating them
    //
    pText = new TCHAR[textSize + 1];
    if (!pText)
    {
        ERROR_OUT(("GetText failing; couldn't allocate TCHAR array"));
    }
    else
    {
        // Null this out in casae textSize is 0.
        pStartText = pText;
        pStartText[0] = 0;

        for (i = 0; i < nNumLines; i++)
        {
            lstrcpy(pStartText, strTextArray[i]);
            pStartText += lstrlen(strTextArray[i]);

            if ((i + 1) < nNumLines)
            {
                lstrcpy(pStartText, _T("\r\n"));
                pStartText += lstrlen(_T("\r\n"));
            }
        }

        ::SetWindowText(m_pEditBox->m_hwnd, pText);
        delete []pText;
    }
}




DWORD WbTextEditor::CalculateExternalLength( void )
{

    // stick text in underlying text object
    if( m_bChanged )
        PutText();

    // fix bounds to get rid off editbox slop
    ((WbTextEditor *)this)->DCWbGraphicText::CalculateBoundsRect();

    // tell textbox to use it in length calculation
    return( DCWbGraphicText::CalculateExternalLength() );
}




void WbTextEditor::CalculateBoundsRect( void )
{
    RECT    cEWndRect;

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);
    ::MapWindowPoints(m_pEditBox->m_hwnd, g_pDraw->m_hwnd,
        (LPPOINT)&cEWndRect, 2);

    m_boundsRect = cEWndRect;
    ::OffsetRect(&m_boundsRect, g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x,
                           g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y);//+1 );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
}




// set editbox visibility
void WbTextEditor::ShowBox( int nShow )
{
    if (m_nLastShow == nShow)
    {
        if( nShow == SW_SHOW)
            ::SetFocus(m_pEditBox->m_hwnd);

        return;
    }

    m_nLastShow = nShow;

    if (nShow == SW_SHOW)
    {
        // show it
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_SHOW);
            ::BringWindowToTop(m_pEditBox->m_hwnd);
            ::SetFocus(m_pEditBox->m_hwnd);

            ::HideCaret(m_pEditBox->m_hwnd);
            m_pEditBox->FitBox();
            ::ShowCaret(m_pEditBox->m_hwnd);
        }
    }
    else
    {
        if (m_pEditBox != NULL)
        {
            ::ShowWindow(m_pEditBox->m_hwnd, SW_HIDE);
            m_bFirstSetFontCall = TRUE;

            delete m_pEditBox;
            m_pEditBox = NULL;
        }
    }
}



//
// Create()
//
// Creates the edit box window
//
BOOL WbTextEditor::Create( void )
{
    if (m_pEditBox == NULL)
    {
        m_pEditBox = new WbTextBox(this);
        if (m_pEditBox == NULL)
        {
            ERROR_OUT(("Couldn't create edit text box"));
            return(FALSE);
        }

        if (!m_pEditBox->Create(g_pDraw->m_hwnd))
        {
            ERROR_OUT(("WbTextEditor::Create failed; can't create edit field"));
            return(FALSE);
        }
    }

    return(TRUE);
}




void WbTextEditor::MoveBy(int cx, int cy)
{
    RECT cEWndRect;

    DCWbGraphicText::MoveBy(cx, cy);

    ::GetClientRect(m_pEditBox->m_hwnd, &cEWndRect);

    if ((m_boundsRect.right - m_boundsRect.left) < (cEWndRect.right - cEWndRect.left))
        m_boundsRect.right = m_boundsRect.left + (cEWndRect.right - cEWndRect.left);

    if ((m_boundsRect.bottom - m_boundsRect.top) < (cEWndRect.bottom - cEWndRect.top))
        m_boundsRect.bottom = m_boundsRect.top + (cEWndRect.bottom - cEWndRect.top);

    cEWndRect = m_boundsRect;
    ::OffsetRect(&cEWndRect, -(g_pDraw->m_originOffset.cx+1 + m_pEditBox->m_ptNTBooger.x),
                          -(g_pDraw->m_originOffset.cy + m_pEditBox->m_ptNTBooger.y) );//+1) );

    ::BringWindowToTop(m_pEditBox->m_hwnd);
    ::MoveWindow(m_pEditBox->m_hwnd, cEWndRect.left, cEWndRect.top,
        cEWndRect.right - cEWndRect.left, cEWndRect.bottom - cEWndRect.top,
        TRUE);
}




void WbTextEditor::SetFont( LOGFONT *pLogFont, BOOL bDummy )
{
    // Ignore bDummy. Had to add that so polymorph will work correctly
    // for DCWbGraphicText::SetFont()

    // Have to delay recalc of bounding rect because editbox will have a
    // bogus (bad) font until SetFont is called. Can't call SetFont
    // before this because new font hasn't been made yet.
    DCWbGraphicText::SetFont( pLogFont, FALSE );

    ::SendMessage(m_pEditBox->m_hwnd, WM_SETFONT, (WPARAM)m_hFont, TRUE);

    // now do bounding rect
    CalculateBoundsRect();

    if( m_bFirstSetFontCall )
        m_bFirstSetFontCall = FALSE;
    else
    {
        ::HideCaret(m_pEditBox->m_hwnd);

        m_pEditBox->FitBox();
        m_pEditBox->AutoCaretScroll();

        ::ShowCaret(m_pEditBox->m_hwnd);
    }
}



void WbTextEditor::WriteExtra( PWB_GRAPHIC pHeader )
{
    PutText();

    DCWbGraphicText::WriteExtra( pHeader );
}




void WbTextEditor::SetTimer( UINT nElapse )
{
    ::SetTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE, nElapse, NULL);
}



void WbTextEditor::KillTimer( void )
{
    ::KillTimer(m_pEditBox->m_hwnd, TIMER_GRAPHIC_UPDATE);
}




// Resets editbox painting for a resized drawing window
void WbTextEditor::ParentResize( void )
{
    ::HideCaret(m_pEditBox->m_hwnd);
    m_pEditBox->FitBox();
    ::ShowCaret(m_pEditBox->m_hwnd);
}




void WbTextEditor::RedrawEditbox(void)
{
    ::InvalidateRect(m_pEditBox->m_hwnd, NULL, TRUE);
    m_pEditBox->FitBox();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\tool.hpp ===
//
// TOOL.HPP
// Tool Classes
//
// Copyright Microsoft 1998-
//
#ifndef __TOOL_HPP_
#define __TOOL_HPP_


class DCWbGraphic;


//
// Tool types
//
#define TOOLTYPE_FIRST  0
enum
{
    TOOLTYPE_SELECT = TOOLTYPE_FIRST,
    TOOLTYPE_ERASER,
    TOOLTYPE_TEXT,
    TOOLTYPE_HIGHLIGHT,
    TOOLTYPE_PEN,
    TOOLTYPE_LINE,
    TOOLTYPE_BOX,
    TOOLTYPE_FILLEDBOX,
    TOOLTYPE_ELLIPSE,
    TOOLTYPE_FILLEDELLIPSE,

    // This must come last
    TOOLTYPE_MAX
}; 


#define TOOL_CMD(index)     ((index) + IDM_TOOLS_START)
#define TOOL_INDEX(cmd)     ((cmd) - IDM_TOOLS_START)
#define TOOL_COUNT          TOOL_INDEX(IDM_TOOLS_MAX)


#define DEF_PENCOLOR        RGB(0, 0, 0)
#define DEF_HIGHLIGHTCOLOR  RGB(255, 255, 0)

#define NUM_OF_WIDTHS       4



BOOL InitToolArray(void);
void DestroyToolArray(void);


//
//
// Class:   WbTool
//
// Purpose: Base Tool class
//
//
class WbTool
{
public:
    //
    // Constructors
    //
    WbTool(int toolType);
    ~WbTool();

    //
    // Return the type of the tool
    //
    virtual int ToolType(void) const { return m_toolType; }

    //
    // Return whether the tool supports various attributes
    //
    virtual BOOL HasColor(void) const;        // Tool supports colors
    virtual BOOL HasWidth(void) const;        // Tool supports widths
    virtual BOOL HasFont(void) const;         // Tool supports font

    //
    // Return the handle of the cursor for the tool
    //
    virtual HCURSOR GetCursorForTool(void) const;

    //
    // Get/set the tool attributes
    //
    UINT GetWidthAtIndex(UINT uiIndex) const
                               { return m_uiWidths[uiIndex]; }
    VOID SetWidthAtIndex(UINT uiIndex, UINT uiWidth)
                               { m_uiWidths[uiIndex] = uiWidth; }
    void SetWidthIndex(UINT uiWidthIndex)
                   { m_uiWidthIndexCur = uiWidthIndex; }

    void SetFont(HFONT hFont);
    void DeselectGraphic(void) { m_selectedTool = TOOLTYPE_MAX; }
    void SelectGraphic(DCWbGraphic* pGraphic);

    //
    // Return the pen attributes
    //
    COLORREF GetColor(void) const { return m_clrCur; }
    void     SetColor(COLORREF clr) { m_clrCur = clr; }
    UINT     GetWidth(void) const { return m_uiWidths[m_uiWidthIndexCur]; }
    UINT     GetWidthIndex(void) const { return m_uiWidthIndexCur; }
    int      GetROP(void) const;
    HFONT    GetFont(void) { return(m_hFont); }


protected:
    //
    // Tool type
    //
    int         m_toolType;
    int         m_selectedTool;

    //
    // Tool attributes
    //
    COLORREF    m_clrCur;
    UINT        m_uiWidths[NUM_OF_WIDTHS];
    UINT        m_uiWidthIndexCur;
    HFONT       m_hFont;
};


#endif // __TOOL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\user.hpp ===
//
// USER.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __USER_HPP_
#define __USER_HPP_


//
//
// Class:   WbUser
//
// Purpose: User object recorder
//
//
class DCWbGraphicPointer;

class WbUser
{
public:
    //
    // Destructor
    //
    ~WbUser(void);

    //
    // Initialize
    //
    BOOL Init(POM_OBJECT hUser);

    //
    // Return the user handle
    //
    POM_OBJECT Handle(void) const { return(m_hUser);}

    //
    // Refresh the user details
    //
    void Refresh(void);

    //
    // Update the external copy of the user information
    //
    void Update(void);

    //
    // Return the user name
    //
    LPCSTR Name(void) const { return(m_strName); }

    //
    // Synchronize the users page with other synced users
    //
    void Sync(void);
    void Unsync(void);

    //
    // Update the user's position from the sync position. This does not
    // change the sync position.
    //
    void GetSyncPosition(void);

    //
    // Update the sync position from the user's current position
    //
    void PutSyncPosition(void);

    //
    // Return a remote pointer object for this user
    //
    DCWbGraphicPointer* GetPointer(void) { return(m_pRemotePointer); }

    //
    // Put the user's remote pointer at the position specified
    //
    void PutPointer(WB_PAGE_HANDLE hPage, POINT point);

    //
    // Remove the user's remote pointer
    //
    void RemovePointer(void);

    //
    // Return TRUE if the user is synced
    //
    BOOL IsSynced(void) const { return m_bSynced; }

    //
    // Return TRUE if the user has the contents lock
    //
    BOOL HasContentsLock(void) const;

    //
    // Return TRUE if the user has their remote pointer active
    //
    BOOL IsUsingPointer(void) const;

    //
    // Return the current page of the user
    //
    WB_PAGE_HANDLE Page(void) const {return m_hPageCurrent; }
    void SetPage(WB_PAGE_HANDLE hPage);

    //
    // Return the current position within the page of the user
    //
    void  GetVisibleRect(LPRECT lprc) { *lprc = m_rectVisible; }
    void  SetVisibleRect(LPCRECT lprc);

    //
    // Return the page of the user's pointer
    //
    WB_PAGE_HANDLE PointerPage(void) const;

    //
    // Return the position of the user's pointer
    //
    void GetPointerPosition(LPPOINT lpptPos);

    //
    // Return the user's color
    //
    COLORREF Color(void) const { return(m_color); }

    //
    // Return TRUE if this is the local user
    //
    BOOL IsLocalUser(void) const { return(m_bLocalUser); }

    //
    // Operators
    //
    virtual WbUser& operator=(const WbUser& user);
    virtual BOOL operator!=(const WbUser& user) const;
    virtual BOOL operator==(const WbUser& user) const;

    //
    // Set zoom/unzoom state
    //
    void Zoom(void) { m_zoomed = TRUE; }
    void Unzoom(void) { m_zoomed = FALSE; }
    BOOL GetZoom(void) const { return(m_zoomed); }

protected:
    //
    // Core access handle
    //
    POM_OBJECT  m_hUser;

    //
    // Flag indicating Whether this is the local user
    //
    BOOL        m_bLocalUser;

    BOOL        m_zoomed;

    //
    // Local copies of the user information
    //
    char        m_strName[TSHR_MAX_PERSON_NAME_LEN];
    BOOL        m_bSynced;
    WB_PAGE_HANDLE  m_hPageCurrent;
    RECT        m_rectVisible;
    COLORREF    m_color;

    //
    // Graphic pointer associated with this user
    //
    DCWbGraphicPointer* m_pRemotePointer;
};


//
//
// Class:   WbUserList
//
// Purpose: Map from user handles to user object pointers
//
//
class WbUserList : public COBLIST
{
public:

    //
    // Destructor
    //
    ~WbUserList(void);

    //
    // Clear all entries from the map, deleting the associated object
    //
    void Clear(void);
};



//
// Return lock status
//
BOOL WB_Locked(void);
BOOL WB_ContentsLocked(void);
BOOL WB_GotLock(void);
BOOL WB_GotContentsLock(void);
BOOL WB_PresentationMode(void);



//
// Return an object representing the local user
//
WbUser* WB_LocalUser(void);

//
// Retrieving users
//
WbUser* WB_GetUser(POM_OBJECT hUser);
WbUser* WB_GetFirstUser(void);
WbUser* WB_GetNextUser(const WbUser* pUser);

//
// Return an object representing the user who has the lock
//
WbUser* WB_LockUser(void);




#endif // __USER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\txted.hpp ===
//
// TXTED.HPP
// Text Object Editor
//
// Copyright Microsoft 1998-
//
#ifndef __TXTED_HPP_
#define __TXTED_HPP_



#define MIN_IME_WINDOW    30

#define MIN_FITBOX_CHARS 6

class WbTextEditor;

/////////////////////////////////////////////////////////////////////////////
// WbTextBox window

class WbTextBox
{
public:
	WbTextBox(WbTextEditor * pEditor);
    ~WbTextBox();

    BOOL Create(HWND hwndParent);

	BOOL FitBox( void );

	void AutoCaretScroll( void );

	int	GetMaxCharHeight( void );

	int	GetMaxCharWidth( void );

	void AbortEditGently( void );

    HWND    m_hwnd;
	POINT   m_ptNTBooger;

    friend LRESULT CALLBACK TextWndProc(HWND, UINT, WPARAM, LPARAM);

    WNDPROC m_pfnEditPrev;

protected:
    RECT    m_MaxRect;
	WbTextEditor *m_pEditor;
	RECT     m_rectErase;
	BOOL	 m_bInIME;
	BOOL	 m_bDontEscapeThisTime;

	void SetupBackgroundRepaint( POINT ptTopPaint, BOOL bNumLinesChanged=TRUE );
	void SelectAtLeastOne( void );

    void    OnClearCut(void);
    void    OnUndoPaste(void);
	void    OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	void    OnTimer(UINT_PTR nIDEvent);
	void    OnLButtonUp(UINT nFlags, int x, int y);
	void    OnMouseMove(UINT nFlags, int x, int y);
    void    OnMove(int x, int y);
	void    OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
};

/////////////////////////////////////////////////////////////////////////////


//
//
// Class:   WbTextEditor
//
// Purpose: Allow editing of the text in a DCWbGraphicText object
//
//
class WbTextEditor : public DCWbGraphicText
{
	friend class WbTextBox;
    friend class WbDrawingArea;
	
	public:
    //
    // Constructor
    //
    WbTextEditor(void);
   ~WbTextEditor(void);

    // writes text to underlying text object before relaying to text object
    DWORD CalculateExternalLength(void);

	// calcs bounds rect and sets editbox to new size
    void CalculateBoundsRect(void);

    void WriteExtra( PWB_GRAPHIC pHeader );

	void SetTimer( UINT nElapse );
	void KillTimer( void );

	// set editbox visibility
	void ShowBox( int nShow );

	BOOL Create( void );

	// Moves underlying text object and then moves editbox rect
    void MoveBy(int cx, int cy);

	void RedrawEditbox(void);

	// resets editbox for parent resizing
	void ParentResize( void );

	// clipboard
	void Copy( void )
		{ ::SendMessage(m_pEditBox->m_hwnd, WM_COPY, 0, 0); }

	void Cut( void )
        { ::SendMessage(m_pEditBox->m_hwnd, WM_CUT, 0, 0); }

	void Paste( void )
        { ::SendMessage(m_pEditBox->m_hwnd, WM_PASTE, 0, 0); }

    virtual void SetFont( LOGFONT *pLogFont, BOOL bDummy=TRUE );
    virtual void SetFont(HFONT hFont) { DCWbGraphicText::SetFont(hFont); }

    //
    // Attach a text object to the editor.  This function copies the
    // contents of the specified text object into the text editor.  The
    // editor will not alter the contents of the object passed and does not
    // keep a copy of the pointer parameter.
    //
    BOOL SetTextObject(DCWbGraphicText * ptext);

    //
    // Return the width and height for the cursor in pixels as a size
    //
    void GetCursorSize(LPSIZE lpsize);

    //
    // Set the current edit cursor position from a point specified in
    // logical co-ordinates.  This function does nothing if the point
    // specified is outside the bounding rectangle of the object being
    // edited.  If the point specified is within the bounding rectangle the
    // current edit cursor position is updated to a point as close as
    // possible to that passed as parameter.
    //
    void SetCursorPosFromPoint(POINT pointXY);

    void Clear(void);                // Delete all text
    BOOL New(void);                  // Delete text and reset handles

    //
    // Return TRUE if there is not text in the object
    //
    BOOL IsEmpty(void);

	void AbortEditGently( void )
		{m_pEditBox->AbortEditGently();}


protected:
    //
    // Pixel position from a character position
    //
    void GetXYPosition(POINT pointChar, LPPOINT lpptGet);

    //
    // Current cursor position.  Note that cursorCharPos.x gives the BYTE
    // position of the cursor rather than the character position.  On SBCS
    // systems the character and byte positions will always be the same,
    // but on DBCS systems the number of bytes in a string can be greater
    // than the number of characters.
    //
    // cursorCharPos.x should NEVER be set to a byte count which is in the
    // middle of a double byte character.
    //
    POINT   m_cursorCharPos;
    POINT   m_cursorXYPos;

	WbTextBox *m_pEditBox;
	int	 m_nLastShow;
	void PutText(void);
	void GetText(void);
};


#endif // __TXTED_HPP_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\tool.cpp ===
//
// TOOL.CPP
// Drawing Tools
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"




//
//
// Function:    WbTool
//
// Purpose:     Constructors for tools
//
//
WbTool::WbTool(int toolType)
{
    COLORREF    defColor;
    UINT        defWidth;
    int         iIndex;

    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::WbTool");


    // Save the tool type
    m_toolType = toolType;
    m_selectedTool = TOOLTYPE_MAX;

    m_uiWidthIndexCur = 0;

    // Read the colors of the pen
    if (toolType == TOOLTYPE_HIGHLIGHT)
        defColor = DEF_HIGHLIGHTCOLOR;
    else
        defColor = DEF_PENCOLOR;
    m_clrCur = defColor;

    for (iIndex = 0; iIndex < NUM_OF_WIDTHS; iIndex++)
    {
        defWidth = (toolType == TOOLTYPE_HIGHLIGHT) ?
            g_HighlightWidths[iIndex] :
            g_PenWidths[iIndex];

        m_uiWidths[iIndex] = defWidth;
    }

    // Read the font details
    LOGFONT lfont;

    ::GetObject(::GetStockObject(DEFAULT_GUI_FONT), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;
    lfont.lfCharSet = DEFAULT_CHARSET;
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
// WbTool::~WbTool
// Destructor
//
WbTool::~WbTool()
{
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
        m_hFont = NULL;
    }
}



//
//
// Function:    HasColor
//
// Purpose:     Return TRUE if the tool supports colors
//
//
BOOL WbTool::HasColor(void) const
{
    BOOL bResult = TRUE;

    switch (m_toolType)
    {
        case TOOLTYPE_ERASER:
            bResult = FALSE;
            break;
    }

    return bResult;
}


//
//
// Function:    HasWidth
//
// Purpose:     Return TRUE if the tool supports widths
//
//
BOOL WbTool::HasWidth(void) const
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_PEN:
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_ELLIPSE:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_PEN:
                {
                    DCWbGraphic * pGraphic;

                    ASSERT(g_pDraw);
                    pGraphic = g_pDraw->GetSelection();
                    if ((pGraphic != NULL) &&
                        !(pGraphic->IsGraphicTool() == enumGraphicFilledRectangle) &&
                        !(pGraphic->IsGraphicTool() == enumGraphicFilledEllipse))
                    {
                        bResult = TRUE;
                    }
                    break;
                }
            }
            break;

        default:
            // The rest don't support widths, including filled tools
            break;
    }

    return bResult;
}


//
//
// Function:    HasFont
//
// Purpose:     Return TRUE if the tool supports fonts
//
//
BOOL WbTool::HasFont(void) const
{
    BOOL bResult = FALSE;

    switch (m_toolType)
    {
        case TOOLTYPE_TEXT:
            bResult = TRUE;
            break;

        // For the selector tool, it depends on the selected object type
        case TOOLTYPE_SELECT:
            switch (m_selectedTool)
            {
                case TOOLTYPE_TEXT:
                    bResult = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default:
            // The other tools do not support fonts
            break;
    }

    return bResult;
}

//
//
// Function:    GetROP
//
// Purpose:     Return the ROP for this tool
//
//
int WbTool::GetROP(void) const
{
    // If this is a highlight tool we use MASKPEN, else we use the standard
    if (m_toolType == TOOLTYPE_HIGHLIGHT)
        return(R2_MASKPEN);
    else
        return(R2_COPYPEN);
}


//
//
// Function:    GetCursorForTool
//
// Purpose:     Return the handle to the cursor for the tool
//
//
HCURSOR WbTool::GetCursorForTool(void) const
{
    int   nName = -1;

    switch(m_toolType)
    {
        case TOOLTYPE_SELECT:
            break; // use default arrow for select cursor (bug 439)

        case TOOLTYPE_PEN:
            nName = PENFREEHANDCURSOR;
            break;

        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            nName = PENCURSOR;
            break;

        case TOOLTYPE_HIGHLIGHT:
            nName = HIGHLIGHTFREEHANDCURSOR;
            break;

        case TOOLTYPE_TEXT:
            nName = TEXTCURSOR;
            break;
    
        case TOOLTYPE_ERASER:
            nName = DELETECURSOR;
            break;

        default:
            // Do nothing - the name pointer is NULL
            break;
    }

    HCURSOR hcursorResult = NULL;

    if (nName == -1)
    {
        // Return the standard arrow cursor as a default
        hcursorResult = ::LoadCursor(NULL, IDC_ARROW);
    }
    else
    {
        // Return the cursor for the tool
        hcursorResult = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( nName ) );
    }

    return hcursorResult;
}

//
//
// Function:    SetFont
//
// Purpose:     Set the current font of the tool
//
//
void WbTool::SetFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbTool::SetFont");

    // Get the font details
    LOGFONT lfont;

    ::GetObject(hFont, sizeof(LOGFONT), &lfont);
    //zap FontAssociation mode (bug 3258)
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    // Set the local font
    if (m_hFont != NULL)
    {
        ::DeleteFont(m_hFont);
    }
    m_hFont = ::CreateFontIndirect(&lfont);
}


//
//
// Function:    SelectGraphic
//
// Purpose:     Set the current selected graphic type, and copy the colors,
//              widths and font into this tool's attributes.
//
//
void WbTool::SelectGraphic(DCWbGraphic* pGraphic)
{
    UINT uiIndex;

    // Save the selected tool type
    m_selectedTool = pGraphic->GraphicTool();

    // Get the tool object for the selected tool type
    WbTool* pTool = g_pMain->m_ToolArray[m_selectedTool];

    if (HasColor())
    {
        m_clrCur = pGraphic->GetColor();
    }

    if (HasWidth())
    {
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            SetWidthAtIndex(uiIndex, pTool->GetWidthAtIndex(uiIndex));
        }

        // See if the object's width matches any of the available colors
        // for this tool type
        for (uiIndex = 0; uiIndex < NUM_OF_WIDTHS; uiIndex++)
        {
            if (pGraphic->GetPenWidth() == m_uiWidths[uiIndex])
            {
                break;
            }
        }

        SetWidthIndex(uiIndex);
    }

    if (HasFont())
    {
        // only text objects have a font, so cast to a DCWbGraphicText
        if (pGraphic->IsGraphicTool() == enumGraphicText)
        {
            SetFont((((DCWbGraphicText*)pGraphic)->GetFont()));
        }
    }
}



//
// InitToolArray
// Create the array of WB tools
//
//
BOOL InitToolArray(void)
{
    int tool;
    WbTool * pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        // Add the new tool to the array
        pTool = new WbTool(tool);
        if (!pTool)
        {
            ERROR_OUT(("Can't create tool %d", tool));
            return(FALSE);
        }

        g_pMain->m_ToolArray[tool] = pTool;

    }

    return(TRUE);
}


//
// DestroyToolAray()
//
// Free the array of WB tools
//
void DestroyToolArray(void)
{
    int         tool;
    WbTool *    pTool;

    for (tool = TOOLTYPE_FIRST; tool < TOOLTYPE_MAX; tool++)
    {
        pTool = g_pMain->m_ToolArray[tool];
        if (pTool != NULL)
        {
            g_pMain->m_ToolArray[tool] = NULL;
            delete pTool;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\user.cpp ===
//
// USER.CPP
// User Class Members
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


//
// Local macros
//
#define ASSERT_LOCAL_USER() ASSERT(IsLocalUser() == TRUE);


//
// Init()
// This could fail...
//
BOOL WbUser::Init(POM_OBJECT hUser)
{
    ASSERT(hUser != NULL);

    m_hPageCurrent      = WB_PAGE_HANDLE_NULL;
    m_zoomed            = FALSE;
    m_hUser             = hUser;

    m_pRemotePointer = new DCWbGraphicPointer(this);
    if (!m_pRemotePointer)
    {
        ERROR_OUT(("WbUser::Init - failed to create m_pRemotePointer"));
        return(FALSE);
    }

    Refresh();
    return(TRUE);
}


//
//
// Function:    ~WbUser
//
// Purpose:     Destructor
//
//
WbUser::~WbUser(void)
{
        // don't leave any loose ends
        if ((g_pMain != NULL) && (g_pMain->GetLockOwner() == this))
        {
                g_pMain->SetLockOwner(NULL);
        g_pMain->UpdateWindowTitle();
        }

        // Free the remote pointer
        if (m_pRemotePointer != NULL)
        {
                delete m_pRemotePointer;
        m_pRemotePointer = NULL;
        }
}



//
//
// Function:    Refresh
//
// Purpose:     Read the user details and copy them to member variables.
//
//
void WbUser::Refresh(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Refresh");

    ASSERT(m_pRemotePointer);

    // Set the flag indicating whether this is the local user
    POM_OBJECT hLocalUser;
    g_pwbCore->WBP_PersonHandleLocal(&hLocalUser);
    m_bLocalUser = (m_hUser == hLocalUser);

    // Read the external data
    WB_PERSON userDetails;
    UINT uiReturn = g_pwbCore->WBP_GetPersonData(m_hUser, &userDetails);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    // Get the user name
    lstrcpy(m_strName, userDetails.personName);

    // Get the sync flag
    m_bSynced  = (userDetails.synced != FALSE);

    // Get the current page
    m_hPageCurrent = userDetails.currentPage;

    // Get the current position in the page
    m_rectVisible.left   = userDetails.visibleRect.left;
    m_rectVisible.right  = userDetails.visibleRect.right;
    m_rectVisible.top    = userDetails.visibleRect.top;
    m_rectVisible.bottom = userDetails.visibleRect.bottom;

    // Get the pointer active flag. We go directly to the member variable
    // here since the SetActive member of the pointer class would re-write
    // the user information.
    m_pRemotePointer->m_bActive = (userDetails.pointerActive != 0);

    // Get the pointer page
    m_pRemotePointer->SetPage(userDetails.pointerPage);

    // Get the pointer position
    m_pRemotePointer->MoveTo(userDetails.pointerPos.x, userDetails.pointerPos.y);

    // Get the color
    m_color = g_ColorTable[userDetails.colorId % NUM_COLOR_ENTRIES];

    // Set the pointer color
    m_pRemotePointer->SetColor(m_color);
}



//
// Function:    Update
//
// Purpose:     Update the external copy of the user information
//
void WbUser::Update()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Update");

    // Can only update if we are the local user
    ASSERT_LOCAL_USER();

    ASSERT(m_pRemotePointer);

    // Get the local user details
    WB_PERSON userDetails;
    UINT uiReturn;

    uiReturn = g_pwbCore->WBP_GetPersonData(m_hUser, &userDetails);
    if (uiReturn != 0)
    {
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    // Don't update the name

    // Set the sync flag
    userDetails.synced = (m_bSynced != FALSE);

    // Set the pointer active flag
    userDetails.pointerActive = (m_pRemotePointer->IsActive() != FALSE);

    // Set the page handle for the current page
    userDetails.currentPage = m_hPageCurrent;

    // Set the current position in the page
    userDetails.visibleRect.left   = (short)m_rectVisible.left;
    userDetails.visibleRect.right  = (short)m_rectVisible.right;
    userDetails.visibleRect.top    = (short)m_rectVisible.top;
    userDetails.visibleRect.bottom = (short)m_rectVisible.bottom;

    // Set the pointer page
    userDetails.pointerPage = m_pRemotePointer->Page();

    // Set the pointer position within the page
    POINT   pointerPos;

    m_pRemotePointer->GetPosition(&pointerPos);
    userDetails.pointerPos.x = (short)pointerPos.x;
    userDetails.pointerPos.y = (short)pointerPos.y;

    // Don't update the color

    // Write the user details back to the core
    uiReturn = g_pwbCore->WBP_SetLocalPersonData(&userDetails);
    if (uiReturn != 0)
    {
        // Throw exception
            DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
        return;
    }
}


//
//
// Function:    PutSyncPosition
//
// Purpose:     Write the sync position from the current position of this
//              user.
//
//
void WbUser::PutSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::PutSyncPosition");

    // Set up a sync object
    WB_SYNC sync;

    sync.length = sizeof(WB_SYNC);

    sync.currentPage        = m_hPageCurrent;
    sync.visibleRect.top    = (short)m_rectVisible.top;         
    sync.visibleRect.left   = (short)m_rectVisible.left;        
    sync.visibleRect.bottom = (short)m_rectVisible.bottom;      
    sync.visibleRect.right  = (short)m_rectVisible.right;       
    sync.zoomed             = (TSHR_UINT16)m_zoomed;

    sync.dataOffset = (TSHR_UINT16)((BYTE *)&(sync.currentPage) - (BYTE *)&sync);

    UINT uiReturn = g_pwbCore->WBP_SyncPositionUpdate(&sync);
    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }
}

//
//
// Function:    GetSyncPosition
//
// Purpose:     Get the position at which this user should be to
//              account for the current sync information. This function
//              assumes that there is a valid sync position available.
//
//
void WbUser::GetSyncPosition(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::GetSyncPosition");

    // Get the current sync position
    WB_SYNC sync;
    UINT uiReturn = g_pwbCore->WBP_SyncPositionGet(&sync);

    if (uiReturn != 0)
    {
        // Throw an exception
        DefaultExceptionHandler(WBFE_RC_WB, uiReturn);
            return;
    }

    TRACE_DEBUG(("Sync page handle = %d", sync.currentPage));

    // If the sync page is not valid, do nothing
    if (sync.currentPage != WB_PAGE_HANDLE_NULL)
    {
        // Get the current sync position
        m_hPageCurrent = sync.currentPage;

        // Now calculate the new visible rectangle
        RECT rectSyncUser;
        rectSyncUser.left   = sync.visibleRect.left;
        rectSyncUser.top    = sync.visibleRect.top;
        rectSyncUser.right  = sync.visibleRect.right;
        rectSyncUser.bottom = sync.visibleRect.bottom;

        // Check the y position of the visible rectangles
        if ((rectSyncUser.bottom - rectSyncUser.top) <= (m_rectVisible.bottom - m_rectVisible.top))
        {
            // The sync rectangle's height is smaller than our visible rectangle's
            if (rectSyncUser.top < m_rectVisible.top)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.top - m_rectVisible.top);
            }
            else if (rectSyncUser.bottom > m_rectVisible.bottom)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.bottom - m_rectVisible.bottom);
            }
        }
        else
        {
            // The sync rectangle is bigger than ours
            if (rectSyncUser.top > m_rectVisible.top)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.top - m_rectVisible.top);
            }
            else if (rectSyncUser.bottom < m_rectVisible.bottom)
            {
                ::OffsetRect(&m_rectVisible, 0, rectSyncUser.bottom - m_rectVisible.bottom);
            }
        }

        if ((rectSyncUser.right - rectSyncUser.left) <= (m_rectVisible.right - m_rectVisible.left))
        {
            // The sync rectangle's width is smaller than our visible rectangle's
            if (rectSyncUser.left < m_rectVisible.left)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.left - m_rectVisible.left, 0);
            }
            else if (rectSyncUser.right > m_rectVisible.right)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.right - m_rectVisible.right, 0);
            }
        }
        else
        {
            // The sync rectangle is bigger than ours
            if (rectSyncUser.left > m_rectVisible.left)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.left - m_rectVisible.left, 0);
            }
            else if (rectSyncUser.right < m_rectVisible.right)
            {
                ::OffsetRect(&m_rectVisible, rectSyncUser.right - m_rectVisible.right, 0);
            }
        }

        m_zoomed = sync.zoomed;
    }
}

//
//
// Function:    Sync
//
// Purpose:     Sync the local user. The page and point passed as parameters
//              are used as the current sync position only if there is no
//              current sync position determined by another user.
//
//
void WbUser::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Sync");

    ASSERT_LOCAL_USER();
    ASSERT(m_pRemotePointer);

    // Determine whether any other users are currently synced
    WbUser* pUser = WB_GetFirstUser();
    while (pUser != NULL)
    {
        // If this user is synced, we are done
        if (pUser->IsSynced())
        {
            break;
        }

        // Try the next user
        pUser = WB_GetNextUser(pUser);
    }

    // If we found a synced user, and we don't have the contents lock
    if (   (pUser != NULL)
        && (!WB_GotContentsLock()))
    {
        // Get the sync position from the core
        GetSyncPosition();
    }
    else
    {
        // Set the sync position from our own position
        PutSyncPosition();
    }

    // Update the synced member flag
    m_bSynced = TRUE;

    // Write the user details back to the core
    Update();
}

//
//
// Function:    Unsync
//
// Purpose:     Unsynchronize the users page from other synced users
//
//
void WbUser::Unsync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Unsync");

    ASSERT_LOCAL_USER();

    // Update the local member
    m_bSynced = FALSE;

    // Update the external details
    Update();
}


//
//
// Function:    PutPointer
//
// Purpose:     Turn on the user's remote pointer
//
//
void WbUser::PutPointer(WB_PAGE_HANDLE hPage, POINT point)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::PutPointer");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    ASSERT(m_pRemotePointer);
    m_pRemotePointer->SetActive(hPage, point);
}

//
//
// Function:    RemovePointer
//
// Purpose:     Turn off the user's remote pointer
//
//
void WbUser::RemovePointer(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::RemovePointer");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Update the remote pointer members
    ASSERT(m_pRemotePointer);
    m_pRemotePointer->m_bActive = FALSE;
    m_pRemotePointer->m_hPage = WB_PAGE_HANDLE_NULL;

    // Update the external user information
    Update();
}


//
// Function:    IsUsingPointer()
//
BOOL WbUser::IsUsingPointer(void) const
{
    ASSERT(m_pRemotePointer);
    return(m_pRemotePointer->IsActive());
}



//
// Function:    PointerPage()
//
WB_PAGE_HANDLE WbUser::PointerPage(void) const
{
    ASSERT(m_pRemotePointer);
    return(m_pRemotePointer->Page());
}



//
// Function:    GetPointerPosition()
//
void WbUser::GetPointerPosition(LPPOINT lpptPos)
{
    ASSERT(m_pRemotePointer);
    m_pRemotePointer->GetPosition(lpptPos);
}

//
//
// Function:    SetPage
//
// Purpose:     Set the user's current page
//
//
void WbUser::SetPage(WB_PAGE_HANDLE hPage)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::Page");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Only make the update if it is a change
    if (m_hPageCurrent != hPage)
    {
        // Update the local member
        m_hPageCurrent = hPage;

        // Update the external information
        Update();
    }
}


//
//
// Function:    CurrentPosition
//
// Purpose:     Set the user's current position
//
//
void WbUser::SetVisibleRect(LPCRECT lprcVisible)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbUser::SetVisibleRect");

    // Check that we are the local user (we cannot do the update if we are not)
    ASSERT_LOCAL_USER();

    // Only make the update if it is a change
    if (!::EqualRect(&m_rectVisible, lprcVisible))
    {
        // Update the local member
        m_rectVisible = *lprcVisible;

        // Update the external information
        Update();
    }
}


//
//
// Function:    operator==
//
// Purpose:     Return TRUE if the specified user is the same as this user
//
//
BOOL WbUser::operator==(const WbUser& user) const
{
    return (m_hUser == user.m_hUser);
}

//
//
// Function:    operator!=
//
// Purpose:     Return FALSE if the specified user is the same as this user
//
//
BOOL WbUser::operator!=(const WbUser& user) const
{
  return (!((*this) == user));
}

//
//
// Function:    operator=
//
// Purpose:     Copy the specified user to this one
//
//
WbUser& WbUser::operator=(const WbUser& user)
{
    // Save the new handles
    m_hUser   = user.m_hUser;

    // Read the details
    Refresh();

    return (*this);
}

//
//
// Function:    HasContentsLock
//
// Purpose:     Check whether this user has the whiteboard contents lock
//
//
BOOL WbUser::HasContentsLock(void) const
{
    // call the core to find out if we have the lock
    return (WB_LockUser() == this);
}



//
//
// Function:    WbUserList::Clear
//
// Purpose:     Clear the user handle map, removing all user objects
//
//
void WbUserList::Clear(void)
{
    // Delete all the user objects in the user map
    WbUser* pUser;
    POM_OBJECT hUser;

    ASSERT(g_pUsers);
        POSITION position = g_pUsers->GetHeadPosition();

        while (position)
        {
                POSITION posSav = position;
                pUser = (WbUser*)g_pUsers->GetNext(position);
                
                if (pUser != NULL)
                {
                delete pUser;
                }

                g_pUsers->RemoveAt(posSav);
        }

    // Remove all the map entries
    EmptyList();
}


//
//
// Function:    ~WbUserList
//
// Purpose:     Destructor
//
//
WbUserList::~WbUserList(void)
{
    // Delete all the user objects in the user map
    Clear();
}



//
//
// Function:    LockUser
//
// Purpose:     Return a user object showing who has the lock
//
//
WbUser* WB_LockUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_LockUser");

    // Get the lock status from the core (cannot fail)
    POM_OBJECT    hLockUser;
    WB_LOCK_TYPE   lockType;

    lockType = g_pwbCore->WBP_LockStatus(&hLockUser);

    // Build a result
    WbUser* pUserResult = NULL;
    if (lockType != WB_LOCK_TYPE_NONE)
    {
        pUserResult = WB_GetUser(hLockUser);
    }

    return pUserResult;
}


//
//
// Function:    Locked
//
// Purpose:     Return TRUE if another user has a lock (contents or page).
//              NOTE that the page order lock implies the contents are
//              locked.
//
//
BOOL WB_Locked(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) != WB_LOCK_TYPE_NONE)
          && (WB_LocalUser() != WB_LockUser()));
}

//
//
// Function:    ContentsLocked
//
// Purpose:     Return TRUE if another user has the contents lock
//
//
BOOL WB_ContentsLocked(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) == WB_LOCK_TYPE_CONTENTS)
          && (WB_LocalUser() != WB_LockUser()));
}


//
//
// Function:    GotLock
//
// Purpose:     Return TRUE if the local user has a lock
//
//
BOOL WB_GotLock(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) != WB_LOCK_TYPE_NONE)
          && (WB_LocalUser() == WB_LockUser()));
}

//
//
// Function:    GotContentsLock
//
// Purpose:     Return TRUE if the local user has the contents lock
//
//
BOOL WB_GotContentsLock(void)
{
    POM_OBJECT  pLockUser;

    return (   (g_pwbCore->WBP_LockStatus(&pLockUser) == WB_LOCK_TYPE_CONTENTS)
          && (WB_LocalUser() == WB_LockUser()));
}



//
//
// Function:    PresentationMode
//
// Purpose:     Return TRUE if the whiteboard is in presentation mode, i.e.
//              another user has the contents lock, and is synced.
//
//
BOOL WB_PresentationMode(void)
{
    return (   (WB_ContentsLocked())
          && (WB_LockUser() != NULL)
          && (WB_LockUser()->IsSynced()));
}



//
//
// Function:    GetUser
//
// Purpose:     Return a pointer to a user object from a user handle
//
//
WbUser* WB_GetUser(POM_OBJECT hUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetFirstUser");

    // Set up a return value
    WbUser* pUserResult = NULL;

    // if the user handle is null, we return a null object pointer
    if (hUser != NULL)
    {
        // Look the user up in the internal map
        ASSERT(g_pUsers);
                POSITION position = g_pUsers->GetHeadPosition();

                BOOL bFound = FALSE;
                while (position)
                {
                        pUserResult = (WbUser*)g_pUsers->GetNext(position);
                        if (hUser == pUserResult->Handle())
                        {
                                return pUserResult;
                        }
                }

        // The user is not yet in our map
        pUserResult = new WbUser();
        if (!pUserResult)
        {
            ERROR_OUT(("Couldn't allocate user object for 0x%08x", hUser));
        }
        else
        {
            if (!pUserResult->Init(hUser))
            {
                ERROR_OUT(("Couldn't init user object for 0x%08x", hUser));
                delete pUserResult;
                pUserResult = NULL;
            }
            else
            {
                // Add the new user to the internal map
                g_pUsers->AddTail(pUserResult);
            }
        }
    }

    return pUserResult;
}

//
//
// Function:    GetFirstUser
//
// Purpose:     Return the first user in the call
//
//
WbUser* WB_GetFirstUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetFirstUser");

    // Get the handle of the first user (cannot fail)
    POM_OBJECT hUser;
    g_pwbCore->WBP_PersonHandleFirst(&hUser);

    // Get a pointer to the user object for this handle
    WbUser* pUser = WB_GetUser(hUser);

    return pUser;
}

//
//
// Function:    GetNextUser
//
// Purpose:     Return the next user in the call
//
//
WbUser* WB_GetNextUser(const WbUser* pUser)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_GetNextUser");
    ASSERT(pUser != NULL);

    // Get the handle of the next user
    POM_OBJECT hNextUser;
    UINT uiReturn = g_pwbCore->WBP_PersonHandleNext(pUser->Handle(),
                                           &hNextUser);

    WbUser* pUserResult = NULL;
    if (uiReturn == 0)
    {
        pUserResult = WB_GetUser(hNextUser);
    }

    return pUserResult;
}

//
//
// Function:    LocalUser
//
// Purpose:     Return an object representing the local user
//
//
WbUser* WB_LocalUser(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WB_LocalUser");

    // Get the local user handle (cannot fail)
    POM_OBJECT hUser;
    g_pwbCore->WBP_PersonHandleLocal(&hUser);

    return WB_GetUser(hUser);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\wboblist.cpp ===
// PRECOMP
#include "precomp.h"


POSITION CWBOBLIST::AddHead(VOID* pItem)
{
	POSITION posRet = NULL;

	if (m_pHead)
	{
		if (posRet = new COBNODE)
		{
			posRet->pNext = m_pHead;
			posRet->pItem = pItem;
			m_pHead = posRet;
		}
	}
	else
	{
		ASSERT(!m_pTail);
		if (m_pHead = new COBNODE)
		{
			m_pTail = m_pHead;
			m_pHead->pItem = pItem;
			m_pHead->pNext = NULL;
		}
	}

	return m_pHead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\wgrp.cpp ===
//
// WGRP.CPP
// Widths Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szWGClassName[] = "WB_WGRP";


WbWidthsGroup::WbWidthsGroup()
{
    int     i;

    m_hwnd  = NULL;
    m_uLast = 0;

    //
    // Calculate the height of each item in the list--it's the max of the
    // pen widths + slop space
    //
    m_cyItem = 0;
    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        m_cyItem = max(m_cyItem, g_PenWidths[i]);
    }
    m_cyItem += 2 * ::GetSystemMetrics(SM_CYEDGE);
}


WbWidthsGroup::~WbWidthsGroup()
{
    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szWGClassName, g_hInstance);
}



BOOL WbWidthsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX      wc;

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = WGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szWGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbWidthsGroup::Create register class failed"));
        return(FALSE);
    }

    ASSERT(!m_hwnd);

    if (!::CreateWindowEx(WS_EX_STATICEDGE, szWGClassName, NULL,
        WS_CHILD | WS_CLIPSIBLINGS, lprect->left, lprect->top,
        lprect->right - lprect->left, lprect->bottom - lprect->top,
        hwndParent, (HMENU)IDM_WIDTH, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbWidthsGroup"));
        return(FALSE);
    }

    return(TRUE);
}



//
// WGWndProc()
// Message handler for width window
//
LRESULT CALLBACK WGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbWidthsGroup * pwg = (WbWidthsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pwg = (WbWidthsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pwg);

            pwg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pwg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pwg);
            pwg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pwg);
            pwg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pwg);
            pwg->OnLButtonDown((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_NOTIFY:
            // Pass up to main window
            lResult = ::SendMessage(g_pMain->m_hwnd, message, wParam, lParam);
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbWidthsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cy = ::GetSystemMetrics(SM_CYEDGE) +
        (NUM_OF_WIDTHS * m_cyItem);

    if (m_hwnd != NULL)
    {
        RECT    rect;

        ::GetWindowRect(m_hwnd, &rect);
        rect.right -= rect.left;
        lpsize->cx = max(WIDTHBAR_WIDTH, rect.right);
    }
    else
    {
        lpsize->cx = WIDTHBAR_WIDTH;
    }
}



void WbWidthsGroup::PushDown(UINT uiIndex)
{
    if( (uiIndex < NUM_OF_WIDTHS))
    {
        //
        // We really should just invalidate the last selected item, if one,
        // and the new selected item, if one.  But heck, there are only 4
        // items, no big deal to paint.
        //
        m_uLast = uiIndex;
        ::InvalidateRect(m_hwnd, NULL, TRUE);
    }
}




void WbWidthsGroup::OnPaint(void) 
{
    PAINTSTRUCT ps;
    int         i;                   
    RECT        rect;
    int         cx, cy;
    int         nPenWidth;
    HBRUSH      hOldBrush;

    ::BeginPaint(m_hwnd, &ps);

    ::GetClientRect(m_hwnd, &rect);
    cx = ::GetSystemMetrics(SM_CXEDGE);
    cy = m_cyItem / 2;

    // First, fill the background of the selected item
    hOldBrush = SelectBrush(ps.hdc, ::GetSysColorBrush(COLOR_3DHILIGHT));

    ::PatBlt(ps.hdc, rect.left, m_uLast * m_cyItem,
        rect.right - rect.left, m_cyItem, PATCOPY);

    rect.right -= rect.left + 2*cx;

    // Now, use the black brush
    SelectBrush(ps.hdc, ::GetStockObject(BLACK_BRUSH));

    for (i = 0; i < NUM_OF_WIDTHS; i++)
    {
        nPenWidth = g_PenWidths[i];

        ::PatBlt(ps.hdc, cx, rect.top + (m_cyItem - nPenWidth) / 2,
            rect.right, nPenWidth, PATCOPY);

        rect.top += m_cyItem;
    }

    SelectBrush(ps.hdc, hOldBrush);

    // Finish painting
    ::EndPaint(m_hwnd, &ps);
}



//
// ItemFromPoint()
// Returns which item, in the client, is under the point.
//
int WbWidthsGroup::ItemFromPoint(int x, int y) const
{
    int iItem;

    iItem = y / m_cyItem;

    // If it's in the border above the first item, pin it.
    if (iItem < 0)
        iItem = 0;

    // If it's in the border below the last item, pin it.
    if (iItem >= (IDM_WIDTHS_END - IDM_WIDTHS_START))
        iItem = (IDM_WIDTHS_END - IDM_WIDTHS_START - 1);

    return(iItem + IDM_WIDTHS_START);
}


//
// GetItemRect()
// Gets the client-relative rectangle of an item
//
void WbWidthsGroup::GetItemRect(int iItem, LPRECT lprc) const
{
    ::GetClientRect(m_hwnd, lprc);
    
    lprc->top = (iItem - IDM_WIDTHS_START) * m_cyItem;
    lprc->bottom = lprc->top + m_cyItem;
}


//
// OnLButtonDown()
//
void WbWidthsGroup::OnLButtonDown(int x, int y)
{
    int iItem;

    iItem = ItemFromPoint(x, y);
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, 
                    (WPARAM)MAKELONG(iItem, BN_CLICKED),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\wboblist.hpp ===
//
// CWBOBLIST.HPP
// User Class
//
// Copyright Microsoft 1998-
//
#ifndef __CWBOBLIST_HPP_
#define __CWBOBLIST_HPP_

class CWBOBLIST : public COBLIST
{
public:
	POSITION AddHead(VOID* pItem);
};

#endif  __CWBOBLIST_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\msconfwb\wgrp.hpp ===
//
// WGRP.HPP
// Widths Group
//
// Copyright Microsoft 1998-
//

#ifndef __WGRP_HPP
#define __WGRP_HPP


#define WIDTHBAR_WIDTH	TOOLBAR_WIDTH
#define WIDTHBAR_HEIGHT	50




class WbWidthsGroup
{
public:
	WbWidthsGroup();
    ~WbWidthsGroup();

	BOOL    Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

    void    PushDown(UINT uiIndex);
    int     ItemFromPoint(int x, int y) const;
    void    GetItemRect(int iItem, LPRECT lprc) const;

    HWND    m_hwnd;

    friend LRESULT CALLBACK  WGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void    OnPaint(void);
    void    OnLButtonDown(int x, int y);

	UINT    m_uLast;
    UINT    m_cyItem;
};

#endif // __WGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\comboboxex.h ===
#ifndef _ComboBoxEx_h_
#define _ComboBoxEx_h_

//#include <windowsx.h>

struct MEMBER_CHANNEL_ID;

#define ComboBoxEx_GetCount(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCOUNT, 0L, 0L))
#define ComboBoxEx_GetCurSel(hwndCtl) ((int)(DWORD)SNDMSG((hwndCtl), CB_GETCURSEL, 0L, 0L))
#define ComboBoxEx_SetCurSel(hwndCtl, index) ((int)(DWORD)SNDMSG((hwndCtl), CB_SETCURSEL, (WPARAM)(int)(index), 0L))
#define ComboBoxEx_GetComboControl( hHWND ) (HWND)SNDMSG( hHWND, CBEM_GETCOMBOCONTROL, 0, 0 )
#define ComboBoxEx_SetImageList( hHWND, iIMAGELIST ) SNDMSG(hHWND,CBEM_SETIMAGELIST,0,(LPARAM)iIMAGELIST)
#define ComboBoxEx_InsertItem( hHWND, lpcCBItem ) (int)SNDMSG( hHWND, CBEM_INSERTITEM, 0, (LPARAM)(const COMBOBOXEXITEM FAR *) lpcCBItem )
#define ComboBoxEx_GetItem( hHWND, lpcCBItem ) (int)SNDMSG( hHWND, CBEM_GETITEM, 0, (LPARAM) lpcCBItem )
#define ComboBoxEx_DeleteItem( hHWND, iIndex ) (int)SNDMSG( hHWND, CBEM_DELETEITEM, (WPARAM)(int) iIndex, 0 )
#define ComboBoxEx_GetItemHeight( hHWND, iIndex ) (int)SNDMSG( hHWND, CB_GETITEMHEIGHT, (WPARAM)(int)iIndex, 0 )

#define CBEIF_ALL (CBEIF_IMAGE | CBEIF_INDENT | CBEIF_LPARAM | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE | CBEIF_TEXT )

T120NodeID ComboBoxEx_GetNodeIDFromSendID( HWND hwnd, T120UserID userID );
T120NodeID ComboBoxEx_GetNodeIDFromPrivateSendID( HWND hwnd, T120UserID userID);
int ComboBoxEx_FindMember( HWND hwnd, int iStart, MEMBER_CHANNEL_ID *pMemberID );
void ComboBoxEx_SetHeight( HWND hwnd, int iHeight );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\chatldr.cpp ===
#include "precomp.h"

CHATLoader  *g_pCHATLoader = NULL;
CChatObj	*g_pChatObj = NULL;
DWORD 		g_dwWorkThreadID = 0;
CNmChatCtl	*g_pChatWindow = NULL;
HANDLE      g_hWorkThread = NULL;
BOOL        g_fShutdownByT120 = FALSE;

DWORD __stdcall CHATWorkThreadProc(LPVOID lpv);


T120Error CALLBACK CreateAppletLoaderInterface
(
    IAppletLoader     **ppOutIntf
)
{
    if (NULL != ppOutIntf)
    {
        if (NULL == g_pCHATLoader)
        {
			DBG_SAVE_FILE_LINE
            *ppOutIntf = (IAppletLoader *) new CHATLoader();
            return ((NULL != *ppOutIntf) ? T120_NO_ERROR : T120_ALLOCATION_FAILURE);
        }
        return T120_ALREADY_INITIALIZED;
    }
    return T120_INVALID_PARAMETER;
}



//
// Chat Applet Loader
//

CHATLoader::CHATLoader(void)
:
    CRefCount(MAKE_STAMP_ID('C','H','L','D'))
{
	ASSERT(NULL == g_pCHATLoader);

	g_pCHATLoader = this;

}


CHATLoader::~CHATLoader(void)
{
    g_pCHATLoader = NULL;
}


//
// Create the work thread and wait for its being started.
//
APPLDR_RESULT CHATLoader::AppletStartup
(
    BOOL            fNoUI
)
{
    APPLDR_RESULT eRet = APPLDR_FAIL;
    if (0 == g_dwWorkThreadID)
    {
        HANDLE hSync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL != hSync)
        {
            g_hWorkThread = ::CreateThread(NULL, 0, CHATWorkThreadProc, hSync, 0, &g_dwWorkThreadID);
            if (NULL != g_hWorkThread)
            {
                ::WaitForSingleObject(hSync, 5000); // 5 seconds
	             eRet = APPLDR_NO_ERROR;
            }
            ::CloseHandle(hSync);
        }
    }

	return  eRet;

}

//
APPLDR_RESULT CHATLoader::AppletCleanup
(
    DWORD           dwTimeout
)
{

	if(g_pChatWindow)
	{
		//
		// Last change to save
		//
		int rc = g_pChatWindow->QueryEndSession();
		if(rc == IDCANCEL)
		{
			return APPLDR_CANCEL_EXIT;
		}
	}

    g_fShutdownByT120 = TRUE;

    ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_CLOSING);

    // notify the work thread to exit
    if(g_pChatWindow)
    {
	    ::PostMessage(g_pChatWindow->GetHandle(), WM_CLOSE, 1, 0);
	}

    // wait for the worker thread's going down
    ::WaitForSingleObject(g_hWorkThread, dwTimeout);

    return APPLDR_NO_ERROR;
}


APPLDR_RESULT CHATLoader::AppletQuery(APPLET_QUERY_ID eQueryId)
{
    // Do nothing here
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CHATLoader::OnNM2xNodeJoin(void)
{
    // Invoke CHAT on NM2.x nodes
    if (NULL != g_pChatObj)
    {
        g_pChatObj->InvokeApplet();
    }
    return APPLDR_NO_ERROR;
}

APPLDR_RESULT CHATLoader::AppletInvoke
(
    BOOL            fRemote,
    T120ConfID      nConfID,
    LPSTR           pszCmdLine
)
{

	if(g_pChatWindow)
	{
		PostMessage(g_pChatWindow->GetHandle(), WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);
	}

    return APPLDR_NO_ERROR;
}


void CHATLoader::ReleaseInterface(void)
{
    Release();
}


DWORD __stdcall CHATWorkThreadProc(LPVOID lpv)
{
	HRESULT hr = S_OK;

	DBG_SAVE_FILE_LINE
	g_pChatObj = new CChatObj();
	if (!g_pChatObj)
	{
		ERROR_OUT(("Can't create g_pChatObj"));
		return S_FALSE;
	}

	DBG_SAVE_FILE_LINE
	g_pChatWindow = new CNmChatCtl();
	if (!g_pChatWindow)
	{
		ERROR_OUT(("Can't create CNmChatCtl"));
		return S_FALSE;
	}

	::SetEvent((HANDLE) lpv);

	::T120_AppletStatus(APPLET_ID_CHAT, APPLET_WORK_THREAD_STARTED);

	PostMessage(g_pChatWindow->GetHandle(), WM_USER_BRING_TO_FRONT_WINDOW, 0, 0);

	//
	// MESSAGE LOOP
	//
	if (S_OK == hr)
	{
		MSG	 msg;
		
		while (::GetMessage(&msg, NULL, NULL, NULL))
		{
			if(!g_pChatWindow->FilterMessage(&msg))
			{
		
				::TranslateMessage(&msg);
				::DispatchMessage(&msg);
			}
		}
	}


	if(g_pChatWindow)
	{
        CGenWindow::DeleteStandardPalette();
		delete g_pChatWindow;
		g_pChatWindow = NULL;
	}

	if(g_pChatObj)
	{
		delete  g_pChatObj;
		g_pChatObj = NULL;
	}


	::T120_AppletStatus(APPLET_ID_CHAT, APPLET_WORK_THREAD_EXITED);

	g_dwWorkThreadID = 0;

    if (! g_fShutdownByT120)
    {
        ::FreeLibraryAndExitThread(g_hInstance, 0);
    }

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\chatldr.h ===
#ifndef _Chat_Loader_H_
#define _Chat_Loader_H_

#include <iappldr.h>


class CHATLoader : public CRefCount, public IAppletLoader
{
public:

    CHATLoader(void);
    ~CHATLoader(void);
    
    // IAppletLoader methods
    STDMETHOD_(void,  ReleaseInterface)(void);
	STDMETHOD_(APPLDR_RESULT,  AppletStartup)(BOOL fNoUI);
	STDMETHOD_(APPLDR_RESULT,  AppletCleanup)(DWORD dwTimeout);
	STDMETHOD_(APPLDR_RESULT,  AppletInvoke)(BOOL fRemote, T120ConfID nConfID, LPSTR pszCmdLine);
    STDMETHOD_(APPLDR_RESULT,  AppletQuery)(APPLET_QUERY_ID eQueryId);
    STDMETHOD_(APPLDR_RESULT,  OnNM2xNodeJoin)(void);
};


#endif // _Chat_Loader_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\comboboxex.cpp ===
#include "precomp.h"
#include "ComboBoxEx.h"

int ComboBoxEx_FindMember( HWND hwnd, int iStart, MEMBER_CHANNEL_ID *pMemberID)
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	if( iStart < 0 )
	{
		iStart = 0;
	}

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			MEMBER_CHANNEL_ID *_pMemberID;
			_pMemberID = (MEMBER_CHANNEL_ID*)cbexFind.lParam;
			if( _pMemberID != pMemberID ) continue;
		}
		else
		{
			return -1;
		}

		return i;
	}

	return -1;
}


T120NodeID ComboBoxEx_GetNodeIDFromSendID( HWND hwnd, T120UserID userID )
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	int	iStart = 0;

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			T120UserID _userID;
			_userID = (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nSendId : 0;
			if( userID != _userID ) continue;
		}
		else
		{
			return 0;
		}

		return (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nNodeId : 0;
	}

	return 0;
}


T120NodeID ComboBoxEx_GetNodeIDFromPrivateSendID( HWND hwnd, T120UserID userID )
{
	int iSize = ComboBoxEx_GetCount( hwnd );

	COMBOBOXEXITEM cbexFind;

	int	iStart = 0;

	for( int i = iStart; i < iSize; i++ )
	{
		ClearStruct(&cbexFind);
		cbexFind.iItem = i;
		cbexFind.mask = CBEIF_LPARAM;

		if( ComboBoxEx_GetItem( hwnd, &cbexFind ) )
		{
			T120UserID _userID;
			_userID = (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nPrivateSendId : 0;
			if( userID != _userID ) continue;
		}
		else
		{
			return 0;
		}

		return (cbexFind.lParam)?((MEMBER_CHANNEL_ID*)(cbexFind.lParam))->nNodeId : 0;
	}

	return 0;
}



void ComboBoxEx_SetHeight( HWND hwnd, int iHeight )
{
	HWND hwndCombo = (HWND)SNDMSG( hwnd, CBEM_GETCOMBOCONTROL, 0, 0 );
	::SetWindowPos( hwndCombo, NULL, 0, 0, 0, iHeight, SWP_NOMOVE | SWP_NOACTIVATE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\cpappletnotify.h ===
#ifndef __CPAppletNotify_h__
#define __CPAppletNotify_h__

#include "CPnmctl1.h"


#endif // __CPAppletNotify_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\containercontrol.h ===
// VidWndCtrl.h : Declaration of the CContainerControl

#ifndef __CONTAINERCONTROL_H_
#define __CONTAINERCONTROL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CContainerControl
class ATL_NO_VTABLE CContainerControl : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IContainerControl, &IID_IContainerControl, &LIBID_NmCtl1Lib>,
	public CComControl<CContainerControl>,
	public IPersistStreamInitImpl<CContainerControl>,
	public IPersistPropertyBagImpl<CContainerControl>,
	public IOleControlImpl<CContainerControl>,
	public IOleObjectImpl<CContainerControl>,
	public IOleInPlaceActiveObjectImpl<CContainerControl>,
	public IViewObjectExImpl<CContainerControl>,
	public IOleInPlaceObjectWindowlessImpl<CContainerControl>,
	public ISupportErrorInfo,
	public CComCoClass<CContainerControl, &CLSID_ContainerControl>,
	public IObjectSafetyImpl<CContainerControl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
private:

	CComBSTR m_strProgIDOfControl;
	bool	 m_bInitialized;


public:
	CContainerControl()
	{
		m_bInitialized = false;
		m_bWindowOnly = TRUE;
	}

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos);

DECLARE_REGISTRY_RESOURCEID(IDR_CONTAINERCONTROL)
DECLARE_NOT_AGGREGATABLE(CContainerControl)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CContainerControl)
	COM_INTERFACE_ENTRY(IContainerControl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

BEGIN_PROP_MAP(CContainerControl)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CContainerControl)
	//CHAIN_MSG_MAP(CComControl<CContainerControl>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		static const IID* arr[] = 
		{
			&IID_IContainerControl,
		};
		for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
		{
			if (InlineIsEqualGUID(*arr[i], riid))
				return S_OK;
		}
		return S_FALSE;
	}

// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IPersistPropertyBag
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);

// IContainerControl
	STDMETHOD(put_ProgIDOfControl)(IN BSTR strProgIDOfControl );
	STDMETHOD(get_ControlDispatch)(OUT LPDISPATCH* ppDisp );

};

#endif //__CONTAINERCONTROL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\contain.h ===
//////////////////////////////////////////////////////////////////////////
//
//  container.h
//
//      This file contains the complete class specification of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _CONTAINER_H_
#define _CONTAINER_H_

#include <ocidl.h>
#include <docobj.h>
#include <atlbase.h>

class CContainer : public IOleClientSite, 
                  public IOleInPlaceSite,
                  public IOleInPlaceFrame,
                  public IOleControlSite,
                  public IDispatch, 
                  public IOleCommandTarget
{
    private:
        ULONG       m_cRefs;        // ref count
        HWND        m_hwnd;         // window handle of the container
        HWND        m_hwndStatus;   // status window handle
        IUnknown    *m_punk;        // IUnknown of contained object
        RECT        m_rect;         // size of control

    public:
        CContainer();
        ~CContainer();

    public:
        // *** IUnknown Methods ***
        STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // *** IOleClientSite Methods ***
        STDMETHOD (SaveObject)();
        STDMETHOD (GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppMk);
        STDMETHOD (GetContainer)(LPOLECONTAINER *ppContainer);
        STDMETHOD (ShowObject)();
        STDMETHOD (OnShowWindow)(BOOL fShow);
        STDMETHOD (RequestNewObjectLayout)();

        // *** IOleWindow Methods ***
        STDMETHOD (GetWindow) (HWND * phwnd);
        STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

        // *** IOleInPlaceSite Methods ***
        STDMETHOD (CanInPlaceActivate) (void);
        STDMETHOD (OnInPlaceActivate) (void);
        STDMETHOD (OnUIActivate) (void);
        STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
        STDMETHOD (Scroll) (SIZE scrollExtent);
        STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
        STDMETHOD (OnInPlaceDeactivate) (void);
        STDMETHOD (DiscardUndoState) (void);
        STDMETHOD (DeactivateAndUndo) (void);
        STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect);

        // *** IOleInPlaceUIWindow Methods ***
        STDMETHOD (GetBorder)(LPRECT lprectBorder);
        STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
        STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                    LPCOLESTR lpszObjName);

        // *** IOleInPlaceFrame Methods ***
        STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
        STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
        STDMETHOD (RemoveMenus)(HMENU hmenuShared);
        STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
        STDMETHOD (EnableModeless)(BOOL fEnable);
        STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

        // *** IOleControlSite Methods ***
        STDMETHOD (OnControlInfoChanged)(void);
        STDMETHOD (LockInPlaceActive)(BOOL fLock);
        STDMETHOD (GetExtendedControl)(IDispatch **ppDisp);
        STDMETHOD (TransformCoords)(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags);
        STDMETHOD (TranslateAccelerator)(LPMSG pMsg, DWORD grfModifiers);
        STDMETHOD (OnFocus)(BOOL fGotFocus);
        STDMETHOD (ShowPropertyFrame)(void);

        // *** IDispatch Methods ***
        STDMETHOD (GetIDsOfNames)(REFIID riid, OLECHAR FAR* FAR* rgszNames,	unsigned int cNames, LCID lcid,	DISPID FAR* rgdispid);
        STDMETHOD (GetTypeInfo)(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
        STDMETHOD (GetTypeInfoCount)(unsigned int FAR * pctinfo);
        STDMETHOD (Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr);

        // *** IOleCommandTarget Methods ***
        STDMETHOD (QueryStatus)(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD  prgCmds[  ], OLECMDTEXT *pCmdText);
        STDMETHOD (Exec)(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);


    public:
        HRESULT add(BSTR clsid);
        void remove();
        void setParent(HWND hwndParent);
        void setLocation(int x, int y, int width, int height);
        void setVisible(BOOL fVisible);
        void setFocus(BOOL fFocus);
        void setStatusWindow(HWND hwndStatus);
        HRESULT translateKey(MSG *pmsg);
        IDispatch *getDispatch();
        IUnknown * getUnknown();

        HRESULT InPlaceActivate( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\iconindices.h ===
#ifndef __IconIndices_h__
#define __IconIndices_h__

#define II_Announcement                     0
#define II_Decision                         1
#define II_ForDiscussion                    2
#define II_Presentation                     3
#define II_Action                           4
#define II_DocLink                          5
#define II_Minutes                          6
#define II_ScriptableAction                 7
#define II_ChatScript                       8
#define II_WhiteboardScript                 9
#define II_Call                            10
#define II_HangUpwStop                     11
#define II_Refresh                         12
#define II_Delete                          13
#define II_SendMail                        14
#define II_Chat                            15
#define II_NewChatMessage                  16
#define II_Whiteboard                      17
#define II_WhiteboardNewActivity           18
#define II_AgendaApplet                    19
#define II_Roster                          20
#define II_RosterSomeoneJoined             21
#define II_RosterSomeoneLeft               22
#define II_OutgoingVideo                   23
#define II_OutgoingVideoNotSending         24
#define II_IncommingVideo                  25
#define II_IncommingVideoReceiving         26
#define II_IncommingVideoNotReceiving      27
#define II_Dot                             30

#endif // __IconIndices_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\compwnd.h ===
#ifndef __CompWnd_h__
#define __CompWnd_h__

// This is included to get INmApplet and IComponentWnd
#include "NmCtl1.h"

// This is to get the defs for CProxyIComponentWndEvent
#include "CPCompWndEvent.h"

class ATL_NO_VTABLE CComponentWnd : 
	public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CComponentWnd, &CLSID_NmAppletFrame>, 
    public IConnectionPointContainerImpl<CComponentWnd>,
    public CProxyIComponentWndEvent<CComponentWnd>,
    public CWindowImpl<CComponentWnd>,
	public IOleClientSite,
	public IOleInPlaceSite,
    public IComponentWnd,
    public IOleInPlaceFrame,
    public INmAppletClientSite
{

// Some Constants

    CONSTANT( WND_DEFAULT_WIDTH = 500 );
    CONSTANT( WND_DEFAULT_HEIGHT = 300 );
    CONSTANT( TOOLBAR_MASK_COLOR = (RGB(255,   0, 255)) );
    
    enum eWndID { 
                  StatusWndID   = 1,
#if CompWnd_HasFileMenuAndToolbar
                  ReBarWndID,
                  ToolBarWndID 
#endif // CompWnd_HasFileMenuAndToolbar
                };


#if CompWnd_HasFileMenuAndToolbar
    enum eIconIDs {
                    II_FILE_OPEN    = 1,
                    II_FILE_SAVE    = 2,
                    II_EDIT_CUT     = 3,
                    II_EDIT_COPY    = 4,
                    II_EDIT_PASTE   = 5,
                    II_FILE_PRINT   = 6
                  };
#endif // #if CompWnd_HasFileMenuAndToolbar

public:
// Gconstruction / destruction
    CComponentWnd( void );
    ~CComponentWnd( void );
    //static HRESULT CreateInstance( IComponentWnd** ppNewWnd, REFIID riid, bool bCreate );

protected:

BEGIN_COM_MAP(CComponentWnd)
	COM_INTERFACE_ENTRY(IOleClientSite)
    COM_INTERFACE_ENTRY(IOleInPlaceFrame)
	COM_INTERFACE_ENTRY(IOleInPlaceSite)
	COM_INTERFACE_ENTRY2(IOleWindow,IOleInPlaceFrame)
    COM_INTERFACE_ENTRY(IOleInPlaceUIWindow)
    COM_INTERFACE_ENTRY(IComponentWnd)
    COM_INTERFACE_ENTRY(INmAppletClientSite)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CComponentWnd)
    CONNECTION_POINT_ENTRY(IID_IComponentWndEvent)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CComponentWnd)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
	MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate);
    MESSAGE_HANDLER(WM_COMMAND, OnCommand);
    MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMax);

#if CompWnd_HasFileMenuAndToolbar
    COMMAND_ID_HANDLER(ID_FILE_OPEN, cmdFileOpen ) 
    COMMAND_ID_HANDLER(ID_FILE_SAVE, cmdFileSave )
    COMMAND_ID_HANDLER(ID_FILE_SAVEAS, cmdFileSaveAs )
    COMMAND_ID_HANDLER(ID_FILE_PRINT, cmdFilePrint ) 
    COMMAND_ID_HANDLER(ID_VIEW_TOOLBAR, cmdViewToolBar ) 
#endif //CompWnd_HasFileMenuAndToolbar

    NOTIFY_CODE_HANDLER(TTN_NEEDTEXT, OnNotifyCode_TTN_NEEDTEXT)

ALT_MSG_MAP(StatusWndID)
    MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)

#if CompWnd_HasFileMenuAndToolbar
    ALT_MSG_MAP(ReBarWndID)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)

    ALT_MSG_MAP(ToolBarWndID)
        MESSAGE_HANDLER(WM_NCDESTROY,OnNcDestroy)
        MESSAGE_HANDLER(WM_CREATE, OnCreate)
#endif // CompWnd_HasFileMenuAndToolbar
 
END_MSG_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_COMPWND)


private:

// Message handlers
    LRESULT OnNcDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnSize(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnClose(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnCreate(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
    LRESULT OnActivate(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	LRESULT OnCommand(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	LRESULT OnGetMinMax(UINT  uMsg, WPARAM  wParam, LPARAM  lParam, BOOL&  lResult );
	
    

// Command handlers
#if CompWnd_HasFileMenuAndToolbar
    LRESULT cmdFileOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFileSave(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFileSaveAs(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdFilePrint(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
#endif // CompWnd_HasFileMenuAndToolbar

    LRESULT cmdViewStatusBar(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdViewToolBar(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT cmdHelpHelpTopics(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    
// Notification handlers
    LRESULT OnNotifyCode_TTN_NEEDTEXT(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IComponentWnd
public:
    STDMETHOD(put_CLSID)(/*[in]*/ REFIID riid );
    STDMETHOD(get_ControlUnknown)(/*[out]*/ LPUNKNOWN* ppUnk );
	STDMETHOD(Create)();
	STDMETHOD(Show)(/*[in]*/ BOOL bShow );
    STDMETHOD(SetFocus)();
    STDMETHOD(Destroy)();
	STDMETHOD(SetWindowPos)(LPCRECT pcRect, UINT nFlags );
	STDMETHOD(GetWindowRect)(LPRECT pRect);
	STDMETHOD(IsChildWindow)(IN HWND hWnd );
	STDMETHOD(ShiftFocus)(IN HWND hWndCur, IN BOOL bForward );


// IOleClientSite
public:
    STDMETHOD(SaveObject)(void);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHOD(GetContainer)(IOleContainer **ppContainer);
    STDMETHOD(ShowObject)(void);
    STDMETHOD(OnShowWindow)(BOOL fShow);
    STDMETHOD(RequestNewObjectLayout)(void);

// INmAppletClientSite
public:
    STDMETHOD(SetStatusBarVisible)(BOOL fShow);
	STDMETHOD(SetIcons)(/*[in]*/HICON hIconSmall, /*[in]*/HICON hIconBig );
	STDMETHOD(SetWindowText)(/*[in]*/LPCTSTR lpszCaption );

// IOleInPlaceSite
public:
    STDMETHOD(CanInPlaceActivate)(void);
    STDMETHOD(OnInPlaceActivate)(void);
    STDMETHOD(OnUIActivate)(void);
    STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc,
		LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD(Scroll)(SIZE scrollExtant);
    STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
    STDMETHOD(OnInPlaceDeactivate)( void);
    STDMETHOD(DiscardUndoState)( void);
    STDMETHOD(DeactivateAndUndo)( void);
    STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);


// IOleWindow
public:
    STDMETHOD (GetWindow) (HWND * phwnd);
    STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);

// IOleInPlaceUIWindow
public:
    STDMETHOD (GetBorder)(LPRECT lprectBorder);
    STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName);

//IOleInPlaceFrame 
public:
    STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD (RemoveMenus)(HMENU hmenuShared);
    STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
    STDMETHOD (EnableModeless)(BOOL fEnable);
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);


private:
    // Helper Fns
    HRESULT _CreateStatusBar( void );
#if CompWnd_HasFileMenuAndToolbar
    HRESULT _CreateReBar( void );
    HRESULT _CreateToolBar( void );
#endif // CompWnd_HasFileMenuAndToolbar
    HIMAGELIST _SetTbImageList( int ImListID, int WndMsg );
    HIMAGELIST _SetTbImageListSpecialCaseFor_TB_SETDISABLEDIMAGELIST( int ImListID );
    HRESULT _GetControlRect( LPRECT prc );
    void _InitMenuAndToolbar( void );
    bool _IsStatusBarVisibleFlagSet( void );
#if CompWnd_HasFileMenuAndToolbar
    bool _IsToolBarVisibleFlagSet( void );
    bool _IsReBarVisibleFlagSet( void );
#endif// CompWnd_HasFileMenuAndToolbar
    HRESULT _SetMenuItemCheck( UINT idItem, bool bChecked = true  );

protected:
// Data members    
    IOleInPlaceActiveObject*    m_pCtlInPlaceActiveObject;
    bool                        m_bSharedMenuActive;
    HOLEMENU                    m_holemenu;
	IOleObject*                 m_pOleObject;
    CComPtr<INmApplet>          m_spNmApplet;
	bool                        m_bInPlaceActive;
    CLSID                       m_ControlCLSID;
    bool                        m_bCLSIDSet;
    CContainedWindow            m_hWndStatusBar;
#if CompWnd_HasFileMenuAndToolbar
    CContainedWindow            m_hWndReBar;
    CContainedWindow            m_hWndToolBar;
#endif // CompWnd_HasFileMenuAndToolbar

    HIMAGELIST                  m_himlTbButtonNormal;
	HIMAGELIST                  m_himlTbButtonHot;
	HIMAGELIST                  m_himlTbButtonDisabled;
	
    int                         m_cxToolBarButton;
    int                         m_cyToolBarButton;
    int                         m_cxToolBarButtonBitmap;
    int                         m_cyToolBarButtonBitmap;
    int                         m_IDToolbarBitmap;
    int                         m_IDToolbarBitmapHot;

    RECT                        m_rcComponentToolbarSpace;
};


inline HRESULT MoveMenuToSharedMenu( HMENU hMenu, HMENU hMenuShared, int MenuBarIndex, int InsertionIndex )
{
    DBGENTRY(MoveMenuToSharedMenu);
    HRESULT hr = S_OK;

    if( IsMenu( hMenu ) && IsMenu( hMenuShared ) )
    {
        TCHAR szMenuItem[ MAX_PATH ] = TEXT("");
        int cbMenuItem = 0;
    
        MENUITEMINFO mii;
        ClearStruct( &mii );
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_DATA | MIIM_SUBMENU | MIIM_TYPE;
        mii.fType = MFT_STRING;

        cbMenuItem = GetMenuString( hMenu, MenuBarIndex, szMenuItem, MAX_PATH, MF_BYPOSITION );
        if( 0 != cbMenuItem )
        {
            mii.cch = 1 + cbMenuItem;
            mii.dwTypeData = szMenuItem;
            mii.hSubMenu = GetSubMenu( hMenu, MenuBarIndex );
                
            RemoveMenu( hMenu, MenuBarIndex, MF_BYPOSITION );

            if( 0 == InsertMenuItem( hMenuShared, InsertionIndex, TRUE, &mii ) )
            {
                ERROR_OUT(("InsertMenuItem failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            ERROR_OUT(("GetMenuString failed"));
            hr = E_FAIL;
        }
    }
    else
    {
        ERROR_OUT(("Passed a bad menu handle"));
        hr = E_HANDLE;
    }

    DBGEXIT_HR( MoveMenuToSharedMenu, hr );
    return hr;
}


#endif // __CompWnd_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\cpcompwndevent.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyIComponentWndEvent
template <class T>
class CProxyIComponentWndEvent : public IConnectionPointImpl<T, &IID_IComponentWndEvent, CComDynamicUnkArray>
{
public:

//IComponentWndEvent : IDispatch
public:
	HRESULT Fire_OnClose()
	{
		T* pT = (T*)this;
		pT->Lock();
		HRESULT ret;
		IUnknown** pp = m_vec.begin();
		while (pp < m_vec.end())
		{
			if (*pp != NULL)
			{
				IComponentWndEvent* pIComponentWndEvent = reinterpret_cast<IComponentWndEvent*>(*pp);
				ret = pIComponentWndEvent->OnClose();
			}
			pp++;
		}
		pT->Unlock();
		return ret;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\contain.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  container.cpp
//
//      This file contains the complete implementation of an ActiveX
//      control container. This purpose of this container is to test
//      a single control being hosted.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include "precomp.h"

#include <shlguid.h>

#include "contain.h"

/**
 *  This method is the constructor for the CContainer object. 
 */
CContainer::CContainer()
{
    m_cRefs     = 1;
    m_hwnd      = NULL;
    m_punk      = NULL;

    memset(&m_rect, 0, sizeof(m_rect));
}

/** 
 *  This method is the destructor for the CContainer object.
 */
CContainer::~CContainer()
{
    if (m_punk)
    {
        m_punk->Release();
        m_punk=NULL;
    }
}

/**
 *  This method is called when the caller wants an interface pointer.
 *
 *  @param      riid        The interface being requested.
 *  @param      ppvObject   The resultant object pointer.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
STDMETHODIMP CContainer::QueryInterface(REFIID riid, PVOID *ppvObject)
{
    if (!ppvObject)
        return E_POINTER;

//~    if (IsEqualIID(riid, IID_IOleClientSite))
//~        *ppvObject = (IOleClientSite *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
    if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *ppvObject = (IOleInPlaceSite *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceFrame))
//~        *ppvObject = (IOleInPlaceFrame *)this;
//~    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
//~        *ppvObject = (IOleInPlaceUIWindow *)this;
//~    else if (IsEqualIID(riid, IID_IOleControlSite))
//~        *ppvObject = (IOleControlSite *)this;
    else if (IsEqualIID(riid, IID_IOleWindow))
        *ppvObject = (IOleWindow *)(IOleInPlaceFrame *)this;
//~    else if (IsEqualIID(riid, IID_IDispatch))
//~        *ppvObject = (IDispatch *)this;
    else if (IsEqualIID(riid, IID_IUnknown))
        *ppvObject = this;
//~    else if (IsEqualIID(riid, IID_IOleCommandTarget))
//~        *ppvObject = (IOleCommandTarget *)this;
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/**
 *  This method increments the current object count.
 *
 *  @return     ULONG       The new reference count.
 */
ULONG CContainer::AddRef(void)
{
    return ++m_cRefs;
}

/**
 *  This method decrements the object count and deletes if necessary.
 *
 *  @return     ULONG       Remaining ref count.
 */
ULONG CContainer::Release(void)
{
    if (--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

// ***********************************************************************
//  IOleClientSite
// ***********************************************************************

HRESULT CContainer::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetContainer(LPOLECONTAINER * ppContainer)
{
    return E_NOINTERFACE;
}

HRESULT CContainer::ShowObject()
{
    return S_OK;
}

HRESULT CContainer::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT CContainer::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleWindow
// ***********************************************************************

HRESULT CContainer::GetWindow(HWND * lphwnd)
{
    if (!IsWindow(m_hwnd))
        return S_FALSE;

    *lphwnd = m_hwnd;
    return S_OK;
}

HRESULT CContainer::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceSite
// ***********************************************************************

HRESULT CContainer::CanInPlaceActivate(void)
{
    return S_OK;
}

HRESULT CContainer::OnInPlaceActivate(void)
{
    return S_OK;
}

HRESULT CContainer::OnUIActivate(void)
{
    return S_OK;
}

HRESULT CContainer::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin,
                                  LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
//~    *ppFrame = (IOleInPlaceFrame *)this;
    *ppFrame = NULL;
    *ppIIPUIWin = NULL;

    RECT rect;
    GetClientRect(m_hwnd, &rect);
    lprcPosRect->left       = 0;
    lprcPosRect->top        = 0;
    lprcPosRect->right      = rect.right;
    lprcPosRect->bottom     = rect.bottom;

    CopyRect(lprcClipRect, lprcPosRect);

    lpFrameInfo->cb             = sizeof(OLEINPLACEFRAMEINFO);
    lpFrameInfo->fMDIApp        = FALSE;
    lpFrameInfo->hwndFrame      = m_hwnd;
    lpFrameInfo->haccel         = 0;
    lpFrameInfo->cAccelEntries  = 0;

//~    (*ppFrame)->AddRef();
    return S_OK;
}

HRESULT CContainer::Scroll(SIZE scrollExtent)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnUIDeactivate(BOOL fUndoable)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnInPlaceDeactivate(void)
{
    return S_OK;
}

HRESULT CContainer::DiscardUndoState(void)
{
    return E_NOTIMPL;
}

HRESULT CContainer::DeactivateAndUndo(void)
{
    return E_NOTIMPL;
}

HRESULT CContainer::OnPosRectChange(LPCRECT lprcPosRect)
{
    return S_OK;
}

// ***********************************************************************
//  IOleInPlaceUIWindow
// ***********************************************************************

HRESULT CContainer::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT CContainer::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IOleInPlaceFrame
// ***********************************************************************

HRESULT CContainer::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return E_NOTIMPL;
}

HRESULT CContainer::RemoveMenus(HMENU hmenuShared)
{
    return E_NOTIMPL;
}

HRESULT CContainer::SetStatusText(LPCOLESTR pszStatusText)
{
    char status[MAX_PATH];              // ansi version of status text

    if (NULL == pszStatusText)
        return E_POINTER;

    WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, status, MAX_PATH, NULL, NULL);

    if (IsWindow(m_hwndStatus))
        SendMessage(m_hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)status);

    return (S_OK);
}

HRESULT CContainer::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT CContainer::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    return S_FALSE;
}

// ***********************************************************************
//  IOleControlSite
// ***********************************************************************

HRESULT CContainer::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT CContainer::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetExtendedControl(IDispatch **ppDisp)
{
    if (ppDisp == NULL)
        return E_INVALIDARG;

    *ppDisp = (IDispatch *)this;
    (*ppDisp)->AddRef();

    return S_OK;
}

HRESULT CContainer::TransformCoords(POINTL *pptlHimetric, POINTF *pptfContainer, DWORD dwFlags)
{
    return E_NOTIMPL;
}

HRESULT CContainer::TranslateAccelerator(LPMSG pMsg, DWORD grfModifiers)
{
    return S_FALSE;
}

HRESULT CContainer::OnFocus(BOOL fGotFocus)
{
    return E_NOTIMPL;
}

HRESULT CContainer::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}

// ***********************************************************************
//  IDispatch
// ***********************************************************************

HRESULT CContainer::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)
{
    *rgdispid = DISPID_UNKNOWN;
    return DISP_E_UNKNOWNNAME;
}

HRESULT CContainer::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    return E_NOTIMPL;
}

HRESULT CContainer::GetTypeInfoCount(unsigned int FAR * pctinfo)
{
    return E_NOTIMPL;
}

HRESULT CContainer::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR *pdispparams, VARIANT FAR *pvarResult, EXCEPINFO FAR * pexecinfo, unsigned int FAR *puArgErr)
{
    return DISP_E_MEMBERNOTFOUND;
}

// ***********************************************************************
//  IOleCommandTarget
// ***********************************************************************

HRESULT CContainer::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD  rgCmds[  ], OLECMDTEXT *pCmdText)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    const int SBCMDID_ADDTOFAVORITES = 8;

#if 0
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (ULONG i=0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {            
            case SBCMDID_ADDTOFAVORITES:
                rgCmds[i].cmdf = OLECMDF_ENABLED | OLECMDF_SUPPORTED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
        hres = S_OK;
    }
#endif
    return hres;
}

HRESULT CContainer::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
    HRESULT hres = OLECMDERR_E_UNKNOWNGROUP;
    const int SBCMDID_ADDTOFAVORITES = 8;

#if 0
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SBCMDID_ADDTOFAVORITES:
            TCHAR szURL[2048];
            TCHAR szTitle[MAX_PATH];
            WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, szURL, sizeof(szURL), NULL, NULL);
            WideCharToMultiByte(CP_ACP, 0, pvaOut->bstrVal, -1, szTitle, sizeof(szTitle), NULL, NULL);
            MessageBox(m_hwnd, 
                szURL,
                szTitle,
                MB_OK);
            hres = S_OK;
            break;
        }
    }
#endif
    return hres;
}

// ***********************************************************************
//  Public (non-interface) Methods
// ***********************************************************************

/**
 *  This method will add an ActiveX control to the container. Note, for
 *  now, this CContainer can only have one control.
 *
 *  @param  bstrClsid   The CLSID or PROGID of the control.
 *
 *  @return     HRESULT     S_OK, E_POINTER, E_NOINTERFACE
 */
HRESULT CContainer::add(BSTR bstrClsid)
{
    CLSID   clsid;          // CLSID of the control object
    HRESULT hr;             // return code

    hr = CLSIDFromString(bstrClsid, &clsid);
	if (FAILED(hr))
		return hr;

    hr = CoCreateInstance(clsid, 
                     NULL, 
                     CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                     IID_IUnknown,
                     (PVOID *)&m_punk);
    if (FAILED(hr))
		return hr;
	
	ASSERT(NULL != m_punk);

    IOleObject *pioo;
    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return hr;

    pioo->SetClientSite(this);
    pioo->Release();

    IPersistStreamInit  *ppsi;
    hr = m_punk->QueryInterface(IID_IPersistStreamInit, (PVOID *)&ppsi);
    if (SUCCEEDED(hr))
    {
        ppsi->InitNew();
        ppsi->Release();
    }

	return hr;
}

/**
 *  This method will remove the control from the container.
 *
 *  @return             No return value.
 */
void CContainer::remove()
{
    if (!m_punk)
        return;

    HRESULT             hr;
    IOleObject          *pioo;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (SUCCEEDED(hr))
    {
        pioo->Close(OLECLOSE_NOSAVE);
        pioo->SetClientSite(NULL);
        pioo->Release();
    }

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (SUCCEEDED(hr))
    {
        pipo->UIDeactivate();
        pipo->InPlaceDeactivate();
        pipo->Release();
    }

    m_punk->Release();
    m_punk = NULL;
}

/**
 *  This method sets the parent window. This is used by the container
 *  so the control can parent itself.
 *
 *  @param  hwndParent  The parent window handle.
 *
 *  @return             No return value.
 */
void CContainer::setParent(HWND hwndParent)
{
    m_hwnd = hwndParent;
}

/**
 *  This method will set the location of the control.
 *  
 *  @param      x       The top left.
 *  @param      y       The top right.
 *  @param      width   The width of the control.
 *  @param      height  The height of the control.
 */
void CContainer::setLocation(int x, int y, int width, int height)
{
    m_rect.left     = x;
    m_rect.top      = y;
    m_rect.right    = x + width;
    m_rect.bottom   = y + height;

    if (!m_punk)
        return;

    HRESULT             hr;
    IOleInPlaceObject   *pipo;

    hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
    if (FAILED(hr))
        return;

    pipo->SetObjectRects(&m_rect, &m_rect);
    pipo->Release();
}



HRESULT CContainer::InPlaceActivate( void )
{

    HRESULT hr = E_FAIL;

    if( m_punk )
    {

        CComQIPtr< IOleObject, &IID_IOleObject > spioo( m_punk );

        if( spioo != NULL )
        {
            spioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
            spioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, &m_rect);
            
        }
    }

    return hr;
    
}


/**
 *  Sets the visible state of the control.
 *
 *  @param  fVisible    TRUE=visible, FALSE=hidden
 *  @return             No return value.
 */
void CContainer::setVisible(BOOL fVisible)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
    if (FAILED(hr))
        return;
    
    if (fVisible)
    {
        pioo->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->DoVerb(OLEIVERB_SHOW, NULL, this, 0, m_hwnd, &m_rect);

		IOleInPlaceObject   *pipo;
		HRESULT hr = m_punk->QueryInterface(IID_IOleInPlaceObject, (PVOID *)&pipo);
		if (SUCCEEDED(hr))
		{
			pipo->SetObjectRects(&m_rect, &m_rect);
			pipo->Release();
		}
    }
    else
        pioo->DoVerb(OLEIVERB_HIDE, NULL, this, 0, m_hwnd, NULL);

    pioo->Release();
}

/**
 *  This sets the focus to the control (a.k.a. UIActivate)
 *
 *  @param  fFocus      TRUE=set, FALSE=remove
 *
 *  @return             No return value.
 */
void CContainer::setFocus(BOOL fFocus)
{
    if (!m_punk)
        return;

    HRESULT     hr;
    IOleObject  *pioo;

    if (fFocus)
    {
        hr = m_punk->QueryInterface(IID_IOleObject, (PVOID *)&pioo);
        if (FAILED(hr))
            return;

        pioo->DoVerb(OLEIVERB_UIACTIVATE, NULL, this, 0, m_hwnd, &m_rect);
        pioo->Release();
    }
}

/**
 *  If the container has an HWND for the status window (must be
 *  common control), then this method is used to tell the container.
 *
 *  @param  hwndStatus  Window handle of the status bar.
 *
 *  @return             No return value.
 */
void CContainer::setStatusWindow(HWND hwndStatus)
{
    m_hwndStatus = hwndStatus;
}

/**
 *  This method gives the control the opportunity to translate and use
 *  key strokes.
 *
 *  @param      msg     Key message.
 *
 *  @return             No return value.
 */
HRESULT CContainer::translateKey(MSG *pmsg)
{
    if (!m_punk)
        return E_FAIL;

    HRESULT                 hr;
    IOleInPlaceActiveObject *pao;

    hr = m_punk->QueryInterface(IID_IOleInPlaceActiveObject, (PVOID *)&pao);
    if (FAILED(hr))
        return hr;

    hr = pao->TranslateAccelerator(pmsg);
    pao->Release();
    return hr;
}

/**
 *  Returns the IDispatch pointer of the contained control. Note, the
 *  caller is responsible for calling IDispatch::Release().
 *
 *  @return             Controls dispatch interface.
 */
IDispatch * CContainer::getDispatch()
{
    if (!m_punk)
        return NULL;

    HRESULT     hr;
    IDispatch   *pdisp;

    hr = m_punk->QueryInterface(IID_IDispatch, (PVOID *)&pdisp);
    return pdisp;
}

/**
 *  Returns the IUnknown interface pointer for the containd control. Note,
 *  the caller is responsible for calling IUnknown::Release().
 *
 *  @return             Controls unknown interface.
 */
IUnknown * CContainer::getUnknown()
{
    if (!m_punk)
        return NULL;

    m_punk->AddRef();
    return m_punk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\makefile.inc ===
#That forces BUILD.EXE to rebuild the rc file when the .rgs files change
nmctl1.rc:  CompWnd.rgs NMChatCtl.rgs ContainerControl.rgs NmApp.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\marshalableti.h ===
// MarshalableTI.h : Declaration of the CMarshalableTI

#ifndef __MARSHALABLETI_H_
#define __MARSHALABLETI_H_

#include "MarshalableTI.h"
#include "mslablti.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMarshalableTI
class ATL_NO_VTABLE CMarshalableTI : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMarshalableTI, &CLSID_MarshalableTI>,
	public IMarshalableTI,
	public IMarshal,
	public ITypeInfo
{
private:
	CComTypeInfoHolder	m_TIHolder;
	GUID				m_guid;
	GUID				m_libid;
	LCID				m_lcid;
	bool				m_bCreated;

public:
	

DECLARE_REGISTRY_RESOURCEID(IDR_MSLABLTI)
DECLARE_NOT_AGGREGATABLE(CMarshalableTI)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshalableTI)
	COM_INTERFACE_ENTRY(IMarshal)
	COM_INTERFACE_ENTRY(ITypeInfo)
END_COM_MAP()

	HRESULT FinalConstruct();

/////////////////////////////////////////////////////////////////////////////////
// IMarshalableTI methods

	STDMETHOD(Create)(/*[in]*/ REFIID clsid, 
					  /*[in]*/ REFIID iidLib, 
					  /*[in]*/ LCID lcid,
					  /*[in]*/ WORD dwMajorVer, 
					  /*[in]*/ WORD dwMinorVer);

/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid);

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize);

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags);

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm);

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved);

/////////////////////////////////////////////////////////////////////////////////
// ITypeInfo methods

    STDMETHOD(GetTypeAttr)(
                TYPEATTR ** ppTypeAttr);

    STDMETHOD(GetTypeComp)(
                ITypeComp ** ppTComp);

    STDMETHOD(GetFuncDesc)(
                UINT index,
                FUNCDESC ** ppFuncDesc);

    STDMETHOD(GetVarDesc)(
                UINT index,
                VARDESC ** ppVarDesc);

    STDMETHOD(GetNames)(
                MEMBERID memid,
                BSTR * rgBstrNames,
                UINT cMaxNames,
                UINT * pcNames);


    STDMETHOD(GetRefTypeOfImplType)(
                UINT index,
                HREFTYPE * pRefType);

    STDMETHOD(GetImplTypeFlags)(
                UINT index,
                INT * pImplTypeFlags);


    STDMETHOD(GetIDsOfNames)(
                LPOLESTR * rgszNames,
                UINT cNames,
                MEMBERID * pMemId);

    STDMETHOD(Invoke)(
                PVOID pvInstance,
                MEMBERID memid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr);

    STDMETHOD(GetDocumentation)(
                MEMBERID memid,
                BSTR * pBstrName,
                BSTR * pBstrDocString,
                DWORD * pdwHelpContext,
                BSTR * pBstrHelpFile);


    STDMETHOD(GetDllEntry)(
                MEMBERID memid,
                INVOKEKIND invKind,
                BSTR * pBstrDllName,
                BSTR * pBstrName,
                WORD * pwOrdinal);


    STDMETHOD(GetRefTypeInfo)(
                HREFTYPE hRefType,
                ITypeInfo ** ppTInfo);


    STDMETHOD(AddressOfMember)(
                MEMBERID memid,
                INVOKEKIND invKind,
                PVOID * ppv);

    STDMETHOD(CreateInstance)(
                IUnknown * pUnkOuter,
                REFIID riid,
                PVOID * ppvObj);


    STDMETHOD(GetMops)(
                MEMBERID memid,
                BSTR * pBstrMops);


    STDMETHOD(GetContainingTypeLib)(
                ITypeLib ** ppTLib,
                UINT * pIndex);

    STDMETHOD_(void, ReleaseTypeAttr)(
                TYPEATTR * pTypeAttr);

    STDMETHOD_(void, ReleaseFuncDesc)(
                FUNCDESC * pFuncDesc);

    STDMETHOD_(void, ReleaseVarDesc)(
                VARDESC * pVarDesc);


private:
	HRESULT _GetClassInfo(ITypeInfo** ppTI);
};

#endif //__MARSHALABLETI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\cpnmagendaitemnotify.h ===
//////////////////////////////////////////////////////////////////////////////
// CProxyINmAgendaItemNotify
template <class T>
class CProxyINmAgendaItemNotify : public IConnectionPointImpl<T, &DIID_INmAgendaItemNotify, CComDynamicUnkArray>
{
public:
//methods:
//INmAgendaItemNotify : IDispatch
public:

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\message.h ===
#ifndef _Message_h_
#define _Message_h_

#define MSG_IN			1
#define MSG_PRIVATE		2
#define MSG_SYS			4

#define INITIAL_LIMIT	500

class CChatMessage
{
	public:
	typedef enum eMsgTypes
	{
		MSG_SYSTEM = MSG_SYS,
		MSG_SAY = ~MSG_IN & ~MSG_PRIVATE,
		MSG_WHISPER = ~MSG_IN & MSG_PRIVATE,
		MSG_FROM_OTHER = MSG_IN & ~MSG_PRIVATE,
		MSG_WHISPER_FROM_OTHER = MSG_IN | MSG_PRIVATE
	} CHAT_MSGTYPE;

	private:
		static CChatMessage *ms_pFirst;
		static int          ms_cMessages;
		static CChatMessage *ms_pLast;
		static int			ms_iMessageLimit;

	private:
		LPTSTR m_szDate;
		LPTSTR m_szTime;
		LPTSTR m_szPerson;
		LPTSTR m_szMessage;
		CHAT_MSGTYPE m_msgType;
		
		CChatMessage *m_pNext;
		CChatMessage *m_pPrev;

	public:
		static CChatMessage *get_head();
		static int get_count();
		static CChatMessage *get_last();
		static void DeleteAll();
		static int get_limit();
		static void put_limit( int iLimit );

		BOOL inline IsPrivate()
		{
			return m_msgType & MSG_PRIVATE;
		}

		BOOL inline IsIncoming()
		{
			return m_msgType & MSG_IN;
		}

		BOOL inline IsValid()
		{
			return (m_szPerson != NULL) && (m_szMessage != NULL);
		}

	public:
		CChatMessage *get_next() const;
		CChatMessage *get_prev() const;
		CChatMessage::CHAT_MSGTYPE get_type() const;
		const LPTSTR get_date() const;
		const LPTSTR get_time() const;
		const LPTSTR get_person() const;
		const LPTSTR get_message() const;
		CChatMessage( LPCTSTR szPerson, LPCTSTR szMessage, CHAT_MSGTYPE msgType );
		~CChatMessage();

	private:
		LPTSTR _CopyString( LPCTSTR sz );
		void _GetDate();
		void _GetTime();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmagendaitemproppage.h ===
// NmAgendaItemPropPage.h : Declaration of the CNmAgendaItemPropPage

#ifndef __NMAGENDAITEMPROPPAGE_H_
#define __NMAGENDAITEMPROPPAGE_H_

#include "resource.h"       // main symbols

EXTERN_C const CLSID CLSID_NmAgendaItemPropPage;

/////////////////////////////////////////////////////////////////////////////
// CNmAgendaItemPropPage
class ATL_NO_VTABLE CNmAgendaItemPropPage :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmAgendaItemPropPage, &CLSID_NmAgendaItemPropPage>,
	public IPropertyPageImpl<CNmAgendaItemPropPage>,
	public CDialogImpl<CNmAgendaItemPropPage>
{
public:
    bool m_bInitialized;

	CNmAgendaItemPropPage() 
	{
		m_dwTitleID = IDS_TITLENmAgendaItemPropPage;
		m_dwHelpFileID = IDS_HELPFILENmAgendaItemPropPage;
		m_dwDocStringID = IDS_DOCSTRINGNmAgendaItemPropPage;
        m_bInitialized = false;
	}

	enum {IDD = IDD_PROPPAGE_AGENDAITEM};

DECLARE_REGISTRY_RESOURCEID(IDR_NMAGENDAITEMPROPPAGE)
DECLARE_NOT_AGGREGATABLE(CNmAgendaItemPropPage)

BEGIN_COM_MAP(CNmAgendaItemPropPage) 
	COM_INTERFACE_ENTRY_IMPL(IPropertyPage)
END_COM_MAP()

BEGIN_MSG_MAP(CNmAgendaItemPropPage)
    MESSAGE_HANDLER( WM_INITDIALOG, OnInitDialog );
	CHAIN_MSG_MAP(IPropertyPageImpl<CNmAgendaItemPropPage>)
    COMMAND_HANDLER(IDC_EDITAGENDAITEMNAME, EN_CHANGE, OnAgendaItemNameChange)
END_MSG_MAP()

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAgendaItemNameChange(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled);

	STDMETHOD(Apply)(void);
};


#endif //__NMAGENDAITEMPROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmagendaitemproppage.cpp ===
// NmAgendaItemPropPage.cpp : Implementation of CNmAgendaItemPropPage
#include "precomp.h"
#include "resource.h"
#include "NmCtl1.h"
#include "NmAgendaHelper.h"
#include "NmAgendaItemPropPage.h"

/////////////////////////////////////////////////////////////////////////////
// CNmAgendaItemPropPage


STDMETHODIMP CNmAgendaItemPropPage::Apply(void)
{
	DBGENTRY(CNmAgendaItemPropPage::Apply);
    HRESULT hr = S_OK;

	for (UINT i = 0; i < m_nObjects; i++)
	{
        CComQIPtr<INmAgendaItem,&IID_INmAgendaItem> pNmAgendaItem( m_ppUnk[i] );
        if( pNmAgendaItem )
        {
            HWND hEditName = GetDlgItem( IDC_EDITAGENDAITEMNAME );
            if( hEditName )
            {
                int cbLen = 1 + ::GetWindowTextLength( hEditName );

                if( cbLen > 1 )
                {
                    TCHAR* sz = new TCHAR[ cbLen ];

                    if( ::GetWindowText( hEditName, sz, cbLen ) )
                    {
                        hr = pNmAgendaItem->put_Name( CComBSTR( sz ) );

                        if( FAILED( hr ) )
                        {
                            WARNING_OUT(("put_Name Failed"));
                        }
                    }

                    delete [] sz;
                }
            }
        }
	}

	m_bDirty = FALSE;
    
    DBGEXIT_HR(CNmAgendaItemPropPage::Apply, hr);
	return hr;
}

LRESULT CNmAgendaItemPropPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT lr = TRUE;
    
    USES_CONVERSION;

    DBGENTRY(CNmAgendaItemPropPage::OnInitDialog);

    if( m_nObjects > 0 )
    {
        CComQIPtr<INmAgendaItem,&IID_INmAgendaItem> pNmAgendaItem( m_ppUnk[0] );
        if( pNmAgendaItem )
        {   
            BSTR bstrName;
            if( SUCCEEDED( pNmAgendaItem->get_Name( &bstrName ) ) )
            {
                SetDlgItemText( IDC_EDITAGENDAITEMNAME, W2T( bstrName ) );

                NmAgendaItemType Type;
                if( SUCCEEDED( pNmAgendaItem->get_Type( &Type ) ) )
                {
                    SetDlgItemText( IDC_EDITAGENDAITEMTYPE, NmAgendaItemTypeToa( Type ) );
                }
            }
        }
    }
    m_bDirty = FALSE;

    m_bInitialized = true;

    DBGEXIT_ULONG(CNmAgendaItemPropPage::OnInitDialog, lr);
    return lr;
}

LRESULT CNmAgendaItemPropPage::OnAgendaItemNameChange(WORD wNotify, WORD wID, HWND hWnd, BOOL& bHandled)
{
    DBGENTRY(CNmAgendaItemPropPage::OnAgendaItemNameChange);
    
    if( m_bInitialized )
    {
        SetDirty( TRUE );
    }
    
    DBGEXIT(CNmAgendaItemPropPage::OnAgendaItemNameChange);
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmchatctl.cpp ===
// NmChatCtl.cpp : Implementation of CNmChatCtl
#include "precomp.h"
#include "NmCtl1.h"
#include "NmChatCtl.h"
#include "ComboBoxEx.h"
#include "Message.h"
#include "OprahCom.h"
#include <version.h>

#include <nmhelp.h>
#include <help_ids.h>

extern CChatObj	*g_pChatObj;
extern DWORD    g_dwWorkThreadID;

// Class name
TCHAR szMainClassName[] = "ChatMainWindowClass";

static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmchat.chm");

void ShiftFocus(HWND hwndTop, BOOL bForward);

static const DWORD _mpIdHelpChatOptions[] = {
		// Information display group
	IDR_MESSAGE_GROUP,				IDH_CHAT_FORMAT_HEADER,
	IDC_INCLUDE_NAME, 				IDH_CHAT_NAME,
	IDC_INCLUDE_DATE, 				IDH_CHAT_DATE,
	IDC_INCLUDE_TIME, 				IDH_CHAT_TIME,
		
		// Message Format group
	IDC_HEADER_GROUP,				IDH_CHAT_FORMAT_MESSAGE,
	IDR_SINGLE_LINE,				IDH_CHAT_FORMAT_MESSAGE,
	IDR_SAME_LINE,					IDH_CHAT_FORMAT_MESSAGE,
	IDR_NEW_LINE,					IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATSINGLE,				IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATWRAP,				    IDH_CHAT_FORMAT_MESSAGE,
	IDC_FORMATWRAPNEW,				IDH_CHAT_FORMAT_MESSAGE,

		// Font buttons and edit controls
	IDC_FONTS_GROUP,				IDH_CHAT_FONTS_LABEL,
	IDC_FONT_MSGIN,					IDH_CHAT_RECEIVE_MSG,
	IDC_EDIT_MSGIN,					IDH_CHAT_FONT,
	IDC_FONT_PRIVATEIN,				IDH_CHAT_RECEIVE_PRIV,
	IDC_EDIT_PRIVATEIN,				IDH_CHAT_FONT,
	IDC_FONT_MSGOUT,				IDH_CHAT_SENT_MSG,
	IDC_EDIT_MSGOUT,				IDH_CHAT_FONT,
	IDC_FONT_PRIVATEOUT,			IDH_CHAT_SENT_PRIV,
	IDC_EDIT_PRIVATEOUT,			IDH_CHAT_FONT,

		// terminator
	0, 0
};

// Option entry names
#define OPT_MAIN_INFORMATION_DISPLAY_NAME     "Information Display Name"
#define OPT_MAIN_INFORMATION_DISPLAY_TIME	  "Information Display Time"
#define OPT_MAIN_INFORMATION_DISPLAY_DATE	  "Information Display Date"
#define OPT_MAIN_MESSAGE_FORMAT          "Message format"
const LPTSTR OPT_FONT_FORMAT[] = {"Received Message", "Received Private Messages",
	"Send Messages",  "Send Private Messages",  "System Format"};
const LPTSTR OPT_FONT_COLOR[] = {"Received Message Color", "Received Private Messages Color",
	"Send Messages Color",  "Send Private Messages Color",  "System Format Color"};


extern CNmChatCtl	*g_pChatWindow;
CNmChatCtl *CNmChatCtl::ms_pThis = NULL;
WORD	CChatOptionsDlg::IDD = IDD_CHAT_OPTIONS;

///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl Construction and initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////

CNmChatCtl::CNmChatCtl( void )
        :   m_hWndMsg( NULL ),
            m_himlIconSmall( NULL ),
            m_cOtherMembers( 0 ),
            m_hMenuShared(NULL),
			m_cchBufferSize( 0 ),
			m_hInstRichEd32( NULL ),
			m_bUseName( -1 ),
			m_bTimeStamp( 0 ),
			m_bUseDate( 0 ),
			m_style( MSGSTYLE_2_LINE_WRAP ),
			m_lpszOwnName( NULL ),
			m_iNameLen( 0 ),
			m_iStaticLen( 0 ),
			m_iDLGUX( 0 ),
			m_iDLGUY( 0 ),
			m_iStaticY( 0 ),
			m_iExtra( 0 ),
			m_szTo( NULL ),
			m_szPrivate( NULL ),
            m_bWeAreActiveApp(false),
			m_dwChatFlags( CHAT_FLAG_NONE ),
			m_hWndPrint( NULL ),
			m_lpszSaveFile( NULL ),
			m_bStatusBarVisible( TRUE ),
			m_wFileOffset( 0 ),
			m_lpszRichEdEOL( NULL ),
			m_lpszRichEd( NULL ),
			m_pChatOptions( NULL ),
			m_cMessages( 0 )
{
	DBGENTRY(CNmChatCtl::CNmChatCtl);


	g_pChatWindow = this;

	// Ensure the common controls are loaded
	INITCOMMONCONTROLSEX icc;
	icc.dwSize = sizeof(icc);
	icc.dwICC = ICC_WIN95_CLASSES | ICC_COOL_CLASSES | ICC_USEREX_CLASSES;
	::InitCommonControlsEx(&icc);

	_LoadIconImages();
	_InitFontsAndColors();

	//
	// CREATE THE MAIN FRAME WINDOW
	//

	//
	// Get the class info for it, and change the name.
	//
	WNDCLASSEX  wc;
	ZeroMemory(&wc, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
	wc.lpfnWndProc      = ChatMainWindowProc;
	wc.hInstance        = g_hInstance;
	wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(CHAT_ICON));
	wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
	wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_CHAT_WITHFILE);
	wc.lpszClassName    = szMainClassName;

	if (!::RegisterClassEx(&wc))
	{
		ERROR_OUT(("Can't register private frame window class"));
	}

	TCHAR szCaption[MAX_PATH * 2];
   	::LoadString(g_hInstance, IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION, szCaption, sizeof(szCaption) );

	m_hWnd = ::CreateWindow(
                    szMainClassName,
                    szCaption,
                    WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_CLIPCHILDREN | WS_TABSTOP,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL,   // no parent window
                    NULL,   // use class' menu
                    g_hInstance,
                    (LPVOID) this);  // this window is for this object


	m_hMenuShared = ::GetMenu(m_hWnd);

    ASSERT(m_hWnd);

	DBGEXIT(CNmChatCtl::CNmChatCtl);
}

CNmChatCtl::~CNmChatCtl( void )
{
	DBGENTRY(CNmChatCtl::~CNmChatCtl);

	delete [] m_lpszOwnName;
	delete [] m_szTo;
	delete [] m_szPrivate;
	delete [] m_lpszSaveFile;
	delete [] m_lpszRichEdEOL;
	delete [] m_lpszRichEd;

	if( NULL != m_hInstRichEd32 )
		FreeLibrary( m_hInstRichEd32 );

	CChatMessage::DeleteAll();

	m_pButton->Release();

	_DeleteFonts();
	_FreeIconImages();
	
	delete m_pChatOptions;

	DBGEXIT(CNmChatCtl::~CNmChatCtl);
}




//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL CNmChatCtl::FilterMessage(MSG* pMsg)
{
    return (   (m_hAccelTable != NULL)
          && ::TranslateAccelerator(m_hWnd, m_hAccelTable, pMsg));
}


//
// ChatMainWindowProc()
// Frame window message handler
//
LRESULT CNmChatCtl::ChatMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	LRESULT lResult = 0;
	CNmChatCtl * pMain;
	LPWINDOWPOS pos;
	
	pMain = (CNmChatCtl *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

	switch (message)
	{

		case WM_NCCREATE:
			pMain = (CNmChatCtl *)((LPCREATESTRUCT)lParam)->lpCreateParams;
			ASSERT(pMain);
			pMain->m_hWnd = hwnd;
			::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
			pMain->OnCreate(wParam,lParam);
			goto DefWndProc;
			break;

		case WM_CREATE:
			::SetFocus(pMain->m_hWndEdit);
			break;
			
		case WM_NCDESTROY:
			pMain->m_hWnd = NULL;
			break;

		case WM_MENUSELECT:
			pMain->OnMenuSelect((DWORD)wParam, (DWORD)lParam);
			break;
		
		case WM_INITMENUPOPUP:
			pMain->OnInitMenuPopup((DWORD)wParam, (DWORD)lParam);
			break;

		case WM_ENDSESSION:
		case WM_CLOSE:
			pMain->cmdFileExit(wParam);
			break;

		case WM_COMMAND:
			pMain->OnCommand((DWORD)wParam, (DWORD)lParam);
			break;

		case WM_CONTEXTMENU:
			pMain->OnContextMenu((short)LOWORD(lParam), (short)HIWORD(lParam));
			break;


		case WM_SIZE:
			pMain->_Resize(0, 0, (short)LOWORD(lParam), (short)HIWORD(lParam));
			break;

		case WM_GETMINMAXINFO:
			if (pMain)
			{
				pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
			}
			break;

		case WM_USER_BRING_TO_FRONT_WINDOW:
			pMain->BringToFront();
			break;

		case WM_ACTIVATE:
			if (WA_INACTIVE != LOWORD(wParam) && IsWindowVisible(pMain->m_hWndEdit))
			{
				::SetFocus(pMain->m_hWndEdit);
			}
			break;

		case WM_NOTIFY:
			if(EN_LINK == ((LPNMHDR)lParam)->code)
			{
				pMain->OnNotifyEnLink((ENLINK*)lParam);
			}
			break;

		default:

DefWndProc:
			lResult = ::DefWindowProc(hwnd, message, wParam, lParam);
			break;
	}

	return(lResult);
}



void CNmChatCtl::BringToFront(void)
{
    if (NULL != m_hWnd)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hWnd, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hWnd, nCmdShow);

        // bring it to the foreground
        ::SetForegroundWindow(m_hWnd);

		//
		// Set the focus on the edit box
		//
        ::SetFocus(m_hWndEdit);
    }
}




///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl Window message and command handlers
///////////////////////////////////////////////////////////////////////////////////////////////////////

LRESULT CNmChatCtl::OnCreate(WPARAM wParam, LPARAM lParam)
{
	DBGENTRY(CNmChatCtl::OnCreate);

	RECT rc;
	SetRect( &rc, 0, 0, 0, 0 );
	TCHAR szRes[MAX_PATH];
	BOOL fRet = FALSE;

	if( NULL == ( m_hInstRichEd32 = NmLoadLibrary( "RICHED20.DLL" ,TRUE) ) )
	{
		if( NULL == ( m_hInstRichEd32 = NmLoadLibrary( "RICHED32.DLL" ,TRUE) ) )
		{
			goto Cleanup;
		}
		else
		{
			LPTSTR szValue = TEXT("RichEdit");
			LPTSTR szValueEOL = TEXT("\r\n");
			DBG_SAVE_FILE_LINE
			m_lpszRichEd = new TCHAR[ lstrlen( szValue ) + 1 ];
			if(m_lpszRichEd  == NULL)
			{
				goto Cleanup;
			}
 			lstrcpy( m_lpszRichEd, szValue );

			m_lpszRichEdEOL = new TCHAR[ lstrlen( szValueEOL ) + 1 ];
			if(m_lpszRichEdEOL  == NULL)
			{
				goto Cleanup;
			}
			lstrcpy( m_lpszRichEdEOL, szValueEOL );
		}
	}
	else
	{
			LPTSTR szValue = RICHEDIT_CLASS;
			LPTSTR szValueEOL = TEXT(" \r");
			DBG_SAVE_FILE_LINE
			m_lpszRichEd = new TCHAR[ lstrlen( szValue ) + 1 ];
			if(m_lpszRichEd  == NULL)
			{
				goto Cleanup;
			}
 			lstrcpy( m_lpszRichEd, szValue );

			DBG_SAVE_FILE_LINE
			m_lpszRichEdEOL = new TCHAR[ lstrlen( szValueEOL ) + 1 ];
 			if(m_lpszRichEdEOL  == NULL)
			{
				goto Cleanup;
			}
			lstrcpy( m_lpszRichEdEOL, szValueEOL );
	}

	////////// Edit control
    m_hWndEdit = ::CreateWindowEx(WS_EX_CLIENTEDGE,
								    _T("EDIT"),
									NULL,
								    WS_CHILD | WS_BORDER | WS_VISIBLE |
								    WS_TABSTOP | ES_MULTILINE | ES_AUTOVSCROLL,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage( m_hWndEdit, WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT ), TRUE);
	::SendMessage( m_hWndEdit, EM_LIMITTEXT, CCHMAX_CHAT_MSG - 1, 0 );
	::SendMessage( m_hWndEdit, EM_EXLIMITTEXT, 0, CCHMAX_CHAT_MSG - 1 );

	//// Get info from edit control
	TEXTMETRIC textmex;
	ZeroMemory( &textmex, sizeof( textmex ) );
	HDC hdc = GetDC(m_hWndEdit);
	GetTextMetrics( hdc, &textmex );
	ReleaseDC(m_hWndEdit, hdc );

	m_iDLGUY = PIX_FROM_DLGU_Y( 1, textmex.tmHeight );
	m_iDLGUX = PIX_FROM_DLGU_X( 1, textmex.tmAveCharWidth);


	////////// Send Button
	DBG_SAVE_FILE_LINE
	m_pButton = new CBitmapButton();
	if(m_pButton)
	{

		if(FALSE == m_pButton->Create(m_hWnd,
								IDI_SENDBUTTON,
								g_hInstance,
								IDB_SENDCHAT,
								TRUE,
								CBitmapButton::Disabled,
								1,
								NULL))
		{
			m_pButton->Release();
			goto Cleanup;
		}
	
        m_hWndSend = m_pButton->GetWindow();								
        m_pButton->SetTooltip((LPSTR)IDS_TOOLTIP_SEND_MESSAGE);
        m_pButton->SetWindowtext(RES2T(IDS_TOOLTIP_SEND_MESSAGE, szRes));
	}
	else
	{
		goto Cleanup;
	}


	////////// Member List
    m_hWndMemberList = ::CreateWindowEx(0,
									_T(WC_COMBOBOXEX),
									NULL,
									WS_VISIBLE | WS_CHILD | CBS_DROPDOWNLIST | WS_TABSTOP | WS_VSCROLL,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);


	ASSERT( m_himlIconSmall );

	::SendMessage(m_hWndMemberList, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);
	ComboBoxEx_SetImageList( m_hWndMemberList, m_himlIconSmall );

	int yFrameBorder = GetSystemMetrics( SM_CYFIXEDFRAME );
	int ySpace = GetSystemMetrics( SM_CYBORDER );
	int iHeight = ComboBoxEx_GetItemHeight( m_hWndMemberList, 0 );
	ComboBoxEx_SetHeight( m_hWndMemberList, ((iHeight + ySpace) * MSGLIST_VISMEMBERS) + yFrameBorder);





	////////// Status bar
   RECT    clientRect;
	::GetClientRect(m_hWnd, &clientRect);
	m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
		WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
		CCS_NORESIZE | SBARS_SIZEGRIP,
		clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
		(clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
		m_hWnd, 0, g_hInstance, NULL);

	if (!m_hwndSB)
	{
		ERROR_OUT(("Failed to create status bar window"));
		goto Cleanup;
	}


	////////// Static
	TCHAR szBuff[ MAX_PATH ];
	NmCtlLoadString( IDS_CHAT_MESSAGE, szBuff, CCHMAX(szBuff));
    m_hWndStaticMessage = ::CreateWindowEx(0,
									_T("STATIC"),
									szBuff,
									WS_VISIBLE | WS_CHILD | SS_LEFT,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage(m_hWndStaticMessage, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);


	////////// Static
	NmCtlLoadString( IDS_CHAT_SENDTO, szBuff, CCHMAX(szBuff));
    m_hWndStaticSendTo = ::CreateWindowEx(0,
									_T("STATIC"),
									szBuff,
									WS_VISIBLE | WS_CHILD | SS_LEFT,
									CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
							        m_hWnd, NULL, g_hInstance, NULL);

	::SendMessage(m_hWndStaticSendTo, WM_SETFONT, (WPARAM)GetStockObject( DEFAULT_GUI_FONT ), TRUE);



	////// Get info for static controls
	hdc = ::GetDC(m_hWndStaticMessage);
	GetTextMetrics( hdc, &textmex );

	TCHAR szBuffer[ MAX_PATH ];

	GetWindowText(m_hWndStaticMessage, szBuffer, CCHMAX( szBuffer ) );
	RECT rect1;
	ZeroMemory( &rect1, sizeof( rect1 ) );
	DrawText( hdc, szBuffer, lstrlen( szBuffer ), &rect1, DT_CALCRECT );

	GetWindowText(m_hWndStaticSendTo, szBuffer, CCHMAX( szBuffer ) );
	RECT rect2;
	ZeroMemory( &rect2, sizeof( rect2 ) );
	DrawText( hdc, szBuffer, lstrlen( szBuffer ), &rect1, DT_CALCRECT );
	
	ReleaseDC(m_hWndStaticMessage, hdc );

	m_iStaticLen = max( rect1.right, rect2.right );
	m_iStaticY = max( rect1.bottom, rect2.bottom );

	_UpdateContainerCaption();
	put_MsgStyle( m_style );
	_LoadStrings();

	HICON hIconSmall = (HICON)LoadImage(
							  g_hInstance,   // handle of the instance containing the image
							  MAKEINTRESOURCE( CHAT_ICON ),  // name or identifier of image
							  IMAGE_ICON,        // type of image
							  ICON_SMALL_SIZE,     // desired width
							  ICON_SMALL_SIZE,     // desired height
							  LR_DEFAULTCOLOR        // load flags
							  );
	HICON hIconLarge = (HICON)LoadImage(
							  g_hInstance,   // handle of the instance containing the image
							  MAKEINTRESOURCE( CHAT_ICON ),  // name or identifier of image
							  IMAGE_ICON,        // type of image
							  ICON_BIG_SIZE,     // desired width
							  ICON_BIG_SIZE,     // desired height
							  LR_DEFAULTCOLOR        // load flags
							  );

	DBGEXIT_ULONG(CNmChatCtl::OnCreate, 0);


    // Load the main accelerator table
    m_hAccelTable = ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR));

    RECT rcUI;
    _GetWindowRectOption(&rcUI);

	::MoveWindow(m_hWnd, rcUI.left, rcUI.top, rcUI.right - rcUI.left, rcUI.bottom - rcUI.top, TRUE);

	fRet = TRUE;

Cleanup:
	if(fRet == FALSE)
	{
		if(m_lpszRichEd)
		{
			delete [] m_lpszRichEd;
		}
		
		if(m_lpszRichEdEOL)
		{
			delete [] m_lpszRichEdEOL;
		}
	}

	return fRet;
}

void CNmChatCtl::_LoadStrings()
{
	TCHAR buffer[ MAX_PATH ];
	
	NmCtlLoadString(IDS_PRIVATE, buffer, CCHMAX(buffer));
	DBG_SAVE_FILE_LINE
	m_szPrivate = new TCHAR[ lstrlen( buffer ) + 1 ];
	ASSERT( m_szPrivate );
	lstrcpy( m_szPrivate, buffer );

	NmCtlLoadString(IDS_TO, buffer, CCHMAX(buffer));
	DBG_SAVE_FILE_LINE
	m_szTo = new TCHAR[ lstrlen( buffer ) + 1 ];
	ASSERT( m_szTo );
	lstrcpy( m_szTo, buffer );

	m_iExtra = lstrlen( m_szTo ) + lstrlen( m_szPrivate ) + 1;
}

void CNmChatCtl::_InitFontsAndColors()
{
	if (_LoadChatOptions())
	{   // Load options succeed
		return;
	}

	// Load Fonts
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		GetObject( GetStockObject( DEFAULT_GUI_FONT ), sizeof( m_hMsgLogFonts[i] ), &m_hMsgLogFonts[i] );
		m_hMsgFonts[ i ] = CreateFontIndirect( &m_hMsgLogFonts[i] );
	}

	m_hMsgColors[ CChatOptionsDlg::FONT_MSGOUT ] = RGB( 0, 0, 0 );
	m_hMsgColors[ CChatOptionsDlg::FONT_MSGIN ] = RGB( 0, 0, 0 );
	m_hMsgColors[ CChatOptionsDlg::FONT_PRIVATEOUT ] = RGB( 100, 100, 100 );
	m_hMsgColors[ CChatOptionsDlg::FONT_PRIVATEIN ] = RGB( 100, 100, 100 );
	m_hMsgColors[ CChatOptionsDlg::FONT_MSGSYSTEM ] = RGB( 255, 0, 0 );
}

void CNmChatCtl::_DeleteFonts()
{
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		DeleteObject( m_hMsgFonts[i] );
	}
}

LRESULT CNmChatCtl::OnInitMenuPopup(WPARAM wParam, LPARAM lParam)
{
    DBGENTRY(CNmChatCtl::OnInitMenuPopup);

	if( FALSE == (BOOL)HIWORD(lParam ) )
	{
		switch( LOWORD( lParam ) )
		{
			case MENUPOS_FILE:
			{
				if( CChatMessage::get_count() )
				{
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVE,
						( m_lpszSaveFile && *m_lpszSaveFile ) ? MF_ENABLED : MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVEAS, MF_ENABLED );
					EnableMenuItem( m_hMenuShared, ID_FILE_PRINT,
						!_IsPrinting() ? MF_ENABLED : MF_GRAYED );
				}
				else
				{
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVE, MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_SAVEAS, MF_GRAYED );
					EnableMenuItem( m_hMenuShared, ID_FILE_PRINT, MF_GRAYED );
				}
				return 0;
			}
			case MENUPOS_EDIT:
			{
				EnableMenuItem( m_hMenuShared, ID_EDIT_CLEARALL,
					CChatMessage::get_count() && !_IsPrinting() ? MF_ENABLED : MF_GRAYED );

				int iEnable = 0;
				
				HWND hwnd = ::GetFocus();
				if(hwnd == m_hWndEdit)
				{
					iEnable = (int)::SendMessage( hwnd, EM_GETSEL, 0, 0 );
					iEnable = (HIWORD(iEnable) == LOWORD(iEnable)) ? MF_GRAYED : MF_ENABLED;
				}
				else if(hwnd == m_hWndMsg)
				{
					CHARRANGE range;
					::SendMessage( hwnd, EM_EXGETSEL, 0, (LPARAM) &range );
					iEnable = (range.cpMin == range.cpMax) ? MF_GRAYED : MF_ENABLED;
				}

				EnableMenuItem( m_hMenuShared, ID_EDIT_CUT,hwnd == m_hWndEdit ?  iEnable : MF_GRAYED);
				EnableMenuItem( m_hMenuShared, ID_EDIT_PASTE,
					(IsClipboardFormatAvailable( CF_TEXT ) && (hwnd == m_hWndEdit)) ? MF_ENABLED : MF_GRAYED );

				EnableMenuItem( m_hMenuShared, ID_EDIT_COPY, iEnable );

				return 0;
			}
			case MENUPOS_VIEW:
			{
				_SetMenuItemCheck( ID_VIEW_STATUSBAR, _IsStatusBarVisibleFlagSet() );
				_SetMenuItemCheck( ID_VIEW_EDITWINDOW, _IsEditWindowVisibleFlagSet() );
				EnableMenuItem( m_hMenuShared, ID_VIEW_OPTIONS, _IsPrinting() ? MF_GRAYED : MF_ENABLED );
				return 0;
				break;
			}
			default:
				return 0;
		}
	}
	return 0;
}

LRESULT CNmChatCtl::OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DBGENTRY(CNmChatCtl::OnMenuSelect);

        UINT fuFlags = HIWORD( wParam );
			// If fuFlags == 0xffff and NULL == lParam, the menu is closed
		if( !( ( 0xFFFF == fuFlags ) && ( NULL == lParam ) ) )
		{
			UINT uStringID = 0;
			if( ( HIWORD( wParam ) & MF_HILITE ) )
			{

				if(( HIWORD( wParam ) & MF_SYSMENU))
				{
					uStringID = LOWORD( wParam );
					if(!uStringID)
					{
						uStringID = IDS_SYSTEM_HELP;
					}
				}
				else
				{

					switch( LOWORD( wParam ) )
					{

						case 0: // FILE top-level item
							uStringID = IDS_HELPTEXT_CHAT_FILE;
							break;

						case 1: // EDIT top-level item
							uStringID = IDS_HELPTEXT_CHAT_EDIT;
							break;

						case 2: // VIEW top-level item
							uStringID = IDS_HELPTEXT_CHAT_VIEW;
							break;

						case 3: // OPTIONS top-level item
							uStringID = IDS_HELPTEXT_CHAT_HELP;
							break;

						case ID_SEND_MESSAGE:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SEND_MESSAGE;
							break;

						case ID_FILE_SAVE:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SAVE;
							break;

						case ID_FILE_SAVEAS:
							uStringID = IDS_HELPTEXT_CHAT_FILE_SAVEAS;
							break;

						case ID_FILE_PRINT:
							uStringID = IDS_HELPTEXT_CHAT_FILE_PRINT;
							break;

						case ID_FILE_EXIT:
							uStringID = IDS_HELPTEXT_CHAT_FILE_EXIT;
							break;

						case ID_VIEW_EDITWINDOW:
							uStringID = IDS_HELPTEXT_CHAT_VIEW_EDITWINDOW;
							break;

						case ID_VIEW_STATUSBAR:
							uStringID = IDS_VIEW_STATUSBAR_HELP;
							break;

						case ID_VIEW_OPTIONS:
							uStringID = IDS_HELPTEXT_CHAT_VIEW_OPTIONS;
							break;

						case ID_EDIT_CUT:
							uStringID = IDS_HELPTEXT_EDIT_CUT  ;
							break;

						case ID_EDIT_COPY:
							uStringID = IDS_HELPTEXT_EDIT_COPY;
							break;

						case ID_EDIT_PASTE:
							uStringID = IDS_HELPTEXT_EDIT_PASTE;
							break;

						case ID_EDIT_CLEARALL:
							uStringID = IDS_HELPTEXT_EDIT_CLEARALL;
							break;

						case ID_HELP_ABOUTCHAT:
							uStringID = IDS_HELPTEXT_HELP_ABOUTCHAT;
							break;

						case ID_HELP_HELPTOPICS:
							uStringID = IDS_HELPTEXT_HELP_HELPTOPICS;
							break;


					}
				}
				_SetContainerStatusText(uStringID);
			}
		}

    DBGEXIT(CNmChatCtl::OnMenuSelect);
    return 0;
}


void CNmChatCtl::OnSendClicked(void)
{
	DBGENTRY(CNmChatCtl::OnSendClicked);

	_SendChatText();

	::SetFocus( m_hWndEdit );

	DBGEXIT(CNmChatCtl::OnCreate);
}

LRESULT CNmChatCtl::OnNotifyEnLink(ENLINK *pEnLink)
{
	DBGENTRY(CNmChatCtl::OnMsgWndNotify);

	switch( pEnLink->msg )
	{
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		{
			return 1;
			break;
		}
		case WM_LBUTTONDOWN:
		{
			TEXTRANGE Range;
			ZeroMemory( &Range, sizeof( TEXTRANGE ) );
			DBG_SAVE_FILE_LINE
			Range.lpstrText = new TCHAR[ pEnLink->chrg.cpMax - pEnLink->chrg.cpMin + 1];
			ASSERT( Range.lpstrText );
			Range.chrg = pEnLink->chrg;
			::SendMessage( m_hWndMsg, EM_GETTEXTRANGE, 0L, (LPARAM)&Range );

			ShellExecute( m_hWndMsg, NULL, Range.lpstrText, NULL, NULL, SW_SHOWNORMAL );

			delete [] Range.lpstrText;
			return 1;
			break;
		}
		default:
		{
			break;
		}
	}

	DBGEXIT(CNmChatCtl::OnMsgWndNotify);

	return 0;
}


//////////////////////////////////////////////////////////////////////////

    void CNmChatCtl::cmdFileSave(void)
    {
        DBGENTRY(CNmChatCtl::cmdFileSave);

		if( ( NULL == m_lpszSaveFile ) || ( _T('\0') == *m_lpszSaveFile ) )
		{
			_SaveAs();
		}
		else
		{
			_Save();
		}

        DBGEXIT(CNmChatCtl::cmdFileSave);
    }

    void CNmChatCtl::cmdFileSaveAs(void)
    {
        DBGENTRY(CNmChatCtl::cmdFileSaveAs);

		_SaveAs();

        DBGEXIT(CNmChatCtl::cmdFileSaveAs);
    }

    void CNmChatCtl::cmdFilePrint(void)
    {

        DBGENTRY(CNmChatCtl::cmdFilePrint);

		m_dwChatFlags |= CHAT_PRINT_FLAG_PRINTING;

		_Print();

		m_dwChatFlags &= ~CHAT_PRINT_FLAG_PRINTING;

        DBGEXIT(CNmChatCtl::cmdFilePrint);
    }

    void CNmChatCtl::cmdFileExit(WPARAM wParam)
    {

        DBGENTRY(CNmChatCtl::cmdFileExit);

	    int iOnSave = IDOK;

		if(wParam == 0)
		{
	        // Check whether there are changes to be saved
    	    iOnSave = QueryEndSession();
    	}

	    // If the exit was not cancelled, close the application
	    if (iOnSave != IDCANCEL)
	    {
			// no more T.120
			g_pChatObj->LeaveT120();

	        // Close chat
    	    ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_CLOSING);
    	    ::DestroyWindow(m_hWnd);
    	    ::UnregisterClass(szMainClassName, g_hInstance);

			m_hWnd = NULL;
			PostQuitMessage(0);

    	}

        DBGEXIT(CNmChatCtl::cmdFileExit);
    }

    void CNmChatCtl::cmdViewStatusBar(void)
    {
        DBGENTRY(CNmChatCtl::cmdViewStatusBar);
		RECT rect;
		GetClientRect(m_hWnd, &rect );
		::ShowWindow(m_hwndSB, _IsStatusBarVisibleFlagSet() ? SW_HIDE : SW_SHOW);
		_Resize( 0, 0, rect.right, rect.bottom );
		RedrawWindow(m_hWnd, NULL, NULL, RDW_UPDATENOW | RDW_INVALIDATE);
		DBGEXIT(CNmChatCtl::cmdViewStatusBar);
    }


//////////////////////////////////////////////////////////////////////////

void CNmChatCtl::cmdViewEditWindow(void)
{
	DBGENTRY(CNmChatCtl::cmdViewEditWindow);

	int iShowCommand = _IsEditWindowVisibleFlagSet() ? SW_HIDE : SW_SHOW;
	::ShowWindow( m_hWndEdit, iShowCommand );
	::ShowWindow( m_hWndSend, iShowCommand );
	::ShowWindow( m_hWndStaticMessage, iShowCommand );
	::ShowWindow( m_hWndStaticSendTo, iShowCommand );
	::ShowWindow( m_hWndMemberList, iShowCommand );

	_CalculateFontMetrics();
	RECT rect;
	GetClientRect(m_hWnd, &rect );
	_Resize( 0, 0, rect.right, rect.bottom );
	RedrawWindow(m_hWnd, NULL, NULL, RDW_UPDATENOW | RDW_INVALIDATE);

	DBGEXIT(CNmChatCtl::cmdViewEditWindow);
}


void CNmChatCtl::cmdEditCut(void)
{
	DBGENTRY(CNmChatCtl::cmdEditCut);

	::SendMessage(m_hWndEdit, WM_CUT, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditCut);
}

void CNmChatCtl::cmdEditCopy(void)
{
	DBGENTRY(CNmChatCtl::cmdEditCopy);

	HWND hwnd = ::GetFocus();
	if(hwnd == 0)
	{
		hwnd = m_hWndEdit;
	}

	::SendMessage(hwnd, WM_COPY, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditCopy);
}

void CNmChatCtl::cmdEditPaste(void)
{
	DBGENTRY(CNmChatCtl::cmdEditPaste);

	::SendMessage(m_hWndEdit, WM_PASTE, 0, 0);

	DBGEXIT(CNmChatCtl::cmdEditPaste);
}


void CNmChatCtl::cmdEditClearAll(void)
{
	DBGENTRY(CNmChatCtl::cmdEditClearAll);

	if( !_IsPrinting() )
	{
		ResetView();
	}

	DBGEXIT(CNmChatCtl::cmdEditClearAll);
}

void CNmChatCtl::cmdViewOptions(void)
{
    DBGENTRY(CNmChatCtl::cmdViewOptions);

	if(m_pChatOptions == NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pChatOptions = new CChatOptionsDlg( this );
	}
	
	::DialogBox (g_hInstance,
					MAKEINTRESOURCE(IDD_CHAT_OPTIONS),
					m_hWnd,
					CChatOptionsDlg::_OptionsDlgProc);

	delete m_pChatOptions;
	m_pChatOptions = NULL;

    DBGEXIT(CNmChatCtl::cmdViewOptions);
}

void CNmChatCtl::cmdHelpHelpTopics(void)
{
	DBGENTRY(CNmChatCtl::cmdHelpHelpTopics);

	ShowNmHelp(s_cszHtmlHelpFile);

	DBGEXIT(CNmChatCtl::cmdHelpHelpTopics);
}


void CNmChatCtl::cmdHelpAboutChat()
{
	DBGENTRY(CNmChatCtl::cmdHelpAboutChat);

	::DialogBox( g_hInstance,
					MAKEINTRESOURCE( IDD_CHAT_ABOUT ),
					m_hWnd,
					_AboutDlgProc );

	DBGEXIT(CNmChatCtl::cmdHelpAboutChat);
}

int  CNmChatCtl::QueryEndSession()
{
	DBGENTRY(CNmChatCtl::QueryEndSession);

	//
	// We may be shuting down, last good chance to save the position
	//
	_SaveWindowPosition();
    _SaveChatOptions();

	int iRet = IDYES;
	
	{
		if( m_dwChatFlags & CHAT_FLAG_DIRTYBIT )
		{
			TCHAR szRes[MAX_PATH];
			TCHAR szRes2[MAX_PATH];

			iRet = ::MessageBox( m_hWnd,
						   			 RES2T(IDS_SAVE_CHANGES_TO_CHAT_BEFORE_EXITING,szRes),
									 RES2T(IDS_NETMEETING_CHAT,szRes2),
									 MB_YESNOCANCEL | MB_ICONEXCLAMATION
								   );
			if( IDCANCEL == iRet )
			{
				return iRet;
			}
			else if( IDYES == iRet )
			{
				if( m_lpszSaveFile && *m_lpszSaveFile )
				{
					// if we already have a save file name
					// we just save it....
					_Save();
				}
				else
				{
					iRet = _SaveAs();
				}
			}
		}
	}

	DBGEXIT(CNmChatCtl::QueryEndSession);
	return iRet;
}

STDMETHODIMP CNmChatCtl::OnMenuSelect( IN DWORD wParam, IN DWORD lParam )
{
	DBGENTRY(CNmChatCtl::OnMenuSelect);
	HRESULT hr = S_OK;
	
	UINT fuFlags = HIWORD( wParam );

	if( !( ( 0xFFFF == fuFlags ) && ( NULL == lParam ) ) )
	{
		switch( LOWORD( wParam ) )
		{

			case ID_SEND_MESSAGE:
			case ID_FILE_SAVE:
			case ID_FILE_SAVEAS:
			case ID_FILE_PRINT:
			case ID_FILE_EXIT:
			case MENUPOS_FILE:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_FILE, 0 ));
				break;

			case ID_VIEW_STATUSBAR:
			case ID_VIEW_EDITWINDOW:
			case ID_VIEW_OPTIONS:
			case MENUPOS_VIEW:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_VIEW, 0 ));
				break;

			case ID_EDIT_CUT:
			case ID_EDIT_COPY:
			case ID_EDIT_PASTE:
			case ID_EDIT_CLEARALL:
			case MENUPOS_EDIT:
				OnInitMenuPopup( 0, MAKELPARAM( MENUPOS_EDIT, 0 ));
				break;

			case ID_HELP_HELPTOPICS:
			case ID_HELP_ABOUTCHAT:
			default:
				break;
		}

		OnMenuSelect(WM_MENUSELECT, wParam, lParam);
	}
	

	DBGEXIT_HR(CNmChatCtl::OnMenuSelect,hr);
	return hr;
}

LRESULT CNmChatCtl::OnContextMenu(short x, short y)
{
    // pop it up
    OnInitMenuPopup(0, MENUPOS_EDIT);
    ::TrackPopupMenu(::GetSubMenu(m_hMenuShared, MENUPOS_EDIT), TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
						x , y , 0, m_hWnd, NULL);

	return 0;
}


STDMETHODIMP CNmChatCtl::OnCommand( IN WPARAM wParam, IN LPARAM lParam )
{
	DBGENTRY(CNmChatCtl::OnCommand);
	HRESULT hr = S_OK;

	if(m_hWndSend == (HWND)lParam)
	{
		OnSendClicked();
		return 0;
	}
	
	if((CBN_SETFOCUS == HIWORD(wParam) && m_hWndMemberList == (HWND)lParam) ||
		(EN_SETFOCUS == HIWORD(wParam) && m_hWndEdit == (HWND)lParam))
	{
		//
		// Deselect the text in the message window
		//
		CHARRANGE charRange;
		charRange.cpMin = m_cchBufferSize + 1;
		charRange.cpMax = m_cchBufferSize + 1;
		::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );
	}

	switch( LOWORD( wParam ) )
	{
		case ID_SEND_MESSAGE: OnSendClicked(); break;
		case ID_FILE_SAVE: cmdFileSave(); break;
		case ID_FILE_SAVEAS: cmdFileSaveAs(); break;
		case ID_FILE_PRINT: cmdFilePrint(); break;
		case ID_FILE_EXIT: cmdFileExit(0); break;
		case ID_VIEW_STATUSBAR: cmdViewStatusBar(); break;
		case ID_EDIT_CUT: cmdEditCut(); break;
		case ID_EDIT_COPY: cmdEditCopy(); break;
		case ID_EDIT_PASTE: cmdEditPaste(); break;
		case ID_EDIT_CLEARALL: cmdEditClearAll(); break;
		case ID_VIEW_EDITWINDOW: cmdViewEditWindow(); break;
		case ID_VIEW_OPTIONS: cmdViewOptions (); break;
		case ID_HELP_HELPTOPICS: cmdHelpHelpTopics(); break;
		case ID_HELP_ABOUTCHAT: cmdHelpAboutChat(); break;
		case ID_NAV_TAB: ShiftFocus(m_hWnd , TRUE);	break;
		case ID_NAV_SHIFT_TAB: ShiftFocus(m_hWnd, FALSE);break;

	}

	DBGEXIT_HR(CNmChatCtl::OnCommand,hr);
	return hr;
}

void CNmChatCtl::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    DBGENTRY(CNmChatCtl::OnGetMinMaxInfo);

	SIZE csFrame;
	csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

	lpmmi->ptMinTrackSize.y =
		    	csFrame.cy +
			    GetSystemMetrics( SM_CYCAPTION ) +
			    GetSystemMetrics( SM_CYMENU ) +
				DYP_CHAT_SEND * 2 +	// At least 2 lines
				m_iStaticY +	// Message:
				DYP_CHAT_SEND +	// Edit box
				m_iStaticY +	// Send to:
				ComboBoxEx_GetItemHeight(m_hWndMemberList, 0) + // ComboBox
				STATUSBAR_HEIGHT +
				csFrame.cy;

	lpmmi->ptMinTrackSize.x =
		csFrame.cx +
		m_iStaticLen * 2 +
		SPACING_DLU_X * m_iDLGUX +
		DXP_CHAT_SEND +
		csFrame.cx;


    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csFrame.cx = rcWorkArea.right - rcWorkArea.left;
    csFrame.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csFrame.cx;
    lpmmi->ptMaxSize.y      = csFrame.cy;
    lpmmi->ptMaxTrackSize.x = csFrame.cx;
    lpmmi->ptMaxTrackSize.y = csFrame.cy;
		
    DBGEXIT(CNmChatCtl::OnGetMinMaxInfo);
}


///////////////////////////////////////////////////////////////////////////////////////////////////////
// CNmChatCtl INmChatCtl implementation
///////////////////////////////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CNmChatCtl::ResetView()
{

	DBGENTRY(CNmChatCtl::ResetView());

	HRESULT hr;

	if( _IsPrinting() )
	{
		hr = E_FAIL;
	}
	else
	{
		::SetWindowText( m_hWndMsg, TEXT(""));
		m_cchBufferSize = 0;
		m_cMessages = 0;
		CChatMessage::DeleteAll();

		m_dwChatFlags &= ~CHAT_FLAG_DIRTYBIT;

		hr = S_OK;
	}

	DBGEXIT_HR(CNmChatCtl::ResetView, hr);

	return hr;
}

void CNmChatCtl::_ReDisplayMessages()
{
	DBGENTRY(CNmChatCtl::_ReDisplayMessages());

	SNDMSG( m_hWndMsg, WM_SETREDRAW, FALSE, 0 );

	::SetWindowText( m_hWndMsg, TEXT(""));
	
	CChatMessage *pMsg = CChatMessage::get_head();
	while( pMsg != NULL )
	{
		_DisplayMsg( pMsg, FALSE );
		pMsg = pMsg->get_next();
	}

	SNDMSG( m_hWndMsg, WM_SETREDRAW, TRUE, 0 );
	::InvalidateRect( m_hWndMsg, NULL, INVALIDATE_BACKGROUND );

	DBGEXIT(CNmChatCtl::_ReDisplayMessages);
}

CNmChatCtl::MSGSTYLE CNmChatCtl::get_MsgStyle()
{
	return m_style;
}

STDMETHODIMP CNmChatCtl::put_MsgStyle( /*[in]*/ MSGSTYLE iStyle )
{
	DBGENTRY(CNmChatCtl::put_MsgStyle);

	HRESULT hr = S_OK;

	DWORD dwStyle;
	
	if( MSGSTYLE_2_LINE_WRAP == iStyle ||
		MSGSTYLE_1_LINE_WRAP == iStyle )
	{
		dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_READONLY | \
		ES_SAVESEL | ES_NOHIDESEL | ES_AUTOVSCROLL | WS_VSCROLL;
	}
	else if( MSGSTYLE_NO_WRAP == iStyle )
	{
		dwStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | ES_MULTILINE | ES_READONLY | \
		ES_SAVESEL | ES_NOHIDESEL | ES_AUTOVSCROLL | WS_VSCROLL | WS_HSCROLL | ES_AUTOVSCROLL;
	}
	else
	{
		hr = E_FAIL;
		DBGEXIT_HR(CNmChatCtl::put_MsgStyle, hr);
		return hr;
	}

	HWND hwndKill = m_hWndMsg;

	m_hWndMsg = ::CreateWindowEx( WS_EX_CLIENTEDGE,
								m_lpszRichEd,
								NULL,
								dwStyle| WS_TABSTOP,
								0,0,0,0,
								m_hWnd,
								NULL,
								g_hInstance,
								this );

	ASSERT( m_hWndMsg );
	::SendMessage( m_hWndMsg, WM_SETFONT, (WPARAM)m_hMsgFonts[ CChatOptionsDlg::FONT_MSGOUT ], 0L );
	::SendMessage( m_hWndMsg, EM_AUTOURLDETECT, (WPARAM) TRUE, 0L );
	::SendMessage( m_hWndMsg, EM_SETBKGNDCOLOR, (WPARAM) TRUE, 0L );
	::SendMessage( m_hWndMsg, EM_SETEVENTMASK, 0L, (LPARAM) ENM_LINK );
	::SendMessage( m_hWndMsg, WM_PAINT, 0, 0);
	
	m_style = iStyle;

	_CalculateFontMetrics();

	RECT rect;
	GetClientRect(m_hWnd, &rect );
	_Resize( 0, 0, rect.right, rect.bottom );

	::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );

	_ReDisplayMessages();

    if( ::IsWindow( hwndKill ) )
    {
	    ::DestroyWindow( hwndKill );
    }

	DBGEXIT_HR(CNmChatCtl::put_MsgStyle, hr);
	
	return hr;
}

STDMETHODIMP CNmChatCtl::put_ShowName(/*[in]*/ short bUseName )
{
	DBGENTRY(CNmChatCtl::put_ShowName);

	m_bUseName = bUseName;

	DBGEXIT_HR(CNmChatCtl::put_ShowName, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_ShowName(/*[out]*/ short *pbUseName )
{
	DBGENTRY(CNmChatCtl::get_ShowName);

	HRESULT hr = S_OK;

	if( NULL == pbUseName )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseName = m_bUseName;
	}

	DBGEXIT_HR(CNmChatCtl::get_ShowName, hr);
	
	return hr;
}


STDMETHODIMP CNmChatCtl::put_Date(/*[in]*/ short bUseDate )
{
	DBGENTRY(CNmChatCtl::put_Date);

	m_bUseDate = bUseDate;

	DBGEXIT_HR(CNmChatCtl::put_Date, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_Date(/*[out]*/ short *pbUseDate )
{
	DBGENTRY(CNmChatCtl::get_Date);

	HRESULT hr = S_OK;

	if( NULL == pbUseDate )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseDate = m_bUseDate;
	}

	DBGEXIT_HR(CNmChatCtl::get_Date, hr);
	
	return hr;
}

STDMETHODIMP CNmChatCtl::put_Timestamp(/*[in]*/ short bUseTimeStamp )
{
	DBGENTRY(CNmChatCtl::put_Timestamp);

	m_bTimeStamp = bUseTimeStamp;

	DBGEXIT_HR(CNmChatCtl::put_Timestamp, S_OK);
	
	return S_OK;
}

STDMETHODIMP CNmChatCtl::get_Timestamp(/*[out]*/ short *pbUseTimeStamp )
{
	DBGENTRY(CNmChatCtl::get_Timestamp);

	HRESULT hr = S_OK;

	if( NULL == pbUseTimeStamp )
	{
		hr = E_POINTER;
	}
	else
	{
		*pbUseTimeStamp = m_bTimeStamp;
	}

	DBGEXIT_HR(CNmChatCtl::get_Timestamp, hr);
	
	return hr;
}

void CNmChatCtl::_Resize(int x, int y, int cx, int cy)
{

	DBGENTRY(CNmChatCtl::_Resize);



	if( _IsEditWindowVisibleFlagSet() )
	{
		int iStatusBarHeight = _IsStatusBarVisibleFlagSet() ? STATUSBAR_HEIGHT : 0;
		int iMsgListY = MSGLIST_DLU_Y * m_iDLGUY;
		int iBetweenX = SPACING_DLU_X * m_iDLGUX;
		int iStaticHeight = m_iStaticY + STATIC_DLU_Y * m_iDLGUY;
		int iStaticStart = STATIC_DLU_Y * m_iDLGUY;

		HDWP hdwp = ::BeginDeferWindowPos(7);

		::DeferWindowPos(hdwp, m_hWndMsg, NULL,
			0,
			0,
			cx,
			cy-DYP_CHAT_SEND-iMsgListY-(iStaticHeight*2) - iStatusBarHeight,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndStaticMessage, NULL,
			0,
			cy-DYP_CHAT_SEND-iMsgListY-iStaticHeight*2 + iStaticStart - iStatusBarHeight,
			m_iStaticLen,
			m_iStaticY,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndEdit, NULL,
			0,
			cy-iMsgListY-iStaticHeight-DYP_CHAT_SEND - iStatusBarHeight,
			cx - DXP_CHAT_SEND - iBetweenX,
			DYP_CHAT_SEND,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndSend, NULL,
			cx-DXP_CHAT_SEND,
			cy-iMsgListY-iStaticHeight-DYP_CHAT_SEND - iStatusBarHeight,
			DXP_CHAT_SEND,
			DYP_CHAT_SEND,
			SWP_NOZORDER);
		
		::DeferWindowPos(hdwp, m_hWndStaticSendTo, NULL,
			0,
			cy-iMsgListY-iStaticHeight + iStaticStart - iStatusBarHeight,
			m_iStaticLen,
			m_iStaticY,
			SWP_NOZORDER);

		::DeferWindowPos(hdwp, m_hWndMemberList, NULL,
			0,
			cy-iMsgListY - iStatusBarHeight,
			cx,
			ComboBoxEx_GetItemHeight(m_hWndMemberList, 0),
			SWP_NOZORDER);

		RECT rect;
	    ::GetClientRect(m_hWnd, &rect);
		 rect.top = rect.bottom - iStatusBarHeight;
	
		::DeferWindowPos(hdwp, m_hwndSB, NULL,
			rect.left, rect.top,
            rect.right - rect.left,
            rect.bottom - rect.top,
			SWP_NOZORDER);
	
		::EndDeferWindowPos(hdwp);


	}
	else
	{

		int iStatusBarHeight = _IsStatusBarVisibleFlagSet() ? STATUSBAR_HEIGHT : 0;

		::MoveWindow(m_hWndMsg,
			0, 0, cx, cy - iStatusBarHeight,
			TRUE);
	}


	DBGEXIT(CNmChatCtl::_Resize);
}

void CNmChatCtl::_LoadIconImages(void)
{
	
	DBGENTRY(CNmChatCtl::_LoadIconImages);

	COLORREF crTOOLBAR_MASK_COLOR = ( RGB( 255,   0, 255 ) );

	if( NULL == m_himlIconSmall )
	{
		m_himlIconSmall = ImageList_Create(DXP_ICON_SMALL, DYP_ICON_SMALL, ILC_MASK, 1, 0);
		if (NULL != m_himlIconSmall)
		{
			HBITMAP hBmp = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_CHAT_SMALL_ICON_IMAGES));
			if (NULL != hBmp)
			{
				ImageList_AddMasked(m_himlIconSmall, hBmp, crTOOLBAR_MASK_COLOR);
				::DeleteObject(hBmp);
			}
		}
	}

	DBGEXIT(CNmChatCtl::_LoadIconImages);
}

void CNmChatCtl::_FreeIconImages(void)
{

	DBGENTRY(CNmChatCtl::_FreeIconImages);

	if (NULL != m_himlIconSmall)
	{
		ImageList_Destroy(m_himlIconSmall);
		m_himlIconSmall = NULL;
	}	
	
	DBGEXIT(CNmChatCtl::_FreeIconImages);
}


HRESULT CNmChatCtl::_SendChatText(void)
{
	DBGENTRY(CNmChatCtl::_SendChatText);

	HRESULT hr = S_OK;
	
	TCHAR szMsg[CCHMAX_CHAT_MSG];

	// Get the text line
	int cb = (int)::SendMessage(m_hWndEdit, WM_GETTEXT, (WPARAM) CCHMAX(szMsg), (LPARAM) szMsg);
	if (0 != cb)
	{
		if (cb == 1)
		{
			szMsg[1] = ' ';
			szMsg[2] = 0;
			cb++;
		}
		// Delete the text in the edit box ( remember it is stored in szMsg )
		::SendMessage(m_hWndEdit, EM_SETSEL, (WPARAM) 0, (LPARAM)-1);
		::SendMessage(m_hWndEdit, WM_SETTEXT, (WPARAM) 0, (LPARAM) "");
		::SetFocus(m_hWndEdit); // reset the focus if we actually sent something

		MEMBER_CHANNEL_ID *pMemberID = (MEMBER_CHANNEL_ID*)_GetSelectedMember();
		MEMBER_ID			memberID;
		
	    TCHAR szName[MAX_PATH*2];
		szName[0] = '\0';
		CChatMessage::CHAT_MSGTYPE cmtype;
		LPTSTR szPerson = NULL;
		if( pMemberID == 0 )
		{
			cmtype = CChatMessage::MSG_SAY;
			memberID = MAKE_MEMBER_ID(0, g_pChatObj->m_broadcastChannel);
		}
		else
		{
			// Use the whisper
			memberID = MAKE_MEMBER_ID(pMemberID->nNodeId, pMemberID->nWhisperId);
			cmtype = CChatMessage::MSG_WHISPER;
			if(!T120_GetNodeName(g_pChatObj->m_nConfID,  pMemberID->nNodeId, szName, MAX_PATH*2))
			{
				return E_FAIL;
			}
		}

		_DisplayMsg( new CChatMessage( szName, szMsg, cmtype ) );
		
		if (g_pChatObj)
		{

			// Allocate a temporary buffer
			BYTE * pb = new BYTE[CB_NM2_HDR + (CCHMAX_CHAT_MSG * sizeof(WCHAR))];
			if (NULL != pb)
			{

				BYTE * pbData = pb+CB_NM2_HDR;

				// Initialize the header
				ZeroMemory(pb, CB_NM2_HDR);
				* ((LPDWORD) pb) = CB_NM2_HDR;

				cb++; // include final null
			#ifdef UNICODE
				lstrcpy(pbData, szMsg);
			#else
				cb = MultiByteToWideChar(CP_ACP, 0, szMsg, cb, (LPWSTR) pbData, CCHMAX_CHAT_MSG);
				cb *= 2; // adjust for UNICODE
			#endif //!UNICODE

				// Add special prefix
				cb += CB_NM2_HDR;

				hr = g_pChatObj->SendData(GET_USER_ID_FROM_MEMBER_ID(memberID), cb, (BYTE*)pb);

				delete [] pb;
			}
			else
			{
				ERROR_OUT(("Out of memory!!!"));
				hr = E_OUTOFMEMORY;

			}
		}
	}
	else
	{
		// There was no chat text

	}
	
	DBGEXIT_HR(CNmChatCtl::_SendChatText, hr);			

	return hr;
}


void  CNmChatCtl::_DataReceived(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID)
{

	DBGENTRY(CNmChatCtl::DataReceived);

	ASSERT(uSize > CNmChatCtl::CB_NM2_HDR);
	LPTSTR psz = (LPTSTR) (pb + *(LPDWORD) pb);  // skip past header

#ifndef UNICODE
	// Convert UNICODE to ANSI
	char sz[CNmChatCtl::CCHMAX_CHAT_MSG];
	WideCharToMultiByte(CP_ACP, 0, (LPWSTR) psz, -1, sz, CNmChatCtl::
CCHMAX_CHAT_MSG, NULL, NULL);
	psz = sz;
#endif //

    TCHAR szPerson[MAX_PATH*2] = "\0";
	T120NodeID nodeID = ComboBoxEx_GetNodeIDFromSendID(m_hWndMemberList,  senderID );
	if (0 == nodeID)
	{
		nodeID = ComboBoxEx_GetNodeIDFromPrivateSendID(m_hWndMemberList, senderID);
	}
	ULONG cb = T120_GetNodeName(g_pChatObj->m_nConfID, nodeID, szPerson, MAX_PATH*2);

	// Display the message to the chat window
	_DisplayMsg(new CChatMessage( szPerson, psz,
		( destinationID == GET_USER_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID)) ?
		CChatMessage::MSG_WHISPER_FROM_OTHER : CChatMessage::MSG_FROM_OTHER ));


	DBGEXIT_HR(CNmChannelEventSink::DataReceived, S_OK);
}


inline void CNmChatCtl::_Write_Msg( LPTSTR pszText )
{
	ASSERT( NULL != pszText );
	::SendMessage( m_hWndMsg, EM_REPLACESEL, (WPARAM) FALSE, (WPARAM) pszText );
	m_cchBufferSize += lstrlen( pszText );
}

inline void CNmChatCtl::_Write_Msg_Range_Format( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	charRange.cpMin = m_cchBufferSize;
	charRange.cpMax = m_cchBufferSize;
	::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );
	::SendMessage( m_hWndMsg, EM_SETCHARFORMAT, (WPARAM)SCF_SELECTION, (LPARAM) &chatFormat );
	_Write_Msg( pszText );
}

inline void CNmChatCtl::_Write_Date_And_Time( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	if( m_bUseDate )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_date() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat ) ;
	}
	if( m_bTimeStamp )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_time() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat ) ;
	}
}

inline void CNmChatCtl::_Write_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	if( m_bUseName )
	{
		wsprintf( pszText, TEXT("%s\t"), pChatMsg->get_person() );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	}
}

inline void CNmChatCtl::_Write_Own_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	if( m_bUseName )
	{
		if(m_lpszOwnName == NULL)
		{
			RegEntry re(ISAPI_CLIENT_KEY, HKEY_CURRENT_USER);
			LPCTSTR pcszName = re.GetString(REGVAL_ULS_NAME);
			
			DBG_SAVE_FILE_LINE
			m_lpszOwnName = new TCHAR[lstrlen(pcszName) + 1];

			if(m_lpszOwnName == NULL)
			{
				return;
			}
			
			lstrcpy( m_lpszOwnName, pcszName);
		}

		wsprintf( pszText, TEXT("%s\t"), m_lpszOwnName );
		_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	}
}

inline void CNmChatCtl::_Write_Message( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	_Write_Msg_Range_Format( pChatMsg->get_message(), charRange, chatFormat );
	_Write_Msg_Range_Format( m_lpszRichEdEOL, charRange, chatFormat );
}

inline void CNmChatCtl::_Write_Private_In( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	wsprintf( pszText, TEXT("[%s]"), m_szPrivate );
	_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	_Write_Message( pszText, charRange, chatFormat, pChatMsg );
}

inline void CNmChatCtl::_Write_Private_Out( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& chatFormat, CChatMessage *pChatMsg )
{
	wsprintf( pszText, TEXT("[%s %s %s] "), m_szPrivate, m_szTo, pChatMsg->get_person() );
	_Write_Msg_Range_Format( pszText, charRange, chatFormat );
	_Write_Message( pszText, charRange, chatFormat, pChatMsg );
}

inline void CNmChatCtl::_Write_New_Line_If_Needed( CHARRANGE& charRange, CHARFORMAT& chatFormat )
{
	if( MSGSTYLE_2_LINE_WRAP == m_style )
	{
		_Write_Msg_Range_Format( m_lpszRichEdEOL, charRange, chatFormat );

		::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine2 );
		::SendMessage( m_hWndMsg, EM_GETPARAFORMAT, 0, (LPARAM) &m_paraLine2 );
	}
}

inline void CNmChatCtl::_AddFontToCharFormat( CHARFORMAT& chatFormat, int i )
{
	chatFormat.dwMask |= CFM_COLOR | CFM_ALLCAPS | CFM_CHARSET | CFM_BOLD | CFM_FACE | CFM_ITALIC | CFM_SIZE | CFM_STRIKEOUT | CFM_UNDERLINE;

	chatFormat.crTextColor = m_hMsgColors[ i ];

	if( m_hMsgLogFonts[i].lfWeight >= FW_BOLD )
	{
		chatFormat.dwEffects |= CFE_BOLD;
	}
	if( m_hMsgLogFonts[i].lfItalic )
	{
		chatFormat.dwEffects |= CFE_ITALIC;
	}
	if( m_hMsgLogFonts[i].lfUnderline  )
	{
		chatFormat.dwEffects |= CFE_UNDERLINE;
	}
	if( m_hMsgLogFonts[i].lfStrikeOut  )
	{
		chatFormat.dwEffects |= CFE_STRIKEOUT;
	}
	chatFormat.yHeight = 20 * _Points_From_LogFontHeight( m_hMsgLogFonts[i].lfHeight, m_hWnd );

	chatFormat.bCharSet = m_hMsgLogFonts[i].lfCharSet;
	chatFormat.bPitchAndFamily = m_hMsgLogFonts[i].lfPitchAndFamily;
	lstrcpy( chatFormat.szFaceName, m_hMsgLogFonts[i].lfFaceName );
}

void CNmChatCtl::_DisplayMsg( CChatMessage *pChatMsg, BOOL bBatchRedraw /*= TRUE*/ )
{
	DBGENTRY(CNmChatCtl::_DisplayMsg);


	if(pChatMsg != NULL && !pChatMsg->IsValid() )
	{
		ERROR_OUT(( TEXT("CNmChatCtl::_DisplayMsg passed invalid message") ));
		return;
	}

	TCHAR pszText[CCHMAX_CHAT_MSG];
	
	CHARRANGE charRange;

	//
	// Start at the end of the last message
	//
	charRange.cpMin = m_cchBufferSize + 1;
	charRange.cpMax = m_cchBufferSize + 1;
	::SendMessage( m_hWndMsg, EM_EXSETSEL, 0L, (LPARAM) &charRange );


	CHARFORMAT chatFormat;
	ZeroMemory( &chatFormat, sizeof( chatFormat ) );
	chatFormat.cbSize = sizeof( chatFormat );

	::SendMessage( m_hWndMsg, EM_SETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );
	::SendMessage( m_hWndMsg, EM_GETPARAFORMAT, 0, (LPARAM) &m_paraLine1 );


	if(pChatMsg)
	{

		CChatMessage::CHAT_MSGTYPE msgType = pChatMsg->get_type();
		switch( msgType )
		{
			case CChatMessage::MSG_WHISPER_FROM_OTHER:
			case CChatMessage::MSG_FROM_OTHER:
			case CChatMessage::MSG_WHISPER:
			case CChatMessage::MSG_SAY:
			{
				if( bBatchRedraw )
				{
					SNDMSG( m_hWndMsg, WM_SETREDRAW, FALSE, 0 );
				}
				switch( msgType )
				{
					case CChatMessage::MSG_WHISPER_FROM_OTHER:
					{
						_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_PRIVATEIN );
						break;
					}
					case CChatMessage::MSG_FROM_OTHER:
					{
						_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGIN );
						break;
					}
					case CChatMessage::MSG_WHISPER:
					{
						_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_PRIVATEOUT );
						break;
					}
					case CChatMessage::MSG_SAY:
					{
						_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGOUT );
						break;
					}
				}
					
				_Write_Date_And_Time( pszText, charRange, chatFormat, pChatMsg );

				if( pChatMsg->IsIncoming() )
				{
					_Write_Name( pszText, charRange, chatFormat, pChatMsg );
				}
				else
				{
					_Write_Own_Name( pszText, charRange, chatFormat );
				}

				_Write_New_Line_If_Needed( charRange, chatFormat );
				
				if( !pChatMsg->IsPrivate() )
				{
					_Write_Message( pszText, charRange, chatFormat, pChatMsg );
				}
				else if( pChatMsg->IsIncoming() )
				{
					_Write_Private_In( pszText, charRange, chatFormat, pChatMsg );
				}
				else
				{
					_Write_Private_Out( pszText, charRange, chatFormat, pChatMsg );
				}

				// Update message count
				m_cMessages++;

				m_dwChatFlags |= CHAT_FLAG_DIRTYBIT;

				if( bBatchRedraw )
				{
					SNDMSG( m_hWndMsg, WM_SETREDRAW, TRUE, 0 );
					::InvalidateRect( m_hWndMsg, NULL, INVALIDATE_BACKGROUND );
				}

				break;
			}
			case CChatMessage::MSG_SYSTEM:
			{
				_AddFontToCharFormat( chatFormat, CChatOptionsDlg::FONT_MSGSYSTEM );
				_Write_Message( pszText, charRange, chatFormat, pChatMsg );
				break;
			}
			default:
			{
				ERROR_OUT(( TEXT("CNmChatCtl::_DisplayMsg - Unknown Message Type") ));
				return;
				break;
			}
		}
	}

	DBGEXIT(CNmChatCtl::_DisplayMsg);
}

HRESULT CNmChatCtl::_AddEveryoneInChat()
{
	DBGENTRY( CNmChatCtl::_AddEveryoneInChat );
	ASSERT( m_hWndMemberList );

	HRESULT hr = S_OK;

	int iImage = II_PERSON_PERSON;
	int iItem = 0;
	TCHAR szName[MAX_PATH];
	TCHAR szRes[MAX_PATH];

	lstrcpy( szName, RES2T( IDS_FILTER_ALL, szRes ) );

	COMBOBOXEXITEM cbexi;
	ClearStruct( &cbexi );
	cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE ;
	cbexi.iItem = iItem;
	cbexi.pszText = szName;
	cbexi.cchTextMax = lstrlen(cbexi.pszText);
	cbexi.iSelectedImage = iImage;
	cbexi.iImage = iImage;
	cbexi.lParam = (LPARAM) NULL;

	ComboBoxEx_InsertItem(m_hWndMemberList, &cbexi);
	ComboBoxEx_SetCurSel( m_hWndMemberList, 0 );

	DBGEXIT_HR( CNmChatCtl::_AddEveryoneInChat, hr );

	return hr;
}

HBITMAP CNmChatCtl::_GetHBITMAP( DWORD dwID )
{

    DBGENTRY(CNmChatCtl::_GetHBITMAP);

    HBITMAP hb = static_cast<HBITMAP>( LoadImage(g_hInstance, MAKEINTRESOURCE(dwID), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE));

    DBGEXIT(CNmChatCtl::_GetHBITMAP);

    return hb;
}


	// Delete item iIndex from the m_hWndMemberList list view and free the
	// pMember that is stored in the lParam of that item...
HRESULT CNmChatCtl::_DeleteMemberListItem( int iIndex )
{
	DBGENTRY(CNmChatCtl::_DeleteMemberListItem);

	HRESULT hr = S_OK;

	TCHAR szName[MAX_PATH];

    COMBOBOXEXITEM cbexi;
    ClearStruct( &cbexi );

	cbexi.iItem = iIndex;
    cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT;
	cbexi.pszText = szName;
	cbexi.cchTextMax = CCHMAX(szName);

        // Find the item iIndex and get the Text and lParam data
    if( ComboBoxEx_GetItem( m_hWndMemberList, &cbexi ) )
    {

        if( CB_ERR == ComboBoxEx_DeleteItem(m_hWndMemberList, iIndex) )
		{
			WARNING_OUT(( "Could not delete %s from ComboBox", cbexi.pszText ));
		}
		
	}
	else
	{
			// There was an error...
		WARNING_OUT(("There was an error getting the list view item..."));
		DWORD dwErr = GetLastError();
		hr = HRESULT_FROM_WIN32( dwErr );
	}

	DBGEXIT_HR(CNmChatCtl::_DeleteMemberListItem, hr);

	return hr;
}


void CNmChatCtl::_DeleteAllListItems( void )
{
	DBGENTRY(CNmChatCtl::_DeleteAllListItems);

    int cItems = ComboBoxEx_GetCount( m_hWndMemberList );
    while( cItems-- )
    {   // Delete the first item in the list...
        int IndexOfFirstItemInList = 0;
        _DeleteMemberListItem( IndexOfFirstItemInList );
    }

	ComboBoxEx_SetCurSel( m_hWndMemberList, 0 );

    DBGEXIT(CNmChatCtl::_DeleteAllListItems);
}

HRESULT CNmChatCtl::_GetOwnName()
{
	DBGENTRY( CNmChatCtl::_GetOwnName );

	HRESULT hr = E_FAIL;

	DBGEXIT_HR( CNmChatCtl::_GetOwnName, hr );

	return( hr );
}


void CNmChatCtl::_UpdateContainerCaption( void )
{
	DBGENTRY(CNmChatCtl::_UpdateContainerCaption);

	TCHAR szCaption[MAX_PATH * 2];
	TCHAR szCaption2[MAX_PATH * 2];
	UINT captionID;
	UINT statusID;
	if (! g_pChatObj->IsInConference())
	{
		captionID = IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION;
		statusID = IDS_CHAT_STATUS_CHAT_NOT_ACTIVE;

	}
	else
	{
		captionID = IDS_CHAT_IN_CALL_WINDOW_CAPTION;
		statusID = IDS_CHAT_STATUS_CHAT_ACTIVE;

	}

   	::LoadString(g_hInstance, captionID, szCaption, sizeof(szCaption) );
   	
	wsprintf(szCaption2, szCaption, m_cOtherMembers);
	::SetWindowText(m_hWnd, szCaption2);

	_SetContainerStatusText( statusID );

	DBGEXIT(CNmChatCtl::_UpdateContainerCaption);
}

void CNmChatCtl::_CalculateFontMetrics()
{
	DBGENTRY(CNmChatCtl::_CalculateFontMetrics);

	ASSERT( m_hWndMsg );
	
	///// Get Info for RichEdit Box
	CHARFORMAT chfmt2;

	int yMaxHeightInTwips = 0;
	for( int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		ZeroMemory( &chfmt2, sizeof( chfmt2 ) );
		_AddFontToCharFormat( chfmt2, i );
		if( yMaxHeightInTwips < chfmt2.yHeight )
		{
			yMaxHeightInTwips = chfmt2.yHeight;
		}
	}

	TEXTMETRIC textmex;
	HDC hdc = ::GetDC( m_hWndMsg );
	::GetTextMetrics( hdc, &textmex );
	::ReleaseDC( m_hWndMsg, hdc );

	/*
	 * Average Width of Char in Twips         Average Width of Chars Logical Unit
	 * ------------------------------    =    -----------------------------------
	 *   Height of Char in Twips                  Height of Char in Logical Unit
	 *
	 */
	int iAveWidthInTwips = yMaxHeightInTwips * textmex.tmAveCharWidth / textmex.tmHeight;
	int iMaxWidthInTwips = yMaxHeightInTwips * textmex.tmMaxCharWidth / textmex.tmHeight;

	// Set the tabs on the two paragraph format rich edit things
	ZeroMemory( &m_paraLine1, sizeof( m_paraLine1 ) );
	m_paraLine1.cbSize = sizeof( m_paraLine1 );
	m_paraLine1.dwMask = PFM_OFFSET | PFM_TABSTOPS | PFM_STARTINDENT | PFM_RIGHTINDENT ;

	ZeroMemory( &m_paraLine2, sizeof( m_paraLine2 ) );
	m_paraLine2.cbSize = sizeof( m_paraLine2 );
	m_paraLine2.dwMask = PFM_OFFSET | PFM_TABSTOPS | PFM_STARTINDENT | PFM_RIGHTINDENT ;
	m_paraLine2.dxStartIndent = MULTILINE_MSG_OFFSET * iAveWidthInTwips;

	int iDelta = 0;
	if( m_bUseDate )
	{
		iDelta = DATE_EXTRA + GetDateFormat(
						LOCALE_USER_DEFAULT,		// locale for which date is to be formatted
						0,							// flags specifying function options
						NULL,						// time to be formatted
						NULL,						// time format string
						NULL,						// buffer for storing formatted string
						0							// size, in bytes or characters, of the buffer
						);

		iDelta *= iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}
		m_paraLine1.cTabCount++;
	}

	if( m_bTimeStamp )
	{
		iDelta = TIME_EXTRA + GetTimeFormat(
						LOCALE_USER_DEFAULT,		// locale for which date is to be formatted
						0,							// flags specifying function options
						NULL,						// time to be formatted
						NULL,						// time format string
						NULL,						// buffer for storing formatted string
						0							// size, in bytes or characters, of the buffer
						);

		iDelta *= iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}

		m_paraLine1.cTabCount++;
	}

	if( m_bUseName )
	{
		iDelta = (MAX_NAME + NAME_EXTRA) * iAveWidthInTwips;
		if( m_paraLine1.cTabCount )
		{
			m_paraLine1.rgxTabs[ m_paraLine1.cTabCount ] = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ] + iDelta;
		}
		else
		{
			m_paraLine1.rgxTabs[ 0 ] = iDelta;
		}

		m_paraLine1.cTabCount++;
	}

	if( m_paraLine1.cTabCount )
	{
		m_paraLine1.dxOffset = m_paraLine1.rgxTabs[ m_paraLine1.cTabCount -1 ];
	}



	DBGEXIT(CNmChatCtl::_CalculateFontMetrics );
}

void CNmChatCtl::_SetContainerStatusText( UINT uID )
{
	DBGENTRY(CNmChatCtl::_SetContainerStatusText);

	TCHAR szStatus[MAX_RESOURCE_STRING_LEN] = "";
	NmCtlLoadString( uID, szStatus, CchMax(szStatus) );
	::SetWindowText(m_hwndSB, szStatus);
	
	DBGEXIT(CNmChatCtl::_SetContainerStatusText);
}


// Get the selected member from the m_hWndMemberList list view...
MEMBER_ID CNmChatCtl::_GetSelectedMember()
{
	DBGENTRY(CNmChatCtl::_GetSelectedMember);

	COMBOBOXEXITEM cbexi;
	ClearStruct( &cbexi );
	cbexi.mask = CBEIF_LPARAM;

	// Find the matching item
	if( CB_ERR == ( cbexi.iItem = ComboBoxEx_GetCurSel(m_hWndMemberList ) ) )
	{	
		ATLTRACE(("CNmChatCtl::_GetSelectedMember - no selection?\n"));
		DBGEXIT(CNmChatCtl::_GetSelectedMember);
		return 0;
	}

	ComboBoxEx_GetItem( m_hWndMemberList, &cbexi );

	MEMBER_ID memberID = (MEMBER_ID)( cbexi.lParam );

	DBGEXIT(CNmChatCtl::_GetSelectedMember);

	return memberID;
}




HRESULT CNmChatCtl::_AddMember(MEMBER_CHANNEL_ID *pMemberID)
{

	DBGENTRY(CNmChatCtl::_AddMember);

	HRESULT hr = S_OK;

	int iImage;
	int iItem = -1;
	TCHAR szName[MAX_PATH*2];

	if (GET_NODE_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID) != pMemberID->nNodeId)
	{

		ULONG cb = T120_GetNodeName(g_pChatObj->m_nConfID,  pMemberID->nNodeId, szName, MAX_PATH*2);

		iImage = II_USER;

		COMBOBOXEXITEM cbexi;
		ClearStruct( &cbexi );
		cbexi.mask = CBEIF_LPARAM | CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE ;
		cbexi.iItem = iItem;
		cbexi.pszText = szName;
		cbexi.cchTextMax = lstrlen(cbexi.pszText);
		cbexi.iSelectedImage = iImage;
		cbexi.iImage = iImage;
		cbexi.lParam = (LPARAM) pMemberID;
		ComboBoxEx_InsertItem(m_hWndMemberList, &cbexi);
	}

	DBGEXIT_HR(CNmChatCtl::_AddMember, hr);
	return hr;

}

HRESULT CNmChatCtl::_RemoveMember(MEMBER_CHANNEL_ID *pMemberID)
{

	DBGENTRY(CNmChatCtl::_RemoveMember);

	HRESULT hr = S_OK;

	int iItem = ComboBoxEx_FindMember( m_hWndMemberList, -1, pMemberID);


	if( -1 != iItem )
	{
		_DeleteMemberListItem( iItem );
    }
    else
    {
        WARNING_OUT(("Could not find the specified item..."));
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

	DBGEXIT_HR(CNmChatCtl::_RemoveMember, hr);

	return hr;
}

HRESULT CNmChatCtl::_SetMenuItemCheck( UINT idItem, BOOL bChecked /* = true */ )
{
    DBGENTRY(CNmChatCtl::_SetMenuItemCheck);
    HRESULT hr = S_OK;
    if( m_hMenuShared )
    {
        MENUITEMINFO mii;
        ClearStruct(&mii);
        mii.cbSize = sizeof( MENUITEMINFO );
        mii.fMask = MIIM_STATE;
        mii.fState = bChecked ? MFS_CHECKED : MFS_UNCHECKED;

        if( !SetMenuItemInfo(m_hMenuShared, idItem, FALSE, &mii) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    DBGEXIT_HR(CNmChatCtl::_SetMenuItemCheck,hr);
    return hr;
}

bool CNmChatCtl::_IsEditWindowVisibleFlagSet(void)
{
    return ( ::IsWindow( m_hWndEdit ) && IsWindowVisible(m_hWndEdit));
}

bool CNmChatCtl::_IsStatusBarVisibleFlagSet(void)
{
    return ( ::IsWindow( m_hwndSB ) && IsWindowVisible(m_hwndSB));
}

int CNmChatCtl::_SaveAs()
{
	int iRet = 0;

	if( NULL == m_lpszSaveFile )
	{
		DBG_SAVE_FILE_LINE
		m_lpszSaveFile = new TCHAR[ MAX_PATH ];
		ASSERT( m_lpszSaveFile );
		if(m_lpszSaveFile == NULL)
		{
			return iRet;
		}
		ZeroMemory( m_lpszSaveFile, sizeof( m_lpszSaveFile ) );
	}

	if( SUCCEEDED( SaveDialog( m_lpszSaveFile, OFN_HIDEREADONLY | OFN_CREATEPROMPT, &m_wFileOffset ) ) )
	{
			// Since the file name has changed, we are dirty....
		m_dwChatFlags |= CHAT_FLAG_DIRTYBIT;

		_Save();
	}
	else
	{
		iRet = IDCANCEL;		
	}

	return iRet;
}


LRESULT CNmChatCtl::SaveDialog(LPTSTR lpszFile, DWORD dwFlags, LPWORD pnFileOffset )
{
    DBGENTRY(CNmChatCtl::SaveDialog)
    HRESULT hr = S_OK;

    TCHAR szFilter[MAX_PATH];
	TCHAR szDefExt[MAX_PATH];

    if( SUCCEEDED ( hr = _GetNmAppletFileOpenFilter( szFilter, CCHMAX( szFilter ), szDefExt, CCHMAX( szDefExt ) ) ) )
    {
        ConvertSzCh(szFilter);

        OPENFILENAME ofn;
        ClearStruct( &ofn );
        ofn.lStructSize = sizeof( OPENFILENAME );
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = szFilter;
		ofn.lpstrFile = lpszFile;
        ofn.nMaxFile = MAX_PATH;
		ofn.lpstrDefExt = szDefExt;
        ofn.Flags = dwFlags;
        if( !GetSaveFileName( &ofn ) )
		{
			hr = E_FAIL;
		}
		else
		{
			*pnFileOffset = ofn.nFileOffset;
		}
    }

    DBGEXIT_HR(CNmChatCtl::SaveDialog,hr)
    return hr;
}

void CNmChatCtl::_SaveWindowPosition()
{
    RECT    rectWindow;

    // If we are not maximized
    if (!::IsZoomed(m_hWnd) && !::IsIconic(m_hWnd))
	{
	    // Get the new window rectangle
    	::GetWindowRect(m_hWnd, &rectWindow);

	    // Write the new option values to file
	    _SetWindowRectOption(&rectWindow);
	}

}


void CNmChatCtl::_SaveChatOptions()
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );

	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_NAME, m_bUseName);
	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_TIME, m_bTimeStamp);
	reWnd.SetValue(OPT_MAIN_INFORMATION_DISPLAY_DATE, m_bUseDate);
	reWnd.SetValue(OPT_MAIN_MESSAGE_FORMAT, m_style);

	for (int i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{
		reWnd.SetValue( OPT_FONT_COLOR[i], &m_hMsgColors[i], sizeof(COLORREF));
		reWnd.SetValue( OPT_FONT_FORMAT[i], &m_hMsgLogFonts[i], sizeof(LOGFONT));
	}
}

BOOL CNmChatCtl::_LoadChatOptions()
{
	BOOL fRet = FALSE;
	int i;
	RegEntry reWnd(CHAT_KEY, HKEY_CURRENT_USER);
	LPVOID pData;

	for (i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
	{	
		if (reWnd.GetBinary(OPT_FONT_COLOR[i], &pData) != sizeof(COLORREF))
			break;
		::CopyMemory(&m_hMsgColors[i], pData, sizeof(COLORREF));

		if (reWnd.GetBinary(OPT_FONT_FORMAT[i], &pData) != sizeof(LOGFONT))
			break;
		::CopyMemory(&m_hMsgLogFonts[i], pData, sizeof(LOGFONT));
	}
	if (i == CChatOptionsDlg::FONT_COUNT)
	{
		for (i = 0; i < CChatOptionsDlg::FONT_COUNT; i++ )
		{
			m_hMsgFonts[ i ] = CreateFontIndirect( &m_hMsgLogFonts[i] );
		}
		m_bUseName = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_NAME);
		m_bTimeStamp = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_TIME);
		m_bUseDate = (BOOL)reWnd.GetNumber(OPT_MAIN_INFORMATION_DISPLAY_DATE);
		m_style = (CNmChatCtl::eMsgStyles)reWnd.GetNumber(OPT_MAIN_MESSAGE_FORMAT);

		fRet = TRUE;
	}
	return fRet;
}


void CNmChatCtl::_Save()
{
	ASSERT( m_lpszSaveFile );

	if( 0 == (m_dwChatFlags & CHAT_FLAG_DIRTYBIT) )
	{
		return;
	}

	TCHAR szDrive[ MAX_PATH ];			
	lstrcpyn( szDrive, m_lpszSaveFile, m_wFileOffset + 1 );
	if( !FDirExists( szDrive ) )
	{
		TCHAR szBuffer[ 2 * MAX_PATH ];
		TCHAR szRes[MAX_PATH];

		wsprintf( szBuffer, RES2T( IDS_CHAT_CREATE_DIRECTORY, szRes ), szDrive );
		if( IDYES == MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_YESNO | MB_ICONQUESTION ) )
		{
			if( !FEnsureDirExists( szDrive ) )
			{
				wsprintf( szBuffer, RES2T( IDS_CHAT_COULD_NOT_CREATE_DIR, szRes ), szDrive );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				return;
			}
		}
	}

	HANDLE hFile = CreateFile( m_lpszSaveFile,
								GENERIC_WRITE,
								0,
								NULL,
								CREATE_ALWAYS,
								0,
								NULL );
	if( INVALID_HANDLE_VALUE == hFile )
	{
		DWORD dw = GetLastError();
		switch( dw )
		{
			case ERROR_ACCESS_DENIED:
			{
				TCHAR szBuffer[ 2 * MAX_PATH ];
				TCHAR szRes[MAX_PATH];

				wsprintf( szBuffer, RES2T( IDS_CHAT_SAVE_ACCESS_DENIED, szRes ), m_lpszSaveFile );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				break;
			}
			default:
			{
				TCHAR szBuffer[ 2 * MAX_PATH ];
				TCHAR szRes[MAX_PATH];

				wsprintf( szBuffer, RES2T( IDS_CHAT_SAVE_FAILED, szRes ), m_lpszSaveFile );
				MessageBox(m_hWnd, szBuffer, RES2T(IDS_CHAT_DOCUMENTNAME, szRes), MB_OK | MB_ICONEXCLAMATION );
				break;
			}
		}
	}
	else
	{
		LPTSTR szHeader1 = TEXT("<HTML>\n<HEAD>\n<TITLE>");
		LPTSTR szHeader2 = TEXT("</TITLE>\n</HEAD>\n<BODY BGCOLOR=\"white\" TEXT=\"black\">\n<TABLE BORDER=1>");
		LPTSTR szEnd = TEXT("</TABLE>\n</BODY>\n</HTML>\n");
		LPTSTR szStartRow = TEXT("<TR><TD>");
		LPTSTR szEndRow = TEXT("</TD></TR>");
		LPTSTR szSplitRow = TEXT("</TD><TD>");
		TCHAR  szPrivateTo[ MAX_PATH ];
		TCHAR  szPrivateFrom[ MAX_PATH ];
		TCHAR  szBuffer[ CCHMAX_CHAT_MSG ];
		DWORD dwWritten;

		NmCtlLoadString(IDS_CHAT_SAVE_PRIVATE_TO, szPrivateTo, MAX_PATH);
		NmCtlLoadString(IDS_CHAT_SAVE_PRIVATE, szPrivateFrom, MAX_PATH);

		WriteFile( hFile, szHeader1, lstrlen( szHeader1 ), &dwWritten, NULL );

		NmCtlLoadString(IDS_CHAT_DOCUMENTNAME, szBuffer, MAX_PATH);
		WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

		WriteFile( hFile, szHeader2, lstrlen( szHeader2 ), &dwWritten, NULL );

		CChatMessage *pMsg = CChatMessage::get_head();
		while( pMsg != NULL )
		{
			CChatMessage::CHAT_MSGTYPE style = pMsg->get_type();
			switch( style )
			{
				case CChatMessage::MSG_SAY:
				case CChatMessage::MSG_WHISPER:
				{

					WriteFile( hFile, szStartRow, lstrlen( szStartRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, m_lpszOwnName );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_date() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_time() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					if( CChatMessage::MSG_WHISPER == style )
					{
						wsprintf( szBuffer, szPrivateTo, pMsg->get_person() );
						WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );
					}

					lstrcpy( szBuffer, pMsg->get_message() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szEndRow, lstrlen( szEndRow ), &dwWritten, NULL );
					break;
				}
				case CChatMessage::MSG_FROM_OTHER:
				case CChatMessage::MSG_WHISPER_FROM_OTHER:
				{
					WriteFile( hFile, szStartRow, lstrlen( szStartRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_person() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_date() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					lstrcpy( szBuffer, pMsg->get_time() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szSplitRow, lstrlen( szSplitRow ), &dwWritten, NULL );

					if( CChatMessage::MSG_WHISPER_FROM_OTHER == style )
					{
						WriteFile( hFile, szPrivateFrom, lstrlen( szPrivateFrom ), &dwWritten, NULL );
					}

					lstrcpy( szBuffer, pMsg->get_message() );
					WriteFile( hFile, szBuffer, lstrlen( szBuffer ), &dwWritten, NULL );

					WriteFile( hFile, szEndRow, lstrlen( szEndRow ), &dwWritten, NULL );
					break;
				}
				default:
				{
					break;
				}
			}
			pMsg = pMsg->get_next();
		};

		WriteFile( hFile, szEnd, lstrlen( szEnd ), &dwWritten, NULL );
		CloseHandle( hFile );

		m_dwChatFlags &= ~CHAT_FLAG_DIRTYBIT;
	}
}


inline BOOL CNmChatCtl::_IsPrinting()
{
	return( m_dwChatFlags & CHAT_PRINT_FLAG_PRINTING );
}

// From: KB Article ID: Q129860
// Modified by t-ivanl
void CNmChatCtl::_PrintIt(HDC hPrinterDC )
{
	DBGENTRY(CNmChatCtl::_PrintIt);

	FORMATRANGE		fr;
	int				nHorizRes =		GetDeviceCaps(hPrinterDC, HORZRES);
	int				nVertRes =		GetDeviceCaps(hPrinterDC, VERTRES);
	int				nLogPixelsX =	GetDeviceCaps(hPrinterDC, LOGPIXELSX);
	int				nLogPixelsY =	GetDeviceCaps(hPrinterDC, LOGPIXELSY);
	LONG			lTextLength = 0;   // Length of document.
	LONG			lTextPrinted = 0;  // Amount of document printed.
	TCHAR			lpszDateOrTime[ MAX_PATH ];
	TCHAR			lpszHeader[ MAX_PATH ];
	RECT            rcPrintLoc;

	// Ensure the printer DC is in MM_TEXT mode.
	SetMapMode ( hPrinterDC, MM_TEXT );

	// Rendering to the same DC we are measuring.
	ZeroMemory(&fr, sizeof(fr));
	fr.hdc = fr.hdcTarget = hPrinterDC;

	// Set up the page.
	fr.rcPage.left     = fr.rcPage.top = 0;
	fr.rcPage.right    = (nHorizRes/nLogPixelsX) * TWIPSPERINCH;
	fr.rcPage.bottom   = (nVertRes/nLogPixelsY) * TWIPSPERINCH;

	// Set up 1" margins all around.
	fr.rc.left   = fr.rcPage.left + TWIPSPERINCH;
	fr.rc.top    = fr.rcPage.top + TWIPSPERINCH;
	fr.rc.right  = fr.rcPage.right - TWIPSPERINCH;
	fr.rc.bottom = fr.rcPage.bottom - TWIPSPERINCH;

	// Default the range of text to print as the entire document.
	fr.chrg.cpMin = 0;
	fr.chrg.cpMax = -1;

	// Set up the print job (standard printing stuff here).
	DOCINFO di;
	ZeroMemory(&di, sizeof(di));
	di.cbSize = sizeof(DOCINFO);

	// Set the document name
	DBG_SAVE_FILE_LINE
	LPTSTR lpszDocName = new TCHAR[ MAX_PATH ];
	ASSERT( lpszDocName );
	NmCtlLoadString(IDS_CHAT_DOCUMENTNAME, lpszDocName, MAX_PATH);
	di.lpszDocName = lpszDocName;

	NmCtlLoadString(IDS_CHAT_HEADER, lpszHeader, MAX_PATH);
	GetDateFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, lpszDateOrTime, CCHMAX( lpszDateOrTime ) );
	lstrcat( lpszHeader, lpszDateOrTime );
	lstrcat( lpszHeader, TEXT(" " ) );
	GetTimeFormat( LOCALE_USER_DEFAULT, 0, NULL, NULL, lpszDateOrTime, CCHMAX( lpszDateOrTime ) );
	lstrcat( lpszHeader, lpszDateOrTime );

	GETTEXTLENGTHEX txtLength;
	txtLength.flags = GTL_NUMCHARS | GTL_PRECISE;
	txtLength.codepage = CP_ACP;

	int bufferSize = (int)::SendMessage( m_hWndMsg, EM_GETTEXTLENGTHEX, (WPARAM)&txtLength, 0 );
	if(bufferSize == E_INVALIDARG)
	{
		return;
	}

	lTextLength =bufferSize;


	if( lTextLength > 1 )
	{
		m_hWndPrint = ::CreateDialog( g_hInstance,
									MAKEINTRESOURCE( IDD_CHAT_PRINT ),
									m_hWnd,
									_PrintDlgProc );
		ASSERT( m_hWndPrint );

		SetAbortProc( hPrinterDC, _AbortProc );

		// Start the document.
		StartDoc(hPrinterDC, &di);

		while( (lTextPrinted < lTextLength) && (0 == (CHAT_PRINT_FLAG_ABORT & m_dwChatFlags) ) )
		{
			// Start the page.
			StartPage(hPrinterDC);

			// New Header print code for bugfix #29365 [mmaddin].
			rcPrintLoc.left   = nLogPixelsX;
			rcPrintLoc.top    = nLogPixelsY / 2;
			rcPrintLoc.right  = fr.rc.right;
			rcPrintLoc.bottom = fr.rc.bottom;
			DrawText( hPrinterDC, lpszHeader, lstrlen( lpszHeader ), &rcPrintLoc, 0);

			// Print as much text as can fit on a page. The return value is the
			// index of the first character on the next page.
			lTextPrinted = (LONG)::SendMessage(m_hWndMsg,
								      	EM_FORMATRANGE,
										FALSE,
										(LPARAM)&fr);
			if( 0 != lTextPrinted )
			{
				::SendMessage(m_hWndMsg, EM_DISPLAYBAND, 0, (LPARAM)&fr.rc);
			}

			// Print last page.
			EndPage(hPrinterDC);


			if(lTextPrinted < fr.chrg.cpMin)
			{
				break;
			}

			// If there is more text to print, adjust the range of characters to
			// start printing at the first character of the next page.
			if( 0 == lTextPrinted )
			{
				break;
			}
			else if (lTextPrinted < lTextLength)
			{
				fr.chrg.cpMin = lTextPrinted;
				fr.chrg.cpMax = -1;
			}
		}

		// Tell the control to release cached information.
		::SendMessage(m_hWndMsg, EM_FORMATRANGE, 0, (LPARAM)NULL);

		EndDoc(hPrinterDC);
	}

	delete [] lpszDocName;

	EndDialog( m_hWndPrint, 0 );

	DBGEXIT(CNmChatCtl::_PrintIt);
}

HRESULT CNmChatCtl::_Print()
{

	DBGENTRY(CNmChatCtl::_Print);
	HRESULT hr = E_FAIL;

	if( 0 == ( CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED & m_dwChatFlags ) )
	{
		ZeroMemory( &m_PrintDlg, sizeof( m_PrintDlg ) );
		m_PrintDlg.lStructSize = sizeof( m_PrintDlg );
		m_PrintDlg.hwndOwner = m_hWnd;
		m_PrintDlg.Flags = PD_ALLPAGES | PD_NOPAGENUMS | PD_NOSELECTION | PD_RETURNDC | PD_DISABLEPRINTTOFILE;
		m_dwChatFlags |= CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED;
	}
	
	BOOL b;
	if( FALSE != (b = PrintDlg( &m_PrintDlg ) ) )
	{
		ms_pThis = this;
		_PrintIt( m_PrintDlg.hDC );
		ms_pThis = NULL;
		hr = S_OK;
	}
	
	DBGEXIT_HR(CNmChatCtl::_Print, hr);

	return hr;
}

BOOL CALLBACK CNmChatCtl::_AbortProc( HDC hdcPrinter, int iCode )
{
	MSG msg;

	while( (0 == (CHAT_PRINT_FLAG_ABORT & ms_pThis->m_dwChatFlags) ) &&
		PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
	{
		if( NULL == ms_pThis->m_hWndPrint ||
			!::IsDialogMessage( ms_pThis->m_hWndPrint, &msg ) )
		{
			TranslateMessage( &msg );
			DispatchMessage( &msg );
		}
	}

	return(0 == (CHAT_PRINT_FLAG_ABORT & ms_pThis->m_dwChatFlags) );
}

INT_PTR CALLBACK CNmChatCtl::_PrintDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_INITDIALOG:
		{
			return TRUE;
			break;
		}
		case WM_COMMAND:
		{
			switch( LOWORD( wParam ) )
			{
				case IDCANCEL:
				{
					ms_pThis->m_dwChatFlags |= CHAT_PRINT_FLAG_ABORT;
					//EndDialog( hDlg, CHAT_PRINT_FLAG_ABORT );
					return TRUE;
				}
			}
		}
	}
	return FALSE;
}

INT_PTR CALLBACK CNmChatCtl::_AboutDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{
	switch( uiMsg )
	{
		case WM_INITDIALOG:
		{

            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hDlg, IDC_CHAT_ABOUT_VERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hDlg, IDC_CHAT_ABOUT_VERSION, szVersion);

			return TRUE;
			break;
		}
		case WM_QUIT:
		case WM_COMMAND:
		{
			EndDialog( hDlg, IDOK );
			return TRUE;
		}
	}
	return FALSE;
}





INT_PTR CALLBACK CChatOptionsDlg::_OptionsDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam )
{

	switch(uiMsg)
	{
		case WM_INITDIALOG:
			g_pChatWindow->m_pChatOptions->OnInit(hDlg);
			break;
			
		case WM_HELP:
			g_pChatWindow->m_pChatOptions->OnHelp(lParam);
			break;
			
		case WM_CONTEXTMENU:
			g_pChatWindow->m_pChatOptions->OnHelpWhatsThis(wParam);
			break;

		case WM_COMMAND:
			g_pChatWindow->m_pChatOptions->OnCommand(wParam);
			break;
	}

	return 0;
}


void CChatOptionsDlg::OnCommand(WPARAM wParam)
{

	switch( LOWORD( wParam ) )
	{
		case IDOK:
		OnOkClicked();
		break;
			
		case IDCANCEL:
		OnCancelClicked();
		break;
			
		case IDC_FONT_MSGOUT:
		case IDC_FONT_MSGIN:
		case IDC_FONT_PRIVATEOUT:
		case IDC_FONT_PRIVATEIN:
		OnFontClicked(LOWORD( wParam ));
		break;
	}
}








CChatOptionsDlg::CChatOptionsDlg( CNmChatCtl *pChatCtl )
		: m_pChatCtl( pChatCtl )
{
}


void CChatOptionsDlg::_DisplayFontNameAndSize( int iFont )
{
	TCHAR szBuffer[ MAX_PATH ];
	TCHAR szRes[MAX_PATH];


	ASSERT( iFont < FONT_COUNT );

	wsprintf( szBuffer, RES2T( IDS_CHAT_OPTIONS_FONT_FORMAT,szRes ),
			_Points_From_LogFontHeight( m_hMsgLogFonts[iFont].lfHeight, m_pChatCtl->GetHandle() ),
			m_hMsgLogFonts[iFont].lfFaceName );

	HWND hwndEdit = NULL;

	switch( iFont )
	{
		case FONT_MSGOUT:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_MSGOUT );
			break;
		}
		case FONT_MSGIN:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_MSGIN );
			break;
		}
		case FONT_PRIVATEOUT:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_PRIVATEOUT );
			break;
		}
		case FONT_PRIVATEIN:
		{
			hwndEdit = GetDlgItem(m_hOptionsDlg, IDC_EDIT_PRIVATEIN );
			break;
		}
	}
	::SetWindowText( hwndEdit, szBuffer );

}

LRESULT CChatOptionsDlg::OnInit(HWND hDlg)
{
	m_hOptionsDlg = hDlg;

	for( int i = 0; i < FONT_COUNT; i++ )
	{
		m_hMsgLogFonts[ i ] = m_pChatCtl->m_hMsgLogFonts[ i ];
		m_hMsgColors[ i ] = m_pChatCtl->m_hMsgColors[ i ];
		m_bDirtyFonts[ i ] = FALSE;
		_DisplayFontNameAndSize( i );
	}

	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bUseName,
		0L );

	::SetFocus( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ));

		
	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_DATE ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bUseDate,
		0L );
	::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_TIME ),
		BM_SETCHECK,
		(WPARAM)m_pChatCtl->m_bTimeStamp,
		0L );

	switch( m_pChatCtl->m_style )
	{
		case CNmChatCtl::MSGSTYLE_2_LINE_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_NEW_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
		case CNmChatCtl::MSGSTYLE_1_LINE_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SAME_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
		case CNmChatCtl::MSGSTYLE_NO_WRAP:
			::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SINGLE_LINE ),
				BM_SETCHECK,
				TRUE,
				0L );
			break;
	}

	return 0L;
}

LRESULT CChatOptionsDlg::OnHelp(LPARAM lParam)
{
	DoHelp(lParam, _mpIdHelpChatOptions);
	return 0L;
}

LRESULT CChatOptionsDlg::OnHelpWhatsThis(WPARAM wParam)
{
	DoHelpWhatsThis(wParam, _mpIdHelpChatOptions);
	return 0L;
}


LRESULT CChatOptionsDlg::OnOkClicked()
{
	BOOL bChanged = FALSE;


	// View Fields
	BOOL bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_NAME ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bUseName == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bUseName = (short)bVal;

	bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_TIME ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bTimeStamp == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bTimeStamp = (short)bVal;

	bVal = (BOOL)::SendMessage( GetDlgItem(m_hOptionsDlg, IDC_INCLUDE_DATE ),
							BM_GETCHECK,
							0L,
							0L );
	bChanged = ( !m_pChatCtl->m_bUseDate == !bVal ) ? bChanged : TRUE;
	m_pChatCtl->m_bUseDate = (short)bVal;

	// Msg Style
	CNmChatCtl::MSGSTYLE style;
	if( ::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SINGLE_LINE ),
		BM_GETCHECK,
		0L,
		0L ) )
	{
		style = CNmChatCtl::MSGSTYLE_NO_WRAP;
	}
	else if( ::SendMessage( GetDlgItem(m_hOptionsDlg, IDR_SAME_LINE ),
		BM_GETCHECK,
		0L,
		0L ) )
	{
		style = CNmChatCtl::MSGSTYLE_1_LINE_WRAP;
	}
	else
	{
		style = CNmChatCtl::MSGSTYLE_2_LINE_WRAP;
	}

	bChanged = ( style == m_pChatCtl->get_MsgStyle() ) ? bChanged : TRUE;					

	// Fonts
	for( int i = 0; i < FONT_COUNT; i++ )
	{
		if( m_bDirtyFonts[i] )
		{
			m_pChatCtl->m_hMsgColors[ i ] = m_hMsgColors[ i ];
			m_pChatCtl->m_hMsgLogFonts[ i ] = m_hMsgLogFonts[ i ];
			DeleteObject( m_pChatCtl->m_hMsgFonts[i] );
			m_pChatCtl->m_hMsgFonts[i] = CreateFontIndirect( &m_pChatCtl->m_hMsgLogFonts[ i ] );
			bChanged = TRUE;
		}
	}
	if( bChanged )
	{
		m_pChatCtl->put_MsgStyle( style );
	}

	EndDialog(m_hOptionsDlg, IDOK );
	return 0L;
}

LRESULT CChatOptionsDlg::OnCancelClicked()
{
	EndDialog(m_hOptionsDlg, IDCANCEL );
	return 0L;
}

LRESULT CChatOptionsDlg::OnFontClicked(WORD wID)
{
	int iIndex = FONT_COUNT;

	switch( wID )
	{
		case IDC_FONT_MSGOUT:
		{
			iIndex = FONT_MSGOUT;
			break;
		}
		case IDC_FONT_MSGIN:
		{
			iIndex = FONT_MSGIN;
			break;
		}
		case IDC_FONT_PRIVATEOUT:
		{
			iIndex = FONT_PRIVATEOUT;
			break;
		}
		case IDC_FONT_PRIVATEIN:
		{
			iIndex = FONT_PRIVATEIN;
			break;
		}
		default:
			ASSERT( 0 );
	}

	CHOOSEFONT cf;
	ZeroMemory( &cf, sizeof( cf ) );
	cf.lStructSize = sizeof( cf );
	cf.hwndOwner = m_hOptionsDlg;
	cf.Flags = CF_FORCEFONTEXIST | CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_EFFECTS;
	cf.lpLogFont = &m_hMsgLogFonts[ iIndex ];
	cf.rgbColors = m_hMsgColors[ iIndex ];

	if( ChooseFont( &cf ) )
	{
		m_bDirtyFonts[ iIndex ] = TRUE;
		m_hMsgColors[ iIndex ] = cf.rgbColors;
		_DisplayFontNameAndSize( iIndex );
	}

	return 0L;
}



//
//
// Function: _GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void _GetWindowRectOption(LPRECT pRect)
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );
	pRect->left = reWnd.GetNumber( REGVAL_WINDOW_XPOS, 0);
	pRect->top = reWnd.GetNumber( REGVAL_WINDOW_YPOS, 0);
	int cx = reWnd.GetNumber( REGVAL_WINDOW_WIDTH, 0);
	int cy = reWnd.GetNumber( REGVAL_WINDOW_HEIGHT, 0);
	pRect->right = pRect->left + cx;
	pRect->bottom = pRect->top + cy;

	int	iTop = pRect->top;
	int iLeft = pRect->left;
	int iBottom = pRect->bottom;
	int iRight = pRect->right;

	//
	// If it was an empty rect
	//
	if( !(pRect->bottom || pRect->top || pRect->left || pRect->right) )
	{
		MINMAXINFO lpmmi;
		g_pChatWindow->OnGetMinMaxInfo(&lpmmi);
		iTop = 50;
		iLeft = 50;
		iBottom = lpmmi.ptMinTrackSize.y + 100;
		iRight = lpmmi.ptMinTrackSize.x + 200;

		pRect->top = iTop;
		pRect->left = iLeft;
		pRect->bottom = iBottom;
		pRect->right = iRight;
		return;
	}
		
	// Make sure that the window rectangle is (at least partially) on
	// screen, and not too large.  First get the screen size
	int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
   // Check the window size
	if ((iRight - iLeft) > screenWidth)
	{
		iRight = iLeft + screenWidth;
	}
	
	if ((iBottom - iTop) > screenHeight)
	{
		iTop = screenHeight;
	}

	// Check the window position
	if (iLeft >= screenWidth)
	{
		// Off screen to the right - keep the width the same
		iLeft  = screenWidth - (iRight - iLeft);
		iRight = screenWidth;
	}

	if (iRight < 0)
	{
		// Off screen to the left - keep the width the same
		iRight = iRight - iLeft;
		iLeft  = 0;
	}

	if (iTop >= screenHeight)
	{
		// Off screen to the bottom - keep the height the same
		iTop    = screenHeight - (iBottom - iTop);
		iBottom = screenHeight;
	}

    if (iBottom < 0)
	{
		// Off screen to the top - keep the height the same
		iBottom = (iBottom - iTop);
		iTop    = 0;
	}

	pRect->left = iLeft;
	pRect->top = iTop;
	pRect->right = iRight;
	pRect->bottom = iBottom;
}

//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
void _SetWindowRectOption(LPCRECT pcRect)
{
	RegEntry reWnd( CHAT_KEY, HKEY_CURRENT_USER );
	reWnd.SetValue( REGVAL_WINDOW_XPOS, pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_YPOS, pcRect->top );
	reWnd.SetValue( REGVAL_WINDOW_WIDTH, pcRect->right - pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_HEIGHT, pcRect->bottom - pcRect->top );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\message.cpp ===
#include "precomp.h"
#include "Message.h"

CChatMessage *CChatMessage::ms_pFirst = NULL;
int          CChatMessage::ms_cMessages = 0;
CChatMessage *CChatMessage::ms_pLast = NULL;
int			 CChatMessage::ms_iMessageLimit = INITIAL_LIMIT;

CChatMessage *CChatMessage::get_head()
{
	return ms_pFirst;
}


int CChatMessage::get_count()
{
	return ms_cMessages;
}


CChatMessage *CChatMessage::get_last()
{
	return ms_pLast;
}

void CChatMessage::put_limit( int iLimit )
{
	ASSERT( iLimit >= 1 );

	ms_iMessageLimit = iLimit;

	while( ms_cMessages > ms_iMessageLimit )
	{
		CChatMessage *pKillMe = ms_pFirst;
		ms_pFirst = ms_pFirst->m_pNext;
		delete pKillMe;
	}
}

int CChatMessage::get_limit()
{
	return ms_iMessageLimit;
}

CChatMessage *CChatMessage::get_next() const
{
	return m_pNext;
}


CChatMessage *CChatMessage::get_prev() const
{
	return m_pPrev;
}


CChatMessage::CHAT_MSGTYPE CChatMessage::get_type() const
{
	return m_msgType;
}


const LPTSTR CChatMessage::get_date() const
{
	return m_szDate;
}


const LPTSTR CChatMessage::get_time() const
{
	return m_szTime;
}


const LPTSTR CChatMessage::get_person() const
{
	return m_szPerson;
}


const LPTSTR CChatMessage::get_message() const
{
	return m_szMessage;
}

CChatMessage::CChatMessage( LPCTSTR szPerson, LPCTSTR szMessage, CHAT_MSGTYPE msgType )
	: m_msgType( msgType ), m_szDate( NULL ), m_szTime( NULL ), 
	m_szPerson( NULL ), m_szMessage( NULL ), m_pNext( NULL ), m_pPrev( NULL )
{
	_GetDate();
	_GetTime();
	m_szPerson = _CopyString( szPerson );
	m_szMessage = _CopyString( szMessage );

	if( 0 == ms_cMessages )
	{
		ms_pFirst = this;
		ms_pLast = this;
	}
	else
	{
		ms_pLast->m_pNext = this;
		m_pPrev = ms_pLast;
		ms_pLast = this;
	}

	ms_cMessages++;

	while( ms_cMessages > ms_iMessageLimit )
	{
		CChatMessage *pKillMe = ms_pFirst;
		ms_pFirst = ms_pFirst->m_pNext;
		delete pKillMe;
	}
}


CChatMessage::~CChatMessage()
{
	delete [] m_szDate;
	delete [] m_szTime;
	delete [] m_szPerson;
	delete [] m_szMessage;

	ms_cMessages--;
}

void CChatMessage::DeleteAll()
{
	CChatMessage *pMsg = ms_pFirst;

	while( pMsg )
	{
		CChatMessage *pNext = pMsg->m_pNext;
		delete pMsg;
		pMsg = pNext;
	}

	ms_pFirst = NULL;
	ms_pLast = NULL;
	ms_cMessages = 0;
}

LPTSTR CChatMessage::_CopyString( LPCTSTR sz )
{
	LPTSTR szNew = NULL;
	if( NULL == sz )
	{
		DBG_SAVE_FILE_LINE
		szNew = new TCHAR[1];
		ASSERT( szNew );
		if( NULL == szNew )
		{
			return NULL;
		}
		szNew[0] = '\0';
	}
	else
	{
		int iLen = lstrlen( sz ) + 1;
		DBG_SAVE_FILE_LINE
		szNew = new TCHAR[ iLen ];
		ASSERT( szNew );
		if( NULL == szNew )
		{
			return NULL;
		}
		lstrcpyn( szNew, sz, iLen );
	}

	return szNew;
}


void CChatMessage::_GetDate()
{
	int iLen = 1 + GetDateFormat(
						LOCALE_USER_DEFAULT,       // locale for which date is to be formatted
						0,     // flags specifying function options
						NULL,                     // time to be formatted
						NULL,  // time format string
						NULL,  // buffer for storing formatted string
						0        // size, in bytes or characters, of the buffer
						);

	m_szDate = new TCHAR[ iLen ];
	ASSERT( m_szDate );
	if( 0 == (iLen = GetDateFormat(
				LOCALE_USER_DEFAULT,       // locale for which date is to be formatted
				0,     // flags specifying function options
				NULL,                     // time to be formatted
				NULL,  // time format string
				m_szDate,  // buffer for storing formatted string
				iLen   // size, in bytes or characters, of the buffer
				) ) )
	{
		DWORD dw = GetLastError();
		WARNING_OUT(( TEXT("CChatMessage::_GetDate: Can not get date") ));
	}
	else
	{
		m_szDate[ iLen ] = '\0';
	}
}


void CChatMessage::_GetTime(void)
{
	int iLen = 1 + GetTimeFormat(
						LOCALE_USER_DEFAULT,       // locale for which time is to be formatted
						0,     // flags specifying function options
						NULL,                     // time to be formatted
						NULL,  // time format string
						NULL,  // buffer for storing formatted string
						0        // size, in bytes or characters, of the buffer
						);

	m_szTime = new TCHAR[ iLen ];
	ASSERT( m_szTime );
	if( 0 == (iLen = GetTimeFormat(
				LOCALE_USER_DEFAULT,       // locale for which time is to be formatted
				0,     // flags specifying function options
				NULL,                     // time to be formatted
				NULL,  // time format string
				m_szTime,  // buffer for storing formatted string
				iLen   // size, in bytes or characters, of the buffer
				) ) )
	{
		DWORD dw = GetLastError();
		WARNING_OUT(( TEXT("CChatMessage::_GetTime: Can not get time") ));
	}
	else
	{
		m_szTime[ iLen ] = '\0';
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmctl1.cpp ===
// ChatCtl.cpp : Implementation of DLL Exports.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ChatCtlps.mk in the project directory.

#include "precomp.h"
#include "NmCtl1.h"
#include "Comboboxex.h"
#include <confguid.h>

BYTE   szStr[MAX_PATH];
GCCRequestTag GccTag;

extern CChatObj	*g_pChatObj;
extern CNmChatCtl	*g_pChatWindow;
extern HANDLE g_hWorkThread;

GUID guidNM2Chat = { 0x340f3a60, 0x7067, 0x11d0, { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
#define cbKeyApp (4 + 1 + sizeof(GUID) + sizeof(DWORD))


static unsigned char H221IDGUID[5] = {H221GUIDKEY0,
                                      H221GUIDKEY1,
                                      H221GUIDKEY2,
                                      H221GUIDKEY3,
                                      H221GUIDKEY4};

static BYTE s_keyApp[cbKeyApp];

// Create an H.221 application key with a guid
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}


/*  S E T  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: SetAppKey

	Set the two pieces of an OctetString (the length and the data.)
	Note that the length always includes the terminating null character.
----------------------------------------------------------------------------*/
VOID SetAppKey(LPOSTR pOct, LPBYTE lpb)
{
	pOct->length = cbKeyApp;
	pOct->value = lpb;
}

/*  C R E A T E  A P P  K E Y */
/*----------------------------------------------------------------------------
    %%Function: CreateAppKey

	Given a guid and a userid, create the appropriate application key.

	The key is formated as:
	0xB5 0x00 0x53 0x4C  - Microsoft Object Identifier
	0x01                 - guid identifier
	<binary guid>        - guid data
	<dword node id>      - user node id
----------------------------------------------------------------------------*/
VOID CreateAppKey(LPBYTE lpb, GUID * pguid, DWORD dwUserId)
{
	CreateH221AppKeyFromGuid(lpb, pguid);
	CopyMemory(lpb + cbKeyApp - sizeof(DWORD), &dwUserId, sizeof(DWORD));
}


#define NODE_ID_ONLY			0x01
#define SEND_ID_ONLY			0x02
#define PRIVATE_SEND_ID_ONLY    0x04
#define WHISPER_ID_ONLY			0x08
#define ALL_IDS					0x10


/*
**  Return the array index of the first duplicate copy
*/
int IsAlreadyInArray(MEMBER_CHANNEL_ID *aArray, MEMBER_CHANNEL_ID *pMember, int nSize, int nFlag)
{
	int  i;

	for (i = 0; i < nSize; i++)
	{
		if (NODE_ID_ONLY == nFlag)
		{
			if (aArray[i].nNodeId == pMember->nNodeId)
				break;
		}
		else if (SEND_ID_ONLY == nFlag)
		{
			if (aArray[i].nSendId == pMember->nSendId)
			break;
		}
		else if (PRIVATE_SEND_ID_ONLY == nFlag)
		{
			if (aArray[i].nPrivateSendId == pMember->nPrivateSendId)
				break;
		}
		else if (WHISPER_ID_ONLY)
		{
			if (aArray[i].nWhisperId == pMember->nWhisperId)
				break;
		}
		else if (ALL_IDS == nFlag)
		{
			if ((aArray[i].nNodeId == pMember->nNodeId)&&
				(aArray[i].nSendId == pMember->nSendId)&&
				(aArray[i].nPrivateSendId == pMember->nPrivateSendId)&&
				(aArray[i].nWhisperId == pMember->nWhisperId))
			break;
		}
	}
	return (i < nSize)?i:-1;
}

void ChatTimerProc(HWND hWnd, UINT uMsg, UINT_PTR nTimerID, DWORD dwTime)
{
    if (g_pChatObj)
    {
        g_pChatObj->SearchWhisperId();
    }
}


#include "NmCtlDbg.h"
HINSTANCE   g_hInstance;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        MyInitDebugModule();
		DisableThreadLibraryCalls(hInstance);
		g_hInstance = hInstance;
		DBG_INIT_MEMORY_TRACKING(hInstance);

        ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_LIBRARY_LOADED);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_CHAT, APPLET_LIBRARY_FREED);

        DBG_CHECK_MEMORY_TRACKING(hDllInst);
	    MyExitDebugModule();
    }
	return TRUE;    // ok
}



//
// T120 Applet Functions
//


void CALLBACK T120AppletCallbackProc
(
	T120AppletMsg 		*pMsg
)
{
	CChatObj *pCHATOBJ = (CChatObj *) pMsg->pAppletContext;
	if (pCHATOBJ == g_pChatObj)
	{
		switch (pMsg->eMsgType)
		{
		case GCC_PERMIT_TO_ENROLL_INDICATION:
			pCHATOBJ->OnPermitToEnroll(pMsg->PermitToEnrollInd.nConfID,
									 pMsg->PermitToEnrollInd.fPermissionGranted);
			break;

		case T120_JOIN_SESSION_CONFIRM:
		default:
			break;
		}
	}
}


void CALLBACK T120SessionCallbackProc
(
	T120AppletSessionMsg	*pMsg
)
{
	if(g_pChatObj == NULL)
	{
		return;
	}

	CChatObj *pSession = (CChatObj *) pMsg->pSessionContext;
    ASSERT(pMsg->pAppletContext == pMsg->pSessionContext);
	if (pSession == g_pChatObj)
	{
        ASSERT(pMsg->nConfID == pSession->GetConfID());
		switch (pMsg->eMsgType)
		{
        case MCS_UNIFORM_SEND_DATA_INDICATION:
		//
		// Check if we are receiving a indication from owrself
		//
		if(pMsg->SendDataInd.initiator == GET_USER_ID_FROM_MEMBER_ID(g_pChatObj->m_MyMemberID))
		{
			return;
		}
        case MCS_SEND_DATA_INDICATION:
				MCSSendDataIndication(
                        pMsg->SendDataInd.user_data.length,
                        pMsg->SendDataInd.user_data.value,
						pMsg->SendDataInd.channel_id,
                        pMsg->SendDataInd.initiator);
            break;

		case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
//			m_fWaitingForBufferAvailable = FALSE;
			break;


        case GCC_APP_ROSTER_REPORT_INDICATION:
            pSession->OnRosterIndication((ULONG) pMsg->AppRosterReportInd.cRosters, pMsg->AppRosterReportInd.apAppRosters);
            break;

		case T120_JOIN_SESSION_CONFIRM:
			pSession->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
			break;

        case GCC_RETRIEVE_ENTRY_CONFIRM:
			// Asynchronous Registry Retrieve Confirm message
			pSession->OnRegistryEntryConfirm(&pMsg->RegistryConfirm);
			break;

		default:
			break;
		}
	}
}


CChatObj::CChatObj() :
	m_pApplet(NULL),
	m_aMembers(&g_aMembers[0]),
	m_nTimerID(0)
{
	DBGENTRY(CChatObj::CChatObj);

	// Construct GCCAppProtEntityList
    ::ZeroMemory(&m_ChatProtocolEnt, sizeof(m_ChatProtocolEnt));
	m_ChatProtocolEnt.must_be_invoked = TRUE;
	m_ChatProtocolEnt.number_of_expected_capabilities = 0;
	m_ChatProtocolEnt.expected_capabilities_list = NULL;
	m_ChatProtocolEnt.startup_channel_type = MCS_DYNAMIC_MULTICAST_CHANNEL;

    // construct the applet key
	m_ChatProtocolEnt.session_key.application_protocol_key.key_type = APPLET_H221_NONSTD_KEY;
	SetAppKey(&m_ChatProtocolEnt.session_key.application_protocol_key.h221_non_standard_id, szStr);
	::CreateH221AppKeyFromGuid(szStr, (GUID *)&guidNM2Chat );

    // ape list
    m_pChatProtocolEnt = &m_ChatProtocolEnt;
	m_AppProtoEntList.cApes = 1;
	m_AppProtoEntList.apApes = &m_pChatProtocolEnt;

    // broadcast
	::ZeroMemory(&m_NodeList, sizeof(m_NodeList));

	// Cleanup per-conference T.120 info
	CleanupPerConf();

    // set the global pointer
	g_pChatObj = this;

	// T.120 Applet
	T120Error rc = ::T120_CreateAppletSAP(&m_pApplet);
	if (T120_NO_ERROR != rc)
	{
		ERROR_OUT(("CChatObj::CChatObj: cannot create applet SAP"));
		return;
	}

	ASSERT(NULL != m_pApplet);
	m_pApplet->Advise(T120AppletCallbackProc, this);

	DBGEXIT(CChatObj::CChatObj);
}

	
CChatObj::~CChatObj()
{

	DBGENTRY(CChatObj::~CChatObj);

	ASSERT(NULL == m_pAppletSession);
	ASSERT(NULL == m_pApplet);

	delete g_pChatWindow;

	DBGEXIT(CChatObj::~CChatObj);
}


void CChatObj::LeaveT120(void)
{
	// no more T.120
	if (NULL != m_pAppletSession)
	{
		m_pAppletSession->ReleaseInterface();
		CleanupPerConf();
	}
	if (NULL != m_pApplet)
	{
		m_pApplet->ReleaseInterface();
		m_pApplet = NULL;
	}
}


void CChatObj::OnPermitToEnroll
(
	T120ConfID			nConfID,
	BOOL				fPermissionGranted
)
{
	if (fPermissionGranted)
	{
		// We are not in a conference, right?
		ASSERT(NULL == m_pAppletSession);

		// Create an applet session
		T120Error rc = m_pApplet->CreateSession(&m_pAppletSession, nConfID);
		if (T120_NO_ERROR == rc)
		{
			ASSERT(NULL != m_pAppletSession);
			m_pAppletSession->Advise(T120SessionCallbackProc, this, this);

			// Build join-sesion request
			::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
			m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER;

			// Non standard key
			CreateAppKey(s_keyApp, &guidNM2Chat, 0);
			GCCObjectKey FAR * pObjKey;
			pObjKey = &m_JoinSessionReq.SessionKey.application_protocol_key;
			pObjKey->key_type = GCC_H221_NONSTANDARD_KEY;
			SetAppKey(&(pObjKey->h221_non_standard_id), s_keyApp);

			m_JoinSessionReq.SessionKey.session_id = m_sidMyself;
			m_JoinSessionReq.fConductingCapable = FALSE;
			m_JoinSessionReq.nStartupChannelType =MCS_DYNAMIC_MULTICAST_CHANNEL;

			//
			// Retrieve registry key
			//
			::ZeroMemory(&m_resourceRequest, sizeof(m_resourceRequest));
			m_resourceRequest.eCommand = APPLET_JOIN_DYNAMIC_CHANNEL;
			m_resourceRequest.RegKey.session_key = m_JoinSessionReq.SessionKey;
			SetAppKey(&m_resourceRequest.RegKey.resource_id, s_keyApp);
			m_JoinSessionReq.cResourceReqs = 1;
			m_JoinSessionReq.aResourceReqs = &m_resourceRequest;




			// Join now
			rc = m_pAppletSession->Join(&m_JoinSessionReq);
			if (T120_NO_ERROR == rc)
			{
                m_nConfID = nConfID;
            }
            else
            {
				WARNING_OUT(("CChatObj::OnPermitToEnroll: cannot join conf=%u, rc=%u", nConfID, rc));
			}
		}
	}
	else
	{
		if (NULL != m_pAppletSession)
		{
			T120RegistryRequest Req;
			::ZeroMemory(&Req, sizeof(Req));
			Req.eCommand = APPLET_DELETE_ENTRY;
			Req.pRegistryKey = &m_resourceRequest.RegKey;
			m_pAppletSession->RegistryRequest(&Req);

			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CChatObj::OnJoinSessionConfirm
(
	T120JoinSessionConfirm		*pConfirm
)
{
	if (NULL != m_pAppletSession)
	{
		ASSERT(m_pAppletSession == pConfirm->pIAppletSession);
		if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
		{
			m_uidMyself = pConfirm->uidMyself;
			m_sidMyself = pConfirm->sidMyself;
			m_eidMyself = pConfirm->eidMyself;
			m_nidMyself = pConfirm->nidMyself;

			// get the broadcast channel
			m_broadcastChannel = pConfirm->aResourceReqs[0].nChannelID;

			// create member ID
			m_MyMemberID = MAKE_MEMBER_ID(m_nidMyself, m_uidMyself);

			// we are now in the conference
			m_fInConference = TRUE;

			if(g_pChatWindow)
			{
				g_pChatWindow->_UpdateContainerCaption();
				g_pChatWindow->_AddEveryoneInChat();
			}

			// Invoke applet on other nodes (for interop with NM 2.x)
            InvokeApplet();

			// Register channel with GCC (for interop with NM 2.x)
			T120RegistryRequest Req;
			GCCRegistryKey		registry_key;
			BYTE				SessionKey[cbKeyApp];
			BYTE				ResourceKey[cbKeyApp];

			::ZeroMemory(&Req, sizeof(Req));
			Req.eCommand = APPLET_REGISTER_CHANNEL;
			::CopyMemory(&registry_key.session_key, 
					&m_resourceRequest.RegKey.session_key, sizeof(GCCSessionKey));
			CreateAppKey(SessionKey, &guidNM2Chat, 0);
			CreateAppKey(ResourceKey, &guidNM2Chat, m_nidMyself);
			SetAppKey(&registry_key.session_key.application_protocol_key.h221_non_standard_id, SessionKey);
			SetAppKey(&registry_key.resource_id, ResourceKey);
			Req.pRegistryKey = &registry_key;
			Req.nChannelID = m_uidMyself;

			m_pAppletSession->RegistryRequest(&Req);
					
		}
		else
		{
			WARNING_OUT(("CChatObj::OnJoinSessionConfirm: failed to join conference, result=%u. error=%u", pConfirm->eResult, pConfirm->eError));
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CChatObj::InvokeApplet(void)
{
	m_ChatProtocolEnt.session_key.session_id = m_sidMyself;
	if (m_pAppletSession)
	{
		m_pAppletSession->InvokeApplet(&m_AppProtoEntList, &m_NodeList, &GccTag);
	}
}

void CChatObj::OnRosterIndication
(
    ULONG           cRosters,
    GCCAppRoster    *apRosters[]
)
{
	if (IsInConference())
	{
		BOOL fAdded = FALSE;
		BOOL fRemoved = FALSE;
		ULONG cOtherMembers = 0;
		ULONG i, j, k;

		// Caculate how many members in this session
		for (i = 0; i < cRosters; i++)
		{
			GCCAppRoster *pRoster = apRosters[i];

			// bail out if this roster is not for this session
			if (pRoster->session_key.session_id != m_sidMyself)
			{
					continue;
			}

			// node added or removed?
			fAdded |= pRoster->nodes_were_added;
			fRemoved |= pRoster->nodes_were_removed;

			// parse the roster records
			for (j = 0; j < pRoster->number_of_records; j++)
			{
				GCCAppRecord *pRecord = pRoster->application_record_list[j];
				// Because the flag is_enrolled_actively is not set correctly in 
				// NM 2.11, we don't bother to check it.
				// MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
				if (pRecord->node_id != m_nidMyself)
				{
					cOtherMembers++;
				}
				
			} // for
		} // for

		// If there are changes, we then do the update
		if (fAdded || fRemoved || cOtherMembers != g_pChatWindow->m_cOtherMembers)
		{
			MEMBER_CHANNEL_ID aTempMembers[MAX_MEMBERS]; // scratch copy

			// make sure we are able to handle it
			if (cOtherMembers >= MAX_MEMBERS)
			{
				ERROR_OUT(("CChatObj::OnRosterIndication: we hit the max members limit, cOtherMembers=%u, max-members=%u",
						cOtherMembers, MAX_MEMBERS));
				cOtherMembers = MAX_MEMBERS;
			}

			// reset the flags for members added and removed
			fAdded = FALSE;
			fRemoved = FALSE;

			// copy the members
			ULONG idxTempMember = 0;
			for (i = 0; i < cRosters; i++)
			{
				GCCAppRoster *pRoster = apRosters[i];

				// bail out if this roster is not for this session
				if (pRoster->session_key.session_id != m_sidMyself)
				{
					continue;
				}

				// parse the roster records
				for (j = 0; j < pRoster->number_of_records; j++)
				{
					GCCAppRecord *pRecord = pRoster->application_record_list[j];
					// Because of a bug in NM2.11, we don't check flag is_enrolled_actively
					// MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
					if (pRecord->node_id != m_nidMyself && idxTempMember < cOtherMembers)
					{
						aTempMembers[idxTempMember].nNodeId = pRecord->node_id;
						aTempMembers[idxTempMember].nSendId = aTempMembers[idxTempMember].nPrivateSendId =
							aTempMembers[idxTempMember].nWhisperId = pRecord->application_user_id;
						idxTempMember++;

						// let's see if it is an 'add' or a 'delete'
						for (k = 0; k <  g_pChatWindow->m_cOtherMembers; k++)
						{
							if (m_aMembers[k].nNodeId == pRecord->node_id)
							{
								::ZeroMemory(&m_aMembers[k], sizeof(MEMBER_CHANNEL_ID));
								break;
							}
						}
						fAdded |= (k >=  g_pChatWindow->m_cOtherMembers); // not found, must be new
					}
				} // for
			} // for

			// sanity check
			ASSERT(idxTempMember == cOtherMembers);

			// see if there are ones that are not in the new roster.
			// if so, they must be removed.
			for (k = 0; k <  g_pChatWindow->m_cOtherMembers; k++)
			{
				if (m_aMembers[k].nNodeId)
				{
					fRemoved = TRUE;
					g_pChatWindow->_RemoveMember(&m_aMembers[k]);
				}
			}

			// now, update the member array
			g_pChatWindow->m_cOtherMembers = cOtherMembers;
			if ( g_pChatWindow->m_cOtherMembers)
			{
				ASSERT(sizeof(m_aMembers[0]) == sizeof(aTempMembers[0]));
				::CopyMemory(&m_aMembers[0], &aTempMembers[0],  g_pChatWindow->m_cOtherMembers * sizeof(m_aMembers[0]));

				// Setup Send Channel Id
				int nDuplicates = 0;
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					int nIndex = IsAlreadyInArray(m_aMembers, &m_aMembers[k], k, NODE_ID_ONLY);
					if (nIndex >= 0)
					{
						m_aMembers[nIndex].nSendId = m_aMembers[k].nSendId;
						nDuplicates++;
						m_aMembers[k].nNodeId = 0;
					}
				}

				// Remove all zeroed out regions
				if (nDuplicates)
				{
					k = 0;
					while (k < g_pChatWindow->m_cOtherMembers)
					{
						if (0 == m_aMembers[k].nNodeId)
						{
							for (i = k + 1; i < g_pChatWindow->m_cOtherMembers; i++)
							{
								if (m_aMembers[i].nNodeId)
									break;
							}
							if (i < g_pChatWindow->m_cOtherMembers)
							{
								m_aMembers[k] = m_aMembers[i];
								m_aMembers[i].nNodeId = 0;
							}
						}
						k++;
					}
				}
				g_pChatWindow->m_cOtherMembers -= nDuplicates;

				// Get the current selection
				MEMBER_CHANNEL_ID *pMemberID = (MEMBER_CHANNEL_ID*)g_pChatWindow->_GetSelectedMember();

				// Add the members to the list
				g_pChatWindow->_DeleteAllListItems();
				g_pChatWindow->_AddEveryoneInChat();
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					g_pChatWindow->_AddMember(&m_aMembers[k]);
				}

				// Remove the bogus whisperId for Nm 2.x nodes
				BOOL fHasNM2xNode = FALSE;
				for (k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
				{
					if (T120_GetNodeVersion(m_nConfID, m_aMembers[k].nNodeId) < 0x0404)
					{   // Version 2.x, give it a whisper id of 0
						m_aMembers[k].nWhisperId = 0;
						fHasNM2xNode = TRUE;
					}
				}

				if ((fHasNM2xNode)&&(!m_nTimerID))
				{   // time out every 1 sec
					m_nTimerID = ::SetTimer(NULL, 0, 1000,  ChatTimerProc);
				}

				//
				// Goto the current selection, if it is still there.
				//
				i = ComboBoxEx_FindMember(g_pChatWindow->GetMemberList(), 0, pMemberID);
				if(i == -1 )
				{
					i = 0;
				}
				ComboBoxEx_SetCurSel( g_pChatWindow->GetMemberList(), i );

			}

			g_pChatWindow->_UpdateContainerCaption();

		} // if any change
	} // if is in conf
}


void CChatObj::OnRegistryEntryConfirm(GCCRegistryConfirm *pRegistryConfirm)
{
	BOOL  fAllFound = TRUE;
	// This is generated by "m_pAppletSession->RegistryRequest(&Req)" above to
	// retrieve the channel id number of NM 2.x nodes
	if (T120_RESULT_SUCCESSFUL == pRegistryConfirm->nResult)
	{
		// Update the m_aWhisperIds array.
		T120NodeID nNodeId;
		::CopyMemory(&nNodeId, pRegistryConfirm->pRegKey->resource_id.value + cbKeyApp - sizeof(DWORD), 
			sizeof(T120NodeID));
		T120ChannelID nChannelId = pRegistryConfirm->pRegItem->channel_id;
		WARNING_OUT(("Receive registry: node id 0x%x, channel id 0x%x.\n",
						nNodeId, nChannelId));
		for (ULONG k = 0; k < g_pChatWindow->m_cOtherMembers; k++)
		{
			if (m_aMembers[k].nNodeId == nNodeId)
			{
				m_aMembers[k].nWhisperId = nChannelId;
			}
			if (fAllFound && (0 == m_aMembers[k].nWhisperId))
			{
				fAllFound = FALSE;
				WARNING_OUT(("Node 0x%x is still not updated.\n", 
							m_aMembers[k].nNodeId));
			}
		}
		if (fAllFound)
		{
			::KillTimer(NULL, m_nTimerID);
			m_nTimerID = 0;
			WARNING_OUT(("All updated. Kill timer.\n"));
		}
	}
}



void CChatObj::CleanupPerConf(void)
{
	m_fInConference = FALSE;
	m_pAppletSession = NULL;
	m_MyMemberID = 0;
    m_nConfID = 0;      // Conf ID
	m_uidMyself = 0;	// User ID
	m_sidMyself = 0;	// Session ID
	m_eidMyself = 0;	// Entity ID
	m_nidMyself = 0;	// Node ID
	if(g_pChatWindow)
	{
		g_pChatWindow->m_cOtherMembers = 0;
		g_pChatWindow->_UpdateContainerCaption();
		g_pChatWindow->_DeleteAllListItems();
	}
}


T120Error CChatObj::SendData
(
	T120UserID		userID,
    ULONG           cbDataSize,
    PBYTE           pbData
)
{
	T120Error rc;

	if (IsInConference())
	{
    	rc = m_pAppletSession->SendData(
                            NORMAL_SEND_DATA,
                            userID,
                            APPLET_LOW_PRIORITY,
                            pbData,
                            cbDataSize,
                            APP_ALLOCATION);
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


void CChatObj::SearchWhisperId(void)
{
	T120RegistryRequest Req;
	GCCRegistryKey		registry_key;
	BYTE				SessionKey[cbKeyApp];
	BYTE				ResourceKey[cbKeyApp];

    if (NULL != m_pAppletSession)
    {
	    // Set up T120RegistryRequest
        ZeroMemory(&Req, sizeof(Req));
    	Req.eCommand = APPLET_RETRIEVE_ENTRY;
	    ::CopyMemory(&registry_key.session_key, 
			&m_resourceRequest.RegKey.session_key, sizeof(GCCSessionKey));
    	CreateAppKey(SessionKey, &guidNM2Chat, 0);
	    SetAppKey(&registry_key.session_key.application_protocol_key.h221_non_standard_id, SessionKey);
    	SetAppKey(&registry_key.resource_id, ResourceKey);
	    Req.pRegistryKey = &registry_key;

    	for (ULONG i = 0; i < g_pChatWindow->m_cOtherMembers; i++)
	    {
		    if (m_aMembers[i].nWhisperId == 0)
		    {
			    CreateAppKey(ResourceKey, &guidNM2Chat, m_aMembers[i].nNodeId);
    			m_pAppletSession->RegistryRequest(&Req);
	    		WARNING_OUT(("Send search registry for node 0x%x.\n", m_aMembers[i].nNodeId));
		    }
        }
	}
}


void MCSSendDataIndication(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID)
{
	if(g_pChatWindow)
	{
		g_pChatWindow->_DataReceived(uSize, pb, destinationID, senderID);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmchatctl.h ===
#ifndef __NMCHATCTL_H_
#define __NMCHATCTL_H_


// Includes
#include "resource.h" 
#include "richedit.h"
#include "message.h"
#include <confreg.h>
#include <gencontrols.h>
#include <gencontainers.h>

#include "Chatldr.h"
typedef ULONG_PTR	MEMBER_ID;				// loword = node_id, hiword = user_id



extern HINSTANCE   g_hInstance;
#define STRING_RESOURCE_MODULE g_hInstance
#define RES2T(uID, psz ) ( Res2THelper( uID, psz, RES_CH_MAX ) )


#include <standrd.h>

#define DECLARE_NMAPPLET_FILE_OPEN_FILTER(idStringResourceFilter, idStringResourceExt) \
static HRESULT _GetNmAppletFileOpenFilter( LPTSTR szFilter, int cchMaxFilter, LPTSTR szExtension, int cchMaxExtension )\
{	HRESULT hr = S_OK;\
	DBGENTRY(_GetNmAppletFileOpenFilter);\
	if( SUCCEEDED( hr = NmCtlLoadString( idStringResourceFilter, szFilter, cchMaxFilter ) ) )\
	{\
		hr = NmCtlLoadString( idStringResourceExt, szExtension, cchMaxExtension );\
	}\
	DBGEXIT_HR(_GetNmAppletFileOpenFilter,hr);\
    return hr;\
}



//
// Extra windows messages for the chat
//
enum
{
    WM_USER_BRING_TO_FRONT_WINDOW  =   WM_USER,
};

#define RES_CH_MAX 256


#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))


// Forward Decls
class CNmChatCtl;
class CChatOptionsDlg;

#define PIX_FROM_DLGU_X( XDLGU, XDBU )  MulDiv(XDLGU, XDBU, 4 )
#define PIX_FROM_DLGU_Y( YDLGU, YDBU )  MulDiv(YDLGU, YDBU, 8 ) 

#define CHAT_FLAG_NONE								0
#define CHAT_PRINT_FLAG_PRINTING					1
#define CHAT_PRINT_FLAG_PRINTDLG_INITIALIZED		2
#define CHAT_PRINT_FLAG_ABORT						4
#define CHAT_FLAG_DIRTYBIT							8

#define TWIPSPERINCH								1440

#define ICON_BIG_SIZE								32
#define ICON_SMALL_SIZE								16

#define INVALIDATE_BACKGROUND						FALSE


void _SetWindowRectOption(LPCRECT pcRect);
void _GetWindowRectOption(LPRECT pRect);




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CChatOptionsDlg
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CChatOptionsDlg
{
friend CNmChatCtl;

private:
	enum { FONT_MSGOUT,
			FONT_MSGIN,
			FONT_PRIVATEOUT,
			FONT_PRIVATEIN,
			FONT_MSGSYSTEM,
			FONT_COUNT
	};

	CNmChatCtl	*m_pChatCtl;
	LOGFONT		m_hMsgLogFonts[ FONT_COUNT ];
	COLORREF	m_hMsgColors[ FONT_COUNT ];
	BOOL		m_bDirtyFonts[ FONT_COUNT ];

public:
	static WORD	IDD;

private:

public:
	CChatOptionsDlg( CNmChatCtl *pChatCtl );
	static INT_PTR CALLBACK _OptionsDlgProc( HWND hDlg,UINT uiMsg, WPARAM wParam, LPARAM lParam );
	void OnCommand(WPARAM wParam);

private:
	
	HWND	m_hOptionsDlg;
	LRESULT OnInit(HWND hDlg);
	LRESULT OnHelp(LPARAM lParam);
	LRESULT OnHelpWhatsThis(WPARAM wParam);
	LRESULT OnOkClicked();
	LRESULT OnCancelClicked();
	LRESULT OnFontClicked(WORD wID);
	void _DisplayFontNameAndSize( int iFont );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNmChatCtl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

struct MEMBER_CHANNEL_ID;

class CNmChatCtl
{
friend CChatOptionsDlg;

public:  // Data Decls

    enum eWndIDs{ MsgWndID = 1,
				  MemberListWndID,
				  EditWndID,
                  SendWndID,
				  StaticMessageID,
				  StaticSendToID
    };

    enum eStates { state_Idle,
                   state_MessageWaiting
    };

	enum eMenuPos { MENUPOS_FILE = 0,
					MENUPOS_EDIT,
					MENUPOS_VIEW,
					MENUPOS_HELP
	};

private: // Data Decls
        // Constants
    enum {DXP_ICON_SMALL = 16 };
	enum {DYP_ICON_SMALL = 16 };
	enum {DYP_CHAT_EDIT = 46 };
	enum {DYP_CHAT_USERS = 46 };
	enum {DXP_CHAT_SEND = 46 };
	enum {DYP_CHAT_SEND = 46 };
	enum {DXP_CHAT_DEST = 100 };
	enum {CCHMAX_CHAT_MSG = 2048 };
	enum {CB_NM2_HDR = 8 };
	enum {ILV_NAME = 0 };
	enum {ILV_TIME = 1 };
	enum {ILV_TEXT = 2 };
	enum {MSG_EXTRA = 4 };
	enum {MAX_DATE = 10 };
	enum {DATE_EXTRA = 1 };
	enum {TIME_EXTRA = 1 };
	enum {MAX_NAME = 15 };
	enum {NAME_EXTRA = 1 };
	enum {MULTILINE_MSG_OFFSET = 5 };
	enum {MSGLIST_DLU_Y = 14 };
	enum {MSGLIST_VISMEMBERS = 5 };
	enum {SPACING_DLU_X = 4 };
	enum {STATIC_DLU_Y = 4 };

	// menu item group constants
    CONSTANT( CHAT_WITH_FILEMENU_NUM_EDITGROUP_ITEMS = 3 );
    CONSTANT( CHAT_WITH_FILEMENU_NUM_OBJECTGROUP_ITEMS = 0 );
    CONSTANT( CHAT_WITH_FILEMENU_NUM_HELPGROUP_ITEMS = 1 );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_EDITGROUP_ITEMS = 1 );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_OBJECTGROUP_ITEMS = CHAT_WITH_FILEMENU_NUM_OBJECTGROUP_ITEMS );
    CONSTANT( CHAT_WITHOUT_FILEMENU_NUM_HELPGROUP_ITEMS  = CHAT_WITH_FILEMENU_NUM_HELPGROUP_ITEMS );


        // These are the icon indices for the listview icon bitmaps
    enum { II_PERSON_PERSON = 1,
           II_EXCLAMATION = 14,
           II_USER = 16
    };

	typedef enum eMsgStyles
	{
		MSGSTYLE_2_LINE_WRAP,
		MSGSTYLE_1_LINE_WRAP,
		MSGSTYLE_NO_WRAP
	} MSGSTYLE;

protected: // Data


	HWND m_hWnd;
    HACCEL     m_hAccelTable;

	static	   CNmChatCtl	*ms_pThis;

	ULONG	   m_cchBufferSize;
    HIMAGELIST m_himlIconSmall;
	HINSTANCE  m_hInstRichEd32;
		
	LPTSTR     m_lpszOwnName;
	LPTSTR     m_szPrivate;
	LPTSTR     m_szTo;
	int		   m_iExtra;
	int        m_iNameLen;

	LPTSTR		m_lpszRichEdEOL;
	LPTSTR		m_lpszRichEd;

	// Msg fonts and colors
	COLORREF	m_hMsgColors[ CChatOptionsDlg::FONT_COUNT ];
	HFONT		m_hMsgFonts[ CChatOptionsDlg::FONT_COUNT ];
	LOGFONT		m_hMsgLogFonts[ CChatOptionsDlg::FONT_COUNT ];

	// UI sizing
	int			m_iStaticLen;
	int			m_iDLGUY;
	int			m_iDLGUX;
	int			m_iStaticY;

	// Msg style formats
	PARAFORMAT m_paraLine1;
	PARAFORMAT m_paraLine2;

	DWORD		m_dwChatFlags;

	// For printing
	PRINTDLG	m_PrintDlg;
	HWND		m_hWndPrint;

	// Count of messages in conference for whether or not to display conference ended
	ULONG		m_cMessages;

	// Saving
	LPTSTR		m_lpszSaveFile;
	WORD		m_wFileOffset;

    // Window stuff    
	HWND			 m_hWndMsg;         // Message window alias

	HWND	m_hWndMemberList;  // Destination (0=everyone)
	HWND	m_hWndEdit;        // Edit control
	HWND	m_hWndSend;        // Send Button
	HWND	m_hWndStaticMessage;
	HWND	m_hWndStaticSendTo;
	HWND	m_hwndSB;			// Status bar

	CBitmapButton  * m_pButton;

	
    BOOL             m_bWeAreActiveApp;

    HMENU m_hMenuShared;

	BOOL			m_bStatusBarVisible;


	// Properties
	short											m_bUseName;
	short											m_bTimeStamp;
	short											m_bUseDate;
	MSGSTYLE										m_style;


public: // Construction/destruction and initialization
	CNmChatCtl();
    ~CNmChatCtl();

    ULONG	m_cOtherMembers;
	HWND	GetMemberList(){return m_hWndMemberList;}

protected:

	static LRESULT ChatMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);



        // Window Message and Command Handling functions for Main Window
	LRESULT OnCreate(WPARAM wParam, LPARAM lParam);
    LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT OnCharEditWnd(UINT uMsg, WPARAM wParam, LPARAM lParam);
	LRESULT OnInitMenuPopup(WPARAM wParam, LPARAM lParam);
	void OnSendClicked(void);
	LRESULT SaveDialog(LPTSTR lpszFile, DWORD dwFlags, LPWORD pnFileOffset );
    void cmdFileSave(void);
    void cmdFileSaveAs(void);
    void cmdFilePrint(void);
	void cmdFileExit(WPARAM wparam);
    void cmdViewStatusBar(void);

	LRESULT OnNotifyEnLink(ENLINK *pEnLink);
	LRESULT OnContextMenu(short, short);

    void cmdViewEditWindow(void);
    void cmdViewOptions(void);
    void cmdEditCut(void);
    void cmdEditCopy(void);
    void cmdEditPaste(void);
    void cmdEditClearAll(void);
    void cmdHelpHelpTopics(void);
    void cmdHelpAboutChat(void);
 

protected:
	STDMETHOD(OnMenuSelect)( IN DWORD wParam, IN DWORD lParam );
	STDMETHOD(OnCommand)( IN WPARAM wParam, IN LPARAM lParam );

protected:
        // INmChatCtl Interface implementation
	STDMETHOD(ResetView)();

        // These may be in the interface is the future...
	STDMETHOD(put_ShowName)(/*[in]*/ short bShowName );
	STDMETHOD(get_ShowName)(/*[out]*/ short *pbShowName );
	STDMETHOD(put_Timestamp)(/*[in]*/ short bUseTimeStamp );
	STDMETHOD(get_Timestamp)(/*[out]*/ short *pbUseTimeStamp );
	STDMETHOD(put_Date)(/*[in]*/ short bUseDate );
	STDMETHOD(get_Date)(/*[out]*/ short *pbUseDate );
	STDMETHOD(put_MsgStyle)(/*[in]*/ MSGSTYLE iStyle );
	MSGSTYLE get_MsgStyle();

private: // Helper Fns
	static BOOL CALLBACK _AbortProc( HDC hdcPrinter, int iCode );
	static INT_PTR CALLBACK _PrintDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam );
	static INT_PTR CALLBACK _AboutDlgProc( HWND hDlg,	UINT uiMsg, WPARAM wParam, LPARAM lParam );

    // Notifitation helpers
    
	void	_CalculateFontMetrics();
    void	_DecrementNumOtherMembers( void );
	void	_DeleteFonts( void );
    HRESULT _DeleteMemberListItem( int iIndex );
	void	_DisplayMsg( CChatMessage *pChatMsg, BOOL bBatchRedraw = TRUE );
	bool	_FCreate(HWND hwndParent);
	void	_FreeView(void);
    HBITMAP _GetHBITMAP( DWORD dwID );
	HRESULT _GetOwnName();
    void	_IncrementNumOtherMembers( void );
    bool	_IsEditWindowVisibleFlagSet(void);
	bool    _IsStatusBarVisibleFlagSet(void);
	void	_InitFontsAndColors();
    void	_FreeIconImages( void );
    void	_LoadIconImages( void );
	void	_LoadStrings();
	HRESULT _Print();
	void	_PrintIt(HDC hPrinterDC );
	void	_ReDisplayMessages();
	void	_Redraw(void);
	void	_Resize(int x, int y, int cx, int cy);
    HRESULT _SendChatText(void);
    void	_SetContainerStatusText( UINT uID );
    HRESULT _SetMenuItemCheck( UINT idItem, BOOL bChecked = TRUE  );
	void 	_SaveWindowPosition();
    void    _SaveChatOptions();
    BOOL    _LoadChatOptions();
	void	_Save();
	int	    _SaveAs();
	void	_ShiftFocus(HWND hwndCur, BOOL fForward);
    HRESULT _UpdateContainerStatusText( void );


	inline BOOL _IsPrinting();
	
	inline void _Write_Msg( LPTSTR pszText );
	inline void _Write_Msg_Range_Format( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat );
	inline void _Write_Date_And_Time( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Own_Name( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat );
	inline void _Write_Message( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Private_In( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_Private_Out( LPTSTR pszText, CHARRANGE& charRange, CHARFORMAT& charFormat, CChatMessage *pChatMsg );
	inline void _Write_New_Line_If_Needed( CHARRANGE& charRange, CHARFORMAT& chatFormat );
	inline void _AddFontToCharFormat( CHARFORMAT& chatFormat, int i );

public:
		BOOL FilterMessage(MSG* pMsg);
		void BringToFront(void);
	    void _UpdateContainerCaption( void );
		void OnGetMinMaxInfo (LPMINMAXINFO lpmmi);
		HWND GetHandle(void){return m_hWnd;}
		int QueryEndSession(void);
		CChatOptionsDlg * m_pChatOptions;

		void _DataReceived(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID);
		HRESULT _AddEveryoneInChat();
		MEMBER_ID _GetSelectedMember();
		HRESULT _AddMember(MEMBER_CHANNEL_ID *pMemberID);
		HRESULT _RemoveMember(MEMBER_CHANNEL_ID *pMemberID);
	    void	_DeleteAllListItems( void );

		DECLARE_NMAPPLET_FILE_OPEN_FILTER(IDS_CHAT_SAVE_FILTER_STRING, IDS_CHAT_SAVE_DEF_EXT )

};

#endif //__NMCHATCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\precomp.h ===
//
// Precompiled header stuff
//


#define OEMRESOURCE
#define STRICT 1


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define ATLTRACE

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <cderr.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>


//
// NM headers
//
#define MULTI_LEVEL_ZONES
#include <ConfDbg.h>
#include <mlzdbg.h>
#include "NmCtlDbg.h"
#include "ms_util.h"
#include "memtrack.h"
#include "t120type.h"

#include <regentry.h>
#include <dllutil.h>

#include "nmchatctl.h"
#include "CHATldr.h"
#include "nmctl1.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmctldbg.h ===
#ifndef __NmCtlDbg_h__
#define __NmCtlDbg_h__

#ifdef _DEBUG

    
    #ifdef ATLTRACE
        #undef ATLTRACE
    #endif 

    void DbgZPrintAtlTrace(LPCTSTR pszFormat,...);
    bool MyInitDebugModule(void);
    void MyExitDebugModule(void);

    #define ZONE_ATLTRACE   3
    #define ZONE_ATLTRACE_FLAG 0x08
    #define ATLTRACE DbgZPrintAtlTrace

#else

    inline bool MyInitDebugModule(void) { return true; }
    inline void MyExitDebugModule(void) { ; }

#endif // _DEBUG



#endif // __NmCtlDbg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmctldbg.cpp ===
#include "precomp.h"
#include "NmCtlDbg.h"


#ifdef _DEBUG

    static PTCHAR _rgZones[] = {
	    TEXT("NmCtl1"),
	    TEXT("Warning"),
	    TEXT("Trace"),
	    TEXT("Function"),
	    TEXT("AtlTrace")
    };

    bool MyInitDebugModule(void)
    {
        g_pcszSpewModule = _rgZones[0];
	    DBGINIT(&ghDbgZone, _rgZones);
	    return true;
    }

    void MyExitDebugModule(void)
    {
	    g_pcszSpewModule = NULL;
	    DBGDEINIT(&ghDbgZone);
    }


    void DbgZPrintAtlTrace(LPCTSTR pszFormat,...)
    {
	    if (GETZONEMASK(ghDbgZone) & ZONE_ATLTRACE_FLAG)
	    {
		    va_list v1;
		    va_start(v1, pszFormat);
            DbgPrintf(NULL, pszFormat, v1 );
		    va_end(v1);
	    }
    }



#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmctl1.h ===
// nmctl1.h : Declaration of the CNMChatObj

#ifndef __NMCHATOBJ_H_
#define __NMCHATOBJ_H_

#include <igccapp.h>
#include "resource.h"       // main symbols
#include <it120app.h>

typedef struct MEMBER_CHANNEL_ID
{
	T120NodeID		nNodeId;
	T120ChannelID	nSendId;
	T120ChannelID	nPrivateSendId;
	T120ChannelID	nWhisperId;
} MEMBER_CHANNEL_ID;

//
// Member ID
//
#define MAKE_MEMBER_ID(nid, uid)				(MAKELONG((nid), (uid)))
#define GET_NODE_ID_FROM_MEMBER_ID(id)          (LOWORD(id))
#define GET_USER_ID_FROM_MEMBER_ID(id)          (HIWORD(id))

//
// Member ID arrays, assuming 512 members
//
#define MAX_MEMBERS			512
static MEMBER_CHANNEL_ID g_aMembers[MAX_MEMBERS];
void MCSSendDataIndication(ULONG uSize, LPBYTE pb, T120ChannelID destinationID, T120UserID senderID);




/////////////////////////////////////////////////////////////////////////////
// CNMChatObj
class  CChatObj
{

public: // Construction/destruction and initialization
	CChatObj();
    ~CChatObj();

	//
	// T120 stuff
	//
	IT120Applet		*m_pApplet;
	IT120AppletSession	*m_pAppletSession;
	T120JoinSessionRequest	m_JoinSessionReq;
	T120ResourceRequest	m_resourceRequest;
	T120TokenRequest	m_tokenRequest;
	T120ConfID		m_nConfID;
	T120UserID		m_uidMyself;
	T120SessionID		m_sidMyself;
	T120EntityID		m_eidMyself;
	T120NodeID		m_nidMyself;
	T120ChannelID		m_broadcastChannel;
	MEMBER_CHANNEL_ID	*m_aMembers;
	BOOL			m_fInConference;
	MEMBER_ID		m_MyMemberID;
	UINT_PTR		m_nTimerID;

    GCCAppProtocolEntity    m_ChatProtocolEnt;
    GCCAppProtocolEntity   *m_pChatProtocolEnt;
    GCCAppProtEntityList    m_AppProtoEntList;
    GCCSimpleNodeList       m_NodeList;
	
	BOOL IsInConference(void) { return m_fInConference; }
    T120ConfID GetConfID(void) { return m_nConfID; }
    void OnPermitToEnroll(T120ConfID, BOOL fPermissionGranted);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnAllocateHandleConfirm(GCCRegAllocateHandleConfirm *);
    void OnRosterIndication(ULONG cRosters, GCCAppRoster *apRosters[]);
    void OnRegistryEntryConfirm(GCCRegistryConfirm *);
    void CleanupPerConf(void);
	void LeaveT120(void);
	void SearchWhisperId(void);
	void InvokeApplet(void);

	T120Error SendData(T120UserID userID, ULONG cb, PBYTE pb);
};

#endif //__NMCHATOBJ_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\nmsysinfo.h ===
#ifndef __NmSysInfo_h__
#define __NmSysInfo_h__

#include "SDKInternal.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CNmSysInfoObj
class ATL_NO_VTABLE CNmSysInfoObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CNmSysInfoObj, &CLSID_NmSysInfo>,
	public IConnectionPointContainerImpl<CNmSysInfoObj>,
	public IConnectionPointImpl<CNmSysInfoObj, &IID_INmSysInfoNotify, CComDynamicUnkArray>,
	public INmSysInfo2,
	public IMarshal
{

	CComPtr<IInternalConfExe> m_spConfHook;

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NMSYSINFO)
DECLARE_NOT_AGGREGATABLE(CNmSysInfoObj)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNmSysInfoObj)
	COM_INTERFACE_ENTRY(INmSysInfo)
	COM_INTERFACE_ENTRY(INmSysInfo2)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IMarshal)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CNmSysInfoObj)
	CONNECTION_POINT_ENTRY(IID_INmSysInfoNotify)
END_CONNECTION_POINT_MAP()

	HRESULT FinalConstruct();
	void FinalRelease();

///////////////////////////////////////////////
// INmSysInfo methods

	STDMETHOD(IsInstalled)(void);
	STDMETHOD(GetProperty)(NM_SYSPROP uProp, BSTR *pbstrProp);
	STDMETHOD(SetProperty)(NM_SYSPROP uProp, BSTR bstrName);
	STDMETHOD(GetUserData)(REFGUID rguid, BYTE **ppb, ULONG *pcb);
	STDMETHOD(SetUserData)(REFGUID rguid, BYTE *pb, ULONG cb);
	STDMETHOD(GetNmApp)(REFGUID rguid,BSTR *pbstrApplication, BSTR *pbstrCommandLine, BSTR *pbstrDirectory);
	STDMETHOD(SetNmApp)(REFGUID rguid,BSTR bstrApplication, BSTR bstrCommandLine, BSTR bstrDirectory);
	STDMETHOD(GetNmchCaps)(ULONG *pchCaps);
	STDMETHOD(GetLaunchInfo)(INmConference **ppConference, INmMember **ppMember);

///////////////////////////////////////////////
// INmSysInfo2 methods

    STDMETHOD(GetOption)(NM_SYSOPT uOption, ULONG * plValue);
    STDMETHOD(SetOption)(NM_SYSOPT uOption, ULONG lValue);
    STDMETHOD(ProcessSecurityData)(DWORD dwTaskCode, DWORD dwParam1, DWORD dwParam2, DWORD * pdwResult);
    STDMETHOD(GkLogon)(BSTR bstrAddr, BSTR bstrName, NM_ADDR_TYPE addrType);
	STDMETHOD(GkLogoff)();
    STDMETHOD(GkState)(NM_GK_STATE* plState);


/////////////////////////////////////////////////////////////////////////////////
// IMarshal methods

    STDMETHOD(GetUnmarshalClass)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID *pCid) { *pCid = CLSID_NmSysInfo; return S_OK; };

    STDMETHOD(GetMarshalSizeMax)(
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD *pSize) { *pSize = 0; return S_OK; }

    STDMETHOD(MarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void *pvDestContext,
            /* [in] */ DWORD mshlflags) { return S_OK; }

    STDMETHOD(UnmarshalInterface)(
            /* [unique][in] */ IStream *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv);

    STDMETHOD(ReleaseMarshalData)(
            /* [unique][in] */ IStream *pStm) { return S_OK; }

    STDMETHOD(DisconnectObject)(
            /* [in] */ DWORD dwReserved) { return S_OK; }

///////////////////////////////////////////////
// Notifications and callbacks
public:

///////////////////////////////////////////////
// Helper Fns

	HRESULT _EnsureConfHook(void);

private:
	static bool _GetKeyDataForProp(NM_SYSPROP uProp, HKEY * phkey, LPTSTR * ppszSubKey, LPTSTR * ppszValue, bool *pfString);
	static void _GetSzKeyForGuid(LPTSTR psz, REFGUID rguid);
};


#endif // __NmSysInfo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NmCtl1.rc
//

/////////////////////////////////////////////
// Registry resource IDS
#define IDR_NMAPP						50
#define IDR_NMCHATCTL                   51
#define IDR_CONTAINERCONTROL			52
#define IDR_MSLABLTI					54
#define IDR_NMSYSINFO					55
#define IDR_NMMANAGER				    56
/////////////////////////////////////////////

#define IDS_SYSTEM_HELP  				60
#define IDS_SIZE_HELP                   61440
#define IDS_MOVE_HELP                   61456
#define IDS_MINIMIZE_HELP               61472
#define IDS_MAXIMIZE_HELP               61488
#define IDS_CLOSE_HELP                  61536
#define IDS_RESTORE_HELP                61728




#define IDS_PROJNAME                    100
#define IDD_CHAT_PRINT                  101
#define IDD_PROPPAGE_AGENDAITEM         102
#define IDD_CHAT_ABOUT                  103
#define CHAT_ICON                       105
#define IDD_CHAT_OPTIONS                108
#define IDB_LGCHAT_TB_DISABLED_ICON     112
#define IDC_SPLITV                      113
#define IDR_MENU_CHAT_WITHFILE          115
#define IDS_UNKNOWN_PERSON              203
#define IDS_FILTER_ALL                  205
#define IDB_CHAT_SMALL_ICON_IMAGES      207
#define IDS_CHAT_NOT_IN_CALL_WINDOW_CAPTION 213
#define IDS_CHAT_IN_CALL_WINDOW_CAPTION 214
#define IDS_CHAT_STATUS_CHAT_ACTIVE     217
#define IDS_CHAT_STATUS_CHAT_NOT_ACTIVE 218
#define IDI_SENDBUTTON                  219
#define IDS_CHAT_SENDTO                 220
#define IDS_PRIVATE                     221
#define IDS_TO                          222
#define IDC_EDIT_AGDOCLINKITEM_URL      223
#define IDC_EDIT_AGDOCLINKITEM_NAME     224
#define IDC_EDIT_AGTITLEDLG_NAME        225
#define IDC_EDIT_AGDECISION_DESC        226
#define IDC_LIST_DECISION_CHOICES       227
#define IDC_EDIT_AGDECISION_NEW_CHOICE  228
#define IDC_BUTTON_AGDECISION_ADD_CHOICE 229
#define IDC_CHECK_AGDECISION_MULTIPLE_CHOICE 230
#define IDD_CHAT_FORMAT                 234
#define FORMATWRAPNEW_ICON              235
#define FORMATWRAP_ICON                 236
#define FORMATSINGLE_ICON               237
#define IDS_CHAT_MESSAGE                240
#define IDS_CHAT_SAVE_FILTER_STRING     241
#define IDR_ACCELERATOR					265
#define IDB_SENDCHAT					270

#define IDS_TOOLTIP_SEND_MESSAGE        283
#define IDS_HELPTEXT_INSERT_NEWSCRIPTABLEACTION 284
#define IDS_HELPTEXT_INSERT_NEWANNOUNCEMENT 285
#define IDS_HELPTEXT_INSERT_NEWDECISION 286
#define IDS_HELPTEXT_INSERT_NEWDISCUSSIONTOPIC 287
#define IDS_HELPTEXT_INSERT_NEWPRESENTATION 288
#define IDS_HELPTEXT_INSERT_NEWACTION   289
#define IDS_HELPTEXT_INSERT_NEWDOCUMENTLINK 290
#define IDS_HELPTEXT_INSERT_NEWMINUTES  291
#define IDS_HELPTEXT_HELP_HELPTOPICS    293
#define IDS_HELPTEXT_EDIT_CUT           294
#define IDS_HELPTEXT_EDIT_COPY          295
#define IDS_HELPTEXT_EDIT_PASTE         296
#define IDS_HELPTEXT_OPTIONS_FONT       297
#define IDS_HELPTEXT_OPTIONS_CHATFORMAT 298
#define IDS_HELPTEXT_HELP_ABOUTCHAT     299
#define IDS_HELPTEXT_EDIT_CLEARALL      300
#define IDS_MINUTES_VIEW_TITLE_CAPTION  301
#define IDS_DECISION_VIEW_ISRESOLVED_CAPTION 302
#define IDS_ACTION_VIEW_ASSIGNEDTO_CAPTION 303
#define IDS_DOCLINK_VIEW_FILENAME_CAPTION 304
#define IDS_DOCLINK_VIEW_BROWSE_BTN_CAPTION 305
#define IDS_SCRPT_ACTION_DOIT_BTN_DEFAULT_CAPTION 306
#define IDS_SCRPT_ACTION_CALLTO_CAPTION 307
#define IDS_SCRPT_ACTION_SEND_FILE_SEND_TO_CAPTION 308
#define IDS_DOCLINK_FILE_BROWSE_DLG_CAPTION 309
#define IDS_DOCLINK_DEFAULT_FILENAME_CAPTION 310
#define IDS_DEFAULT_ACTION_ITEM_NAME    311
#define IDS_DEFAULT_ACTION_ITEM_ASSIGNEE 312
#define IDS_WB_FILE_OPEN_FILTER_STRING  313
#define IDS_WB_FILE_BROWSE_DLG_CAPTION  314
#define ID_SEND_MESSAGE                 321
#define ID_FILE_SAVE                    322
#define ID_FILE_SAVEAS                  323
#define ID_FILE_PRINT                   324
#define ID_VIEW_TOOLBAR                 325
#define ID_VIEW_STATUSBAR               326
#define IDS_VIEW_TOOLBAR_HELP           327
#define IDS_VIEW_STATUSBAR_HELP         328
#define IDS_HELPTEXT_CHAT_FILE_SEND_MESSAGE     329
#define IDS_HELPTEXT_CHAT_FILE_SAVE     330
#define IDS_HELPTEXT_CHAT_FILE_SAVEAS   331
#define IDS_HELPTEXT_CHAT_FILE_PRINT    332
#define IDS_HELPTEXT_CHAT_FILE_EXIT     333
#define ID_FILE_EXIT                    334
#define IDS_HELPTEXT_CHAT_FILE          335
#define IDS_HELPTEXT_CHAT_VIEW          336
#define IDS_HELPTEXT_CHAT_OPTIONS       337
#define IDS_HELPTEXT_CHAT_HELP          338
#define IDS_HELPTEXT_CHAT_EDIT          339
#define ID_VIEW_EDITWINDOW              340
#define IDS_HELPTEXT_CHAT_VIEW_EDITWINDOW 341
#define IDS_CHAT_DOCUMENTNAME           342
#define IDS_CHAT_HEADER                 343
#define IDS_CHAT_SAVE_PRIVATE_TO        344
#define IDS_CHAT_SAVE_PRIVATE           345
#define IDS_CHAT_CREATE_DIRECTORY       346
#define IDS_CHAT_COULD_NOT_CREATE_DIR   347
#define IDS_CHAT_SAVE_ACCESS_DENIED     348
#define IDS_CHAT_SAVE_FAILED            349
#define IDS_CHAT_CONF_OVER_SAVE         350
#define IDS_CHAT_MB_TITLE               351
#define IDS_CHAT_SAVE_DEF_EXT           352
#define IDS_CHAT_ICON_LABEL             353
#define IDS_CHAT_OPTIONS_FONT_FORMAT    354
#define IDS_HELPTEXT_CHAT_VIEW_OPTIONS  355
#define IDS_CHAT_CONF_ENDED             356
#define IDS_NETMEETING_CHAT             357
#define IDS_SAVE_CHANGES_TO_CHAT_BEFORE_EXITING 358
#define IDC_HEADER_GROUP                401
#define IDC_INCLUDE_NAME                402
#define IDC_INCLUDE_DATE                403
#define IDC_INCLUDE_TIME                404
#define IDR_MESSAGE_GROUP               405
#define IDR_SINGLE_LINE                 406
#define IDR_SAME_LINE                   407
#define IDR_NEW_LINE                    408
#define IDC_FONTS_GROUP                 409
#define IDC_CHAT_PRINT_STATIC           1001
#define IDC_CHAT_ABOUT_VERSION          1002
#define IDC_FORMATSINGLE                1003
#define IDC_CHAT_ABOUT_PRODUCT_NAME     1003
#define IDC_FORMATWRAP                  1004
#define IDC_CHAT_ABOUT_COPYRIGHT        1004
#define IDC_FORMATWRAPNEW               1005
#define IDC_FONT_MSGOUT                 1016
#define IDC_FONT_MSGIN                  1017
#define IDC_FONT_PRIVATEOUT             1018
#define IDC_FONT_PRIVATEIN              1019
#define IDC_EDIT_MSGIN                  1021
#define IDC_EDIT_PRIVATEIN              1022
#define IDC_EDIT_MSGOUT                 1023
#define IDC_EDIT_PRIVATEOUT             1024
#define IDM_PROPERTIES                  32768
#define IDM_INSERT                      32769
#define ID_EDIT_CUT                     32770
#define ID_EDIT_COPY                    32771
#define ID_EDIT_PASTE                   32772
#define ID_EDIT_CLEARALL                32773
#define ID_OPTIONS_FONT                 32774
#define ID_OPTIONS_CHATFORMAT           32775
#define ID_HELP_ABOUTCHAT               32776
#define ID_HELP_HELPTOPICS              32777
#define ID_INSERT_NEWANNOUNCEMENT       32778
#define ID_INSERT_NEWDECISION           32779
#define ID_INSERT_NEWDISCUSSIONTOPIC    32780
#define ID_INSERT_NEWPRESENTATION       32781
#define ID_INSERT_NEWACTION             32782
#define ID_INSERT_NEWDOCUMENTLINK       32783
#define ID_INSERT_NEWMINUTES            32784
#define ID_INSERT_NEWSCRIPTABLEACTION   32785

#define ID_NAV_SHIFT_TAB               0x3627
#define ID_NAV_TAB                     0x3628

#define ID_VIEW_OPTIONS                 40004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        113
#define _APS_NEXT_COMMAND_VALUE         40005
#define _APS_NEXT_CONTROL_VALUE         1025
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\splitbar2.h ===
// File: splitbar.h

#ifndef __SplitBar2_h__
#define __SplitBar2_h__


class CSplitBar2 
: public CWindowImpl<CSplitBar2>
{

public: // Datatypes
    typedef void (WINAPI * PFN_ADJUST)(int dxp, LPARAM lParam);

private:
	HWND  m_hwndBuddy;      // Buddy window
	HWND  m_hwndParent;     // Parent window
	BOOL  m_fCaptured;      // TRUE if captured
	HDC   m_hdcDrag;        // The captured desktop hdc

    static int ms_dxpSplitBar; // width of a splitbar window
	int   m_dxSplitter;     // Width of the splitter bar
	int   m_dxDragOffset;   // Offset of mouse click within splitter (0 - m_dxSplitter)
	int   m_xCurr;          // Current x position of bar (m_hwndParent co-ordinates)
	int   m_dxMin;
	int   m_dxMax;


        // callback data and fn ptrs
    PFN_ADJUST  m_pfnAdjust;
    LPARAM      m_Context;
	

BEGIN_MSG_MAP(CSplitBar2)
    MESSAGE_HANDLER( WM_LBUTTONDOWN, OnLButtonDown )
END_MSG_MAP()

    // Message map handlers
    LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    CSplitBar2(void);
	~CSplitBar2();
    
    HRESULT Create(HWND hwndBuddy, PFN_ADJUST pfnAdjust, LPARAM Context);


    int GetWidth(void) const { return ms_dxpSplitBar; }


    static CWndClassInfo& GetWndClassInfo();

private:
	void _DrawBar(void);
	int  _ConstrainDragPoint(short x);
	void CancelDragLoop(void);
	BOOL FInitDragLoop(POINT pt);
	void OnDragMove(POINT pt);
	void OnDragEnd(POINT pt);

private:
// Helper Fns
	void _TrackDrag(POINT pt);
    static void _UpdateSplitBar(void);
};

#endif // __SplitBar2_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\agrp.hpp ===
//
// AGRP.HPP
// WbAttributesGroup
//
// Copyright Microsoft 1998-
//

#ifndef __AGRP_HPP_
#define __AGRP_HPP_


#define FONTBUTTONWIDTH        100
#define FONTBUTTONHEIGHT        23


#define PAGEBTN_WIDTH	23
#define PAGEBTN_HEIGHT	23
#define MAX_NUMCHARS	3


//
// Local defines
//
#define BORDER_SIZE_X        ::GetSystemMetrics(SM_CXEDGE)
#define BORDER_SIZE_Y        ::GetSystemMetrics(SM_CYEDGE)
#define SEPARATOR_SIZE_X     6
#define SEPARATOR_SIZE_Y     6

#define DEFAULT_PGC_WIDTH   (8*24)

enum
{
    PGC_FIRST = 0,
    PGC_PREV,
    PGC_ANY,
    PGC_NEXT,
    PGC_LAST,
    PGC_INSERT,
    NUM_PAGE_CONTROLS
};


//
// Indexedby PGC_ value
//
typedef struct tagPAGECTRL
{
    HBITMAP     hbmp;
    HWND        hwnd;
}
PAGECTRL;


//
// The buttons are all BS_BITMAP
// The edit field is ES_CENTER | ES_MULTILINE | ES_NUMBER | WS_BORDER
//



class WbTool;

//
//
// Class:   WbAttributesGroup
//
// Purpose: Define Whiteboard tool attributes display group
//
//
class WbAttributesGroup
{
public:
    WbAttributesGroup();
    ~WbAttributesGroup();

    //
    // Window creation
    //
    BOOL Create(HWND hwndParent, LPCRECT lprc);

    //
    // Display the attributes of the tool passed as parameter
    //
    void DisplayTool(WbTool* pTool);

    //
    // Hide the tool attributes bar.
    //
    void Hide(void);

    //
    // Resizing functions
    //
    void GetNaturalSize(LPSIZE lpsize);


    //
    // Colors
    //
    void SelectColor(WbTool* pTool);
	
    void SetChoiceColor(COLORREF clr)
		{m_colorsGroup.SetCurColor(clr);}

	LRESULT OnEditColors( void )
		{return m_colorsGroup.OnEditColors();}

    void SaveSettings( void )
        {m_colorsGroup.SaveSettings();}

    //
    // Page Controls
    //
    BOOL IsChildEditField(HWND hwnd);

    UINT GetCurrentPageNumber(void);
    void SetCurrentPageNumber(UINT number);
    void SetLastPageNumber(UINT number);

    void EnablePageCtrls(BOOL bEnable);
    void EnableInsert(BOOL bEnable);

    BOOL RecolorButtonImages();

    HWND    m_hwnd;

    friend LRESULT CALLBACK AGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void OnSize(UINT nType, int cx, int cy);
    void OnCommand(UINT id, UINT code, HWND hwndCtl);

    //
    // Color palette
    //
	WbColorsGroup     m_colorsGroup;

    //
    // Font Button
    //
    HWND        m_hwndFontButton;

    //
    // Page controls
    //
    PAGECTRL    m_uPageCtrls[NUM_PAGE_CONTROLS];
    HFONT       m_hPageCtrlFont;
    int         m_cxPageCtrls;

    void        SetPageButtonNo(UINT pgcCtrl, UINT uiPageNumber);
};


#endif // __AGRP_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\agrp.cpp ===
//
// AGRP.CPP
// Tool Attributes Display Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


// Class name
static const TCHAR szAGClassName[] = "T126WB_AGRP";

void ShiftFocus(HWND hwndTop, BOOL bForward);


//
// Page Control child IDs
// Index is PGC_ value
//
static UINT_PTR g_uPageIds[NUM_PAGE_CONTROLS] =
{
    IDM_PAGE_FIRST,
    IDM_PAGE_PREV,
    IDM_PAGE_ANY,
    IDM_PAGE_NEXT,
    IDM_PAGE_LAST,
    IDM_PAGE_INSERT_AFTER
};



//
// WbAttributesGroup()
//
WbAttributesGroup::WbAttributesGroup(void)
{
    int             i;

    m_hwnd = NULL;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        m_uPageCtrls[i].hbmp = NULL;
        m_uPageCtrls[i].hwnd = NULL;
    }

    m_hPageCtrlFont = NULL;
    m_cxPageCtrls = DEFAULT_PGC_WIDTH;

    m_hwndFontButton = NULL;
}


//
// ~WbAttibutesGroup()
//
WbAttributesGroup::~WbAttributesGroup(void)
{
    int i;

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szAGClassName, g_hInstance);

    //
    // Delete control bitmaps
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        if (m_uPageCtrls[i].hbmp)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
            m_uPageCtrls[i].hbmp = NULL;
        }
    }

    if (m_hPageCtrlFont != NULL)
    {
        ::DeleteFont(m_hPageCtrlFont);
        m_hPageCtrlFont = NULL;
    }

}



//
// Create()
//
BOOL WbAttributesGroup::Create
(
    HWND    hwndParent,
    LPCRECT lpRect
)
{
    SIZE    size;
    RECT    rectCG;
    RECT    rectFSG;
    TCHAR   szFOBStr[256];
    HFONT   hOldFont;
    HDC     hdc;
    int     i;
    BITMAP  bmpInfo;
    int     x, cx;
    int     yLogPix;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = 0;
    wc.lpfnWndProc      = AGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszClassName    = szAGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbAttributesGroup::Create register class failed"));
        return(FALSE);
    }

    // Create the window
    if (!::CreateWindowEx(0, szAGClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN ,
        lpRect->left, lpRect->top,
        lpRect->right - lpRect->left, lpRect->bottom - lpRect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Couldn't create WbAttributesGroup window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Create the page control button bitmaps
    //
    if (!RecolorButtonImages())
    {
        ERROR_OUT(("Error getting page button bitmaps"));
        return(FALSE);
    }

    hdc = ::CreateCompatibleDC(NULL);
    yLogPix = ::GetDeviceCaps(hdc, LOGPIXELSY);
    ::DeleteDC(hdc);

    //
    // Create the font for the edit field and buttons
    //
    ::GetObject(m_uPageCtrls[PGC_LAST].hbmp, sizeof(BITMAP), &bmpInfo);
    m_hPageCtrlFont = ::CreateFont(-bmpInfo.bmHeight,
                                0, 0, 0,
                                FW_NORMAL, 0, 0, 0,
                                DEFAULT_CHARSET,
                                OUT_TT_PRECIS,
                                CLIP_DFA_OVERRIDE,
                                DEFAULT_QUALITY,
                                VARIABLE_PITCH | FF_SWISS,
                                "Arial" );
    if (!m_hPageCtrlFont)
    {
        ERROR_OUT(("WbPagesGroup::Create - couldn't create font"));
        return(FALSE);
    }

    //
    // Create the child controls in order, left to right
    //
    x = lpRect->right;

    for (i = 0; i <NUM_PAGE_CONTROLS; i++)
    {
        x -= BORDER_SIZE_X;

        switch (i)
        {
            case PGC_ANY:
                cx = (3*PAGEBTN_WIDTH)/2;
                break;

            case PGC_FIRST:
            case PGC_LAST:
                // make button fit bitmap width + standard border
                ::GetObject(m_uPageCtrls[i].hbmp, sizeof(BITMAP), &bmpInfo);
                cx = bmpInfo.bmWidth + 2*::GetSystemMetrics(SM_CXFIXEDFRAME); // standard button border
                break;

            default:
                cx = PAGEBTN_WIDTH;
                break;

        }

        x -= cx;

        if (i == PGC_ANY)
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(WS_EX_CLIENTEDGE,
                _T("EDIT"), NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE |
                ES_NUMBER | ES_CENTER | ES_MULTILINE| WS_TABSTOP,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP edit field"));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, EM_LIMITTEXT, MAX_NUMCHARS, 0);
            ::SendMessage(m_uPageCtrls[i].hwnd, WM_SETFONT, (WPARAM)m_hPageCtrlFont, 0);
        }
        else
        {
            m_uPageCtrls[i].hwnd = ::CreateWindowEx(0, _T("BUTTON"),
                NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | BS_BITMAP| WS_TABSTOP,
                x, 2*BORDER_SIZE_Y, cx, PAGEBTN_HEIGHT,
                m_hwnd, (HMENU)g_uPageIds[i], g_hInstance, NULL);

            if (!m_uPageCtrls[i].hwnd)
            {
                ERROR_OUT(("Couldn't create PGRP button ID %x", g_uPageIds[i]));
                return(FALSE);
            }

            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)m_uPageCtrls[i].hbmp);
        }
    }

    m_cxPageCtrls = lpRect->right - x;

    SetPageButtonNo(PGC_FIRST, 1);
    SetPageButtonNo(PGC_LAST, 1);

    //
    // Create the color palette
    //

    m_colorsGroup.GetNaturalSize(&size);
    rectCG.left = BORDER_SIZE_X;
    rectCG.right = rectCG.left + size.cx;
    rectCG.top = BORDER_SIZE_Y;
    rectCG.bottom = rectCG.top + size.cy;

    if (!m_colorsGroup.Create(m_hwnd, &rectCG))
    {
        ERROR_OUT(("Couldn't create CGRP window"));
        return(FALSE);
    }

    //
    // Create the font button.
    // Now calculate the real size of the button
    //

    hdc = ::GetDC(m_hwnd);
    if (!hdc)
        return(FALSE);

    hOldFont = SelectFont(hdc, (HFONT)::GetStockObject(DEFAULT_GUI_FONT));

    ::LoadString(g_hInstance, IDS_FONTOPTIONS, szFOBStr, 256);
    ::GetTextExtentPoint(hdc, szFOBStr, lstrlen(szFOBStr), &size);

    SelectFont(hdc, hOldFont);
    ::ReleaseDC(m_hwnd, hdc);

    size.cx += 4 * BORDER_SIZE_X;
    size.cy += 4 * BORDER_SIZE_Y;

    m_hwndFontButton = ::CreateWindowEx(0, _T("BUTTON"), szFOBStr,
        WS_CHILD | WS_CLIPSIBLINGS | BS_PUSHBUTTON| WS_TABSTOP,
        rectCG.right + SEPARATOR_SIZE_X, 2*BORDER_SIZE_Y,
        max(size.cx, FONTBUTTONWIDTH), max(size.cy, FONTBUTTONHEIGHT),
        m_hwnd, (HMENU)IDM_FONT, g_hInstance, NULL);

    if (!m_hwndFontButton)
    {
        ERROR_OUT(("Couldn't create FONT button"));
        return(FALSE);
    }

    ::SendMessage(m_hwndFontButton, WM_SETFONT, (WPARAM)::GetStockObject(DEFAULT_GUI_FONT),
        FALSE);

    return(TRUE);
}



//
// RecolorButtonImages()
//
BOOL WbAttributesGroup::RecolorButtonImages(void)
{
    int         i;
    HBITMAP     hbmpNew;

    //
    // This creates button bitmaps tied to the 3D colors, and clears the old
    // ones/sets the new ones if the buttons are around.
    //

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // No bitmaps for the edit field
        if (i == PGC_ANY)
            continue;

        hbmpNew = (HBITMAP)::LoadImage(g_hInstance, MAKEINTRESOURCE(g_uPageIds[i]),
            IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS | LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
        if (!hbmpNew)
        {
            ERROR_OUT(("AG::RecolorButtonImages faile to load bitmap ID %d",
                g_uPageIds[i]));
            return(FALSE);
        }

        // Set the new one
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            ::SendMessage(m_uPageCtrls[i].hwnd, BM_SETIMAGE, IMAGE_BITMAP,
                (LPARAM)hbmpNew);
        }

        // Delete the old one
        if (m_uPageCtrls[i].hbmp != NULL)
        {
            ::DeleteBitmap(m_uPageCtrls[i].hbmp);
        }

        // Save this one
        m_uPageCtrls[i].hbmp = hbmpNew;

        // Put the page number on top
        if (m_uPageCtrls[i].hwnd != NULL)
        {
            if (i == PGC_FIRST)
            {
                SetPageButtonNo(i, 1);
            }
            else if (i == PGC_LAST)
            {
                SetPageButtonNo(i, 1);
            }
        }
    }

    return(TRUE);
}




//
//
// Function:    GetNaturalSize
//
// Purpose:     Return the natural size of the attributes group
//
//
void WbAttributesGroup::GetNaturalSize(LPSIZE lpsize)
{
    SIZE    sizeCG;
    SIZE    sizeFSG;
    RECT    rc;

    m_colorsGroup.GetNaturalSize(&sizeCG);

    if (!m_hwndFontButton)
    {
        sizeFSG.cx = FONTBUTTONWIDTH;
        sizeFSG.cy = FONTBUTTONHEIGHT;
    }
    else
    {
        ::GetWindowRect(m_hwndFontButton, &rc);
        sizeFSG.cx = rc.right - rc.left;
        sizeFSG.cy = rc.bottom - rc.top;
    }

    // m_cxPageCtrls includes BORDER_SIZE_X on right side
    lpsize->cx = BORDER_SIZE_X
               + sizeCG.cx
               + SEPARATOR_SIZE_X
               + sizeFSG.cx
               + SEPARATOR_SIZE_X
               + m_cxPageCtrls;

    sizeFSG.cy = max(sizeFSG.cy, PAGEBTN_HEIGHT) + BORDER_SIZE_Y;
    lpsize->cy = BORDER_SIZE_Y
                + max(sizeCG.cy, sizeFSG.cy)
                + BORDER_SIZE_Y;
}


//
// IsChildEditField()
//
BOOL WbAttributesGroup::IsChildEditField(HWND hwnd)
{
    return(hwnd == m_uPageCtrls[PGC_ANY].hwnd);
}


//
// GetCurrentPageNumber()
//
UINT WbAttributesGroup::GetCurrentPageNumber(void)
{
    return(::GetDlgItemInt(m_hwnd, IDM_PAGE_ANY, NULL, FALSE));
}


//
// SetCurrentPageNumber()
//
void WbAttributesGroup::SetCurrentPageNumber(UINT number)
{
    ::SetDlgItemInt(m_hwnd, IDM_PAGE_ANY, number, FALSE);
}


//
// SetLastPageNumber()
//
void WbAttributesGroup::SetLastPageNumber(UINT number)
{
    SetPageButtonNo(PGC_LAST, number);
}


//
// EnablePageCtrls()
//
void WbAttributesGroup::EnablePageCtrls(BOOL bEnable)
{
    int i;

    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        ::EnableWindow(m_uPageCtrls[i].hwnd, bEnable);
    }

	//
	// Insert is enabled if we are synced and didn't reach the limit
	//
   ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, g_pDraw->IsSynced() &&  (g_numberOfWorkspaces < 256) ? bEnable : FALSE);


}


//
// EnableInsert()
//
void WbAttributesGroup::EnableInsert(BOOL bEnable)
{
    ::EnableWindow(m_uPageCtrls[PGC_INSERT].hwnd, bEnable);
}


//
// AGWndProc()
//
LRESULT CALLBACK AGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbAttributesGroup * pag = (WbAttributesGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pag = (WbAttributesGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pag);

            pag->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pag);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pag);
            pag->m_hwnd = NULL;
            break;

        case WM_SIZE:
            ASSERT(pag);
            pag->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_COMMAND:
            ASSERT(pag);
            pag->OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                    GET_WM_COMMAND_CMD(wParam, lParam),
                    GET_WM_COMMAND_HWND(wParam, lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    OnSize
//
// Purpose:     The tool window has been resized
//
//
void WbAttributesGroup::OnSize(UINT, int, int)
{
    RECT    rc;
    int     i;
    int     x;
    RECT    rcT;

    //
    // We haven't created our children yet.
    //
    if (!m_uPageCtrls[0].hwnd)
        return;

    ::GetClientRect(m_hwnd, &rc);
    x = rc.right - m_cxPageCtrls;

    //
    // Move the page controls to be right justified.
    //
    for (i = 0; i < NUM_PAGE_CONTROLS; i++)
    {
        // Get width of control
        ::GetWindowRect(m_uPageCtrls[i].hwnd, &rcT);
        rcT.right -= rcT.left;

        ::MoveWindow(m_uPageCtrls[i].hwnd, x, 2*BORDER_SIZE_Y,
            rcT.right, PAGEBTN_HEIGHT, TRUE);

        //
        // Move to the next one
        //
        x += rcT.right + BORDER_SIZE_X;
    }

    //
    // The color palette and font button are left justified, no need to
    // move them.
    //
}



//
// SetPageButtonNo()
//
// Updates the page text in the first/last button
//
void WbAttributesGroup::SetPageButtonNo(UINT pgcIndex, UINT uiPageNumber )
{
    HDC     hdc;
    BITMAP  bmpInfo;
    HBITMAP hbmp;
    HFONT   hOldFont;
    HBITMAP hOldBitmap;
    RECT    rectNumBox;
    TCHAR   NumStr[16];
    TEXTMETRIC tm;
    HWND    hwndButton;

    MLZ_EntryOut(ZONE_FUNCTION, "WbAttributesGroup::SetPageButtonNo");

    hwndButton = m_uPageCtrls[pgcIndex].hwnd;
    hbmp = m_uPageCtrls[pgcIndex].hbmp;

    ASSERT(hwndButton);
    ASSERT(hbmp);
    ASSERT(m_hPageCtrlFont);

    ::GetObject(hbmp, sizeof (BITMAP), (LPVOID)&bmpInfo);

    hdc = ::CreateCompatibleDC(NULL);
    hOldFont = SelectFont(hdc, m_hPageCtrlFont);
    hOldBitmap = SelectBitmap(hdc, hbmp);
    ::GetTextMetrics(hdc, &tm);

    rectNumBox.left = 10;
    rectNumBox.top = -(tm.tmInternalLeading/2);
    rectNumBox.right = bmpInfo.bmWidth;
    rectNumBox.bottom = bmpInfo.bmHeight;

    SelectBrush(hdc, ::GetSysColorBrush( COLOR_3DFACE ) );
    ::SetTextColor(hdc, ::GetSysColor( COLOR_BTNTEXT ) );
    ::SetBkColor(hdc, ::GetSysColor( COLOR_3DFACE ) );

    ::PatBlt(hdc, rectNumBox.left, rectNumBox.top,
        rectNumBox.right - rectNumBox.left, rectNumBox.bottom - rectNumBox.top,
        PATCOPY);

    wsprintf(NumStr, "%d", uiPageNumber);
    ::DrawText(hdc, NumStr, -1, &rectNumBox, DT_CENTER);

    SelectFont(hdc, hOldFont);
    SelectBitmap(hdc, hOldBitmap);

    ::DeleteDC(hdc);

    ::InvalidateRect(hwndButton, NULL, TRUE);
    ::UpdateWindow(hwndButton);
}



//
//
// Function:    DisplayTool
//
// Purpose:     Display a tool in the attributes group
//
//
void WbAttributesGroup::DisplayTool(WbTool* pTool)
{
    SIZE    size;

    // Display the colors group if necessary
    if (!pTool->HasColor())
    {
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);
    }
    else
    {
        // Change the color button to match the tool
        m_colorsGroup.SetCurColor(pTool->GetColor());

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(m_colorsGroup.m_hwnd))
        {
            ::ShowWindow(m_colorsGroup.m_hwnd, SW_SHOW);
        }
    }

    // Display the widths group if necessary
    if( (!pTool->HasWidth()) || (!g_pMain->IsToolBarOn()) )
    {
        ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_HIDE);
    }
    else
    {
        UINT uiWidthIndex = pTool->GetWidthIndex();

        // If the width index isn't valid, then pop up all the buttons
        if (uiWidthIndex < NUM_OF_WIDTHS)
        {
            // Tell the widths group of the new selection
            g_pMain->m_WG.PushDown(uiWidthIndex);
        }

        // If the group is currently hidden, show it
        if (!::IsWindowVisible(g_pMain->m_WG.m_hwnd))
        {
            ::ShowWindow(g_pMain->m_WG.m_hwnd, SW_SHOW);
        }
    }

    // The font sample group is visible for text and select tools
    if (!pTool->HasFont())
    {
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
    }
    else
    {
        if (!::IsWindowVisible(m_hwndFontButton))
        {
            ::ShowWindow(m_hwndFontButton, SW_SHOW);
        }
    }
}


//
//
// Function:    Hide.
//
// Purpose:     Hide the tool attributes bar.
//
//
void WbAttributesGroup::Hide(void)
{
    if (m_colorsGroup.m_hwnd != NULL)
        ::ShowWindow(m_colorsGroup.m_hwnd, SW_HIDE);

    if (m_hwndFontButton != NULL)
        ::ShowWindow(m_hwndFontButton, SW_HIDE);
}

//
//
// Function:    SelectColor
//
// Purpose:     Set the current color
//
//
void WbAttributesGroup::SelectColor(WbTool* pTool)
{
    if (pTool != NULL)
    {
        pTool->SetColor(m_colorsGroup.GetCurColor());
    }
}




//
// This forwards all button commands to our main window
//
void WbAttributesGroup::OnCommand(UINT id, UINT cmd, HWND hwndCtl)
{
	SHORT key1;
	SHORT key2;
    switch (id)
    {
        case IDM_PAGE_FIRST:
        case IDM_PAGE_PREV:
        case IDM_PAGE_NEXT:
        case IDM_PAGE_LAST:
        case IDM_PAGE_INSERT_AFTER:
        case IDM_FONT:
            if (cmd == BN_CLICKED)
            {
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
            }
            break;

        case IDM_PAGE_ANY:
            if (cmd == EN_SETFOCUS)
            {
                ::SendMessage(hwndCtl, EM_SETSEL, 0, (LPARAM)-1);
                ::SendMessage(hwndCtl, EM_SCROLLCARET, 0, 0);
            }
			else if(cmd == EN_MAXTEXT)
			{
                ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(id, cmd, hwndCtl));
			}
			else if (cmd != EN_KILLFOCUS)
			{
				key1 = GetAsyncKeyState(VK_TAB);
				key2 = GetAsyncKeyState(VK_SHIFT);

				if(key1)
				{
					if(key2)
					{
						::SetFocus(m_uPageCtrls[PGC_PREV].hwnd);
					}
					else
					{
						::SetFocus(m_uPageCtrls[PGC_NEXT].hwnd);
					}
				}
			}
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\bmpobj.hpp ===
//
// BITMAPOBJ.HPP
// Bitmap objects:
//
// Copyright Microsoft 1998-
//
#ifndef __BITMAPOBJ_HPP_
#define __BITMAPOBJ_HPP_

typedef struct COLOREDICON
{
	HICON    hIcon;
 	COLORREF color;
} COLORED_ICON;


#define MAX_BITMAP_DATA 8192

UINT GetBitmapDestinationAddress(BitmapDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID);

#define NonStandard24BitBitmapID "Bitmap24\0"

typedef struct tagBITMAP_DATA
{
	//
	// Data Buffer
	//
    BOOL m_bdataCheckpoint;
    UINT m_padBits;
	UINT m_length;
} BITMAPDATA, *PBITMAPDATA;


class BitmapObj : public T126Obj
{

public:

	BitmapObj (BitmapCreatePDU * pbitmapCreatePDU);
	void Continue (BitmapCreateContinuePDU * pbitmapCreateContinuePDU);
	BitmapObj (UINT);
	~BitmapObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	BOOL CheckReallyHit(LPCRECT pRectHit){return RectangleHit(FALSE, pRectHit);}
	void FromScreenArea(LPCRECT lprcScreen);

	BOOL HasFillColor(void){return FALSE;}
	void SetFillColor(COLORREF cr, BOOL isPresent){}
    BOOL GetFillColor(COLORREF * pcr){return FALSE;}
    BOOL GetFillColor(RGBTRIPLE* prgb){return FALSE;}

	void SetPenColor(COLORREF cr, BOOL isPresent){}
    BOOL GetPenColor(COLORREF * pcr) {return FALSE;}
    BOOL GetPenColor(RGBTRIPLE* prgb){return FALSE;}

    void SetViewHandle(UINT viewHandle){};


	void DeleteSavedBitmap(void);
	void BitmapEditObj ( BitmapEditPDU * pbitmapEditPDU );
	void GetBitmapAttrib(PBitmapCreatePDU_attributes pAttribPDU);
	void SetBitmapAttrib(PBitmapCreatePDU_attributes *pattributes);
	void AllocateAttrib(PBitmapCreatePDU_attributes *pAttributes);

	//
	// PDU stuff
	//
	void CreateBitmapCreatePDU(CWBOBLIST * pCreatePDUList);
	void CreateBitmapEditPDU(BitmapEditPDU *pEditPDU);
	void CreateBitmapDeletePDU(BitmapDeletePDU *pDeletePDU);
	void CreateNonStandard24BitBitmap(BitmapCreatePDU * pBitmapCreatePDU);


	LPBITMAPINFOHEADER  m_lpbiImage;		// local copy of the DIB
	LPBITMAPINFOHEADER	m_lpBitMask;		// Bitmask for transparent bitmaps.
	LPBYTE				m_lpTransparencyMask;
	UINT				m_SizeOfTransparencyMask;
	
	BOOL				m_fMoreToFollow;

	//
	// Masks 0x000000007 (BitmapAttribute_viewState_chosen = 1... BitmapAttribute_transparencyMask_chosen = 3)
	//
	void ChangedViewState(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_viewState_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};
	void ChangedZOrder(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_zOrder_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};
	void ChangedTransparencyMask(void){m_dwChangedAttrib |= (1 << (BitmapAttribute_transparencyMask_chosen-1)) |
								BitmapEditPDU_attributeEdits_present;};

	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_viewState_chosen-1)));};
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_zOrder_chosen-1)));};
	BOOL HasTransparencyMaskChanged(void){return (m_dwChangedAttrib & ( 1 << (BitmapAttribute_transparencyMask_chosen-1)));};

	//
	// Masks 0x000000070 (BitmapEditPDU_scalingEdit_present = 0x10... BitmapEditPDU_anchorPointEdit_present = 0x40)
	//
	void ChangedAnchorPoint(void){ m_dwChangedAttrib |= BitmapEditPDU_anchorPointEdit_present;}
	void ChangedRegionOfInterest(void){ m_dwChangedAttrib |= bitmapRegionOfInterestEdit_present;}
	void ChangedScaling(void){ m_dwChangedAttrib |= BitmapEditPDU_scalingEdit_present;}

	BOOL HasAnchorPointChanged(void){ return (m_dwChangedAttrib & BitmapEditPDU_anchorPointEdit_present);}
	BOOL HasRegionOfInterestChanged(void){ return (m_dwChangedAttrib & bitmapRegionOfInterestEdit_present);}
	BOOL HasScalingChanged(void){ return (m_dwChangedAttrib & BitmapEditPDU_scalingEdit_present);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x07;}
	DWORD GetPresentAttribs(void){return ((m_dwChangedAttrib & 0x0F0));}

	void ChangedPenThickness(void){};

	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void	GetEncodedCreatePDU(ASN1_BUF *pBuf);


	//Remote pointer stuff
    //
    // Device context used for drawing and undrawing the pointer
    //
    HDC         m_hMemDC;

    //
    // Pointer to the bitmap used to save the data under the pointer
    //
    HBITMAP     m_hSaveBitmap;

    //
    // Handle of bitmap originally supplied with memDC
    //
    HBITMAP     m_hOldBitmap;

    //
    // Handle of icon to be used for drawing
    //
    HICON       m_hIcon;

	HICON	CreateColoredIcon(COLORREF color, LPBITMAPINFOHEADER lpbInfo = NULL, LPBYTE pMaskBits = NULL);
	void	CreateSaveBitmap();
	void	UnDraw(void);
	BOOL	UndrawScreen();
	void	SetBitmapSize(LONG x, LONG y){m_bitmapSize.x = x; m_bitmapSize.y = y;}

protected:

	DWORD			m_dwChangedAttrib;
	POINT			m_bitmapSize;			// Width, Height
	RECT			m_bitmapRegionOfInterest;
	UINT			m_pixelAspectRatio;
	POINT			m_scaling;
	UINT			m_checkPoints;
	BITMAPDATA		m_bitmapData;

};


#endif // __BITMAPOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\bmpobj.cpp ===
//
// BitmapObj.CPP
// Bitmap objects:
//
// Copyright Microsoft 1998-
//
#include "precomp.h"

#include "NMWbObj.h"

BitmapObj::BitmapObj (BitmapCreatePDU * pbitmapCreatePDU)
{
	ResetAttrib();
	SetType(bitmapCreatePDU_chosen);
	SetPenThickness(0);
	SetMyWorkspace(NULL);
	m_lpTransparencyMask = NULL;
	m_lpbiImage = NULL;
	m_lpBitMask = NULL;
	m_hSaveBitmap = NULL;
	m_hOldBitmap = NULL;
	m_hIcon = NULL;
	m_fMoreToFollow = TRUE;

	//
	// Created remotely, not selected, not editing or deleting.
	//
	ClearCreationFlags();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	if(pbitmapCreatePDU->bitmapFormatHeader.choice != bitmapHeaderNonStandard_chosen)
	{
	    ERROR_OUT(("Only Handle uncompresed bitmaps"));
	    return;
	}

    SetThisObjectHandle(pbitmapCreatePDU->bitmapHandle);

	UINT workspaceHandle;
	UINT planeID;
	m_ToolType = GetBitmapDestinationAddress(&pbitmapCreatePDU->destinationAddress, &workspaceHandle, &planeID);
	SetWorkspaceHandle(workspaceHandle);
	SetPlaneID(planeID);

	//
	// Get bitmap attributes
	//
	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_attributes_present)
	{
		GetBitmapAttrib(pbitmapCreatePDU->attributes);
	}

	//
	// Get bitmap anchor point
	//
	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_anchorPoint_present)
	{

		SetAnchorPoint(pbitmapCreatePDU->anchorPoint.xCoordinate, pbitmapCreatePDU->anchorPoint.yCoordinate);
	}

	//
	// Get bitmap size
	//
    m_bitmapSize.x = pbitmapCreatePDU->bitmapSize.width;
    m_bitmapSize.y = pbitmapCreatePDU->bitmapSize.height;

	RECT rect;
	rect.top = pbitmapCreatePDU->anchorPoint.yCoordinate;
	rect.left = pbitmapCreatePDU->anchorPoint.xCoordinate;
	rect.bottom = pbitmapCreatePDU->anchorPoint.yCoordinate + m_bitmapSize.y;
	rect.right = pbitmapCreatePDU->anchorPoint.xCoordinate + m_bitmapSize.x;
	SetRect(&rect);

	//
	// Get bitmap region of interest
	//
	if(pbitmapCreatePDU->bit_mask & bitmapRegionOfInterest_present)
	{
		m_bitmapRegionOfInterest.left = pbitmapCreatePDU->bitmapRegionOfInterest.upperLeft.xCoordinate;
		m_bitmapRegionOfInterest.top = pbitmapCreatePDU->bitmapRegionOfInterest.upperLeft.yCoordinate;
		m_bitmapRegionOfInterest.right = pbitmapCreatePDU->bitmapRegionOfInterest.lowerRight.xCoordinate;
		m_bitmapRegionOfInterest.bottom = pbitmapCreatePDU->bitmapRegionOfInterest.lowerRight.yCoordinate;
	}

    //
    // Get the bitmap pixel aspect ration
    //
    m_pixelAspectRatio = pbitmapCreatePDU->pixelAspectRatio.choice;

	if(pbitmapCreatePDU->bit_mask & BitmapCreatePDU_scaling_present)
	{
		m_scaling.x =  pbitmapCreatePDU->scaling.xCoordinate;
		m_scaling.y =  pbitmapCreatePDU->scaling.yCoordinate;
	}


   	//
   	// Non standard bitmap
   	//
	if((pbitmapCreatePDU->bit_mask & BitmapCreatePDU_nonStandardParameters_present) &&
		pbitmapCreatePDU->nonStandardParameters->value.nonStandardIdentifier.choice == h221nonStandard_chosen)
	{

		m_bitmapData.m_length = pbitmapCreatePDU->nonStandardParameters->value.data.length;
    	m_lpbiImage = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, m_bitmapData.m_length);
    	memcpy(m_lpbiImage, // pColor is now pointing to the begining of the bitmap bits
    			pbitmapCreatePDU->nonStandardParameters->value.data.value,
    			m_bitmapData.m_length);
	}

    m_fMoreToFollow = pbitmapCreatePDU->moreToFollow;


    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);

	//
	// If this is a remote pointer
	//
	if(m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		CreateColoredIcon(0, m_lpbiImage, m_lpTransparencyMask);
		CreateSaveBitmap();
	}


}

void BitmapObj::Continue (BitmapCreateContinuePDU * pbitmapCreateContinuePDU)
{
	//
	// Get the continuation bitmap data
	//
	BYTE * pNewBitmapBuffer = NULL;
	ULONG length = 0;
	BYTE* pSentBuff;

   	//
   	// Allocate a buffer for the previous data and the one we just got, copy the old data in the new buffer
   	//
	if(pbitmapCreateContinuePDU->bit_mask == BitmapCreateContinuePDU_nonStandardParameters_present)
	{
		length = pbitmapCreateContinuePDU->nonStandardParameters->value.data.length;
		pSentBuff = pbitmapCreateContinuePDU->nonStandardParameters->value.data.value;
	}
	else
	{
		return;
	}

	//
	// Copy the old data
	//
	pNewBitmapBuffer = (BYTE *)::GlobalAlloc(GPTR, m_bitmapData.m_length + length);
	if(pNewBitmapBuffer == NULL)
	{
		TRACE_DEBUG(("Could not allocate memory size = %d)", m_bitmapData.m_length + length));
		return;
	}
	
	memcpy(pNewBitmapBuffer, m_lpbiImage, m_bitmapData.m_length);

	TRACE_DEBUG(("BitmapObj::Continue length = %d moreToFollow = %d)", length, pbitmapCreateContinuePDU->moreToFollow));

	//
	// Copy the new data
	//
    memcpy(pNewBitmapBuffer + m_bitmapData.m_length, pSentBuff, length);

	//
	// delete the old buffer
	//
    ::GlobalFree((HGLOBAL)m_lpbiImage);

	//
	// Update bitmap data info
	//
    m_lpbiImage = (LPBITMAPINFOHEADER)pNewBitmapBuffer;
	m_bitmapData.m_length += length;
	m_lpbiImage->biSizeImage += length;

    m_fMoreToFollow = pbitmapCreateContinuePDU->moreToFollow;
}


BitmapObj::BitmapObj (UINT toolType)
{

	SetType(bitmapCreatePDU_chosen);
	ResetAttrib();
	SetOwnerID(g_MyMemberID);
	SetMyWorkspace(NULL);
	m_ToolType = toolType;
	m_lpTransparencyMask = NULL;
	m_lpbiImage = NULL;
	m_lpBitMask = NULL;
	m_hSaveBitmap = NULL;
	m_hOldBitmap = NULL;
	m_fMoreToFollow = FALSE;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	SetPenThickness(0);

	//
	// Set it to 0 so it boundsRect == rect
	//
	RECT rect;
    ::SetRectEmpty(&rect);
	SetRect(&rect);

	
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
	SetPlaneID(1);

	SetViewState(unselected_chosen);
	SetZOrder(front);
	SetAnchorPoint(0,0);

	if(m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		// We haven't yet created our mem DC
	    m_hSaveBitmap = NULL;
	    m_hOldBitmap = NULL;

    	// Set the bounding rectangle of the object
		rect.left = 0;
		rect.top = 0;
		rect.right = ::GetSystemMetrics(SM_CXICON);
		rect.bottom = ::GetSystemMetrics(SM_CYICON);
		SetRect(&rect);
	}

    // Show that we do not have an icon for drawing yet
    m_hIcon = NULL;

    // Create a memory DC compatible with the display
    m_hMemDC = ::CreateCompatibleDC(NULL);

}

BitmapObj::~BitmapObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);
	
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}
    ::GlobalFree((HGLOBAL)m_lpbiImage);

	DeleteSavedBitmap();
	
    if (m_hMemDC != NULL)
    {
        ::DeleteDC(m_hMemDC);
        m_hMemDC = NULL;
    }

	if(g_pMain && g_pMain->m_pLocalRemotePointer == this)
	{
		GetAnchorPoint(&g_pMain->m_localRemotePointerPosition);
		g_pMain->m_pLocalRemotePointer = NULL;
		g_pMain->m_TB.PopUp(IDM_REMOTE);
	}

	if(m_lpTransparencyMask)
	{
		delete m_lpTransparencyMask;
		m_lpTransparencyMask = NULL;
	}

	if(m_hIcon)
	{
		::DestroyIcon(m_hIcon);
	}


}
	

void BitmapObj::BitmapEditObj (BitmapEditPDU * pbitmapEditPDU )
{
	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_MSG(("bitmapHandle = %d", pbitmapEditPDU->bitmapHandle ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Read attributes
	//
	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_attributeEdits_present)
	{
		GetBitmapAttrib((PBitmapCreatePDU_attributes)pbitmapEditPDU->attributeEdits);
	}

	//
	// Change the anchor point
	//
	GetAnchorPoint(&anchorPoint);
	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_anchorPointEdit_present)
	{

		TRACE_DEBUG(("Old anchor point (%d,%d)", anchorPoint.x, anchorPoint.y));
		TRACE_DEBUG(("New anchor point (%d,%d)",
		pbitmapEditPDU->anchorPointEdit.xCoordinate, pbitmapEditPDU->anchorPointEdit.yCoordinate));
		//
		// Get the delta from previous anchor point
		//
		deltaX =  pbitmapEditPDU->anchorPointEdit.xCoordinate - anchorPoint.x;
		deltaY =  pbitmapEditPDU->anchorPointEdit.yCoordinate - anchorPoint.y;
		TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

		//
		// Was edited remotely
		//
		ClearEditionFlags();

		//
		// Set new anchor point
		//
		anchorPoint.x = pbitmapEditPDU->anchorPointEdit.xCoordinate;
		anchorPoint.y = pbitmapEditPDU->anchorPointEdit.yCoordinate;
		SetAnchorPoint(anchorPoint.x, anchorPoint.y);

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
	}


//	if(pbitmapEditPDU->bit_mask & BitmapEditPDU_nonStandardParameters_present)
//	{
//		;		// Do the non Standard Edit PDU NYI
//	}

	if(HasAnchorPointChanged())
	{
		g_pDraw->EraseInitialDrawFinal(0 - deltaX,0 - deltaY, FALSE, (T126Obj*)this);
		GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}

	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
	}
	else
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();

}

void    BitmapObj::GetBitmapAttrib(PBitmapCreatePDU_attributes pAttribPDU)
{

	PBitmapCreatePDU_attributes attributes;
	attributes = (PBitmapCreatePDU_attributes)pAttribPDU;
	while(attributes)
	{
		switch(attributes->value.choice)
		{

			case(BitmapAttribute_viewState_chosen):
			{

				if((attributes->value.u.viewState).choice != nonStandardViewState_chosen)
				{
					SetViewState(attributes->value.u.viewState.choice);
					
					//
					// If the other node is selecting the drawing or unselecting
					//
					if(attributes->value.u.viewState.choice == selected_chosen)
					{
						SelectedRemotely();
					}
					else if(attributes->value.u.viewState.choice == unselected_chosen)
					{
						ClearSelectionFlags();
					}

					TRACE_MSG(("Attribute viewState %d", attributes->value.u.viewState.choice));
				}
				else
				{
					// Do the non Standard view state
					;
				}
				break;
			}

			case(BitmapAttribute_zOrder_chosen):
			{
				SetZOrder(attributes->value.u.zOrder);
				TRACE_MSG(("Attribute zOrder %d", attributes->value.u.zOrder));
				break;
			}

			case(BitmapAttribute_transparencyMask_chosen):
			{
				TRACE_MSG(("Attribute transparencyMask"));
				if(attributes->value.u.transparencyMask.bitMask.choice == uncompressed_chosen)
				{
					m_SizeOfTransparencyMask = attributes->value.u.transparencyMask.bitMask.u.uncompressed.length;
					DBG_SAVE_FILE_LINE
					m_lpTransparencyMask = new BYTE[m_SizeOfTransparencyMask];

					memcpy(m_lpTransparencyMask, attributes->value.u.transparencyMask.bitMask.u.uncompressed.value, m_SizeOfTransparencyMask);

					//
					// Asn wants it top bottom left right
					//
//					BYTE swapByte;
//					for (UINT i=0; i <m_SizeOfTransparencyMask ; i++)
//					{
//						swapByte = attributes->value.u.transparencyMask.bitMask.u.uncompressed.value[i];
//						m_lpTransparencyMask [i] = ~(((swapByte >> 4) & 0x0f) | ((swapByte << 4)));
//					}
				}
				break;
			}
			
			case(DrawingAttribute_nonStandardAttribute_chosen):
			{
				break; // NYI
			}

			default:
		    WARNING_OUT(("Invalid attributes choice"));
			break;
		}

		attributes = attributes->next;
	}
}

void BitmapObj::CreateNonStandard24BitBitmap(BitmapCreatePDU * pBitmapCreatePDU)
{
	pBitmapCreatePDU->bit_mask |= BitmapCreatePDU_nonStandardParameters_present;

	//
	// Create the bitmpa header because it is not optional
	//
	pBitmapCreatePDU->bitmapFormatHeader.choice = bitmapHeaderNonStandard_chosen;
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.nonStandardIdentifier.choice = bitmapHeaderNonStandard_chosen;
	CreateNonStandardPDU(&pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard, NonStandard24BitBitmapID);
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.data.length = 0;
	pBitmapCreatePDU->bitmapFormatHeader.u.bitmapHeaderNonStandard.data.value = NULL;

	
	DBG_SAVE_FILE_LINE
	pBitmapCreatePDU->nonStandardParameters = new BitmapCreatePDU_nonStandardParameters;
	pBitmapCreatePDU->nonStandardParameters->next = NULL;
	CreateNonStandardPDU(&pBitmapCreatePDU->nonStandardParameters->value, NonStandard24BitBitmapID);
	
}


void BitmapObj::CreateBitmapCreatePDU(CWBOBLIST * pCreatePDUList)
{

	if(m_lpbiImage == NULL)
	{
		TRACE_MSG(("We dont have a bitmap structure to sent"));
		return;
	}

	
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(!sipdu)
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        return;
	}

	//
	// This is the first bitmap create pdu
	//
	sipdu->choice = bitmapCreatePDU_chosen;
	BitmapCreatePDU *pCreatePDU = &sipdu->u.bitmapCreatePDU;

	pCreatePDU->bit_mask = 0;
	pCreatePDU->nonStandardParameters = NULL;

	//
	// Pass the bitmap Handle
	//
	pCreatePDU->bitmapHandle = GetThisObjectHandle();

	//
	// Pass the destination adress
	//
	if(	m_ToolType == TOOLTYPE_REMOTEPOINTER)
	{
		pCreatePDU->destinationAddress.choice = softCopyPointerPlane_chosen;
		pCreatePDU->destinationAddress.u.softCopyPointerPlane.workspaceHandle = GetMyWorkspace()->GetWorkspaceHandle();
	}
	else
	{
		pCreatePDU->destinationAddress.choice = BitmapDestinationAddress_softCopyImagePlane_chosen;
		pCreatePDU->destinationAddress.u.softCopyImagePlane.workspaceHandle = GetMyWorkspace()->GetWorkspaceHandle();
		pCreatePDU->destinationAddress.u.softCopyImagePlane.plane = (DataPlaneID)GetPlaneID();
	}

	//
	// Pass the bitmap attributes
	//
	pCreatePDU->bit_mask |=BitmapCreatePDU_attributes_present;
 	SetBitmapAttrib(&pCreatePDU->attributes);

	//
	// Pass the anchor point
	//
    pCreatePDU->bit_mask |=BitmapCreatePDU_anchorPoint_present;
	POINT point;
	GetAnchorPoint(&point);
    pCreatePDU->anchorPoint.xCoordinate = point.x;
    pCreatePDU->anchorPoint.yCoordinate = point.y;

	//
	// Pass the bitmap size
	//
	pCreatePDU->bitmapSize.width = m_bitmapSize.x;
	pCreatePDU->bitmapSize.height = m_bitmapSize.y;

	//
	// Pass bitmap region of interest
	//
	pCreatePDU->bit_mask |=bitmapRegionOfInterest_present;
    BitmapRegion bitmapRegionOfInterest;

	//
	// Pass pixel aspect ratio
	//
    pCreatePDU->pixelAspectRatio.choice = PixelAspectRatio_square_chosen;

	//
	// Pass scaling factor
	//
//	pCreatePDU->bit_mask |=BitmapCreatePDU_scaling_present;
//  pCreatePDU->scaling.xCoordinate = 0;
//  pCreatePDU->scaling.yCoordinate = 0;

	//
	// Pass check points
//
//	pCreatePDU->bit_mask |=checkpoints_present;
//  pCreatePDU->checkpoints;

	//
	// JOSEF If we want > 8 have to recalculate to 24
	//
	
	LPSTR pDIB_bits;
	LPBITMAPINFOHEADER lpbi8 = m_lpbiImage;
	HDC hdc = NULL;
	HBITMAP hbmp = NULL;
	DWORD sizeOfBmpData = 0;

	if(!g_pNMWBOBJ->CanDo24BitBitmaps())
	{
	
		hdc = GetDC(NULL);
		
		BITMAPINFOHEADER lpbmih;
		if(lpbi8->biBitCount > MAX_BITS_PERPIXEL)
		{
	
			lpbmih.biSize = sizeof(BITMAPINFOHEADER);
			lpbmih.biWidth = lpbi8->biWidth;
			lpbmih.biHeight = lpbi8->biHeight;
			lpbmih.biPlanes = 1;
			lpbmih.biBitCount = MAX_BITS_PERPIXEL;
			lpbmih.biCompression = lpbi8->biCompression;
			lpbmih.biSizeImage = lpbi8->biSizeImage;
			lpbmih.biXPelsPerMeter = lpbi8->biXPelsPerMeter;
			lpbmih.biYPelsPerMeter = lpbi8->biYPelsPerMeter;
			lpbmih.biClrUsed = lpbi8->biClrUsed;
			lpbmih.biClrImportant = lpbi8->biClrImportant;
	
			hbmp = CreateDIBitmap(hdc, &lpbmih, CBM_INIT, DIB_Bits(lpbi8),(LPBITMAPINFO)lpbi8, DIB_RGB_COLORS);
			lpbi8 = DIB_FromBitmap(hbmp, NULL, FALSE, FALSE);
		}
	}


	if(lpbi8 == NULL)
	{
		TRACE_MSG(("Failed to convert bitmap"));
		::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
		delete [] sipdu;
		return;
	}


	pDIB_bits = (LPSTR)lpbi8;
	sizeOfBmpData = DIB_TotalLength(lpbi8);

	
	
	//
	// Sending data
	//
	BOOL bMoreToFollow = FALSE;
	DWORD length = sizeOfBmpData;
	
	pCreatePDU->bitmapData.bit_mask = 0;
	
	if(sizeOfBmpData > MAX_BITMAP_DATA)
	{
		length = MAX_BITMAP_DATA;
		bMoreToFollow = TRUE;
	}
	
	pCreatePDU->moreToFollow = (ASN1bool_t)bMoreToFollow;
	//
	// Pass the bitmap info
	//
	pCreatePDU->bit_mask |= BitmapCreatePDU_nonStandardParameters_present;
	CreateNonStandard24BitBitmap(&sipdu->u.bitmapCreatePDU);
	pCreatePDU->nonStandardParameters->value.data.length = length;
	pCreatePDU->nonStandardParameters->value.data.value = (ASN1octet_t *)pDIB_bits;

	//
	// We are not passing it into the data field
	//
	pCreatePDU->bitmapData.bit_mask = 0;
	pCreatePDU->bitmapData.data.length = 1;

	pCreatePDUList->AddTail(sipdu);
	
	BitmapCreateContinuePDU * pCreateContinuePDU;
	while(bMoreToFollow)
	{
		//
		// Advance the pointer
		//
		pDIB_bits += MAX_BITMAP_DATA;
		sizeOfBmpData-= MAX_BITMAP_DATA;
	
		if(sizeOfBmpData > MAX_BITMAP_DATA)
		{
			length = MAX_BITMAP_DATA;
		}
		else
		{
			length = sizeOfBmpData;
			bMoreToFollow = FALSE;
		}

		//
		// Create a new BitmapCreateContinuePDU
		//
		sipdu = NULL;
		DBG_SAVE_FILE_LINE
		sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
		if(!sipdu)
		{
			TRACE_MSG(("Failed to create sipdu"));
	        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	        return;
		}

		sipdu->choice = bitmapCreateContinuePDU_chosen;
		pCreateContinuePDU = &sipdu->u.bitmapCreateContinuePDU;
		
		pCreateContinuePDU->bit_mask = 0;
		pCreateContinuePDU->nonStandardParameters = NULL;

	
		//
		// Pass the bitmap Handle
		//
		pCreateContinuePDU->bitmapHandle = GetThisObjectHandle();
			
		//
		// Pass the data
		//
		pCreateContinuePDU->bit_mask |= BitmapCreateContinuePDU_nonStandardParameters_present;
			
		//
		// Pass the bitmap info
		//
		DBG_SAVE_FILE_LINE
		pCreateContinuePDU->nonStandardParameters = new BitmapCreateContinuePDU_nonStandardParameters;
		pCreateContinuePDU->nonStandardParameters->next = NULL;
			
		CreateNonStandardPDU(&pCreateContinuePDU->nonStandardParameters->value, NonStandard24BitBitmapID);
		pCreateContinuePDU->nonStandardParameters->value.data.length = length;
		pCreateContinuePDU->nonStandardParameters->value.data.value = (ASN1octet_t *)pDIB_bits;

		//
		// We are not passing it into the data field
		//
		pCreateContinuePDU->bitmapData.bit_mask = 0;
		pCreateContinuePDU->bitmapData.data.length = 1;
		
		pCreateContinuePDU->moreToFollow = (ASN1bool_t) bMoreToFollow;
		pCreatePDUList->AddTail(sipdu);
		
	}
	
	if(hbmp)
	{
		DeleteObject(hbmp);
	}
	
	if(hdc)
	{
		ReleaseDC(NULL, hdc);
	}
}
	
void BitmapObj::CreateBitmapEditPDU(BitmapEditPDU *pEditPDU)
{
	pEditPDU->bit_mask = (ASN1uint16_t) GetPresentAttribs();

	//
	// Pass the anchor point
	//
	if(HasAnchorPointChanged())
	{
		POINT point;
		GetAnchorPoint(&point);
		pEditPDU->anchorPointEdit.xCoordinate = point.x;
		pEditPDU->anchorPointEdit.yCoordinate = point.y;
	}

	//
	// JOSEF Pass Region of interest (FEATURE)
	//

	//
	// JOSEF Pass scaling (FEATURE)
	//
	
	//
	// Pass all the changed attributes, if any.
	//
	pEditPDU->attributeEdits = NULL;
	if(pEditPDU->bit_mask & BitmapEditPDU_attributeEdits_present)
	{
		SetBitmapAttrib((PBitmapCreatePDU_attributes *)&pEditPDU->attributeEdits);
	}
	
	pEditPDU->bitmapHandle = GetThisObjectHandle();

}
	
void BitmapObj::CreateBitmapDeletePDU(BitmapDeletePDU *pDeletePDU)
{
	pDeletePDU->bit_mask = 0;
	pDeletePDU->bitmapHandle = GetThisObjectHandle();
}


void    BitmapObj::AllocateAttrib(PBitmapCreatePDU_attributes *pAttributes)
{
	DBG_SAVE_FILE_LINE
	PBitmapCreatePDU_attributes  pAttrib = (PBitmapCreatePDU_attributes)new BYTE[sizeof(BitmapCreatePDU_attributes)];
	if(*pAttributes == NULL)
	{
		*pAttributes = pAttrib;	
		pAttrib->next = NULL;
	}
	else
	{
		((PBitmapCreatePDU_attributes)pAttrib)->next = *pAttributes;
		*pAttributes = pAttrib;
	}
}





void    BitmapObj::SetBitmapAttrib(PBitmapCreatePDU_attributes *pattributes)
{
	PBitmapCreatePDU_attributes attributes = NULL;

	//
	// Do the viewState
	//
	if(HasViewStateChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_viewState_chosen;
		attributes->value.u.viewState.choice = (ASN1choice_t)GetViewState();
	}

	//
	// Do the zOrder
	//
	if(HasZOrderChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_zOrder_chosen;
		attributes->value.u.zOrder = GetZOrder();
	}


	//
	// Do the Transparency
	//
	if(HasTransparencyMaskChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = BitmapAttribute_transparencyMask_chosen;
		attributes->value.u.transparencyMask.bit_mask = 0;
		attributes->value.u.transparencyMask.bitMask.choice = uncompressed_chosen;
		attributes->value.u.transparencyMask.bitMask.u.uncompressed.length = m_SizeOfTransparencyMask;
		attributes->value.u.transparencyMask.bitMask.u.uncompressed.value = m_lpTransparencyMask;
	}
	
	//
	// End of attributes
	//
	*pattributes = attributes;

}


void	BitmapObj::Draw(HDC hDC, BOOL bForcedDraw, BOOL bPrinting)
{

	if(!bPrinting)
	{
		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

	RECT	clipBox;
	RECT 	rect;
	GetRect(&rect);

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}
	
	MLZ_EntryOut(ZONE_FUNCTION, "BitmapObj::Draw");

	// Only draw anything if the bounding rectangle intersects
	// the current clip box.
	if (::GetClipBox(hDC, &clipBox) == ERROR)
	{
		WARNING_OUT(("Failed to get clip box"));
	}
	else if (!::IntersectRect(&clipBox, &clipBox, &rect))
	{
		TRACE_MSG(("No clip/bounds intersection"));
		return;
	}

	if(m_ToolType == TOOLTYPE_FILLEDBOX)
	{
		if(m_fMoreToFollow)
		{
			return;
		}

	    // Set the stretch mode to be used so that scan lines are deleted
		// rather than combined. This will tend to preserve color better.
		int iOldStretchMode = ::SetStretchBltMode(hDC, STRETCH_DELETESCANS);

		// Draw the bitmap
		::StretchDIBits(hDC,
						 rect.left,
						 rect.top,
						 rect.right - rect.left,
						 rect.bottom - rect.top,
						 0,
						 0,
						 (UINT) m_lpbiImage->biWidth,
						 (UINT) m_lpbiImage->biHeight,
						 (VOID FAR *) DIB_Bits(m_lpbiImage),
						 (LPBITMAPINFO)m_lpbiImage,
						 DIB_RGB_COLORS,
						 SRCCOPY);

		// Restore the stretch mode
		::SetStretchBltMode(hDC, iOldStretchMode);
	}
 	else
	{
		// Create the save bitmap if necessary
		CreateSaveBitmap();

		// Draw the icon
		::DrawIcon(hDC, rect.left, rect.top, m_hIcon);
  	
	}

}



//
//
// Function:    BitmapObj::::FromScreenArea
//
// Purpose:     Set the content of the object from an area of the screen
//
//
void BitmapObj::FromScreenArea(LPCRECT lprcScreen)
{
    m_lpbiImage = DIB_FromScreenArea(lprcScreen);
    if (m_lpbiImage == NULL)
    {
        ::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
    }
    else
    {

		m_bitmapSize.x = m_lpbiImage->biWidth;
		m_bitmapSize.y = m_lpbiImage->biHeight;

		RECT rect;
    	GetBoundsRect(&rect);
        // Calculate the bounding rectangle from the size of the bitmap
        rect.right = rect.left + m_lpbiImage->biWidth;
        rect.bottom = rect.top + m_lpbiImage->biHeight;
		SetRect(&rect);
    }
}


UINT GetBitmapDestinationAddress(BitmapDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID)
{
	UINT toolType = TOOLTYPE_FILLEDBOX;

	//
	// Get the destination address
	//
	switch(destinationAddress->choice)
	{

		case(BitmapDestinationAddress_softCopyImagePlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyImagePlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyImagePlane.plane);
			break;
		}
		case(BitmapDestinationAddress_softCopyAnnotationPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyAnnotationPlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyAnnotationPlane.plane);
			break;
		}
		case(softCopyPointerPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyPointerPlane.workspaceHandle);
			*planeID = (0);
			toolType = TOOLTYPE_REMOTEPOINTER;
			break;
		}
	
//		case(BitmapDestinationAddress_nonStandardDestination_chosen):
//		{
//			break;
//		}

		default:
	    ERROR_OUT(("Invalid destinationAddress"));
		break;
	}
	return toolType;
}


//
// UI Edited the Bitmap Object
//
void BitmapObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;
	
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = bitmapEditPDU_chosen;
		CreateBitmapEditPDU(&sipdu->u.bitmapEditPDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// UI Deleted the Bitmap Object
//
void BitmapObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = bitmapDeletePDU_chosen;
		CreateBitmapDeletePDU(&sipdu->u.bitmapDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

void	BitmapObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	pBuf->length = DIB_TotalLength(m_lpbiImage);
	pBuf->value = (PBYTE)m_lpbiImage;
}



//
// UI Created a new Bitmap Object
//
void BitmapObj::SendNewObjectToT126Apps(void)
{
	SIPDU *sipdu = NULL;
	CWBOBLIST BitmapContinueCreatePDUList;
	BitmapContinueCreatePDUList.EmptyList();
	CreateBitmapCreatePDU(&BitmapContinueCreatePDUList);
	T120Error rc = T120_NO_ERROR;
	
	WBPOSITION pos = BitmapContinueCreatePDUList.GetHeadPosition();
	while (pos != NULL)
    {
		sipdu = (SIPDU *) BitmapContinueCreatePDUList.GetNext(pos);
		TRACE_DEBUG(("Sending Bitmap >> Bitmap handle  = %d", sipdu->u.bitmapCreatePDU.bitmapHandle ));
		if(g_bSavingFile && GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			; // Don't send Remote pointers to disk
		}
		else
		{
			if(!m_fMoreToFollow)
			{
				rc = SendT126PDU(sipdu);
			}
		}

		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
			
	}
	BitmapContinueCreatePDUList.EmptyList();

}




//
//
// Function:	CreateColoredIcon
//
// Purpose:	 Create an icon of the correct color for this pointer.
//
//
HICON BitmapObj::CreateColoredIcon(COLORREF color, LPBITMAPINFOHEADER lpbInfo, LPBYTE pMaskBits)
{
	HICON	   hColoredIcon = NULL;
	HBRUSH	  hBrush = NULL;
	HBRUSH	  hOldBrush;
	HBITMAP	 hImage = NULL;
	HBITMAP	 hOldBitmap;
	HBITMAP	 hMask = NULL;
	COLOREDICON  *pColoredIcon;
	ICONINFO	ii;
	UINT i;
	LPSTR pBits;
	LPBITMAPINFOHEADER lpbi;
	BYTE swapByte;

	color = SET_PALETTERGB(color);
	
	MLZ_EntryOut(ZONE_FUNCTION, "RemotePointerObject::CreateColoredIcon");

	//
	// Create the mask for the icon with the data sent through T126
	//
	if(pMaskBits && lpbInfo)
	{
		hMask = CreateBitmap(lpbInfo->biWidth, lpbInfo->biHeight, 1, 1, m_lpTransparencyMask);
	}
	//
	// Create the local mask
	//
	else
	{
		// Load the mask bitmap
		hMask = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERANDMASK));
		if (!hMask)
		{
			TRACE_MSG(("Could not load mask bitmap"));
			goto CreateIconCleanup;
		}
	}	

	//
	// Create a bitmap with the data that sent through T126
	//
	if(lpbInfo)
	{
		VOID *ppvBits;
		hImage = CreateDIBSection(m_hMemDC, (LPBITMAPINFO)lpbInfo, DIB_RGB_COLORS, &ppvBits, NULL, 0);

		if(!ppvBits)
		{
			TRACE_MSG(("CreateColoredIcon failed calling CreateDIBSection  error = %d", GetLastError()));
			goto CreateIconCleanup;
		}

		
		pBits = DIB_Bits(lpbInfo);

		::GetDIBits(m_hMemDC, hImage, 0, (WORD) lpbInfo->biHeight, NULL,(LPBITMAPINFO)lpbInfo, DIB_RGB_COLORS);
		memcpy(ppvBits, pBits, lpbInfo->biSizeImage);
		if(!hMask)
		{
			hMask = CreateBitmap(lpbInfo->biWidth, lpbInfo->biHeight, 1, 1, NULL);
		}
	}
	//
	// Create a local bitmap
	//
	else
	{
		// Load the image bitmap
		hImage = ::LoadBitmap(g_hInstance, MAKEINTRESOURCE(REMOTEPOINTERXORDATA));
		if (!hImage)
		{
			TRACE_MSG(("Could not load pointer bitmap"));
			goto CreateIconCleanup;
		}

		hBrush = ::CreateSolidBrush(color);
		if (!hBrush)
		{
			TRACE_MSG(("Couldn't create color brush"));
			goto CreateIconCleanup;
		}

		// Select in the icon color
		hOldBrush = SelectBrush(m_hMemDC, hBrush);

		// Select the image bitmap into the memory DC
		hOldBitmap = SelectBitmap(m_hMemDC, hImage);

		if(!hOldBitmap)
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
		}

		// Fill the image bitmap with color
		::FloodFill(m_hMemDC, ::GetSystemMetrics(SM_CXICON) / 2, ::GetSystemMetrics(SM_CYICON) / 2, RGB(0, 0, 0));

		SelectBitmap(m_hMemDC, hOldBitmap);

		SelectBrush(m_hMemDC, hOldBrush);
   	}

	//
	// Now use the image and mask bitmaps to create an icon
	//
	ii.fIcon = TRUE;
	ii.xHotspot = 0;
	ii.yHotspot = 0;
	ii.hbmMask = hMask;
	ii.hbmColor = hImage;

	// Create a new icon from the data and mask
	hColoredIcon = ::CreateIconIndirect(&ii);

	//
	// Create the internal format if we were created locally
	//
	if(m_lpbiImage == NULL)
	{
		m_lpbiImage = DIB_FromBitmap(hImage, NULL, FALSE, FALSE, TRUE);
	}	

	if(m_lpTransparencyMask == NULL)
	{
		ChangedTransparencyMask();
		
		lpbi = DIB_FromBitmap(hMask,NULL,FALSE, TRUE);
		pBits = DIB_Bits(lpbi);
		m_SizeOfTransparencyMask = lpbi->biSizeImage;
		DBG_SAVE_FILE_LINE
		m_lpTransparencyMask = new BYTE[m_SizeOfTransparencyMask];
		memcpy(m_lpTransparencyMask, pBits, m_SizeOfTransparencyMask );
		::GlobalFree(lpbi);
	}	
	
	if (m_lpbiImage == NULL)
	{
		::Message(NULL, (UINT)IDS_MSG_CAPTION, (UINT)IDS_CANTGETBMP, (UINT)MB_OK );
	}
	else
	{

		m_bitmapSize.x = m_lpbiImage->biWidth;
		m_bitmapSize.y = m_lpbiImage->biHeight;

		RECT rect;
		GetBoundsRect(&rect);
		// Calculate the bounding rectangle from the size of the bitmap
		rect.right = rect.left + m_lpbiImage->biWidth;
		rect.bottom = rect.top + m_lpbiImage->biHeight;
		SetRect(&rect);
		SetAnchorPoint(rect.left, rect.top);

 	}

CreateIconCleanup:

	// Free the image bitmap
	if (hImage != NULL)
	{
		::DeleteBitmap(hImage);
	}

	// Free the mask bitmap
	if (hMask != NULL)
	{
		::DeleteBitmap(hMask);
	}

	if (hBrush != NULL)
	{
		::DeleteBrush(hBrush);
	}

	m_hIcon = hColoredIcon;
	
	return(hColoredIcon);
}


//
//
// Function:    BitmapObj::CreateSaveBitmap()
//
// Purpose:     Create a bitmap for saving the bits under the pointer.
//
//
void BitmapObj::CreateSaveBitmap()
{
    MLZ_EntryOut(ZONE_FUNCTION, "BitmapObj::CreateSaveBitmap");

    // If we already have a save bitmap, exit immediately
    if (m_hSaveBitmap != NULL)
    {
        TRACE_MSG(("Already have save bitmap"));
        return;
    }

    // Create a bitmap to save the bits under the icon. This bitmap is
    // created with space for building the new screen image before
    // blitting it to the screen.
	RECT rect;
	RECT    rcVis;

	POINT point;
	POINT delta;
	HDC hDC = NULL;
    g_pDraw->GetVisibleRect(&rcVis);
	GetRect(&rect);

	delta.x = rect.right - rect.left;
	delta.y = rect.bottom - rect.top;

	point.x = rect.left - rcVis.left;
	point.y = rect.top - rcVis.top;

	ClientToScreen (g_pDraw->m_hwnd, &point);

	rect.left = point.x;
	rect.top = point.y;
	rect.right = rect.left + delta.x;
	rect.bottom = rect.top + delta.y;

	//
	// Create the bitmap
	//
	m_hSaveBitmap = FromScreenAreaBmp(&rect);

}

//
//
// Function:    BitmapObj::Undraw()
//
// Purpose:     Draw the marker object
//
//
void BitmapObj::UnDraw(void)
{
	if(GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{

		// Create the save bitmap if necessary
		CreateSaveBitmap();

		//
		// Select the saved area
		//
		if(m_hSaveBitmap)
		{
			m_hOldBitmap = SelectBitmap(m_hMemDC, m_hSaveBitmap);
			if(!m_hOldBitmap)
			{
				ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
			}
		}

		// Copy the saved bits onto the screen
		UndrawScreen();
	}
	else
	{
		RECT rect;
		GetBoundsRect(&rect);
		g_pDraw->InvalidateSurfaceRect(&rect,TRUE);
	}
	
}

//
//
// Function:    BitmapObj::UndrawScreen()
//
// Purpose:     Copy the saved bits under the pointer to the screen.
//
//
BOOL BitmapObj::UndrawScreen()
{
    BOOL    bResult = FALSE;
    RECT    rcUpdate;

    MLZ_EntryOut(ZONE_FUNCTION, "DCWbGraphicPointer::UndrawScreen");

	GetRect(&rcUpdate);


    // We are undrawing - copy the saved bits to the DC passed
    bResult = ::BitBlt(g_pDraw->m_hDCCached, rcUpdate.left, rcUpdate.top,
        rcUpdate.right - rcUpdate.left, rcUpdate.bottom - rcUpdate.top,
        m_hMemDC, 0, 0, SRCCOPY);

    if (!bResult)
    {
        WARNING_OUT(("UndrawScreen - Could not copy from bitmap"));
    }
	else
	{
		DeleteSavedBitmap();
	}


    return(bResult);
}

void BitmapObj::DeleteSavedBitmap(void)
{

	// Restore the original bitmap to the memory DC
	if (m_hOldBitmap != NULL)
	{
		if(!SelectBitmap(m_hMemDC, m_hOldBitmap))
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not select old bitmap"));
		}

//		if(!DeleteBitmap(m_hOldBitmap))
//		{
//			ERROR_OUT(("DeleteSavedBitmap - Could not delete old bitmap"));
//		}
		m_hOldBitmap = NULL;
	}

	if (m_hSaveBitmap != NULL)
	{
		if(!DeleteBitmap(m_hSaveBitmap))
		{
			ERROR_OUT(("DeleteSavedBitmap - Could not delete bitmap"));
		}
		m_hSaveBitmap = NULL;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\nmctl1\splitbar2.cpp ===
#include "precomp.h"
#include "splitbar2.h"
#include "resource.h"

/* static */ int CSplitBar2::ms_dxpSplitBar = 0;  // width of a standard split bar window // GetSystemMetrics(SM_CXSIZEFRAME);

/* static */ void CSplitBar2::_UpdateSplitBar(void)
{
	ms_dxpSplitBar = GetSystemMetrics(SM_CXSIZEFRAME);
}

/*  C  S P L I T  B A R  */
/*-------------------------------------------------------------------------
    %%Function: CSplitBar2
    
-------------------------------------------------------------------------*/
CSplitBar2::CSplitBar2(void)
: m_hwndBuddy (NULL)
, m_hwndParent(NULL)
, m_pfnAdjust(NULL)
, m_Context(NULL)
, m_hdcDrag(NULL)
, m_fCaptured(FALSE)
{

    DBGENTRY(CSplitBar2::CSplitBar2);

    _UpdateSplitBar();

    DBGEXIT(CSplitBar2::CSplitBar2);
}


CSplitBar2::~CSplitBar2()
{
    DBGENTRY(CSplitBar2::~CSplitBar2);
	
    if( ::IsWindow( m_hWnd ) )
    {
        DestroyWindow();
    }

    DBGEXIT(CSplitBar2::~CSplitBar2);
}



HRESULT CSplitBar2::Create(HWND hwndBuddy, PFN_ADJUST pfnAdjust, LPARAM Context)
{
    DBGENTRY(CSplitBar2::Create);
    HRESULT hr = S_OK;

    if( hwndBuddy && pfnAdjust )
    {
        m_hwndBuddy = hwndBuddy;
        m_hwndParent = ::GetParent(hwndBuddy);
        m_pfnAdjust = pfnAdjust;
        m_Context = Context;

        RECT rc;
        SetRect( &rc, 0, 0, ms_dxpSplitBar, 0 );    
        
        if( !CWindowImpl<CSplitBar2>::Create( m_hwndParent, rc ) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = E_INVALIDARG;

    }

    DBGEXIT_HR(CSplitBar2::Create,hr);
    return hr;
}


LRESULT CSplitBar2::OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    
    
    DBGENTRY(CSplitBar2::OnLButtonDown);        

	POINT pt;
	pt.x = LOWORD(lParam);
	pt.y = HIWORD(lParam); 

	_TrackDrag(pt);

    DBGEXIT(CSplitBar2::OnLButtonDown);

	return 0;

}


/*  C O N S T R A I N  D R A G  P O I N T  */
/*-------------------------------------------------------------------------
    %%Function: _ConstrainDragPoint
    
-------------------------------------------------------------------------*/
int CSplitBar2::_ConstrainDragPoint(short x)
{

    DBGENTRY(CSplitBar2::_ConstrainDragPoint);


	// Factor out the drag offset (to make calculations easier)
	int dx = x - m_dxDragOffset;

	// Don't allow the panes to go below their minimum size
	if (dx < m_dxMin)
	{
		dx = m_dxMin;
	}
	else if (dx > m_dxMax)
	{
		dx = m_dxMax;
	}


    DBGEXIT(CSplitBar2::_ConstrainDragPoint);

	// Factor the drag offset back in
	return (m_dxDragOffset + dx);
}


/*  D R A W  B A R  */
/*-------------------------------------------------------------------------
    %%Function: _DrawBar
    
-------------------------------------------------------------------------*/
void CSplitBar2::_DrawBar(void)
{
    DBGENTRY(CSplitBar2::_DrawBar);

	RECT rc;
    
    RECT ClientRect;
    GetClientRect( &ClientRect );

	// Rectangle is a larger to make it easier to see.
	rc.top = ClientRect.top;
	rc.bottom = ClientRect.bottom;
	rc.left = m_xCurr - (m_dxDragOffset + 1); //ClientRect.left + 
	rc.right = rc.left + ms_dxpSplitBar + 1;
	::MapWindowPoints(m_hwndParent, GetDesktopWindow(), (POINT *) &rc, 2);

	::InvertRect(m_hdcDrag, &rc);

    DBGEXIT(CSplitBar2::_DrawBar);
}


/*  F  I N I T  D R A G  L O O P  */
/*-------------------------------------------------------------------------
    %%Function: FInitDragLoop

    Initialize the mouse down drag loop.
    Return FALSE if there was a problem.
-------------------------------------------------------------------------*/
BOOL CSplitBar2::FInitDragLoop(POINT pt)
{
    
    DBGENTRY(CSplitBar2::FInitDragLoop);

	if (NULL != ::GetCapture())
	{
		ERROR_OUT(("InitDragLoop: Unable to capture"));
		return FALSE;
	}

	// handle pending WM_PAINT messages
	MSG msg;
	while (::PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_NOREMOVE))
	{
		if (!GetMessage(&msg, NULL, WM_PAINT, WM_PAINT))
			return FALSE;
		DispatchMessage(&msg);
	}

	HWND hwndDesktop = GetDesktopWindow();
	DWORD dwFlags = ::LockWindowUpdate(hwndDesktop) ? DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE : DCX_WINDOW|DCX_CACHE;

	ASSERT(m_hdcDrag == NULL);
	m_hdcDrag = ::GetDCEx(hwndDesktop, NULL, dwFlags);
	ASSERT(m_hdcDrag != NULL);

	ASSERT(!m_fCaptured);
	SetCapture();
	ASSERT(m_hWnd == GetCapture());
	m_fCaptured = TRUE;

	m_dxDragOffset = pt.x;
	m_xCurr = pt.x;
	_DrawBar();

	RECT rc;
	// determine the drag extent
	::GetClientRect(m_hwndBuddy, &rc);
	::MapWindowPoints(m_hwndBuddy, m_hwndParent, (POINT *) &rc, 1);
	m_dxMin = rc.left + (32 + (3*2));
	
	::GetClientRect( ::GetParent( m_hwndParent ) , &rc);
	m_dxMax = RectWidth(rc) - (ms_dxpSplitBar + 176);

	if (m_dxMax < m_dxMin)
		m_dxMax = m_dxMin;

	TRACE_OUT(("captured mouse at (%d,%d) (min=%d, max=%d)", pt.x, pt.y, m_dxMin, m_dxMax));

    DBGEXIT(CSplitBar2::FInitDragLoop);

	return TRUE;
}


/*  O N  D R A G  M O V E  */
/*-------------------------------------------------------------------------
    %%Function: OnDragMove
    
-------------------------------------------------------------------------*/
void CSplitBar2::OnDragMove(POINT pt)
{

    DBGENTRY(CSplitBar2::OnDragMove);

	ASSERT(m_fCaptured);

	::ScreenToClient(m_hwndParent, &pt);
	int x = _ConstrainDragPoint((short)pt.x);
	if (x != m_xCurr)
	{
		_DrawBar();
		m_xCurr = x;
		_DrawBar();
	}

    DBGEXIT(CSplitBar2::OnDragMove);
}


/*  O N  D R A G  E N D  */
/*-------------------------------------------------------------------------
    %%Function: OnDragEnd
    
-------------------------------------------------------------------------*/
void CSplitBar2::OnDragEnd(POINT pt)
{

    DBGENTRY(CSplitBar2::OnDragEnd);

	CancelDragLoop();

    RECT ClientRect;
    GetClientRect( &ClientRect );

	::ScreenToClient(m_hwndParent, &pt);
	int x = _ConstrainDragPoint((short)pt.x);
	if (0 != x)
	{
		// Call the adjustment function
        if(m_pfnAdjust)
        {
            m_pfnAdjust(x - (ClientRect.left + m_dxDragOffset), m_Context);
        }

//		ForceWindowResize();
	}

    DBGEXIT(CSplitBar2::OnDragEnd);
}


/*  C A N C E L  D R A G  L O O P  */
/*-------------------------------------------------------------------------
    %%Function: CancelDragLoop
    
-------------------------------------------------------------------------*/
void CSplitBar2::CancelDragLoop(void)
{

    DBGENTRY(CSplitBar2::CancelDragLoop);

	if (m_fCaptured)
    {
	    TRACE_OUT(("Canceling drag loop..."));

	    // Release the capture
	    ReleaseCapture();
	    m_fCaptured = FALSE;

	    // Erase the bar
	    _DrawBar();

	    // unlock window updates
	    LockWindowUpdate(NULL);
	    if (m_hdcDrag != NULL)
	    {
		    ::ReleaseDC(GetDesktopWindow(), m_hdcDrag);
		    m_hdcDrag = NULL;
	    }
    }
    
    DBGEXIT(CSplitBar2::CancelDragLoop);
}


void CSplitBar2::_TrackDrag(POINT pt)
{

    DBGENTRY(CSplitBar2::_TrackDrag);

	// set capture to the window which received this message
	if (FInitDragLoop(pt))
	{
	    // get messages until capture lost or cancelled/accepted
	    while (GetCapture() == m_hWnd)
	    {
		    MSG msg;
		    if (!::GetMessage(&msg, NULL, 0, 0))
		    {
			    PostQuitMessage(msg.wParam);
			    break;
		    }

		    if (WM_MOUSEMOVE == msg.message)
		    {
			    OnDragMove(msg.pt);
			    continue;
		    }

		    if (WM_LBUTTONUP == msg.message)
		    {
			    OnDragEnd(msg.pt);
			    break;
		    }

		    if ((WM_KEYDOWN == msg.message) || 
			    (WM_RBUTTONDOWN == msg.message))
		    {
			    break;
		    }

		    // dispatch all other messages
		    DispatchMessage(&msg);
	    }

	    CancelDragLoop();
	}
    else
    {
		WARNING_OUT(("Unable to Initialize drag loop?"));
    }

    DBGEXIT(CSplitBar2::_TrackDrag);
}



/* static */ CWndClassInfo& CSplitBar2::GetWndClassInfo()
{

    DBGENTRY(CSplitBar2::GetWndClassInfo);

	static CWndClassInfo wc =
	{
		{ 
            sizeof(WNDCLASSEX), // cbSize
            NULL,               // style
            StartWindowProc,    // WndProc
            0,                  // cbClsExtra
            0,                  // cbWndExtra
            0,                  // hInstance
            0,                  // hIcon
            NULL,               // hCursor
            reinterpret_cast<HBRUSH>(COLOR_3DFACE + 1),  // hBackground
            0,                          // lpszMenuName
            _T("ConfSplitBarClass2"),   // lpszClassName
            0                           // hIconSm
        },
		NULL, 
        NULL, 
        MAKEINTRESOURCE(IDC_SPLITV), // hCursor, 
        FALSE, 
        0, 
        _T("")
	};

    DBGEXIT(CSplitBar2::GetWndClassInfo);

	return wc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\ccl32.cpp ===
//
// CCL32.CPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#define COMPILE_MULTIMON_STUBS
#include <multimon.h>
#include <regentry.h>
#include "NMWbObj.h"

LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam );



HHOOK   g_utMouseHookHandle = NULL;
HWND    g_utCaptureWindow = NULL;





void UT_CaptureMouse( HWND   hwnd )
{
	// disable asynchronous input so we don't lose capture because the
	// left button isn't down
    g_utMouseHookHandle = SetWindowsHookEx( WH_JOURNALRECORD,
                                              DummyMouseHookProc,
                                              g_hInstance,
                                              NULL );

    if( g_utMouseHookHandle == NULL )
    {
        WARNING_OUT(("Failed to insert JournalRecord hook"));
	}

	// grap mouse
    ::SetCapture(hwnd);
    g_utCaptureWindow = hwnd;
}


void UT_ReleaseMouse( HWND  hwnd )
{
    ::ReleaseCapture();
    g_utCaptureWindow = NULL;

    if (g_utMouseHookHandle != NULL )
	{
		// le go my lego
        ::UnhookWindowsHookEx( g_utMouseHookHandle );
        g_utMouseHookHandle = NULL;
	}
}


LRESULT CALLBACK DummyMouseHookProc( int code, WPARAM wParam, LPARAM lParam )
{
    return( CallNextHookEx( g_utMouseHookHandle, code, wParam, lParam ) );
}




//
// General definitions
//
#define MAX_OPTIONS_LINE_LENGTH         255
#define MAX_SECTION_LEN                 200


//
//
// Function: HexDigitToByte
//
// Purpose:  Helper function to convert a single hex digit to a byte value.
//
//
BOOL HexDigitToByte(char cHexDigit, BYTE& byte);

BOOL HexDigitToByte(char cHexDigit, BYTE& byte)
{
  // Decimal digits
  if (   (cHexDigit >= '0')
      && (cHexDigit <= '9'))
  {
    byte = (BYTE) (cHexDigit - '0');
    return(TRUE);
  }

  // Uppercase characters
  if (   (cHexDigit >= 'A')
      && (cHexDigit <= 'F'))
  {
    byte = (BYTE) ((cHexDigit - 'A') + 10);
    return(TRUE);
  }

  // Lowercase characters
  if (   (cHexDigit >= 'a')
      && (cHexDigit <= 'f'))
  {
    byte = (BYTE) ((cHexDigit - 'a') + 10);
    return(TRUE);
  }

  // The character is not a valid hex digit
  return(FALSE);
}




//
//
// Function: GetIntegerOption
//
// Purpose:  Retrieve a named option from the dictionary and convert the
//           option string to a long integer value.
//
//
LONG OPT_GetIntegerOption
(
    LPCSTR  cstrOptionName,
    LONG    lDefault
)
{
    LONG    lResult;
    TCHAR   cstrValue[MAX_OPTIONS_LINE_LENGTH];

    if (OPT_Lookup(cstrOptionName, cstrValue, MAX_OPTIONS_LINE_LENGTH))
    {
        // Option has been found, convert it to a long
        lResult = RtStrToInt(cstrValue);
    }
    else
    {
        // The option is not in the dictionary, return the default
        lResult = lDefault;
    }

    return lResult;
}



//
//
// Function: GetBooleanOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a boolean value.
//
//
BOOL OPT_GetBooleanOption
(
    LPCSTR  cstrOptionName,
    BOOL    bDefault
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];

    // Lookup the option
    if (OPT_Lookup(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH))
    {
        return(cstrValue[0] == 'y' || cstrValue[0] =='Y') ;
    }

    return bDefault;
}



//
//
// Function: GetStringOption
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it. No conversion of the string is performed.
//
//
void OPT_GetStringOption
(
    LPCSTR  cstrOptionName,
    LPSTR   cstrValue,
    UINT	size
)
{
    if (!OPT_Lookup(cstrOptionName, cstrValue, size) || !(lstrlen(cstrValue)))
    {
        *cstrValue = _T('\0');
    }
}


//
//
// Function: Lookup
//
// Purpose:  Retrieve a named option from the dictionary and return a copy
//           of it in the CString object passed. No conversion is performed.
//
//
BOOL OPT_Lookup
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrResult,
    UINT		size
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    read_hkey = NULL;
	DWORD	    read_type;
	DWORD	    read_bufsize;

	// open key
	if (RegOpenKeyEx( HKEY_CURRENT_USER,
					  NEW_WHITEBOARD_KEY,
					  0,
					  KEY_EXECUTE,
					  &read_hkey )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not open key"));
        goto bail_out;
    }


	// read key's value
	read_bufsize = size;
	if (RegQueryValueEx( read_hkey,
					     cstrOptionName,
						 NULL,
						 &read_type,
						 (LPBYTE)cstrResult,
						 &read_bufsize )
		!= ERROR_SUCCESS )
    {
        TRACE_MSG(("Could not read key"));
        goto bail_out;
    }


	// check for valid type
	if (read_type != REG_SZ)
    {
        WARNING_OUT(("Bad key data"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (read_hkey != NULL)
		RegCloseKey(read_hkey);

	return (fSuccess);
}

//
//
// Function: GetWindowRectOption
//
// Purpose:  Retrieve a named option from the dictionary and convert it to
//           a window rectangle.  The rectangle is checked to make sure that
//           it is at least partially on screen, and not zero sized.
//
//
void OPT_GetWindowRectOption(LPRECT pRect)
{
	RegEntry reWnd( NEW_WHITEBOARD_KEY, HKEY_CURRENT_USER );
	pRect->left = reWnd.GetNumber( REGVAL_WINDOW_XPOS, 0);
	pRect->top = reWnd.GetNumber( REGVAL_WINDOW_YPOS, 0);
	int cx = reWnd.GetNumber( REGVAL_WINDOW_WIDTH, 0);
	int cy = reWnd.GetNumber( REGVAL_WINDOW_HEIGHT, 0);
	pRect->right = pRect->left + cx;
	pRect->bottom = pRect->top + cy;

	int	iTop = pRect->top;
	int iLeft = pRect->left;
	int iBottom = pRect->bottom;
	int iRight = pRect->right;

	//
	// If it was an empty rect
	//
	if( !(pRect->bottom || pRect->top || pRect->left || pRect->right) )
	{
		MINMAXINFO lpmmi;
		g_pMain->OnGetMinMaxInfo(&lpmmi);
		iTop = 0;
		iLeft = 0;
		iBottom = lpmmi.ptMinTrackSize.y;
		iRight = lpmmi.ptMinTrackSize.x;
	}
		
	// Make sure that the window rectangle is (at least partially) on
	// screen, and not too large.  First get the screen size
	int screenWidth  = ::GetSystemMetrics(SM_CXSCREEN);
	int screenHeight = ::GetSystemMetrics(SM_CYSCREEN);
   // Check the window size
	if ((iRight - iLeft) > screenWidth)
	{
		iRight = iLeft + screenWidth;
	}
	
	if ((iBottom - iTop) > screenHeight)
	{
		iTop = screenHeight;
	}

	// Check the window position
	if (iLeft >= screenWidth)
	{
		// Off screen to the right - keep the width the same
		iLeft  = screenWidth - (iRight - iLeft);
		iRight = screenWidth;
	}

	if (iRight < 0)
	{
		// Off screen to the left - keep the width the same
		iRight = iRight - iLeft;
		iLeft  = 0;
	}

	if (iTop >= screenHeight)
	{
		// Off screen to the bottom - keep the height the same
		iTop    = screenHeight - (iBottom - iTop);
		iBottom = screenHeight;
	}

    if (iBottom < 0)
	{
		// Off screen to the top - keep the height the same
		iBottom = (iBottom - iTop);
		iTop    = 0;
	}

	pRect->left = iLeft;
	pRect->top = iTop;
	pRect->right = iRight;
	pRect->bottom = iBottom;
}
	

//
//
// Function: GetDataOption
//
// Purpose:  Retrieve a named option from the dictionary and parse it as
//           an ASCII representation of a string of hex bytes.
//
//
int OPT_GetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbResult
)
{
    TCHAR cstrValue[MAX_OPTIONS_LINE_LENGTH];
    BYTE* pbSaveResult = pbResult;

    // Lookup the option
    OPT_GetStringOption(cstrOptionName, cstrValue,MAX_OPTIONS_LINE_LENGTH);
    if (lstrlen(cstrValue))
    {
        // Calculate the maximum number of characters to convert
        int iMaxChars = min(2 * iBufferLength, lstrlen(cstrValue));

        // Option found, convert the string to hex bytes
        for (int iIndex = 0; iIndex < iMaxChars; iIndex += 2)
        {
            BYTE bByteHigh = 0;
            BYTE bByteLow  = 0;

            if (   (HexDigitToByte(cstrValue[iIndex], bByteHigh) == FALSE)
                || (HexDigitToByte(cstrValue[iIndex + 1], bByteLow) == FALSE))
            {
                // The character was not a valid hex digit
                break;
            }

            // Build the result byte
            *pbResult++ = (BYTE) ((bByteHigh << 4) | bByteLow);
        }
    }

    // Return the length of data in the buffer
    return (int)(pbResult - pbSaveResult);
}



//
//
// Function: SetStringOption
//
// Purpose:  Set the value of an option in the dictionary.
//

//
BOOL OPT_SetStringOption
(
    LPCSTR      cstrOptionName,
    LPCSTR      cstrValue
)
{
    BOOL        fSuccess = FALSE;
	HKEY	    write_hkey = NULL;
	DWORD       disposition;

    // open or create the key
	if (RegCreateKeyEx( HKEY_CURRENT_USER,
						NEW_WHITEBOARD_KEY,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&write_hkey,
						&disposition) != ERROR_SUCCESS)
    {
        WARNING_OUT(("Could not write key"));
        goto bail_out;
    }

    // got data, write the value
    if (RegSetValueEx( write_hkey,
                       cstrOptionName,
					   0,
					   REG_SZ,
					   (LPBYTE)cstrValue,
                       _tcsclen(cstrValue) + sizeof(TCHAR)) != ERROR_SUCCESS )
    {
        WARNING_OUT(("Could not write key value"));
        goto bail_out;
    }

    fSuccess = TRUE;

bail_out:
	if (write_hkey != NULL)
		RegCloseKey(write_hkey);

    return(fSuccess);
}



//
//
// Function: SetIntegerOption
//
// Purpose:  Write an integer option
//
//
BOOL OPT_SetIntegerOption
(
    LPCSTR      cstrOptionName,
    LONG        lValue
)
{
    char cBuffer[20];

    // Convert the integer value to ASCII decimal
    wsprintf(cBuffer, "%ld", lValue);

	// Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}


//
//
// Function: SetBooleanOption
//
// Purpose:  Write a boolean option
//
//
BOOL OPT_SetBooleanOption
(
    LPCSTR      cstrOptionName,
    BOOL        bValue
)
{
    char        cBuffer[8];

    wsprintf(cBuffer, "%c", (bValue ? 'Y' : 'N'));

    // Write the option
	return OPT_SetStringOption(cstrOptionName, cBuffer);
}



//
//
// Function: SetWindowRectOption
//
// Purpose:  Write a window position rectangle
//
//
void OPT_SetWindowRectOption(LPCRECT pcRect)
{
	RegEntry reWnd( NEW_WHITEBOARD_KEY, HKEY_CURRENT_USER );
	reWnd.SetValue( REGVAL_WINDOW_XPOS, pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_YPOS, pcRect->top );
	reWnd.SetValue( REGVAL_WINDOW_WIDTH, pcRect->right - pcRect->left );
	reWnd.SetValue( REGVAL_WINDOW_HEIGHT, pcRect->bottom - pcRect->top );
}

//
//
// Function: SetDataOption
//
// Purpose:  Write a data option to the options file
//
//
BOOL OPT_SetDataOption
(
    LPCSTR      cstrOptionName,
    int         iBufferLength,
    BYTE*       pbBuffer
)
{
    char        cBuffer[1024];
    LPSTR       cTmp;

    ASSERT(iBufferLength*2 < sizeof(cBuffer));

    // Loop through the data array converting a byte at a time
    cTmp = cBuffer;
    for (int iIndex = 0; iIndex < iBufferLength; iIndex++)
    {
        // Convert the next byte to ASCII hex
        wsprintf(cTmp, "%02x", pbBuffer[iIndex]);

        // add it to the string to be written
        cTmp += lstrlen(cTmp);
    }

    // Write the option
    return OPT_SetStringOption(cstrOptionName, cBuffer);
}





//
//
// Function:    CreateSystemPalette
//
// Purpose:     Get a palette representing the system palette
//
//
HPALETTE CreateSystemPalette(void)
{
    LPLOGPALETTE    lpLogPal;
    HDC             hdc;
    HPALETTE        hPal = NULL;
    int             nColors;

    MLZ_EntryOut(ZONE_FUNCTION, "CreateSystemPalette");

    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);

    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

    nColors = ::GetDeviceCaps(hdc, SIZEPALETTE);

    ::DeleteDC(hdc);

    if (nColors == 0)
    {
        TRACE_MSG(("CreateSystemPalette: device has no palette"));
        return(NULL);
    }

    // Allocate room for the palette and lock it.
    lpLogPal = (LPLOGPALETTE)::GlobalAlloc(GPTR, sizeof(LOGPALETTE) +
                                    nColors * sizeof(PALETTEENTRY));

    if (lpLogPal != NULL)
    {
        lpLogPal->palVersion    = PALVERSION;
        lpLogPal->palNumEntries = (WORD) nColors;

        for (int iIndex = 0;  iIndex < nColors;  iIndex++)
        {
            lpLogPal->palPalEntry[iIndex].peBlue  = 0;
            *((LPWORD) (&lpLogPal->palPalEntry[iIndex].peRed)) = (WORD) iIndex;
            lpLogPal->palPalEntry[iIndex].peFlags = PC_EXPLICIT;
        }

        hPal = ::CreatePalette(lpLogPal);

        // Free the logical palette structure
        ::GlobalFree((HGLOBAL)lpLogPal);
    }

    return(hPal);
}


//
//
// Function:    CreateColorPalette
//
// Purpose:     Get a 256-color palette
//
//
HPALETTE CreateColorPalette(void)
{
    HDC hdc;
    HPALETTE hPal = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "CreateColorPalette");

	// Find out how many colors are reserved
    hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
    if (!hdc)
    {
        ERROR_OUT(("Couldn't create DISPLAY IC"));
        return(NULL);
    }

	UINT uiSystemUse  = ::GetSystemPaletteUse(hdc);

    // Get the number of static colors
    int  iCountStatic = 20;
    int  iHalfCountStatic = 10;
	if (uiSystemUse == SYSPAL_NOSTATIC)
	{
        iCountStatic = 2;
        iHalfCountStatic = 1;
    }

	LOGPALETTE_NM gIndeoPalette = gcLogPaletteIndeo;

    // put system colors in correct lower and upper pal entries (bug NM4db:817)
    ::GetSystemPaletteEntries(hdc,
							  0,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[0]) );

    ::GetSystemPaletteEntries(hdc,
							  MAXPALETTE - iHalfCountStatic,
							  iHalfCountStatic,
							  &(gIndeoPalette.aEntries[MAXPALETTE - iHalfCountStatic]) );

    // Create the windows object for this palette
    // from the logical palette
    hPal = CreatePalette( (LOGPALETTE *)&gIndeoPalette );

	// Delete the display DC
	::DeleteDC(hdc);

	return(hPal);
}





//
//
// Function:    FromScreenAreaBmp
//
// Purpose:     Create a bitmap from an area of the screen
//
//
HBITMAP FromScreenAreaBmp(LPCRECT lprect)
{
    RECT    rcScreen;
    HBITMAP hBitMap = NULL;

    //
    // Get screen boundaries, in a way that works for single and multiple
    // monitor scenarios.
    //
    if (rcScreen.right = ::GetSystemMetrics(SM_CXVIRTUALSCREEN))
    {
        //
        // This is Win98, NT 4.0 SP-3, or NT5
        //
        rcScreen.bottom  = ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
        rcScreen.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
        rcScreen.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
    }
    else
    {
        //
        // The VIRTUALSCREEN size metrics are zero on older platforms
        // which don't support them.
        //
        rcScreen.right  = ::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = ::GetSystemMetrics(SM_CYSCREEN);
        rcScreen.left   = 0;
        rcScreen.top    = 0;
    }

    rcScreen.right += rcScreen.left;
    rcScreen.bottom += rcScreen.top;

    //
    // Clip bitmap rectangle to the screen.
    //
    if (IntersectRect(&rcScreen, &rcScreen, lprect))
    {
        // Create a DC for the screen and create
        // a memory DC compatible to screen DC
        HDC hdisplayDC;
        hdisplayDC = ::CreateDC("DISPLAY", NULL, NULL, NULL);

        HDC hmemDC;
        hmemDC = ::CreateCompatibleDC(hdisplayDC);

        // Create a bitmap compatible with the screen DC
        hBitMap =  ::CreateCompatibleBitmap(hdisplayDC,
            rcScreen.right - rcScreen.left,
            rcScreen.bottom - rcScreen.top);
        if (hBitMap != NULL)
        {
            // Select new bitmap into memory DC
            HBITMAP  hOldBitmap = SelectBitmap(hmemDC, hBitMap);

            // BitBlt screen DC to memory DC
            ::BitBlt(hmemDC, 0, 0, rcScreen.right - rcScreen.left,
                rcScreen.bottom - rcScreen.top, hdisplayDC,
                rcScreen.left, rcScreen.top, SRCCOPY);

            // Select old bitmap back into memory DC and get handle to
            // bitmap of the screen
            SelectBitmap(hmemDC, hOldBitmap);
        }

        ::DeleteDC(hmemDC);

        ::DeleteDC(hdisplayDC);
    }

    // return handle to the bitmap
    return hBitMap;
}





// Macro to round off the given value to the closest byte
#define WIDTHBYTES(i)   (((i+31)/32)*4)


//
//
// Function:    DIB_NumberOfColors
//
// Purpose:     Calculates the number of colours in the DIB
//
//
UINT DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi)
{
    UINT                numColors;
    int                 bits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_NumberOfColors");

    ASSERT(lpbi != NULL);

    //  With the BITMAPINFO format headers, the size of the palette
    //  is in biClrUsed, whereas in the BITMAPCORE - style headers, it
    //  is dependent on the bits per pixel ( = 2 raised to the power of
    //  bits/pixel).
    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        // Old DIB format, some apps still put this on the clipboard
        numColors = 0;
        bits = ((LPBITMAPCOREHEADER)lpbi)->bcBitCount;
    }
    else
    {
        numColors = lpbi->biClrUsed;
        bits = lpbi->biBitCount;
    }

    if ((numColors == 0) && (bits <= 8))
    {
        numColors = (1 << bits);
    }

    return numColors;
}


//
//
// Function:    DIB_PaletteLength
//
// Purpose:     Calculates the palette size in bytes
//
//
UINT DIB_PaletteLength(LPBITMAPINFOHEADER lpbi)
{
    UINT size;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_PaletteLength");

    if (lpbi->biSize == sizeof(BITMAPCOREHEADER))
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBTRIPLE);
    }
    else
    {
        size = DIB_NumberOfColors(lpbi) * sizeof(RGBQUAD);
    }

    TRACE_MSG(("Palette length %d", size));
    return(size);
}

//
//
// Function:    DIB_DataLength
//
// Purpose:     Return the length of the DIB data (after the header and the
//              color table.
//
//
UINT DIB_DataLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_DataLength");

    ASSERT(lpbi);

    UINT dwLength = 0;

    // If the image is not compressed, calculate the length of the data
    if (lpbi->biCompression == BI_RGB)
    {
        // Image is not compressed, the size can be given as zero in the header

        // Calculate the width in bytes of the image
        DWORD dwByteWidth = ( ((DWORD) lpbi->biWidth) * (DWORD) lpbi->biBitCount);
        TRACE_MSG(("Data byte width is %ld",dwByteWidth));

        // Round the width to a multiple of 4 bytes
        dwByteWidth = WIDTHBYTES(dwByteWidth);
        TRACE_MSG(("Rounded up to %ld",dwByteWidth));

        dwLength = (dwByteWidth * ((DWORD) lpbi->biHeight));
    }
    else
    {
        // Image is compressed, the length should be correct in the header
        dwLength = lpbi->biSizeImage;
    }

    TRACE_MSG(("Total data length is %d",dwLength));

    return(dwLength);
}


//
//
// Function:    DIB_TotalLength
//
// Purpose:     Return the total length of the DIB (header + colors + data).
//
//
UINT DIB_TotalLength(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_TotalLength");

    ASSERT(lpbi);

    // Header + Palette + Bits
    return(lpbi->biSize + DIB_PaletteLength(lpbi) + DIB_DataLength(lpbi));
}


//
//
// Function:    DIB_CreatePalette
//
// Purpose:     Create a palette object from the bitmap info color table
//
//
HPALETTE DIB_CreatePalette(LPBITMAPINFOHEADER lpbi)
{
    LOGPALETTE    *pPal;
    HPALETTE      hpal = NULL;
    WORD          nNumColors;
    BYTE          red;
    BYTE          green;
    BYTE          blue;
    WORD          i;
    RGBQUAD FAR * pRgb;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_CreatePalette");

    if (!lpbi)
        return NULL;

    if (lpbi->biSize != sizeof(BITMAPINFOHEADER))
        return NULL;

    // Get a pointer to the color table and the number of colors in it
    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi->biSize);
    nNumColors = (WORD)DIB_NumberOfColors(lpbi);

    if (nNumColors)
    {
        TRACE_MSG(("There are %d colors in the palette",nNumColors));

        // Allocate for the logical palette structure
        pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR, sizeof(LOGPALETTE)
                                    + (nNumColors * sizeof(PALETTEENTRY)));
        if (!pPal)
        {
            ERROR_OUT(("Couldn't allocate palette memory"));
            return(NULL);
        }

        pPal->palNumEntries = nNumColors;
        pPal->palVersion    = PALVERSION;

        // Fill in the palette entries from the DIB color table and
        // create a logical color palette.
        for (i = 0; i < nNumColors; i++)
        {
            pPal->palPalEntry[i].peRed   = pRgb[i].rgbRed;
            pPal->palPalEntry[i].peGreen = pRgb[i].rgbGreen;
            pPal->palPalEntry[i].peBlue  = pRgb[i].rgbBlue;
            pPal->palPalEntry[i].peFlags = (BYTE)0;
        }

        hpal = ::CreatePalette(pPal);

        ::GlobalFree((HGLOBAL)pPal);
    }
    else
    {
        if (lpbi->biBitCount == 24)
        {
            // A 24 bitcount DIB has no color table entries so, set the number
            // of to the maximum value (256).
            nNumColors = MAXPALETTE;

            pPal = (LOGPALETTE*) ::GlobalAlloc(GPTR,  sizeof(LOGPALETTE)
                    + (nNumColors * sizeof(PALETTEENTRY)));
            if (!pPal)
            {
                ERROR_OUT(("Couldn't allocate palette memory"));
                return NULL;
            }

            pPal->palNumEntries = nNumColors;
            pPal->palVersion    = PALVERSION;

            red = green = blue = 0;

            // Generate 256 (= 8*8*4) RGB combinations to fill the palette
            // entries.

            for (i = 0; i < pPal->palNumEntries; i++)
            {
                pPal->palPalEntry[i].peRed   = red;
                pPal->palPalEntry[i].peGreen = green;
                pPal->palPalEntry[i].peBlue  = blue;
                pPal->palPalEntry[i].peFlags = (BYTE) 0;

                if (!(red += 32))
                    if (!(green += 32))
                        blue += 64;
            }

            hpal = ::CreatePalette(pPal);
            ::GlobalFree((HGLOBAL)pPal);
        }
    }

    return hpal;
}


//
//
// Function:    DIB_Bits
//
// Purpose:     Return a pointer to the bitmap bits data (from a pointer
//              to the bitmap info header).
//
//
LPSTR DIB_Bits(LPBITMAPINFOHEADER lpbi)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Bits");
    ASSERT(lpbi);

    return ((LPSTR) (((char *) lpbi)
                   + lpbi->biSize
                   + DIB_PaletteLength(lpbi)));
}



//
//
// Function:    DIB_FromScreenArea
//
// Purpose:     Create a DIB from an area of the screen
//
//
LPBITMAPINFOHEADER DIB_FromScreenArea(LPCRECT lprect)
{
    HBITMAP     hBitmap     = NULL;
    HPALETTE    hPalette    = NULL;
    LPBITMAPINFOHEADER lpbi = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromScreenArea");

    //  Get the device-dependent bitmap from the screen area
    hBitmap = FromScreenAreaBmp(lprect);
    if (hBitmap != NULL)
    {
        // Get the current system palette
        hPalette = CreateSystemPalette();
        lpbi = DIB_FromBitmap(hBitmap, hPalette, FALSE, FALSE);
    }

    if (hPalette != NULL)
        ::DeletePalette(hPalette);

    if (hBitmap != NULL)
        ::DeleteBitmap(hBitmap);

    return(lpbi);
}


//
//
// Function:    DIB_Copy
//
// Purpose:     Make a copy of the DIB memory
//
//
LPBITMAPINFOHEADER DIB_Copy(LPBITMAPINFOHEADER lpbi)
{
    LPBITMAPINFOHEADER  lpbiNew = NULL;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_Copy");

    ASSERT(lpbi);

    // Get the length of memory
    DWORD dwLen = DIB_TotalLength(lpbi);

    lpbiNew = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
    if (lpbiNew != NULL)
    {
        // Copy the data
        memcpy(lpbiNew, lpbi, dwLen);
    }

    return(lpbiNew);
}

//
//
// Function:    DIB_FromBitmap
//
// Purpose:     Creates a DIB from a bitmap and palette
//
//
LPBITMAPINFOHEADER DIB_FromBitmap
(
    HBITMAP     hBitmap,
    HPALETTE    hPalette,
    BOOL        fGHandle,
    BOOL		fTopBottom,
    BOOL		fForce8Bits
)
{
    LPBITMAPINFOHEADER  lpbi = NULL;
    HGLOBAL             hmem = NULL;
    BITMAP              bm;
    BITMAPINFOHEADER    bi;
    DWORD               dwLen;
    WORD                biBits;

    MLZ_EntryOut(ZONE_FUNCTION, "DIB_FromBitmap");

    // If the bitmap handle given is null, do nothing
    if (hBitmap != NULL)
    {
        if (hPalette == NULL)
            hPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);

        // Get the bitmap information
        ::GetObject(hBitmap, sizeof(bm), (LPSTR) &bm);
		if(!fForce8Bits)
		{

	        biBits =  (WORD) (bm.bmPlanes * bm.bmBitsPixel);

    	    if (biBits > 8)
        	{
				if(g_pNMWBOBJ->CanDo24BitBitmaps())
				{
					biBits = 24;
				}
				else
				{
		            // If > 8, The maximum T126 supports is 8
		            biBits = 8;
		        }
	        }
	    }
	    else
	    {
	    	biBits = 8;
	    }

        bi.biSize               = sizeof(BITMAPINFOHEADER);
        bi.biWidth              = bm.bmWidth;
        bi.biHeight             = fTopBottom ? 0 - bm.bmHeight : bm.bmHeight;
        bi.biPlanes             = 1;
        bi.biBitCount           = biBits;
        bi.biCompression        = 0;
        bi.biSizeImage          = 0;
        bi.biXPelsPerMeter      = 0;
        bi.biYPelsPerMeter      = 0;
        bi.biClrUsed            = 0;
        bi.biClrImportant       = 0;

        dwLen  = bi.biSize + DIB_PaletteLength(&bi);

        HDC         hdc;
        HPALETTE    hPalOld;

        hdc = ::CreateDC("DISPLAY", NULL, NULL, NULL);
        hPalOld = ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);

        // Allocate memory for the DIB
        if (fGHandle)
        {
            // For the clipboard, we MUST use GHND
            hmem = ::GlobalAlloc(GHND, dwLen);
            lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
        }
        else
        {
            lpbi = (LPBITMAPINFOHEADER)::GlobalAlloc(GPTR, dwLen);
        }

        if (lpbi != NULL)
        {
            *lpbi = bi;

            // Call GetDIBits with a NULL lpBits param, so it will calculate the
            // biSizeImage field for us
            ::GetDIBits(hdc, hBitmap, 0, (WORD) bm.bmHeight, NULL,
                  (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

            bi = *lpbi;

            // If the driver did not fill in the biSizeImage field, make one up
            if (bi.biSizeImage == 0)
            {
                bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight;
            }

            // Realloc the buffer big enough to hold all the bits
            dwLen = bi.biSize + DIB_PaletteLength(&bi) + bi.biSizeImage;

            if (fGHandle)
            {
                HGLOBAL hT;

                ::GlobalUnlock(hmem);
                hT = ::GlobalReAlloc(hmem, dwLen, GHND);
                if (!hT)
                {
                    ERROR_OUT(("Can't reallocate DIB handle"));
                    ::GlobalFree(hmem);
                    hmem = NULL;
                    lpbi = NULL;
                }
                else
                {
                    hmem = hT;
                    lpbi = (LPBITMAPINFOHEADER)::GlobalLock(hmem);
                }
            }
            else
            {
                LPBITMAPINFOHEADER lpbiT;

                lpbiT = (LPBITMAPINFOHEADER)::GlobalReAlloc((HGLOBAL)lpbi, dwLen, GMEM_MOVEABLE);
                if (!lpbiT)
                {
                    ERROR_OUT(("Can't reallocate DIB ptr"));

                    ::GlobalFree((HGLOBAL)lpbi);
                    lpbi = NULL;
                }
                else
                {
                    lpbi = lpbiT;
                }
            }
        }

        if (lpbi != NULL)
        {
            ::GetDIBits(hdc, hBitmap, 0,
                    (WORD)bm.bmHeight,
                    DIB_Bits(lpbi),
                    (LPBITMAPINFO)lpbi,
                    DIB_RGB_COLORS);

            if (fGHandle)
            {
                // We want to return the HANDLE, not the POINTER
                ::GlobalUnlock(hmem);
                lpbi = (LPBITMAPINFOHEADER)hmem;
            }
        }

        // Restore the old palette and give back the device context
        ::SelectPalette(hdc, hPalOld, FALSE);
        ::DeleteDC(hdc);
    }

    return(lpbi);
}





//
// AbortProc()
// Process messages during printing
//
//
BOOL CALLBACK AbortProc(HDC, int)
{
    MSG msg;

    ASSERT(g_pPrinter);

    // Message pump in case user wants to cancel printing
    while (!g_pPrinter->Aborted()
        && PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
    {
        if ( (g_pPrinter->m_hwndDialog == NULL) ||
            !::IsDialogMessage(g_pPrinter->m_hwndDialog, &msg))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return !g_pPrinter->Aborted();
}

//
//
// Function:    WbPrinter
//
// Purpose:     Constructor for a printer object
//
//
WbPrinter::WbPrinter(LPCTSTR szDeviceName)
{
    m_szDeviceName = szDeviceName;
    m_szPrintPageText[0] = 0;

    // Set up the global pointer for the abort procedure
    g_pPrinter = this;

    // Create the dialog window
    m_hwndDialog = ::CreateDialogParam(g_hInstance, MAKEINTRESOURCE(PRINTCANCEL),
        g_pMain->m_hwnd, CancelPrintDlgProc, 0);

    // Save the original text for the page number area
    ::GetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, m_szPrintPageText, _MAX_PATH);
}


//
//
// Function:    ~WbPrinter
//
// Purpose:     Destructor for a printer object
//
//
WbPrinter::~WbPrinter(void)
{
    // Kill off the dialog etc. if still around
    StopDialog();

    ASSERT(m_hwndDialog == NULL);

    g_pPrinter = NULL;
}


//
// StopDialog()
// If the dialog is up, ends it.
//
void WbPrinter::StopDialog(void)
{
    ::EnableWindow(g_pMain->m_hwnd, TRUE);

    // Close and destroy the dialog
    if (m_hwndDialog != NULL)
    {
        ::DestroyWindow(m_hwndDialog);
        m_hwndDialog = NULL;
    }

}

//
//
// Function:    StartDoc
//
// Purpose:     Tell the printer we are starting a new document
//
//
int WbPrinter::StartDoc
(
    HDC     hdc,
    LPCTSTR szJobName,
    int     nStartPage
)
{
    // Initialize the result codes and page number
    m_bAborted  = FALSE;         // Not aborted
    m_nPrintResult = 1;        // Greater than 0 implies all is well

    // Disable the main window
    ::EnableWindow(g_pMain->m_hwnd, FALSE);

    // Attach the printer DC
    SetPrintPageNumber(nStartPage);

    // Set up the abort routine for the print
    if (SetAbortProc(hdc, AbortProc) >= 0)
    {
        // Abort routine successfully set
        ::ShowWindow(m_hwndDialog, SW_SHOW);
        ::UpdateWindow(m_hwndDialog);

	    DOCINFO docinfo;

        docinfo.cbSize = sizeof(DOCINFO);
        docinfo.lpszDocName = szJobName;
        docinfo.lpszOutput = NULL;
        docinfo.lpszDatatype = NULL;   // Windows 95 only; ignored on Windows NT
        docinfo.fwType = 0;         // Windows 95 only; ignored on Windows NT

        // Initialize the document.
        m_nPrintResult = ::StartDoc(hdc, &docinfo);
    }

    return m_nPrintResult;
}

//
//
// Function:    StartPage
//
// Purpose:     Tell the printer we are starting a new page
//
//
int WbPrinter::StartPage(HDC hdc, int nPageNumber)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::StartPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        SetPrintPageNumber(nPageNumber);

        // Tell the printer of the new page number
        m_nPrintResult = ::StartPage(hdc);
    }

    return(m_nPrintResult);
}


//
//
// Function:    EndPage
//
// Purpose:     Tell the printer we are finishing a page
//
//
int WbPrinter::EndPage(HDC hdc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbPrinter::EndPage");

    m_nPrintResult = -1;  // Initialise to error

    // If the print has been aborted, return an error.
    if (m_bAborted)
    {
        TRACE_DEBUG(("Print has been aborted"));
    }
    else
    {
        // Tell the printer of the new page number
        m_nPrintResult = ::EndPage(hdc);
    }

    return(m_nPrintResult);
}

//
//
// Function:    EndDoc
//
// Purpose:     Tell the printer we have completed a document
//
//
int WbPrinter::EndDoc(HDC hdc)
{
    // If an error has occurred the driver will already have aborted the print
    if (m_nPrintResult > 0)
    {
        if (!m_bAborted)
        {
            // If we have not been aborted, and no error has occurred
            //   end the document
            m_nPrintResult = ::EndDoc(hdc);
        }
        else
        {
            m_nPrintResult = ::AbortDoc(hdc);
        }
    }

    StopDialog();

    // Return an the error indicator
    return m_nPrintResult;
}

//
//
// Function:    AbortDoc
//
// Purpose:     Abort the document currently in progress
//
//
int WbPrinter::AbortDoc()
{
    // Show that we have been aborted, the actual abort is
    // done by the EndDoc call.
    m_bAborted = TRUE;

    //
    // Renable the application window.
    //
    StopDialog();

    // Return a positive value indicating "aborted OK"
    return 1;
}


//
//
// Function:    SetPrintPageNumber
//
// Purpose:     Set the number of the page currently being printed
//
//
void WbPrinter::SetPrintPageNumber(int nPageNumber)
{
	// Display the number of the page currently being printed
	TCHAR szPageNumber [10 + _MAX_PATH];

    wsprintf(szPageNumber, m_szPrintPageText, nPageNumber);
    ::SetDlgItemText(m_hwndDialog, IDD_PRINT_PAGE, szPageNumber);
}


//
// CancelPrintDlgProc()
// Dialog message handler for the cancel printing dialog
//
INT_PTR CALLBACK CancelPrintDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ASSERT(g_pPrinter != NULL);
            ::SetDlgItemText(hwnd, IDD_DEVICE_NAME, g_pPrinter->m_szDeviceName);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ASSERT(g_pPrinter != NULL);
                            g_pPrinter->AbortDoc();
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
// Bogus Bogus LAURABU
// STRING ARRAY (TEMP!)
//

StrArray::StrArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = 0;
}

StrArray::~StrArray()
{
    ClearOut();
}


void StrArray::ClearOut(void)
{
    int iItem;

    for (iItem = 0; iItem < m_nSize; iItem++)
    {
        if (m_pData[iItem] != NULL)
        {
            delete (LPTSTR)m_pData[iItem];
            m_pData[iItem] = NULL;
        }
    }

    m_nSize = 0;
    m_nMaxSize = 0;

    if (m_pData != NULL)
    {
        delete[] m_pData;
        m_pData = NULL;
    }

}


void StrArray::SetSize(int nNewSize)
{
	if (nNewSize == 0)
	{
		// shrink to nothing
        ClearOut();
	}
    else if (nNewSize <= m_nMaxSize)
    {
        // No shrinking allowed.
        ASSERT(nNewSize >= m_nSize);

        // We're still within the alloced block range
        m_nSize = nNewSize;
    }
	else
	{
        //
		// Make a larger array (isn't this lovely if you already have an
        // array, we alloc a new one and free the old one)
        //
		int nNewMax;

        nNewMax = (nNewSize + (ALLOC_CHUNK -1)) & ~(ALLOC_CHUNK-1);
		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around

		DBG_SAVE_FILE_LINE
		LPCTSTR* pNewData = new LPCTSTR[nNewMax];
        if (!pNewData)
        {
            ERROR_OUT(("StrArray::SetSize failed, couldn't allocate larger array"));
        }
        else
        {
            // Zero out the memory
            ZeroMemory(pNewData, nNewMax * sizeof(LPCTSTR));

            // If an old array exists, copy the existing string ptrs.
            if (m_pData != NULL)
            {
                CopyMemory(pNewData, m_pData, m_nSize * sizeof(LPCTSTR));

                //
                // Delete the old array, but not the strings inside, we're
                // keeping them around in the new array
                //
                delete[] m_pData;
            }

    		m_pData = pNewData;
	    	m_nSize = nNewSize;
		    m_nMaxSize = nNewMax;
        }
	}
}


void StrArray::SetAtGrow(int nIndex, LPCTSTR newElement)
{
	ASSERT(nIndex >= 0);

	if (nIndex >= m_nSize)
		SetSize(nIndex+1);

    SetAt(nIndex, newElement);
}


LPCTSTR StrArray::operator[](int nIndex) const
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < m_nSize);
    return(m_pData[nIndex]);
}


void StrArray::SetAt(int nIndex, LPCTSTR newElement)
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < m_nSize);

	DBG_SAVE_FILE_LINE
    m_pData[nIndex] = new TCHAR[lstrlen(newElement) + 1];
    lstrcpy((LPTSTR)m_pData[nIndex], newElement);
}


void StrArray::Add(LPCTSTR newElement)
{
	SetAtGrow(m_nSize, newElement);
}


//
//char *StrTok(string, control) - tokenize string with delimiter in control
//
char *  StrTok (char * string, char * control)
{
        char *str;
        char *ctrl = control;

        unsigned char map[32];
        int count;

        static char *nextoken;

        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. If string is NULL, set str to the saved
         * pointer (i.e., continue breaking tokens out of the string
         * from the last StrTok call) */
        if (string)
                str = string;
        else
                str = nextoken;

        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token iff this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
                str++;

        string = str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
                if ( map[*str >> 3] & (1 << (*str & 7)) ) {
                        *str++ = '\0';
                        break;
                }

        /* Update nextoken (or the corresponding field in the per-thread data
         * structure */
        nextoken = str;

        /* Determine if a token has been found. */
        if ( string == str )
                return NULL;
        else
                return string;
}


StrCspn(char * string, char * control)
{
        unsigned char *str = (unsigned char *)string;
        unsigned char *ctrl = (unsigned char *)control;

        unsigned char map[32];
        int count;

        /* Clear out bit map */
        for (count=0; count<32; count++)
                map[count] = 0;

        /* Set bits in control map */
        while (*ctrl)
        {
                map[*ctrl >> 3] |= (1 << (*ctrl & 7));
                ctrl++;
        }
		count=0;
        map[0] |= 1;    /* null chars not considered */
        while (!(map[*str >> 3] & (1 << (*str & 7))))
        {
                count++;
                str++;
        }
        return(count);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\ccl32.hpp ===
//
// CCL32.HPP
// Common Control Classes
//
// Copyright Microsoft 1998-
//

#ifndef CCL32_HPP
#define CCL32_HPP


#define HLP_MENU_ITEM_OFFSET	0x10000

	
#define HLP_BASE				600
enum
{
    IDH_CONTENTS = HLP_BASE + 1,
    IDH_SEARCH,
    IDH_ABOUT,
    IDH_HELPHELP,
    HLP_PROCESSED
};



#define HELPID_WBSAVEASDLG      4070
#define HELPID_WBFILEMENU       4140
#define HELPID_WBEDITMENU       4150
#define HELPID_WBVIEWMENU       4160
#define HELPID_WBTOOLSMENU      4170
#define HELPID_WBHELPMENU       4190
#define HELPID_WBWIDTHMENU      4210
#define HELPID_WBSYSTEMMENU     4300


//
// IMM32 stuff
//
typedef HIMC (WINAPI * IGC_PROC)(HWND);
typedef BOOL (WINAPI * INI_PROC)(HIMC, DWORD, DWORD, DWORD);

extern void  UT_CaptureMouse( HWND   hwnd );
extern void  UT_ReleaseMouse( HWND  hwnd );



//
// Option entry names
//

#define OPT_MAIN_STATUSBARVISIBLE       "StatusBarVisible"
#define OPT_MAIN_TOOLBARVISIBLE         "ToolBarVisible"
#define OPT_MAIN_MAXIMIZED              "Maximized"
#define OPT_MAIN_MINIMIZED              "Minimized"
#define OPT_MAIN_MAINWINDOWRECT         "MainWindowPosition"
#define OPT_MAIN_SELECTWINDOW_NOTAGAIN  "GrabWindow_dontwarn"
#define OPT_MAIN_SELECTAREA_NOTAGAIN    "GrabArea_dontwarn"
#define OPT_MAIN_COLORPALETTE		    "ColorPalette"
#define OPT_MAIN_CUSTOMCOLORS		    "CustomColors"

#define DFLT_MAIN_STATUSBARVISIBLE      TRUE
#define DFLT_MAIN_TOOLBARVISIBLE        TRUE
#define DFLT_MAIN_MAXIMIZED             FALSE			
#define DFLT_MAIN_MINIMIZED             FALSE			
#define DFLT_MAIN_SELECTWINDOW_NOTAGAIN FALSE			
#define DFLT_MAIN_SELECTAREA_NOTAGAIN   FALSE			



//
// Settings routines
//

//
// GetIntegerOption retrieves and converts an option string to a long.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
LONG OPT_GetIntegerOption(LPCSTR cstrOptionName,
                          LONG lDefault = 0L);

//
// GetBooleanOption retrieves and converts an option string to a boolean
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_GetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bDefault = FALSE);

//
// GetStringOption  retrieves a string option (no conversion).
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetStringOption(LPCSTR cstrOptionName,
                            LPSTR pcDefault,
                            UINT size);

//
// GetDataOption    retrieves an option string and parses it into an
//                  array of hex bytes.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
int OPT_GetDataOption(LPCSTR optionName,
                      int   iBufferLength,
                      BYTE* pbBuffer);

//
// GetWindowRectOption  retrieves a option string and parses it into a
//                      rectangle representing the corners of the
//                  window.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
void OPT_GetWindowRectOption(LPRECT lprc);

//
// SetStringOption  writes a string option (no conversion).
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetStringOption(LPCSTR cstrOptionName,
                         LPCSTR cstrValue);

//
// SetBooleanOption writes a boolean option
//                  Returns TRUE if the option was successfully written.
//
BOOL OPT_SetBooleanOption(LPCSTR cstrOptionName,
                          BOOL  bValue);

//
// SetIntegerOption write an integer option
//                  Returns TRUE if the option was successfully written.
	
//
BOOL OPT_SetIntegerOption(LPCSTR cstrOptionName,
                          LONG  lValue);

//
// SetWindowRectOption  write a window rectangle option.
//                  Returns TRUE if the option was successfully written.
//
void OPT_SetWindowRectOption(LPCRECT lpwindowRect);

//
// SetDataOption    writes a data option.
//                  If the specified option cannot be found, or cannot
//                  be read, the default value specified as the last
//                  parameter is returned.
//
BOOL OPT_SetDataOption(LPCSTR optionName,
                       int   iBufferLength,
                       BYTE* pbBuffer);

BOOL OPT_Lookup(LPCSTR cstrOptionName,
                          LPCSTR cstrResult,
                          UINT size);




//
//
// Class:   WbPrinter
//
// Purpose: Printer class including cancellation dialog
//
//
class WbPrinter
{
public:
    //
    // Constructor
    //
    // The parameter specifies the printer to be used. Under Windows this
    // value can be obtained from the Common Print Dialog.
    //
    WbPrinter(LPCTSTR szDeviceName);
    ~WbPrinter(void);

    void    SetPrintPageNumber(int nPageNumber);

    // Return TRUE if an error has occurred
    BOOL    Error(void)       { return (m_bAborted || (m_nPrintResult < 0)); };

    // Return TRUE if the user has aborted the print
    BOOL    Aborted(void)     { return m_bAborted; };

    // Return the last result code from a print function call
    int     PrintResult(void) { return m_nPrintResult; };

    //
    // Document manipulation functions
    //

    // Start a new print job
    int StartDoc(HDC hdc, LPCTSTR cstrDocName, int nStartPage);

    // Start a new page
    int StartPage(HDC hdc, int nPageNumber);

    // Indicate that the page is now complete
    int EndPage(HDC hdc);

    // Indicate that the document is complete
    int EndDoc(HDC hdc);

    // Abort the print job
    int AbortDoc(void);

protected:
    HWND    m_hwndDialog;

    //
    // Device and port name for this printer
    //
    LPCTSTR m_szDeviceName;
    TCHAR   m_szPrintPageText[_MAX_PATH];

    //
    // Internal state variables
    //
    int     m_nPrintResult;
    BOOL    m_bAborted;

    void    StopDialog(void);

    //
    // Friend callback routine
    //
    friend BOOL CALLBACK AbortProc(HDC, int);
    friend INT_PTR CALLBACK CancelPrintDlgProc(HWND, UINT, WPARAM, LPARAM);
};




//
// Defines for palettes
//
#define PALVERSION  0x300
#define MAXPALETTE  256

HPALETTE CreateSystemPalette(void);
HPALETTE CreateColorPalette(void);


HBITMAP FromScreenAreaBmp(LPCRECT lprc);


UINT        DIB_NumberOfColors(LPBITMAPINFOHEADER lpbi);
UINT        DIB_PaletteLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_DataLength(LPBITMAPINFOHEADER lpbi);
UINT        DIB_TotalLength(LPBITMAPINFOHEADER lpbi);

HPALETTE    DIB_CreatePalette(LPBITMAPINFOHEADER lpbi);
LPSTR       DIB_Bits(LPBITMAPINFOHEADER lpbi);

LPBITMAPINFOHEADER  DIB_FromBitmap(HBITMAP hBitmap, HPALETTE hPalette, BOOL fGHandle, BOOL fTopBottom, BOOL fForce8Bits = FALSE);
LPBITMAPINFOHEADER  DIB_FromScreenArea(LPCRECT lprc);
LPBITMAPINFOHEADER  DIB_Copy(LPBITMAPINFOHEADER lpbi);



//
// Extra windows messages for the Whiteboard
//
enum
{
    WM_USER_GOTO_USER_POSITION  =   WM_USER,
    WM_USER_GOTO_USER_POINTER,
    WM_USER_JOIN_CALL,
    WM_USER_DISPLAY_ERROR,
    WM_USER_UPDATE_ATTRIBUTES,
    WM_USER_JOIN_PENDING_CALL,
    WM_USER_PRIVATE_PARENTNOTIFY,
    WM_USER_BRING_TO_FRONT_WINDOW,
    WM_USER_LOAD_FILE

};

//
// Internal error codes
//
#define WB_BASE_RC                     0x0300
#define WB_LAST_RC                     0x03FF

#define WBFE_RC_BASE       (WB_LAST_RC - 20)

enum
{
    WBFE_RC_WINDOWS = WBFE_RC_BASE,
    WBFE_RC_WB,
    WBFE_RC_JOIN_CALL_FAILED,
    WBFE_RC_CM,
    WBFE_RC_AL,
    WBFE_RC_PRINTER
};


enum
{
    WB_RC_NOT_LOCKED = WB_BASE_RC,
    WB_RC_LOCKED,
    WB_RC_BAD_FILE_FORMAT,
    WB_RC_BAD_STATE,
    WB_RC_WRITE_FAILED,
    WB_RC_BAD_PAGE_HANDLE,
    WB_RC_BAD_PAGE_NUMBER,
    WB_RC_CHANGED,
    WB_RC_NOT_CHANGED,
    WB_RC_NO_SUCH_PAGE,
    WB_RC_NO_SUCH_GRAPHIC,
    WB_RC_NO_SUCH_PERSON,
    WB_RC_TOO_MANY_PAGES,
    WB_RC_ALREADY_LOADING,
    WB_RC_BUSY,
    WB_RC_GRAPHIC_LOCKED,
    WB_RC_GRAPHIC_NOT_LOCKED,
    WB_RC_NOT_LOADING,
    WB_RC_CREATE_FAILED,
    WB_RC_READ_FAILED
};


//
// The following functions can be found in wwbapp.cpp
//

//
// Functions displaying a message box from the string resources specified
//
int Message(HWND hwndOwner,
            UINT uiCaption,
            UINT uiMessage,
            UINT uiStyle = (MB_OK | MB_ICONEXCLAMATION));

//
// Functions displaying a message box from return codes
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
// Default exception handler
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode);


//
//
// Class:   DCWbPointerColorMap
//
// Purpose: Map from pointer color to pointer structures
//
//
class DCWbColorToIconMap : public COBLIST
{

  public:
    //
    // Destructor
    //
    ~DCWbColorToIconMap(void);
};




//
// BOGUS LAURABU TEMP!
// StrArray
//

#define ALLOC_CHUNK     8

class StrArray
{
public:
	StrArray();
	~StrArray();

	int GetSize() const { return(m_nSize); }
	void SetSize(int nNewSize);

	// Clean up
	void RemoveAll() { SetSize(0); }
    void ClearOut();
	
	// Adding elements
	void SetAt(int nIndex, LPCTSTR newElement);
	void SetAtGrow(int nIndex, LPCTSTR newElement);
	void Add(LPCTSTR newElement);

	// overloaded operator helpers
	LPCTSTR operator[](int nIndex) const;

// Implementation
protected:

	LPCTSTR * m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
};

char *  StrTok (
        char * string,
        char * control
        );

StrCspn(char * string, char * control);

#endif // CCL32_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\coder.cpp ===
//
// CODER.CPP
// ASN1 t126 encoder/decoder
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

#include   "coder.hpp"

#ifdef __cplusplus
}
#endif /*__cplusplus*/





Coder::Coder()
{
	T126_InitModule();
	InitCoder();
}

Coder::~Coder(){

	EnterCriticalSection(&m_critSec);
	T126_TermCoder(&p_Coder);
	T126_TermModule();
	LeaveCriticalSection(&m_critSec);
	DeleteCriticalSection(&m_critSec);
}

int Coder::InitCoder()
{

    int	iError = 0;

	InitializeCriticalSection(&m_critSec);

    // Call TELES Library initialization routine
    EnterCriticalSection(&m_critSec);
    iError = T126_InitCoder(&p_Coder);
    LeaveCriticalSection(&m_critSec);

    return iError;
}

// ASN.1 Encode a T.126 PDU
// Take a T.126 structure and returns a T.126 PDU
//
int Coder::	Encode(SIPDU *pInputData, ASN1_BUF *pOutputOssBuf){
	int iError;

	// initialize encoding buffer structure values
	pOutputOssBuf->value = NULL;
	pOutputOssBuf->length = 0;

	// encode pdu
	EnterCriticalSection(&m_critSec);
    iError = T126_Encode(&p_Coder,
                       (void *)pInputData,
                       SIPDU_PDU,
                       pOutputOssBuf);
	LeaveCriticalSection(&m_critSec);
    return iError;
}


int Coder::Decode(ASN1_BUF *pInputOssBuf, SIPDU **pOutputData){
	int iError;

	// NULL tells decoder to malloc memory for SIPDU
	// user must free this memory by calling Coder::FreePDU()
	 *pOutputData = NULL;
	
	// decode the pdu
	EnterCriticalSection(&m_critSec);
    iError = T126_Decode(&p_Coder,
                       (void **)pOutputData,
                       SIPDU_PDU,
                       pInputOssBuf);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by decode
int Coder::Free(SIPDU *pData){
	int iError;

	EnterCriticalSection(&m_critSec);
	iError = freePDU(&p_Coder,SIPDU_PDU,pData, T126_Module);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by encode
void Coder::Free(ASN1_BUF Asn1Buf){
	EnterCriticalSection(&m_critSec);
	ASN1_FreeEncoded(p_Coder.pEncInfo,(void *)(Asn1Buf.value));
	LeaveCriticalSection(&m_critSec);
}



// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

extern "C" {

int T126_InitModule(void)
{
    T126_Module_Startup();
    return (T126_Module != NULL) ? ASN1_SUCCESS : ASN1_ERR_MEMORY;
}

int T126_TermModule(void)
{
    T126_Module_Cleanup();
    return ASN1_SUCCESS;
}

int T126_InitCoder(ASN1_CODER_INFO *pCoder)
{
    int rc;

    ZeroMemory(pCoder, sizeof(*pCoder));

    if (T126_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                T126_Module,           // ptr to mdule
                &(pCoder->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pCoder->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                T126_Module,           // ptr to mdule
                &(pCoder->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pCoder->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        T126_TermCoder(pCoder);
    }

    return rc;
}

int T126_TermCoder(ASN1_CODER_INFO *pCoder)
{
    if (T126_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pCoder->pEncInfo);
    ASN1_CloseDecoder(pCoder->pDecInfo);

    ZeroMemory(pCoder, sizeof(*pCoder));

    return ASN1_SUCCESS;
}

int T126_Encode(ASN1_CODER_INFO *pCoder, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pCoder->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                // buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
        ASSERT(FALSE);
    }
    return rc;
}

int T126_Decode(ASN1_CODER_INFO *pCoder, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pCoder->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
		ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\cgrp.hpp ===
//
// CGRP.HPP
// WbColorsGroup
//
// Copyright Microsoft 1998-
//

#ifndef CGRP_HPP
#define CGRP_HPP



#define NUMROWS			2
#define NUMCOLS			14
#define NUMCLRPANES		(NUMROWS*NUMCOLS + 1) // palette + current one
#define INDEX_CHOICE    (NUMCLRPANES-1)     // last one
#define NUMCUSTCOLORS	16

#define CLRPANE_HEIGHT	16
#define CLRPANE_WIDTH	CLRPANE_HEIGHT
#define CLRPANE_BLACK	RGB( 0,0,0 )
#define CLRPANE_WHITE	RGB( 255,255,255 )


#define CLRCHOICE_HEIGHT    (NUMROWS * CLRPANE_HEIGHT)
#define CLRCHOICE_WIDTH     CLRCHOICE_HEIGHT


//
// Colors window proc
//
class WbColorsGroup
{
public:
	WbColorsGroup();
	~WbColorsGroup();
	virtual BOOL Create(HWND hwndParent, LPCRECT lprect);
    void    GetNaturalSize(LPSIZE lpsize);

	void SaveSettings( void );

    COLORREF GetCurColor(void);
    void    SetCurColor(COLORREF clr);
	LRESULT    OnEditColors( void );

    HWND    m_hwnd;

    friend  LRESULT CALLBACK CGWndProc(HWND, UINT, WPARAM, LPARAM);

protected:
    void     OnPaint(void);
    void     OnLButtonDown(UINT nFlags, int x, int y);
    void     OnLButtonDblClk(UINT nFlags, int x, int y);

	int      m_nLastColor;
	COLORREF m_crColors[ NUMCLRPANES ];
	HBRUSH   m_hBrushes[ NUMCLRPANES ];
	COLORREF m_crCustomColors[ NUMCUSTCOLORS ];

	COLORREF GetColorOfBrush( int nColor );
	void     SetColorOfBrush( int nColor, COLORREF crNewColor );
    void     SetColorOfPane(int nColor, COLORREF clr);

	COLORREF DoColorDialog( int nColor );
	void     ClickOwner( void );
};



#endif // CGRP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\draw.cpp ===
//
// DRAW.CPP
// Main Drawing Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include "nmwbobj.h"

static const TCHAR szDrawClassName[] = "T126WB_DRAW";

//
//
// Function:    Constructor
//
// Purpose:     Initialize the drawing area object
//
//
WbDrawingArea::WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::WbDrawingArea");

    g_pDraw = this;

    m_hwnd = NULL;

    m_hDCWindow = NULL;
    m_hDCCached = NULL;

    m_originOffset.cx = 0;
    m_originOffset.cy = 0;

    m_posScroll.x     = 0;
    m_posScroll.y     = 0;

    // Show that the drawing area is not zoomed
    m_iZoomFactor = 1;
    m_iZoomOption = 1;

    // Show that the left mouse button is up
    m_bLButtonDown = FALSE;
    m_bIgnoreNextLClick = FALSE;
    m_bBusy = FALSE;
    m_bLocked = FALSE;
    m_HourGlass = FALSE;
    m_bSync = TRUE;

    // Indicate that the cached zoom scroll position is invalid
    m_zoomRestoreScroll = FALSE;

    // Show that we are not currently editing text
    m_bGotCaret = FALSE;
    m_bTextEditorActive = FALSE;
	m_pTextEditor = NULL;


    // Show that no graphic object is in progress
    m_pGraphicTracker = NULL;

    // Show that the marker is not present.
    m_bMarkerPresent = FALSE;
    m_bNewMarkedGraphic = FALSE;
    m_pSelectedGraphic = NULL;
    m_bTrackingSelectRect = FALSE;

    // Show that no area is currently marked
    ::SetRectEmpty(&m_rcMarkedArea);

    // Show we haven't got a tool yet
    m_pToolCur = NULL;

    // Show that we dont have a page attached yet
    g_pCurrentWorkspace = NULL;
	g_pConferenceWorkspace = NULL;


    // Create the brush to be used to draw the marker rectangle
    WORD    bits[] = {204, 204, 51, 51, 204, 204, 51, 51};
    HBITMAP hBmpMarker = ::CreateBitmap(8, 8, 1, 1, bits);
    m_hMarkerBrush = ::CreatePatternBrush(hBmpMarker);
    ::DeleteBitmap(hBmpMarker);

    DBG_SAVE_FILE_LINE
    m_pMarker = new DrawObj(rectangle_chosen, TOOLTYPE_SELECT);
    if(m_pMarker)
    {
	    m_pMarker->SetPenColor(RGB(0,0,0), TRUE);
        m_pMarker->SetFillColor(RGB(255,255,255), FALSE);
        m_pMarker->SetLineStyle(PS_DOT);
        m_pMarker->SetPenThickness(1);
	    
        RECT rect;
		::SetRectEmpty(&rect);
		m_pMarker->SetRect(&rect);
		m_pMarker->SetBoundsRect(&rect);
    }
}


//
//
// Function:    Destructor
//
// Purpose:     Close down the drawing area
//
//
WbDrawingArea::~WbDrawingArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::~WbDrawingArea");

    if (m_pTextEditor != NULL)
    {
	    m_pTextEditor->AbortEditGently();
    }

    if (m_pMarker != NULL)
    {
		delete m_pMarker;
		m_pMarker = NULL;
	}


    if (m_hMarkerBrush != NULL)
    {
        DeleteBrush(m_hMarkerBrush);
        m_hMarkerBrush = NULL;
    }


    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    ::UnregisterClass(szDrawClassName, g_hInstance);

	g_pDraw = NULL;

}

//
// WbDrawingArea::Create()
//
BOOL WbDrawingArea::Create(HWND hwndParent, LPCRECT lprect)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Create");

    // Get our cursor
    m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENFREEHANDCURSOR));

    //
    // Register the window class
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_OWNDC;
    wc.lpfnWndProc      = DrawWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = m_hCursor;
    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName    = szDrawClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbDraw::Create register class failed"));
        return(FALSE);
    }

    //
    // Create our window
    //
    ASSERT(m_hwnd == NULL);

    if (!::CreateWindowEx(WS_EX_CLIENTEDGE, szDrawClassName, NULL,
        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL | WS_BORDER |
        WS_CLIPCHILDREN,
        lprect->left, lprect->top, lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Error creating drawing area window"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);

    //
    // Initialize remaining data members
    //
    ASSERT(!m_bBusy);
    ASSERT(!(m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID));
    ASSERT(!m_HourGlass);

    // Start and end points of the last drawing operation
    m_ptStart.x = m_originOffset.cx;
    m_ptStart.y = m_originOffset.cy;
    m_ptEnd = m_ptStart;

    // Get the zoom factor to be used
    m_iZoomOption = DRAW_ZOOMFACTOR;

    m_hDCWindow = ::GetDC(m_hwnd);
    m_hDCCached = m_hDCWindow;

    PrimeDC(m_hDCCached);
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);
    return(TRUE);
}



//
// DrawWndProc()
// Message handler for the drawing area
//
LRESULT CALLBACK DrawWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbDrawingArea * pDraw = (WbDrawingArea *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pDraw = (WbDrawingArea *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pDraw);

            pDraw->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pDraw);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pDraw);

            //
            // When you call GetDC(), the HDC you get back is only valid
            // as long as the HWND it refers to is.  So we must release
            // it here.
            //
            pDraw->ShutDownDC();
            pDraw->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pDraw);
            pDraw->OnPaint();
            break;

        case WM_MOUSEMOVE:
            ASSERT(pDraw);
            pDraw->OnMouseMove((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONDOWN:
            ASSERT(pDraw);
			pDraw->DeleteSelection();
            pDraw->OnLButtonDown((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONUP:
            ASSERT(pDraw);
            pDraw->OnLButtonUp((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_CONTEXTMENU:
            ASSERT(pDraw);
            pDraw->OnContextMenu((short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_SIZE:
            ASSERT(pDraw);
            pDraw->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_HSCROLL:
            ASSERT(pDraw);
            pDraw->OnHScroll(GET_WM_HSCROLL_CODE(wParam, lParam),
                GET_WM_HSCROLL_POS(wParam, lParam));
            break;

		case WM_MOUSEWHEEL:
			ASSERT(pDraw);
			lParam = 0;
			if((short) HIWORD(wParam) > 0)
			{
				wParam = SB_LINEUP;
			}
			else
			{
				wParam = SB_LINEDOWN;
	   		}
			pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
				GET_WM_VSCROLL_POS(wParam, lParam));
				
			wParam = SB_ENDSCROLL;
           	//
           	// Just work like a vertical scroll
           	//
		
        case WM_VSCROLL:
            ASSERT(pDraw);
            pDraw->OnVScroll(GET_WM_VSCROLL_CODE(wParam, lParam),
                GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_CTLCOLOREDIT:
            ASSERT(pDraw);
            lResult = pDraw->OnEditColor((HDC)wParam);
            break;

        case WM_SETFOCUS:
            ASSERT(pDraw);
            pDraw->OnSetFocus();
            break;

        case WM_ACTIVATE:
            ASSERT(pDraw);
            pDraw->OnActivate(GET_WM_ACTIVATE_STATE(wParam, lParam));
            break;

        case WM_SETCURSOR:
            ASSERT(pDraw);
            lResult = pDraw->OnCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CANCELMODE:
            ASSERT(pDraw);
            pDraw->OnCancelMode();
            break;

        case WM_TIMER:
            ASSERT(pDraw);
            pDraw->OnTimer((UINT)wParam);
            break;


        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}


//
//
// Function:    RealizePalette
//
// Purpose:     Realize the drawing area palette
//
//
void WbDrawingArea::RealizePalette( BOOL bBackground )
{
    UINT entriesChanged;
    HDC hdc = m_hDCCached;

    if (g_pCurrentWorkspace != NULL)
    {
        HPALETTE    hPalette = PG_GetPalette();
        if (hPalette != NULL)
        {
            // get our 2cents in
            m_hOldPalette = ::SelectPalette(hdc, hPalette, bBackground);
            entriesChanged = ::RealizePalette(hdc);

            // if mapping changes go repaint
            if (entriesChanged > 0)
                ::InvalidateRect(m_hwnd, NULL, TRUE);
        }
    }
}


LRESULT WbDrawingArea::OnEditColor(HDC hdc)
{
    HPALETTE    hPalette = PG_GetPalette();

    if (hPalette != NULL)
    {
        ::SelectPalette(hdc, hPalette, FALSE);
        ::RealizePalette(hdc);
    }

	COLORREF rgb;
	m_pTextEditor->GetPenColor(&rgb);
	
    ::SetTextColor(hdc, SET_PALETTERGB( rgb) );

    return((LRESULT)::GetSysColorBrush(COLOR_WINDOW));
}

//
//
// Function:	OnPaint
//
// Purpose:	 Paint the window. This routine is called whenever Windows
//			  issues a WM_PAINT message for the Whiteboard window.
//
//
void WbDrawingArea::OnPaint(void)
{
	RECT		rcUpdate;
	RECT		rcTmp;
	RECT		rcBounds;
	HDC		 hSavedDC;
	HPEN		hSavedPen;
	HBRUSH	  hSavedBrush;
	HPALETTE	hSavedPalette;
	HPALETTE	hPalette;
	HFONT	   hSavedFont;

	MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnPaint");

	// Get the update rectangle
	::GetUpdateRect(m_hwnd, &rcUpdate, FALSE);

	if (Zoomed())
	{
		::InflateRect(&rcUpdate, 1, 1);
		InvalidateSurfaceRect(&rcUpdate, TRUE);
	}

	// Start painting
	PAINTSTRUCT	 ps;

	::BeginPaint(m_hwnd, &ps);

	hSavedDC	  =   m_hDCCached;
	hSavedFont	=   m_hOldFont;
	hSavedPen	 =   m_hOldPen;
	hSavedBrush   =   m_hOldBrush;
	hSavedPalette =   m_hOldPalette;

	TRACE_MSG(("Flipping cache to paint DC"));
	m_hDCCached   =   ps.hdc;
	PrimeDC(m_hDCCached);

	// Only draw anything if we have a valid page attached
	if (g_pCurrentWorkspace != NULL )
	{
		// set palette
		hPalette = PG_GetPalette();
		if (hPalette != NULL)
		{
			m_hOldPalette = ::SelectPalette(m_hDCCached, hPalette, FALSE );
			::RealizePalette(m_hDCCached);
		}


		T126Obj * pObj = NULL;
		WBPOSITION pos;

		pObj = PG_First(g_pCurrentWorkspace, &rcUpdate, FALSE);
		if(pObj)
		{
			pos = pObj->GetMyPosition();
			if(pos)
			{
				g_pCurrentWorkspace->GetNextObject(pos);
			}
		}
	
		while (pObj != NULL)
		{
			pObj->Draw(NULL, TRUE);
	
			// Get the next one
			if(pos)
			{
				pObj = PG_Next(g_pCurrentWorkspace, pos, &rcUpdate, FALSE);
			}
			else
			{
				break;
			}
		}
		
		if (hPalette != NULL)
		{
			::SelectPalette(m_hDCCached, m_hOldPalette, TRUE);
		}

		// fixes painting problems for bug 2185
		if( TextEditActive() )
		{
			RedrawTextEditbox();
		}

		//
		// Draw the tracking graphic
		//
		if ((m_pGraphicTracker != NULL) && !EqualPoint(m_ptStart, m_ptEnd))
		{
			TRACE_MSG(("Drawing the tracking graphic"));
			m_pGraphicTracker->Draw(NULL, FALSE);
		}
	
	}

	//
	// Restore the DC to its original state
	//
	UnPrimeDC(m_hDCCached);

	m_hOldFont	  = hSavedFont;
	m_hOldPen	   = hSavedPen;
	m_hOldBrush	 = hSavedBrush;
	m_hOldPalette   = hSavedPalette;
	m_hDCCached	 = hSavedDC;

	// Finish painting
	::EndPaint(m_hwnd, &ps);
}


//
// Selects all graphic objs contained in rectSelect. If rectSelect is
// NULL then ALL objs are selected
//
void WbDrawingArea::SelectMarkerFromRect(LPCRECT lprcSelect)
{
    T126Obj* pGraphic;
    RECT    rc;
    ::SetRectEmpty(&rc);

    m_HourGlass = TRUE;
    SetCursorForState();

	WBPOSITION pos;
		
	pGraphic = NULL;
    pGraphic = PG_First(g_pCurrentWorkspace, lprcSelect, TRUE);
	if(pGraphic)
	{
		pos = pGraphic->GetMyPosition();
		if(pos)
		{
			g_pCurrentWorkspace->GetNextObject(pos);
		}
	}


    while (pGraphic != NULL)
    {
		if(pGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER &&	// if it is a pointer and it is not local
			(!pGraphic->IAmTheOwner() ||						// we can't select it. Or this was a select all
			(pGraphic->IAmTheOwner() && lprcSelect == NULL)))
		{
			; // don't select it
		}
		else
		{
	        SelectGraphic(pGraphic, TRUE, TRUE);

			//
			// Calculate de size of the total selection
			//
			RECT selctRect;
			pGraphic->GetBoundsRect(&selctRect);
			::UnionRect(&rc,&selctRect,&rc);
		}

        // Get the next one
        pGraphic = PG_Next(g_pCurrentWorkspace, pos, lprcSelect, TRUE );
    }

	m_pMarker->SetRect(&rc);

    m_HourGlass = FALSE;
    SetCursorForState();

    g_pMain->OnUpdateAttributes();

}

//
//
// Function:    OnTimer
//
// Purpose:     Process a timer event. These are used to update freehand and
//              text objects while they are being drawn/edited and to
//              update the remote pointer position when the mouse stops.
//
//
void WbDrawingArea::OnTimer(UINT idTimer)
{
    TRACE_TIMER(("WbDrawingArea::OnTimer"));

    // We are only interested if the user is drawing something or editing
    if (m_bLButtonDown == TRUE)
    {


		if(idTimer == TIMER_REMOTE_POINTER_UPDATE)
		{
			ASSERT(g_pMain->m_pLocalRemotePointer);
			if(g_pMain->m_pLocalRemotePointer)
			{
				if(g_pMain->m_pLocalRemotePointer->HasAnchorPointChanged())
				{
					g_pMain->m_pLocalRemotePointer->OnObjectEdit();
					g_pMain->m_pLocalRemotePointer->ResetAttrib();
				}
			}
			return;
		}


        // If the user is dragging an object or drawing a freehand line
        if (m_pGraphicTracker != NULL)
        {
        	if(m_pGraphicTracker->HasAnchorPointChanged() || m_pGraphicTracker->HasPointListChanged())
        	{
				//
				// If we are not added to the workspace
				//
				if(!m_pGraphicTracker->GetMyWorkspace())
				{
					m_pGraphicTracker->AddToWorkspace();
				}
				else
				{
					m_pGraphicTracker->OnObjectEdit();
				}
	        }
        }
    }
}



//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbDrawingArea::OnSize(UINT nType, int cx, int cy)
{
    // Only process this message if the window is not minimized
    if (   (nType == SIZEFULLSCREEN)
        || (nType == SIZENORMAL))
    {
        if (TextEditActive())
        {
            TextEditParentResize();
        }

        // Set the new scroll range (based on the new client area)
        SetScrollRange(cx, cy);

        // Ensure that the scroll position lies in the new scroll range
        ValidateScrollPos();

        // make page move if needed
        ScrollWorkspace();

        // Update the scroll bars
        ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
        ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);
    }
}


//
//
// Function:    SetScrollRange
//
// Purpose:     Set the current scroll range. The range is based on the
//              work surface size and the size of the client area.
//
//
void WbDrawingArea::SetScrollRange(int cx, int cy)
{
    SCROLLINFO scinfo;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetScrollRange");

    // If we are in zoom mode, then allow for the magnification
    ASSERT(m_iZoomFactor != 0);
    cx /= m_iZoomFactor;
    cy /= m_iZoomFactor;

    ZeroMemory( &scinfo,  sizeof (SCROLLINFO) );
    scinfo.cbSize = sizeof (SCROLLINFO);
    scinfo.fMask = SIF_PAGE    | SIF_RANGE|
                    SIF_DISABLENOSCROLL;

    // Set the horizontal scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_WIDTH - 1;
    scinfo.nPage = cx;
    ::SetScrollInfo(m_hwnd, SB_HORZ, &scinfo, FALSE);

    // Set the vertical scroll range and proportional thumb size
    scinfo.nMin = 0;
    scinfo.nMax = DRAW_HEIGHT - 1;
    scinfo.nPage = cy;
    ::SetScrollInfo(m_hwnd, SB_VERT, &scinfo, FALSE);
}

//
//
// Function:    ValidateScrollPos
//
// Purpose:     Ensure that the current scroll position is within the bounds
//              of the current scroll range. The scroll range is set to
//              ensure that the window on the worksurface never extends
//              beyond the surface boundaries.
//
//
void WbDrawingArea::ValidateScrollPos()
{
    int iMax;
    SCROLLINFO scinfo;

    // Validate the horixontal scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_HORZ, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage;
    m_posScroll.x = max(m_posScroll.x, 0);
    m_posScroll.x = min(m_posScroll.x, iMax);

    // Validate the vertical scroll position using proportional settings
    scinfo.cbSize = sizeof(scinfo);
    scinfo.fMask = SIF_ALL;
    ::GetScrollInfo(m_hwnd, SB_VERT, &scinfo);
    iMax = scinfo.nMax - scinfo.nPage;
    m_posScroll.y = max(m_posScroll.y, 0);
    m_posScroll.y = min(m_posScroll.y, iMax);
}

//
//
// Function:    ScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::ScrollWorkspace(void)
{

	RECT rc;
	
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ScrollWorkspace");


    // Do the scroll
    DoScrollWorkspace();


	if(Zoomed())
	{
    	// Tell the parent that the scroll position has changed
	    HWND    hwndParent;

	    hwndParent = ::GetParent(m_hwnd);
	    if (hwndParent != NULL)
	    {
	        ::PostMessage(hwndParent, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);
	    }
	}
}

//
//
// Function:    DoScrollWorkspace
//
// Purpose:     Scroll the workspace to the position set in the member
//              variable m_posScroll.
//
//
void WbDrawingArea::DoScrollWorkspace()
{
    // Validate the scroll position
    ValidateScrollPos();

    // Set the scroll box position
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Only update the screen if the scroll position has changed
    if ( (m_originOffset.cy != m_posScroll.y)
        || (m_originOffset.cx != m_posScroll.x) )
    {

		// Calculate the amount to scroll
        INT iVScrollAmount = m_originOffset.cy - m_posScroll.y;
        INT iHScrollAmount = m_originOffset.cx - m_posScroll.x;

        // Save the new position (for UpdateWindow)
        m_originOffset.cx = m_posScroll.x;
        m_originOffset.cy = m_posScroll.y;

        ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

        // Scroll and redraw the newly invalidated portion of the window
        ::ScrollWindow(m_hwnd, iHScrollAmount, iVScrollAmount, NULL, NULL);
        ::UpdateWindow(m_hwnd);
	}
}

//
//
// Function:    GotoPosition
//
// Purpose:     Move the top-left corner of the workspace to the specified
//              position in the workspace.
//
//
void WbDrawingArea::GotoPosition(int x, int y)
{
    // Set the new scroll position
    m_posScroll.x = x;
    m_posScroll.y = y;

    // Scroll to the new position
    DoScrollWorkspace();

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnVScroll
//
// Purpose:     Process a WM_VSCROLL messages.
//
//
void WbDrawingArea::OnVScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle HEIGHT
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.top == 0);
    rcClient.bottom -= rcClient.top;

    // Act on the scroll code
    switch(nSBCode)
    {
        // Scroll to bottom
        case SB_BOTTOM:
            m_posScroll.y = DRAW_HEIGHT - rcClient.bottom;
            break;

        // Scroll down a line
        case SB_LINEDOWN:
            m_posScroll.y += DRAW_LINEVSCROLL;
            break;

        // Scroll up a line
        case SB_LINEUP:
            m_posScroll.y -= DRAW_LINEVSCROLL;
            break;

        // Scroll down a page
        case SB_PAGEDOWN:
            m_posScroll.y += rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll up a page
        case SB_PAGEUP:
            m_posScroll.y -= rcClient.bottom / m_iZoomFactor;
            break;

        // Scroll to the top
        case SB_TOP:
            m_posScroll.y = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.y = nPos; // don't round
            break;

        default:
        break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}

//
//
// Function:    OnHScroll
//
// Purpose:     Process a WM_HSCROLL messages.
//
//
void WbDrawingArea::OnHScroll(UINT nSBCode, UINT nPos)
{
    RECT    rcClient;

    // Get the current client rectangle WIDTH
    ::GetClientRect(m_hwnd, &rcClient);
    ASSERT(rcClient.left == 0);
    rcClient.right -= rcClient.left;

    switch(nSBCode)
    {
        // Scroll to the far right
        case SB_BOTTOM:
            m_posScroll.x = DRAW_WIDTH - rcClient.right;
            break;

        // Scroll right a line
        case SB_LINEDOWN:
            m_posScroll.x += DRAW_LINEHSCROLL;
            break;

        // Scroll left a line
        case SB_LINEUP:
            m_posScroll.x -= DRAW_LINEHSCROLL;
            break;

        // Scroll right a page
        case SB_PAGEDOWN:
            m_posScroll.x += rcClient.right / m_iZoomFactor;
            break;

        // Scroll left a page
        case SB_PAGEUP:
            m_posScroll.x -= rcClient.right / m_iZoomFactor;
            break;

        // Scroll to the far left
        case SB_TOP:
            m_posScroll.x = 0;
            break;

        // Track the scroll box
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            m_posScroll.x = nPos; // don't round
            break;

        default:
            break;
    }

    // Validate the scroll position
    ValidateScrollPos();
    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);

    // If this message is informing us of the end of scrolling,
    //   update the window
    if (nSBCode == SB_ENDSCROLL)
    {
        // Scroll the window
        ScrollWorkspace();
    }

    // Invalidate the zoom scroll cache if we scroll when unzoomed.
    if (!Zoomed())
    {
        m_zoomRestoreScroll = FALSE;
    }
}


//
//
// Function:    AutoScroll
//
// Purpose:     Auto-scroll the window to bring the position passed as
//              parameter into view.
//
//
BOOL WbDrawingArea::AutoScroll
(
    int     xSurface,
    int     ySurface,
    BOOL    bMoveCursor,
    int     xCaret,
    int     yCaret
)
{
    int nXPSlop, nYPSlop;
    int nXMSlop, nYMSlop;
    int nDeltaHScroll, nDeltaVScroll;
    BOOL bDoScroll = FALSE;

    nXPSlop = 0;
    nYPSlop = 0;
    nXMSlop = 0;
    nYMSlop = 0;

    if( TextEditActive() )
    {

        POINT   ptDirTest;

        ptDirTest.x = xSurface - xCaret;
        ptDirTest.y = ySurface - yCaret;

        // set up for text editbox
        if( ptDirTest.x > 0 )
            nXPSlop = m_pTextEditor->m_textMetrics.tmMaxCharWidth;
        else
        if( ptDirTest.x < 0 )
            nXMSlop = -m_pTextEditor->m_textMetrics.tmMaxCharWidth;

        if( ptDirTest.y > 0 )
            nYPSlop = m_pTextEditor->m_textMetrics.tmHeight;
        else
        if( ptDirTest.y < 0 )
            nYMSlop = -m_pTextEditor->m_textMetrics.tmHeight;

        nDeltaHScroll = m_pTextEditor->m_textMetrics.tmMaxCharWidth;
        nDeltaVScroll = m_pTextEditor->m_textMetrics.tmHeight;
    }
    else
    {
        // set up for all other objects
        nDeltaHScroll = DRAW_LINEHSCROLL;
        nDeltaVScroll = DRAW_LINEVSCROLL;
    }

    // Get the current visible surface rectangle
    RECT  visibleRect;
    GetVisibleRect(&visibleRect);

    // Check for pos + slop being outside visible area
    if( (xSurface + nXPSlop) >= visibleRect.right )
    {
        bDoScroll = TRUE;
        m_posScroll.x +=
            (((xSurface + nXPSlop) - visibleRect.right) + nDeltaHScroll);
    }

    if( (xSurface + nXMSlop) <= visibleRect.left )
    {
        bDoScroll = TRUE;
        m_posScroll.x -=
            ((visibleRect.left - (xSurface + nXMSlop)) + nDeltaHScroll);
    }

    if( (ySurface + nYPSlop) >= visibleRect.bottom)
    {
        bDoScroll = TRUE;
        m_posScroll.y +=
            (((ySurface + nYPSlop) - visibleRect.bottom) + nDeltaVScroll);
    }

    if( (ySurface + nYMSlop) <= visibleRect.top)
    {
        bDoScroll = TRUE;
        m_posScroll.y -=
            ((visibleRect.top - (ySurface + nYMSlop)) + nDeltaVScroll);
    }

    if( !bDoScroll )
        return( FALSE );

    // Indicate that scrolling has completed (in both directions)
    ScrollWorkspace();

    // Update the mouse position (if required)
    if (bMoveCursor)
    {
        POINT   screenPos;

        screenPos.x = xSurface;
        screenPos.y = ySurface;

        SurfaceToClient(&screenPos);
        ::ClientToScreen(m_hwnd, &screenPos);
        ::SetCursorPos(screenPos.x, screenPos.y);
    }

    return( TRUE );
}

//
//
// Function:    OnCursor
//
// Purpose:     Process a WM_SETCURSOR messages.
//
//
LRESULT WbDrawingArea::OnCursor(HWND hwnd, UINT uiHit, UINT uMsg)
{
    BOOL bResult = FALSE;

    // Check that this message is for the main window
    if (hwnd == m_hwnd)
    {
        // If the cursor is now in the client area, set the cursor
        if (uiHit == HTCLIENT)
        {
            bResult = SetCursorForState();
        }
        else
        {
            // Restore the cursor to the standard arrow. Set m_hCursor to NULL
            // to indicate that we have not set a special cursor.
            m_hCursor = NULL;
           ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
            bResult = TRUE;
        }
    }

    // Return result indicating whether we processed the message or not
    return bResult;
}

//
//
// Function:    SetCursorForState
//
// Purpose:     Set the cursor for the current state
//
//
BOOL WbDrawingArea::SetCursorForState(void)
{
    BOOL    bResult = FALSE;

    m_hCursor = NULL;

    // If the drawing area is locked, use the "locked" cursor
    if (m_HourGlass)
    {
        m_hCursor = ::LoadCursor( NULL, IDC_WAIT );
    }
    else if (m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID)
    {
        // Return the cursor for the tool
        m_hCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( LOCKCURSOR ));
    }
    else if (m_pToolCur != NULL)
    {
        // Get the cursor for the tool currently in use
        m_hCursor = m_pToolCur->GetCursorForTool();
    }

    if (m_hCursor != NULL)
    {
        ::SetCursor(m_hCursor);
        bResult = TRUE;
    }

    // Return result indicating whether we set the cursor or not
    return bResult;
}

//
//
// Function:    Lock
//
// Purpose:     Lock the drawing area, preventing further updates
//
//
void WbDrawingArea::Lock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Lock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Stop any drawing we are doing.
    CancelDrawingMode();

    // Deselect any selected graphic
    ClearSelection();

    // Show that we are now locked
    m_bLocked = TRUE;
    TRACE_MSG(("Drawing area is now locked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    Unlock
//
// Purpose:     Unlock the drawing area, preventing further updates
//
//
void WbDrawingArea::Unlock(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Unlock");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Show that we are now unlocked
    m_bLocked = FALSE;
    TRACE_MSG(("Drawing area is now UNlocked"));

    // Set the cursor for the drawing mode, but only if we should be drawing
    // a special cursor (if m_hCursor != the current cursor, then the cursor
    // is out of the client area).
    if (::GetCursor() == m_hCursor)
    {
        SetCursorForState();
    }
}

//
//
// Function:    PageCleared
//
// Purpose:     The page has been cleared
//
//
void WbDrawingArea::PageCleared(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PageCleared");

    // Check whether the drawing area is busy - this is not allowed
    ASSERT(!m_bBusy);

    // Discard any text being edited
    if (m_bTextEditorActive)
    {
        if (m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID)
        {
            DeactivateTextEditor();
        }
        else
        {
            EndTextEntry(FALSE);
        }
    }

    // Remove the copy of the marked graphic and the marker
    ClearSelection();

    // Invalidate the whole window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    InvalidateSurfaceRect
//
// Purpose:     Invalidate the window rectangle corresponding to the given
//              drawing surface rectangle.
//
//
void WbDrawingArea::InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase)
{
    RECT    rc;

    // Convert the surface co-ordinates to client window and invalidate
    // the rectangle.
    rc = *lprc;
    SurfaceToClient(&rc);
    ::InvalidateRect(m_hwnd, &rc, bErase);
}


//
//
// Function:    PrimeFont
//
// Purpose:     Insert the supplied font into our DC and return the
//              text metrics
//
//
void WbDrawingArea::PrimeFont(HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeFont");

    //
    // temporarily unzoom to get the font that we want
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
    }

    HFONT hOldFont = SelectFont(hDC, hFont);
    if (hOldFont == NULL)
    {
        WARNING_OUT(("Failed to select font into DC"));
    }

    if (pTextMetrics != NULL)
    {
        ::GetTextMetrics(hDC, pTextMetrics);
    }

    //
    // restore the zoom state
    //
    if (Zoomed())
    {
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);
    }
}

//
//
// Function:    UnPrimeFont
//
// Purpose:     Remove the specified font from the DC and clear cache
//              variable
//
//
void WbDrawingArea::UnPrimeFont(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeFont");

    if (hDC != NULL)
    {
        SelectFont(hDC, ::GetStockObject(SYSTEM_FONT));
    }
}

//
//
// Function:    PrimeDC
//
// Purpose:     Set up a DC for drawing
//
//
void WbDrawingArea::PrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::PrimeDC");

    ::SetMapMode(hDC, MM_ANISOTROPIC);

    ::SetBkMode(hDC, TRANSPARENT);

    ::SetTextAlign(hDC, TA_LEFT | TA_TOP);
}

//
//
// Function:    UnPrimeDC
//
// Purpose:     Reset the DC to default state
//
//
void WbDrawingArea::UnPrimeDC(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::UnPrimeDC");

    SelectPen(hDC, (HPEN)::GetStockObject(BLACK_PEN));
    SelectBrush(hDC, (HBRUSH)::GetStockObject(BLACK_BRUSH));

    UnPrimeFont(hDC);
}


//
// WbDrawingArea::OnContextMenu()
//
void WbDrawingArea::OnContextMenu(int xScreen, int yScreen)
{
    POINT   pt;
    RECT    rc;

    pt.x = xScreen;
    pt.y = yScreen;
    ::ScreenToClient(m_hwnd, &pt);

    ::GetClientRect(m_hwnd, &rc);
    if (::PtInRect(&rc, pt))
    {
        // Complete drawing action, if any
        OnLButtonUp(0, pt.x, pt.y);

        // Ask main window to put up context menu
        g_pMain->PopupContextMenu(pt.x, pt.y);
    }
}


//
// WbDrawingArea::OnLButtonDown()
//
void WbDrawingArea::OnLButtonDown(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonDown");

    if( m_bIgnoreNextLClick )
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONDOWN") );
        return;
    }

    // Set the focus to this window. This is done to ensure that we trap
    // the text edit keys and the delete key when they are used.
    ::SetFocus(m_hwnd);

    // Save the operation start point (and current end point)
    // Adjust the mouse position to allow for the zoom factor
    m_ptStart.x = x;
    m_ptStart.y = y;
    ClientToSurface(&m_ptStart);
    m_ptEnd   = m_ptStart;

    // Show that the mouse button is now down
    m_bLButtonDown = TRUE;

    // Show that the drawing area is now busy
    m_bBusy = TRUE;

    // Only allow the action to take place if the drawing area is unlocked,
    // and we have a valid tool
    if ((m_bLocked && g_pNMWBOBJ->m_LockerID != g_MyMemberID) || (m_pToolCur == NULL))
    {
        // Tidy up the state and leave now
        m_bLButtonDown = FALSE;
        m_bBusy        = FALSE;
        return;
    }

    // Call the relevant initialization routine
    if (m_pToolCur->ToolType() != TOOLTYPE_SELECT)
    {
        // dump selection if not select tool
        ClearSelection();
    }

	INT border = 1;
    switch (m_pToolCur->ToolType())
    {

        case TOOLTYPE_TEXT:
			break;

		case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
        case TOOLTYPE_LINE:
        case TOOLTYPE_BOX:
        case TOOLTYPE_FILLEDBOX:
        case TOOLTYPE_ELLIPSE:
        case TOOLTYPE_FILLEDELLIPSE:
            BeginDrawingMode(m_ptStart);
            break;

        case TOOLTYPE_ERASER:
        	BeginSelectMode(m_ptStart, TRUE);
			break;

        case TOOLTYPE_SELECT:
        	border = -2;
			BeginSelectMode(m_ptStart, FALSE);
			break;


        // Do nothing if we do not recognise the pen type
        default:
            ERROR_OUT(("Bad tool type"));
            break;
    }

    // Clamp the cursor to the drawing window
    RECT    rcClient;

    ::GetClientRect(m_hwnd, &rcClient);
    ::MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcClient.left, 2);
    ::InflateRect(&rcClient, border, border);
    ::ClipCursor(&rcClient);
}

//
//
// Function:	SelectPreviousGraphicAt
//
// Purpose:	 Select the previous graphic (in the Z-order) at the position
//			  specified, and starting at a specified graphic. If the
//			  graphic pointer given is NULL the search starts from the
//			  top. If the point specified is outside the bounding
//			  rectangle of the specified graphic the search starts at the
//			  top and chooses the first graphic which contains the point.
//
//			  The search process will loop back to the top of the Z-order
//			  if it gets to the bottom having failed to find a graphic.
//
//			  Graphics which are locked are ignored by the search.
//
//
T126Obj* WbDrawingArea::SelectPreviousGraphicAt
(
	T126Obj* pStartGraphic,
	POINT	   point
)
{
	// Set the result to "none found" initially
	T126Obj* pResultGraphic = NULL;

	// If a starting point has been specified
	if (pStartGraphic != NULL)
	{
		RECT rectHit;

		MAKE_HIT_RECT(rectHit, point);

		// If the reference point is within the start graphic
		if ( pStartGraphic->PointInBounds(point) &&
			pStartGraphic->CheckReallyHit( &rectHit ) )
		{
			WBPOSITION pos = pStartGraphic->GetMyPosition();
			g_pCurrentWorkspace->GetPreviousObject(pos);
			while (pos)
			{
		   		pResultGraphic = g_pCurrentWorkspace->GetPreviousObject(pos);
				if( pResultGraphic && pResultGraphic->CheckReallyHit( &rectHit ) )
				{
					if(m_pMarker)
					{
						RECT rect;
						pResultGraphic->GetRect(&rect);
						m_pMarker->SetRect(&rect);
					}
					break;
				}			
		   		pResultGraphic = NULL;
		   	}
		}
	}

	// If we have not got a result graphic yet. (This catches two cases:
	// - where no start graphic has been given so that we want to start
	//   from the top,
	// - where we have searched back from the start graphic and reached
	//   the bottom of the Z-order without finding a suitable graphic.
	if (pResultGraphic == NULL)
	{
		// Get the topmost graphic that contains the point specified
		pResultGraphic = PG_SelectLast(g_pCurrentWorkspace, point);
	}

	// If we have found an object, draw the marker
	if (pResultGraphic != NULL)
	{
		//
		// If we are already selected and we didn't select it
		// some other node has the control over this graphic don't select it
		// in this case
		// Or if we are trying to select a remote pointer that is not ours
		//
		if(pResultGraphic->IsSelected() && pResultGraphic->WasSelectedRemotely()
			|| (pResultGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER && !pResultGraphic->IAmTheOwner()))
		{
			pResultGraphic = NULL;
		}
		else
		{
			// Select the new one
			SelectGraphic(pResultGraphic);
		}
	}

	return pResultGraphic;
}

//
//
// Function:    BeginSelectMode
//
// Purpose:     Process a mouse button down in select mode
//
//

void WbDrawingArea::BeginSelectMode(POINT surfacePos, BOOL bDontDrag )
{
    RECT    rc;

    // Assume we do not start dragging a graphic
    m_pGraphicTracker = NULL;

    // Assume that we do not mark a new graphic
    m_bNewMarkedGraphic = FALSE;

    // turn off TRACK-SELECT-RECT
    m_bTrackingSelectRect = FALSE;

    // Check whether there is currently an object marked, and
    // whether we are clicking inside the same object. If we are then
    // we do nothing here - the click will be handled by the tracking or
    // completion routines for select mode.
    if (   (GraphicSelected() == FALSE)
        || (m_pMarker->PointInBounds(surfacePos) == FALSE))
    {
	    ::SetRectEmpty(&g_pDraw->m_selectorRect);
		
        // We are selecting a new object if bDontDrag == FALSE, find it.
        //  otherwise just turn on the select rect
        T126Obj* pGraphic;
        if( bDontDrag )
            pGraphic = NULL;
        else
            pGraphic = SelectPreviousGraphicAt(NULL, surfacePos);

        // If we have found an object, draw the marker
        if (pGraphic != NULL)
        {

			if(pGraphic->IsSelected() && pGraphic->WasSelectedRemotely())	
			{
				return;
			}
			// Show that a new graphic has now been marked.
			m_bNewMarkedGraphic = TRUE;
        }
        else
        {
            if( (GetAsyncKeyState( VK_SHIFT ) >= 0) &&
                (GetAsyncKeyState( VK_CONTROL ) >= 0) )
            {
                // clicked on dead air, remove all selections
                ClearSelection();
            }

            //TRACK-SELECT-RECT
            m_bTrackingSelectRect = TRUE;

            BeginDrawingMode(surfacePos);

            return;
        }
    }

	if(GraphicSelected())
	{
		m_pMarker->SetRect(&m_selectorRect);
		m_pMarker->SetBoundsRect(&m_selectorRect);
		m_pGraphicTracker = m_pMarker;
	}
	
    // Get all mouse input directed to the this window
    ::SetCapture(m_hwnd);
}


//
//
// Function:    TrackSelectMode
//
// Purpose:     Process a mouse move event in select mode
//
//
void WbDrawingArea::TrackSelectMode(POINT surfacePos)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::TrackSelectMode");
	

	if( m_bTrackingSelectRect )
		TrackDrawingMode(surfacePos);
	else
	{
		// In this case we must be dragging a marked object
		if(!EqualPoint(surfacePos, m_ptEnd))
		{
			MoveSelectedGraphicBy(surfacePos.x - m_ptEnd.x, surfacePos.y - m_ptEnd.y);
		}
		m_ptEnd = surfacePos;
	}
}


void WbDrawingArea::BeginDeleteMode(POINT mousePos )
{
    // turn off object dragging
    BeginSelectMode( mousePos, TRUE );
}



void  WbDrawingArea::TrackDeleteMode( POINT mousePos )
{
    TrackSelectMode( mousePos );
}






//
//
// Function:	BeginTextMode
//
// Purpose:	 Process a mouse button down in text mode
//
//
void WbDrawingArea::BeginTextMode(POINT surfacePos)
{
	RECT	rc;

	MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::BeginTextMode");

	//
	// Get a DC for passing into the text editor
	//
	HDC hDC = m_hDCCached;

	// If we are already editing a text object, we just move the text cursor
	if (m_bTextEditorActive)
	{
		// If the mouse has been clicked in the currently active object
		// we just move the cursor within the object, otherwise we end the
		// edit for the current object and move to a new one.
		m_pTextEditor->GetRect(&rc);
		if (::PtInRect(&rc, surfacePos))
		{
			// Set the new position for the cursor
			m_pTextEditor->SetCursorPosFromPoint(surfacePos);
		}
		else
		{
			// Complete the text entry accepting the changes
			EndTextEntry(TRUE);

			// LAURABU BOGUS:
			// It would be cooler to now return, that way you don't get
			// another text object just cuz you ended the current editing
			// session.
		}
	}

	// If we are not editing an object we check to see whether there is
	// a text object under the cursor or whether we must start a new one.
	if (!m_bTextEditorActive)
	{
		// Check whether we are clicking over a text object. If we are
		// start editing the object, otherwise we start a new text object.

		// Look back through the Z-order for a text object
		T126Obj* pGraphic = PG_SelectLast(g_pCurrentWorkspace, surfacePos);
		T126Obj* pNextGraphic = NULL;
		WBPOSITION pos;
		if(pGraphic)
		{
			pos = pGraphic->GetMyPosition();
		}
		while (   (pGraphic != NULL)  && pGraphic->GraphicTool() != TOOLTYPE_TEXT)
		{

			// Get the next one
			pNextGraphic = PG_SelectPrevious(g_pCurrentWorkspace, pos, surfacePos);

			// Use the next one
			pGraphic = pNextGraphic;
		}

		// Check whether this graphic object is already being edited by
		// another user in the call.
		if (pGraphic != NULL && !pGraphic->WasSelectedRemotely() && pGraphic->GraphicTool() == TOOLTYPE_TEXT)
		{
			// We found a text object under the mouse pointer...
			// ...edit it
			m_pTextEditor = (WbTextEditor*)pGraphic;

			m_pTextEditor->SetTextObject(m_pTextEditor);

			// Make sure the tool reflects the new information
			if (m_pToolCur != NULL)
			{
				m_pToolCur->SelectGraphic(pGraphic);
			}

            HWND hwndParent = ::GetParent(m_hwnd);
            if (hwndParent != NULL)
            {
                ASSERT(g_pMain);
                ASSERT(g_pMain->m_hwnd == hwndParent);
                ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
            }
		
			// Show that we are now gathering text but dont put up cursor
			// yet. Causes cursor droppings later (bug 2505)
			//ActivateTextEditor( FALSE );
			RECT rect;
			m_pTextEditor->GetRect(&rect);
			m_pTextEditor->Create();
		
			// init editbox size
			m_pTextEditor->GetText();

			//
			// Tell the other nodes they can't edit this object now
			//
			m_pTextEditor->SetViewState(selected_chosen);
			m_pTextEditor->OnObjectEdit();

			ActivateTextEditor( TRUE );

			::BringWindowToTop(m_pTextEditor->m_pEditBox->m_hwnd);
			
			//
			// Account for scrolling
			//
			SurfaceToClient(&rect);
				
			::MoveWindow(m_pTextEditor->m_pEditBox->m_hwnd, rect.left, rect.top,
				rect.right - rect.left, rect.bottom - rect.top,	TRUE);

			// Set the initial cursor position for the edit
			m_pTextEditor->SetCursorPosFromPoint(surfacePos);

		}
		else
		{


			RECT rect;
			rect.top = m_ptEnd.y;
			rect.left = m_ptEnd.x;
			rect.bottom = m_ptEnd.y;
			rect.right = m_ptEnd.x;
	
			DBG_SAVE_FILE_LINE
			m_pTextEditor = new WbTextEditor();

			m_pTextEditor->SetRect(&rect);
			m_pTextEditor->SetAnchorPoint(m_ptEnd.x, m_ptEnd.y);
			m_pTextEditor->SetViewState(selected_chosen);

			
			// There are no text objects under the mouse pointer...
			// ...start a new one

			// Clear any old text out of the editor, and reset its graphic
			// handle. This prevents us from replacing an old text object when
			// we next save the text editor contents.
			if (!m_pTextEditor->New())
			{
				DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
				return;
			}


			// Set the attributes of the text
			m_pTextEditor->SetFont(m_pToolCur->GetFont());
			m_pTextEditor->SetPenColor(m_pToolCur->GetColor(), TRUE);

			// We need to reselect a font now into our DC
			SelectFont(hDC, m_pTextEditor->GetFont());

			// Set the position of the new object
			SIZE sizeCursor;
			m_pTextEditor->GetCursorSize(&sizeCursor);
			m_pTextEditor->CalculateBoundsRect();
			m_pTextEditor->MoveTo(m_ptEnd.x, m_ptEnd.y - sizeCursor.cy);
			// Show that we are now gathering text
			ActivateTextEditor( TRUE );
		}
	}
}

void WbDrawingArea::BeginDrawingMode(POINT surfacePos)
{

	if(!g_pCurrentWorkspace)
	{
		TRACE_DEBUG(("Can't draw without a workspace"));
		return;
	}

	//
	// Get all mouse input directed to the this window
	//
	::SetCapture(m_hwnd);

	//
	// We shouldn't be using the tracker
	//
	ASSERT(!m_pGraphicTracker);

	UINT drawingType;
	BOOL sendBeforefinished = FALSE;
	BOOL highlight = FALSE;
	UINT lineStyle = PS_SOLID;
	UINT toolType = m_pToolCur->ToolType();
	switch (toolType)
	{
		case TOOLTYPE_HIGHLIGHT:
			highlight = TRUE;
		case TOOLTYPE_PEN:
			sendBeforefinished = TRUE;
		case TOOLTYPE_LINE:
			drawingType = openPolyLine_chosen;
			break;

		case TOOLTYPE_SELECT:
		case TOOLTYPE_ERASER:
			m_pGraphicTracker = m_pMarker;
			return;
			break;

		case TOOLTYPE_FILLEDBOX:
		case TOOLTYPE_BOX:
			drawingType = rectangle_chosen;
			break;

		case TOOLTYPE_FILLEDELLIPSE:
		case TOOLTYPE_ELLIPSE:
			drawingType = ellipse_chosen;
			break;
	}	


	
	DBG_SAVE_FILE_LINE
	m_pGraphicTracker = new DrawObj(drawingType, toolType);
    if(NULL == m_pGraphicTracker)
    {
        ERROR_OUT(("Failed to allocate new DrawObj"));
        return;
    }

	//
	// Use black for the tracking rectangle unless it is pen or highlighter
	//
	if(m_pToolCur->ToolType() == TOOLTYPE_PEN || m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT)
	{
		m_pGraphicTracker->SetPenColor(m_pToolCur->GetColor(), TRUE);
	}
	else
	{
		m_pGraphicTracker->SetPenColor(RGB(0,0,0), TRUE);
	}

	m_pGraphicTracker->SetFillColor(RGB(255,255,255), FALSE);
	m_pGraphicTracker->SetLineStyle(lineStyle);
	m_pGraphicTracker->SetAnchorPoint(surfacePos.x, surfacePos.y);
	m_pGraphicTracker->SetHighlight(highlight);
	m_pGraphicTracker->SetViewState(unselected_chosen);
	m_pGraphicTracker->SetZOrder(front);

	//
	// Start a timer if we want it to send intermidiate drawings
	//
	if(sendBeforefinished)
	{

		RECT rect;
		rect.left = surfacePos.x;
		rect.top = surfacePos.y;
		rect.right = surfacePos.x;
		rect.bottom = surfacePos.y;
		
		m_pGraphicTracker->SetRect(&rect);
		m_pGraphicTracker->SetBoundsRect(&rect);

		surfacePos.x = 0;
		surfacePos.y = 0;
		m_pGraphicTracker->AddPoint(surfacePos);
		
		//
		// Select the final ROP
		//
		if (highlight)
		{
			m_pGraphicTracker->SetROP(R2_MASKPEN);
		}
		else
		{
			m_pGraphicTracker->SetROP(R2_COPYPEN);
		}

		//
		// Use the tools width for pen or highlight
		//
		m_pGraphicTracker->SetPenThickness(m_pToolCur->GetWidth());

		// Start the timer for updating the graphic (this is only for updating
		// the graphic when the user stops moving the pointer but keeps the
		// mouse button down).
		::SetTimer(m_hwnd, TIMER_GRAPHIC_UPDATE, DRAW_GRAPHICUPDATEDELAY, NULL);

		// Save the current time (used to determine when to update
		// the external graphic pointer information while the mouse is
		// being moved).
		m_dwTickCount = ::GetTickCount();

		m_pGraphicTracker->SetViewState(selected_chosen);

		
	}
	else
	{
		m_pGraphicTracker->SetPenThickness(1);
	}
}



//
//
// Function:    TrackDrawingMode
//
// Purpose:     Process a mouse move event in drawing mode
//
//
void WbDrawingArea::TrackDrawingMode(POINT surfacePos)
{
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

	if(!m_pGraphicTracker)
	{
		return;
	}

	if(EqualPoint(surfacePos, m_ptEnd))
	{
		return;
	}

    // Get a device context for tracking
    HDC         hDC = m_hDCCached;

    // set up palette
    if ((g_pCurrentWorkspace != NULL) && ((hPal = PG_GetPalette()) != NULL) )
    {
        hOldPal = ::SelectPalette(hDC, hPal, FALSE );
        ::RealizePalette(hDC);
    }

    // Erase the last ellipse (using XOR property)
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        // Draw the rectangle
        m_pGraphicTracker->Draw();
    }

    // Draw the new rectangle (XORing it onto the display)
    if (!EqualPoint(m_ptStart, surfacePos))
    {
		//
		// If we are using a pen or highlighter
		// Tracking in draw mode is a special case. We draw directly to the client
		// area of the window and to the recording device context.
		if(	m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT || m_pToolCur->ToolType() == TOOLTYPE_PEN)
		{
			POINT deltaPoint;

			deltaPoint.x = surfacePos.x - m_ptEnd.x;
			deltaPoint.y = surfacePos.y - m_ptEnd.y;

			// Save the point, checking there aren't too many points
			if (m_pGraphicTracker->AddPoint(deltaPoint) == FALSE)
	    	{
				// too many points so end the freehand object
				OnLButtonUp(0, surfacePos.x, surfacePos.y);
				goto cleanUp;
			}
			m_pGraphicTracker->SetRectPts(m_ptEnd, surfacePos);

			m_pGraphicTracker->AddPointToBounds(surfacePos.x, surfacePos.y);

			m_ptEnd = surfacePos;
	
		}
		else
		{

			// Save the new box end point
			m_ptEnd = surfacePos;

			// Draw the rectangle
			m_pGraphicTracker->SetRectPts(m_ptStart, m_ptEnd);

		}

		m_pGraphicTracker->Draw();

	}

cleanUp:

    if (hOldPal != NULL)
    {
        ::SelectPalette(hDC, hOldPal, TRUE);
    }
}



//
// WbDrawingArea::OnMouseMove
//
void WbDrawingArea::OnMouseMove(UINT flags, int x, int y)
{

	if(!g_pCurrentWorkspace)
	{
		return;
	}

    POINT surfacePos;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnMouseMove");

    surfacePos.x = x;
    surfacePos.y = y;

    // Check if the left mouse button is down
    if (m_bLButtonDown)
    {
        // Calculate the worksurface position
        // Adjust the mouse position to allow for the zoom factor
        ClientToSurface(&surfacePos);

        // Make sure the point is a valid surface position
        MoveOntoSurface(&surfacePos);

        // Check whether the window needs to be scrolled to get the
        // current position into view.
        AutoScroll(surfacePos.x, surfacePos.y, FALSE, 0, 0);

        // Action taken depends on the tool type
        switch(m_pToolCur->ToolType())
        {
            case TOOLTYPE_HIGHLIGHT:
            case TOOLTYPE_PEN:
            case TOOLTYPE_LINE:
            case TOOLTYPE_BOX:
            case TOOLTYPE_FILLEDBOX:
            case TOOLTYPE_ELLIPSE:
            case TOOLTYPE_FILLEDELLIPSE:
                TrackDrawingMode(surfacePos);
                break;

            case TOOLTYPE_ERASER:
            case TOOLTYPE_SELECT:
				TrackSelectMode(surfacePos);
				break;

            case TOOLTYPE_TEXT:
        	// JOSEF add functionality
                break;


            default:
                ERROR_OUT(("Unknown tool type"));
                break;
        }
    }
}

//
//
// Function:    CancelDrawingMode
//
// Purpose:     Cancels a drawing operation after an error.
//
//
void WbDrawingArea::CancelDrawingMode(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::CancelDrawingMode");

    //
    // Quit if there's nothing to cancel.
    //
    if (!m_bBusy && !m_bTextEditorActive)
    {
        TRACE_DEBUG(("Drawing area not busy and text editor not active..."));
        return;
    }

    // The drawing area is no longer busy
    m_bBusy = FALSE;

    //
    // Redraw the object - we need to discard any local updates which we
    // weren't able to write to the object we are editing.  Ideally we should
    // just invalidate the object itself but because some of the co-ordinates
    // we have already drawn on the page may have been lost, we dont know
    // exactly how big the object is.
    //
    ::InvalidateRect(m_hwnd, NULL, TRUE);

    m_bLButtonDown = FALSE;

    // Release the mouse capture
    if (::GetCapture() == m_hwnd)
    {
        ::ReleaseCapture();
    }

    //
    // Perform any tool specific processing.
    //
    switch(m_pToolCur->ToolType())
    {
        case TOOLTYPE_HIGHLIGHT:
        case TOOLTYPE_PEN:
            CompleteDrawingMode();
            break;

        case TOOLTYPE_SELECT:
            // Stop the pointer update timer
            ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
            break;

        case TOOLTYPE_TEXT:
            if (m_bTextEditorActive)
            {
                m_pTextEditor->AbortEditGently();
            }
            break;

        default:
            break;
    }

    // Show that we are no longer tracking an object
    if (m_pGraphicTracker != NULL)
    {
        m_pGraphicTracker = NULL; // We don't delete the tracker, because it is also the drawing
    }
}



//
// WbDrawingArea::OnLButtonUp()
//
void WbDrawingArea::OnLButtonUp(UINT flags, int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnLButtonUp");

    if (m_bIgnoreNextLClick)
    {
        TRACE_MSG( ("Ignoring WM_LBUTTONUP") );
        m_bIgnoreNextLClick = FALSE;
        return;
    }

    // Only process the event if we saw the button down event
    if (m_bLButtonDown)
    {
        TRACE_MSG(("End of drawing operation"));

        m_bLButtonDown = FALSE;

        // The drawing area is no longer busy
        m_bBusy = FALSE;

        if (m_pGraphicTracker == NULL)
        {
            // Calculate the work surface position
            // Adjust the mouse position to allow for the zoom factor
            POINT surfacePos;

            surfacePos.x = x;
            surfacePos.y = y;
            ClientToSurface(&surfacePos);
            MoveOntoSurface(&surfacePos);
            m_ptEnd = surfacePos;
        }

        // Release the mouse capture
        if (::GetCapture() == m_hwnd)
        {
            ::ReleaseCapture();
        }

        // Check the page is valid - might not be if it has been deleted
        // while the object was being drawn - we would not have been
        // alerted to this because m_bBusy was true.
        if (g_pCurrentWorkspace != NULL)
        {


            // surround in an exception handler in case of lock errors, etc -
            // we need to remove the graphic tracker
            // Action taken depends on the current tool type
            switch(m_pToolCur->ToolType())
            {
                case TOOLTYPE_HIGHLIGHT:
                case TOOLTYPE_PEN:
                case TOOLTYPE_LINE:
                case TOOLTYPE_BOX:
                case TOOLTYPE_FILLEDBOX:
                case TOOLTYPE_ELLIPSE:
                case TOOLTYPE_FILLEDELLIPSE:
                    CompleteDrawingMode();
                    break;

                case TOOLTYPE_SELECT:
                    CompleteSelectMode();
                    break;

                case TOOLTYPE_ERASER:
                    CompleteDeleteMode();
                    break;

                case TOOLTYPE_TEXT:
                    m_ptStart.x = x;
                    m_ptStart.y = y;
                    ClientToSurface(&m_ptStart);
                    BeginTextMode(m_ptStart);
                    break;

                default:
                    ERROR_OUT(("Unknown pen type"));
                    break;
            }
        }

        // Show that we are no longer tracking an object
        if (m_pGraphicTracker != NULL)
        {
	        m_pGraphicTracker = NULL;	// Don't delete the tracker since it is the drawing object
        }
	}

    // unclamp cursor (bug 589)
    ClipCursor(NULL);
}

//
//
// Function:    CompleteSelectMode
//
// Purpose:     Complete a select mode operation
//
//
void WbDrawingArea::CompleteSelectMode()
{
    // If an object is being dragged
    //if (m_pGraphicTracker != NULL)
    {
		// Check if we were dragging a pointer. Pointers track
		// themselves i.e. the original copy of the pointer is not
		// left on the page. We want to leave the last drawn image on
		// the page as this is the new pointer position.
		if( m_bTrackingSelectRect && (!EqualPoint(m_ptStart, m_ptEnd)))
		{
			CompleteMarkAreaMode();
			SelectMarkerFromRect( &m_rcMarkedArea );
		}
		else
		{

			// If we need to remove the rubber band box
			if (!EqualPoint(m_ptStart, m_ptEnd))
			{
				EraseInitialDrawFinal(m_ptStart.x - m_ptEnd.x , m_ptStart.y - m_ptEnd.y, TRUE);
				InvalidateSurfaceRect(&g_pDraw->m_selectorRect,TRUE);
				
			}
			else
			{
				// Start and end points were the same, in this case the object has
				// not been moved. We treat this as a request to move the marker
				// back through the stack of objects.
				if (m_bNewMarkedGraphic == FALSE)
				{
					SelectPreviousGraphicAt(m_pSelectedGraphic, m_ptEnd);
				}
			}

			m_bTrackingSelectRect = TRUE;
		}

		//
		// Make sure to delete the saved bitmap
		//
		if(m_pSelectedGraphic && m_pSelectedGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
		{
			((BitmapObj*)m_pSelectedGraphic)->DeleteSavedBitmap();

		}
	}
}




void WbDrawingArea::CompleteDeleteMode()
{
    // select object(s)
    CompleteSelectMode();


	//
	// If we are draging the remote pointer do nothing
	//
    if(m_pSelectedGraphic && m_pSelectedGraphic->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
    {
    	return;
    }

    // nuke 'em
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND, MAKELONG(IDM_DELETE, BN_CLICKED), 0);
}



//
//
// Function:	CompleteMarkAreaMode
//
// Purpose:	 Process a mouse button up event in mark area mode
//
//
void WbDrawingArea::CompleteMarkAreaMode(void)
{
	// Get a device context for tracking
	HDC hDC = m_hDCCached;

	// Erase the last ellipse (using XOR property)
	if (!EqualPoint(m_ptStart, m_ptEnd))
	{
		// Draw the rectangle
		m_pGraphicTracker->Draw();

		// Use normalized coords
		if (m_ptEnd.x < m_ptStart.x)
		{
			m_rcMarkedArea.left = m_ptEnd.x;
			m_rcMarkedArea.right = m_ptStart.x;
		}
		else
		{
			m_rcMarkedArea.left = m_ptStart.x;
			m_rcMarkedArea.right = m_ptEnd.x;
		}

		if (m_ptEnd.y < m_ptStart.y)
		{
			m_rcMarkedArea.top = m_ptEnd.y;
			m_rcMarkedArea.bottom = m_ptStart.y;
		}
		else
		{
			m_rcMarkedArea.top = m_ptStart.y;
			m_rcMarkedArea.bottom = m_ptEnd.y;
		}
	}
}

//
//
// Function:    CompleteTextMode
//
// Purpose:     Complete a text mode operation
//
//
void WbDrawingArea::CompleteTextMode()
{
    // Not much to for text mode. Main text mode actions are taken
    // as a result of a WM_CHAR message and not on mouse events.
    // Just deselect our font if it is still selected
    UnPrimeFont(m_hDCCached);
}


//
//
// Function:    CompleteDrawingMode
//
// Purpose:     Complete a draw mode operation
//
//
void WbDrawingArea::CompleteDrawingMode()
{
    // Only draw the line if it has non-zero length
    if (!EqualPoint(m_ptStart, m_ptEnd))
    {
        DrawObj *pObj;
        pObj = m_pGraphicTracker;
		
   		//
		// Erase the last traking
		//
		pObj->Draw();

		if(m_pToolCur->ToolType() == TOOLTYPE_PEN || m_pToolCur->ToolType() == TOOLTYPE_HIGHLIGHT)
		{
			// DO nothing because we drew it already and all the attributes are also already set
		    // Stop the update timer
		    ::KillTimer(m_hwnd, TIMER_GRAPHIC_UPDATE);
		}
		else
		{
	
			RECT rect;
			rect.left = m_ptStart.x;
			rect.top = m_ptStart.y;
			rect.right = m_ptEnd.x;
			rect.bottom = m_ptEnd.y;

			pObj->SetRect(&rect);
			pObj->SetPenThickness(m_pToolCur->GetWidth());
			::InflateRect(&rect, m_pToolCur->GetWidth()/2, m_pToolCur->GetWidth()/2);
			pObj->SetBoundsRect(&rect);

			pObj->SetPenColor(m_pToolCur->GetColor(), TRUE);
			pObj->SetFillColor(m_pToolCur->GetColor(), (m_pToolCur->ToolType() == TOOLTYPE_FILLEDELLIPSE || m_pToolCur->ToolType() == TOOLTYPE_FILLEDBOX));
			pObj->SetROP(m_pToolCur->GetROP());

			POINT deltaPoint;
			deltaPoint.x =   m_ptEnd.x - m_ptStart.x;
			deltaPoint.y =   m_ptEnd.y - m_ptStart.y;
			pObj->AddPoint(deltaPoint);

			//
			// Draw the object
			//
			pObj->Draw();
		}

		//
		// We are done with this drawing
		//
		pObj->SetIsCompleted(TRUE);

		pObj->SetViewState(unselected_chosen);

		//
		// If the object was alredy added just send an edit
		//
		if(pObj->GetMyWorkspace())
		{
			pObj->OnObjectEdit();
		}
		else
		{
			// Add the object to the list of objects
			pObj->AddToWorkspace();
		}
		
    }
    else
    {
		delete m_pGraphicTracker;
    }
   	m_pGraphicTracker =NULL;
}

//
//
// Function:    EndTextEntry
//
// Purpose:     The user has finished entering a text object. The parameter
//              indicates whether the changes are to be accepted or
//              discarded.
//
//
void WbDrawingArea::EndTextEntry(BOOL bAccept)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::EndTextEntry");

	WorkspaceObj * pWorkspace = m_pTextEditor->GetMyWorkspace();

	// Deactivate the text editor
	DeactivateTextEditor();

	if(bAccept &&( m_pTextEditor->strTextArray.GetSize()) )
	{
		if(!pWorkspace && m_pTextEditor->strTextArray.GetSize())
		{
			m_pTextEditor->AddToWorkspace();
		}
		else
		{
			if(m_pTextEditor->HasTextChanged())
			{
				m_pTextEditor->OnObjectEdit();
			}
		}

		//
		// Tell the other nodes they can edit this object now
		//
		m_pTextEditor->SetViewState(unselected_chosen);
		m_pTextEditor->OnObjectEdit();


	}
	else
	{
		//
		// if we were already added by a WM_TIMER message
		//
		if(pWorkspace)
		{

			//
			// Tell the other nodes we deleted this text.
			//
			m_pTextEditor->OnObjectDelete();			

			//
			// If we delete localy we add this object to the trash can, but we really want to delete it
			//
			m_pTextEditor->ClearDeletionFlags();
			pWorkspace->RemoveT126Object(m_pTextEditor);
		}
		else
		{
			delete m_pTextEditor;
		}
	}
	
	m_pTextEditor = NULL;
}

//
//
// Function:    Zoom
//
// Purpose:     Toggle the zoom state of the drawing area
//
//
void WbDrawingArea::Zoom(void)
{
    RECT    rcClient;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::Zoom");

    // We zoom focusing on the centre of the window
    ::GetClientRect(m_hwnd, &rcClient);
    long xOffset = (rcClient.right - (rcClient.right / m_iZoomOption)) / 2;
    long yOffset = (rcClient.bottom - (rcClient.bottom / m_iZoomOption)) / 2;

    if (m_iZoomFactor != 1)
    {
        // We are already zoomed move back to unzoomed state
        // First save the scroll position in case we return to zoom immediately
        m_posZoomScroll = m_posScroll;
        m_zoomRestoreScroll  = TRUE;

        m_posScroll.x  -= xOffset;
        m_posScroll.y  -= yOffset;
        ::ScaleViewportExtEx(m_hDCCached, 1, m_iZoomFactor, 1, m_iZoomFactor, NULL);
        m_iZoomFactor = 1;
    }
    else
    {
        // We are not zoomed so do it
        if (m_zoomRestoreScroll)
        {
            m_posScroll = m_posZoomScroll;
        }
        else
        {
            m_posScroll.x += xOffset;
            m_posScroll.y += yOffset;
        }

        m_iZoomFactor = m_iZoomOption;
        ::ScaleViewportExtEx(m_hDCCached, m_iZoomFactor, 1, m_iZoomFactor, 1, NULL);

        // ADDED BY RAND - don't allow text editing in zoom mode
        if( (m_pToolCur == NULL) || (m_pToolCur->ToolType() == TOOLTYPE_TEXT) )
            ::SendMessage(g_pMain->m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0 );
    }

    TRACE_MSG(("Set zoom factor to %d", m_iZoomFactor));

      // Update the scroll information
    SetScrollRange(rcClient.right, rcClient.bottom);
    ValidateScrollPos();

    ::SetScrollPos(m_hwnd, SB_HORZ, m_posScroll.x, TRUE);
    ::SetScrollPos(m_hwnd, SB_VERT, m_posScroll.y, TRUE);

    // Update the origin offset from the scroll position
    m_originOffset.cx = m_posScroll.x;
    m_originOffset.cy = m_posScroll.y;
    ::SetWindowOrgEx(m_hDCCached, m_originOffset.cx, m_originOffset.cy, NULL);

    // Tell the parent that the scroll position has changed
    ::PostMessage(g_pMain->m_hwnd, WM_USER_PRIVATE_PARENTNOTIFY, WM_VSCROLL, 0L);

    //
    // Update the tool/menu item states, since our zoom state has changed
    // and that will enable/disable some tools, etc.
    //
    g_pMain->SetMenuStates(::GetSubMenu(::GetMenu(g_pMain->m_hwnd), 3));

    // Redraw the window
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    SelectTool
//
// Purpose:     Set the current tool
//
//
void WbDrawingArea::SelectTool(WbTool* pToolNew)
{
	if(pToolNew == m_pToolCur)
	{
		return;
	}

    // If we are leaving text mode, complete the text entry
    if (m_bTextEditorActive  && (m_pToolCur->ToolType() == TOOLTYPE_TEXT)
      && (pToolNew->ToolType() != TOOLTYPE_TEXT))
  {
    // End text entry accepting the changes
    EndTextEntry(TRUE);
  }

  // If we are no longer in select mode, and the marker is present,
  // then remove it and let the tool know it's no longer selected
  if (m_pToolCur != NULL)
  {
    RemoveMarker();
    m_pSelectedGraphic = NULL;
  }

    // Save the new tool
    m_pToolCur = pToolNew;
}

//
//
// Function:    SetSelectionColor
//
// Purpose:     Set the color of the selected object
//
//
void WbDrawingArea::SetSelectionColor(COLORREF clr)
{
    RECT    rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionColor");

	if(g_pCurrentWorkspace)
	{
		RECT rect;
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				//
				// Set the new pen color
				//
				pObj->SetPenColor(clr, TRUE);
				pObj->SetFillColor(clr, (pObj->GraphicTool() == TOOLTYPE_FILLEDELLIPSE || pObj->GraphicTool() == TOOLTYPE_FILLEDBOX));
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
	
	
	
    // If the text editor is active - redraw the text in the new color
    if (m_bTextEditorActive)
    {
        // Change the color being used by the editor
        m_pTextEditor->SetPenColor(clr, TRUE);

        // Update the screen
        m_pTextEditor->GetBoundsRect(&rc);
        InvalidateSurfaceRect(&rc, TRUE);
    }

}

//
//
// Function:    SetSelectionWidth
//
// Purpose:     Set the nib width used to draw the currently selected object
//
//
void WbDrawingArea::SetSelectionWidth(UINT uiWidth)
{
	if(g_pCurrentWorkspace)
	{
		RECT rect;
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				//
				// Undraw the object
				//
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Get the correct width for each object
				//
				WbTool*   pSelectedTool = g_pMain->m_ToolArray[pObj->GraphicTool()];
				pSelectedTool->SetWidthIndex(uiWidth);
				pObj->SetPenThickness(pSelectedTool->GetWidth());

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
}

//
//
// Function:    SetSelectionFont
//
// Purpose:     Set the font used by the currently selected object
//
//
void WbDrawingArea::SetSelectionFont(HFONT hFont)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SetSelectionFont");


    // Define rectangles for redrawing
    RECT    rcOldBounds;
    RECT    rcNewBounds;


    // Pass the font onto the text editor
    // If the text editor is active - redraw the text in the new font
    if (m_bTextEditorActive)
    {
	    m_pTextEditor->GetBoundsRect(&rcOldBounds);

		m_pTextEditor->SetFont(hFont);

        // Get the new rectangle of the text
        m_pTextEditor->GetBoundsRect(&rcNewBounds);

        // Remove and destroy the text cursor to ensure that it
        // gets re-drawn with the new size for the font

        // Update the screen
        InvalidateSurfaceRect(&rcOldBounds, TRUE);
        InvalidateSurfaceRect(&rcNewBounds, TRUE);

        // get the text cursor back
        ActivateTextEditor( TRUE );
    }

	if(g_pCurrentWorkspace)
	{
		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() == TOOLTYPE_TEXT)
			{
				//
				// Set the new pen color
				//
				((TextObj*)pObj)->SetFont(hFont);
				pObj->UnDraw();
				pObj->DrawRect();

				//
				// Send it to other nodes
				//
				pObj->OnObjectEdit();

				//
				// Draw it locally
				//
				pObj->Draw();
			}
		}	
	}
}

//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbDrawingArea::OnSetFocus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::OnSetFocus");

    //
    // If we are in text mode, we must make the text cursor visible.
    //
    if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
    {
        ActivateTextEditor(TRUE);
    }
}


//
//
// Function:    OnActivate
//
// Purpose:     The window is being activated or deactivated
//
//
void WbDrawingArea::OnActivate(UINT uiState)
{
    // Check if we are being activated or deactivated
    if (uiState)
    {
        // We are being activated, get the focus as well
        ::SetFocus(m_hwnd);

        // If we are in text mode, we must make the text cursor visible
        if (m_bTextEditorActive && (m_pToolCur->ToolType() == TOOLTYPE_TEXT))
        {
            ActivateTextEditor(TRUE);
        }
    }
    else
    {
        // We are being deactivated
        DeactivateTextEditor();
    }
}

//
//
// Function:    DeleteSelection
//
// Purpose:     Delete the currently selected object
//
//
void WbDrawingArea::DeleteSelection()
{
	m_pSelectedGraphic = NULL;
}

//
//
// Function:    GetSelection
//
// Purpose:     Return the currently selected graphic (or NULL if none).
//
//
T126Obj* WbDrawingArea::GetSelection()
{
  T126Obj* pGraphic = NULL;

  // If there is an object currently selected...
  if (GraphicSelected())
  {
    // ...return it
    pGraphic = m_pSelectedGraphic;
  }

  return pGraphic;
}

//
//
// Function:    BringToTopSelection
//
// Purpose:     Bring the currently selected object to the top
//
//
LRESULT WbDrawingArea::BringToTopSelection(BOOL editedLocally, T126Obj * pT126Obj)
{
	T126Obj* pObj;
	WBPOSITION posTail;
	WBPOSITION pos;
	WBPOSITION myPos;
	WorkspaceObj *pWorkspace;

	if(pT126Obj)
	{
		pos = pT126Obj->GetMyPosition();
		pWorkspace = pT126Obj->GetMyWorkspace();
	}
	else
	{
		pos = g_pCurrentWorkspace->GetHeadPosition();
		pWorkspace = g_pCurrentWorkspace;
	}


	posTail = pWorkspace->GetTailPosition();


	while(pos && pos != posTail)
	{
		pObj = pWorkspace->GetNextObject(pos);

		//
		// If the graphic is selected
		//
		if( pObj && (pObj->IsSelected() &&
		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pObj->WasSelectedLocally()) ||
		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		((!editedLocally && pObj->WasSelectedRemotely())))))
		{
			myPos = pObj->GetMyPosition();
			pObj = pWorkspace->RemoveAt(myPos);
			pWorkspace->AddTail(pObj);

			if(pT126Obj)
			{
				::InvalidateRect(m_hwnd, NULL, TRUE);
				return  S_OK;
			}
			
			//
			// send change of z order
			//
			pObj->ResetAttrib();
			pObj->SetZOrder(front);
			pObj->OnObjectEdit();

			//
			// Unselect it
			//
			pObj->UnselectDrawingObject();

			RECT rect;
			pObj->GetBoundsRect(&rect);
			InvalidateSurfaceRect(&rect,TRUE);

		}
	}
	return S_OK;
}

//
//
// Function:    SendToBackSelection
//
// Purpose:     Send the currently marked object to the back
//
//
LRESULT WbDrawingArea::SendToBackSelection(BOOL editedLocally, T126Obj * pT126Obj)
{
	// If there is an object currently selected...
	T126Obj* pObj;
	WBPOSITION posHead;
	WBPOSITION myPos;
	WBPOSITION pos;
	WorkspaceObj *pWorkspace;

	if(pT126Obj)
	{
		pos = pT126Obj->GetMyPosition();
		pWorkspace = pT126Obj->GetMyWorkspace();
	}
	else
	{
		pos = g_pCurrentWorkspace->GetTailPosition();
		pWorkspace = g_pCurrentWorkspace;

	}

	posHead = pWorkspace->GetHeadPosition();

	while(pos && pos != posHead)
	{
		pObj = pWorkspace->GetPreviousObject(pos);
		//
		// If the graphic is selected
		//
		if( (pObj->IsSelected() &&
		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pObj->WasSelectedLocally()) ||
		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		((!editedLocally && pObj->WasSelectedRemotely())))))
		{
			myPos = pObj->GetMyPosition();
			pObj = pWorkspace->RemoveAt(myPos);
			pWorkspace->AddHead(pObj);

			if(pT126Obj)
			{
				::InvalidateRect(m_hwnd, NULL, TRUE);
				return  S_OK;
			}

			//
			// send change of z order
			//
			pObj->ResetAttrib();
			pObj->SetZOrder(back);
			pObj->OnObjectEdit();

			//
			// Unselect it
			//
			pObj->UnselectDrawingObject();

			RECT rect;
			pObj->GetBoundsRect(&rect);
			::InvalidateRect(m_hwnd, NULL , TRUE);
		}
	}
	return S_OK;
}

//
//
// Function:    Clear
//
// Purpose:     Clear the drawing area.
//
//
void WbDrawingArea::Clear()
{
    // Remove the recorded objects
//    PG_Clear(m_hPage);

  // The page will be redrawn after an event generated by the clear request
}

//
//
// Function:    Attach
//
// Purpose:     Change the page the window is displaying
//
//
void WbDrawingArea::Attach(WorkspaceObj* pNewWorkspace)
{

    // Accept any text being edited
    if (m_bTextEditorActive)
    {
        EndTextEntry(TRUE);
    }

    // finish any drawing operation now
    if (m_bLButtonDown)
    {
        OnLButtonUp(0, m_ptStart.x, m_ptStart.y);
    }

    // Get rid of the selection
    ClearSelection();

    // Save the new page details
    g_pCurrentWorkspace = pNewWorkspace;

	if(IsSynced())
	{
		g_pConferenceWorkspace = g_pCurrentWorkspace;
	}



    // Force a redraw of the window to show the new contents
    ::InvalidateRect(m_hwnd, NULL, TRUE);
}

//
//
// Function:    DrawMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::DrawMarker(HDC hDC)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DrawMarker");

    // Draw the marker
    m_pMarker->Draw();
}

//
//
// Function:    PutMarker
//
// Purpose:     Draw the graphic object marker
//
//
void WbDrawingArea::PutMarker(HDC hDC, BOOL bDraw)
{
}

//
//
// Function:    RemoveMarker
//
// Purpose:     Remove the graphic object marker
//
//
void WbDrawingArea::RemoveMarker()
{
	if(g_pCurrentWorkspace)
	{
	    T126Obj* pObj;
		WBPOSITION pos;
		pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				pObj->UnselectDrawingObject();
			}
		}	
	}
}




//
//
// Function:    ActivateTextEditor
//
// Purpose:     Start a text editing session
//
//
void WbDrawingArea::ActivateTextEditor( BOOL bPutUpCusor )
{
    // Record that the editor is now active
    m_bTextEditorActive = TRUE;

    // show editbox
    m_pTextEditor->ShowBox( SW_SHOW );

    // Start the timer for updating the text
    m_pTextEditor->SetTimer( DRAW_GRAPHICUPDATEDELAY);
}

//
//
// Function:    DeactivateTextEditor
//
// Purpose:     End a text editing session
//
//
void WbDrawingArea::DeactivateTextEditor(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::DeactivateTextEditor");

    // Stop the update timer
    m_pTextEditor->KillTimer();

    // Show that we are not editing any text
    m_bTextEditorActive = FALSE;

	// hide editbox
    m_pTextEditor->ShowBox( SW_HIDE );

}



//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a point in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPPOINT lppoint)
{
    lppoint->x -= m_originOffset.cx;
    lppoint->x *= m_iZoomFactor;

    lppoint->y -= m_originOffset.cy;
    lppoint->y *= m_iZoomFactor;
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a point in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPPOINT lppoint)
{
    ASSERT(m_iZoomFactor != 0);

    lppoint->x /= m_iZoomFactor;
    lppoint->x += m_originOffset.cx;

    lppoint->y /= m_iZoomFactor;
    lppoint->y += m_originOffset.cy;
}


//
//
// Function:    SurfaceToClient
//
// Purpose:     Convert a rectangle in surface co-ordinates to client
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::SurfaceToClient(LPRECT lprc)
{
    SurfaceToClient((LPPOINT)&lprc->left);
    SurfaceToClient((LPPOINT)&lprc->right);
}

//
//
// Function:    ClientToSurface
//
// Purpose:     Convert a rectangle in client co-ordinates to surface
//              co-ordinates (taking account of the current zoom factor).
//
//
void WbDrawingArea::ClientToSurface(LPRECT lprc)
{
    ClientToSurface((LPPOINT)&lprc->left);
    ClientToSurface((LPPOINT)&lprc->right);
}

//
//
// Function:    GraphicSelected
//
// Purpose:     Return TRUE if a graphic is currently selected
//
//
BOOL WbDrawingArea::GraphicSelected(void)
{

	if(g_pCurrentWorkspace)
	{

		T126Obj* pObj;
		WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
			if(pObj && pObj->WasSelectedLocally())
			{
				m_pSelectedGraphic = pObj;
				return TRUE;
			}
		}	
	}

	return FALSE;
}




BOOL WbDrawingArea::MoveSelectedGraphicBy(LONG x, LONG y)
{

    T126Obj* pObj;
	WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();

	while(pos)
	{
		pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally())
		{
			pObj->MoveBy(x, y);
		}
	}	

	return FALSE;
}

void WbDrawingArea::EraseSelectedDrawings(void)
{

    T126Obj* pObj;
	//
	// Burn trash
	//
	pObj = (T126Obj *)g_pTrash->RemoveTail();
    while (pObj != NULL)
    {
		delete pObj;
		pObj = (T126Obj *) g_pTrash->RemoveTail();
	}

	WBPOSITION pos = g_pCurrentWorkspace->GetHeadPosition();
	while(pos)
	{
		pObj = (T126Obj*)g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() != TOOLTYPE_REMOTEPOINTER)
		{
			pObj->DeletedLocally();
			g_pCurrentWorkspace->RemoveT126Object(pObj);
		}
	}
}

void WbDrawingArea::EraseInitialDrawFinal(LONG x, LONG y, BOOL editedLocally, T126Obj* pObj)

{

    T126Obj* pGraphic;
    WorkspaceObj * pWorkspace;	WBPOSITION pos;
	
	if(pObj)
	{
	 	pWorkspace = pObj->GetMyWorkspace();
		pGraphic = pObj;
	}
	else
	{
		pWorkspace = g_pCurrentWorkspace;
	}

	//
	// Check if the objects workspace is valid or if there is a current workspace
	//
	if(pWorkspace == NULL)
	{
		return;
	}

	pos = pWorkspace->GetHeadPosition();

	while(pos)
	{
		// if we are talking about an specifc object
		if(!pObj)
		{
			pGraphic = (T126Obj*)pWorkspace->GetNextObject(pos);
		}

		//
		// If the graphic is selected
		//
		if(pGraphic &&

		//
		// We were called locally and the graphic is selected locally
		//
		((editedLocally && pGraphic->WasSelectedLocally()) ||

		//
		// We were called because the graphic got edited remotely
		// and it is selected remotely
		//
		(!editedLocally)))
		
		{

			POINT finalAnchorPoint;
			RECT initialRect;
			RECT rect;
			RECT initialBoundsRect;
			RECT boundsRect;

			//
			// Get The final Rects
			//
			pGraphic->GetRect(&rect);
			pGraphic->GetBoundsRect(&boundsRect);
			initialRect = rect;
			initialBoundsRect = boundsRect;
			pGraphic->GetAnchorPoint(&finalAnchorPoint);


			//
			// Find out were the drawing was
			//
			::OffsetRect(&initialRect, x, y);
			::OffsetRect(&initialBoundsRect, x, y);
			pGraphic->SetRect(&initialRect);
			pGraphic->SetBoundsRect(&initialBoundsRect);
			
			pGraphic->SetAnchorPoint(finalAnchorPoint.x + x, finalAnchorPoint.y + y);

			//
			// Erase initial drawing
			//
			pGraphic->UnDraw();

			//
			//Erase the selection rectangle only if we selected locally
			//
			if(editedLocally)
			{
				pGraphic->DrawRect();
			}

			//
			// The only attributes we want to send unselected and anchorpoint
			//
			pGraphic->ResetAttrib();
			
			//
			// Restore rectangles and draw the object in the final position
			//
			pGraphic->SetRect(&rect);
			pGraphic->SetBoundsRect(&boundsRect);
			pGraphic->SetAnchorPoint(finalAnchorPoint.x, finalAnchorPoint.y);
			pGraphic->Draw(FALSE);

			//
			// Don't send it if it was not created locally
			//
			if(editedLocally)
			{
				pGraphic->EditedLocally();

				//
				// Sends the final drawing to the other nodes
				//
				pGraphic->OnObjectEdit();

				//
				// This will remove the selection box and send a
				// edit PDU telling other nodes the object is not selected
				//
				pGraphic->UnselectDrawingObject();
			}
		}

		//
		// Just moved one specifc object
		//
		if(pObj != NULL)
		{
			return;
		}
	
	}	
}




//
//
// Function:    SelectGraphic
//
// Purpose:     Select a graphic - save the pointer to the graphic and
//              draw the marker on it.
//
//
void WbDrawingArea::SelectGraphic(T126Obj* pGraphic,
                                      BOOL bEnableForceAdd,
                                      BOOL bForceAdd )
{
    BOOL bZapCurrentSelection;
    RECT rc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::SelectGraphic");

	if(pGraphic->IsSelected() && pGraphic->WasSelectedLocally())
	{
		pGraphic->UnselectDrawingObject();
		return;
	}
	else if(pGraphic->IsSelected() && pGraphic->WasSelectedRemotely())
	{
		return;
	}
	else
	{

		// new selection, add to list or replace list?
		if( bEnableForceAdd )
		{
			bZapCurrentSelection = !bForceAdd;
		}
		else
		{
			bZapCurrentSelection = ((GetAsyncKeyState( VK_SHIFT ) >= 0) && (GetAsyncKeyState( VK_CONTROL ) >= 0));
		}
	
		if( bZapCurrentSelection )
		{
			// replace list
			RemoveMarker();
		}
	}


   // Update the attributes window to show graphic is selected
    m_pToolCur->SelectGraphic(pGraphic);
	pGraphic->SelectDrawingObject();

    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
    }
}

//
//
// Function:    DeselectGraphic
//
// Purpose:     Deselect a graphic - remove the marker and delete the
//              graphic object associated with it.
//
//
void WbDrawingArea::DeselectGraphic(void)
{
    HWND hwndParent = ::GetParent(m_hwnd);
    if (hwndParent != NULL)
    {
        ::PostMessage(hwndParent, WM_USER_UPDATE_ATTRIBUTES, 0, 0);
    }
}



//
//
// Function:    GetVisibleRect
//
// Purpose:     Return the rectangle of the surface currently visible in the
//              drawing area window.
//
//
void WbDrawingArea::GetVisibleRect(LPRECT lprc)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::VisibleRect");

    // Get the client rectangle
    ::GetClientRect(m_hwnd, lprc);

    // Convert to surface co-ordinates
    ClientToSurface(lprc);
}


//
//
// Function:    MoveOntoSurface
//
// Purpose:     If a given point is outwith the surface rect, move it on
//
//
void WbDrawingArea::MoveOntoSurface(LPPOINT lppoint)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::MoveOntoSurface");

    //
    // Make sure that the position is within the surface rect
    //

    if (lppoint->x < 0)
    {
        lppoint->x = 0;
    }
    else if (lppoint->x >= DRAW_WIDTH)
    {
        lppoint->x = DRAW_WIDTH - 1;
    }

    if (lppoint->y < 0)
    {
        lppoint->y = 0;
    }
    else if (lppoint->y >= DRAW_HEIGHT)
    {
        lppoint->y = DRAW_HEIGHT - 1;
    }
}


//
//
// Function:    GetOrigin
//
// Purpose:     Provide current origin of display
//
//
void WbDrawingArea::GetOrigin(LPPOINT lppoint)
{
    lppoint->x = m_originOffset.cx;
    lppoint->y = m_originOffset.cy;
}



void WbDrawingArea::ShutDownDC(void)
{
    UnPrimeDC(m_hDCCached);

    if (m_hDCWindow != NULL)
    {
        ::ReleaseDC(m_hwnd, m_hDCWindow);
        m_hDCWindow = NULL;
    }

    m_hDCCached = NULL;
}




void WbDrawingArea::ClearSelection( void )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbDrawingArea::ClearSelection");

    RemoveMarker();

    g_pMain->OnUpdateAttributes();
}





void WbDrawingArea::OnCancelMode( void )
{
    // We were dragging but lost mouse control, gracefully end the drag (NM4db:573)
    POINT pt;

    ::GetCursorPos(&pt);
    ::ScreenToClient(m_hwnd, &pt);
    OnLButtonUp(0, pt.x, pt.y);
    m_bLButtonDown = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\clpbd.cpp ===
//
// CLPBD.CPP
// Clipboard Handling
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"



//
// NFC, SFR 5921.  Maximum length of a string pasted from the clipboard.
// We impose this limit as our graphic object code cant
// handle more then this number of chars.
//
#define WB_MAX_TEXT_PASTE_LEN  (INT_MAX-1)

//
//
// Function:    Paste
//
// Purpose:     Paste a format from the clipboard
//
//
BOOL WbMainWindow::CLP_Paste(void)
{
	UINT		length = 0;
	HANDLE		handle = NULL;
	T126Obj*	pGraphic = NULL;
	BOOL bResult = FALSE;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Paste");

	// Get the highest priority acceptable format in the clipboard
	int iFormat = CLP_AcceptableClipboardFormat();
	if (!iFormat)
		goto NoOpenClip;

	TRACE_MSG(("Found acceptable format %d", iFormat));

	// Open the clipboard

	if (!::OpenClipboard(m_hwnd))
	{
		WARNING_OUT(("CLP_Paste: can't open clipboard"));
		goto NoOpenClip;
	}

	handle = ::GetClipboardData(iFormat);
	if (!handle)
	{
		WARNING_OUT(("CLP_Paste: can't get data for format %d", iFormat));
		goto NoFormatData;
	}

	switch (iFormat)
	{
		//
		// Check the standard formats
		//
		case CF_DIB:
		{
			TRACE_MSG(("Pasting CF_DIB"));

			// Lock the handle to get a pointer to the DIB
			LPBITMAPINFOHEADER lpbi;
			lpbi = (LPBITMAPINFOHEADER) ::GlobalLock(handle);
			if (lpbi != NULL)
			{
				bResult= PasteDIB(lpbi);

				// Release the memory
				::GlobalUnlock(handle);
			}

		
		}
		break;

		//
		// We have a metafile. Play it into a bitmap and then use the
		// data.
		//
		case CF_ENHMETAFILE:
		{
			TRACE_MSG(("Pasting CF_ENHMETAFILE"));

			HDC		 hDrawingDC;
			ENHMETAHEADER meta_header;
			HBITMAP	 hBitmap = NULL;
			HDC		 meta_dc = NULL;
			HBITMAP	 hSaveBitmap;
			HPEN		hSavePen;
			HPALETTE	hPalette;
			RECT		meta_rect;
			LPBITMAPINFOHEADER lpbiNew;
			int		 tmp;

			// We just need a DC compatible with the drawing area wnd
			hDrawingDC = m_drawingArea.GetCachedDC();

			// make a dc
			meta_dc = ::CreateCompatibleDC(hDrawingDC);
			if (!meta_dc)
				goto CleanupMetaFile;

			// figure out image size.
			::GetEnhMetaFileHeader( (HENHMETAFILE)handle,
									  sizeof( ENHMETAHEADER ),
									  &meta_header );
			meta_rect.left = meta_rect.top = 0;

			meta_rect.right = ((meta_header.rclFrame.right - meta_header.rclFrame.left)
				* ::GetDeviceCaps(hDrawingDC, LOGPIXELSX ))/2540;

			meta_rect.bottom = ((meta_header.rclFrame.bottom - meta_header.rclFrame.top)
				* ::GetDeviceCaps(hDrawingDC, LOGPIXELSY ))/2540;

			// Normalize coords
			if (meta_rect.right < meta_rect.left)
			{
				tmp = meta_rect.left;
				meta_rect.left = meta_rect.right;
				meta_rect.right = tmp;
			}
			if (meta_rect.bottom < meta_rect.top)
			{
				tmp = meta_rect.top;
				meta_rect.top = meta_rect.bottom;
				meta_rect.bottom = tmp;
			}

			// make a place to play meta in
			hBitmap = ::CreateCompatibleBitmap(hDrawingDC,
				meta_rect.right - meta_rect.left,
				meta_rect.bottom - meta_rect.top);
			if (!hBitmap)
				goto CleanupMetaFile;

			hSaveBitmap = SelectBitmap(meta_dc, hBitmap);

			// erase our paper
			hSavePen = SelectPen(meta_dc, GetStockObject(NULL_PEN));

			::Rectangle(meta_dc, meta_rect.left, meta_rect.top,
				meta_rect.right + 1, meta_rect.bottom + 1);

			SelectPen(meta_dc, hSavePen);

			// play the tape
			::PlayEnhMetaFile(meta_dc, (HENHMETAFILE)handle, &meta_rect);

			// unplug our new bitmap
			SelectBitmap(meta_dc, hSaveBitmap);

			// Check for a palette object in the clipboard
			hPalette = (HPALETTE)::GetClipboardData(CF_PALETTE);

			// Create a new DIB from the bitmap
		   	lpbiNew = DIB_FromBitmap(hBitmap, hPalette, FALSE, FALSE);

			if(lpbiNew != NULL)
			{
				bResult= PasteDIB(lpbiNew);
			}

CleanupMetaFile:
			// Free our temp intermediate bitmap
			if (hBitmap != NULL)
			{
				DeleteBitmap(hBitmap);
			}

			if (meta_dc != NULL)
			{
				::DeleteDC(meta_dc);
			}
		}
		break;

		case CF_TEXT:
		{
			LPSTR   pData;

			TRACE_DEBUG(("Pasting text"));

            // Get a handle to the clipboard contents
            pData = (LPSTR)::GlobalLock(handle);

			if(pData)
			{
	            // Create a text object to hold the data - get the font to
	            // use from the tool attributes group.
				DBG_SAVE_FILE_LINE
	            WbTextEditor* pPasteText = new WbTextEditor();

    	        // Use the current font attributes
                if (!pPasteText)
                {
                    ERROR_OUT(("CF_TEXT handling; failed to allocate DCWbGraphicText object"));
                }
                else
                {
                    pPasteText->SetFont(m_pCurrentTool->GetFont());
    	            pPasteText->SetText(pData);
					
					RECT    rcVis;
					m_drawingArea.GetVisibleRect(&rcVis);
					pPasteText->SetPenColor(RGB(0,0,0),TRUE);
					pPasteText->SetAnchorPoint(0, 0);
					pPasteText->MoveTo(rcVis.left, rcVis.top);
					pPasteText->Draw();
					pPasteText->m_pEditBox = NULL;

					// Add the new grabbed bitmap
					pPasteText->SetAllAttribs();
					pPasteText->AddToWorkspace();
					bResult = TRUE;
                }

        	    pGraphic = pPasteText;
            }

		}
		break;

		default:
		{
			if (iFormat == g_ClipboardFormats[CLIPBOARD_PRIVATE])
			{

				WB_OBJ objectHeader;
				UINT type;
				ULONG nItems = 0;
			
				PBYTE pClipBoardBuffer;
				if (pClipBoardBuffer = (PBYTE) ::GlobalLock(handle))
				{

					//
					// Count objects before we paste.
					//
					PBYTE pClipBuff = pClipBoardBuffer;
					length = ((PWB_OBJ)pClipBuff)->length;
					pClipBuff += sizeof(objectHeader);
					while(length)
					{
						nItems++;
						pClipBuff += length;
						length = ((PWB_OBJ)pClipBuff)->length;
						pClipBuff += sizeof(objectHeader);
					}

					TimeToGetGCCHandles(nItems);

					length = ((PWB_OBJ)pClipBoardBuffer)->length;
					type = ((PWB_OBJ)pClipBoardBuffer)->type;
					pClipBoardBuffer += sizeof(objectHeader);
					
					while(length)
					{
						if(type == TYPE_T126_ASN_OBJECT)
						{
							bResult = T126_MCSSendDataIndication(length, pClipBoardBuffer, g_MyMemberID, TRUE);
						}
						else if(type == TYPE_T126_DIB_OBJECT)
						{
							bResult = PasteDIB((LPBITMAPINFOHEADER)pClipBoardBuffer);
						}
						
						pClipBoardBuffer += length;
						length = ((PWB_OBJ)pClipBoardBuffer)->length;
						type = ((PWB_OBJ)pClipBoardBuffer)->type;
						pClipBoardBuffer += sizeof(objectHeader);
					}
				
					// Release the handle
					::GlobalUnlock(handle);
				}				   
			}
		}
		break;
	}

NoFormatData:
	::CloseClipboard();

NoOpenClip:
	return bResult;
}


//
//
// Function:	Copy
//
// Purpose:	 Copy a graphic to the clipboard.
//
//
BOOL WbMainWindow::CLP_Copy()
{
	BOOL bResult = FALSE;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_Copy");

	//
	// We act according to the format of the selected graphic.
	//
	// For all formats we supply the Whiteboard private format (which is
	// just a copy of the flat representation of the graphic).
	//
	// We supply standard formats as follows.
	//
	// For bitmaps and all others we supply CF_DIB.
	//
	// For text graphics we supply CF_TEXT.
	//

	TRACE_MSG(("Rendering the graphic now"));

	// Have to empty the clipboard before rendering the formats.
	if (::OpenClipboard(m_hwnd))
	{
		// Get ownership of the clipboard
		::EmptyClipboard();
		::CloseClipboard();

		// Render the graphic
		bResult = CLP_RenderAllFormats();
	}


	return bResult;
}


//
//
// Function:	RenderAllFormats
//
// Purpose:	 Render a graphic to the clipboard
//
//
BOOL WbMainWindow::CLP_RenderAllFormats()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAllFormats");
	BOOL bResult = FALSE;

	// Open the clipboard
	if (bResult = ::OpenClipboard(m_hwnd))
	{
		TRACE_DEBUG(("Rendering all formats of graphic"));

		// Render the private format
		bResult &= CLP_RenderPrivateFormat();

		// Text graphic
		bResult &= CLP_RenderAsText();

		// DIBs
//		bResult &= CLP_RenderAsImage();

		// Bitmaps
		bResult &= CLP_RenderAsBitmap();

		// Close the clipboard
		::CloseClipboard();
	}

	return bResult;
}


//
//
// Function:	CLP_RenderPrivateFormat
//
// Purpose:	 Render the private format of a graphic to the clipboard.
//			  The clipboard should be open before this call is made.
//
//
BOOL WbMainWindow::CLP_RenderPrivateFormat()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderPrivateFormat");

	BOOL bResult = FALSE;
	LPBYTE pDest = NULL;
	HGLOBAL hMem = NULL;
	HGLOBAL hRealloc = NULL;
	WB_OBJ objectHeader; 
	ULONG length = sizeof(objectHeader);
	BOOL	bDoASN1CleanUp = FALSE;
	
	
	ULONG previousLength = 0;

	WBPOSITION pos;
	T126Obj * pObj;
	ASN1_BUF encodedPDU;

	pos = g_pCurrentWorkspace->GetHeadPosition();

	while(pos)
	{
		pObj = g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally())
		{

			//
			// Get the encoded buffer
			//
			pObj->SetAllAttribs();
			pObj->SetViewState(unselected_chosen);
			pObj->GetEncodedCreatePDU(&encodedPDU);
			objectHeader.length = encodedPDU.length;


			if(pObj->GetType() == bitmapCreatePDU_chosen)
			{
				objectHeader.type = TYPE_T126_DIB_OBJECT;
			}
			else if(pObj->GetType() == drawingCreatePDU_chosen  || pObj->GetType() == siNonStandardPDU_chosen)
			{
				objectHeader.type = TYPE_T126_ASN_OBJECT;
				bDoASN1CleanUp = TRUE;
			}
			
			length += encodedPDU.length + sizeof(objectHeader);

			if(pDest)
			{
				hRealloc = ::GlobalReAlloc(hMem, length, GMEM_MOVEABLE | GMEM_DDESHARE);
				if(!hRealloc)
				{
					goto bail;
				}
				hMem = hRealloc;
			
			}
			else
			{
				// Allocate memory for the clipboard data
				hMem = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, length);
				if(hMem == NULL)
				{
					goto bail;
				}
			}


			//
			// Get a pointer to the destination
			//
			pDest = (LPBYTE)::GlobalLock(hMem);

			//
			// Write the header
			//
			memcpy(pDest + previousLength, &objectHeader, sizeof(objectHeader));
			previousLength += sizeof(objectHeader);

			//
			// Copy the decoded data in the destination
			//
			memcpy(pDest + previousLength, encodedPDU.value, encodedPDU.length);
			previousLength += encodedPDU.length;

			//
			// Terminate the block with a 0 
			//
			objectHeader.length = 0;
			memcpy(pDest + previousLength, &objectHeader, sizeof(objectHeader));
		
			//
			// Free the encoded data
			//	
			if(bDoASN1CleanUp)
			{
				g_pCoder->Free(encodedPDU);
				bDoASN1CleanUp = FALSE;
			}
		}
	}

	// Release the memory
	::GlobalUnlock(hMem);

	// Pass the data to the clipboard
	if (::SetClipboardData(g_ClipboardFormats[CLIPBOARD_PRIVATE], hMem))
	{
			TRACE_DEBUG(("Rendered data in Whiteboard format"));
			bResult = TRUE;
	}

bail:



	if(bDoASN1CleanUp)
	{
		g_pCoder->Free(encodedPDU);
	}

	// If we failed to put the data into the clipboard, free the memory.
	// (If we did put it into the clipboard we must not free it).
	if (bResult == FALSE)
	{
		WARNING_OUT(("Render failed"));
		::GlobalFree(hMem);
	}

	return bResult;
}

//
//
// Function:	RenderAsText
//
// Purpose:	 Render the text format of a graphic to the clipboard.
//			  The clipboard should be open before this call is made.
//			  This member should only be called for text graphics.
//
//
BOOL WbMainWindow::CLP_RenderAsText()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsText");

    BOOL bResult = TRUE;

	WBPOSITION pos;

	T126Obj * pObj;
	pos = g_pCurrentWorkspace->GetHeadPosition();
	while(pos)
	{
		pObj = g_pCurrentWorkspace->GetNextObject(pos);
		if(pObj && pObj->WasSelectedLocally() && pObj->GraphicTool() == TOOLTYPE_TEXT)
		{

			// Get the total length of the clipboard format of the text
			StrArray& strText = ((TextObj*) pObj)->strTextArray;
			int   iCount = strText.GetSize();
			int   iIndex;
			DWORD dwLength = 0;

			for (iIndex = 0; iIndex < iCount; iIndex++)
			{
				// Length of string plus 2 for carriage return and line feed
				dwLength += lstrlen(strText[iIndex]) + 2;
			}

			// One more for the terminating NULL
			dwLength += 1;

			// Allocate memory for the clipboard data
			HANDLE hMem = ::GlobalAlloc(GHND, dwLength);
			if (hMem != NULL)
			{
				// Get a pointer to the memory
				LPSTR pDest = (LPSTR) ::GlobalLock(hMem);
				if (pDest != NULL)
				{
					// Write the graphic data to the allocated memory
					for (iIndex = 0; iIndex < iCount; iIndex++)
					{
						_tcscpy(pDest, strText[iIndex]);
						pDest += lstrlen(strText[iIndex]);

						// Add the carriage return and line feed
						*pDest++ = '\r';
						*pDest++ = '\n';
					}

					// Add the final NULL
					*pDest = '\0';

					// Release the memory
					::GlobalUnlock(hMem);

					// Pass the data to the clipboard
					if (::SetClipboardData(CF_TEXT, hMem))
					{
						TRACE_DEBUG(("Rendered data in text format"));
					}
					else
					{
						bResult = FALSE;
					}
				}

				// If we failed to put the data into the clipboard, free the memory
				if (bResult == FALSE)
				{
					::GlobalFree(hMem);
				}
				

				break;		// JOSEF what about copying all the text objects in the clipboard
			}

		}
	}

    return bResult;
}


//
// CLP_RenderAsBitmap()
//
// This draws all other graphics into a bitmap and pastes the DIB contents
// onto the clipboard.
//
BOOL WbMainWindow::CLP_RenderAsBitmap()
{
	BOOL	bResult = FALSE;
	HDC	 hdcDisplay = NULL;
	HDC	 hdcMem = NULL;
	HBITMAP hBitmap = NULL;
	HBITMAP hOldBitmap = NULL;
	HPALETTE hPalette;
	RECT	rcBounds = g_pDraw->m_selectorRect;
	POINT   pt;
	LPBITMAPINFOHEADER lpbi;
	T126Obj * pObj = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CLP_RenderAsBitmap");

	//
	// First, draw this into a bitmap
	// Second, get the DIB bits of the bitmap
	//

	hdcDisplay = ::CreateDC("DISPLAY", NULL, NULL, NULL);
	if (!hdcDisplay)
	{
		ERROR_OUT(("Can't create DISPLAY dc"));
		goto AsBitmapDone;
	}

	hdcMem = ::CreateCompatibleDC(hdcDisplay);
	if (!hdcMem)
	{
		ERROR_OUT(("Can't create DISPLAY compatible dc"));
		goto AsBitmapDone;
	}

	hBitmap = ::CreateCompatibleBitmap(hdcDisplay,
		(rcBounds.right - rcBounds.left), (rcBounds.bottom - rcBounds.top));
	if (!hBitmap)
	{
		ERROR_OUT(("Can't create compatible bitmap"));
		goto AsBitmapDone;
	}

	hOldBitmap = SelectBitmap(hdcMem, hBitmap);
	if (!hOldBitmap)
	{
		ERROR_OUT(("Failed to select compatible bitmap"));
		goto AsBitmapDone;
	}

	::SetMapMode(hdcMem, MM_ANISOTROPIC);
	::SetWindowOrgEx(hdcMem, rcBounds.left,rcBounds.top, NULL);

	// Clear out bitmap with white background -- now that origin has been
	// altered, we can use drawing area coors.
	::PatBlt(hdcMem, rcBounds.left, rcBounds.top, rcBounds.right - rcBounds.left,
		rcBounds.bottom - rcBounds.top, WHITENESS);


		WBPOSITION pos;

		pos = g_pCurrentWorkspace->GetHeadPosition();

		while(pos)
		{
			pObj = g_pCurrentWorkspace->GetNextObject(pos);

			if(pObj && pObj->WasSelectedLocally())
			{
				pObj->Draw(hdcMem);
			}
		}

	SelectBitmap(hdcMem, hOldBitmap);

	// Now get the dib bits...
	hPalette = CreateSystemPalette();
	lpbi = DIB_FromBitmap(hBitmap, hPalette, TRUE, FALSE);
	if (hPalette != NULL)
		::DeletePalette(hPalette);

	// And put the handle on the clipboard
	if (lpbi != NULL)
	{
		if (::SetClipboardData(CF_DIB, (HGLOBAL)lpbi))
		{
			bResult = TRUE;
		}
		else
		{
			::GlobalFree((HGLOBAL)lpbi);
		}
	}

AsBitmapDone:
	if (hBitmap != NULL)
		::DeleteBitmap(hBitmap);

	if (hdcMem != NULL)
		::DeleteDC(hdcMem);

	if (hdcDisplay != NULL)
		::DeleteDC(hdcDisplay);

	return(bResult);
}

//
//
// Function:	AcceptableClipboardFormat
//
// Purpose:	 Return highest priority clipboard format if an acceptable
//			  one is available, else return NULL.
//
//
int WbMainWindow::CLP_AcceptableClipboardFormat(void)
{
	// Look for any of the supported formats being available
	int iFormat = ::GetPriorityClipboardFormat((UINT *)g_ClipboardFormats, CLIPBOARD_ACCEPTABLE_FORMATS);
	if (iFormat == -1)
	{
		iFormat = 0;
	}

	return iFormat;
}


BOOL WbMainWindow::PasteDIB( LPBITMAPINFOHEADER lpbi)
{
	BOOL bResult = FALSE;
	
	//
	// Create a bitmap object
	//
	BitmapObj* pDIB = NULL;
	DBG_SAVE_FILE_LINE
	pDIB = new BitmapObj(TOOLTYPE_FILLEDBOX);
    if(NULL == pDIB)
    {
        ERROR_OUT(("Failed to allocate new BitmapObj"));
        return FALSE;
    }
    
	pDIB->SetBitmapSize(lpbi->biWidth,lpbi->biHeight);

	RECT rect;
	// Calculate the bounding rectangle from the size of the bitmap
	rect.top = 0;
	rect.left = 0;
	rect.right = lpbi->biWidth;
	rect.bottom = lpbi->biHeight;
	pDIB->SetRect(&rect);
	pDIB->SetAnchorPoint(rect.left, rect.top);

	//
	// Make a copy of the clipboard data
	//
	pDIB->m_lpbiImage = DIB_Copy(lpbi);

	if(pDIB->m_lpbiImage!= NULL)
	{
		// Add the new bitmap
		AddCapturedImage(pDIB);
		bResult = TRUE;
	}
	else
	{
		delete pDIB;
	}

	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\coder.hpp ===
#ifndef _CODER_HPP
#define _CODER_HPP

#define ObjectID_       ASN1objectidentifier_s

typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}ASN1_BUF;

#include "t126.h"

extern "C" {
int T126_InitModule(void);
int T126_TermModule(void);
int T126_InitCoder(ASN1_CODER_INFO *pCoder);
int T126_TermCoder(ASN1_CODER_INFO *pCoder);
int T126_Encode(ASN1_CODER_INFO *pCoder, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int T126_Decode(ASN1_CODER_INFO *pCoder, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			20     // H225.0
#define RECOMM_NUMBER   126
#define VERSION         0
#define ADDITIONAL      1


class Coder{

private:
	ASN1_CODER_INFO		p_Coder;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(SIPDU *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, SIPDU **pOutputData);
	// Used to free buffer created by decode
	int Free(SIPDU *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns TRUE if protocols match, FALSE - otherwise

	__inline int freePDU(ASN1_CODER_INFO *pCoder, int nPDU, void *pDecoded, 
	ASN1module_t pModule)
	{
	    ASN1_FreeDecoded(pCoder->pDecInfo, pDecoded, nPDU);
	    return ASN1_SUCCESS;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\cgrp.cpp ===
//
// CGRP.CPP
// Color Group
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"


static const TCHAR szCGClassName[] = "T126WB_CGRP";

// These default colors are the same as MSPaint
COLORREF g_crDefaultColors[NUMCLRPANES] =
{
        PALETTERGB(   0,  0,  0 ),
        PALETTERGB( 128,128,128 ),
        PALETTERGB( 128,  0,  0 ),
        PALETTERGB( 128,128,  0 ),
        PALETTERGB(   0,128,  0 ),
        PALETTERGB(   0,128,128 ),
        PALETTERGB(   0,  0,128 ),
        PALETTERGB( 128,  0,128 ),
        PALETTERGB( 128,128, 64 ),
        PALETTERGB(   0, 64, 64 ),
        PALETTERGB(   0,128,255 ),
        PALETTERGB(   0, 64,128 ),
        PALETTERGB(  64,  0,255 ),
        PALETTERGB( 128, 64,  0 ),

        PALETTERGB( 255,255,255 ),
        PALETTERGB( 192,192,192 ),
        PALETTERGB( 255,  0,  0 ),
        PALETTERGB( 255,255,  0 ),
        PALETTERGB(   0,255,  0 ),
        PALETTERGB(   0,255,255 ),
        PALETTERGB(   0,  0,255 ),
        PALETTERGB( 255,  0,255 ),
        PALETTERGB( 255,255,128 ),
        PALETTERGB(   0,255,128 ),
        PALETTERGB( 128,255,255 ),
        PALETTERGB( 128,128,255 ),
        PALETTERGB( 255,  0,128 ),
        PALETTERGB( 255,128, 64 ),

        PALETTERGB(   0,  0,  0 )    // Current color
};



//
// WbColorsGroup()
//
WbColorsGroup::WbColorsGroup()
{
    int         i;

    m_hwnd = NULL;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        m_crColors[i] = g_crDefaultColors[i];
        m_hBrushes[i] = NULL;
    }


    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        m_crCustomColors[i] = CLRPANE_WHITE;
    }

    m_nLastColor = 0;
}



WbColorsGroup::~WbColorsGroup(void)
{
    int i;

    // clean up
    for (i = 0; i < NUMCLRPANES; i++)
    {
        if (m_hBrushes[i] != NULL)
        {
            ::DeleteBrush(m_hBrushes[i]);
            m_hBrushes[i] = NULL;
        }
    }

    if (m_hwnd != NULL)
    {
        ::DestroyWindow(m_hwnd);
        ASSERT(m_hwnd == NULL);
    }

    // Unregister our class
    ::UnregisterClass(szCGClassName, g_hInstance);
}



BOOL WbColorsGroup::Create(HWND hwndParent, LPCRECT lprect)
{
    int         i;
    HDC         hdc;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;
    WNDCLASSEX  wc;

    ASSERT(m_hwnd == NULL);

    // Register our class
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize           = sizeof(wc);
    wc.style            = CS_DBLCLKS;
    wc.lpfnWndProc      = CGWndProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = ::LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszClassName    = szCGClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("WbColorsGroup::Create register class failed"));
        return(FALSE);
    }

    //
    // We should be created the right siez
    //
    ASSERT(lprect->right - lprect->left == CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH);
    ASSERT(lprect->bottom - lprect->top == CLRCHOICE_HEIGHT);

    //
    // Calculate our item colors, then figure out our size.
    //

    hdc = ::GetDC(hwndParent);
    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(hdc, hPal, FALSE);
        ::RealizePalette(hdc);
    }

    // load the colors from last time
    OPT_GetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_GetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

    // make brushes.
    for (i = 0; i < NUMCLRPANES; i++)
    {
        // force color matching
        m_crColors[i] = SET_PALETTERGB( m_crColors[i] );
        m_hBrushes[i] = ::CreateSolidBrush(m_crColors[i]);
    }

    for (i = 0; i < NUMCUSTCOLORS; i++)
    {
        // force color matching
        m_crCustomColors[i] = SET_PALETTERGB( m_crCustomColors[i] );
    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(hdc, hOldPal, TRUE);
    }
    ::ReleaseDC(hwndParent, hdc);

    //
    // Here's our layout:
    //      * The colors window is CHOICEFRAME_HEIGHT pixels high
    //      * The current choice is a rect of CHOICEFRAME_WIDTH by
    //          CHOICEFRAME_HEIGHT pixels, on the left side.  This includes
    //          a sunken EDGE.
    //      * There is no gap horizontally or vertically among panes.

    //
    // Create our window -- we're always visible.  The attribute group
    // shows/hides colors by showing/hiding itself.
    //
    if (!::CreateWindowEx(0, szCGClassName, NULL, WS_CHILD | WS_VISIBLE,
        lprect->left, lprect->top,
        lprect->right - lprect->left,
        lprect->bottom - lprect->top,
        hwndParent, NULL, g_hInstance, this))
    {
        ERROR_OUT(("Can't create WbColorsGroup"));
        return(FALSE);
    }

    ASSERT(m_hwnd != NULL);
    return(TRUE);
}


LRESULT CALLBACK CGWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbColorsGroup * pcg;

    pcg = (WbColorsGroup *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pcg = (WbColorsGroup *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            ASSERT(pcg);

            pcg->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pcg);
            goto DefWndProc;
            break;

        case WM_NCDESTROY:
            ASSERT(pcg);
            pcg->m_hwnd = NULL;
            break;

        case WM_PAINT:
            ASSERT(pcg);
            pcg->OnPaint();
            break;

        case WM_LBUTTONDOWN:
            pcg->OnLButtonDown((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_LBUTTONDBLCLK:
            pcg->OnLButtonDblClk((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        default:
DefWndProc:
            lResult = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    return(lResult);
}



void WbColorsGroup::GetNaturalSize(LPSIZE lpsize)
{
    lpsize->cx = CLRCHOICE_WIDTH + NUMCOLS*CLRPANE_WIDTH;
    lpsize->cy = CLRCHOICE_HEIGHT;
}



COLORREF WbColorsGroup::GetCurColor(void)
{
    return(GetColorOfBrush(INDEX_CHOICE));
}



void WbColorsGroup::SetCurColor(COLORREF clr)
{
    SetColorOfPane(INDEX_CHOICE, clr);
}






//
// OnPaint()
//
// MFC message handler for WM_PAINT
//
void WbColorsGroup::OnPaint(void)
{
    PAINTSTRUCT ps;
    RECT        rc;
    RECT        rcClient;
    int         dx, dy;
    int         i;
    HPALETTE    hPal;
    HPALETTE    hOldPal = NULL;

    ::BeginPaint(m_hwnd, &ps);

    hPal = PG_GetPalette();
    if (hPal != NULL)
    {
        hOldPal = ::SelectPalette(ps.hdc, hPal, FALSE);
        ::RealizePalette(ps.hdc);
    }

    dx = ::GetSystemMetrics(SM_CXEDGE);
    dy = ::GetSystemMetrics(SM_CYEDGE);
    ::GetClientRect(m_hwnd, &rcClient);

    // Draw the current choice
    rc = rcClient;
    rc.right = rc.left + CLRCHOICE_WIDTH;
    ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_ADJUST | BF_RECT);
    ::FillRect(ps.hdc, &rc, m_hBrushes[INDEX_CHOICE]);

    // Draw the colors
    rcClient.left += CLRCHOICE_WIDTH;

    rc = rcClient;
    rc.right = rc.left + CLRPANE_WIDTH;
    rc.bottom = rc.top + CLRPANE_HEIGHT;

    for (i = 0; i < NUMCLRPANES; i++)
    {
        ::DrawEdge(ps.hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        ::FillRect(ps.hdc, &rc, m_hBrushes[i]);
        ::InflateRect(&rc, dx, dy);

        if (i == NUMCOLS - 1)
        {
            ::OffsetRect(&rc, - (NUMCOLS-1)*CLRPANE_WIDTH, CLRPANE_HEIGHT);
        }
        else
        {
            ::OffsetRect(&rc, CLRPANE_WIDTH, 0);
        }

    }

    if (hOldPal != NULL)
    {
        ::SelectPalette(ps.hdc, hOldPal, TRUE);
    }

    ::EndPaint(m_hwnd, &ps);

}

//
// OnLButtonDown()
//
void WbColorsGroup::OnLButtonDown(UINT nFlags, int x, int y)
{
    //
    // If this is the current choice, do nothing.  Otherwise, change the
    // current color.
    //
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        // Set the current color
        SetColorOfPane(INDEX_CHOICE, GetColorOfBrush(pane));
        m_nLastColor = pane;

        // tell Whiteboard about it.
        ClickOwner();
    }
}



//
// OnLButtonDblClk()
//
void  WbColorsGroup::OnLButtonDblClk(UINT nFlags, int x, int y)
// Invoke color dialog to edit this color
{
    if (x >= CLRCHOICE_WIDTH)
    {
        int pane;

        pane = 0;
        if (y >= CLRPANE_HEIGHT)
            pane += NUMCOLS;
        pane += (x - CLRCHOICE_WIDTH) / CLRPANE_WIDTH;

        DoColorDialog(pane);
    }
}



// Returns COLORREF of Brushes[] or BLACK if no brush
COLORREF WbColorsGroup::GetColorOfBrush( int nColor )
{
    ASSERT(nColor >= 0);
    ASSERT(nColor < NUMCLRPANES);

    if (m_hBrushes[nColor] != NULL)
    {
        return(m_crColors[nColor]);
    }
    else
    {
        return(CLRPANE_BLACK);
    }
}


// Recreates the nColor-th brush, using the new color
void WbColorsGroup::SetColorOfBrush( int nColor, COLORREF crNewColor )
{
    HBRUSH  hNewBrush;

    // force color matching
    crNewColor = SET_PALETTERGB( crNewColor );

    // check if we need to do anything
    if ((nColor > -1) && (crNewColor != GetColorOfBrush(nColor)))
    {
        // new color is different from old color, make a new brush

        hNewBrush = ::CreateSolidBrush(crNewColor);
        if (hNewBrush != NULL)
        {
            // We managed to create the new brush.  Delete the old one
            if (m_hBrushes[nColor] != NULL)
            {
                ::DeleteBrush(m_hBrushes[nColor]);
            }

            m_hBrushes[nColor] = hNewBrush;
            m_crColors[nColor] = crNewColor;
        }
    }
}



//
// SetColorOfPane()
//
// Replaces brush associated with nPaneId.
//
void WbColorsGroup::SetColorOfPane(int pane, COLORREF crNewColor )
{
    RECT    rcClient;

    // make a new brush
    SetColorOfBrush(pane, crNewColor);

    // update pane
    ::GetClientRect(m_hwnd, &rcClient);
    if (pane == INDEX_CHOICE)
    {
        rcClient.right = rcClient.left + CLRCHOICE_WIDTH;
    }
    else
    {
        rcClient.left += CLRCHOICE_WIDTH;

        rcClient.top += (pane / NUMCOLS) * CLRPANE_HEIGHT;
        rcClient.bottom = rcClient.top + CLRPANE_HEIGHT;
        rcClient.left += (pane % NUMCOLS) * CLRPANE_WIDTH;
        rcClient.right = rcClient.left + CLRPANE_WIDTH;
    }
    ::InvalidateRect(m_hwnd, &rcClient, FALSE);
}




void WbColorsGroup::SaveSettings( void )
    // Saves stuff in registry because we're shutting down
{
    // load the colors from last time
    OPT_SetDataOption(OPT_MAIN_COLORPALETTE,
                           sizeof m_crColors,
                          (BYTE *)m_crColors );

    OPT_SetDataOption(OPT_MAIN_CUSTOMCOLORS,
                          sizeof m_crCustomColors,
                          (BYTE *)m_crCustomColors );

}



LRESULT WbColorsGroup::OnEditColors( void )
{
    DoColorDialog( m_nLastColor );
	return S_OK;
}



//
// DoColorDialog()
// Put up ComDlg color picker to edit the pane's color value
//
COLORREF WbColorsGroup::DoColorDialog( int nColor )
{
    CHOOSECOLOR cc;

    memset(&cc, 0, sizeof(cc));
    cc.lStructSize = sizeof(cc);
    cc.lpCustColors = m_crCustomColors;
    cc.Flags = CC_RGBINIT;
    cc.rgbResult = GetColorOfBrush(nColor);
    cc.hwndOwner = m_hwnd;

    ::ChooseColor(&cc);

    // force color matching
    cc.rgbResult = SET_PALETTERGB(cc.rgbResult);

    // use the new color
    SetColorOfPane(nColor, cc.rgbResult );

    // set choice pane
    SetColorOfPane(INDEX_CHOICE,  cc.rgbResult );
    m_nLastColor = nColor;

    // tell Whiteboard about it.
    ClickOwner();

    return(cc.rgbResult );
}





void WbColorsGroup::ClickOwner( void )
{
    ::PostMessage(g_pMain->m_hwnd, WM_COMMAND,
                    (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                    (LPARAM)m_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\draw.hpp ===
//
// DRAW.HPP
// Drawing Code
//
// Copyright Microsoft 1998-
//


#ifndef __DRAW_HPP_
#define __DRAW_HPP_

#include <oblist.h>

#define HIT_WINDOW 1
#define MAKE_HIT_RECT(r, p )  \
    ::SetRect(&r, p.x-HIT_WINDOW, p.y-HIT_WINDOW, p.x+HIT_WINDOW, p.y+HIT_WINDOW);

//
// Timer for periodic update of some graphic objects
//
#define TIMER_GRAPHIC_UPDATE  8
#define TIMER_REMOTE_POINTER_UPDATE 9

#define EqualPoint(pt1, pt2)    (((pt1).x == (pt2).x) && ((pt1).y == (pt2).y))


#define DRAW_WIDTH                      1280
#define DRAW_HEIGHT                     1024
#define DRAW_LINEVSCROLL                8				
#define DRAW_LINEHSCROLL                8				
#define DRAW_HANDLESIZE                 6				
#define DRAW_ZOOMFACTOR                 2
#define DRAW_REMOTEPOINTERDELAY         250
#define DRAW_GRAPHICUPDATEDELAY         1000


extern WorkspaceObj* g_pCurrentWorkspace;


//
//
// Class:   WbDrawingArea
//
// Purpose: drawing window
//
//
class WbDrawingArea
{

  friend class WbTextBox;


public:
    //
    // Constructor
    //
    WbDrawingArea(void);
    ~WbDrawingArea(void);

	void ShutDownDC(void);
  
    //
    // Create the drawing area
    //
    BOOL Create(HWND hwndParent, LPCRECT lprect);

    //
    // Return TRUE if the drawing area is busy and may be actively using
    // graphic objects in the current page.
    //
    BOOL IsBusy(void) { return m_bBusy; }

    //
    // Lock and unlock the drawing area
    //
    BOOL IsLocked (void) { return m_bLocked; }
    void SetLock(BOOL bLock){ m_bLocked = bLock; }
    void Unlock   (void);
    void Lock     (void);

    BOOL IsSynced (void) { return m_bSync; }
    void SetSync(BOOL bSync) { m_bSync = bSync; }

    //
    // Realize the drawing area's palette
    //
    void RealizePalette( BOOL bBackground );//CHANGED BY RAND

    //
    // Selection functions
    //
    void SelectTool(WbTool* pToolNew);  // Select drawing tool

    //
    // Update the selected object
    //
    void SetSelectionColor (COLORREF clr);         // Change color
    void SetSelectionWidth (UINT uiNewWidth);  // Select pen width
    void SetSelectionFont  (HFONT hFont);       // Select font

    //
    // External update functions
    //
    void PageCleared(void);

    //
    // Query functions
    //
    // Ask whether an object is currently selected
    BOOL GraphicSelected(void);

    // Return the currently selected graphic
    T126Obj* GetSelection(void);

	// Clear current (multi object) selection
	void ClearSelection( void );

	T126Obj *GetHitObject( POINT surfacePos )
		{return( PG_SelectLast(g_pCurrentWorkspace, surfacePos) );}


    // Ask whether the drawing area is zoomed
    BOOL Zoomed(void) { return (m_iZoomFactor != 1); }

    // Ask whether the drawing area is zoomed
    int ZoomOption(void) { return (m_iZoomOption); }
    int ZoomFactor(void) { return (m_iZoomFactor); }

    //
    // Complete a text object
    //
    void EndTextEntry(BOOL bAccept);

    // Ask whether the text editor is active
    BOOL TextEditActive(void) { return m_bTextEditorActive; }

	// text editor clipboard
	void   TextEditCopy( void )	{m_pTextEditor->Copy();}

	void   TextEditCut( void ) 	{m_pTextEditor->Cut();}

	void   TextEditPaste( void ) {m_pTextEditor->Paste();}

	// Resets text editor for window resizing
	void TextEditParentResize( void )
		{m_pTextEditor->ParentResize();}

	// Redraws editbox
	void RedrawTextEditbox(void)
		{m_pTextEditor->RedrawEditbox();}

	// Gets editbox bounding rect
	void GetTextEditBoundsRect(LPRECT lprc)
		{ m_pTextEditor->GetBoundsRect(lprc); }

    // Return the rectangle currently being viewed i.e. that portion of
    // the page surface that is within the window client area.
    void    GetVisibleRect(LPRECT lprc);

	// Select objects inside rectSelect or ALL if rect is NULL
	void SelectMarkerFromRect(LPCRECT lprcSelect);
    DrawObj *GetMarker( void )
		{return( m_pMarker );}

    T126Obj* SelectPreviousGraphicAt(T126Obj* pGraphic, POINT point);

	void SetLClickIgnore( BOOL bIgnore )
		{m_bIgnoreNextLClick = bIgnore;}


    //
    // Action members
    //
    void  Attach(WorkspaceObj * pNewWorkspace);    // Attach a new page to the window
    void  Detach(void) { Attach(NULL); }   // Attach the empty page

    void  DeleteSelection(void);           // Delete selected graphic

    LRESULT  BringToTopSelection(BOOL editedLocally, T126Obj * pT126Obj = NULL);       // Bring selected graphic to top
	LRESULT  SendToBackSelection(BOOL editedLocally, T126Obj * pT126Obj = NULL);       // Send selected graphic to back

    void  Clear(void);                     // Clear the workspace

    void  Zoom(void);                      // Zoom the drawing area

    void GotoPosition(int x, int y); // Set scroll position

	// select an object
    void SelectGraphic(T126Obj* pGraphic, 
						 BOOL bEnableForceAdd=FALSE, //CHANGED BY RAND
						 BOOL bForceAdd=FALSE );	 //CHANGED BY RAND


	BOOL MoveSelectedGraphicBy(LONG x, LONG y);
	void EraseInitialDrawFinal(LONG x, LONG y, BOOL editedLocally, T126Obj* pObj = NULL);
	void EraseSelectedDrawings();

    //
	//
    // Convert between surface and client co-ordinates
    //
    void SurfaceToClient(LPPOINT lppt);
    void ClientToSurface(LPPOINT lppt);
    void SurfaceToClient(LPRECT lprc);
    void ClientToSurface(LPRECT lprc);
    void MoveOntoSurface(LPPOINT lppt);
    void GetOrigin(LPPOINT lppt);
	T126Obj* GetSelectedGraphic (void){ return m_pSelectedGraphic;}

    //
    // Invalidate the client area rectangle corresponding to the surface
    // rectangle specified.
    //
    void InvalidateSurfaceRect(LPCRECT lprc, BOOL bErase);

    HDC  GetCachedDC  (void) const {return(m_hDCCached); }
    void PrimeFont   (HDC hDC, HFONT hFont, TEXTMETRIC* pTextMetrics);
    void UnPrimeFont (HDC hDC);

    void DrawMarker   (HDC hDC);
    void PutMarker    (HDC hDC, BOOL bDraw = TRUE );
    void RemoveMarker (void);

    //
    // Cancel a drawing operation.
    //
    void CancelDrawingMode(void);

    friend LRESULT CALLBACK DrawWndProc(HWND, UINT, WPARAM, LPARAM);

    //
    // Windows message handling
    //
    void OnPaint(void);
    void OnMouseMove(UINT flags, int x, int y);
    void OnLButtonDown(UINT flags, int x, int y);
    void OnLButtonUp(UINT flags, int x, int y);
    void OnRButtonDown(UINT flags, int x, int y);
    void OnSize(UINT flags, int cx, int cy);
    void OnHScroll(UINT code, UINT pos);
    void OnVScroll(UINT code, UINT pos);
    LRESULT OnEditColor(HDC hdc);
    void OnSetFocus(void);
    void OnActivate(UINT flags);
    LRESULT OnCursor(HWND hwnd, UINT hitTest, UINT msg);
    void OnTimer(UINT idTimer);
    void OnCancelMode(void);
    void OnContextMenu(int xScreen, int yScreen);

protected:
    //
    // Set the cursor to be used in the drawing area for the current state
    //
    BOOL SetCursorForState(void);

    //
    // Setup functions for the various drawing operations
    //
    BOOL RemotePointerSelect (POINT mousePos);
    void BeginSelectMode     (POINT mousePos, 
									BOOL bDontDrag );
    void BeginDeleteMode     (POINT mousePos);
    void BeginTextMode       (POINT mousePos);

    //
    // Mouse tracking functions. These are called for each mouse move event
    // (depending on the current drawing mode).
    //
    void TrackSelectMode    (POINT mousePos);
    void TrackDeleteMode    (POINT mousePos);

    //
    // Completion functions for the various mode drawing operations.
    //
    void CompleteSelectMode();
    void CompleteDeleteMode();
    void CompleteMarkAreaMode();
    void CompleteTextMode();

	void BeginDrawingMode(POINT surfacePos);
	void TrackDrawingMode(POINT surfacePos);
	void CompleteDrawingMode();

    //
    // Scroll the workspace to scrollPosition
    //
    void ScrollWorkspace   (void);
    void DoScrollWorkspace (void);
    BOOL   AutoScroll(int xPos, int yPos, BOOL bMoveCursor, int xCaret, int yCaret);

    //
    // Graphic object selection and marker manipulation
    //
    void DeselectGraphic(void);

    //
    // Remote pointer manipulation
    //

    //
    // Redraw the pointers in the list specified. The pointers are drawn
    // from the start of the list to the end. If a NULL pointer is
    // specified, the undrawnPointers list is used.
    //
    void PutPointers(HDC hDC, COBLIST* pDrawList = NULL);

    void PrimeDC   (HDC hDC);
    void UnPrimeDC (HDC hDC);

    //
    // Flag indicating that the drawing area is busy or locked
    //
    BOOL        m_bBusy;
    BOOL        m_bLocked;
	BOOL        m_HourGlass; // we're busy doing something local
	BOOL		m_bSync;

    //
    // Saved drawing attributes
    //
    HPEN        m_hOldPen;
    HBRUSH      m_hOldBrush;
    HPALETTE    m_hOldPalette;
    HFONT       m_hOldFont;
    HFONT       m_hCurFont;

    //
    // Current offset of the client region of the window onto the picture
    //
    RECT        m_rcSurface;

public:
    SIZE        m_originOffset;
    HWND        m_hwnd;

    //
    // Saved drawing attributes
    //
    HDC         m_hDCCached;
    HDC         m_hDCWindow;

    HBRUSH		m_hMarkerBrush;
	RECT		m_selectorRect;
    WbTextEditor* m_pTextEditor;
    void DeactivateTextEditor(void);

protected:
    //
    // Scrolling control
    //
    void   SetScrollRange(int cx, int cy);
    void   ValidateScrollPos(void);

    POINT   m_posScroll;
    POINT   m_posZoomScroll;
    BOOL    m_zoomRestoreScroll;

    //
    // Start and end points of most recent drawing operation
    //
    POINT   m_ptStart;
    POINT   m_ptEnd;

    //
    // Current drawing tool
    //
    WbTool * m_pToolCur;

    //
    // Mouse button down flag
    //
    BOOL    m_bLButtonDown;

    //
    // Graphics object pointer used for tracking object
    //
    DrawObj* m_pGraphicTracker;

    //
    // Tick count used to determine when it is time to update the external
    // copy of a graphic.
    //
    DWORD   m_dwTickCount;

    //
    // Marker for selection mode
    //
    DrawObj* m_pMarker;
    T126Obj* m_pSelectedGraphic;
    BOOL m_bMarkerPresent;
    BOOL m_bNewMarkedGraphic;

	BOOL m_bTrackingSelectRect; 

    //
    // Text editor control
    //
    BOOL        m_bTextEditorActive;
//    TextObj* 	m_pActiveText;

    void ActivateTextEditor( BOOL bPutUpCusor ); 

    //
    // Text cursor control
    //
    BOOL        m_bGotCaret;

    //
    // Currently marked area
    //
    RECT    m_rcMarkedArea;

    //
    // Zoom variables
    //
    int     m_iZoomFactor;                   // Current zoom factor
    int     m_iZoomOption;                   // Zoom factor to be used


    HCURSOR m_hCursor;                    // handle of last cursor we displayed
                                        // (or null if normal arrow cursor)
	BOOL    m_bIgnoreNextLClick;

};


#endif // __DRAW_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\drawobj.cpp ===
//
// DRAWOBJ.CPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#include "precomp.h"

#define DECIMAL_PRECISION  100


DrawObj::DrawObj(UINT drawingType, UINT toolType):
	m_drawingType(drawingType),
	m_isDrawingCompleted(FALSE)
{
	SetMyWorkspace(NULL);
	SetOwnerID(g_MyMemberID);

	m_ToolType = toolType;

	//
	// Created locally, not selected, not editing or deleting.
	//
	CreatedLocally();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	SetFillColor(0,FALSE);

	//
	// No attributes changed, they will be set as we change them
	//
	ResetAttrib();

	DBG_SAVE_FILE_LINE
	m_points = new DCDWordArray();
	SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
	SetType(drawingCreatePDU_chosen);
	SetPenNib(circular_chosen);
	SetROP(R2_NOTXORPEN);
	SetPlaneID(1);
	SetMyPosition(NULL);
	SetMyWorkspace(NULL);

	
	RECT rect;
    ::SetRectEmpty(&rect);
	SetBoundsRect(&rect);
	SetRect(&rect);

}

DrawObj::DrawObj (DrawingCreatePDU * pdrawingCreatePDU)
{
	SetType(drawingCreatePDU_chosen);
	SetMyWorkspace(NULL);

	//
	// Created remotely, not selected, not editing or deleting.
	//
	ClearCreationFlags();
	ClearSelectionFlags();
	ClearEditionFlags();
	ClearDeletionFlags();

	ResetAttrib();

	//
	// Get the drawing handle
	//
	SetThisObjectHandle(pdrawingCreatePDU->drawingHandle);

	//
	// Get the destination address
	//
	UINT workspaceHandle = 0;
	UINT planeID = 0;
	GetDrawingDestinationAddress(&pdrawingCreatePDU->destinationAddress, &workspaceHandle, &planeID);
	SetWorkspaceHandle(workspaceHandle);
	SetPlaneID(planeID);
	TRACE_DEBUG(("Destination address, Workspace Handle = %d", workspaceHandle));
	TRACE_DEBUG(("Destination address, Plane ID = %d", planeID));

	//
	// Get the drawing type, line, circle, etc ...
	//
    SetDrawingType(pdrawingCreatePDU->drawingType.choice);

	//
	// Set defaults
	//
//	m_T126Drawing.m_sampleRate = INVALID_SAMPLE_RATE;

	//
	// Default attributes
	//
	// Pen color black
	SetPenColor(0,TRUE);
	// No fill color
	SetFillColor(0,FALSE);
	// 1 Pixels for pen thickness
	SetPenThickness(1);
	// Pen Nib is circular
	SetPenNib(circular_chosen);
	// Solid line
	SetLineStyle(PS_SOLID);
	// No highlight
	SetHighlight(FALSE);
	// Not selected
	SetViewState(unselected_chosen);
	// Top object
	SetZOrder(front);

	// This is a complete drawing
	SetIsCompleted(TRUE);

	//
	// Get attributes
	//
	if(pdrawingCreatePDU->bit_mask & DrawingCreatePDU_attributes_present)
	{
		GetDrawingAttrib((PVOID)pdrawingCreatePDU->attributes);
	}

	DBG_SAVE_FILE_LINE
	m_points = new DCDWordArray();

	//
	// Get Anchor point
	//
	POINT Point;

	//
	// For open polylines the first point will be an offset of the anchor point
	//
	if(pdrawingCreatePDU->drawingType.choice == openPolyLine_chosen)
	{
		Point.x = 0;
		Point.y = 0;
		AddPoint(Point);
	}
	
	SetAnchorPoint(pdrawingCreatePDU->anchorPoint.xCoordinate, pdrawingCreatePDU->anchorPoint.yCoordinate);
	GetAnchorPoint(&Point);
	RECT rect;
	rect.left = pdrawingCreatePDU->anchorPoint.xCoordinate;
	rect.top = pdrawingCreatePDU->anchorPoint.yCoordinate;
	rect.right = pdrawingCreatePDU->anchorPoint.xCoordinate;
	rect.bottom = pdrawingCreatePDU->anchorPoint.yCoordinate;		
	SetRect(&rect);
	SetBoundsRect(&rect);
	AddPointToBounds(pdrawingCreatePDU->anchorPoint.xCoordinate, pdrawingCreatePDU->anchorPoint.yCoordinate);
	
	//
	// Since we don't know ahead of time how many points we have, set the type as a polyline
	//
	m_ToolType = TOOLTYPE_PEN;

	//
	// Get consecutive points
	//
	UINT nPoints;
	nPoints = GetSubsequentPoints(pdrawingCreatePDU->pointList.choice, &Point, &pdrawingCreatePDU->pointList);

	//
	// Find out what UI tool are we, and set the correct ROP
	//
	SetUIToolType();

	
	if(nPoints == 1)
	{
		POINT *point;
		point = m_points->GetBuffer();
		rect.right = point->x + pdrawingCreatePDU->anchorPoint.xCoordinate;
		rect.bottom = point->y + pdrawingCreatePDU->anchorPoint.yCoordinate;		
		SetRect(&rect);
		::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
		SetBoundsRect(&rect);
	}
	
	//
	// Get Non standard stuff
	//
	if(pdrawingCreatePDU->bit_mask & DrawingCreatePDU_nonStandardParameters_present)
	{
		; // NYI
	}


}

DrawObj::~DrawObj( void )
{
	RemoveObjectFromResendList(this);
	RemoveObjectFromRequestHandleList(this);

	TRACE_DEBUG(("drawingHandle = %d", GetThisObjectHandle() ));

	//
	// Tell other nodes that we are gone
	//
	if(GetMyWorkspace() != NULL && WasDeletedLocally())
	{
		OnObjectDelete();
	}

	//
	// Clear the list of points
	//
	delete m_points;

}

void DrawObj::DrawEditObj ( DrawingEditPDU * pdrawingEditPDU )
{

	RECT		rect;
	POSITION	pos;
	POINT		anchorPoint;
	LONG 		deltaX = 0;
	LONG		deltaY = 0;

	TRACE_DEBUG(("DrawEditObj drawingHandle = %d", pdrawingEditPDU->drawingHandle ));

	//
	// Was edited remotely
	//
	ClearEditionFlags();

	//
	// Read attributes
	//
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_attributeEdits_present)
	{
		GetDrawingAttrib((PVOID)pdrawingEditPDU->attributeEdits);
	}

	//
	// Change the anchor point
	//
	GetAnchorPoint(&anchorPoint);
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_anchorPointEdit_present)
	{

		TRACE_DEBUG(("Old anchor point (%d,%d)", anchorPoint.x, anchorPoint.y));
		TRACE_DEBUG(("New anchor point (%d,%d)",
		pdrawingEditPDU->anchorPointEdit.xCoordinate, pdrawingEditPDU->anchorPointEdit.yCoordinate));
		//
		// Get the delta from previous anchor point
		//
		deltaX =  pdrawingEditPDU->anchorPointEdit.xCoordinate - anchorPoint.x;
		deltaY =  pdrawingEditPDU->anchorPointEdit.yCoordinate - anchorPoint.y;
		TRACE_DEBUG(("Delta (%d,%d)", deltaX , deltaY));

		//
		// Was edited remotely
		//
		ClearEditionFlags();
	}
	
	//
	// Get Rotation
	//
//	if(pdrawingEditPDU->bit_mask & rotationEdit_present)
//	{
//		m_T126Drawing.m_rotation.m_bIsPresent = TRUE;
//	    m_T126Drawing.m_rotation.m_rotation.rotationAngle = pdrawingEditPDU->rotation.rotationAngle;
//    	m_T126Drawing.m_rotation.m_rotation.rotationAxis.xCoordinate = pdrawingEditPDU->rotation.rotationAxis.xCoordinate;
//    	m_T126Drawing.m_rotation.m_rotation.rotationAxis.yCoordinate = pdrawingEditPDU->rotation.rotationAxis.yCoordinate;
//	}
//	else
//	{
//		m_T126Drawing.m_rotation.m_bIsPresent = FALSE;
//	}


	//
	// Get the list of points
	//
	if(pdrawingEditPDU->bit_mask & pointListEdits_present)
	{
		UINT i, initialIndex, xInitial,yInitial,numberOfPoints;
		
		PointListEdits_Seq pointList;
		POINT initialPoint;

		TRACE_DEBUG(("Number of point edit lists %d", pdrawingEditPDU->pointListEdits.count));


		for (i = 0; i<pdrawingEditPDU->pointListEdits.count; i++)
		{
			pointList = pdrawingEditPDU->pointListEdits.value[i];
			initialIndex = pointList.initialIndex;
			TRACE_DEBUG(("Points cached = %d", m_points->GetSize()));
			TRACE_DEBUG(("initialIndex = %d", initialIndex));
			initialPoint.x = pointList.initialPointEdit.xCoordinate;
			initialPoint.y = pointList.initialPointEdit.yCoordinate;

			POINT * pPoint = m_points->GetBuffer();
				
			TRACE_DEBUG(("initialPoint=(%d, %d), previousPoint=(%d, %d), anchorPoint=(%d, %d)",
					initialPoint.x, initialPoint.y,
					pPoint[initialIndex-1].x, pPoint[initialIndex-1].y,
					anchorPoint.x , anchorPoint.y
					));
			if(initialIndex > 1)
			{
				for(UINT k = 0; k< initialIndex; k++)
				{
					deltaX += pPoint[k].x;
					deltaY += pPoint[k].y;
				}
				initialPoint.x -= deltaX;
				initialPoint.y -= deltaY;
			}
			m_points->SetSize(initialIndex);
			AddPoint(initialPoint);

			if(GetDrawingType() == rectangle_chosen || GetDrawingType() == ellipse_chosen)
			{
				
				GetRect(&rect);
				rect.right = initialPoint.x + anchorPoint.x;
				rect.bottom = initialPoint.y + anchorPoint.y;		
				SetRect(&rect);
				::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
				SetBoundsRect(&rect);
			}


			if(pointList.bit_mask & subsequentPointEdits_present)
			{
				GetSubsequentPoints(pointList.subsequentPointEdits.choice,
									&anchorPoint,
									&pointList.subsequentPointEdits);

			}
	        ChangedPointList();
		}
	}

	//
	// Just changed the anchor point, the other points have to change as well
	//
	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_anchorPointEdit_present)
	{
		//
		// Set new anchor point
		//
		anchorPoint.x = pdrawingEditPDU->anchorPointEdit.xCoordinate;
		anchorPoint.y = pdrawingEditPDU->anchorPointEdit.yCoordinate;
		SetAnchorPoint(anchorPoint.x, anchorPoint.y);

		GetRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetRect(&rect);
	
		GetBoundsRect(&rect);
		::OffsetRect(&rect,  deltaX, deltaY);
		SetBoundsRect(&rect);

	}


	if(pdrawingEditPDU->bit_mask & DrawingEditPDU_nonStandardParameters_present)
	{
		;		// Do the non Standard Edit PDU NYI
	}
	if(HasAnchorPointChanged() ||
		HasPointListChanged() ||
		HasFillColorChanged() ||
		HasPenColorChanged()||
		HasPenThicknessChanged()||
		HasLineStyleChanged())
	{
		g_pDraw->EraseInitialDrawFinal(0 - deltaX,0 - deltaY, FALSE, (T126Obj*)this);
		::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);

	}
	else if(HasZOrderChanged())
	{
		if(GetZOrder() == front)
		{
			g_pDraw->BringToTopSelection(FALSE, this);
		}
		else
		{
			g_pDraw->SendToBackSelection(FALSE, this);
		}
	}
	//
	// If it just select/unselected it
	//
	else if(HasViewStateChanged())
	{
		; // do nothing
	}
	//
	// If we have a valid pen.
	//
	else if(GetPenThickness())
	{
		Draw();
	}

	//
	// Reset all the attributes
	//
	ResetAttrib();
}


void    DrawObj::GetDrawingAttrib(PVOID pAttribPDU)
{
	PDrawingEditPDU_attributeEdits attributes;
	attributes = (PDrawingEditPDU_attributeEdits)pAttribPDU;
	COLORREF rgb;
	while(attributes)
	{
		switch(attributes->value.choice)
		{
			case(penColor_chosen):
			{
				switch(attributes->value.u.penColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.penColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.penColor.u.rgbTrueColor.r,
										attributes->value.u.penColor.u.rgbTrueColor.g,
										attributes->value.u.penColor.u.rgbTrueColor.b);
						SetPenColor(rgb, TRUE);
						TRACE_DEBUG(("Attribute penColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.penColor.u.rgbTrueColor.r,
								attributes->value.u.penColor.u.rgbTrueColor.g,
								attributes->value.u.penColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetPenColor(0,FALSE);
						break;
					}
					default:
				    ERROR_OUT(("Invalid penColor choice"));
					break;
				}
				break;
  			}

			case(fillColor_chosen):
			{
				TRACE_DEBUG(("Attribute fillColor"));
				switch(attributes->value.u.fillColor.choice)
				{
//					case(workspacePaletteIndex_chosen):
//					{
//						ASN1uint16_t workspacePaletteIndex = ((attributes->value.u.fillColor).u).workspacePaletteIndex;
//						break;
//					}
					case(rgbTrueColor_chosen):
					{
						rgb = RGB(attributes->value.u.fillColor.u.rgbTrueColor.r,
										attributes->value.u.fillColor.u.rgbTrueColor.g,
										attributes->value.u.fillColor.u.rgbTrueColor.b);
						SetFillColor(rgb, TRUE);
						TRACE_DEBUG(("Attribute fillColor (r,g,b)=(%d, %d,%d)",
								attributes->value.u.fillColor.u.rgbTrueColor.r,
								attributes->value.u.fillColor.u.rgbTrueColor.g,
								attributes->value.u.fillColor.u.rgbTrueColor.b));
						break;
					}
					case(transparent_chosen):
					{
						SetFillColor(0,FALSE);
						break;
					}
					default:
				    ERROR_OUT(("Invalid fillColor choice"));
					break;
					}
					break;
  				}

			case(penThickness_chosen):
			{
				SetPenThickness(attributes->value.u.penThickness);
				TRACE_DEBUG(("Attribute penThickness %d", attributes->value.u.penThickness));
				break;
			}

			case(penNib_chosen):
			{
				if (attributes->value.u.penNib.choice != nonStandardNib_chosen)
				{
					SetPenNib(attributes->value.u.penNib.choice);
					TRACE_DEBUG(("Attribute penNib %d",attributes->value.u.penNib.choice));
				}
				else
				{
					// Do the non Standard penNib NYI
					;
				}
				break;
			}

			case(lineStyle_chosen):
			{
				if((attributes->value.u.lineStyle).choice != nonStandardStyle_chosen)
				{
					SetLineStyle(attributes->value.u.lineStyle.choice - 1);
					TRACE_DEBUG(("Attribute lineStyle %d", attributes->value.u.lineStyle.choice));
				}
				else
				{
					// Do the non Standard lineStyle NYI
					;
				}
				break;
			}
				
			case(highlight_chosen):
			{
				SetHighlight(attributes->value.u.highlight);
				TRACE_DEBUG(("Attribute highlight %d", attributes->value.u.highlight));
				break;
			}

			case(DrawingAttribute_viewState_chosen):
			{
				if((attributes->value.u.viewState).choice != nonStandardViewState_chosen)
				{
					SetViewState(attributes->value.u.viewState.choice);
					
					//
					// If the other node is selecting the drawing or unselecting
					//
					if(attributes->value.u.viewState.choice == selected_chosen)
					{
						SelectedRemotely();
					}
					else if(attributes->value.u.viewState.choice == unselected_chosen)
					{
						ClearSelectionFlags();
					}

					TRACE_DEBUG(("Attribute viewState %d", attributes->value.u.viewState.choice));
				}
				else
				{
					// Do the non Standard lineStyle NYI
					;
				}
				break;
			}

			case(DrawingAttribute_zOrder_chosen):
			{
				SetZOrder(attributes->value.u.zOrder);
				TRACE_DEBUG(("Attribute zOrder %d", attributes->value.u.zOrder));
				break;

			}
			case(DrawingAttribute_nonStandardAttribute_chosen):
			{
				break; // NYI
			}

			default:
		    ERROR_OUT(("Invalid attributes choice"));
			break;
		}

		attributes = attributes->next;
	}
	
}


UINT    DrawObj::GetSubsequentPoints(UINT choice, POINT * initialPoint, PointList * pointList)
{
	UINT numberOfPoints = 0;
	INT deltaX, deltaY;

	POINT point;
	if(choice == pointsDiff16_chosen)
	{
		PPointList_pointsDiff16 drawingPoint = pointList->u.pointsDiff16;
		deltaX = (SHORT)initialPoint->x;
		deltaY = (SHORT)initialPoint->y;
 		TRACE_DEBUG(("initialpoint (%d,%d)", deltaX, deltaY));

		while(drawingPoint)
		{
			numberOfPoints++;
	    	point.x = drawingPoint->value.xCoordinate;
   			point.y = drawingPoint->value.yCoordinate;
	        m_points->Add(point);
			deltaX += point.x;
			deltaY += point.y;
			drawingPoint = drawingPoint->next;
		}
	}
	else
	{
		TRACE_DEBUG(("GetSubsequentPoints got points != pointsDiff16_chosen"));
	}

	TRACE_DEBUG(("Got %d points", numberOfPoints));

	return numberOfPoints;
}



void DrawObj::CreateDrawingCreatePDU(DrawingCreatePDU *pCreatePDU)
{
	int nPoints = 1;
	pCreatePDU->bit_mask = 0;

	//
	// Pass the drawing Handle
	//
	pCreatePDU->bit_mask |=drawingHandle_present;
	pCreatePDU->drawingHandle = GetThisObjectHandle();

	//
	// Pass the destination adress
	//
	pCreatePDU->destinationAddress.choice = DrawingDestinationAddress_softCopyAnnotationPlane_chosen;
	pCreatePDU->destinationAddress.u.softCopyAnnotationPlane.workspaceHandle = GetWorkspaceHandle();
	pCreatePDU->destinationAddress.u.softCopyAnnotationPlane.plane = (DataPlaneID)GetPlaneID();

	//
	// Pass the drawing type
	//
	pCreatePDU->drawingType.choice = (ASN1choice_t)GetDrawingType();

	//
	// Pass the attributes
	//
	SetDrawingAttrib(&pCreatePDU->attributes);
	if(pCreatePDU->attributes != NULL)
	{
		pCreatePDU->bit_mask |=DrawingCreatePDU_attributes_present;
	}


	//
	// Pass the anchor point
	//
	POINT point;
	GetAnchorPoint(&point);
	pCreatePDU->anchorPoint.xCoordinate = point.x;
	pCreatePDU->anchorPoint.yCoordinate = point.y;

	RECT  rect;
	GetRect(&rect);


	pCreatePDU->pointList.choice = pointsDiff16_chosen;
	DBG_SAVE_FILE_LINE
	pCreatePDU->pointList.u.pointsDiff16 = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
	PPointList_pointsDiff16 drawingPoint = pCreatePDU->pointList.u.pointsDiff16;
	PPointList_pointsDiff16 drawingPointLast = NULL;
	drawingPoint->next = NULL;

	switch(GetDrawingType())
	{

		case point_chosen:
		drawingPoint->value.xCoordinate = 0;
		drawingPoint->value.yCoordinate = 0;
		drawingPoint->next = NULL;
		break;

		case openPolyLine_chosen:
		case closedPolyLine_chosen:
		case rectangle_chosen:
		case ellipse_chosen:
		{
			nPoints = m_points->GetSize();
			UINT maxPoints = 1;
			POINT * pPoint = m_points->GetBuffer();
			while(nPoints && maxPoints < (MAX_POINT_LIST_VALUES + 1))
			{
				drawingPoint->value.xCoordinate = (SHORT)pPoint->x;
				drawingPoint->value.yCoordinate = (SHORT)pPoint->y;
				drawingPointLast = drawingPoint;
				DBG_SAVE_FILE_LINE
				drawingPoint->next = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
				drawingPoint = drawingPoint->next;
				nPoints--;
				pPoint++;
				maxPoints++;
			}
			if(drawingPointLast)
			{
				delete drawingPointLast->next;
				drawingPointLast->next = NULL;
			}
			
		}
		break;		
	}
	
}
	
void DrawObj::CreateDrawingEditPDU(DrawingEditPDU *pEditPDU)
{
	pEditPDU->bit_mask = (ASN1uint16_t) GetPresentAttribs();

	//
	// Pass the anchor point
	//
	POINT point;
	GetAnchorPoint(&point);

	if(HasAnchorPointChanged())
	{
		pEditPDU->anchorPointEdit.xCoordinate = point.x;
		pEditPDU->anchorPointEdit.yCoordinate = point.y;
	}

	pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16 = NULL;

	//
	// Pass point list changes
	//
	if(HasPointListChanged())
	{

		UINT nPoints = m_points->GetSize();
		POINT * pPoint = m_points->GetBuffer();

		pPoint = &pPoint[1];

		//
		// Just send the last 255 points
		//
		if(nPoints > 256)
		{
			pEditPDU->pointListEdits.value[0].initialIndex = nPoints - 256;
			nPoints = 256;
		}
		else
		{
			pEditPDU->pointListEdits.value[0].initialIndex = 0;
		}

		//
		// Calculate the initial point
		//
		point.x = 0;
		point.y = 0;
		for(UINT i = 0; i < pEditPDU->pointListEdits.value[0].initialIndex; i++)
		{
			point.x += pPoint[i].x;
			point.y += pPoint[i].y;
		}

		pEditPDU->pointListEdits.count = 1;
		pEditPDU->pointListEdits.value[0].bit_mask = subsequentPointEdits_present;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.choice = pointsDiff16_chosen;
		pEditPDU->pointListEdits.value[0].initialPointEdit.xCoordinate = (SHORT)point.x;
		pEditPDU->pointListEdits.value[0].initialPointEdit.yCoordinate = (SHORT)point.y;

		TRACE_DEBUG(("Sending List of points starting at Index = %d  point(%d,%d)",
			pEditPDU->pointListEdits.value[0].initialIndex, point.x, point.y));


		pPoint = &pPoint[pEditPDU->pointListEdits.value[0].initialIndex];

		DBG_SAVE_FILE_LINE
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16 = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
		PPointList_pointsDiff16 drawingPointLast = NULL;
		PPointList_pointsDiff16 drawingPoint = pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->next = NULL;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->value.xCoordinate = 0;
		pEditPDU->pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16->value.yCoordinate = 0;

		
		nPoints--;
		while(nPoints)
		{
			drawingPoint->value.xCoordinate = (SHORT)pPoint->x;
			drawingPoint->value.yCoordinate = (SHORT)pPoint->y;
			drawingPointLast = drawingPoint;
			DBG_SAVE_FILE_LINE
			drawingPoint->next = (PPointList_pointsDiff16)new BYTE[sizeof(PointList_pointsDiff16)];
			drawingPoint = drawingPoint->next;
			nPoints--;
			pPoint++;
		}
		if(drawingPointLast)
		{
			delete drawingPointLast->next;
			drawingPointLast->next = NULL;
		}
	}

	//
	// JOSEF Pass rotation if we ever do it (FEATURE)
	//
	
	//
	// Pass all the changed attributes, if any.
	//
	if(pEditPDU->bit_mask & DrawingEditPDU_attributeEdits_present)
	{
		SetDrawingAttrib((PDrawingCreatePDU_attributes *)&pEditPDU->attributeEdits);
	}

	pEditPDU->drawingHandle = GetThisObjectHandle();
}
	
void DrawObj::CreateDrawingDeletePDU(DrawingDeletePDU *pDeletePDU)
{
	pDeletePDU->bit_mask = 0;
	pDeletePDU->drawingHandle = GetThisObjectHandle();
}

void    DrawObj::AllocateAttrib(PDrawingCreatePDU_attributes *pAttributes)
{
	DBG_SAVE_FILE_LINE
	PDrawingCreatePDU_attributes  pAttrib = (PDrawingCreatePDU_attributes)new BYTE[sizeof(DrawingCreatePDU_attributes)];
	if(*pAttributes == NULL)
	{
		*pAttributes = pAttrib;	
		pAttrib->next = NULL;
	}
	else
	{
		((PDrawingCreatePDU_attributes)pAttrib)->next = *pAttributes;
		*pAttributes = pAttrib;
	}
}

void    DrawObj::SetDrawingAttrib(PDrawingCreatePDU_attributes *pattributes)
{

	PDrawingCreatePDU_attributes attributes = NULL;
	RGBTRIPLE color;

	//
	// Do the pen Color
	//
	if(HasPenColorChanged())
	{
		if(GetPenColor(&color))
		{
			AllocateAttrib(&attributes);
			attributes->value.choice = penColor_chosen;
			attributes->value.u.penColor.choice = rgbTrueColor_chosen;
			attributes->value.u.penColor.u.rgbTrueColor.r = color.rgbtRed;
			attributes->value.u.penColor.u.rgbTrueColor.g = color.rgbtGreen;
			attributes->value.u.penColor.u.rgbTrueColor.b = color.rgbtBlue;
		}
	}

	//
	// Do the fillColor
	//
	if(HasFillColorChanged())
	{
		if(GetFillColor(&color))
		{
			AllocateAttrib(&attributes);
			attributes->value.choice = fillColor_chosen;
			attributes->value.u.fillColor.choice = rgbTrueColor_chosen;
			attributes->value.u.fillColor.u.rgbTrueColor.r = color.rgbtRed;
			attributes->value.u.fillColor.u.rgbTrueColor.g = color.rgbtGreen;
			attributes->value.u.fillColor.u.rgbTrueColor.b = color.rgbtBlue;
		}
	}
	
	//
	// Do the penThickness
	//
	if(HasPenThicknessChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = penThickness_chosen;
		attributes->value.u.penThickness = (PenThickness)GetPenThickness();
	}

	//
	// Do the penNib
	//
	if(HasPenNibChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = penNib_chosen;
		attributes->value.u.penNib.choice = (ASN1choice_t)GetPenNib();
	}

	//
	// Do the lineStyle
	//
	if(HasLineStyleChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = lineStyle_chosen;
		attributes->value.u.lineStyle.choice = GetLineStyle()+1;
	}
	
	//
	// Do the Highlight
	//
	if(HasHighlightChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = highlight_chosen;
		attributes->value.u.highlight = (ASN1bool_t)GetHighlight();
	}
	
	//
	// Do the viewState
	//
	if(HasViewStateChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = DrawingAttribute_viewState_chosen;
		attributes->value.u.viewState.choice = (ASN1choice_t)GetViewState();
	}
	
	//
	// Do the zOrder
	//
	if(HasZOrderChanged())
	{
		AllocateAttrib(&attributes);
		attributes->value.choice = DrawingAttribute_zOrder_chosen;
		attributes->value.u.zOrder = GetZOrder();
	}

	*pattributes = attributes;

}






//
// CircleHit()
//
// Checks for overlap between circle at PcxPcy with uRadius and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL CircleHit( LONG Pcx, LONG Pcy, UINT uRadius, LPCRECT lpHitRect,
					BOOL bCheckPt )
{
	RECT hr = *lpHitRect;
	RECT ellipse;
	ellipse.left = Pcx - uRadius;
	ellipse.right= Pcx + uRadius;
	ellipse.bottom = Pcy + uRadius;
	ellipse.top = Pcy - uRadius;


	// check the easy thing first (don't use PtInRect)
	if( bCheckPt &&(lpHitRect->left >= ellipse.left)&&(ellipse.right >= lpHitRect->right)&&
				   (lpHitRect->top >= ellipse.top)&&(ellipse.bottom >= lpHitRect->bottom))
	{
		return( TRUE );
	}

	//
	// The circle is just a boring ellipse
	//
	return EllipseHit(&ellipse, bCheckPt,  uRadius, lpHitRect );
}


//
// EllipseHit()
//
// Checks for overlap between ellipse defined by lpEllipseRect and
// lpHitRect. If overlap TRUE is returned, otherwise FALSE.
//
BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth,
					 LPCRECT lpHitRect )
{
	RECT hr = *lpHitRect;
	RECT er = *lpEllipseRect;

	// Some code below assumes l<r and t<b
	NormalizeRect(&er);
	lpEllipseRect = &er;

	// Check easy thing first. If lpEllipseRect is inside lpHitRect
	// then we have a hit (no duh...)
	if( (hr.left <= lpEllipseRect->left)&&(hr.right >= lpEllipseRect->right)&&
		(hr.top <= lpEllipseRect->top)&&(hr.bottom >= lpEllipseRect->bottom) )
		return( TRUE );

	// Check easy thing first. If lpEllipseRect is disjoint from lpHitRect
	// then we have a miss (no duh...)
	if( (hr.left > lpEllipseRect->right)||(hr.right < lpEllipseRect->left)||
		(hr.top > lpEllipseRect->bottom)||(hr.bottom < lpEllipseRect->top) )
		return( FALSE );

	// If this is an ellipse....
	//
	//		*  *         ^
	//	 *     | b       | Y
	// *       |    a    +-------> X
	// *-------+--------
	//         |
	//
		
	
	//
	// Look for the ellipse hit. (x/a)^2 + (y/b)^2 = 1
	// If it is > 1 than the point is outside the ellipse
	// If it is < 1 it is inside
	//
	LONG a,b,aOuter, bOuter, x, y, xCenter, yCenter;
	BOOL bInsideOuter = FALSE;
	BOOL bOutsideInner = FALSE;

	//
	// Calculate a and b
	//
	a = (lpEllipseRect->right - lpEllipseRect->left)/2;
	b = (lpEllipseRect->bottom - lpEllipseRect->top)/2;

	//
	// Get the center of the ellipse
	//
	xCenter = lpEllipseRect->left + a;
	yCenter = lpEllipseRect->top + b;

	//
	// a and b generates a inner ellipse
	// aOuter and bOuter generates a outer ellipse
	//
	aOuter = a + uPenWidth/2;
	bOuter = b + uPenWidth/2;
	a = a - uPenWidth/2;
	b = b - uPenWidth/2;

	//
	// Make our coordinates relative to the center of the ellipse
	//
	y = abs(hr.bottom - yCenter);
	x = abs(hr.right - xCenter);

	
	//
	// Be carefull not to divide by 0
	//
	if((a && b && aOuter && bOuter) == 0)
	{
		return FALSE;
	}

	//
	// We are using LONG instead of double and we need to have some precision
	// that is why we multiply the equation of the ellipse
	// ((x/a)^2 + (y/b)^2 = 1) by DECIMAL_PRECISION
	// Note that the multiplication has to be done before the division, if we didn't do that
	// we will always get 0 or 1 for x/a
	//
	if(x*x*DECIMAL_PRECISION/(aOuter*aOuter) + y*y*DECIMAL_PRECISION/(bOuter*bOuter) <= DECIMAL_PRECISION)
	{
		bInsideOuter = TRUE;
	}

	if(x*x*DECIMAL_PRECISION/(a*a)+ y*y*DECIMAL_PRECISION/(b*b) >= DECIMAL_PRECISION)
	{
		bOutsideInner = TRUE;
	}
	
	//
	// If we are checking for border hit,
	// we need to be inside the outer ellipse and inside the inner
	//
	if( bBorderHit )
	{
			return( bInsideOuter & bOutsideInner );
	}
	// just need to be inside the outer ellipse
	else
	{
		return( bInsideOuter );
	}

}


//
// LineHit()
//
// Checks for overlap (a "hit") between lpHitRect and the line
// P1P2 accounting for line width. If bCheckP1End or bCheckP2End is
// TRUE then a circle of radius 0.5 * uPenWidth is also checked for
// a hit to account for the rounded ends of wide lines.
//
// If a hit is found TRUE is returned, otherwise FALSE.
//
BOOL LineHit( LONG P1x, LONG P1y, LONG P2x, LONG P2y, UINT uPenWidth,
				  BOOL bCheckP1End, BOOL bCheckP2End,
				  LPCRECT lpHitRect )
{

	LONG uHalfPenWidth = uPenWidth/2;

	//
	// It is really hard to hit if the width is only 2
	//
	if(uHalfPenWidth == 1)
	{
		uHalfPenWidth = 2;
	}

	LONG a,b,x,y;

	x = lpHitRect->left + (lpHitRect->right - lpHitRect->left)/2;
	y = lpHitRect->bottom + (lpHitRect->top - lpHitRect->bottom)/2;

	//
	// This code assume the rectangle is normalized
	//
	RECT rect;
	rect.top = P1y;
	rect.left = P1x;
	rect.bottom = P2y;
	rect.right = P2x;

	NormalizeRect(&rect);

	if( (P1x == P2x)&&(P1y == P2y) )
	{
		// just check one end point's circle
		return( CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, TRUE ) );
	}

	// check rounded end at P1
	if( bCheckP1End && CircleHit( P1x, P1y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );

	// check rounded end at P2
	if( bCheckP2End && CircleHit( P2x, P2y, uHalfPenWidth, lpHitRect, FALSE ) )
		return( TRUE );
	
	//
	// The function of a line is Y = a.X + b
	//
	// a = (Y1-Y2)/(X1 -X2)
	// if we found a we get b = y1 -a.X1
	//

	if(P1x == P2x)
	{
		a=0;
		b = DECIMAL_PRECISION*P1x;

	}
	else
	{
		a = (P1y - P2y)*DECIMAL_PRECISION/(P1x - P2x);
		b = DECIMAL_PRECISION*P1y - a*P1x;
	}


	//
	// Paralel to Y
	//
	if(P1x == P2x && ((x >= P1x - uHalfPenWidth) && x <= P1x + uHalfPenWidth))
	{
		return (P1y <= y && P2y >= y);
	}

	//
	// Paralel to X
	//
	if(P1y == P2y && ((y >= P1y - uHalfPenWidth) && y <= P1y + uHalfPenWidth))
	{
		return (P1x <= x && P2x >= x);
	}

	//
	// General line
	//

	return(( y*DECIMAL_PRECISION <= a*x + b + DECIMAL_PRECISION*uHalfPenWidth) &&
			( y*DECIMAL_PRECISION >= a*x + b - DECIMAL_PRECISION*uHalfPenWidth)&&
			((rect.top <= y && rect.bottom >= y) && (rect.left <= x && rect.right >= x)));
}





//
// Checks object for an actual overlap with pRectHit. This
// function assumes that the boundingRect has already been
// compared with pRectHit.
//
BOOL DrawObj::PolyLineHit(LPCRECT pRectHit)
{
	POINT	*lpPoints;
	int		iCount;
	int		i;
	POINT	ptLast;
	UINT	uRadius;
	RECT	rectHit;

	iCount = m_points->GetSize();
	lpPoints = (POINT *)m_points->GetBuffer();

	if( iCount == 0 )
		return( FALSE );


	// addjust hit rect to lpPoints coord space.
	rectHit = *pRectHit;
	POINT anchorPoint;
	GetAnchorPoint(&anchorPoint);

	if( (iCount > 0)&&(iCount < 2) )
	{
		// only one point, just hit check it
		uRadius = GetPenThickness() >> 1; // m_uiPenWidth/2
		return(CircleHit( anchorPoint.x + lpPoints->x, anchorPoint.y - lpPoints->y, uRadius, &rectHit, TRUE ));
	}


	// look for a hit on each line segment body
	ptLast = anchorPoint;
	for( i=1; i<iCount; i++ )
	{
		RECT rect;
		rect.top = ptLast.y;
		rect.left = ptLast.x;
		rect.bottom =  ptLast.y + lpPoints->y;
		rect.right = ptLast.x + lpPoints->x;
		NormalizeRect(&rect);

		if( LineHit(rect.left, rect.top, rect.right, rect.bottom, GetPenThickness(), TRUE, TRUE, &rectHit))
		{
			return( TRUE ); // got a hit
		}

		lpPoints++;
		ptLast.x +=lpPoints->x;
		ptLast.y +=lpPoints->y;
	}

	// now, look for a hit on the line endpoints if m_uiPenWidth > 1
	if( GetPenThickness() > 1 )
	{
		uRadius = GetPenThickness() >> 1; // m_uiPenWidth/2
		lpPoints = (POINT *)m_points->GetBuffer();
		for( i=0; i<iCount; i++, lpPoints++ )
		{
			if( CircleHit( anchorPoint.x + lpPoints->x, anchorPoint.y + lpPoints->y, uRadius, &rectHit, FALSE ))
			{
				return( TRUE ); // got a hit
			}
		}
	}

	return( FALSE ); // no hits
}




DrawObj::CheckReallyHit(LPCRECT pRectHit)
{
	RECT rect;
	
	switch(GetDrawingType())
	{
		case point_chosen:
		case openPolyLine_chosen:
		{
			UINT nPoints = m_points->GetSize();
			if(nPoints > 2 )
			{
				return PolyLineHit(pRectHit);
			}
			else
			{
				GetRect(&rect);
				return(LineHit(rect.left, rect.top, rect.right, rect.bottom, GetPenThickness(), TRUE, TRUE, pRectHit));
	       	}
       }
		break;

		case rectangle_chosen:
		{
		    // Draw the rectangle
		    return(RectangleHit(!HasFillColor(), pRectHit));
		}
		break;
		
		case ellipse_chosen:
		{
			GetRect(&rect);
		    return( EllipseHit( &rect, !HasFillColor(), GetPenThickness(), pRectHit ));

		}
		break;
	}

	return FALSE;
}

void DrawObj::UnDraw(void)
{
	RECT rect;
	UINT penThickness;
	GetBoundsRect(&rect);
	penThickness = GetPenThickness();
	::InflateRect(&rect, penThickness, penThickness);
	g_pDraw->InvalidateSurfaceRect(&rect,TRUE);

	BitmapObj* remotePointer = NULL;
	WBPOSITION pos = NULL;
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, penThickness, NULL);
	while(remotePointer)
	{
		remotePointer->DeleteSavedBitmap();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, penThickness, remotePointer->GetMyPosition());
	}
}


void DrawObj::Draw(HDC hDC, BOOL bForcedDraw, BOOL bPrinting)
{

	if(!bPrinting)
	{
		//
		// Don't draw anything if we don't belong in this workspace
		//
		if(!(GraphicTool() == TOOLTYPE_SELECT || GraphicTool() == TOOLTYPE_ERASER) && GetWorkspaceHandle() != g_pCurrentWorkspace->GetThisObjectHandle())
		{
			return;
		}
	}

	HPEN	hPen = NULL;
	HPEN	hOldPen = NULL;
	HBRUSH	hBrush = NULL;
	HBRUSH  hOldBrush = NULL;
	BOOL	bHasPenColor;
	BOOL	bHasFillColor;
	BitmapObj* remotePointer = NULL;
	COLORREF color;
	COLORREF fillColor;
	RECT boundsRect;
	RECT rect;
	UINT penThickness = GetPenThickness();

	if(hDC == NULL)
	{
		hDC = g_pDraw->m_hDCCached;
	}

	MLZ_EntryOut(ZONE_FUNCTION, "DrawObj::Draw");

	// Select the required pen and fill color
	bHasPenColor = GetPenColor(&color);
	bHasFillColor = GetFillColor(&fillColor);

	if(bHasFillColor)
	{
		hBrush = ::CreateSolidBrush(SET_PALETTERGB(fillColor));
		hOldBrush = SelectBrush(hDC, hBrush);
	}
	else
	{
		hOldBrush = SelectBrush(hDC, ::GetStockObject(NULL_BRUSH));
	}

	//
	// Get rect
	//
	GetBoundsRect(&boundsRect);
	GetRect(&rect);


	hPen = ::CreatePen(GetLineStyle(), penThickness, SET_PALETTERGB(color));
	hOldPen = SelectPen(hDC, hPen);


	if (hOldPen != NULL)
	{

		// Select the raster operation
		int iOldROP = ::SetROP2(hDC, GetROP());

		switch(GetDrawingType())
		{
			case point_chosen:
			case openPolyLine_chosen:
			{
				UINT nPoints = m_points->GetSize();
				//
				// This is a redraw of a pen or highlight
				// We have to draw all the segments
				//
				if( (bForcedDraw || GetIsCompleted()) && nPoints  > 1)
				{
					POINT anchorPoint;
					GetAnchorPoint(&anchorPoint);

					AddPointToBounds(anchorPoint.x, anchorPoint.y);

					//
					// Go to the beggining
					//
					::MoveToEx(hDC, anchorPoint.x, anchorPoint.y, NULL);

					//
					// Get the list of points
					//
					POINT *point = m_points->GetBuffer();
					while(nPoints)
					{
						anchorPoint.x += point->x;
						anchorPoint.y += point->y;
						::LineTo(hDC, anchorPoint.x, anchorPoint.y);
						::MoveToEx(hDC, anchorPoint.x, anchorPoint.y, NULL);
						point++;
						nPoints--;

						RECT rect1;
						MAKE_HIT_RECT(rect1, anchorPoint);
						if(remotePointer)
						{
							remotePointer->Draw();
							remotePointer = NULL;
						}

						AddPointToBounds(anchorPoint.x, anchorPoint.y);

						::InflateRect(&rect1, GetPenThickness()/2, GetPenThickness()/2);
						remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect1, GetPenThickness()/2, NULL);

					}
									
				}
				else
				{
					// Draw the line
					::MoveToEx(hDC, rect.left, rect.top, NULL);
					::LineTo(hDC, rect.right, rect.bottom);
				}
			}
			break;


			case rectangle_chosen:
			{

				TRACE_DEBUG(("RECTANGLE %d, %d, %d , %d", rect.left, rect.top, rect.right, rect.bottom ));

				// Draw the rectangle
				::Rectangle(hDC, rect.left, rect.top, rect.right, rect.bottom);
			}
			break;
			
			case ellipse_chosen:
			{
				::Ellipse(hDC, rect.left, rect.top, rect.right, rect.bottom);
			}
			break;
	
			case closedPolyLine_chosen:
			default:
			TRACE_DEBUG(("Unsupported DrawingType", GetDrawingType()));
			break;
		}

		//
		// De-select the brush
		//
		SelectBrush(hDC, hOldBrush);

		// De-select the pen and ROP
		::SetROP2(hDC, iOldROP);
		SelectPen(hDC, hOldPen);
	}

    //
    // Do NOT draw focus if clipboard or printing
    //
	if (WasSelectedLocally() && (hDC == g_pDraw->m_hDCCached))
	{
		DrawRect();
	}

	if (hPen != NULL)
	{
		::DeletePen(hPen);
	}

	if (hBrush != NULL)
	{
		::DeleteBrush(hBrush);
	}

	if(remotePointer)
	{
		remotePointer->Draw();
	}

	//
	// Now for rectangles ellipses and lines, check if we are on top of any remote pointer
	//

	remotePointer = NULL;
	WBPOSITION pos = NULL;
	::InflateRect(&rect, GetPenThickness()/2, GetPenThickness()/2);
	remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, GetPenThickness()/2, NULL);
	while(remotePointer)
	{
		remotePointer->DeleteSavedBitmap();
		remotePointer->Draw();
		remotePointer = g_pCurrentWorkspace->RectHitRemotePointer(&rect, GetPenThickness()/2, remotePointer->GetMyPosition());
	}
}

void DrawObj::SetPenColor(COLORREF rgb, BOOL isPresent)
{
	ChangedPenColor();
	m_bIsPenColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_penColor.rgbtRed = GetRValue(rgb);
	m_penColor.rgbtGreen = GetGValue(rgb);
	m_penColor.rgbtBlue = GetBValue(rgb);

}

BOOL DrawObj::GetPenColor(COLORREF * rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = RGB(m_penColor.rgbtRed, m_penColor.rgbtGreen, m_penColor.rgbtBlue);
	}
	return m_bIsPenColorPresent;
}

BOOL DrawObj::GetPenColor(RGBTRIPLE* rgb)
{
	if(m_bIsPenColorPresent)
	{
		*rgb = m_penColor;
	}
	return m_bIsPenColorPresent;
}


void DrawObj::SetFillColor(COLORREF rgb, BOOL isPresent)
{
	ChangedFillColor();
	m_bIsFillColorPresent = isPresent;
	if(!isPresent)
	{
		return;
	}
	
	m_fillColor.rgbtRed = GetRValue(rgb);
	m_fillColor.rgbtGreen = GetGValue(rgb);
	m_fillColor.rgbtBlue = GetBValue(rgb);

}

BOOL DrawObj::GetFillColor(COLORREF* rgb)
{
	if(m_bIsFillColorPresent && rgb !=NULL)
	{
		*rgb = RGB(m_fillColor.rgbtRed, m_fillColor.rgbtGreen, m_fillColor.rgbtBlue);
	}
	return m_bIsFillColorPresent;
}

BOOL DrawObj::GetFillColor(RGBTRIPLE* rgb)
{
	if(m_bIsFillColorPresent && rgb!= NULL)
	{
		*rgb = m_fillColor;
	}
	return m_bIsFillColorPresent;
}


BOOL DrawObj::AddPoint(POINT point)
{
    BOOL bSuccess = TRUE;

    MLZ_EntryOut(ZONE_FUNCTION, "DrawObj::::AddPoint");

	int nPoints = m_points->GetSize();

    // if we've reached the maximum number of points then quit with failure
    if (nPoints >= MAX_FREEHAND_POINTS)
    {
        bSuccess = FALSE;
        TRACE_DEBUG(("Maximum number of points for freehand object reached."));
        return(bSuccess);
    }

    m_points->Add(point);
	nPoints++;

	ChangedPointList();


	//
	// If we hit the 256 limit fake a timer notification and resend the polyline
	//
	if((nPoints & 0xff) == 0)
	{
		g_pDraw->OnTimer(0);
	}
	
	
    return(bSuccess);
}


void DrawObj::AddPointToBounds(int x, int y)
{
    // Create a rectangle containing the point just added (expanded
    // by the width of the pen being used).
    RECT  rect;
	RECT  boundsRect;
	rect.left   = x - 1;
    rect.top    = y - 1;
    rect.right  = x + 1;
    rect.bottom = y + 1;


	GetBoundsRect(&boundsRect);
	::UnionRect(&boundsRect, &boundsRect, &rect);
    SetBoundsRect(&boundsRect);
}


void GetDrawingDestinationAddress(DrawingDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID)
{

	//
	// Get the destination address
	//
	switch(destinationAddress->choice)
	{

		case(DrawingDestinationAddress_softCopyAnnotationPlane_chosen):
		{
			*workspaceHandle = (destinationAddress->u.softCopyAnnotationPlane.workspaceHandle);
			*planeID = (destinationAddress->u.softCopyAnnotationPlane.plane);
			break;
		}
//		case(DrawingDestinationAddress_nonStandardDestination_chosen):
//		{
//			break;
//		}

		default:
	    ERROR_OUT(("Invalid destinationAddress"));
		break;
	}
}


void DrawObj::SetUIToolType(void)
{
	UINT drawingType = GetDrawingType();
	BOOL filled	= HasFillColor();

	UINT rop = R2_COPYPEN;

    switch (drawingType)
    {
    	case openPolyLine_chosen:
    	{
			if(m_points->GetSize() > 1)
			{
				if(GetHighlight())
				{
					m_ToolType = TOOLTYPE_HIGHLIGHT;
					 rop = R2_MASKPEN;

				}
				else
				{
					m_ToolType = TOOLTYPE_PEN;	
				}

			}
			else
			{
				m_ToolType = TOOLTYPE_LINE;	
			}
    	}
    	break;
    	
		case rectangle_chosen:
		{
			if(filled)
			{
				m_ToolType = TOOLTYPE_FILLEDBOX;
			}
			else
			{
				m_ToolType = TOOLTYPE_BOX;
			}
		}
		break;

		case ellipse_chosen:
		{
			if(filled)
			{
				m_ToolType = TOOLTYPE_FILLEDELLIPSE;
			}
			else
			{
				m_ToolType = TOOLTYPE_ELLIPSE;
			}
		}
		break;
	}	

	SetROP(rop);
}



//
// UI Edited the Drawing Object
//
void	DrawObj::OnObjectEdit(void)
{
	g_bContentsChanged = TRUE;

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingEditPDU_chosen;

		CreateDrawingEditPDU(&sipdu->u.drawingEditPDU);

		TRACE_DEBUG(("Sending Drawing Edit >> Drawing handle  = %d", sipdu->u.drawingEditPDU.drawingHandle ));

		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
			ResetAttrib();
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}

//
// UI Deleted the Drawing Object
//
void	DrawObj::OnObjectDelete(void)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingDeletePDU_chosen;
		CreateDrawingDeletePDU(&sipdu->u.drawingDeletePDU);
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}

}

//
// Get the encoded buffer for Drawing Create PDU
//
void	DrawObj::GetEncodedCreatePDU(ASN1_BUF *pBuf)
{
	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingCreatePDU_chosen;
		CreateDrawingCreatePDU(&sipdu->u.drawingCreatePDU);

		ASN1_BUF encodedPDU;
		g_pCoder->Encode(sipdu, pBuf);

		SIPDUCleanUp(sipdu);
	}
	else
	{
		TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);

	}
}


//
// UI Created a new Drawing Object
//
void DrawObj::SendNewObjectToT126Apps(void)
{

	SIPDU *sipdu = NULL;
	DBG_SAVE_FILE_LINE
	sipdu = (SIPDU *) new BYTE[sizeof(SIPDU)];
	if(sipdu)
	{
		sipdu->choice = drawingCreatePDU_chosen;
		CreateDrawingCreatePDU(&sipdu->u.drawingCreatePDU);

		TRACE_DEBUG(("Sending Drawing >> Drawing handle  = %d", sipdu->u.drawingCreatePDU.drawingHandle ));
		T120Error rc = SendT126PDU(sipdu);
		if(rc == T120_NO_ERROR)
		{
			SIPDUCleanUp(sipdu);
		}
	}
	else
	{
		TRACE_MSG(("Failed to create sipdu"));
        ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
	}
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\gcchelp.h ===
//
// GCCHELP.H
// GCC Helper functions
//
// Copyright Microsoft 1998-
//

void T126_GCCAllocateHandleConfirm(ULONG, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\gccmsg.h ===
#ifndef GCCMSG_H
#define GCCMSG_H
#include <igccapp.h>

GCCError CreateSap(void);
GCCError DeleteSap(void);

void CALLBACK DispatchGCCNotification( GCCAppSapMsg *pMsg );
#endif //GCCMSG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\gcchelp.cpp ===
//
// GCCHELP.CPP
// GCC helper functions
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"
#include "gcchelp.h"

void	T126_GCCAllocateHandleConfirm(ULONG drawingHandle, ULONG handle_range)
{
	g_WaitingForGCCHandles = FALSE;
	TRACE_MSG(("T126_GCCAllocateHandleConfirm drawing handle = %d, range = %d", drawingHandle, handle_range));

	TRACE_MSG(("GCC Tank 0 has %d GCC handles ", g_GCCPreallocHandles[0].GccHandleCount));
	TRACE_MSG(("GCC Tank 1 has %d GCC handles ", g_GCCPreallocHandles[1].GccHandleCount));

	ULONG gccHandle;
	if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
	{
		TRACE_MSG(("Using GCC Tank %d ", g_iGCCHandleIndex));

		g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle = drawingHandle;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = handle_range;
	}
	else
	{
		UINT index = g_iGCCHandleIndex ? 0 : 1;
		TRACE_MSG(("T126_GCCAllocateHandleConfirm: Using GCC Tank %d that contains %d handles",
							index, g_GCCPreallocHandles[index].GccHandleCount ));
		TRACE_MSG(("Filling up GCC Tank %d ", index));
		g_GCCPreallocHandles[index].InitialGCCHandle = drawingHandle;
		g_GCCPreallocHandles[index].GccHandleCount = handle_range;
	}

	if(handle_range <= 2)
	{
		gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - handle_range;
		g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount = g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - handle_range;

		//
		// Remove the drawing object from the list of objects to send
		//
		T126Obj * pT126Obj = (T126Obj*)g_pListOfObjectsThatRequestedHandles->RemoveTail();

		if(!pT126Obj)
		{
			return;
		}

		pT126Obj->GotGCCHandle(gccHandle);

	}
	else
	{
		
		if(handle_range != PREALLOC_GCC_HANDLES)
		{

			//
			// Resend all objects
			//
			WBPOSITION pos;
			WBPOSITION posObj;
			WorkspaceObj* pWorkspace;
			ULONG	workspaceHandle;
			T126Obj* pObj;

			pos = g_pListOfWorkspaces->GetHeadPosition();

			while(pos)
			{
				gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - 2;
				
				if(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount == 0)
				{
					//
					// Time to switch to the other tank
					//
					g_iGCCHandleIndex =  g_iGCCHandleIndex ? 0 : 1;
				}
					
				
				ASSERT(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount);
				g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount -=2;
				
				workspaceHandle = gccHandle;
				pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
				pWorkspace->SetThisObjectHandle(workspaceHandle);
				pWorkspace->SetWorkspaceHandle(workspaceHandle);
				pWorkspace->SetOwnerID(g_MyMemberID);
				pWorkspace->SetViewHandle(workspaceHandle + 1);

				posObj = pWorkspace->GetHeadPosition();
				while(posObj)
				{
					pObj = pWorkspace->GetNextObject(posObj);
					if(pObj)
					{
						gccHandle = g_GCCPreallocHandles[g_iGCCHandleIndex].InitialGCCHandle + g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount - 1;
						ASSERT(g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount);
						g_GCCPreallocHandles[g_iGCCHandleIndex].GccHandleCount--;
						pObj->SetThisObjectHandle(gccHandle);
						pObj->SetWorkspaceHandle(workspaceHandle);
						pObj->SetOwnerID(g_MyMemberID);
					}
				}
			}
		}
	}


	//
	// Check if we have enough handles or shoul switch
	//
	TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
	SetFakeGCCHandle(drawingHandle + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\drawobj.hpp ===
//
// DRAWOBJ.HPP
// Drawing objects: point, openpolyline, closepolyline, ellipse
//
// Copyright Microsoft 1998-
//
#ifndef __DRAWOBJ_HPP_
#define __DRAWOBJ_HPP_

//
// Maximum number of points in a freehand object
//
#define MAX_FREEHAND_POINTS     65535
#define MAX_POINT_LIST_VALUES   255

BOOL EllipseHit(LPCRECT lpEllipseRect, BOOL bBorderHit, UINT uPenWidth, LPCRECT lpHitRect );
void GetDrawingDestinationAddress(DrawingDestinationAddress *destinationAddress, PUINT workspaceHandle, PUINT planeID);

typedef struct tagCOLOR_PRESENT
{
	BOOL		m_bIsPresent;
	RGBTRIPLE	m_color;
}COLOR;


class DrawObj : public T126Obj
{

public:

	DCDWordArray *	m_points;				// List of consecutive points including anchor point


	DrawObj (UINT drawingType, UINT toolType);
	DrawObj ( DrawingCreatePDU * pdrawingCreatePDU );
	void DrawEditObj ( DrawingEditPDU * pdrawingEditPDU );

	~DrawObj( void );

	void Draw(HDC hDC = NULL, BOOL bForcedDraw = FALSE, BOOL bPrinting = FALSE);
	BOOL PolyLineHit(LPCRECT pRectHit);
	BOOL CheckReallyHit(LPCRECT pRectHit);

	//
	// PDU stuff
	//
	void CreateDrawingCreatePDU(DrawingCreatePDU *);
	void CreateDrawingEditPDU(DrawingEditPDU *);
	void CreateDrawingDeletePDU(DrawingDeletePDU*);
	void SetDrawingAttrib(PDrawingCreatePDU_attributes *attributes);
	void AllocateAttrib(PDrawingCreatePDU_attributes *pattributes);


	//
	// Get/Set drawing type
	//
	void SetDrawingType(UINT type){m_drawingType = type;};
	UINT GetDrawingType(void) {return m_drawingType;}

    //
    // Get/set the pen style
    //
    void SetLineStyle(UINT lineStyle){m_lineStyle = lineStyle;	ChangedLineStyle();};
    UINT  GetLineStyle(void) { return m_lineStyle;}


	//
	// Get/set pen Color
	//
    void SetPenColor(COLORREF rgb, BOOL isPresent);
    BOOL GetPenColor(COLORREF * rgb);
	BOOL GetPenColor(RGBTRIPLE* rgb);

	//
	// Get/set fill Color
	//
	BOOL HasFillColor(void){return m_bIsFillColorPresent;}
    void SetFillColor(COLORREF rgb, BOOL isPresent);
    BOOL GetFillColor(COLORREF * rgb);
	BOOL GetFillColor(RGBTRIPLE* rgb);

	//
	//
	// Get/set pen nib
	//
    void SetPenNib(UINT nib){m_penNib = nib;ChangedPenNib();};
    UINT GetPenNib(void){return m_penNib;}

	//
	// Get/set highlight
	//
    void SetHighlight(BOOL bHighlight){m_bHighlight = bHighlight; ChangedHighlight();};
    BOOL GetHighlight(void){return m_bHighlight;}


	BOOL AddPoint(POINT point);
	void AddPointToBounds(int x, int y);


	// JOSEF add functionality
	void SetEnd(POINT){};
	void UnDraw(void);
    void SetViewHandle(UINT viewHandle){};

	//
	// Get/set flag telling that this drawing is completed
	//
	void SetIsCompleted(BOOL isCompleted) {m_isDrawingCompleted = isCompleted;}
	BOOL GetIsCompleted(void){return m_isDrawingCompleted;}

	//
	// Get the UI tool from a drawing pdu
	//
	void SetUIToolType(void);

	//
	// Mask 0x000008FF (penColor_chosen = 1... DrawingAttribute_zOrder_chosen = 8)
	//
	void ChangedPenColor(void){m_dwChangedAttrib |=
					(1 << (penColor_chosen-1)) | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedFillColor(void){m_dwChangedAttrib |=
					(1 << (fillColor_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedPenThickness(void){m_dwChangedAttrib |=
					(1 << (penThickness_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedPenNib(void){m_dwChangedAttrib |=
					(1 << (penNib_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedLineStyle(void){m_dwChangedAttrib |=
					(1 << (lineStyle_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedHighlight(void){m_dwChangedAttrib |=
					(1 << (highlight_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedViewState(void){m_dwChangedAttrib |=
					(1 << (DrawingAttribute_viewState_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}
	void ChangedZOrder(void){m_dwChangedAttrib |=
					(1 << (DrawingAttribute_zOrder_chosen-1))  | (DrawingEditPDU_attributeEdits_present << 4);}

	BOOL HasPenColorChanged(void){return (m_dwChangedAttrib & (1 << (penColor_chosen - 1)));}
	BOOL HasFillColorChanged(void){return (m_dwChangedAttrib & (1 << (fillColor_chosen - 1)));}
	BOOL HasPenThicknessChanged(void){return (m_dwChangedAttrib & (1 << (penThickness_chosen - 1)));}
	BOOL HasPenNibChanged(void){return (m_dwChangedAttrib & (1 << (penNib_chosen - 1)));}
	BOOL HasLineStyleChanged(void){return (m_dwChangedAttrib & (1 << (lineStyle_chosen - 1)));}
	BOOL HasHighlightChanged(void){return (m_dwChangedAttrib & (1 << (highlight_chosen - 1)));}
	BOOL HasViewStateChanged(void){return (m_dwChangedAttrib & (1 << (DrawingAttribute_viewState_chosen - 1)));}
	BOOL HasZOrderChanged(void){return (m_dwChangedAttrib & (1 << (DrawingAttribute_zOrder_chosen - 1)));}


	//
	// Mask 0x000000700 bits (pointListEdits_present = 0x10... DrawingEditPDU_anchorPointEdit_present = 0x40)
	//
	void ChangedPointList(void) { m_dwChangedAttrib |= pointListEdits_present << 4;}
	void ChangedRotation(void) { m_dwChangedAttrib |= rotationEdit_present << 4;}
	void ChangedAnchorPoint(void) { m_dwChangedAttrib |= DrawingEditPDU_anchorPointEdit_present << 4;}

	BOOL HasPointListChanged(void) { return (m_dwChangedAttrib & pointListEdits_present << 4);}
	BOOL HasRotationChanged(void) { return (m_dwChangedAttrib & rotationEdit_present << 4);}
	BOOL HasAnchorPointChanged(void) { return (m_dwChangedAttrib & DrawingEditPDU_anchorPointEdit_present << 4);}
	DWORD GetPresentAttribs(void){return ((m_dwChangedAttrib & 0x0F00)>> 4);}
	void ResetAttrib(void){m_dwChangedAttrib = 0;}
	void SetAllAttribs(void){m_dwChangedAttrib = 0x08FF;}


	void	OnObjectEdit(void);
	void	OnObjectDelete(void);
	void	SendNewObjectToT126Apps(void);
	void	GetEncodedCreatePDU(ASN1_BUF *pBuf);

		
protected:

		//
		// T126 Drawing and UI specific
		//
		DWORD		m_dwChangedAttrib;
		UINT		m_drawingType;
		UINT 		m_lineStyle;
		BOOL		m_bIsPenColorPresent;
		BOOL		m_bIsFillColorPresent;
		RGBTRIPLE	m_penColor;
		RGBTRIPLE	m_fillColor;
		UINT		m_penNib;
		BOOL		m_bHighlight;
		BOOL		m_isDrawingCompleted;



UINT  GetSubsequentPoints(UINT choice, POINT * initialPoint, PointList * pointList);
void  GetDrawingAttrib(PVOID pAttribPDU);


};

#endif // __DRAWOBJ_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG



// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
};


__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\ms_util.cpp ===
#include "precomp.h"


CRefCount::CRefCount(DWORD dwStampID)
:
#ifndef SHIP_BUILD
    m_dwStampID(dwStampID),
#endif
    m_cRefs(1)
{
}


// though it is pure virtual, we still need to have a destructor.
CRefCount::~CRefCount(void)
{
}


LONG CRefCount::AddRef(void)
{
    ASSERT(0 < m_cRefs);
    ::InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}


LONG CRefCount::Release(void)
{
    ASSERT(NULL != this);
    ASSERT(0 < m_cRefs);
    if (0 == ::InterlockedDecrement(&m_cRefs))
    {
        delete this;
        return 0;
    }
    return m_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\globals.h ===
//
// Global variables
//

extern WbMainWindow *   g_pMain;
extern HINSTANCE    g_hInstance;
extern UINT         g_uConfShutdown;
extern HPALETTE     g_hRainbowPaletteDisplay;
extern WbPrinter *  g_pPrinter;
extern HINSTANCE        g_hImmLib;
extern IGC_PROC         g_fnImmGetContext;
extern INI_PROC         g_fnImmNotifyIME;


//extern "C" int _fltused;
extern int __cdecl atexit (void);


enum
{
    CLIPBOARD_PRIVATE = 0,
    CLIPBOARD_DIB,
    CLIPBOARD_ENHMETAFILE,
    CLIPBOARD_TEXT,
    CLIPBOARD_ACCEPTABLE_FORMATS
};



//
// GCC handle allocation
//
#define PREALLOC_GCC_HANDLES 256
#define PREALLOC_GCC_BUFFERS 2

typedef struct tagGCCPrealloc
{
	ULONG InitialGCCHandle;
	ULONG GccHandleCount;
} GCCPREALOC;

extern GCCPREALOC g_GCCPreallocHandles[];
extern UINT g_iGCCHandleIndex;
extern BOOL g_WaitingForGCCHandles;



#define MAX_BITS_PERPIXEL 8 // Specifies the number of bits per pixel ASN1 allows

extern int         g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS];

extern BOOL         g_bPalettesInitialized;
extern BOOL         g_bUsePalettes;
extern UINT         g_PenWidths[NUM_OF_WIDTHS];
extern UINT         g_HighlightWidths[NUM_OF_WIDTHS];


#define NUM_COLOR_ENTRIES   21
extern COLORREF     g_ColorTable[NUM_COLOR_ENTRIES];


//
// Complex object globals
//
extern WbDrawingArea*		g_pDraw;
extern DCWbColorToIconMap*	g_pIcons;

extern UINT			g_numberOfWorkspaces;
extern UINT			g_numberOfObjects;
extern CWBOBLIST*	g_pListOfWorkspaces;
extern CWBOBLIST*	g_pListOfObjectsThatRequestedHandles;
extern CWBOBLIST*	g_pRetrySendList;
extern BOOL			g_fWaitingForBufferAvailable;
extern CWBOBLIST*	g_pTrash;
extern UINT			g_localGCCHandle;
extern WorkspaceObj*g_pCurrentWorkspace;
extern WorkspaceObj*g_pConferenceWorkspace;
extern ULONG		g_MyMemberID;
extern ULONG		g_RefresherID;
extern UINT			g_MyIndex;
extern COLORREF 	g_crDefaultColors[];
extern BOOL			g_bSavingFile;
extern BOOL			g_bContentsChanged;
extern Coder *		g_pCoder;
extern DWORD g_dwWorkThreadID;




#define WB_MAX_WORKSPACES 256

class CNMWbObj;

extern CNMWbObj * g_pNMWBOBJ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\mcshelp.cpp ===
#include "precomp.h"
#include "gcchelp.h"
#include "coder.hpp"
#include "drawobj.hpp"
#include "NMWbObj.h"

extern Coder * g_pCoder;

UINT AllocateFakeGCCHandle(void)
{
	return g_localGCCHandle++;
}

void SetFakeGCCHandle(UINT fakeGCCHandle)
{
	g_localGCCHandle = fakeGCCHandle;
}

//
// Add drawings/bitmaps etc... to workspace
//
BOOL AddT126ObjectToWorkspace(T126Obj *pObj)
{
	WorkspaceObj * pWorkspace =	GetWorkspace(pObj->GetWorkspaceHandle());
	if(pWorkspace)
	{	
		pWorkspace->AddTail(pObj);
		g_numberOfObjects++;
		return TRUE;
	}
	else
	{
		WARNING_OUT(("Object sent to invalid workspace %d, will be deleted now!!!", GetWorkspace(pObj->GetWorkspaceHandle())));
		delete pObj;
		return FALSE;
	}
}

//
// Cleanup for all pdus we send
//
void SIPDUCleanUp(SIPDU *sipdu)
{
	switch(sipdu->choice)
	{
		//
		// Simple cleanup
		//
		case bitmapDeletePDU_chosen:
		case drawingDeletePDU_chosen:
		case workspaceDeletePDU_chosen:
		case workspaceRefreshStatusPDU_chosen:
		break;

		//
		// Bitmap Create cleanup
		//
		case bitmapCreatePDU_chosen:
		{
			if(sipdu->u.bitmapCreatePDU.nonStandardParameters)
			{
				delete sipdu->u.bitmapCreatePDU.nonStandardParameters;
			}

			PBitmapCreatePDU_attributes pAttrib;
			PBitmapCreatePDU_attributes pNextAttrib;
			pAttrib = sipdu->u.bitmapCreatePDU.attributes;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}
		}
		break;


		case bitmapEditPDU_chosen:
		{
			BitmapEditPDU_attributeEdits * pAttrib;
			BitmapEditPDU_attributeEdits * pNextAttrib;
			pAttrib = sipdu->u.bitmapEditPDU.attributeEdits;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}
		}
		break;


		//
		// Bitmap Continue cleanup
		//
		case bitmapCreateContinuePDU_chosen:
		{
			if(sipdu->u.bitmapCreateContinuePDU.nonStandardParameters)
			{
				delete sipdu->u.bitmapCreateContinuePDU.nonStandardParameters;
			}
		}
		break;

		//
		// Drawing Edit Cleanup
		//
		case drawingEditPDU_chosen:
		{
			if(sipdu->u.drawingEditPDU.bit_mask & DrawingEditPDU_attributeEdits_present)
			{
				PDrawingEditPDU_attributeEdits pAttrib;
				PDrawingEditPDU_attributeEdits pNextAttrib;
				pAttrib = sipdu->u.drawingEditPDU.attributeEdits;
				while(pAttrib)
				{
					pNextAttrib = pAttrib->next;
					delete pAttrib;
					pAttrib = pNextAttrib;
				}
			}

			if(sipdu->u.drawingEditPDU.pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16)
			{
				PPointList_pointsDiff16 drawingPoint = sipdu->u.drawingEditPDU.pointListEdits.value[0].subsequentPointEdits.u.pointsDiff16;
				PPointList_pointsDiff16 drawingPointNext = drawingPoint; 
				while(drawingPointNext)
				{
					drawingPointNext = drawingPoint->next;
					delete drawingPoint;
					drawingPoint = drawingPointNext;
				}
			}
		}
		break;


		//
		// Drawing Edit cleanup
		//
		case drawingCreatePDU_chosen:
		{
			PDrawingCreatePDU_attributes pNextAttrib;
			PDrawingCreatePDU_attributes pAttrib;

			pAttrib = sipdu->u.drawingCreatePDU.attributes;
			while(pAttrib)
			{
				pNextAttrib = pAttrib->next;
				delete pAttrib;
				pAttrib = pNextAttrib;
			}

			PPointList_pointsDiff16 pNextPoint;
			PPointList_pointsDiff16 pPoint;
			pPoint = sipdu->u.drawingCreatePDU.pointList.u.pointsDiff16;

			while(pPoint)
			{
				pNextPoint = pPoint->next;
				delete pPoint;
				pPoint = pNextPoint;
			}
		}
		break;


		//
		// Non Standard cleanup
		//
		case siNonStandardPDU_chosen:
		if(sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value)
		{
			delete sipdu->u.siNonStandardPDU.nonStandardTransaction.data.value;
		}
		break;


		//
		// Workspace Edit cleanup
		//
		case workspaceEditPDU_chosen:
		{
			if(sipdu->u.workspaceEditPDU.bit_mask & viewEdits_present)
			{
				PWorkspaceEditPDU_viewEdits_Set_action_editView pEditView = sipdu->u.workspaceEditPDU.viewEdits->value.action.u.editView;
				PWorkspaceEditPDU_viewEdits_Set_action_editView pNextEditView = pEditView;
				while(pNextEditView)
				{
					pNextEditView = pEditView->next;
					delete pEditView;
					pEditView = pNextEditView;
				}
				delete sipdu->u.workspaceEditPDU.viewEdits;
			}
		}
		break;
		

		//
		// Workspace Create cleanup
		//
		case workspaceCreatePDU_chosen:
		{

			if(sipdu->u.workspaceCreatePDU.viewParameters)
			{
				if(sipdu->u.workspaceCreatePDU.viewParameters->value.viewAttributes)
				{
					delete sipdu->u.workspaceCreatePDU.viewParameters->value.viewAttributes;
				}
				delete sipdu->u.workspaceCreatePDU.viewParameters;
			}

			if(sipdu->u.workspaceCreatePDU.planeParameters)
			{
				PWorkspaceCreatePDU_planeParameters_Seq_usage pNextUsage;
				PWorkspaceCreatePDU_planeParameters_Seq_usage pUsage = sipdu->u.workspaceCreatePDU.planeParameters->value.usage;
				while(pUsage)
				{
					pNextUsage = pUsage->next;
					delete pUsage;
					pUsage = pNextUsage;
				}

				delete sipdu->u.workspaceCreatePDU.planeParameters->value.planeAttributes;
				PWorkspaceCreatePDU_planeParameters pNextPlaneParameters;
				PWorkspaceCreatePDU_planeParameters pPlaneParameters = sipdu->u.workspaceCreatePDU.planeParameters;
				while(pPlaneParameters)
				{
					pNextPlaneParameters = pPlaneParameters->next;
					delete pPlaneParameters;
					pPlaneParameters = pNextPlaneParameters;
				}
			}
		}
		break;

		default:
        ERROR_OUT(("UNKNOWN PDU TYPE =  %d we may leak memory", sipdu->choice));
		break;

	}
	
	delete sipdu;
}


//
// Cleans the retry list, when we close down or disconnect
//
void DeleteAllRetryPDUS(void)
{
	SIPDU * sipdu;
	while((sipdu = (SIPDU *)g_pRetrySendList->RemoveTail()) != NULL)
	{
		SIPDUCleanUp(sipdu);
	}
}

//
// Retry sending buffered pdus and send the new pdu
//
T120Error SendT126PDU(SIPDU * pPDU)
{

    MLZ_EntryOut(ZONE_FUNCTION, "SendT126PDU");


	//
	// First send buffered pdus
	//
	RetrySend();

	//
	// Now send the current pdu
	//
	T120Error rc = SendPDU(pPDU, FALSE);


	return rc;
}


//
// Retry sending pdus that couldn't be sent before
//
void RetrySend(void)
{

    MLZ_EntryOut(ZONE_FUNCTION, "RetrySend");

	if(g_fWaitingForBufferAvailable)
	{
		return;
	}

	TRACE_MSG(("RetrySend"));

	SIPDU * sipdu;
	while((sipdu = (SIPDU *)g_pRetrySendList->RemoveTail()) != NULL)
	{
		TRACE_DEBUG(("RetrySend sipdu->choice = %d", sipdu->choice));
		T120Error rc = SendPDU(sipdu, TRUE);
		if(rc == T120_NO_ERROR)
		{
			TRACE_DEBUG(("RetrySend OK!!!"));
			SIPDUCleanUp(sipdu);
		}
		else
		{
			TRACE_DEBUG(("RetrySend Failed"));
			break;
		}
	}
}

//
// Send T126 pdus down to the conference
//
T120Error SendPDU(SIPDU * pPDU, BOOL bRetry)
{

    MLZ_EntryOut(ZONE_FUNCTION, "SendPDU");

	T120Error rc = T120_NO_ERROR;
	
	//
	// If we are in a conference
	//
	if(g_pNMWBOBJ->IsInConference() || g_bSavingFile)
	{
		ASN1_BUF encodedPDU;

		g_pCoder->Encode(pPDU, &encodedPDU);
		if(g_bSavingFile)
		{
			g_pMain->ObjectSave(TYPE_T126_ASN_OBJECT, encodedPDU.value, encodedPDU.length);
		}
		else
		{
			if(!g_fWaitingForBufferAvailable)
			{

				T120Priority	ePriority = APPLET_LOW_PRIORITY;
				
				if(pPDU->choice == workspaceCreatePDU_chosen ||
					pPDU->choice == workspaceEditPDU_chosen ||
					pPDU->choice == workspaceDeletePDU_chosen)
				{


					//
					// Do what the standard says send the pdus in 3 different priorities
					//
					TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_HIGH_PRIORITY", encodedPDU.length));

					rc = g_pNMWBOBJ->SendData(APPLET_HIGH_PRIORITY,
												    encodedPDU.length,
													encodedPDU.value);


					TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_MEDIUM_PRIORITY", encodedPDU.length));
					if(rc == T120_NO_ERROR)
					{
						rc = g_pNMWBOBJ->SendData(APPLET_MEDIUM_PRIORITY,
													encodedPDU.length,
													encodedPDU.value);
					}
				}
											    

				TRACE_MSG(("SendPDU sending PDU length = %d in APPLET_LOW_PRIORITY", encodedPDU.length));
				if(rc == T120_NO_ERROR)
				{
					rc = g_pNMWBOBJ->SendData(ePriority,
											    encodedPDU.length,
											    encodedPDU.value);
				}

				if(rc == MCS_TRANSMIT_BUFFER_FULL)
				{
					g_fWaitingForBufferAvailable = TRUE;

					//
					// We need to add it back to the correct position
					//
					if(bRetry)
					{
						g_pRetrySendList->AddTail(pPDU);
					}
					else
					{
						g_pRetrySendList->AddHead(pPDU);
					}
				}
											    
			}
			else
			{
				rc = MCS_TRANSMIT_BUFFER_FULL;
				g_pRetrySendList->AddHead(pPDU);
			}
		}

		// Free the encoder memory
		g_pCoder->Free(encodedPDU);
	}

	return rc;
}


BOOL T126_MCSSendDataIndication(ULONG uSize, LPBYTE pb, ULONG memberID, BOOL bResend)
{
	BOOL bRet = TRUE;
	SIPDU * pDecodedPDU;
	ASN1_BUF InputBuffer;

	InputBuffer.length =  uSize;
	InputBuffer.value = pb;
		
	//
	// Decode incoming PDU
	if(ASN1_SUCCEEDED(g_pCoder->Decode(&InputBuffer, &pDecodedPDU)))
	{
		switch(pDecodedPDU->choice)
		{
//			case (archiveAcknowledgePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveAcknowledgePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveClosePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveClosePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveErrorPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveErrorPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (archiveOpenPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a archiveOpenPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			case (bitmapAbortPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapAbortPDU"));
				OnBitmapAbortPDU(&pDecodedPDU->u.bitmapAbortPDU, memberID);
				break;
			}

			case (bitmapCheckpointPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCheckpointPDU"));
				OnBitmapCheckpointPDU(&pDecodedPDU->u.bitmapCheckpointPDU, memberID);
				break;
			}

			case (bitmapCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCreatePDU"));
				OnBitmapCreatePDU(&pDecodedPDU->u.bitmapCreatePDU, memberID, bResend);
				break;
			}

			case (bitmapCreateContinuePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapCreateContinuePDU"));
				OnBitmapCreateContinuePDU(&pDecodedPDU->u.bitmapCreateContinuePDU, memberID, bResend);
				break;
			}

			case (bitmapDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapDeletePDU"));
				OnBitmapDeletePDU(&pDecodedPDU->u.bitmapDeletePDU, memberID);
				break;
			}

			case (bitmapEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a bitmapEditPDU"));
				OnBitmapEditPDU(&pDecodedPDU->u.bitmapEditPDU, memberID);
				break;
			}

			case (conductorPrivilegeGrantPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a conductorPrivilegeGrantPDU"));
				TRACE_DEBUG(("No action taken"));
				break;
			}

			case (conductorPrivilegeRequestPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a conductorPrivilegeRequestPDU"));
				TRACE_DEBUG(("No action taken"));
				break;
			}

			case (drawingCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingCreatePDU"));
				OnDrawingCreatePDU(&pDecodedPDU->u.drawingCreatePDU, memberID, bResend);
				break;
			}

			case (drawingDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingDeletePDU"));
				OnDrawingDeletePDU(&pDecodedPDU->u.drawingDeletePDU, memberID);
				break;
			}

			case (drawingEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a drawingEditPDU"));
				OnDrawingEditPDU(&pDecodedPDU->u.drawingEditPDU, memberID, bResend);
				break;
			}

//			case (remoteEventPermissionGrantPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteEventPermissionGrantPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remoteEventPermissionRequestPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteEventPermissionRequestPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remoteKeyboardEventPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remoteKeyboardEventPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remotePointingDeviceEventPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remotePointingDeviceEventPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (remotePrintPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a remotePrintPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			case (siNonStandardPDU_chosen):
			{

				if(pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.nonStandardIdentifier.choice == h221nonStandard_chosen)
				{

					PT126_VENDORINFO pVendorInfo = (PT126_VENDORINFO)pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.nonStandardIdentifier.u.h221nonStandard.value;

					if (!lstrcmp((LPSTR)&pVendorInfo->nonstandardString, NonStandardTextID))
					{
						TEXTPDU_HEADER *pHeader = (TEXTPDU_HEADER*) pDecodedPDU->u.siNonStandardPDU.nonStandardTransaction.data.value;
						switch(pHeader->nonStandardPDU)
						{
							case textCreatePDU_chosen:
							TRACE_DEBUG((">>> Received a textCreatePDU_chosen"));
							OnTextCreatePDU((MSTextPDU*)pHeader, memberID, bResend);
							break;

							case textEditPDU_chosen:
							TRACE_DEBUG((">>> Received a textEditPDU_chosen"));
							OnTextEditPDU((MSTextPDU*)pHeader, memberID);
							break;

							case textDeletePDU_chosen:
							TRACE_DEBUG((">>> Received a textDeletePDU_chosen"));
							OnTextDeletePDU(pHeader, memberID);
							break;

							default:
							TRACE_DEBUG(("Invalid text pdu"));
							break;
						}
						
					}


				}

				break;
			}

			case (workspaceCreatePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceCreatePDU"));
				OnWorkspaceCreatePDU(&pDecodedPDU->u.workspaceCreatePDU, memberID, bResend);
				break;
			}

			case (workspaceCreateAcknowledgePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceCreateAcknowledgePDU"));
				OnWorkspaceCreateAcknowledgePDU(&pDecodedPDU->u.workspaceCreateAcknowledgePDU, memberID);
				break;
			}

			case (workspaceDeletePDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceDeletePDU"));
				OnWorkspaceDeletePDU(&pDecodedPDU->u.workspaceDeletePDU, memberID);
				break;
			}

			case (workspaceEditPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceEditPDU"));
				OnWorkspaceEditPDU(&pDecodedPDU->u.workspaceEditPDU, memberID);
				break;
			}

			case (workspacePlaneCopyPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspacePlaneCopyPDU"));
				OnWorkspacePlaneCopyPDU(&pDecodedPDU->u.workspacePlaneCopyPDU, memberID);
				break;
			}

			case (workspaceReadyPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceReadyPDU"));
				OnWorkspaceReadyPDU(&pDecodedPDU->u.workspaceReadyPDU, memberID);
				break;
			}

			case (workspaceRefreshStatusPDU_chosen):
			{
				TRACE_DEBUG((">>> Received a workspaceRefreshStatusPDU"));
				OnWorkspaceRefreshStatusPDU(&pDecodedPDU->u.workspaceRefreshStatusPDU, memberID);
				break;
			}

//			case (fontPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a fontPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textCreatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textCreatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textDeletePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textDeletePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (textEditPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a textEditPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowCreatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowCreatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowDeleatePDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowDeleatePDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

//			case (videoWindowEditPDU_chosen):
//			{
//				TRACE_DEBUG((">>> Received a videoWindowEditPDU"));
//				TRACE_DEBUG(("No action taken"));
//				break;
//			}

			default:
			bRet = FALSE;
			TRACE_DEBUG(("Receive an Unhandled PDU choice = %d", pDecodedPDU->choice));
			break;
		}
	}

	//
	// Free the decoded pdu
	// JOSEF: for performance in the future we could pass
	// the decoded buffer to the ui, avoiding more memory allocation.
	// But it will be hard to read the code, since the T126 structures
	// are a bit confusing.
	//
	
	g_pCoder->Free(pDecodedPDU);

	return bRet;
}


//
// Delete All Workspaces sent and received
//
void DeleteAllWorkspaces(BOOL sendPDU)
{
	T126Obj * pObj;

	if(g_pDraw && g_pDraw->m_pTextEditor)
	{
		g_pDraw->m_pTextEditor->AbortEditGently();
	}

	g_pCurrentWorkspace = NULL;
	g_pConferenceWorkspace = NULL;

	while ((pObj = (T126Obj *)g_pListOfWorkspaces->RemoveTail()) != NULL)
	{
		if(sendPDU)
		{
			pObj->DeletedLocally();
		}
		else
		{
			pObj->ClearDeletionFlags();
		}
		
		delete pObj;
	}
	
	if(g_pMain)
	{
		g_pMain->EnableToolbar(FALSE);
		g_pMain->UpdatePageButtons();
	}

}

/////////////////////////////////////////////////////////////////////////////////////////////
// TEXT PDUS
/////////////////////////////////////////////////////////////////////////////////////////////
void	OnTextCreatePDU(MSTextPDU* pCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	WorkspaceObj* pWObj;
	WbTextEditor * pText;

	//
	// Check for resend
	//

	if(!bForcedResend)
	{

		pWObj = GetWorkspace(pCreatePDU->header.workspaceHandle);
		if(pWObj)
		{
			pText = (WbTextEditor *)pWObj->FindObjectInWorkspace(pCreatePDU->header.textHandle);
			if(pText)
			{
				TRACE_DEBUG(("drawingHandle already used = %d", pCreatePDU->header.textHandle ));
				return;
			}
		}	
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pText = new WbTextEditor();
    if(NULL == pText)
    {
        ERROR_OUT(("Failed to allocate new WbTextEditor"));
        return;
    }
	pText->SetWorkspaceHandle(pCreatePDU->header.workspaceHandle);
	pText->SetThisObjectHandle(pCreatePDU->header.textHandle);
	
	if(!bForcedResend)
	{
		//
		// Some one sent us this drawing, it is not created locally
		//
		pText->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pText))
		{
			return;
		}
	}
	else
	{
	
		//
		// Add this object and send Create PDU
		//
		pText->SetAllAttribs();
		pText->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
		pText->ClearSelectionFlags();
		pText->GetTextAttrib(&pCreatePDU->attrib);
		pText->AddToWorkspace();
		pText->Draw();
		return;		
	}

	pText->TextEditObj(&pCreatePDU->attrib);
	pText->Draw();
	pText->ResetAttrib();	
}

void	OnTextDeletePDU(TEXTPDU_HEADER *pHeader, ULONG memberID)
{

	T126Obj*  pText;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pHeader->textHandle, (T126Obj**)&pText, (WorkspaceObj**)&pWorkspace))
	{
		pText->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object(pText);
	}

}

void	OnTextEditPDU(MSTextPDU *pEditPDU, ULONG memberID)
{
	TextObj*  pText;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pEditPDU->header.textHandle, (T126Obj **)&pText, (WorkspaceObj**)&pWorkspace))
	{
		pText->SetOwnerID(memberID);
		pText->TextEditObj(&pEditPDU->attrib);
	}
}



/////////////////////////////////////////////////////////////////////////////////////////////
// DRAWING PDUS
/////////////////////////////////////////////////////////////////////////////////////////////
void	OnDrawingCreatePDU(DrawingCreatePDU * pdrawingCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	WorkspaceObj* pWObj;
	DrawObj * pDraw;
	UINT workspace;
	UINT planeID;

	//
	// If we don't have a drawing handle dont take it
	//
	if(!(pdrawingCreatePDU->bit_mask & drawingHandle_present))
	{
		TRACE_DEBUG(("Got a DrawingCreatePDU but no drawingHandle" ));
		return;
	}

	GetDrawingDestinationAddress(&pdrawingCreatePDU->destinationAddress, &workspace, &planeID);

	//
	// Check for resend
	//

	if(!bForcedResend)
	{

		pWObj = GetWorkspace(workspace);
		if(pWObj)
		{
			pDraw = (DrawObj *)pWObj->FindObjectInWorkspace(pdrawingCreatePDU->drawingHandle);
			if(pDraw)
			{
				TRACE_DEBUG(("drawingHandle already used = %d", pdrawingCreatePDU->drawingHandle ));
				return;
			}
		}	
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pDraw = new DrawObj(pdrawingCreatePDU);
    if(NULL == pDraw)
    {
        ERROR_OUT(("Failed to alocate DrawObj"));
        return;
    }
	pDraw->SetOwnerID(memberID);

	if(!bForcedResend)
	{
		//
		// Some one sent us this drawing, it is not created locally
		//
		pDraw->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pDraw))
		{
			return;
		}
	}
	else
	{
	
		//
		// Add this object and send Create PDU
		//
		pDraw->SetAllAttribs();
		pDraw->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle()); 
		pDraw->ClearSelectionFlags();
		pDraw->AddToWorkspace();
		pDraw->Draw();
		return;
	}

	//
	// Draw it
	//
	if(pDraw->GetPenThickness())
	{
		pDraw->Draw();
		pDraw->ResetAttrib();	
	}

}

void	OnDrawingDeletePDU(DrawingDeletePDU * pdrawingDeletePDU, ULONG memberID)
{

	DrawObj*  pDraw;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pdrawingDeletePDU->drawingHandle, (T126Obj **)&pDraw, (WorkspaceObj**)&pWorkspace))
	{
		pDraw->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object((T126Obj*)pDraw);
	}

}

void	OnDrawingEditPDU(DrawingEditPDU * pdrawingEditPDU, ULONG memberID, BOOL bResend)
{
	DrawObj*  pDraw;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
	if(FindObjectAndWorkspace(pdrawingEditPDU->drawingHandle, (T126Obj **)&pDraw, (WorkspaceObj**)&pWorkspace))
	{
		pDraw->SetOwnerID(memberID);
		pDraw->DrawEditObj(pdrawingEditPDU);
	}
	else
	{
		//
		// We are reading this pdu from disk add the rest of the line to the previous freehand drawing
		//
		if(bResend)
		{
			T126Obj * pObj;
			pObj = g_pCurrentWorkspace->GetTail();
			if(pObj && pObj->GetType() == drawingCreatePDU_chosen &&
			(pObj->GraphicTool() == TOOLTYPE_PEN ||  pObj->GraphicTool() == TOOLTYPE_HIGHLIGHT))
			{
				pdrawingEditPDU->drawingHandle = pObj->GetThisObjectHandle();
				pObj->SetOwnerID(memberID);
				((DrawObj*)pObj)->DrawEditObj(pdrawingEditPDU);
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////////////////////
// WORKSPACE PDUS
/////////////////////////////////////////////////////////////////////////////////////////////


BOOL FindObjectAndWorkspace(UINT objectHandle, T126Obj**  pObj, WorkspaceObj**pWorkspace)
{
	WorkspaceObj * pWrkspc;
	T126Obj * pT126Obj;

	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos != NULL)
    {
		pWrkspc = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);
		if(pWrkspc)
		{
			pT126Obj = pWrkspc->FindObjectInWorkspace(objectHandle);
			if(pT126Obj)
			{
				*pObj = pT126Obj;
				*pWorkspace = pWrkspc;
				return TRUE;
			}
		}
	}

	return FALSE;
}




//
// Retrieves workspace from the list of workspaces
//
WorkspaceObj * GetWorkspace(UINT activeWorkspace)
{
	WorkspaceObj * pWorkspaceObj;
	WBPOSITION pos;
	pos = g_pListOfWorkspaces->GetHeadPosition();
    while (pos != NULL)
    {
		pWorkspaceObj = (WorkspaceObj *) g_pListOfWorkspaces->GetNext(pos);

		if(pWorkspaceObj->GetWorkspaceHandle() == activeWorkspace)
		{
			return pWorkspaceObj;
		}
	}


	return NULL;
}

//
// The remote sent us a new workspace
//
void OnWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU, ULONG memberID, BOOL bForcedResend)
{
	TRACE_DEBUG(("OnWorkspaceCreatePDU WorkspaceIdentifier = %d", pWorkspaceCreatePDU->workspaceIdentifier.u.activeWorkspace));

	WorkspaceObj * pWorkspaceObj;


	//
	// Check for resend
	//
	if(!bForcedResend)
	{
		pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceCreatePDU->workspaceIdentifier));
		if(pWorkspaceObj)
		{
			return;
		}

		DBG_SAVE_FILE_LINE
		pWorkspaceObj = new WorkspaceObj(pWorkspaceCreatePDU, bForcedResend);
        if(NULL == pWorkspaceObj)
        {
            ERROR_OUT(("Failed to allocated new WorkspaceObj"));
            return;
        }
        
		pWorkspaceObj->SetOwnerID(memberID);
	}
	else
	{
		DBG_SAVE_FILE_LINE
		pWorkspaceObj = new WorkspaceObj(pWorkspaceCreatePDU, bForcedResend);
        if(NULL == pWorkspaceObj)
        {
            ERROR_OUT(("Failed to allocated new WorkspaceObj"));
            return;
        }
        
		pWorkspaceObj->SetOwnerID(memberID);
	}
}

//
// If we created an unsynchronized workspace the remote has to sen us
// a WorkspaceCreateAcknowledgePDU. Why???
//
void OnWorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU * pWorkspaceCreateAcknowledgePDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceCreateAcknowledgePDU WorkspaceIdentifier = %d", pWorkspaceCreateAcknowledgePDU->workspaceIdentifier));
}

//
// The remote is deleting the workspace
//
void OnWorkspaceDeletePDU(WorkspaceDeletePDU * pWorkspaceDeletePDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceDeletePDU WorkspaceIdentifier = %d", pWorkspaceDeletePDU->workspaceIdentifier.u.activeWorkspace));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceDeletePDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}

	pWorkspaceObj->SetOwnerID(memberID);
	pWorkspaceObj->ClearDeletionFlags();

	//
	// Reason for deleting
	//
	TRACE_DEBUG(("OnWorkspaceDeletePDU reason = %d", pWorkspaceDeletePDU->reason.choice));

	//
	// Remove it from the List Of Workspaces
	//
	WBPOSITION prevPos;
	WBPOSITION pos;

	pos = g_pListOfWorkspaces->GetPosition(pWorkspaceObj);
	prevPos = g_pListOfWorkspaces->GetHeadPosition(); 

	//
	// This is the only workspace we have ?????
	//
	if(g_pListOfWorkspaces->GetHeadPosition() == g_pListOfWorkspaces->GetTailPosition())
	{
		RemoveWorkspace(pWorkspaceObj);

		g_pCurrentWorkspace = NULL;

		if(g_pMain)
		{
			g_pMain->EnableToolbar(FALSE);
		}
	}
	else
	{

		//
		// If we had a remote pointer
		//
		BOOL	 bRemote = FALSE;
		if(g_pMain->m_pLocalRemotePointer)
		{
			bRemote = TRUE;
			g_pMain->OnRemotePointer();
		}

		//
		// Remove the workspace and point the current one to the correct one.
		//
		pWorkspaceObj = RemoveWorkspace(pWorkspaceObj);

		g_pConferenceWorkspace = pWorkspaceObj;

		if(g_pDraw->IsSynced())
		{
			g_pMain->GoPage(pWorkspaceObj,FALSE);
		}

		//
		// If we had a remote pointer
		//
		if(bRemote)
		{
			g_pMain->OnRemotePointer();
		}
	}
}

//
// The remote is changing the workspace
//
void OnWorkspaceEditPDU(WorkspaceEditPDU * pWorkspaceEditPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceEditPDU WorkspaceIdentifier = %d",pWorkspaceEditPDU->workspaceIdentifier.u.activeWorkspace));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceEditPDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}
	pWorkspaceObj->SetOwnerID(memberID);
	pWorkspaceObj->WorkspaceEditObj(pWorkspaceEditPDU);
}

void OnWorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU * pWorkspacePlaneCopyPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspacePlaneCopyPDU WorkspaceIdentifier = %d",pWorkspacePlaneCopyPDU->sourceWorkspaceIdentifier));
}

void OnWorkspaceReadyPDU(WorkspaceReadyPDU * pWorkspaceReadyPDU, ULONG memberID)
{
	TRACE_DEBUG(("OnWorkspaceReadyPDU WorkspaceIdentifier = %d",pWorkspaceReadyPDU->workspaceIdentifier));

	//
	// Find the workspace
	//
	WorkspaceObj * pWorkspaceObj;
	pWorkspaceObj = GetWorkspace(WorkspaceObj::GetWorkspaceIdentifier(&pWorkspaceReadyPDU->workspaceIdentifier));
	if(!pWorkspaceObj)
	{
		return;
	}
	pWorkspaceObj->SetOwnerID(memberID);

	//
	// This workspace is ready
	//
	pWorkspaceObj->m_bWorkspaceReady = TRUE;
}

//
// If we got a refreshStatus == TRUE, we have to refresh late joiners
//
void OnWorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU * pWorkspaceRefreshStatusPDU, ULONG memberID)
{
	if (pWorkspaceRefreshStatusPDU->refreshStatus == TRUE)
	{
		g_RefresherID = memberID;
	}
	else
	{
		//
		// The token is out there, try to grab it
		//
		g_pNMWBOBJ->GrabRefresherToken();
	}
}





/////////////////////////////////////////////////////////////////////////////////////////////
// BITMAP PDUS
/////////////////////////////////////////////////////////////////////////////////////////////

void	OnBitmapCreatePDU(BitmapCreatePDU * pBitmapCreatePDU, ULONG memberID, BOOL bForcedResend)
{

	TRACE_DEBUG(("drawingHandle = %d", pBitmapCreatePDU->bitmapHandle ));
	
	//
	// If we find this object, it is because T120 is broadcasting the drawing
	// we just sent to T126
	//
	UINT workspace;
	UINT planeID;
	
	GetBitmapDestinationAddress(&pBitmapCreatePDU->destinationAddress, &workspace, &planeID);

	//
	// Check for resend
	//
	WorkspaceObj* pWObj;
	BitmapObj * pBitmap;
	if(!bForcedResend)
	{
		pWObj = GetWorkspace(workspace);
		if(pWObj)
		{
			pBitmap = (BitmapObj*)pWObj->FindObjectInWorkspace(pBitmapCreatePDU->bitmapHandle);
			if(pBitmap)
			return;
		}
	}

	//
	// New Drawing object
	//
	DBG_SAVE_FILE_LINE
	pBitmap = new BitmapObj(pBitmapCreatePDU);
    if(NULL == pBitmap)
    {
        ERROR_OUT(("Failed to allocated new BitmapObj"));
        return;
    }
    
	pBitmap->SetOwnerID(memberID);


	if(!bForcedResend)
	{
		//
		// Someone else sent us this bitmap, it was not created locally
		//
		pBitmap->ClearCreationFlags();

		//
		// Add a this drawing to the correct workspace
		//
		if(!AddT126ObjectToWorkspace(pBitmap))
		{
			return;
		}

	}
	else
	{
		//
		// If we are reading from disk, this has to be added in the current workspace
		// and we have to wait until we have the whole bitmap to send it
		//
		if(pBitmap->m_fMoreToFollow)
		{
			pBitmap->SetWorkspaceHandle(g_pCurrentWorkspace == NULL ? 0 : g_pCurrentWorkspace->GetWorkspaceHandle());
			AddT126ObjectToWorkspace(pBitmap);
		}
		else
		{
			//
			// Add this object and send Create PDU
			//
			pBitmap->SetAllAttribs();
			pBitmap->AddToWorkspace();
		}
	}


	//
	// PASS IT TO UI
	//
	if(!pBitmap->m_fMoreToFollow)
	{
		pBitmap->Draw();
	}

}
void	OnBitmapCreateContinuePDU(BitmapCreateContinuePDU * pBitmapCreateContinuePDU, ULONG memberID,  BOOL bForcedResend)
{

	WorkspaceObj* pWorkspace;
	BitmapObj*  pBitmap = NULL;
	
	// We should find this drawing object

	//
	// If we are loading from file it is in the current workspace
	//
	if(bForcedResend)
	{
		ASSERT(g_pCurrentWorkspace);
		if(g_pCurrentWorkspace)
		{
			pBitmap = (BitmapObj*)g_pCurrentWorkspace->FindObjectInWorkspace(pBitmapCreateContinuePDU->bitmapHandle);
		}
	}
	else
	{
		FindObjectAndWorkspace(pBitmapCreateContinuePDU->bitmapHandle, (T126Obj **)&pBitmap, (WorkspaceObj**)&pWorkspace);
	}


	if(pBitmap)
	{

		pBitmap->SetOwnerID(memberID);

		//
		// Found the previous bitmap, concatenate the data
		//
		pBitmap->Continue(pBitmapCreateContinuePDU);

		//
		// PASS IT TO UI
		//
		if(!pBitmap->m_fMoreToFollow)
		{
			pBitmap->Draw();

			if(bForcedResend)
			{
				pBitmap->SetAllAttribs();
				pBitmap->AddToWorkspace();
			}
		}
	}
}
void	OnBitmapCheckpointPDU(BitmapCheckpointPDU * pBitmapCheckPointPDU, ULONG memberID)
{
}

void	OnBitmapAbortPDU(BitmapAbortPDU * pBitmapAbortPDU, ULONG memberID)
{
		BitmapDeletePDU bitmapDeletePDU;
		bitmapDeletePDU.bitmapHandle = pBitmapAbortPDU->bitmapHandle;
		bitmapDeletePDU.bit_mask = 0;

		//
		// Pass it to bitmapDeletePDU
		//
		OnBitmapDeletePDU(&bitmapDeletePDU, memberID);
}
void	OnBitmapEditPDU(BitmapEditPDU * pBitmapEditPDU, ULONG memberID)
{
	BitmapObj*  pObj;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pBitmapEditPDU->bitmapHandle, (T126Obj **)&pObj, (WorkspaceObj**)&pWorkspace))
	{
		pObj->SetOwnerID(memberID);
		pObj->BitmapEditObj(pBitmapEditPDU);
	}

}
void	OnBitmapDeletePDU(BitmapDeletePDU * pBitmapDeletePDU, ULONG memberID)
{
	BitmapObj*  pObj;
	WorkspaceObj* pWorkspace;
	
	// We should find this drawing object
    if(FindObjectAndWorkspace(pBitmapDeletePDU->bitmapHandle, (T126Obj **)&pObj, (WorkspaceObj**)&pWorkspace))
	{
		pObj->SetOwnerID(memberID);
		pWorkspace->RemoveT126Object((T126Obj*)pObj);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\mcshelp.h ===
//
// MCSHELP.H
// MCS Helper functions
//
// Copyright Microsoft 1998-
//
#include "imcsapp.h"

#include "mcatmcs.h"	// For MAX_MCS_DATA_SIZE
#define     _MAX_MCS_MESSAGE_SIZE	64000
#define		_MAX_MCS_PDU_SIZE		MAX_MCS_DATA_SIZE
#define 	ObjectIDNode  unsigned long

// From T120 recomendation
#define _SI_CHANNEL_0                    8  
#define _SI_BITMAP_CREATE_TOKEN			 8
#define	_SI_WORKSPACE_REFRESH_TOKEN		 9

//Default values
#define INVALID_SAMPLE_RATE - 1


// Prototypes
BOOL T126_MCSSendDataIndication(ULONG uSize, LPBYTE pb, ULONG memberID, BOOL bResend);
BOOL AddT126ObjectToWorkspace(T126Obj *pObj);
UINT AllocateFakeGCCHandle(void);
void SetFakeGCCHandle(UINT fakeHandle);
WorkspaceObj * GetWorkspace(UINT activeWorkspace);
BOOL FindObjectAndWorkspace(UINT objectHandle, T126Obj**  pObj, WorkspaceObj** pWorkspace);

//
// From transport to UI
//

//
// DrawingPDUs
//
void	OnDrawingCreatePDU(DrawingCreatePDU * pdrawingCreatePDU, ULONG memberID, BOOL bResend);
void	OnDrawingEditPDU(DrawingEditPDU * pdrawingEditPDU, ULONG memberID, BOOL bResend);
void	OnDrawingDeletePDU(DrawingDeletePDU * pdrawingDeletePDU, ULONG memberID);

//
// TextPDUs
//
void	OnTextCreatePDU(MSTextPDU* pCreatePDU, ULONG memberID, BOOL bForcedResend);;
void	OnTextEditPDU(MSTextPDU *pEditPDU, ULONG memberID);
void	OnTextDeletePDU(TEXTPDU_HEADER *pHeader, ULONG memberID);

//
// WorkspacePDUs
//
void OnWorkspaceCreatePDU(WorkspaceCreatePDU * pWorkspaceCreatePDU, ULONG memberID, BOOL bResend);
void OnWorkspaceCreateAcknowledgePDU(WorkspaceCreateAcknowledgePDU * pWorkspaceCreateAcknowledgePDU, ULONG memberID);
void OnWorkspaceDeletePDU(WorkspaceDeletePDU * pWorkspaceDeletePDU, ULONG memberID);
void OnWorkspaceEditPDU(WorkspaceEditPDU * pWorkspaceEditPDU, ULONG memberID);
void OnWorkspacePlaneCopyPDU(WorkspacePlaneCopyPDU * pWorkspacePlaneCopyPDU, ULONG memberID);
void OnWorkspaceReadyPDU(WorkspaceReadyPDU * pWorkspaceReadyPDU, ULONG memberID);
void OnWorkspaceRefreshStatusPDU(WorkspaceRefreshStatusPDU * pWorkspaceRefreshStatusPDU, ULONG memberID);

//
// BitmapPDUs
//
void	OnBitmapCreatePDU(BitmapCreatePDU * pBitmapCreatePDU, ULONG memberID, BOOL bResend);
void	OnBitmapCreateContinuePDU(BitmapCreateContinuePDU * pBitmapCreateContinuePDU, ULONG memberID, BOOL bForcedResend);
void	OnBitmapCheckpointPDU(BitmapCheckpointPDU * pBitmapCheckPointPDU, ULONG memberID);
void	OnBitmapAbortPDU(BitmapAbortPDU * pBitmapAbortPDU, ULONG memberID);
void	OnBitmapEditPDU(BitmapEditPDU * pBitmapEditPDU, ULONG memberID);
void	OnBitmapDeletePDU(BitmapDeletePDU * pBitmapDeletePDU, ULONG memberID);

void	DeleteAllWorkspaces(BOOL sendPDU);

void RetrySend(void);
T120Error  	SendT126PDU(SIPDU * pPDU);
T120Error   SendPDU(SIPDU * pPDU, BOOL bRetry);
void SIPDUCleanUp(SIPDU *sipdu);
void DeleteAllRetryPDUS(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\main.cpp ===
//
// MAIN.CPP
// Whiteboard Windows App Code
//
// Copyright Microsoft 1998-
//


// PRECOMP
#include "precomp.h"
#include <it120app.h>
#include <regentry.h>
#include "gccmsg.h"
#include "coder.hpp"
#include "NMWbObj.h"
#include "wbloader.h"

Coder * g_pCoder;

WbMainWindow *  g_pMain;
HINSTANCE   g_hInstance;
UINT        g_uConfShutdown;
WbPrinter * g_pPrinter;
BOOL        g_bPalettesInitialized;
BOOL        g_bUsePalettes;
HPALETTE    g_hRainbowPaletteDisplay;
DWORD		g_dwWorkThreadID = 0;
DWORD __stdcall WBWorkThreadProc(LPVOID lpv);

HINSTANCE   g_hImmLib;
IGC_PROC    g_fnImmGetContext;
INI_PROC    g_fnImmNotifyIME;

extern HANDLE g_hWorkThread;

//
// Arrays
//
COLORREF    g_ColorTable[NUM_COLOR_ENTRIES] =
{
    RGB(  0, 255, 255),                   // Cyan
    RGB(255, 255,   0),                   // Yellow
    RGB(255,   0, 255),                   // Magenta
    RGB(  0,   0, 255),                   // Blue
    RGB(192, 192, 192),                   // Grey
    RGB(255,   0,   0),                   // Red
    RGB(  0,   0, 128),                   // Dark blue
    RGB(  0, 128, 128),                   // Dark cyan
    RGB(  0, 255,   0),                   // Green
    RGB(  0, 128,   0),                   // Dark green
    RGB(128,   0,   0),                   // Dark red
    RGB(128,   0, 128),                   // Purple
    RGB(128, 128,   0),                   // Olive
    RGB(128, 128, 128),                   // Grey
    RGB(255, 255, 255),                   // White
    RGB(  0,   0,   0),                   // Black
    RGB(255, 128,   0),                   // Orange
    RGB(128, 255, 255),                   // Turquoise
    RGB(  0, 128, 255),                   // Mid blue
    RGB(  0, 255, 128),                   // Pale green
    RGB(255,   0, 128)                    // Dark pink
};


int g_ClipboardFormats[CLIPBOARD_ACCEPTABLE_FORMATS] =
{
    0,                   // CLIPBOARD_PRIVATE - Reserved for the T126 whiteboard private format
    CF_DIB,              // Standard formats
    CF_ENHMETAFILE,	   // move metafiles to lower pri than bitmaps (bug NM4db:411)
    CF_TEXT
};



// Default widths for all tools except for highlighters
UINT g_PenWidths[NUM_OF_WIDTHS] = { 2, 4, 8, 16 };

// Default widths for highlight tools
UINT g_HighlightWidths[NUM_OF_WIDTHS] = { 4, 8, 16, 32 };

//
// Objects
//
WbDrawingArea *         g_pDraw;
DCWbColorToIconMap *    g_pIcons;
UINT					g_localGCCHandle;		// This is a fake GCC handle used when we are not in a conference

#ifdef _DEBUG
HDBGZONE    ghZoneWb;

PTCHAR      g_rgZonesWb[] = // CHECK ZONE_WBxxx CONSTANTS IF THESE CHANGE
{
    "NewWB",
    DEFAULT_ZONES
	"DEBUG",
	"MSG",
	"TIMER",
	"EVENT"
};
#endif // _DEBUG


//
// Mapping of internal return codes to string resources                     
//
typedef struct tagERROR_MAP
{
    UINT uiFEReturnCode;
    UINT uiDCGReturnCode;
    UINT uiCaption;
    UINT uiMessage;
}
ERROR_MAP;


ERROR_MAP g_ErrorStringID[] =
{
  { WBFE_RC_JOIN_CALL_FAILED,           // Registration failed
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_JOIN_CALL_FAILED
  },

  { WBFE_RC_WINDOWS,                    // A windows error has occurred
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_WINDOWS_RESOURCES
  },

  { WBFE_RC_WB,                         // Page limit exceeded
    WB_RC_TOO_MANY_PAGES,
    IDS_MSG_CAPTION,
    IDS_MSG_TOO_MANY_PAGES
  },

  { WBFE_RC_WB,          // Another user has the contents lock
    WB_RC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_LOCKED
  },

  { WBFE_RC_WB,          // Another user has the graphic locked
    WB_RC_GRAPHIC_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_GRAPHIC_LOCKED,
  },

  { WBFE_RC_WB,          // The local user does not have the lock
    WB_RC_NOT_LOCKED,
    IDS_MSG_CAPTION,
    IDS_MSG_NOT_LOCKED
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_FILE_FORMAT,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_FILE_FORMAT
  },

  { WBFE_RC_WB,          // File is not in expected format
    WB_RC_BAD_STATE,
    IDS_MSG_CAPTION,
    IDS_MSG_BAD_STATE_TO_LOAD_FILE
  },


  { WBFE_RC_WB,          // Whiteboard busy (exhausted page cache)
    WB_RC_BUSY,
    IDS_MSG_CAPTION,
    IDS_MSG_BUSY
  },

  { WBFE_RC_CM,          // Failed to access call manager
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_CM_ERROR
  },

  { WBFE_RC_AL,          // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_AL_ERROR
  },

  { WBFE_RC_PRINTER,     // Failed to register with application loader
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_PRINTER_ERROR
  },

  { 0,                   // Catch-all default
    0,
    IDS_MSG_CAPTION,
    IDS_MSG_DEFAULT
  }
};




//
//                                                                          
// Function:    Message                                                     
//                                                                          
// Purpose:     Display an error message box with string resources specified
//              as parameters, with the WB main window as the modal window. 
//                                                                          
//
int Message
(
    HWND    hwnd,
    UINT    uiCaption,
    UINT    uiMessage,
    UINT    uiStyle
)
{
    TCHAR   message[256];
    TCHAR   caption[256];

	//make sure we're on top
    ASSERT(g_pMain);
    if (!hwnd)
        hwnd = g_pMain->m_hwnd;

    if (hwnd != NULL)
    {
		::SetForegroundWindow(hwnd);
    }

    LoadString(g_hInstance, uiMessage, message, 256);

    LoadString(g_hInstance, uiCaption, caption, 256);

    //
    // BOGUS LAURABU:
    // Make use of MessageBoxEx() and just pass the string IDs along, 
    // rather than doing the LoadString() ourself.
    //

    // Display a message box with the relevant text
	return(::MessageBox(hwnd, message, caption, uiStyle));
}



//
//                                                                          
// Function:    ErrorMessage                                                
//                                                                          
// Purpose:     Display an error based on return codes from Whiteboard      
//              processing.                                                 
//                                                                          
//
void ErrorMessage(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "::ErrorMessage (codes)");

    TRACE_MSG(("FE return code  = %hd", uiFEReturnCode));
    TRACE_MSG(("DCG return code = %hd", uiDCGReturnCode));

    // Find the associated string resource IDS
    int iIndex;

    for (iIndex = 0; ; iIndex++)
    {
        // If we have come to the end of the list, stop
        if (g_ErrorStringID[iIndex].uiFEReturnCode == 0)
        {
            break;
        }

        // Check for a match
        if (g_ErrorStringID[iIndex].uiFEReturnCode == uiFEReturnCode)
        {
            if (   (g_ErrorStringID[iIndex].uiDCGReturnCode == uiDCGReturnCode)
                || (g_ErrorStringID[iIndex].uiDCGReturnCode == 0))
            {
                break;
            }
        }
    }

    // Display the message
    Message(NULL, g_ErrorStringID[iIndex].uiCaption, g_ErrorStringID[iIndex].uiMessage);
}



//
//                                                                          
// Function:    DefaultExceptionHandler                                     
//                                                                          
// Purpose:     Default exception processing. This can be called in an      
//              exception handler to get a message relevant to the          
//              exception. The message is generated by posting a message to 
//              the applications main window.                               
//                                                                          
//
void DefaultExceptionHandler(UINT uiFEReturnCode, UINT uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "DefaultExceptionHandler");

    // Post a message to the main window to get the error displayed
    if (g_pMain != NULL)
    {
        if (g_pMain->m_hwnd)
            ::PostMessage(g_pMain->m_hwnd, WM_USER_DISPLAY_ERROR, uiFEReturnCode, uiDCGReturnCode);
    }
}


BOOL WINAPI DllMain(HINSTANCE hDllInst, DWORD fdwReason, LPVOID lpv)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hInstance = hDllInst;
        DisableThreadLibraryCalls(hDllInst);
		g_dwWorkThreadID = 0;
		

#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &g_rgZonesWb[0],
            (sizeof(g_rgZonesWb) / sizeof(g_rgZonesWb[0])) - 1);
#endif

        DBG_INIT_MEMORY_TRACKING(hDllInst);
        g_pCoder = new Coder; 

        ::T120_AppletStatus(APPLET_ID_WB, APPLET_LIBRARY_LOADED);
        break;

    case DLL_PROCESS_DETACH:

        if (NULL != g_hWorkThread)
        {
            ::CloseHandle(g_hWorkThread);
        }
        ::T120_AppletStatus(APPLET_ID_WB, APPLET_LIBRARY_FREED);
		g_hInstance = NULL;
		g_dwWorkThreadID = 0;

		if(g_pCoder)
		{
			delete g_pCoder;
			g_pCoder = NULL;
		}

        DBG_CHECK_MEMORY_TRACKING(hDllInst);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif

        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\page.cpp ===
//
// PAGE.CPP
// WB Page Handling
//
// Copyright Microsoft 1998-
//
	
// PRECOMP
#include "precomp.h"




//
//
// Function:    Draw
//
// Purpose:     Draw the contents of the page into the specified device
//              context.
//
//
void PG_Draw(WorkspaceObj* pWorkspace, HDC hDC)
{
	T126Obj * pObj = NULL;
	WBPOSITION pos = NULL;

	if(pWorkspace)
	{
		pos = pWorkspace->GetHeadPosition();
	}
	
	while(pos)
	{
		pObj = (T126Obj*)pWorkspace->GetNextObject(pos);
		if(pObj)
		{
	        pObj->Draw(hDC, FALSE, TRUE);
	    }
	}
}


//
//
// Function:    First (crect)
//
// Purpose:     Return the first object in the page (bottommost Z-order)
//              that intersects the bounding rectangle
//
//
T126Obj* PG_First(WorkspaceObj * pWorkSpc,LPCRECT pRectUpdate, BOOL bCheckReallyHit)
{
    BOOL         empty = TRUE;
    T126Obj*	 pGraphic = NULL;
    RECT         rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_First");

	if(pWorkSpc)
	{
		pGraphic = pWorkSpc->GetHead();
	}

	if(pGraphic == NULL)
	{
		return NULL;
	}

    if (pRectUpdate == NULL)
    {
        // We have got what we want
        TRACE_MSG(("Got the object we want"));
    }
    else
    {
        WBPOSITION pos = pWorkSpc->GetHeadPosition(); 

		pGraphic->GetBoundsRect(&rc);
    	empty = !::IntersectRect(&rc, &rc, pRectUpdate);

        if (empty)
        {
            TRACE_MSG(("First object not needed - go to next"));
            pGraphic = PG_Next(pWorkSpc, pos, pRectUpdate, bCheckReallyHit);
        }
        else
        {
            if(bCheckReallyHit)
            {
                // do a real object hit test since we
                // know its bounding rect has hit
                if( !pGraphic->CheckReallyHit( pRectUpdate ) )
                {
                    pGraphic = PG_Next(pWorkSpc, pos, pRectUpdate, TRUE); // look again
                }
            }
        }
    }

    return(pGraphic);
}


//
//
// Function:    Next
//
// Purpose:     Return the next graphic in the page (going up through the
//              Z-order).  GetFirst must have been called before this
//              member.
//
T126Obj* PG_Next(WorkspaceObj* pWorkSpc, WBPOSITION& pos, LPCRECT pRectUpdate, BOOL bCheckReallyHit)
{
    BOOL		empty = TRUE;
    T126Obj*	pGraphic = NULL;
    RECT		rc;

    MLZ_EntryOut(ZONE_FUNCTION, "PG_Next");

    while (pos)
    {
		if(pWorkSpc)
		{
			pGraphic = pWorkSpc->GetNextObject(pos);
		}
    	
        if (pRectUpdate == NULL)
        {
            // We have got what we want
            TRACE_MSG(("Got the object we want"));
			break;
        }
        else
        {
			if(pGraphic)
			{
				pGraphic->GetBoundsRect(&rc);
				empty = !::IntersectRect(&rc, &rc, pRectUpdate);
			}
			
			if (!empty)
			{
				if( bCheckReallyHit )
				{
					// do a real object hit test since we
					// know its bounding rect has hit
					if( pGraphic && pGraphic->CheckReallyHit( pRectUpdate ) )
					{
						break;
					}
					else
                    {
						pGraphic = NULL; // look again
                    }
                }
                else
                {
					break; // found it
				}
            }
			else
			{
				pGraphic = NULL;
			}
        }
    }

    return(pGraphic);
}


//
//
// Function:    Last
//
// Purpose:     Select the last object whose bounding rectangle contains
//              the point specified.
//
//
T126Obj* PG_SelectLast
(
    WorkspaceObj * pWorkSpc,
    POINT	point
)
{
    RECT		rectHit;
    T126Obj*	pGraphic = NULL;

	if(pWorkSpc)
	{
		pGraphic = pWorkSpc->GetTail();
	}

	if(pGraphic == NULL)
	{
		return NULL;
	}

    WBPOSITION pos = pWorkSpc->GetTailPosition(); 

	MAKE_HIT_RECT(rectHit, point);
	if (!pGraphic->CheckReallyHit( &rectHit ))
	{
		// have to look some more
        pGraphic = PG_SelectPrevious(pWorkSpc, pos, point);
	}

    return(pGraphic);
}

//
//
// Function:    Previous
//
// Purpose:     Select the previous object whose bounding rectangle contains
//              the point specified.
//
//
T126Obj* PG_SelectPrevious(WorkspaceObj* pWorkspace, WBPOSITION& pos, POINT point)
{
	RECT        rectHit;
	T126Obj* pGraphic = NULL;

	MLZ_EntryOut(ZONE_FUNCTION, "PG_Previous");
	MAKE_HIT_RECT(rectHit, point );

	while (pos)
	{
		if(pWorkspace)
		{
	   		pGraphic = pWorkspace->GetPreviousObject(pos);
		}

        if( pGraphic && pGraphic->CheckReallyHit( &rectHit ) )
		{
			break;
		}            
        pGraphic = NULL;
    }
    return(pGraphic);
}

//CHANGED BY RAND
#define WB_MIN_PRINT_MARGIN_SIZE     (30)

//
//
// Function:    Print
//
// Purpose:     Print the contents of the page to the specified printer. The
//              contents are scaled to "best fit" on the page. i.e. the
//              largest scaling factor that preserves the aspect ratio of
//              the page is used.
//
//
void PG_Print(WorkspaceObj* pWorkspace,HDC hdc, LPCRECT lprcPrint)
{
    int pageWidth;
    int pageHeight;
    int areaHeight;
    int areaWidth;
    int areaAspectRatio;
    int pageAspectRatio;
    int nPhysOffsetX;
    int nPhysOffsetY;
    int nPhysWidth;
    int nPhysHeight;
    int nVOffsetX;
    int nVOffsetY;

    // get physical printer params
    nPhysOffsetX = GetDeviceCaps(hdc, PHYSICALOFFSETX );
    nPhysOffsetY = GetDeviceCaps(hdc, PHYSICALOFFSETY );
    nPhysWidth   = GetDeviceCaps(hdc, PHYSICALWIDTH );
    nPhysHeight  = GetDeviceCaps(hdc, PHYSICALHEIGHT );

    // calc correct printer area (allow for bugs in some drivers...)
    if( nPhysOffsetX <= 0 )
    {
        nPhysOffsetX = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetX = nPhysOffsetX;
    }
    else
        nVOffsetX = 0;

    if( nPhysOffsetY <= 0 )
    {
        nPhysOffsetY = WB_MIN_PRINT_MARGIN_SIZE;
        nVOffsetY = nPhysOffsetY;
    }
    else
        nVOffsetY = 0;


    // get and adjust printer page area
    pageWidth  = GetDeviceCaps(hdc, HORZRES );
    pageHeight = GetDeviceCaps(hdc, VERTRES );

    if( pageWidth >= (nPhysWidth - nPhysOffsetX) )
    {
        // HORZRES is lying to us, compensate
        pageWidth = nPhysWidth - 2*nPhysOffsetX;
    }

    if( pageHeight >= (nPhysHeight - nPhysOffsetY) )
    {
        // VERTRES is lying to us, compensate
        pageHeight = nPhysHeight - 2*nPhysOffsetY;
    }


    // adjust printer area to get max fit for Whiteboard page
    areaWidth  = lprcPrint->right - lprcPrint->left;
    areaHeight = lprcPrint->bottom - lprcPrint->top;
    areaAspectRatio = ((100 * areaHeight + (areaWidth/2))/(areaWidth));
    pageAspectRatio = ((100 * pageHeight + (pageWidth/2))/(pageWidth));

    if (areaAspectRatio < pageAspectRatio)
        pageHeight  = ((pageWidth * areaHeight + (areaWidth/2))/areaWidth);
    else 
    if (areaAspectRatio > pageAspectRatio)
        pageWidth = ((pageHeight * areaWidth + (areaHeight/2))/areaHeight);

    // set up xforms

   	::SetMapMode(hdc, MM_ANISOTROPIC );
    ::SetWindowExtEx(hdc, areaWidth, areaHeight,NULL );
    ::SetWindowOrgEx(hdc, 0,0, NULL );
    ::SetViewportExtEx(hdc, pageWidth, pageHeight, NULL );
    ::SetViewportOrgEx(hdc, nVOffsetX, nVOffsetY, NULL );
    
    // draw the page
    PG_Draw(pWorkspace, hdc);
}

//
//
// Function:    PG_InitializePalettes
//
// Purpose:     Create palettes for display and print (if necessary)
//
//
void PG_InitializePalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_InitializePalettes");

    // If the palettes are not yet initialized - initialize them now
    if (!g_bPalettesInitialized)
    {
        ASSERT(!g_hRainbowPaletteDisplay);

        // Get the number of colors supported by the screen
        // We only need an info DC for this, not a full DC
        HDC     hdc;

        hdc = ::CreateIC("DISPLAY", NULL, NULL, NULL);
        if (!hdc)
        {
            return;
        }

        // Determine whether the device supports palettes
        int iBitsPixel = ::GetDeviceCaps(hdc, BITSPIXEL);
        int iPlanes    = ::GetDeviceCaps(hdc, PLANES);
        int iNumColors = iBitsPixel * iPlanes;

        ::DeleteDC(hdc);

        // If we need the palette, create it.
        // We only need the palette on a 8bpp machine. Anything less (4bpp)
        // and there will be no palette, anything more is a pure color display.
        if ((iNumColors == 8) &&
            (g_hRainbowPaletteDisplay = CreateColorPalette()))
        {
            // Show that we want to use the palette
            g_bUsePalettes = TRUE;

        }
        else
        {
            g_bUsePalettes = FALSE;
        }

        // Show that we have now initialized the palette information
        g_bPalettesInitialized = TRUE;
    }
}

//
//
// Function:    PG_GetPalette
//
// Purpose:     Return the palette for use with this page.
//              This object is temporary and should not be stored.
//
//
HPALETTE PG_GetPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_GetPalette");

    // If the palettes are not yet initialized - initialize them now
    PG_InitializePalettes();

    if (g_bUsePalettes)
    {
        // If we are using a non-default palette, set the return value
        return(g_hRainbowPaletteDisplay);
    }
    else
    {
        return(NULL);
    }
}


void PG_ReinitPalettes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "PG_ReinitPalettes");

    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }
        ::DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    PG_InitializePalettes();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\nmwbobj.h ===
// NMWbObj.h : Declaration of the CNMWbObj

#ifndef __NMWBOBJ_H_
#define __NMWBOBJ_H_

#include <igccapp.h>
#include "resource.h"       // main symbols
#include <it120app.h>


//Microsoft non-collapsing capabilities values....
enum NonCollapsCaps
{
	_iT126_TEXT_CAPABILITY_ID = 0,
	_iT126_24BIT_BITMAP_ID,
	_iT126_LAST_NON_COLLAPSING_CAPABILITIES
};

LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

enum eMenuPos { MENUPOS_FILE = 0,
					MENUPOS_EDIT,
					MENUPOS_VIEW,
					MENUPOS_TOOLS};


// Forward Decls
class CNMWbObj;

#define ICON_BIG_SIZE								32
#define ICON_SMALL_SIZE								16



/////////////////////////////////////////////////////////////////////////////
// CNMWbObj
class  CNMWbObj
{

public: // Construction/destruction and initialization
	CNMWbObj();
    ~CNMWbObj();

    ULONG GetNumberOfMembers(void){return m_cOtherMembers;}
	BOOL			m_bImTheTopProvider;
	BOOL			m_bImTheT126Refresher;
	BOOL			m_bICanDo24BitBitmaps;
	BOOL			m_bConferenceCanDo24BitBitmaps;
	BOOL 			m_bConferenceCanDoText;
	BOOL			m_bConferenceOnlyNetmeetingNodes;
	BOOL 			CanDo24BitBitmaps(){return m_bConferenceCanDo24BitBitmaps;}
	BOOL			CanDoText(){return m_bConferenceCanDoText;}
	ULONG			m_LockerID;
	UINT      		m_instanceNumber;

	//
	// T120 stuff
	//
	IT120Applet				*m_pApplet;
	IT120AppletSession		*m_pAppletSession;
	T120JoinSessionRequest	m_JoinSessionReq;
	T120ResourceRequest		m_tokenResourceRequest;
	T120TokenRequest		m_tokenRequest;
    T120ConfID              m_nConfID;
	T120UserID				m_uidMyself;
	T120SessionID			m_sidMyself;
	T120EntityID			m_eidMyself;
	T120NodeID				m_nidMyself;
    ULONG      				m_cOtherMembers;
	MEMBER_ID				*m_aMembers;
	BOOL					m_fInConference;

	BOOL IsInConference(void) { return m_fInConference; }
    T120ConfID GetConfID(void) { return m_nConfID; }
    void OnPermitToEnroll(T120ConfID, BOOL fPermissionGranted);
    void OnJoinSessionConfirm(T120JoinSessionConfirm *);
    void OnAllocateHandleConfirm(GCCRegAllocateHandleConfirm *);
    void OnRosterIndication(ULONG cRosters, GCCAppRoster *apRosters[]);
    void CleanupPerConf(void);

	void BuildCaps(void);
	
	T120Error SendData(T120Priority	ePriority, ULONG cb, PBYTE pb);
    T120Error AllocateHandles(ULONG cHandles);
	T120Error GrabRefresherToken(void);
	HRESULT _UpdateContainerCaption( void );
};

#endif //__NMWBOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\mwnd.cpp ===
//
// MWND.CPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

// PRECOMP
#include "precomp.h"
#include <dde.h>
#include "version.h"
#include "nmwbobj.h"

static const TCHAR s_cszHtmlHelpFile[] = TEXT("nmwhiteb.chm");

// Class name
TCHAR szMainClassName[] = "T126WBMainWindowClass";

extern TCHAR g_PassedFileName[];

void ShiftFocus(HWND hwndTop, BOOL bForward);
BOOL IsWindowActive(HWND hwnd);

//
// Scroll accelerators
//
typedef struct tagSCROLL
{
	UINT uiMenuId;
	UINT uiMessage;
	UINT uiScrollCode;
}
SCROLL;

static const SCROLL s_MenuToScroll[] =
{
  { IDM_PAGEUP,        WM_VSCROLL, SB_PAGEUP },
  { IDM_PAGEDOWN,      WM_VSCROLL, SB_PAGEDOWN },
  { IDM_SHIFTPAGEUP,   WM_HSCROLL, SB_PAGEUP },
  { IDM_SHIFTPAGEDOWN, WM_HSCROLL, SB_PAGEDOWN },
  { IDM_HOME,          WM_HSCROLL, SB_TOP },
  { IDM_HOME,          WM_VSCROLL, SB_TOP },
  { IDM_END,           WM_HSCROLL, SB_BOTTOM },
  { IDM_END,           WM_VSCROLL, SB_BOTTOM },
  { IDM_LINEUP,        WM_VSCROLL, SB_LINEUP },
  { IDM_LINEDOWN,      WM_VSCROLL, SB_LINEDOWN },
  { IDM_SHIFTLINEUP,   WM_HSCROLL, SB_LINEUP },
  { IDM_SHIFTLINEDOWN, WM_HSCROLL, SB_LINEDOWN }
};


// tooltip data
// check codes
#define NA    0   // dont't check checked state
#define TB    1    // check toolbar for checked state
#define BT    2    // check tipped wnd (a button) for checked state

typedef struct
{
    UINT    nID;
    UINT    nCheck;
    UINT    nUpTipID;
    UINT    nDownTipID;
}
TIPIDS;

TIPIDS g_tipIDsArray[]    =
{
{IDM_SELECT,            TB, IDS_HINT_SELECT,        IDS_HINT_SELECT},
{IDM_ERASER,            TB, IDS_HINT_ERASER,        IDS_HINT_ERASER},
{IDM_TEXT,              TB, IDS_HINT_TEXT,          IDS_HINT_TEXT},
{IDM_HIGHLIGHT,         TB, IDS_HINT_HIGHLIGHT,     IDS_HINT_HIGHLIGHT},
{IDM_PEN,               TB, IDS_HINT_PEN,           IDS_HINT_PEN},
{IDM_LINE,              TB, IDS_HINT_LINE,          IDS_HINT_LINE},
{IDM_BOX,               TB, IDS_HINT_BOX,           IDS_HINT_BOX},
{IDM_FILLED_BOX,        TB, IDS_HINT_FBOX,          IDS_HINT_FBOX},
{IDM_ELLIPSE,           TB, IDS_HINT_ELLIPSE,       IDS_HINT_ELLIPSE},
{IDM_FILLED_ELLIPSE,    TB, IDS_HINT_FELLIPSE,      IDS_HINT_FELLIPSE},
{IDM_ZOOM,              TB, IDS_HINT_ZOOM_UP,       IDS_HINT_ZOOM_DOWN},
{IDM_REMOTE,            TB, IDS_HINT_REMOTE_UP,     IDS_HINT_REMOTE_DOWN},
{IDM_LOCK,              TB, IDS_HINT_LOCK_UP,       IDS_HINT_LOCK_DOWN},
{IDM_SYNC,              TB, IDS_HINT_SYNC_UP,       IDS_HINT_SYNC_DOWN},
{IDM_GRAB_AREA,         TB, IDS_HINT_GRAB_AREA,     IDS_HINT_GRAB_AREA},
{IDM_GRAB_WINDOW,       TB, IDS_HINT_GRAB_WINDOW,   IDS_HINT_GRAB_WINDOW},

{IDM_WIDTH_1,           NA, IDS_HINT_WIDTH_1,       IDS_HINT_WIDTH_1},
{IDM_WIDTH_2,           NA, IDS_HINT_WIDTH_2,       IDS_HINT_WIDTH_2},
{IDM_WIDTH_3,           NA, IDS_HINT_WIDTH_3,       IDS_HINT_WIDTH_3},
{IDM_WIDTH_4,           NA, IDS_HINT_WIDTH_4,       IDS_HINT_WIDTH_4},

{IDM_PAGE_FIRST,        BT, IDS_HINT_PAGE_FIRST,    IDS_HINT_PAGE_FIRST},
{IDM_PAGE_PREV,         BT, IDS_HINT_PAGE_PREVIOUS, IDS_HINT_PAGE_PREVIOUS},
{IDM_PAGE_ANY,          NA, IDS_HINT_PAGE_ANY,      IDS_HINT_PAGE_ANY},
{IDM_PAGE_NEXT,         BT, IDS_HINT_PAGE_NEXT,     IDS_HINT_PAGE_NEXT},
{IDM_PAGE_LAST,         BT, IDS_HINT_PAGE_LAST,     IDS_HINT_PAGE_LAST},
{IDM_PAGE_INSERT_AFTER, BT, IDS_HINT_PAGE_INSERT,   IDS_HINT_PAGE_INSERT}
    };
////////////


HRESULT WbMainWindow::WB_LoadFile(LPCTSTR szFile)
{
	//
	// If a file name was passed
	//
    if (szFile && g_pMain)
    {
        int     cchLength;
        BOOL    fSkippedQuote;

        // Skip past first quote
        if (fSkippedQuote = (*szFile == '"'))
            szFile++;

        cchLength = lstrlen(szFile);

        //
        // NOTE:
        // There may be DBCS implications with this.  Hence we check to see
        // if we skipped the first quote; we assume that if the file name
        // starts with a quote it must end with one also.  But we need to check
        // it out.
        //
        // Strip last quote
        if (fSkippedQuote && (cchLength > 0) && (szFile[cchLength - 1] == '"'))
        {
            BYTE * pLastQuote = (BYTE *)&szFile[cchLength - 1];
            TRACE_MSG(("Skipping last quote in file name %s", szFile));
        	*pLastQuote = '\0';
        }

        g_pMain->OnOpen(szFile);
	}

	return S_OK;
}

void WbMainWindow::BringToFront(void)
{
    if (NULL != m_hwnd)
    {
        int nCmdShow = SW_SHOW;

        WINDOWPLACEMENT wp;
        ::ZeroMemory(&wp, sizeof(wp));
        wp.length = sizeof(wp);

        if (::GetWindowPlacement(m_hwnd, &wp))
        {
            if (SW_MINIMIZE == wp.showCmd || SW_SHOWMINIMIZED == wp.showCmd)
            {
                // The window is minimized - restore it:
                nCmdShow = SW_RESTORE;
            }
        }

        // show the window now
        ::ShowWindow(m_hwnd, nCmdShow);

        // bring it to the foreground
        ::SetForegroundWindow(m_hwnd);
    }
}



//
//
// Function:    WbMainWindow constructor
//
// Purpose:     Create the main Whiteboard window. An exception is thrown
//              if an error occurs during construction.
//
//
WbMainWindow::WbMainWindow(void)
{
    OSVERSIONINFO   OsData;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::WbMainWindow");

    //
    // Initialize member vars first!
    //
    ZeroMemory(m_ToolArray, sizeof(m_ToolArray));

	m_hwnd = NULL;
    m_hwndToolTip = NULL;
    ZeroMemory(&m_tiLastHit, sizeof(m_tiLastHit));
    m_nLastHit = -1;

    m_bInitOk = FALSE;
    m_bDisplayingError = FALSE;

    m_hwndSB = NULL;
    m_bStatusBarOn = TRUE;
    m_bToolBarOn    = TRUE;

    // Load the main accelerator table
    m_hAccelTable =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(MAINACCELTABLE));

    m_hwndQuerySaveDlg = NULL;
    m_hwndWaitForEventDlg = NULL;
    m_hwndWaitForLockDlg = NULL;


    m_pCurrentTool = NULL;
	ZeroMemory(m_strFileName, sizeof(m_strFileName));
	m_pTitleFileName = NULL;

    // Load the alternative accelerator table for the pages edit
    // field and text editor
    m_hAccelPagesGroup =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(PAGESGROUPACCELTABLE));
    m_hAccelTextEdit   =
        ::LoadAccelerators(g_hInstance, MAKEINTRESOURCE(TEXTEDITACCELTABLE));


    // Show that we are not yet in a call
    m_uiSubState = SUBSTATE_IDLE;

    // We are not currently displaying a menu
    m_hContextMenuBar = NULL;
    m_hContextMenu = NULL;
    m_hGrobjContextMenuBar = NULL;
    m_hGrobjContextMenu = NULL;

    m_bInSaveDialog = FALSE;

    m_bSelectAllInProgress = FALSE;
    m_bUnlockStateSettled = TRUE;
    m_bQuerySysShutdown = FALSE;

    // figure out if we're on Win95
    m_bIsWin95 = FALSE;
    OsData.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if( GetVersionEx( &OsData ) )
    {
        if( OsData.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
            m_bIsWin95 = TRUE;
    }

    m_cancelModeSent = FALSE;

    //
    // We only do this once for the lifetime of the DLL.  There is no
    // way really to clean up registered window messages, and each register
    // bumps up a ref count.  If we registered each time WB was started up
    // during one session of CONF, we'd overflow the refcount.
    //
    if (!g_uConfShutdown)
    {
        g_uConfShutdown = ::RegisterWindowMessage( NM_ENDSESSION_MSG_NAME );
    }

	m_pLocalRemotePointer = NULL;
	m_localRemotePointerPosition.x = -50;
	m_localRemotePointerPosition.y = -50;
}


//
// Open()
// Do Main window initialization (stuff that can fail).  After this,
// the run code will try to join the current domain and do message loop
// stuff.
//
BOOL WbMainWindow::Open(int iCommand)
{
    WNDCLASSEX  wc;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Open");

    //
    // CREATE OTHER GLOBALS
    //


    if (!InitToolArray())
    {
        ERROR_OUT(("Can't create tools; failing to start up"));
        return(FALSE);
    }

    //
    // Init comon controls
    //
    InitCommonControls();


    //
    // CREATE THE MAIN FRAME WINDOW
    //
    ASSERT(!m_hwnd);

	//
    // Get the class info for it, and change the name.
    //
    ZeroMemory(&wc, sizeof(wc));
    wc.cbSize = sizeof(wc);
    wc.style            = CS_DBLCLKS; // CS_HREDRAW | CS_VREDRAW?
    wc.lpfnWndProc      = WbMainWindowProc;
    wc.hInstance        = g_hInstance;
    wc.hIcon            = ::LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APP));
    wc.hCursor          = ::LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName     = MAKEINTRESOURCE(IDR_MENU_WB_WITHFILE);
    wc.lpszClassName    = szMainClassName;

    if (!::RegisterClassEx(&wc))
    {
        ERROR_OUT(("Can't register private frame window class"));
        return(FALSE);
    }

    // Create the main drawing window.
    if (!::CreateWindowEx(WS_EX_APPWINDOW | WS_EX_WINDOWEDGE, szMainClassName,
        NULL, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, g_hInstance, this))
    {
        // Could not create the main window
        ERROR_OUT(("Failed to create main window"));
        return(FALSE);
    }

    ASSERT(m_hwnd);

	//
    // Create the pop-up context menu
    //
    if (!CreateContextMenus())
    {
        ERROR_OUT(("Failed to create context menus"));
        return(FALSE);
    }

	//
    // Register the the main window for Drag/Drop messages.
    //
    DragAcceptFiles(m_hwnd, TRUE);

    //
    // CREATE THE CHILD WINDOWS
    //

    // Create the drawing pane
    // (the Create call throws an exception on error)
    RECT    clientRect;
    RECT    drawingAreaRect;

	::GetClientRect(m_hwnd, &clientRect);
  	drawingAreaRect.top=0;
	drawingAreaRect.bottom = DRAW_HEIGHT;
	drawingAreaRect.left = 0;
	drawingAreaRect.right = DRAW_WIDTH;

    // Every control in the main window has a border on it, so increase the
    // client size by 1 to force these borders to be drawn under the inside
    // black line in the window frame.  This prevents a 2 pel wide border
    // being drawn
    ::InflateRect(&clientRect, 1, 1);

    SIZE sizeAG;
    m_AG.GetNaturalSize(&sizeAG);

    if (!m_drawingArea.Create(m_hwnd, &drawingAreaRect))
    {
        ERROR_OUT(("Failed to create drawing area"));
        return(FALSE);
    }

	//
	// Create the toolbar
	//
    if (!m_TB.Create(m_hwnd))
    {
        ERROR_OUT(("Failed to create tool window"));
        return(FALSE);
    }


    //
    // Create the attributes group
    // The attributes group is on the bottom, underneath the
    // drawing area, above the status bar.
    //
    RECT    rectAG;

    rectAG.left = clientRect.left;
    rectAG.right = clientRect.right;
    rectAG.top = drawingAreaRect.bottom;
    rectAG.bottom = rectAG.top + sizeAG.cy;

    if (!m_AG.Create(m_hwnd, &rectAG))
    {
        ERROR_OUT(("Failed to create attributes group window"));
        return(FALSE);
    }

    //
    // Create the widths group.
    // The widths group is on the left side, underneath the tools group
    //
    SIZE    sizeWG;
    RECT    rectWG;


    // The widths group is on the left side, underneath the toolbar
    m_WG.GetNaturalSize(&sizeWG);
    rectWG.left = 0;
    rectWG.right = rectWG.left + sizeWG.cx;
    rectWG.bottom = rectAG.top;
    rectWG.top  = rectWG.bottom - sizeWG.cy;

    if (!m_WG.Create(m_hwnd, &rectWG))
    {
        ERROR_OUT(("Failed to create widths group window"));
        return(FALSE);
    }

	//
	// Create the status bar
	//
	m_hwndSB = ::CreateWindowEx(0, STATUSCLASSNAME, NULL,
		WS_CHILD | WS_VISIBLE | CCS_NOPARENTALIGN | CCS_NOMOVEY |
		CCS_NORESIZE | SBARS_SIZEGRIP,
		clientRect.left, clientRect.bottom - STATUSBAR_HEIGHT,
		(clientRect.right - clientRect.left), STATUSBAR_HEIGHT,
		m_hwnd, 0, g_hInstance, NULL);

	if (!m_hwndSB)
	{
		ERROR_OUT(("Failed to create status bar window"));
		return(FALSE);
	}

    // Initialize the color, width and tool menus
    InitializeMenus();

    m_currentMenuTool       = IDM_SELECT;
    m_pCurrentTool          = m_ToolArray[TOOL_INDEX(IDM_SELECT)];
	OnSelectTool(m_currentMenuTool);


    m_hwndToolTip = ::CreateWindowEx(NULL, TOOLTIPS_CLASS, NULL,
        WS_POPUP | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, m_hwnd, NULL, g_hInstance, NULL);
    if (!m_hwndToolTip)
    {
        ERROR_OUT(("Unable to create tooltip window"));
        return(FALSE);
    }

    // Add a dead-area tooltip
    TOOLINFO ti;

    ZeroMemory(&ti, sizeof(ti));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = m_hwnd;
    ti.uId = (UINT_PTR)m_hwnd;
    ::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    // Ensure the page buttons are disabled while starting
    UpdatePageButtons();

    // If this is the first time we have created a clipboard object,
    // register the private Whiteboard formats.
    if (g_ClipboardFormats[CLIPBOARD_PRIVATE] == 0)
    {
        g_ClipboardFormats[CLIPBOARD_PRIVATE] =
            (int) ::RegisterClipboardFormat("NMWT126");
    }


    m_bInitOk = TRUE;

    BOOL bSuccess = TRUE;    // indicates whether window opened successfully

    // Get the position of the window from options
    RECT    rectWindow;

    OPT_GetWindowRectOption(&rectWindow);

    ::MoveWindow(m_hwnd, rectWindow.left, rectWindow.top,
            rectWindow.right - rectWindow.left,
            rectWindow.bottom - rectWindow.top, FALSE );


	//
	// Inititalize the fake GCC handle, it will be used when we are not in a conference and need
	//	handles for workspaces/drawings/bitmaps etc...
	//
	g_localGCCHandle = 1;

	//
	// Create a standard workspace
	//
	if(g_pCurrentWorkspace)
	{
		m_drawingArea.Attach(g_pCurrentWorkspace);
	}
	else
	{
		if(g_numberOfWorkspaces < WB_MAX_WORKSPACES)
		{
			m_drawingArea.Detach();
			WorkspaceObj * pObj;
			DBG_SAVE_FILE_LINE
			pObj = new WorkspaceObj();
			pObj->AddToWorkspace();
			g_pConferenceWorkspace = pObj;
		}
	}

	CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
	CheckMenuItem(IDM_TOOL_BAR_TOGGLE);

	//
	// Start synced
	//
	Sync();

	if(!OPT_GetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, DFLT_MAIN_STATUSBARVISIBLE))
	{
		OnStatusBarToggle();
	}	

	if(!OPT_GetBooleanOption(OPT_MAIN_TOOLBARVISIBLE, DFLT_MAIN_TOOLBARVISIBLE))
	{
		OnToolBarToggle();
	}
	
	::ShowWindow(m_hwnd, iCommand);
	::UpdateWindow(m_hwnd);

	// Update the window title with no file name
	UpdateWindowTitle();


	// Return value indicating success or failure
	return(bSuccess);
}




//
//
// Function : OnMenuSelect
//
// Purpose  : Update the text in the help bar
//
//
void WbMainWindow::OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu)
{
	UINT   firstMenuId;
	UINT   statusId;

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnMenuSelect");

	//
	// Work out the help ID for the menu item.  We have to store this now
	// because when the user presses F1 from a menu item, we can't tell
	// which item it was.
	//
	if ((uiFlags & MF_POPUP) && (uiFlags & MF_SYSMENU))
	{
		//
		// System menu selected
		//
		statusId   = IDS_MENU_SYSTEM;
	}
	else if (uiFlags & MF_POPUP)
	{
		// get popup menu handle and first item (bug NM4db:463)
		HMENU hPopup = ::GetSubMenu( hSysMenu, uiItemID );
		firstMenuId = ::GetMenuItemID( hPopup, 0 );

		// figure out which popup it is so we can display the right help text
		switch (firstMenuId)
		{
			case IDM_NEW:
				statusId   = IDS_MENU_FILE;
				break;

			case IDM_DELETE:
				statusId   = IDS_MENU_EDIT;
				break;

			case IDM_TOOL_BAR_TOGGLE:
				statusId   = IDS_MENU_VIEW;
				break;

			case IDM_EDITCOLOR:
			case IDM_TOOLS_START:
				statusId   = IDS_MENU_TOOLS;
				break;

			case IDM_HELP:
				statusId = IDS_MENU_HELP;
				break;

			case IDM_WIDTH_1: // (added for bug NM4db:463)
				statusId   = IDS_MENU_WIDTH;
				break;

			default:
				statusId   = IDS_DEFAULT;
				break;
		}
	}
	else
	{
		//
		// A normal menu item has been selected
		//
		statusId   = uiItemID;
	}

	// Set the new help text
	TCHAR   szStatus[256];

	if (::LoadString(g_hInstance, statusId, szStatus, 256))
	{
		::SetWindowText(m_hwndSB, szStatus);
	}
}




//
// WbMainWindowProc()
// Frame window message handler
//
LRESULT WbMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    WbMainWindow * pMain;

    pMain = (WbMainWindow *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (message)
    {
        case WM_NCCREATE:
            pMain = (WbMainWindow *)((LPCREATESTRUCT)lParam)->lpCreateParams;
            ASSERT(pMain);

            pMain->m_hwnd = hwnd;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pMain);
            goto DefWndProc;
            break;

        case WM_DESTROY:
            ShutDownHelp();
            break;

        case WM_NCDESTROY:
            pMain->m_hwnd = NULL;
            break;

        case WM_SIZE:
            pMain->OnSize((UINT)wParam, (short)LOWORD(lParam), (short)HIWORD(lParam));
            break;

        case WM_ACTIVATE:
            if (GET_WM_ACTIVATE_STATE(wParam, lParam) == WA_INACTIVE)
            {
                // Cancel the tooltip if it's around
                if (pMain->m_hwndToolTip)
                    ::SendMessage(pMain->m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
            }
            goto DefWndProc;
            break;

        case WM_SETFOCUS:
            pMain->OnSetFocus();
            break;

        case WM_CANCELMODE:
            pMain->OnCancelMode();
            break;

        case WM_INITMENUPOPUP:
            pMain->OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_MENUSELECT:
            pMain->OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam),
                GET_WM_MENUSELECT_FLAGS(wParam, lParam),
                GET_WM_MENUSELECT_HMENU(wParam, lParam));
            break;

        case WM_MEASUREITEM:
            pMain->OnMeasureItem((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam);
            break;

        case WM_DRAWITEM:
            pMain->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_QUERYNEWPALETTE:
            lResult = pMain->OnQueryNewPalette();
            break;

        case WM_PALETTECHANGED:
            pMain->OnPaletteChanged((HWND)wParam);
            break;

        case WM_HELP:
            pMain->OnCommand(IDM_HELP, 0, NULL);
            break;

        case WM_CLOSE:
            pMain->OnClose();
            break;

        case WM_QUERYENDSESSION:
            lResult = pMain->OnQueryEndSession();
            break;

        case WM_ENDSESSION:
            pMain->OnEndSession((UINT)wParam);
            break;

        case WM_SYSCOLORCHANGE:
            pMain->OnSysColorChange();
            break;

        case WM_USER_PRIVATE_PARENTNOTIFY:
            pMain->OnParentNotify(GET_WM_PARENTNOTIFY_MSG(wParam, lParam));
            break;

        case WM_GETMINMAXINFO:
            if (pMain)
                pMain->OnGetMinMaxInfo((LPMINMAXINFO)lParam);
            break;

        case WM_COMMAND:
            pMain->OnCommand(LOWORD(wParam), HIWORD(wParam), (HWND)lParam);
            break;

        case WM_NOTIFY:
            pMain->OnNotify((UINT)wParam, (NMHDR *)lParam);
            break;

        case WM_DROPFILES:
            pMain->OnDropFiles((HDROP)wParam);
            break;

        case WM_USER_DISPLAY_ERROR:
            pMain->OnDisplayError(wParam, lParam);
            break;

        case WM_USER_UPDATE_ATTRIBUTES:
            pMain->m_AG.DisplayTool(pMain->m_pCurrentTool);
            break;

		case WM_USER_LOAD_FILE:
			pMain->WB_LoadFile(g_PassedFileName);
			// Fall through.

        case WM_USER_BRING_TO_FRONT_WINDOW:
        	pMain->BringToFront();
        	break;

        default:
            if (message == g_uConfShutdown)
            {
                lResult = pMain->OnConfShutdown(wParam, lParam);
            }
            else
            {
DefWndProc:
                lResult = DefWindowProc(hwnd, message, wParam, lParam);
            }
            break;
    }

    return(lResult);
}



//
// OnCommand()
// Command dispatcher for the main window
//
void WbMainWindow::OnCommand(UINT cmd, UINT code, HWND hwndCtl)
{
	switch (cmd)
	{
		//
		// FILE MENU
		//
		case IDM_NEW:
			OnNew();
			break;

		case IDM_OPEN:
			OnOpen();
			break;

		case IDM_SAVE:
			OnSave(FALSE);
			break;

		case IDM_SAVE_AS:
			OnSave(TRUE);
			break;

		case IDM_PRINT:
			OnPrint();
			break;

		case IDM_EXIT:
			::PostMessage(m_hwnd, WM_CLOSE, 0, 0);
			break;

		//
		// EDIT MENU
		//
		case IDM_DELETE:
			OnDelete();
			break;

		case IDM_UNDELETE:
			OnUndelete();
			break;

		case IDM_CUT:
			OnCut();
			break;

		case IDM_COPY:
			OnCopy();
			break;

		case IDM_PASTE:
			OnPaste();
			break;

		case IDM_SELECTALL:
			OnSelectAll();
			break;

		case IDM_BRING_TO_TOP:
			m_drawingArea.BringToTopSelection(TRUE, 0);
			break;

		case IDM_SEND_TO_BACK:
			m_drawingArea.SendToBackSelection(TRUE, 0);
			break;

		case IDM_CLEAR_PAGE:
			OnClearPage();
			break;

		case IDM_DELETE_PAGE:
			OnDeletePage();
			break;

		case IDM_PAGE_INSERT_AFTER:
			OnInsertPageAfter();
			break;

		//
		// VIEW MENU
		//
		case IDM_TOOL_BAR_TOGGLE:
			OnToolBarToggle();
			break;

		case IDM_STATUS_BAR_TOGGLE:
			OnStatusBarToggle();
			break;

		case IDM_ZOOM:
			OnZoom();
			break;

		//
		// TOOLS MENU
		//
		case IDM_SELECT:
		case IDM_PEN:
		case IDM_HIGHLIGHT:
		case IDM_TEXT:
		case IDM_ERASER:
		case IDM_LINE:
		case IDM_BOX:
		case IDM_FILLED_BOX:
		case IDM_ELLIPSE:
		case IDM_FILLED_ELLIPSE:
			OnSelectTool(cmd);
			break;

		case IDM_REMOTE:
			OnRemotePointer();

			//
			// Are we turnig remote pointer on
			//
			if(m_pLocalRemotePointer)
			{
				//put us in select-tool mode
				OnSelectTool(IDM_SELECT);
			}
			break;

		case IDM_GRAB_AREA:
			OnGrabArea();
			break;

		case IDM_GRAB_WINDOW:
			OnGrabWindow();
			break;

		case IDM_SYNC:
			OnSync();
			break;

		case IDM_LOCK:
			OnLock();
			break;

		case IDM_COLOR:
			OnSelectColor();
			break;

		case IDM_EDITCOLOR:
			m_AG.OnEditColors();
			break;

		case IDM_FONT:
			OnChooseFont();
			break;

		case IDM_WIDTH_1:
		case IDM_WIDTH_2:
		case IDM_WIDTH_3:
		case IDM_WIDTH_4:
			OnSelectWidth(cmd);
			break;

		//
		// HELP MENU
		//
		case IDM_ABOUT:
			OnAbout();
			break;

		case IDM_HELP:
			ShowHelp();
			break;

		//
		// PAGE BAR
		//
		case IDM_PAGE_FIRST:
			OnFirstPage();
			break;

		case IDM_PAGE_PREV:
			OnPrevPage();
			break;

		case IDM_PAGE_GOTO:
			OnGotoPage();
			break;

		case IDM_PAGE_NEXT:
			OnNextPage();
			break;

		case IDM_PAGE_LAST:
			OnLastPage();
			break;

		//
		// SCROLLING
		//
		case IDM_PAGEUP:
		case IDM_PAGEDOWN:
		case IDM_SHIFTPAGEUP:
		case IDM_SHIFTPAGEDOWN:
		case IDM_HOME:
		case IDM_END:
		case IDM_LINEUP:
		case IDM_LINEDOWN:
		case IDM_SHIFTLINEUP:
		case IDM_SHIFTLINEDOWN:
			OnScrollAccelerator(cmd);
			break;

		case ID_NAV_TAB:
			ShiftFocus(m_hwnd, TRUE);
			break;

		case ID_NAV_SHIFT_TAB:
			ShiftFocus(m_hwnd, FALSE);
			break;


	}
}



//
//
// Function:    OnInitMenuPopup
//
// Purpose:     Process a WM_INITMENUPOPUP event
//
//
void WbMainWindow::OnInitMenuPopup
(
    HMENU   hMenu,
    UINT    uiIndex,
    BOOL    bSystemMenu
)
{

    // Ignore the event if it relates to the system menu
    if (!bSystemMenu)
    {
        if (hMenu)
        {
            SetMenuStates(hMenu);
            m_hInitMenu = hMenu;
        }
        else
        {
            m_hInitMenu = NULL;
        }

        // Save the last menu we handled, so that we can alter its state
        // if necessary whilst it is still visible
    }
}


//
//
// Function:    GetMenuWithItem
//
// Purpose:     Return the menu which contains the specified item.
//
//
HMENU WbMainWindow::GetMenuWithItem(HMENU hMenu, UINT uiID)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetMenuWithItem");

    ASSERT(hMenu != NULL);

    HMENU hMenuResult = NULL;

    // Get the number ofitems in the menu
    UINT uiNumItems = ::GetMenuItemCount(hMenu);
    UINT   uiPos;
    UINT   uiNextID;

    // Look for the item through the menu
    for (uiPos = 0; uiPos < uiNumItems; uiPos++)
    {
        // Get the ID of the item at this position
        uiNextID = ::GetMenuItemID(hMenu, uiPos);

        if (uiNextID == uiID)
        {
            // We have found the item
            hMenuResult = hMenu;
            break;
        }
    }

    // If we have not yet found the item
    if (hMenuResult == NULL)
    {
        // Look through each of the submenus of the current menu
        HMENU hSubMenu;

        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Get the ID of the item at this position
            uiNextID = ::GetMenuItemID(hMenu, uiPos);

            // If the item is a submenu
            if (uiNextID == -1)
            {
                // Get the submenu
                hSubMenu = ::GetSubMenu(hMenu, (int) uiPos);

                // Search the submenu
                hMenuResult = GetMenuWithItem(hSubMenu, uiID);
                if (hMenuResult != NULL)
                {
                    // We have found the menu with the requested item
                    break;
                }
            }
        }
    }

    return hMenuResult;
}



//
//
// Function:    WbMainWindow::InitializeMenus
//
// Purpose:     Initialise the menus: set up owner-drawn menu items and
//              those read from options file.
//
//
void WbMainWindow::InitializeMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::InitializeMenus");

    // Make the width menu ownerdraw
    HMENU hMenu = GetMenuWithItem(::GetMenu(m_hwnd), IDM_WIDTH_1);
    if (hMenu != NULL)
    {
        // Change each entry to be ownerdraw (loop until failure)
        int iIndex;
        UINT uiId;
        int iCount = ::GetMenuItemCount(hMenu);

        for (iIndex = 0; iIndex < iCount; iIndex++)
        {
            uiId = ::GetMenuItemID(hMenu, iIndex);
            ::ModifyMenu(hMenu, iIndex,
                        MF_BYPOSITION
                      | MF_ENABLED
                      | MF_OWNERDRAW,
                      uiId,
                      NULL);
        }
    }
}




//
//
// Function:    CheckMenuItem
//
// Purpose:     Check an item on the application menus (main and context
//              menu.)
//
//
void WbMainWindow::CheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_CHECKED);
}

//
//
// Function:    UncheckMenuItem
//
// Purpose:     Uncheck an item on the application menus (main and context
//              menus.)
//
//
void WbMainWindow::UncheckMenuItem(UINT uiId)
{
    CheckMenuItemRecursive(::GetMenu(m_hwnd), uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
    CheckMenuItemRecursive(m_hGrobjContextMenu, uiId, MF_BYCOMMAND | MF_UNCHECKED);
}

//
//
// Function:    CheckMenuItemRecursive
//
// Purpose:     Check or uncheck an item on the any of the Whiteboard menus.
//              This function recursively searches through the menus until
//              it finds the specified item. The menu item Ids must be
//              unique for this function to work.
//
//
BOOL WbMainWindow::CheckMenuItemRecursive(HMENU hMenu,
                                            UINT uiId,
                                            BOOL bCheck)
{
    UINT uiNumItems = ::GetMenuItemCount(hMenu);

    // Attempt to check the menu item
    UINT uiCheck = MF_BYCOMMAND | (bCheck ? MF_CHECKED : MF_UNCHECKED);

    // A return code of -1 from CheckMenuItem implies that
    // the menu item was not found
    BOOL bChecked = ((::CheckMenuItem(hMenu, uiId, uiCheck) == -1) ? FALSE : TRUE);
    if (bChecked)
    {
        //
        // If this item is on the active menu, ensure it's redrawn now
        //
        if (hMenu == m_hInitMenu)
        {
            InvalidateActiveMenu();
        }
    }
    else
    {
        UINT   uiPos;
        HMENU hSubMenu;

        // Recurse through the submenus of the specified menu
        for (uiPos = 0; uiPos < uiNumItems; uiPos++)
        {
            // Assume that the next item is a submenu
            // and try to get a pointer to it
            hSubMenu = ::GetSubMenu(hMenu, (int)uiPos);

            // NULL return implies the item is a not submenu
            if (hSubMenu != NULL)
            {
                // Item is a submenu, make recursive call to search it
                bChecked = CheckMenuItemRecursive(hSubMenu, uiId, bCheck);
                if (bChecked)
                {
                    // We have found the item
                    break;
                }
            }
        }
    }

    return bChecked;
}

//
//
//  Function:  InvalidateActiveMenu
//
//  Purpose:   If a menu is currently active, gray items according to
//             the current state, and force it to redraw.
//
//
void WbMainWindow::InvalidateActiveMenu()
{
  if (m_hInitMenu != NULL)
  {
      // A menu is displayed, so set the state appropriately and force a
      // repaint to show the new state
      SetMenuStates(m_hInitMenu);

      ::RedrawWindow(::GetTopWindow(::GetDesktopWindow()),
                     NULL, NULL,
                     RDW_FRAME | RDW_INVALIDATE | RDW_ERASE |
                                   RDW_ERASENOW | RDW_ALLCHILDREN);
  }
}

//
//
// Function:    SetMenuState
//
// Purpose:     Sets menu contents to their correct enabled/disabled state
//
//
void WbMainWindow::SetMenuStates(HMENU hInitMenu)
{
    BOOL  bLocked;
    BOOL  bPageOrderLocked;
    BOOL  bPresentationMode;
    UINT  uiEnable;
    UINT  uiCountPages;
    BOOL  bIdle;
    BOOL  bSelected;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetMenuStates");

    //
    // Check menu exists
    //
    if (hInitMenu == NULL)
    {
        WARNING_OUT(("Menu doesn't exist"));
        return;
    }

    HMENU hMainMenu = ::GetMenu(m_hwnd);

    // Get the window's main menu and check that the menu
    // now being popped up is one on the top-level. (We do not
    // seem to be able to associate the index number passed with
    // sub-menus easily.)
    if ((hInitMenu != m_hContextMenu) && (hInitMenu != m_hGrobjContextMenu))
    {
        BOOL bTopLevel = FALSE;

        int nCount = ::GetMenuItemCount(hMainMenu);

        for (int nNext = 0; nNext < nCount; nNext++)
        {
            HMENU hNextMenu = ::GetSubMenu(hMainMenu, nNext);
            if (hNextMenu != NULL)
            {
                if (hNextMenu == hInitMenu)
                {
                    bTopLevel = TRUE;
                    break;
                }
            }
        }

        // not a top level, so leave the function now
        if (!bTopLevel)
        {
            TRACE_DEBUG(("Not top-level menu"));
            return;
        }
    }

	BOOL bImNotLocked = (g_pCurrentWorkspace ? (g_pCurrentWorkspace->GetUpdatesEnabled() ? TRUE : g_pNMWBOBJ->m_LockerID == g_MyMemberID) :FALSE);
	BOOL bIsThereAnything = IsThereAnythingInAnyWorkspace();
	BOOL bIsThereSomethig = bImNotLocked && (g_pCurrentWorkspace && g_pCurrentWorkspace->GetHead() != NULL) ? TRUE : FALSE;
	BOOL bIsThereTrash = bImNotLocked && (g_pTrash->GetHead() != NULL) && (g_pCurrentWorkspace != NULL);
	BOOL bIsSomethingSelected = bImNotLocked && g_pDraw->GraphicSelected() && g_pDraw->GetSelectedGraphic()->GraphicTool() != TOOLTYPE_REMOTEPOINTER && g_pCurrentWorkspace != NULL;
	BOOL bIsSynced = g_pDraw->IsSynced();
	BOOL bOnlyOnePage = (g_pListOfWorkspaces->GetHead() == g_pListOfWorkspaces->GetTail());

    //
    // Functions which are disabled when contents is locked
    //
    uiEnable = MF_BYCOMMAND | (bImNotLocked && bIsSynced ? MF_ENABLED : MF_GRAYED);

	//
	// File menu
	//
    ::EnableMenuItem(hInitMenu, IDM_NEW,     uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_OPEN,    uiEnable);

    uiEnable = MF_BYCOMMAND | (bIsThereAnything ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_SAVE,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SAVE_AS, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PRINT,   uiEnable);

	//
	// Tools menu
	//
    uiEnable = MF_BYCOMMAND | (bImNotLocked ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_SELECT,    uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ERASER, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_PEN, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_HIGHLIGHT, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_AREA, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_GRAB_WINDOW, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_LINE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_BOX, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ELLIPSE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_FILLED_ELLIPSE, uiEnable);
	::EnableMenuItem(hInitMenu, IDM_TEXT, m_drawingArea.Zoomed() ? MF_BYCOMMAND | MF_GRAYED : uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_ZOOM, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_REMOTE, uiEnable);

	::EnableMenuItem(hInitMenu, IDM_FONT, MF_BYCOMMAND | bImNotLocked && m_pCurrentTool->HasFont() ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_EDITCOLOR, MF_BYCOMMAND | bImNotLocked && m_pCurrentTool->HasColor() ? MF_ENABLED : MF_GRAYED);

    HMENU hToolsMenu = ::GetSubMenu(hMainMenu, MENUPOS_TOOLS);
    uiEnable = (bImNotLocked && m_pCurrentTool->HasWidth()) ? MF_ENABLED : MF_GRAYED;

    if (hToolsMenu == hInitMenu )
    {
        ::EnableMenuItem(hToolsMenu, TOOLSPOS_WIDTH, MF_BYPOSITION | uiEnable );
    }


	UINT i;
	UINT uIdmCurWidth = 0;
    if( uiEnable == MF_ENABLED )
        uIdmCurWidth = m_pCurrentTool->GetWidthIndex() + IDM_WIDTH_1;

    for( i=IDM_WIDTH_1; i<=IDM_WIDTH_4; i++ )
    {
        ::EnableMenuItem(hInitMenu,  i, uiEnable );

        if( uiEnable == MF_ENABLED )
        {
            if( uIdmCurWidth == i )
                ::CheckMenuItem(hInitMenu, i, MF_CHECKED );
            else
                ::CheckMenuItem(hInitMenu, i, MF_UNCHECKED );
        }
    }


	//
	// Edit Menu
	//
    uiEnable = MF_BYCOMMAND | (bIsSomethingSelected? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_DELETE, uiEnable );
    ::EnableMenuItem(hInitMenu, IDM_CUT, uiEnable );
    ::EnableMenuItem(hInitMenu, IDM_COPY, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_BRING_TO_TOP, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SEND_TO_BACK, uiEnable);

    uiEnable = MF_BYCOMMAND | (bIsThereSomethig ?MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_CLEAR_PAGE, uiEnable);
    ::EnableMenuItem(hInitMenu, IDM_SELECTALL, uiEnable);

    ::EnableMenuItem(hInitMenu, IDM_PASTE, MF_BYCOMMAND | CLP_AcceptableClipboardFormat() && bImNotLocked ?  MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_UNDELETE, MF_BYCOMMAND | (bIsThereTrash? MF_ENABLED : MF_GRAYED) );

    ::EnableMenuItem(hInitMenu, IDM_DELETE_PAGE, MF_BYCOMMAND | bIsSynced && bImNotLocked && !bOnlyOnePage ? MF_ENABLED : MF_GRAYED);
    ::EnableMenuItem(hInitMenu, IDM_PAGE_INSERT_AFTER, MF_BYCOMMAND | bIsSynced && bImNotLocked && g_numberOfWorkspaces < WB_MAX_WORKSPACES ? MF_ENABLED : MF_GRAYED);

	//
	// View Menu
	//
    ::EnableMenuItem(hInitMenu, IDM_SYNC, MF_BYCOMMAND | (bImNotLocked && !m_drawingArea.IsLocked()? MF_ENABLED : MF_GRAYED));
    ::EnableMenuItem(hInitMenu, IDM_LOCK, MF_BYCOMMAND |((bImNotLocked && bIsSynced) ? MF_ENABLED : MF_GRAYED));


	//
    // Enable toolbar
	//
    EnableToolbar(bImNotLocked);

	//
    // Enable page controls
	//
    m_AG.EnablePageCtrls(bImNotLocked);
}


//
//
// Function:    WbMainWindow destructor
//
// Purpose:     Tidy up main window on destruction.
//
//
WbMainWindow::~WbMainWindow()
{
    //
    // Destroy the tooltip window
    //
    if (m_hwndToolTip)
    {
        ::DestroyWindow(m_hwndToolTip);
        m_hwndToolTip = NULL;
    }


    if (m_hGrobjContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hGrobjContextMenuBar);
        m_hGrobjContextMenuBar = NULL;
    }
    m_hGrobjContextMenu = NULL;

    if (m_hContextMenuBar != NULL)
    {
        ::DestroyMenu(m_hContextMenuBar);
        m_hContextMenuBar = NULL;
    }
    m_hContextMenu = NULL;

	POSITION position = m_pageToPosition.GetHeadPosition();

	PAGE_POSITION * pPoint;

	while (position)
	{
		pPoint = (PAGE_POSITION*)m_pageToPosition.GetNext(position);
		delete pPoint;
	}

	m_pageToPosition.EmptyList();

    //
    // Free the palette
    //
    if (g_hRainbowPaletteDisplay)
    {
        if (g_pDraw && g_pDraw->m_hDCCached)
        {
            // Select out the rainbow palette so we can delete it
            ::SelectPalette(g_pDraw->m_hDCCached, (HPALETTE)::GetStockObject(DEFAULT_PALETTE), TRUE);
        }

        DeletePalette(g_hRainbowPaletteDisplay);
        g_hRainbowPaletteDisplay = NULL;
    }

    g_bPalettesInitialized = FALSE;
    g_bUsePalettes = FALSE;

    if (g_pIcons)
    {
        delete g_pIcons;
        g_pIcons = NULL;
    }

	if(m_pTitleFileName)
	{
		delete m_pTitleFileName;
        m_pTitleFileName = NULL;
	}

	//
	// Delete all the objectsb in global lists
	//
	DeleteAllWorkspaces(FALSE);
    ASSERT(g_pListOfWorkspaces);
  	g_pListOfWorkspaces->EmptyList();

    ASSERT(g_pListOfObjectsThatRequestedHandles);
   	g_pListOfObjectsThatRequestedHandles->EmptyList();

	g_numberOfWorkspaces = 0;

    //
    // Delete objects in limbo, sitting in the undelete trash
    //
    ASSERT(g_pTrash);

    T126Obj* pGraphic;

	//
    // Burn trash
	//
    pGraphic = (T126Obj *)g_pTrash->RemoveTail();
	while (pGraphic != NULL)
    {
	   	delete pGraphic;
	    pGraphic = (T126Obj *) g_pTrash->RemoveTail();
    }

	DeleteAllRetryPDUS();

	DestroyToolArray();

	::DestroyWindow(m_hwnd);
	::UnregisterClass(szMainClassName, g_hInstance);


}

//
// OnToolHitTest()
// This handles tooltips for child windows.
//
int WbMainWindow::OnToolHitTest(POINT pt, TOOLINFO* pTI) const
{
    HWND    hwnd;
    int     status;
    int     nHit = -1;

    ASSERT(!IsBadWritePtr(pTI, sizeof(TOOLINFO)));

    hwnd = ::ChildWindowFromPointEx(m_hwnd, pt, CWP_SKIPINVISIBLE);
    if (hwnd == m_AG.m_hwnd)
    {
        ::MapWindowPoints(m_hwnd, m_AG.m_hwnd, &pt, 1);
        hwnd = ::ChildWindowFromPointEx(m_AG.m_hwnd, pt, CWP_SKIPINVISIBLE);

        if (hwnd != NULL)
        {
            nHit = ::GetDlgCtrlID(hwnd);

            pTI->hwnd = m_hwnd;
            pTI->uId = (UINT_PTR)hwnd;
            pTI->uFlags |= TTF_IDISHWND;
            pTI->lpszText = LPSTR_TEXTCALLBACK;

            return(nHit);
        }
    }
    else if (hwnd == m_WG.m_hwnd)
    {
        int iItem;

        ::MapWindowPoints(m_hwnd, m_WG.m_hwnd, &pt, 1);

        iItem = m_WG.ItemFromPoint(pt.x, pt.y);

        pTI->hwnd = m_WG.m_hwnd;
        pTI->uId  = iItem;

        // Since the area isn't a window, we must fill in the rect ourself
        m_WG.GetItemRect(iItem, &pTI->rect);
        pTI->lpszText = LPSTR_TEXTCALLBACK;

        return(iItem);
    }
    else if (hwnd == m_TB.m_hwnd)
    {
        RECT        rect;
        TBBUTTON    button;
        int         i;

        for (i = 0; i < TOOLBAR_MAXBUTTON; i++)
        {
            if (::SendMessage(m_TB.m_hwnd, TB_GETITEMRECT, i, (LPARAM)&rect) &&
                ::PtInRect(&rect, pt) &&
                ::SendMessage(m_TB.m_hwnd, TB_GETBUTTON, i, (LPARAM)&button) &&
                !(button.fsStyle & TBSTYLE_SEP))
            {
                nHit = button.idCommand;

                pTI->hwnd = m_TB.m_hwnd;
                pTI->uId = nHit;
                pTI->rect = rect;
                pTI->lpszText = LPSTR_TEXTCALLBACK;

                // found matching rect, return the ID of the button
                return(nHit);
            }
        }
    }

    return(-1);
}


//
// WinHelp() wrapper
//
LRESULT WbMainWindow::ShowHelp(void)
{
    HWND hwndCapture;

    // Get the main window out of any mode
    ::SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);

    // Cancel any other tracking
    if (hwndCapture = ::GetCapture())
        ::SendMessage(hwndCapture, WM_CANCELMODE, 0, 0);

	// finally, run the NetMeeting Help engine
    ShowNmHelp(s_cszHtmlHelpFile);

    return S_OK;
}


//
// TimedDlgProc()
// This puts up a visible or invisible dialog which only goes away when
// an event occurs or a certain amount of time has passed.  We store the
// DialogBoxParam parameter, a TMDLG pointer, in our user data.  That is
// from the stack of the DialogBoxParam() caller, so it is valid until that
// function returns, which won't be until a bit after the dialog has been
// destroyed.
//
INT_PTR CALLBACK TimedDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL        fHandled = FALSE;
    TMDLG *     ptm;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            ptm = (TMDLG *)lParam;
            ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)ptm);

            //
            // Set the WbMainWindow hwnd
            //
            if (ptm->bLockNotEvent)
            {
                g_pMain->m_hwndWaitForLockDlg = hwnd;
            }
            else
            {
                g_pMain->m_hwndWaitForEventDlg = hwnd;
            }

            //
            // Set max timer
            //
            ::SetTimer(hwnd, TIMERID_MAXDISPLAY, ptm->uiMaxDisplay, NULL);

            //
            // Change the cursor if invisible
            //
            if (!ptm->bVisible)
                ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

            fHandled = TRUE;
            break;

        case WM_TIMER:
            ASSERT(wParam == TIMERID_MAXDISPLAY);

            // End the dialog--since we timed out, it acts like cancel
            ::SendMessage(hwnd, WM_COMMAND, MAKELONG(IDCANCEL, BN_CLICKED), 0);

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        ptm = (TMDLG *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);
                        ASSERT(!IsBadWritePtr(ptm, sizeof(TMDLG)));

                        // Clear out the HWND variable
                        if (ptm->bLockNotEvent)
                        {
                            g_pMain->m_hwndWaitForLockDlg = NULL;
                        }
                        else
                        {
                            g_pMain->m_hwndWaitForEventDlg = NULL;
                        }

                        // Restore the cursor
                        if (!ptm->bVisible)
                            ::SetCursor(::LoadCursor(NULL, IDC_ARROW));

                        ::KillTimer(hwnd, TIMERID_MAXDISPLAY);

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                    }
                    break;
            }

            fHandled = TRUE;
            break;

        //
        // Don't let these dialogs be killed by any other means than our
        // getting an event or timing out.
        //
        case WM_CLOSE:
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
// FilterMessage()
//
// This does tooltip message filtering, then translates accelerators.
//
BOOL WbMainWindow::FilterMessage(MSG* pMsg)
{
    BOOL   bResult = FALSE;

   	if ((pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST) ||
    	(pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONDBLCLK) ||
	    (pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONDBLCLK) ||
	    (pMsg->message == WM_MBUTTONDOWN || pMsg->message == WM_MBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCLBUTTONDOWN || pMsg->message == WM_NCLBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCRBUTTONDOWN || pMsg->message == WM_NCRBUTTONDBLCLK) ||
	    (pMsg->message == WM_NCMBUTTONDOWN || pMsg->message == WM_NCMBUTTONDBLCLK))
   	{
        // Cancel any tooltip up
        ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, FALSE, 0);
   	}

	// handle tooltip messages (some messages cancel, some may cause it to popup)
	if ((pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_NCMOUSEMOVE ||
		 pMsg->message == WM_LBUTTONUP || pMsg->message == WM_RBUTTONUP ||
		 pMsg->message == WM_MBUTTONUP) &&
		(GetKeyState(VK_LBUTTON) >= 0 && GetKeyState(VK_RBUTTON) >= 0 &&
		 GetKeyState(VK_MBUTTON) >= 0))
	{
#if 0
        //
        // If this mouse move isn't for a descendant of the main window, skip
        // it.  For example, when the tooltip is shown, it gets a mousemove
        // to itself, which if we didn't check for it, would cause us to
        // immediately dismiss this!
        //
        HWND    hwndTmp = pMsg->hwnd;

        while (hwndTmp && (::GetWindowLong(hwndTmp, GWL_STYLE) & WS_CHILD))
        {
            hwndTmp = ::GetParent(hwndTmp);
        }

        if (hwndTmp != m_hwnd)
        {
            // This is not for us, it's for another top level window in
            // our app.
            goto DoneToolTipFiltering;
        }
#endif

		// determine which tool was hit
        POINT   pt;

        pt = pMsg->pt;
		::ScreenToClient(m_hwnd, &pt);

		TOOLINFO tiHit;

        ZeroMemory(&tiHit, sizeof(tiHit));
		tiHit.cbSize = sizeof(TOOLINFO);

		int nHit = OnToolHitTest(pt, &tiHit);

		if (m_nLastHit != nHit)
		{
			if (nHit != -1)
			{
				// add new tool and activate the tip
                if (!::SendMessage(m_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)&tiHit))
                {
                    ERROR_OUT(("TTM_ADDTOOL failed"));
                }

				if (::GetActiveWindow() == m_hwnd)
				{
					// allow the tooltip to popup when it should
                    ::SendMessage(m_hwndToolTip, TTM_ACTIVATE, TRUE, 0);

					// bring the tooltip window above other popup windows
					::SetWindowPos(m_hwndToolTip, HWND_TOP, 0, 0, 0, 0,
						SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOMOVE);
				}
			}

			// relay mouse event before deleting old tool
            ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);

			// now safe to delete the old tool
            if (m_tiLastHit.cbSize != 0)
                ::SendMessage(m_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&m_tiLastHit);

            m_nLastHit = nHit;
            m_tiLastHit = tiHit;
		}
		else
		{
			// relay mouse events through the tooltip
			if (nHit != -1)
                ::SendMessage(m_hwndToolTip, TTM_RELAYEVENT, 0, (LPARAM)pMsg);
		}
	}

#if 0
DoneToolTipFiltering:
#endif
    // Assume we will use the main accelerator table
    HACCEL hAccelTable = m_hAccelTable;

    // If this window has focus, just continue
    HWND hwndFocus = ::GetFocus();
    if (hwndFocus && (hwndFocus != m_hwnd))
    {
        // Check whether an edit field in the pages group has the focus
        if (m_AG.IsChildEditField(hwndFocus))
        {
            hAccelTable = m_hAccelPagesGroup;
        }
        // Check whether text editor has the focus and is active
        else if (   (hwndFocus == m_drawingArea.m_hwnd)
                 && (m_drawingArea.TextEditActive()))
        {
            // Let editbox do its own acceleration.
            hAccelTable = NULL;
        }
    }

    return (   (hAccelTable != NULL)
          && ::TranslateAccelerator(m_hwnd, hAccelTable, pMsg));
}

//
//
// Function:    OnDisplayError
//
// Purpose:     Display an error message
//
//
void WbMainWindow::OnDisplayError(WPARAM uiFEReturnCode, LPARAM uiDCGReturnCode)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDisplayError");

    // Only continue if we are not currently displaying an error
    if (!m_bDisplayingError)
    {
        // Show that we are currently displaying an error message
        m_bDisplayingError = TRUE;

        // Display the error
        ::ErrorMessage((UINT)uiFEReturnCode, (UINT)uiDCGReturnCode);

        // Show that we are no longer displaying an error
        m_bDisplayingError = FALSE;
    }
}


//
//
// Function:    OnPaletteChanged
//
// Purpose:     The palette has changed.
//
//
void WbMainWindow::OnPaletteChanged(HWND hwndPalette)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaletteChanged");

    if ((hwndPalette != m_hwnd) &&
        (hwndPalette != m_drawingArea.m_hwnd))
    {
        // Tell the drawing area to realize its palette
        m_drawingArea.RealizePalette( TRUE );
    }
}



//
//
// Function:    OnQueryNewPalette
//
// Purpose:     We are getting focus and must realize our palette
//
//
LRESULT WbMainWindow::OnQueryNewPalette(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnQueryNewPalette");

    // Tell the drawing area to realize its palette
    m_drawingArea.RealizePalette( FALSE );

    return TRUE;
}

//
//
// Function:    PopupContextMenu
//
// Purpose:     Popup the context menu for the drawing area. This is called
//              by the drawing area window on a right mouse click.
//
//
void WbMainWindow::PopupContextMenu(int x, int y)
{
    POINT   surfacePos;
    RECT    clientRect;
    T126Obj * pGraphic;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::PopupContextMenu");

    surfacePos.x = x;
    surfacePos.y = y;

    m_drawingArea.ClientToSurface(&surfacePos);
    if( (pGraphic = m_drawingArea.GetHitObject( surfacePos )) != NULL
		&& pGraphic->GraphicTool() != TOOLTYPE_REMOTEPOINTER )
    {
		if(!pGraphic->IsSelected() )
		{
			g_pDraw->SelectGraphic(pGraphic);
		}

        // selector tool is active, and one or more objects are selected
        m_hInitMenu = m_hGrobjContextMenu;

	}
    else
    {
		// no current selection, show drawing menu
		m_hInitMenu = m_hContextMenu;
	}


    // set up current menu state
    SetMenuStates(m_hInitMenu);

    // pop it up
    ::GetClientRect(m_drawingArea.m_hwnd, &clientRect);
    ::MapWindowPoints(m_drawingArea.m_hwnd, NULL, (LPPOINT)&clientRect.left, 2);

    ::TrackPopupMenu(m_hInitMenu, TPM_RIGHTALIGN | TPM_RIGHTBUTTON,
                                 x + clientRect.left,
                                 y + clientRect.top,
                                 0,
                                 m_hwnd,
                                 NULL);

    // reset m_hInitMenu to indicate the popup menu isn't being shown anymore
    m_hInitMenu = NULL;

}




//
//
// Function:    OnSize
//
// Purpose:     The window has been resized.
//
//
void WbMainWindow::OnSize(UINT nType, int cx, int cy )
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSize");

    // Only process this message if the window is not minimized
    if (nType != SIZE_MINIMIZED)
    {

	    // The user's view has changed
	    PositionUpdated();

		if (m_bStatusBarOn)
		{
			::ShowWindow(m_hwndSB, SW_HIDE);
		}
	
		// Resize the subpanes of the window
		ResizePanes();

		// Show it again
		if (m_bStatusBarOn)
		{
			::ShowWindow(m_hwndSB, SW_SHOW);
		}

	    // If the status has changed, set the option
	    if (m_uiWindowSize != nType)
	    {
	        m_uiWindowSize = nType;

	        // Write the new option values to file
	        OPT_SetBooleanOption(OPT_MAIN_MAXIMIZED,
	                             (m_uiWindowSize == SIZE_MAXIMIZED));
	        OPT_SetBooleanOption(OPT_MAIN_MINIMIZED,
	                             (m_uiWindowSize == SIZE_MINIMIZED));
    	}
	}
}

//
//
// Function:    SaveWindowPosition
//
// Purpose:     Save the current window position to the options file.
//
//
void WbMainWindow::SaveWindowPosition(void)
{
    RECT    rectWindow;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SaveWindowPosition");

    // Get the new window rectangle
    ::GetWindowRect(m_hwnd, &rectWindow);

    // Write the new option values to file
    OPT_SetWindowRectOption(&rectWindow);
}


//
//
// Function:    ResizePanes
//
// Purpose:     Resize the subpanes of the main window.
//
//
void WbMainWindow::ResizePanes(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ResizePanes");

    //
    //
    // The client area is organized as follows:
    //
    //  -------------------------------------
    //  |   |                               |
    //  | T |                               |
    //  | o |   Drawing Area                |
    //  | o |                               |
    //  | l |                               |
    //  | s |                               |
    //  |---|                               |
    //  | W |                               |
    //  | i |                               |
    //  | d |                               |
    //  | t |                               |
    //  | h |                               |
    //  | s |                               |
    //  |-----------------------------------|
    //  | Attributes (colors)   | Pages     |
    //  |-----------------------------------|
    //  |       Status                      |
    //  -------------------------------------
    //
    //

    RECT clientRect;
    RECT rectStatusBar;
    RECT rectToolBar;
    RECT rectWG;
    RECT rectAG;
    RECT rectDraw;
    SIZE size;
    SIZE sizeAG;

    // Get the client rectangle
    ::GetClientRect(m_hwnd, &clientRect);
    rectStatusBar = clientRect;

    // Resize the help bar and progress meter
    if (m_bStatusBarOn)
    {
        rectStatusBar.top = rectStatusBar.bottom - STATUSBAR_HEIGHT;

        ::MoveWindow(m_hwndSB, rectStatusBar.left, rectStatusBar.top,
            rectStatusBar.right - rectStatusBar.left,
            rectStatusBar.bottom - rectStatusBar.top, TRUE);
    }
    else
    {
        // Status bar is off - set it's height to zero
        rectStatusBar.top = rectStatusBar.bottom;
    }

    // Resize the tool and width windows
    m_TB.GetNaturalSize(&size);
    rectToolBar.left  = 0;
    rectToolBar.right = rectToolBar.left + size.cx;
    rectToolBar.top =  0;
    rectToolBar.bottom = rectToolBar.top + size.cy;

    m_WG.GetNaturalSize(&size);
    rectWG.left = rectToolBar.left;
    rectWG.top = rectToolBar.bottom;
    rectWG.bottom = rectWG.top + size.cy;

    if (!m_bToolBarOn)
    {
        // Toolbar is either off or floating - set its width to zero
        rectToolBar.right = rectToolBar.left;
    }
    rectWG.right = rectToolBar.right;

    // Position attribute group
    m_AG.GetNaturalSize(&sizeAG);

    ::MoveWindow(m_AG.m_hwnd, rectToolBar.left, rectStatusBar.top - sizeAG.cy,
        clientRect.right - rectToolBar.left, sizeAG.cy, TRUE);

    // finish fiddling with tools and widths bars
    if (m_bToolBarOn)
    {
        //
        // We make the toolbar, which includes the width bar, extend all
        // down the left side.
        //
        rectToolBar.bottom = rectStatusBar.top - sizeAG.cy;
        rectWG.left += TOOLBAR_MARGINX;
        rectWG.right -= 2*TOOLBAR_MARGINX;

        ::MoveWindow(m_TB.m_hwnd, rectToolBar.left,
            rectToolBar.top, rectToolBar.right - rectToolBar.left,
            rectToolBar.bottom - rectToolBar.top, TRUE);

        ::MoveWindow(m_WG.m_hwnd, rectWG.left, rectWG.top,
            rectWG.right - rectWG.left, rectWG.bottom - rectWG.top, TRUE);

        ::BringWindowToTop(m_WG.m_hwnd);
    }

    // Resize the drawing pane
    rectDraw = clientRect;
    rectDraw.bottom = rectStatusBar.top - sizeAG.cy;
    rectDraw.left   = rectToolBar.right;
    ::MoveWindow(m_drawingArea.m_hwnd, rectDraw.left, rectDraw.top,
        rectDraw.right - rectDraw.left, rectDraw.bottom - rectDraw.top, TRUE);

    // Check to see if Width group is overlapping Attributes group. This can happen if
    // the menu bar has wrapped because the window isn't wide enough (bug 424)
    RECT crWidthWnd;
    RECT crAttrWnd;

    ::GetWindowRect(m_WG.m_hwnd, &crWidthWnd);
    ::GetWindowRect(m_AG.m_hwnd, &crAttrWnd);

    if (crAttrWnd.top < crWidthWnd.bottom)
    {
        // the menu bar has wrapped and our height placements are wrong. Adjust window
        // by difference and try again
        RECT crMainWnd;

        ::GetWindowRect(m_hwnd, &crMainWnd);
        crMainWnd.bottom += (crWidthWnd.bottom - crAttrWnd.top + ::GetSystemMetrics(SM_CYFIXEDFRAME));

        ::MoveWindow(m_hwnd, crMainWnd.left, crMainWnd.top,
            crMainWnd.right - crMainWnd.left, crMainWnd.bottom - crMainWnd.top,
            FALSE);

        // this is going to recurse but the adjustment will happen only once.....
    }
}


//
//
// Function:    WbMainWindow::OnGetMinMaxInfo
//
// Purpose:     Set the minimum and maximum tracking sizes of the window
//
//
void WbMainWindow::OnGetMinMaxInfo(LPMINMAXINFO lpmmi)
{
    if (m_TB.m_hwnd == NULL)
        return; // not ready to do this yet

    SIZE    csFrame;
    SIZE    csSeparator;
    SIZE    csAG;
    SIZE    csToolBar;
    SIZE    csWidthBar;
    SIZE    csMaxSize;
    SIZE    csScrollBars;

    csFrame.cx = ::GetSystemMetrics(SM_CXSIZEFRAME);
    csFrame.cy = ::GetSystemMetrics(SM_CYSIZEFRAME);

    csSeparator.cx = ::GetSystemMetrics(SM_CXEDGE);
    csSeparator.cy = ::GetSystemMetrics(SM_CYEDGE);

    csScrollBars.cx = ::GetSystemMetrics(SM_CXVSCROLL);
    csScrollBars.cy = ::GetSystemMetrics(SM_CYHSCROLL);

    m_AG.GetNaturalSize(&csAG);

    m_TB.GetNaturalSize(&csToolBar);
    m_WG.GetNaturalSize(&csWidthBar);


    // Set the minimum width and height of the window
    lpmmi->ptMinTrackSize.x =
      csFrame.cx + csAG.cx + csFrame.cx;

    lpmmi->ptMinTrackSize.y =
      csFrame.cy +
      GetSystemMetrics( SM_CYCAPTION ) +
      GetSystemMetrics( SM_CYMENU ) +
      csToolBar.cy +
      csWidthBar.cy +
      csSeparator.cy +
      csAG.cy +
      csSeparator.cy +
      csFrame.cy +
      STATUSBAR_HEIGHT;

    //
    // Retrieves the size of the work area on the primary display monitor. The work
    // area is the portion of the screen not obscured by the system taskbar or by
    // application desktop toolbars
    //
    RECT rcWorkArea;
    ::SystemParametersInfo( SPI_GETWORKAREA, 0, (&rcWorkArea), NULL );
    csMaxSize.cx = rcWorkArea.right - rcWorkArea.left;
    csMaxSize.cy = rcWorkArea.bottom - rcWorkArea.top;

    lpmmi->ptMaxPosition.x  = 0;
    lpmmi->ptMaxPosition.y  = 0;
    lpmmi->ptMaxSize.x      = csMaxSize.cx;
    lpmmi->ptMaxSize.y      = csMaxSize.cy;
    lpmmi->ptMaxTrackSize.x = csMaxSize.cx;
    lpmmi->ptMaxTrackSize.y = csMaxSize.cy;
}


//
//
// Function:    WbMainWindow::CreateContextMenus
//
// Purpose:     Create the pop-up context menus: used within the application
//              drawing area.
//
//
BOOL WbMainWindow::CreateContextMenus(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CreateContextMenus");

    m_hContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(CONTEXTMENU));
    if (!m_hContextMenuBar)
    {
        ERROR_OUT(("Failed to create context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hContextMenu = ::GetSubMenu(m_hContextMenuBar, 0);

    m_hGrobjContextMenuBar = ::LoadMenu(g_hInstance, MAKEINTRESOURCE(GROBJMENU));
    if (!m_hGrobjContextMenuBar)
    {
        ERROR_OUT(("Failed to create grobj context menu"));
        DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
        return FALSE;
    }
    m_hGrobjContextMenu = ::GetSubMenu(m_hGrobjContextMenuBar, 0);

    // make parts of m_hGrobjContextMenu be owner draw
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_1, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_1, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_2, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_2, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_3, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_3, NULL);
    ::ModifyMenu(m_hGrobjContextMenu, IDM_WIDTH_4, MF_ENABLED | MF_OWNERDRAW,
                                 IDM_WIDTH_4, NULL);

    return TRUE;
}




//
//
// Function:    WbMainWindow::OnMeasureItem
//
// Purpose:     Return the size of an item in the widths menu
//
//
void WbMainWindow::OnMeasureItem
(
    int                 nIDCtl,
    LPMEASUREITEMSTRUCT measureStruct
)
{
    // Check that this is for a color menu item
    if (    (measureStruct->itemID >= IDM_WIDTHS_START)
         && (measureStruct->itemID < IDM_WIDTHS_END))
    {
        measureStruct->itemWidth  = ::GetSystemMetrics(SM_CXMENUCHECK) +
            (2 * CHECKMARK_BORDER_X) + COLOR_MENU_WIDTH;
        measureStruct->itemHeight = ::GetSystemMetrics(SM_CYMENUCHECK) +
            (2 * CHECKMARK_BORDER_Y);
    }
}

//
//
// Function:    WbMainWindow::OnDrawItem
//
// Purpose:     Draw an item in the color menu
//
//
void WbMainWindow::OnDrawItem
(
    int     nIDCtl,
    LPDRAWITEMSTRUCT drawStruct
)
{
    COLORREF crMenuBackground;
    COLORREF crMenuText;
    HPEN     hOldPen;
    HBRUSH      hOldBrush;
    COLORREF crOldBkgnd;
    COLORREF crOldText;
    int         nOldBkMode;
    HBITMAP hbmp = NULL;
    BITMAP  bitmap;
    UINT    uiCheckWidth;
    UINT    uiCheckHeight;
    RECT    rect;
    RECT    rectCheck;
    RECT    rectLine;
    HDC     hMemDC;
    UINT    uiWidthIndex;
    UINT    uiWidth;
    HPEN    hPenMenu;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDrawItem");

    // Check that this is a width menu item
    if( (drawStruct->itemID < IDM_WIDTHS_START) ||
        (drawStruct->itemID >= IDM_WIDTHS_END) )
    {
        return;
    }

    // get menu item colors
    if( (drawStruct->itemState & ODS_SELECTED) ||
        ((drawStruct->itemState & (ODS_SELECTED |ODS_CHECKED)) ==
            (ODS_SELECTED |ODS_CHECKED))
        )
    {
        crMenuBackground = COLOR_HIGHLIGHT;
        crMenuText = COLOR_HIGHLIGHTTEXT;
    }
    else if( drawStruct->itemState & ODS_GRAYED)
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_GRAYTEXT;
    }
    else
    {
        crMenuBackground = COLOR_MENU;
        crMenuText = COLOR_MENUTEXT;
    }

    hPenMenu = ::CreatePen(PS_SOLID, 0, ::GetSysColor(crMenuBackground));
    if (!hPenMenu)
    {
        TRACE_MSG(("Failed to create penMenu"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    rect = drawStruct->rcItem;

    // Fill the whole box with current menu background color
    hOldPen     = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush   = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuBackground));

    ::Rectangle(drawStruct->hDC, rect.left, rect.top, rect.right, rect.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    if( (hbmp = (HBITMAP)LoadImage( NULL, MAKEINTRESOURCE( OBM_CHECK ), IMAGE_BITMAP,
                0,0, 0 ))
        == NULL )
    {
        TRACE_MSG(("Failed to create check image"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    // Get the width and height of the bitmap (allowing some border)
    ::GetObject(hbmp, sizeof(BITMAP), &bitmap);
    uiCheckWidth  = bitmap.bmWidth  + (2 * CHECKMARK_BORDER_X);
    uiCheckHeight = bitmap.bmHeight;

    // Draw in a checkmark (if needed)
    if (drawStruct->itemState & ODS_CHECKED)
    {
        hMemDC = ::CreateCompatibleDC(drawStruct->hDC);
        if (!hMemDC)
        {
            ERROR_OUT(("Failed to create memDC"));
            ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
            goto bail_out;
        }

        crOldBkgnd = ::SetBkColor(drawStruct->hDC, GetSysColor( crMenuBackground ) );
        crOldText = ::SetTextColor(drawStruct->hDC, GetSysColor( crMenuText ) );
        nOldBkMode = ::SetBkMode(drawStruct->hDC, OPAQUE );

        HBITMAP hOld = SelectBitmap(hMemDC, hbmp);

        if (hOld != NULL)
        {
            rectCheck = rect;
            rectCheck.top += ((rectCheck.bottom - rectCheck.top)/2 - uiCheckHeight/2);
            rectCheck.right  = rectCheck.left + uiCheckWidth;
            rectCheck.bottom = rectCheck.top + uiCheckHeight;

            ::BitBlt(drawStruct->hDC, rectCheck.left,
                        rectCheck.top,
                        rectCheck.right - rectCheck.left,
                        rectCheck.bottom - rectCheck.top,
                        hMemDC,
                        0,
                        0,
                        SRCCOPY);

            SelectBitmap(hMemDC, hOld);
        }

        ::SetBkMode(drawStruct->hDC, nOldBkMode);
        ::SetTextColor(drawStruct->hDC, crOldText);
        ::SetBkColor(drawStruct->hDC, crOldBkgnd);

        ::DeleteDC(hMemDC);
    }

    DeleteBitmap(hbmp);

    // Allow room for the checkmark to the left of the color
    rect.left += uiCheckWidth;

    uiWidthIndex = drawStruct->itemID - IDM_WIDTHS_START;
    uiWidth = g_PenWidths[uiWidthIndex];

    // If pens are very wide they can be larger than the allowed rectangle.
    // So we reduce the clipping rectangle here. We save the DC so that we
    // can restore it - getting the clip region back.
    if (::SaveDC(drawStruct->hDC) == 0)
    {
        ERROR_OUT(("Failed to save DC"));
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    if (::IntersectClipRect(drawStruct->hDC, rect.left, rect.top,
        rect.right, rect.bottom) == ERROR)
    {
        ERROR_OUT(("Failed to set clip rect"));

        ::RestoreDC(drawStruct->hDC, -1);
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WINDOWS, 0);
        goto bail_out;
    }

    hOldPen   = SelectPen(drawStruct->hDC, hPenMenu);
    hOldBrush = SelectBrush(drawStruct->hDC, GetSysColorBrush(crMenuText));

    rectLine.left = rect.left;
    rectLine.top    = rect.top + ((rect.bottom - rect.top) / 2) - uiWidth/2;
    rectLine.right= rect.right - ((rect.right - rect.left) / 6);
    rectLine.bottom = rectLine.top + uiWidth + 2;

    ::Rectangle(drawStruct->hDC, rectLine.left, rectLine.top,
        rectLine.right, rectLine.bottom);

    SelectBrush(drawStruct->hDC, hOldBrush);
    SelectPen(drawStruct->hDC, hOldPen);

    ::RestoreDC(drawStruct->hDC, -1);

bail_out:
    if (hPenMenu != NULL)
    {
        ::DeletePen(hPenMenu);
    }
}



//
//
// Function:    OnSetFocus
//
// Purpose:     The window is getting the focus
//
//
void WbMainWindow::OnSetFocus(void)
{
    // We pass the focus on to the main drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
}


//
//
// Function:    OnParentNotfiy
//
// Purpose:     Process a message coming from a child window
//
//
void WbMainWindow::OnParentNotify(UINT uiMessage)
{
    switch (uiMessage)
    {
        // Scroll message from the drawing area. These are sent when the user
        // scrolls the area using the scroll bars. We queue an update of the
        // current sync position.
        case WM_HSCROLL:
        case WM_VSCROLL:
            // The user's view has changed
            PositionUpdated();
            break;
    }
}


//
//
// Function:    QuerySaveRequired
//
// Purpose:     Check whether the drawing pane contents are to be saved
//              before a destructive function is performed.
//
//
int WbMainWindow::QuerySaveRequired(BOOL bCancelBtn)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::QuerySaveRequired");

    // If we are not maximized
    if (!::IsZoomed(m_hwnd) && !::IsIconic(m_hwnd))
    {
        // Save the new position of the window
        SaveWindowPosition();
    }

    // Default the response to "no save required"
    int  iResult = IDNO;

    //
    // If we are already displaying a "Save As" dialog, dismiss it.
    //
    if (m_hwndQuerySaveDlg != NULL)
    {
        ::SendMessage(m_hwndQuerySaveDlg, WM_COMMAND,
            MAKELONG(IDCANCEL, BN_CLICKED), 0);
        ASSERT(m_hwndQuerySaveDlg == NULL);
    }

    // If any of the pages has changed - ask the user if they want to
    // save the contents of the Whiteboard.
    if (g_bContentsChanged  && IsThereAnythingInAnyWorkspace())
    {
        ::SetForegroundWindow(m_hwnd); //bring us to the top first

        // SetForegroundWindow() does not work properly in Memphis when its called during a
        // SendMessage handler, specifically, when conf calls me to shutdown. The window activation
        // state is messed up or something and my window does not pop to the top. So I have to
        // force my window to the top using SetWindowPos. But even after that the titlebar is not
        // highlighted properly. I tried combinations of SetActiveWindow, SetFocus, etc but to no
        // avail. But, at least the dialog is visible so you can clear it thus fixing the
        // bug (NM4db:2103). SetForegroundWindow() works ok for Win95 and NT here without
        // having to use SetWindowPos (it doesn't hurt anyting to do it anyway so I didn't
        // do a platform check).
        ::SetWindowPos(m_hwnd, HWND_TOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );       // force to top
        ::SetWindowPos(m_hwnd, HWND_NOTOPMOST, 0,0, 0,0, SWP_NOMOVE | SWP_NOSIZE );  // let go of topmost

        //
        // Display a dialog box with the relevant question
        //      LOWORD of user data is "cancel command is allowed"
        //      HIWORD of user data is "disable cancel button"
        //
        iResult = (int)DialogBoxParam(g_hInstance,
            bCancelBtn ? MAKEINTRESOURCE(QUERYSAVEDIALOGCANCEL)
                       : MAKEINTRESOURCE(QUERYSAVEDIALOG),
            m_hwnd,
            QuerySaveDlgProc,
            MAKELONG(bCancelBtn, FALSE));
    }

    return iResult;
}



//
// QuerySaveDlgProc()
// Handler for query save dialogs.  We save some flags in GWL_USER
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            //
            // Save away our HWND so this dialog can be cancelled if necessary
            //
            g_pMain->m_hwndQuerySaveDlg = hwnd;

            // Remember the flags we passed
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            // Should the cancel button be disabled?
            if (HIWORD(lParam))
                ::EnableWindow(::GetDlgItem(hwnd, IDCANCEL), FALSE);

            // Bring us to the front
            ::SetForegroundWindow(hwnd);

            fHandled = TRUE;
            break;

        case WM_CLOSE:
            // Even if the cancel button is disabled, kill the dialog
            ::PostMessage(hwnd, WM_COMMAND, IDCANCEL, 0);
            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDCANCEL:
                    //
                    // If a dialog doesn't have a cancel button or it's
                    // disabled and the user pressed the close btn, we can
                    // get here.
                    //
                    if (!LOWORD(::GetWindowLongPtr(hwnd, GWLP_USERDATA)))
                        wParam = MAKELONG(IDNO, HIWORD(wParam));
                    // FALL THRU

                case IDYES:
                case IDNO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        g_pMain->m_hwndQuerySaveDlg = NULL;

                        ::EndDialog(hwnd, GET_WM_COMMAND_ID(wParam, lParam));
                        break;
                    }
                    break;
            }
            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


//
//
// Function:    OnNew
//
// Purpose:     Clear the workspace and associated filenames
//
//
LRESULT WbMainWindow::OnNew(void)
{
    int iDoNew;

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return S_OK;


    // check state before proceeding - if we're already doing a new, then abort
    if (m_uiSubState == SUBSTATE_NEW_IN_PROGRESS)
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_OK;
    }
    // if we're currently loading, then cancel the load and proceed (don't
    // prompt to save).
    else if (m_uiSubState == SUBSTATE_LOADING)
    {
        // cancel load, not releasing the page order lock, because
        // we need it immediately afterwards
        CancelLoad(FALSE);
        iDoNew = IDNO;
    }
    // otherwise prompt to save if necessary
    else
    {
        // Get confirmation for the new
        iDoNew = QuerySaveRequired(TRUE);
    }

    if (iDoNew == IDYES)
    {
        // Save the changes
        iDoNew = (int)OnSave(FALSE);
    }

    // If the user did not cancel the operation, clear the drawing area
    if (iDoNew != IDCANCEL)
    {
        //
        // Remember if we had a remote pointer.
        // In OldWB, the remote pointer is a global thing that clearing
        //      doesn't get rid of.
        // In T.126WB, it's just an object on a page, so we need to add
        //      it back because we're deleting the old pages and creating
        //      new ones.
        //
        BOOL bRemote = FALSE;
        if (m_pLocalRemotePointer)
        {
            // Remove remote pointer from pages
            bRemote = TRUE;
            OnRemotePointer();
        }

    	::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
	    DeleteAllWorkspaces(TRUE);

	    WorkspaceObj * pObj;
	    DBG_SAVE_FILE_LINE
    	pObj = new WorkspaceObj();
	    pObj->AddToWorkspace();

        if (bRemote)
        {
            // Put it back
            OnRemotePointer();
        }

        // Clear the associated file name
        ZeroMemory(m_strFileName, sizeof(m_strFileName));

        // Update the window title with no file name
        UpdateWindowTitle();
    }

    return S_OK;
}

//
//
// Function:    OnNextPage
//
// Purpose:     Move to the next worksheet in the pages list
//
//
LRESULT WbMainWindow::OnNextPage(void)
{
	// Go to the next page
	if(g_pCurrentWorkspace)
	{
		WBPOSITION pos = g_pCurrentWorkspace->GetMyPosition();
		g_pListOfWorkspaces->GetNext(pos);
		if(pos)
		{
			WorkspaceObj* pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
			GotoPage(pWorkspace);
		}
	}
	return S_OK;
}

//
//
// Function:    OnPrevPage
//
// Purpose:     Move to the previous worksheet in the pages list
//
//
LRESULT WbMainWindow::OnPrevPage(void)
{
	if(g_pCurrentWorkspace)
	{
		WBPOSITION pos = g_pCurrentWorkspace->GetMyPosition();
		g_pListOfWorkspaces->GetPrevious(pos);
		if(pos)
		{
			WorkspaceObj* pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetPrevious(pos);
			GotoPage(pWorkspace);
		}
	}
    return S_OK;
}

//
//
// Function:    OnFirstPage
//
// Purpose:     Move to the first worksheet in the pages list
//
//
LRESULT WbMainWindow::OnFirstPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnFirstPage");

	WorkspaceObj * pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetHead();
	GotoPage(pWorkspace);
    return S_OK;
}

//
//
// Function:    OnLastPage
//
// Purpose:     Move to the last worksheet in the pages list
//
//
LRESULT WbMainWindow::OnLastPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnLastPage");

	WorkspaceObj * pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetTail();
    GotoPage(pWorkspace);
    return S_OK;
}

//
//
// Function:    OnGotoPage
//
// Purpose:     Move to the specified page (if it exists)
//
//
LRESULT WbMainWindow::OnGotoPage(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGotoPage");

	// Get the requested page number from the pages group
	UINT uiPageNumber = m_AG.GetCurrentPageNumber() - 1;

	WBPOSITION pos;
	WorkspaceObj* pWorkspace = NULL;

	pos = g_pListOfWorkspaces->GetHeadPosition();

	while(pos && uiPageNumber != 0)
	{
		g_pListOfWorkspaces->GetNext(pos);
		uiPageNumber--;
	}

	if(pos)
	{
		pWorkspace = (WorkspaceObj *)g_pListOfWorkspaces->GetNext(pos);
		GotoPage(pWorkspace);
	}

    return S_OK;
}

//
// Check if remote pointer was on before we go to page
//
void WbMainWindow::GotoPage(WorkspaceObj * pNewWorkspace, BOOL bSend)
{

	//
	// If we were editing text
	//
	if (g_pDraw->TextEditActive())
   	{
		g_pDraw->EndTextEntry(TRUE);
	}

	//
	// If we had a remote pointer
	//
	BOOL bRemote = FALSE;
	if(m_pLocalRemotePointer)
	{
		bRemote = TRUE;
		OnRemotePointer();
	}
	
	//
	// Undraw remote pointers
	//
	T126Obj * pPointer = g_pCurrentWorkspace->GetTail();
	WBPOSITION pos = g_pCurrentWorkspace->GetTailPosition();
	while(pos && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->UnDraw();	
		pPointer = (T126Obj*) g_pCurrentWorkspace->GetPreviousObject(pos);	
	}

	GoPage(pNewWorkspace, bSend);

	//
	// Draw remote pointers back
	//
	pPointer = g_pCurrentWorkspace->GetTail();
	pos = g_pCurrentWorkspace->GetTailPosition();
	while(pos && pPointer->GraphicTool() == TOOLTYPE_REMOTEPOINTER)
	{
		pPointer->Draw();	
		pPointer = (T126Obj*) g_pCurrentWorkspace->GetPreviousObject(pos);	
	}



	//
	// If we had a remote pointer
	//
	if(bRemote)
	{
		OnRemotePointer();
	}
}






//
//
// Function:    GoPage
//
// Purpose:     Move to the specified page
//
//
void WbMainWindow::GoPage(WorkspaceObj * pNewWorkspace, BOOL bSend)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPage");

	// If we are changing pages
	if (pNewWorkspace != g_pCurrentWorkspace)
	{

		m_drawingArea.CancelDrawingMode();

		// Attach the new page to the drawing area
		m_drawingArea.Attach(pNewWorkspace);

		// set the focus back to the drawing area
		if (!(m_AG.IsChildEditField(::GetFocus())))
		{
			::SetFocus(m_drawingArea.m_hwnd);
		}

		::InvalidateRect(m_drawingArea.m_hwnd, NULL, TRUE );
		::UpdateWindow(m_drawingArea.m_hwnd);

		//
		// Tell the other nodes we moved to a different page.
		//
		if(bSend)
		{
			//
			// Set the view state
			//
			pNewWorkspace->SetViewState(focus_chosen);
			pNewWorkspace->SetViewActionChoice(editView_chosen);
			pNewWorkspace->OnObjectEdit();

		}
	}

	UpdatePageButtons();
}


//
//
// Function:	GotoPosition
//
// Purpose:		Move to the specified position within the page
//
//
void WbMainWindow::GotoPosition(int x, int y)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GotoPosition");

    // Move the drawing area to the new position
    m_drawingArea.GotoPosition(x, y);

    // The user's view has changed
    PositionUpdated();
}


//
//
// Function:    LoadFile
//
// Purpose:     Load a metafile into the application. Errors are reported
//              to the caller by the return code.
//
//
void WbMainWindow::LoadFile
(
    LPCSTR szLoadFileName
)
{
    UINT    uRes;

    // Check we're in idle state
    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        goto UserPointerCleanup;
    }

    if (*szLoadFileName)
    {
        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL, IDC_WAIT));

        // Set the state to say that we are loading a file
        SetSubstate(SUBSTATE_LOADING);

       // Load the file
       uRes = ContentsLoad(szLoadFileName);
       if (uRes != 0)
       {
           DefaultExceptionHandler(WBFE_RC_WB, uRes);
           goto UserPointerCleanup;
       }

        // Set the window title to the new file name
        lstrcpy(m_strFileName, szLoadFileName);

		// Update the window title with the new file name

		g_bContentsChanged = FALSE;
    }

UserPointerCleanup:
	// Set the state to say that we are loading a file
	SetSubstate(SUBSTATE_IDLE);

    // Restore the cursor
    ::SetCursor(::LoadCursor(NULL, IDC_ARROW));
}

//
//
// Function:    OnDropFiles
//
// Purpose:     Files have been dropped onto the Whiteboard window
//
//
void WbMainWindow::OnDropFiles(HDROP hDropInfo)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDropFiles");

    UINT  uiFilesDropped = 0;
    UINT  eachfile;
	PT126WB_FILE_HEADER_AND_OBJECTS pHeader = NULL;

    // Get the total number of files dropped
    uiFilesDropped = ::DragQueryFile(hDropInfo, (UINT) -1, NULL, (UINT) 0);

    // release mouse capture in case we report any errors (message boxes
    // won't repsond to mouse clicks if we don't)
    ReleaseCapture();

    for (eachfile = 0; eachfile < uiFilesDropped; eachfile++)
    {
        // Retrieve each file name
        char  szDropFileName[256];

        ::DragQueryFile(hDropInfo, eachfile,
            szDropFileName, 256);

        TRACE_MSG(("Loading file: %s", szDropFileName));

		OnOpen(szDropFileName);
    }

    ::DragFinish(hDropInfo);
}

//
//
// Function:    OnOpen
//
// Purpose:     Load a metafile into the application.
//
//
LRESULT WbMainWindow::OnOpen(LPCSTR szLoadFileName)
{
    int iOnSave;


	if(g_pDraw->IsLocked() || !g_pDraw->IsSynced())
	{
	    DefaultExceptionHandler(WBFE_RC_WB, WB_RC_BAD_STATE);
	    return S_FALSE;
	}	


    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnOpen");

    if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
        return S_OK;

    // Check we're in idle state
    if ((m_uiSubState == SUBSTATE_NEW_IN_PROGRESS))
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_OK;
      }

    // Don't prompt to save file if we're already loading
    if (m_uiSubState != SUBSTATE_LOADING)
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
    }
    else
    {
        iOnSave = IDNO;
    }

    if (iOnSave == IDYES)
    {
        // User wants to save the drawing area contents
        int iResult = (int)OnSave(TRUE);

        if (iResult == IDOK)
        {
        }
        else
        {
            // cancelled out of Save As, so cancel the open operation
            iOnSave = IDCANCEL;
        }
    }

    // Only continue if the user has not cancelled the operation
    if (iOnSave != IDCANCEL)
    {
		//
		// If the filename was passed
		//
		if(szLoadFileName)
		{
			LoadFile(szLoadFileName);
		}
		else
		{

			OPENFILENAME    ofn;
			TCHAR           szFileName[_MAX_PATH];
			TCHAR           szFileTitle[64];
			TCHAR           strLoadFilter[2*_MAX_PATH];
			TCHAR           strDefaultExt[_MAX_PATH];
			TCHAR           strDefaultPath[2*_MAX_PATH];
			TCHAR *         pStr;
  			UINT            strSize = 0;
      		UINT            totalSize;

			// Build the filter for loadable files
			pStr = strLoadFilter;
			totalSize = 2*_MAX_PATH;

			// These must be NULL separated, with a double NULL at the end
			strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
			pStr += strSize;
			ASSERT(totalSize > strSize);
			totalSize -= strSize;

			*pStr = 0;

			//
			// Setup the OPENFILENAME struct
			//
			ZeroMemory(&ofn, sizeof(ofn));
			ofn.lStructSize = sizeof(ofn);
			ofn.hwndOwner = m_hwnd;

			// No file name supplied to begin with
			szFileName[0] = 0;
			ofn.lpstrFile = szFileName;
			ofn.nMaxFile = _MAX_PATH;

			// Default Extension:  .NMW
			::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
			ofn.lpstrDefExt = strDefaultExt;

			// Default file title is empty
			szFileTitle[0] = 0;
			ofn.lpstrFileTitle = szFileTitle;
			ofn.nMaxFileTitle = 64;

			// Open flags
			ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;
			ofn.hInstance = g_hInstance;

			// Filter
			ofn.lpstrFilter = strLoadFilter;

			// Default path
			if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
				ofn.lpstrInitialDir = strDefaultPath;

			// Get user input, continue only if the user selects the OK button
			if (::GetOpenFileName(&ofn))
			{
				// Change the cursor to "wait"
				::SetCursor(::LoadCursor(NULL, IDC_WAIT));

				// if we're currently loading a file, cancel it, not releasing
				// the page order lock, because we need it immediately afterwards
				if (m_uiSubState == SUBSTATE_LOADING)
				{
					CancelLoad(FALSE);
				}

				// Load the file
				LoadFile(ofn.lpstrFile);
			}
		}
	}

	// Update the window title with no file name
	UpdateWindowTitle();

    return S_OK;
}


//
//
// Function:    GetFileName
//
// Purpose:     Get a file name for saving the contents
//
//
int WbMainWindow::GetFileName(void)
{
    OPENFILENAME    ofn;
    int             iResult;
    TCHAR           szFileTitle[64];
    TCHAR           strSaveFilter[2*_MAX_PATH];
    TCHAR           strDefaultExt[_MAX_PATH];
    TCHAR           strDefaultPath[2 * _MAX_PATH];
    TCHAR           szFileName[2*_MAX_PATH];
    TCHAR *         pStr;
    UINT            strSize = 0;
    UINT            totalSize;

    //
    // If we are already displaying a "Save As" dialog, dismiss it and create
    // a new one.  This can happen if Win95 shuts down whilst WB is
    // displaying the "Save As" dialog and the use selects "Yes" when asked
    // whether they want to save the contents - a second "Save As dialog
    // appears on top of the first.
    //
    if (m_bInSaveDialog)
    {
        CancelSaveDialog();
    }

    // Build the filter for save files
    pStr = strSaveFilter;
    totalSize = 2*_MAX_PATH;

    // These must be NULL separated, with a double NULL at the end
    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_WHT_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    strSize = ::LoadString(g_hInstance, IDS_FILTER_ALL_SPEC, pStr, totalSize) + 1;
    pStr += strSize;
    ASSERT(totalSize > strSize);
    totalSize -= strSize;

    *pStr = 0;

    //
    // Setup the OPENFILENAME struct
    //
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hwnd;

    lstrcpy(szFileName, m_strFileName);
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = _MAX_PATH;

    // Build the default extension string
    ::LoadString(g_hInstance, IDS_EXT_WHT, strDefaultExt, sizeof(strDefaultExt));
    ofn.lpstrDefExt = strDefaultExt;

    szFileTitle[0] = 0;
    ofn.lpstrFileTitle = szFileTitle;
    ofn.nMaxFileTitle = 64;

    // Save flags
    ofn.Flags = OFN_HIDEREADONLY | OFN_NOREADONLYRETURN |
        OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;
    ofn.hInstance = g_hInstance;

    // Filter
    ofn.lpstrFilter = strSaveFilter;

    // Default path
    if (GetDefaultPath(strDefaultPath, sizeof(strDefaultPath)))
        ofn.lpstrInitialDir = strDefaultPath;

    m_bInSaveDialog = TRUE;

    if (::GetSaveFileName(&ofn))
    {
        // The user selected OK
        iResult = IDOK;
        lstrcpy(m_strFileName, szFileName);
    }
    else
    {
        iResult = IDCANCEL;
    }

    m_bInSaveDialog = FALSE;

    return iResult;
}


//
//
// Function:    OnSave
//
// Purpose:     Save the contents of the Whiteboard using the current file
//              name (or prompting for a new name if there is no current).
//
//
LRESULT WbMainWindow::OnSave(BOOL bPrompt)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnSave");

    LRESULT iResult = IDOK;

    // save the old file name in case there's an error
    TCHAR strOldName[2*MAX_PATH];
    UINT fileNameSize = lstrlen(m_strFileName);
    lstrcpy(strOldName, m_strFileName);

    BOOL bNewName = FALSE;

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return(iResult);
    }

    // Check whether there is a filename available for use
    if (!fileNameSize || (bPrompt))
    {
        // Get user input, continue only if the user selects the OK button
        iResult = GetFileName();

        if (iResult == IDOK)
        {
            // entering a blank file name is treated as cancelling the save
            if (!lstrlen(m_strFileName))
            {
                lstrcpy(m_strFileName, strOldName);
                iResult = IDCANCEL;
            }
            else
            {
                // flag that we've changed the contents file name
                bNewName = TRUE;
            }
        }
    }

    // Now save the file
    if ((iResult == IDOK) && lstrlen(m_strFileName))
    {
        WIN32_FIND_DATA findFileData;
        HANDLE          hFind;

        // Get attributes
        hFind = ::FindFirstFile(m_strFileName, &findFileData);
        if (hFind != INVALID_HANDLE_VALUE)
        {
            ::FindClose(hFind);

            // This is a read-only file; we can't change its contents
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                WARNING_OUT(("Dest file %s is read only", m_strFileName));
                ::Message(NULL, IDS_SAVE, IDS_SAVE_READ_ONLY);

                // If the file name was changed for this save then undo
                // the change
                if (bNewName)
                {
                    lstrcpy(m_strFileName, strOldName);
                    bNewName = FALSE;
                }

                // Change the return code to indicate no save was made
                iResult = IDCANCEL;
                return(iResult);
            }
        }

        // Change the cursor to "wait"
        ::SetCursor(::LoadCursor(NULL,IDC_WAIT));

        // Write the file
        if (ContentsSave(m_strFileName) != 0)
        {
            // Show that an error occurred saving the file.
            WARNING_OUT(("Error saving file"));
            ::Message(NULL, IDS_SAVE, IDS_SAVE_ERROR);

            // If the file name was changed for this save then undo
            // the change
            if (bNewName)
            {
                lstrcpy(m_strFileName, strOldName);
                bNewName = FALSE;
            }

            // Change the return code to indicate no save was made
            iResult = IDCANCEL;
        }
        else
        {
        	g_bContentsChanged = FALSE;
        }

        // Restore the cursor
        ::SetCursor(::LoadCursor(NULL,IDC_ARROW));
    }

    // if the contents file name has changed as a result of the save then
    // update the window title
    if (bNewName)
    {
		UpdateWindowTitle();
    }

    return(iResult);
}


//
// CancelSaveDialog()
// This cancels the save as dialog if up and we need to kill it to continue.
// We walk back up the owner chain in case the save dialog puts up help or
// other owned windows.
//
void WbMainWindow::CancelSaveDialog(void)
{
    WBFINDDIALOG        wbf;

    ASSERT(m_bInSaveDialog);

    wbf.hwndOwner = m_hwnd;
    wbf.hwndDialog = NULL;
    EnumThreadWindows(::GetCurrentThreadId(), WbFindCurrentDialog, (LPARAM)&wbf);

    if (wbf.hwndDialog)
    {
        // Found it!
        ::SendMessage(wbf.hwndDialog, WM_COMMAND, IDCANCEL, 0);
    }

    m_bInSaveDialog = FALSE;
}



BOOL CALLBACK WbFindCurrentDialog(HWND hwndNext, LPARAM lParam)
{
    WBFINDDIALOG * pwbf = (WBFINDDIALOG *)lParam;

    // Is this a dialog, owned by the main window?
    if ((::GetClassLong(hwndNext, GCW_ATOM) == 0x8002) &&
        (::GetWindow(hwndNext, GW_OWNER) == pwbf->hwndOwner))
    {
        pwbf->hwndDialog = hwndNext;
        return(FALSE);
    }

    return(TRUE);
}


//
//
// Function:    OnClose
//
// Purpose:     Close the Whiteboard
//
//
void WbMainWindow::OnClose()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClose");

    int iOnSave = IDOK;

    m_drawingArea.CancelDrawingMode();

    m_AG.SaveSettings();

    // If we got here, by way of OnDestroy from the DCL cores or
    // by system shutdown, then assume that user responded already to the
    // save-changes dialog that would have poped up during conf's global shutdown
    // message. We don't need to ask 'em again. What tangled webs......
    if ((!m_bQuerySysShutdown) && (IsIdle()))
    {
        // Check whether there are changes to be saved
        iOnSave = QuerySaveRequired(TRUE);
        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            iOnSave = (int)OnSave(TRUE);
        }
    }

    // If the exit was not cancelled, close the application
    if (iOnSave != IDCANCEL)
    {
        // Close the application
        ::PostQuitMessage(0);

    }

}


//
//
// Function:    OnClearPage
//
// Purpose:     Clear the Whiteboard drawing area. The user is prompted to
//              choose clearing of foreground, background or both.
//
//
LRESULT WbMainWindow::OnClearPage(BOOL bClearAll)
{
    LRESULT iResult;
    BOOL bWasPosted;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnClearPage");

    if( UsersMightLoseData( &bWasPosted, NULL ) ) // bug NM4db:418
        return S_OK;

    if( bWasPosted )
        iResult = IDYES;
    else
        iResult = ::Message(NULL, bClearAll == FALSE ? IDS_DELETE_PAGE : IDS_CLEAR_CAPTION, bClearAll == FALSE ? IDS_DELETE_PAGE_MESSAGE : IDS_CLEAR_MESSAGE, MB_YESNO | MB_ICONQUESTION);


    if ((iResult == IDYES) && bClearAll)
    {
		OnSelectAll();
		OnDelete();
		
        TRACE_MSG(("User requested clear of page"));
	}
	return iResult;
}




//
//
// Function:    OnDelete
//
// Purpose:     Delete the current selection
//
//
LRESULT WbMainWindow::OnDelete()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnDelete");


    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

	// Delete the currently selected graphics and add to m_LastDeletedGraphic
	m_drawingArea.EraseSelectedDrawings();

    return S_OK;
}

//
//
// Function:	OnUndelete
//
// Purpose:	 Undo the last delete operation
//
//
LRESULT WbMainWindow::OnUndelete()
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnUndelete");

	// If there is a deleted graphic to restore
   	T126Obj * pObj;
	pObj = (T126Obj *)g_pTrash->RemoveHead();
	while (pObj != NULL)
	{
		if(!AddT126ObjectToWorkspace(pObj))
		{
			return S_FALSE;
		}
		if(pObj->GetMyWorkspace() == g_pCurrentWorkspace)
		{
			pObj->Draw(FALSE);
		}

        //
        // Make sure it gets added back as unselected.  It was selected
        // when deleted.
        //
        pObj->ClearDeletionFlags();
        pObj->SetAllAttribs();
        pObj->SetViewState(unselected_chosen);
        pObj->SendNewObjectToT126Apps();

		pObj = (T126Obj *) g_pTrash->RemoveHead();
	}
	return S_OK;
}


//
//
// Function:    OnSelectAll
//
// Purpose:     Select all the objects in the current page
//
//
LRESULT WbMainWindow::OnSelectAll( void )
{

	// Unselect every oject first.
	m_drawingArea.RemoveMarker();

    // turn off any selections
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // inhibit normal select-tool action
    m_bSelectAllInProgress = TRUE;

    //put us in select-tool mode first
    OnSelectTool(IDM_SELECT);

    // back to normal
    m_bSelectAllInProgress = FALSE;

    // now, select everything
    m_drawingArea.SelectMarkerFromRect( NULL );

	return S_OK;
}

//
//
// Function:    OnCut
//
// Purpose:     Cut the current selection
//
//
LRESULT WbMainWindow::OnCut()
{
	// Copy all the selected graphics to the clipboard
	BOOL bResult = CLP_Copy();
	
	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDM_CUT, IDS_COPY_ERROR);
		return S_FALSE;
	}

	//
	// Erase the selected objects
	//
	OnDelete();

    return S_OK;
}


//
// OnCopy()
// Purpose:     Copy the current selection to the clipboard
//
//
LRESULT WbMainWindow::OnCopy(void)
{
	// Copy all the selected graphics to the clipboard
	BOOL bResult = CLP_Copy();

	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDS_COPY, IDS_COPY_ERROR);
		return S_FALSE;
	}

    return S_OK;
}


//
//
// Function:    OnPaste
//
// Purpose:     Paste the contents of the clipboard into the drawing pane
//
//
LRESULT WbMainWindow::OnPaste()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPaste");

	BOOL bResult = CLP_Paste();
	
	// If an error occurred during the copy, report it now
	if (!bResult)
	{
		::Message(NULL, IDS_PASTE, IDS_PASTE_ERROR);
		return S_FALSE;
	}

	return S_OK;
}


//
//
// Function:    OnScrollAccelerator
//
// Purpose:     Called when a scroll accelerator is used
//
//
LRESULT WbMainWindow::OnScrollAccelerator(UINT uiMenuId)
{
    int     iScroll;

    // Locate the scroll messages to be sent in the conversion table
    for (iScroll = 0; iScroll < ARRAYSIZE(s_MenuToScroll); iScroll++)
    {
        if (s_MenuToScroll[iScroll].uiMenuId == uiMenuId)
        {
            // Found it;
            break;
        }
    }

    // Send the messages
    if (iScroll < ARRAYSIZE(s_MenuToScroll))
    {
        while ((s_MenuToScroll[iScroll].uiMenuId == uiMenuId) && (iScroll < ARRAYSIZE(s_MenuToScroll)))
        {
            // Tell the drawing pane to scroll
            ::PostMessage(m_drawingArea.m_hwnd, s_MenuToScroll[iScroll].uiMessage,
                s_MenuToScroll[iScroll].uiScrollCode, 0);

            iScroll++;
        }

        // Indicate that scrolling has completed (in both directions)
        ::PostMessage(m_drawingArea.m_hwnd, WM_HSCROLL, SB_ENDSCROLL, 0L);
        ::PostMessage(m_drawingArea.m_hwnd, WM_VSCROLL, SB_ENDSCROLL, 0L);
    }
    return S_OK;
}


//
//
// Function:    OnZoom
//
// Purpose:     Zoom or unzoom the drawing area
//
//
LRESULT WbMainWindow::OnZoom()
{
    // If the drawing area is currently zoomed
    if (m_drawingArea.Zoomed())
    {
        // Tell the tool bar of the new selection
        m_TB.PopUp(IDM_ZOOM);
		UncheckMenuItem(IDM_ZOOM);

    }
    else
    {
        // Tell the tool bar of the new selection
        m_TB.PushDown(IDM_ZOOM);
		CheckMenuItem(IDM_ZOOM);

    }

    // Zoom/unzoom the drawing area
    m_drawingArea.Zoom();

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


LRESULT WbMainWindow::OnLock()
{
	// If the drawing area is currently Locked
	if (m_drawingArea.IsLocked())
	{
		m_TB.PopUp(IDM_LOCK);
		UncheckMenuItem(IDM_LOCK);
	}
	else
	{
		
		m_TB.PushDown(IDM_LOCK);
		CheckMenuItem(IDM_LOCK);
		g_pNMWBOBJ->m_LockerID = g_MyMemberID;
	}
	m_drawingArea.SetLock(!m_drawingArea.IsLocked());
	TogleLockInAllWorkspaces(m_drawingArea.IsLocked(), TRUE);
	EnableToolbar( TRUE );

	return S_OK;
}


//
//
// Function:    OnSelectTool
//
// Purpose:     Select the current tool
//
//
LRESULT WbMainWindow::OnSelectTool(UINT uiMenuId)
{

    UncheckMenuItem(m_currentMenuTool);
    CheckMenuItem( uiMenuId);

    UINT uiIndex;

    // Save the new menu Id
    m_currentMenuTool = uiMenuId;

    // Tell the tool bar of the new selection
    m_TB.PushDown(m_currentMenuTool);

    // Get the new tool
    m_pCurrentTool = m_ToolArray[TOOL_INDEX(m_currentMenuTool)];

    // Set the current attributes
    if( !m_bSelectAllInProgress )
    {
        m_AG.SetChoiceColor(m_pCurrentTool->GetColor() );

        ::SendMessage(m_hwnd, WM_COMMAND, IDM_COLOR, 0L);
    }

    // Report the change of tool to the attributes group
    m_AG.DisplayTool(m_pCurrentTool);

    // Select the new tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
	return S_OK;
}


//
//
// Function:    OnSelectColor
//
// Purpose:     Set the current color
//
//
LRESULT WbMainWindow::OnSelectColor(void)
{
    // Tell the attributes group of the new selection and get the
    // new color value selected ino the current tool.
    m_AG.SelectColor(m_pCurrentTool);

    // Select the changed tool into the drawing area
    m_drawingArea.SelectTool(m_pCurrentTool);

    // If there is an object marked for changing
    if (m_drawingArea.GraphicSelected() || m_drawingArea.TextEditActive())
    {
		// Update the object
        m_drawingArea.SetSelectionColor(m_pCurrentTool->GetColor());
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
//
// Function:    OnSelectWidth
//
// Purpose:     Set the current nib width
//
//
LRESULT WbMainWindow::OnSelectWidth(UINT uiMenuId)
{
    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // Save the new pen width
    m_currentMenuWidth = uiMenuId;

    // Tell the attributes display of the new selection
    m_WG.PushDown(uiMenuId - IDM_WIDTHS_START);

    if (m_pCurrentTool != NULL)
    {
        m_pCurrentTool->SetWidthIndex(uiMenuId - IDM_WIDTHS_START);
    }

    // Tell the drawing pane of the new selection
    m_drawingArea.SelectTool(m_pCurrentTool);

	// If there is an object marked for changing
	if (m_drawingArea.GraphicSelected())
	{
		// Update the object
		m_drawingArea.SetSelectionWidth(uiMenuId - IDM_WIDTHS_START);
	}

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
//
// Function:    OnChooseFont
//
// Purpose:     Let the user select a font
//
//
LRESULT WbMainWindow::OnChooseFont(void)
{
    HDC hdc;
    LOGFONT lfont;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnChooseFont");

    // cleanup select logic in case object context menu called us (bug 426)
    m_drawingArea.SetLClickIgnore( FALSE );

    // It is only really sensible to be here when a text tool is selected.
    // This is achieved by graying the Font selection menu entry when
    // anything other than a text tool is in use.

    // Get the font details from the current tool
    ::GetObject(m_pCurrentTool->GetFont(), sizeof(LOGFONT), &lfont);
    lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

    //
    // The Font dialog is passed a LOGFONT structure which it uses to
    // initialize all of its fields (face name, weight etc).
    //
    // The face name passed in the LOGFONT structure is checked by the dialog
    // against the facenames of all available fonts.  If the name does not
    // match one of the available fonts, no name is displayed.
    //
    // WB stores the LOGFONT structure specifying the font used for a text
    // object in the object.  This LOGFONT is selected into a DC where the
    // GDIs font mapper decides which physical font most closely matches the
    // required logical font.  On boxes where the original font is not
    // supported the font is substituted for the closest matching font
    // available.
    //
    // So, if we pass the LOGFONT structure for a font which is not supported
    // into the Font dialog, no facename is displayed.  To bypass this we
    //
    // - select the logical font into a DC
    //
    // - determine the textmetrics and get the face name of the physical font
    //   chosen by the Font Mapper
    //
    // - use these textmetrics to create a LOGFONT structure which matches
    //   the substituted font!
    //
    // The resulting LOGFONT will have the correct weight, dimensions and
    // facename for the substituted font.
    //
    hdc = ::CreateCompatibleDC(NULL);
    if (hdc != NULL)
    {
        TEXTMETRIC  tm;
        HFONT       hFont;
        HFONT       hOldFont;

        hFont = ::CreateFontIndirect(&lfont);

        //
        // Get the face name and text metrics of the selected font.
        //
        hOldFont = SelectFont(hdc, hFont);
        if (hOldFont == NULL)
        {
            WARNING_OUT(("Failed to select font into DC"));
        }
        else
        {
            ::GetTextMetrics(hdc, &tm);
            ::GetTextFace(hdc, LF_FACESIZE, lfont.lfFaceName);

            //
            // Restore the old font back into the DC.
            //
            SelectFont(hdc, hOldFont);

            //
            // Create a LOGFONT structure which matches the Text metrics
            // of the font used by the DC so that the font dialog manages
            // to initialise all of its fields properly, even for
            // substituted fonts...
            //
            lfont.lfHeight    =  tm.tmHeight;
            lfont.lfWidth     =  tm.tmAveCharWidth;
            lfont.lfWeight    =  tm.tmWeight;
            lfont.lfItalic    =  tm.tmItalic;
            lfont.lfUnderline =  tm.tmUnderlined;
            lfont.lfStrikeOut =  tm.tmStruckOut;
            lfont.lfCharSet   =  tm.tmCharSet;

            //ADDED BY RAND - to make lfHeight be a char height. This makes
            //                the font dlg show the same pt size that is
            //                displayed in the sample font toolbar
            if( lfont.lfHeight > 0 )
            {
                lfont.lfHeight = -(lfont.lfHeight - tm.tmInternalLeading);
            }
        }

        ::DeleteDC(hdc);

        if (hFont != NULL)
        {
            ::DeleteFont(hFont);
        }
    }
    else
    {
        WARNING_OUT(("Failed to get DC to select font into"));
    }

    CHOOSEFONT  cf;
    TCHAR       szStyleName[64];

    ZeroMemory(&cf, sizeof(cf));
    ZeroMemory(szStyleName, sizeof(szStyleName));

    cf.lStructSize = sizeof(cf);
    cf.lpszStyle = szStyleName;
    cf.rgbColors = m_pCurrentTool->GetColor() & 0x00ffffff; // blow off palette bits (NM4db:2304)
    cf.Flags = CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS |
        CF_NOVERTFONTS;
    cf.lpLogFont = &lfont;
    cf.hwndOwner = m_hwnd;

    // Call up the ChooseFont dialog from COM DLG
    if (::ChooseFont(&cf))
    {
        lfont.lfClipPrecision |= CLIP_DFA_OVERRIDE;

        //ADDED BY RAND - set color selected in dialog.
        m_pCurrentTool->SetColor(cf.rgbColors);
        m_AG.DisplayTool( m_pCurrentTool );

        ::SendMessage(m_hwnd, WM_COMMAND,
                (WPARAM)MAKELONG( IDM_COLOR, BN_CLICKED ),
                (LPARAM)0 );

        // Inform the drawing pane of the new selection
        HFONT   hNewFont;

        hNewFont = ::CreateFontIndirect(&lfont);
        if (!hNewFont)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return S_FALSE;
        }

        //
        // We need to set the text editor font after inserting it in the DC
        // and querying the metrics, otherwise we may get a font with different
        // metrics in zoomed mode
        //
        HFONT   hNewFont2;
        HDC hDC = m_drawingArea.GetCachedDC();
        TEXTMETRIC textMetrics;

        m_drawingArea.PrimeFont(hDC, hNewFont, &textMetrics);
        lfont.lfHeight            = textMetrics.tmHeight;
        lfont.lfWidth             = textMetrics.tmAveCharWidth;
        lfont.lfPitchAndFamily    = textMetrics.tmPitchAndFamily;
        ::GetTextFace(hDC, sizeof(lfont.lfFaceName),
                     lfont.lfFaceName);
        TRACE_MSG(("Font face name %s", lfont.lfFaceName));

        // Inform the drawing pane of the new selection
        hNewFont2 = ::CreateFontIndirect(&lfont);
        if (!hNewFont2)
        {
            ERROR_OUT(("Failed to create font"));
            DefaultExceptionHandler(WBFE_RC_WINDOWS, 0);
            return S_FALSE;
        }

		m_drawingArea.SetSelectionColor(cf.rgbColors);

        m_drawingArea.SetSelectionFont(hNewFont2);

        if (m_pCurrentTool != NULL)
        {
            m_pCurrentTool->SetFont(hNewFont2);
        }
        m_drawingArea.SelectTool(m_pCurrentTool);

        //
        // discard the new font
        //
        m_drawingArea.UnPrimeFont( hDC );

        // Delete the fonts we created--everybody above makes copies
        ::DeleteFont(hNewFont2);
        ::DeleteFont(hNewFont);
    }

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);
    return S_OK;
}


//
//
// Function:    OnToolBarToggle
//
// Purpose:     Let the user toggle the tool bar on/off
//
//
LRESULT WbMainWindow::OnToolBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bToolBarOn = !m_bToolBarOn;

    // Make the necessary updates
    if (m_bToolBarOn)
    {
        // The tool bar was hidden, so show it
        ::ShowWindow(m_TB.m_hwnd, SW_SHOW);

        // The tool window is fixed so we must resize the other panes in
        // the window to make room for it
        ResizePanes();

        // Check the associated menu item
        CheckMenuItem(IDM_TOOL_BAR_TOGGLE);
    }
    else
    {
        // The tool bar was visible, so hide it
        ::ShowWindow(m_TB.m_hwnd, SW_HIDE);

        ResizePanes();

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_TOOL_BAR_TOGGLE);

    }

    // Make sure things reflect current tool
    m_AG.DisplayTool(m_pCurrentTool);

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_TOOLBARVISIBLE,
                           m_bToolBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top, rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
	
	return S_OK;
}


//
//
// Function:    OnStatusBarToggle
//
// Purpose:     Let the user toggle the help bar on/off
//
//
void WbMainWindow::OnStatusBarToggle(void)
{
    RECT rectWnd;

    // Toggle the flag
    m_bStatusBarOn = !m_bStatusBarOn;

    // Make the necessary updates
    if (m_bStatusBarOn)
    {
        // Resize the panes to give room for the help bar
        ResizePanes();

        // The help bar was hidden, so show it
        ::ShowWindow(m_hwndSB, SW_SHOW);

        // Check the associated menu item
        CheckMenuItem(IDM_STATUS_BAR_TOGGLE);
    }
    else
    {
        // The help bar was visible, so hide it
        ::ShowWindow(m_hwndSB, SW_HIDE);

        // Uncheck the associated menu item
        UncheckMenuItem(IDM_STATUS_BAR_TOGGLE);

        // Resize the panes to take up the help bar space
        ResizePanes();
    }

    // Write the new option value to the options file
    OPT_SetBooleanOption(OPT_MAIN_STATUSBARVISIBLE, m_bStatusBarOn);

    ::GetWindowRect(m_hwnd, &rectWnd);
    ::MoveWindow(m_hwnd, rectWnd.left, rectWnd.top, rectWnd.right - rectWnd.left, rectWnd.bottom - rectWnd.top, TRUE);
}


//
//
// Function:    OnAbout
//
// Purpose:     Show the about box for the Whiteboard application. This
//              method is called whenever a WM_COMMAND with IDM_ABOUT
//              is issued by Windows.
//
//
LRESULT	WbMainWindow::OnAbout()
{
    ::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(ABOUTBOX), m_hwnd,
        AboutDlgProc, 0);
        return S_OK;
}


INT_PTR AboutDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            TCHAR   szFormat[256];
            TCHAR   szVersion[512];

            ::GetDlgItemText(hwnd, IDC_ABOUTVERSION, szFormat, 256);
            wsprintf(szVersion, szFormat, VER_PRODUCTRELEASE_STR,
                VER_PRODUCTVERSION_STR);
            ::SetDlgItemText(hwnd, IDC_ABOUTVERSION, szVersion);

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}


void WbMainWindow::UpdateWindowTitle(void)
{
	TCHAR szCaption[MAX_PATH * 2];
	TCHAR szFileName[MAX_PATH * 2];
	UINT captionID;
	if (! g_pNMWBOBJ->IsInConference())
	{
		captionID = IDS_WB_NOT_IN_CALL_WINDOW_CAPTION;
	}
	else
	{
		captionID = IDS_WB_IN_CALL_WINDOW_CAPTION;
	}

   	::LoadString(g_hInstance, captionID, szFileName, sizeof(szFileName) );
   	
	wsprintf(szCaption, szFileName, GetFileNameStr(), g_pNMWBOBJ->m_cOtherMembers);
	SetWindowText(m_hwnd, szCaption);

}




//
//
// Function:    SelectWindow
//
// Purpose:     Let the user select a window for grabbing
//
//
HWND WbMainWindow::SelectWindow(void)
{
    POINT   mousePos;            // Mouse position
    HWND    hwndSelected = NULL; // Window clicked on
    MSG     msg;                 // Current message

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( GRABCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode state
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Trap all mouse messages until a WM_LBUTTONUP is received
    for ( ; ; )
    {
        // Wait for the next message
        ::WaitMessage();


        // Cancel if we have been sent a WM_CANCELMODE message
        if (CancelModeSent())
        {
            break;
        }

        // If it is a mouse message, process it
        if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
        {
            if (msg.message == WM_LBUTTONUP)
            {
                // Get mouse position
                mousePos.x = (short)LOWORD(msg.lParam);
                mousePos.y = (short)HIWORD(msg.lParam);

                // Convert to screen coordinates
                ::ClientToScreen(m_hwnd, &mousePos);

                // Get the window under the mouse
                hwndSelected = ::WindowFromPoint(mousePos);

                // Leave the loop
                break;
            }
        }

        // Cancel if ESCAPE is pressed.
        // or if another window receives the focus
        else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
        {
            if (msg.wParam == VK_ESCAPE)
            {
                break;
            }
        }
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    return(hwndSelected);
}


//
//
// Function:    OnGrabWindow
//
// Purpose:     Allows the user to grab a bitmap of a window
//
//
LRESULT WbMainWindow::OnGrabWindow(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabWindow");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTWINDOW),
        m_hwnd, WarnSelectWindowDlgProc, 0) != IDOK)
    {
        // User cancelled; bail out
        return S_OK;;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);


	HWND mainUIhWnd = FindWindow("MPWClass\0" , NULL);
	if(IsWindowVisible(mainUIhWnd))
	{
		::UpdateWindow(mainUIhWnd);
    }

    // Get window selection from the user
    HWND hwndSelected = SelectWindow();

    if (hwndSelected != NULL)
    {
        // Walk back to the find the 'real' window ancestor
        HWND    hwndParent;

        // The following piece of code attempts to find the frame window
        // enclosing the selected window. This allows us to bring the
        // enclosing window to the top, bringing the child window with it.
        DWORD dwStyle;

        while ((hwndParent = ::GetParent(hwndSelected)) != NULL)
        {
            // If we have reached a stand-alone window, stop the search
            dwStyle = ::GetWindowLong(hwndSelected, GWL_STYLE);

            if (   ((dwStyle & WS_POPUP) == WS_POPUP)
                || ((dwStyle & WS_THICKFRAME) == WS_THICKFRAME)
                || ((dwStyle & WS_DLGFRAME) == WS_DLGFRAME))
            {
                break;
            }

            // Move up to the parent window
            hwndSelected = hwndParent;
        }

        // Bring the selected window to the top
        ::BringWindowToTop(hwndSelected);
        ::UpdateWindow(hwndSelected);

        // Get an image copy of the window
        RECT areaRect;

        ::GetWindowRect(hwndSelected, &areaRect);

        BitmapObj* dib;
		DBG_SAVE_FILE_LINE
        dib = new BitmapObj(TOOLTYPE_FILLEDBOX);
        dib->FromScreenArea(&areaRect);

		if(dib->m_lpbiImage == NULL)
		{
			delete dib;
			return S_FALSE;
		}

        // Add the new grabbed bitmap
        AddCapturedImage(dib);

        // Force the selection tool to be selected
        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }

    // Show the windows again
    ::ShowWindow(m_hwnd, SW_SHOW);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

    return S_OK;
}


//
// WarnSelectWindowDlgProc()
// This puts up the warning/explanation dialog.  We use the default settings
// or whatever the user chose last time this dialog was up.
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            if (OPT_GetBooleanOption( OPT_MAIN_SELECTWINDOW_NOTAGAIN,
                            DFLT_MAIN_SELECTWINDOW_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;
        }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SWWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTWINDOW_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
                    break;
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:    ShowAllWindows
//
// Purpose:     Show or hide the main window and associated windows
//
//
void WbMainWindow::ShowAllWindows(int iShow)
{
    // Show/hide the main window
    ::ShowWindow(m_hwnd, iShow);

    // Show/hide the tool window
    if (m_bToolBarOn)
    {
        ::ShowWindow(m_TB.m_hwnd, iShow);
    }
}

//
//
// Function:    OnGrabArea
//
// Purpose:     Allows the user to grab a bitmap of an area of the screen
//
//
LRESULT WbMainWindow::OnGrabArea(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnGrabArea");

    if (::DialogBoxParam(g_hInstance, MAKEINTRESOURCE(WARNSELECTAREA),
        m_hwnd, WarnSelectAreaDlgProc, 0) != IDOK)
    {
        // User cancelled, so bail out
        return S_OK;;
    }

    // Hide the application windows
    ::ShowWindow(m_hwnd, SW_HIDE);

	HWND mainUIhWnd = FindWindow("MPWClass\0" , NULL);
	if(IsWindowVisible(mainUIhWnd))
	{
		::UpdateWindow(mainUIhWnd);
    }

    // Load the grabbing cursors
    HCURSOR hGrabCursor = ::LoadCursor(g_hInstance, MAKEINTRESOURCE( PENCURSOR ) );

    // Capture the mouse
    UT_CaptureMouse(m_hwnd);

    // Ensure we receive all keyboard messages.
    ::SetFocus(m_hwnd);

    // Reset the CancelMode status
    ResetCancelMode();

    // Change to the grab cursor
    HCURSOR hOldCursor = ::SetCursor(hGrabCursor);

    // Let the user select the area to be grabbed
    RECT rect;
    int  tmp;

    GetGrabArea(&rect);

    // Normalize coords
    if (rect.right < rect.left)
    {
        tmp = rect.left;
        rect.left = rect.right;
        rect.right = tmp;
    }

    if (rect.bottom < rect.top)
    {
        tmp = rect.top;
        rect.top = rect.bottom;
        rect.bottom = tmp;
    }

    BitmapObj* dib;
	DBG_SAVE_FILE_LINE
    dib = new BitmapObj(TOOLTYPE_FILLEDBOX);
    if (!::IsRectEmpty(&rect))
    {
        // Get a bitmap copy of the screen area
        dib->FromScreenArea(&rect);
    }

    // Show the windows again now - if we do it later we get the bitmap to
    // be added re-drawn twice (once on the window show and once when the
    // graphic added indication arrives).
    ::ShowWindow(m_hwnd, SW_SHOW);
    ::UpdateWindow(m_hwnd);




    if (!::IsRectEmpty(&rect) && dib->m_lpbiImage)
    {
    	
	        // Add the bitmap
    	    AddCapturedImage(dib);

        	// Force the selection tool to be selected
	        ::PostMessage(m_hwnd, WM_COMMAND, IDM_TOOLS_START, 0L);
    }
    else
    {
    	delete dib;
    	dib = NULL;
    }

    // Release the mouse
    UT_ReleaseMouse(m_hwnd);

    // Restore the cursor
    ::SetCursor(hOldCursor);

    // Restore the focus to the drawing area
    ::SetFocus(m_drawingArea.m_hwnd);

	if(dib)
	{
		dib->Draw();
	}


    return S_OK;
}


//
// WarnSelectArea dialog handler
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    BOOL    fHandled = FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            if (OPT_GetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN,
                    DFLT_MAIN_SELECTAREA_NOTAGAIN))
            {
                // End this right away, the user doesn't want a warning
                ::EndDialog(hwnd, IDOK);
            }

            fHandled = TRUE;
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            //
                            // Update settings -- note that we don't have to write out
                            // FALSE--we wouldn't be in the dialog in the first place
                            // if the current setting weren't already FALSE.
                            //
                            if (::IsDlgButtonChecked(hwnd, IDC_SAWARN_NOTAGAIN))
                            {
                                OPT_SetBooleanOption(OPT_MAIN_SELECTAREA_NOTAGAIN, TRUE);
                            }

                            ::EndDialog(hwnd, IDOK);
                            break;
                    }
                    break;

                case IDCANCEL:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case BN_CLICKED:
                            ::EndDialog(hwnd, IDCANCEL);
                            break;
                    }
            }

            fHandled = TRUE;
            break;
    }

    return(fHandled);
}



//
//
// Function:	GetGrabArea
//
// Purpose:	 Allows the user to grab a bitmap of an area of the screen
//
//
void WbMainWindow::GetGrabArea(LPRECT lprect)
{
	POINT  mousePos;			// Mouse position
	MSG	msg;				 // Current message
	BOOL   tracking = FALSE;	// Flag indicating mouse button is down
	HDC	hDC = NULL;
	POINT  grabStartPoint;	  // Start point (when mouse button is pressed)
	POINT  grabEndPoint;		// End point (when mouse button is released)
	POINT  grabCurrPoint;	   // Current mouse position

	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::GetGrabArea");

	// Set the result to an empty rectangle
	::SetRectEmpty(lprect);

	// Create the rectangle to be used for tracking
	DrawObj* pRectangle = NULL;

	DBG_SAVE_FILE_LINE
	pRectangle = new DrawObj(rectangle_chosen, TOOLTYPE_SELECT);
    if(NULL == pRectangle)
    {
        ERROR_OUT(("Failed to allocate DrawObj"));
        goto GrabAreaCleanup;
    }
	pRectangle->SetPenColor(RGB(0,0,0), TRUE);
	pRectangle->SetFillColor(RGB(255,255,255), FALSE);
	pRectangle->SetLineStyle(PS_DOT);
	pRectangle->SetPenThickness(1);


	// Get the DC for tracking
	HWND hDesktopWnd = ::GetDesktopWindow();
	hDC = ::GetWindowDC(hDesktopWnd);
	if (hDC == NULL)
	{
		WARNING_OUT(("NULL desktop DC"));
		goto GrabAreaCleanup;
	}

	RECT rect;

	// Trap all mouse messages until a WM_LBUTTONUP is received
	for ( ; ; )
	{
		// Wait for the next message
		::WaitMessage();


		// Cancel if we have been sent a WM_CANCELMODE message
		if (CancelModeSent())
		{
			TRACE_MSG(("canceling grab"));

			// Erase the last tracking rectangle
			if (!EqualPoint(grabStartPoint, grabEndPoint))
			{
				rect.top = grabStartPoint.y;
				rect.left = grabStartPoint.x;
				rect.bottom = grabEndPoint.y;
				rect.right = grabEndPoint.x;
				pRectangle->SetRect(&rect);
				pRectangle->SetBoundsRect(&rect);
				pRectangle->Draw(hDC);
			}

			break;
		}

		// If it is a mouse message, process it
		if (::PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
		{
			// Get mouse position
			TRACE_MSG( ("msg = %x, lParam = %0x", msg.message, msg.lParam) );
			mousePos.x = (short)LOWORD(msg.lParam);
			mousePos.y = (short)HIWORD(msg.lParam);

			TRACE_MSG( ("mousePos = %d,%d", mousePos.x, mousePos.y) );

			// Convert to screen coordinates
			::ClientToScreen(m_hwnd, &mousePos);
			grabCurrPoint = mousePos;

			switch (msg.message)
			{
				// Starting the grab
				case  WM_LBUTTONDOWN:
					// Save the starting position
					TRACE_MSG(("grabbing start position"));
					grabStartPoint = mousePos;
					grabEndPoint   = mousePos;
					tracking	   = TRUE;
					break;

				// Completing the rectangle
				case WM_LBUTTONUP:
				{
					tracking	   = FALSE;
					// Check that there is an area to capture
					TRACE_MSG(("grabbing end position"));
					if (EqualPoint(grabStartPoint, grabCurrPoint))
					{
						TRACE_MSG(("start == end, skipping grab"));
						goto GrabAreaCleanup;
					}

					// Erase the last tracking rectangle
					if (!EqualPoint(grabStartPoint, grabEndPoint))
					{	
						rect.top = grabStartPoint.y;
						rect.left = grabStartPoint.x;
						rect.bottom = grabEndPoint.y;
						rect.right = grabEndPoint.x;
						pRectangle->SetRect(&rect);
						pRectangle->SetBoundsRect(&rect);
						pRectangle->Draw(hDC);
					}

					// Update the rectangle object
					rect.top = grabStartPoint.y;
					rect.left = grabStartPoint.x;
					rect.bottom = grabCurrPoint.y;
					rect.right = grabCurrPoint.x;
					pRectangle->SetRect(&rect);
					pRectangle->SetBoundsRect(&rect);
					pRectangle->GetBoundsRect(lprect);

					// We are done
					goto GrabAreaCleanup;
				}
				break;

				// Continuing the rectangle
				case WM_MOUSEMOVE:
					if (tracking)
					{
						TRACE_MSG(("tracking grab"));

						// Erase the last tracking rectangle
						if (!EqualPoint(grabStartPoint, grabEndPoint))
						{
							rect.top = grabStartPoint.y;
							rect.left = grabStartPoint.x;
							rect.bottom = grabEndPoint.y;
							rect.right = grabEndPoint.x;
							pRectangle->SetRect(&rect);
							pRectangle->SetBoundsRect(&rect);
							pRectangle->Draw(hDC);
						}

						// Draw the new rectangle
						if (!EqualPoint(grabStartPoint, grabCurrPoint))
						{
							// Save the new box end point
							grabEndPoint = grabCurrPoint;

							// Draw the rectangle
							TRACE_MSG( ("grabStartPoint = %d,%d",
								grabStartPoint.x, grabStartPoint.y) );
							TRACE_MSG( ("grabEndPoint = %d,%d",
								grabEndPoint.x, grabEndPoint.y) );

							rect.top = grabStartPoint.y;
							rect.left = grabStartPoint.x;
							rect.bottom = grabEndPoint.y;
							rect.right = grabEndPoint.x;
							pRectangle->SetRect(&rect);
							pRectangle->SetBoundsRect(&rect);
							pRectangle->Draw(hDC);
						}
					}
					break;
			}
		}
		// Cancel if ESCAPE is pressed.
		else if (::PeekMessage(&msg, NULL, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE))
		{
			if( ((msg.message == WM_KEYUP)||(msg.message == WM_SYSKEYUP))&&
				(msg.wParam == VK_ESCAPE) )
			{
				TRACE_MSG(("grab cancelled by ESC"));

				// Erase the last tracking rectangle
				if (!EqualPoint(grabStartPoint, grabEndPoint))
				{
					rect.top = grabStartPoint.y;
					rect.left = grabStartPoint.x;
					rect.bottom = grabEndPoint.y;
					rect.right = grabEndPoint.x;
					pRectangle->SetRect(&rect);
					pRectangle->Draw(hDC);
				}
				break;
			}
		}
	}

GrabAreaCleanup:

	// Release the device context (if we have it)
	if (hDC != NULL)
	{
		::ReleaseDC(hDesktopWnd, hDC);
	}


	delete pRectangle;
}



//
//
// Function:    AddCapturedImage
//
// Purpose:     Add a bitmap to the contents (adding a new page for it
//              if necessary).
//
//
void WbMainWindow::AddCapturedImage(BitmapObj* dib)
{
    // Position the grabbed object at the top left of the currently visible
    // area.
    RECT    rcVis;
    m_drawingArea.GetVisibleRect(&rcVis);
    dib->MoveTo(rcVis.left, rcVis.top);

	dib->Draw();

    // Add the new grabbed bitmap
	dib->AddToWorkspace();
}

//
//
// Function:    OnPrint
//
// Purpose:     Print the contents of the drawing pane
//
//
LRESULT WbMainWindow::OnPrint()
{
    BOOL        bPrintError = FALSE;
    PRINTDLG    pd;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnPrint");

    if (!IsIdle())
    {
        // post an error message indicating the whiteboard is busy
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_WB, WB_RC_BUSY);
        return S_FALSE;
    }

    //
    // Initialize the PRINTDLG structure
    //
    ZeroMemory(&pd, sizeof(pd));
    pd.lStructSize      = sizeof(pd);
    pd.hInstance        = g_hInstance;
    pd.hwndOwner        = m_hwnd;
    pd.Flags            = PD_ALLPAGES | PD_RETURNDC | PD_PAGENUMS |
        PD_HIDEPRINTTOFILE | PD_NOSELECTION;

    pd.nMinPage         = 1;
    pd.nMaxPage         = (WORD)g_numberOfWorkspaces;
    pd.nFromPage        = pd.nMinPage;
    pd.nToPage          = pd.nMaxPage;

    // Put up the COMMDLG print dialog
    if (::PrintDlg(&pd))
    {
        int nStartPage, nEndPage;

        // Get the start and end page numbers to be printed
        if (pd.Flags & PD_PAGENUMS)
        {
            nStartPage  = pd.nFromPage;
            nEndPage    = pd.nToPage;
        }
        else
        {
            nStartPage  = pd.nMinPage;
            nEndPage    = pd.nMaxPage;
        }

        // Check whether any pages are to be printed
        if (nStartPage <= pd.nMaxPage)
        {
            // Ensure that the start and end pages lie within range.
            nStartPage = max(nStartPage, pd.nMinPage);
            nEndPage = min(nEndPage, pd.nMaxPage);

            // Get the printer and output port names.
            // These are written to the dialog for the user to see
            // in the OnInitDialog member.
            TCHAR szDeviceName[2*_MAX_PATH];
            LPDEVNAMES lpDev;

            // Device name
            if (pd.hDevNames == NULL)
            {
                szDeviceName[0] = 0;
            }
            else
            {
                lpDev = (LPDEVNAMES)::GlobalLock(pd.hDevNames);

                wsprintf(szDeviceName, "%s %s",
                    (LPCTSTR)lpDev + lpDev->wDeviceOffset,
                    (LPCTSTR)lpDev + lpDev->wOutputOffset);

                ::GlobalUnlock(pd.hDevNames);
            }

            //
            // Tell the printer we are starting the print.
            // Note that the printer object handles the cancellation dialog.
            WbPrinter printer(szDeviceName);

            TCHAR szJobName[_MAX_PATH];
            ::LoadString(g_hInstance, IDS_PRINT_NAME, szJobName, _MAX_PATH);

            int nPrintResult = printer.StartDoc(pd.hDC, szJobName, nStartPage);
            if (nPrintResult < 0)
            {
                WARNING_OUT(("Print result %d", nPrintResult));
                bPrintError = TRUE;
            }
            else
            {
                // Find out how many copies to print
                int copyNum;

                copyNum = 0;
                while ((copyNum < pd.nCopies) && !bPrintError)
                {
                    // Loop through all pages
                    int nPrintPage = 0;

					WBPOSITION pos;
					WorkspaceObj * pWorkspace = NULL;
					pos = g_pListOfWorkspaces->GetHeadPosition();

					while(pos)
					{
						pWorkspace = (WorkspaceObj*) g_pListOfWorkspaces->GetNext(pos);
						nPrintPage++;

						if (nPrintPage >= nStartPage &&  nPrintPage <= nEndPage	// We are in the range
							&& pWorkspace && pWorkspace->GetHead() != NULL)		// is there anything in the workspace
						{
                            // Tell the printer we are starting a new page
                            printer.StartPage(pd.hDC, nPrintPage);
                            if (!printer.Error())
                            {
                                RECT    rectArea;

                                rectArea.left = 0;
                                rectArea.top = 0;
                                rectArea.right = DRAW_WIDTH;
                                rectArea.bottom = DRAW_HEIGHT;

                                // Print the page
                                PG_Print(pWorkspace, pd.hDC, &rectArea);

                                // Inform the printer that the page is complete
                                printer.EndPage(pd.hDC);
                            }
                            else
                            {
                                bPrintError = TRUE;
                                break;
                            }
                        }
                    }

                    copyNum++;
                }

                // The print has completed
                nPrintResult = printer.EndDoc(pd.hDC);
                if (nPrintResult < 0)
                {
                    WARNING_OUT(("Print result %d", nPrintResult));
                    bPrintError = TRUE;
                }

                // reset the error if the user cancelled the print
                if (printer.Aborted())
                {
                    WARNING_OUT(("User cancelled print"));
                    bPrintError = FALSE;
                }
            }
        }
    }

    // Inform the user if an error occurred
    if (bPrintError)
    {
        // display a message informing the user the job terminated
        ::PostMessage(m_hwnd, WM_USER_DISPLAY_ERROR, WBFE_RC_PRINTER, 0);
    }

    //
    // Cleanup the hDevMode, hDevNames, and hdc blocks if allocated
    //
    if (pd.hDevMode != NULL)
    {
        ::GlobalFree(pd.hDevMode);
        pd.hDevMode = NULL;
    }

    if (pd.hDevNames != NULL)
    {
        ::GlobalFree(pd.hDevNames);
        pd.hDevNames = NULL;
    }

    if (pd.hDC != NULL)
    {
        ::DeleteDC(pd.hDC);
        pd.hDC = NULL;
    }

	return S_OK;
}

//
//
// Function:	InsertPageAfter
//
// Purpose:	 Insert a new page after the specified page.
//
//
void WbMainWindow::InsertPageAfter(WorkspaceObj * pCurrentWorkspace)
{
	//
	// Create a standard workspace
	//
	if(g_numberOfWorkspaces < WB_MAX_WORKSPACES)
	{
		//
		// If we were editing text
		//
		if (g_pDraw->TextEditActive())
	   	{
			g_pDraw->EndTextEntry(TRUE);
		}
		
		BOOL bRemote = FALSE;
		if(m_pLocalRemotePointer)
		{
			bRemote = TRUE;
			OnRemotePointer();
		}

		WorkspaceObj * pObj;
		DBG_SAVE_FILE_LINE
		pObj = new WorkspaceObj();
		pObj->AddToWorkspace();

		if(bRemote)
		{
			OnRemotePointer();
		}
	}
}

//
//
// Function:    OnInsertPageAfter
//
// Purpose:     Insert a new page after the current page
//
//
LRESULT WbMainWindow::OnInsertPageAfter()
{
    // Insert the new page
    InsertPageAfter(g_pCurrentWorkspace);
    return S_OK;
}

//
//
// Function:    OnDeletePage
//
// Purpose:     Delete the current page
//
//
LRESULT WbMainWindow::OnDeletePage()
{

	//
	// Clear the page
	//
	if(g_pListOfWorkspaces->GetHeadPosition() == g_pListOfWorkspaces->GetTailPosition())
	{
		OnClearPage(TRUE);
	}
	else
	{
		LRESULT result = OnClearPage(FALSE);
		//
		// If we had more pages move to the previous page
		//
		if(result == IDYES)
		{
			//
			// Deleted locally
			//
			g_pCurrentWorkspace->DeletedLocally();

			//
			// If the text editor is active
			//
			if(m_drawingArea.TextEditActive())
			{
				m_drawingArea.DeactivateTextEditor();
			}


			BOOL remotePointerIsOn = FALSE;
			if(g_pMain->m_pLocalRemotePointer)
			{
				g_pMain->OnRemotePointer();
				remotePointerIsOn = TRUE;
			}

			//
			// Remove the workspace and point current to the correct one.
			//
			WorkspaceObj * pWorkspace = RemoveWorkspace(g_pCurrentWorkspace);
			g_pMain->GoPage(pWorkspace);

			if(remotePointerIsOn)
			{
				g_pMain->OnRemotePointer();
			}

		
		}
	}
	return S_OK;
}

//
//
// Function:    OnRemotePointer
//
// Purpose:     Create a remote pointer
//
//
LRESULT WbMainWindow::OnRemotePointer(void)
{

	if(m_pLocalRemotePointer == NULL)
	{
		BitmapObj* remotePtr;

		DBG_SAVE_FILE_LINE
		m_pLocalRemotePointer = new BitmapObj(TOOLTYPE_REMOTEPOINTER);


		if(g_pMain->m_localRemotePointerPosition.x < 0 && g_pMain->m_localRemotePointerPosition.y < 0 )
		{
			// Position the remote pointer in center of the drawing area
			RECT    rcVis;
			m_drawingArea.GetVisibleRect(&rcVis);
			m_localRemotePointerPosition.x = rcVis.left + (rcVis.right - rcVis.left)/2;
			m_localRemotePointerPosition.y =  rcVis.top + (rcVis.bottom - rcVis.top)/2;
		}
		m_pLocalRemotePointer->MoveTo(m_localRemotePointerPosition.x ,m_localRemotePointerPosition.y);

		COLORREF color;
		color = g_crDefaultColors[g_MyIndex + 1];
		m_pLocalRemotePointer->CreateColoredIcon(color);
		
		//
		// If we couldn't create an image for teh remote pointer bitmap
		//
		if(m_pLocalRemotePointer->m_lpbiImage == NULL)
		{
			delete m_pLocalRemotePointer;
			m_pLocalRemotePointer = NULL;
			return S_FALSE;
		}
		m_pLocalRemotePointer->Draw(FALSE);

	    // Add the new grabbed bitmap
		m_pLocalRemotePointer->AddToWorkspace();

	    m_TB.PushDown(IDM_REMOTE);
	    CheckMenuItem(IDM_REMOTE);

	    // Start the timer for updating the graphic (this is only for updating
	    // the graphic when the user stops moving the pointer but keeps the
	    // mouse button down).
	    ::SetTimer(g_pDraw->m_hwnd, TIMER_REMOTE_POINTER_UPDATE, DRAW_REMOTEPOINTERDELAY, NULL);

	}
	else
	{
       ::KillTimer(g_pDraw->m_hwnd, TIMER_REMOTE_POINTER_UPDATE);
		m_pLocalRemotePointer->DeletedLocally();
		g_pCurrentWorkspace->RemoveT126Object(m_pLocalRemotePointer);
		m_pLocalRemotePointer = NULL;
	    m_TB.PopUp(IDM_REMOTE);
		UncheckMenuItem(IDM_REMOTE);
	}
	
	return S_OK;
}


//
//
// Function:    OnSync
//
// Purpose:     Sync or unsync the Whiteboard with other users
//
//
LRESULT WbMainWindow::OnSync(void)
{
	// Determine whether we are currently synced
	if (m_drawingArea.IsSynced())
    {
		// currently synced, so unsync
		Unsync();
	}
	else
	{
		// currently unsynced, so sync
		Sync();
	}
	m_drawingArea.SetSync(!m_drawingArea.IsSynced());
	EnableToolbar( TRUE );
	m_AG.EnablePageCtrls(TRUE);

	return S_OK;
}



//
//
// Function:    Sync
//
// Purpose:     Sync the Whiteboard with other users
//
//
void WbMainWindow::Sync(void)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Sync");
    m_TB.PushDown(IDM_SYNC);
    CheckMenuItem(IDM_SYNC);
	GotoPage(g_pConferenceWorkspace);
} // Sync



//
//
// Function:    Unsync
//
// Purpose:     Unsync the Whiteboard with other users
//
//
void WbMainWindow::Unsync(void)
{
	MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::Unsync");
	m_TB.PopUp(IDM_SYNC);
    UncheckMenuItem(IDM_SYNC);
}  // Unsync



LRESULT WbMainWindow::OnConfShutdown( WPARAM, LPARAM )
{
    if (OnQueryEndSession())
    {
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0); // do close immediately
        //    :
        // DON'T DO ANYTHING else at this point except for exit.
        return( 0 );// tell conf ok to shutdown
    }
    else
        return( (LRESULT)g_cuEndSessionAbort ); // don't shutdown
}


//
//
// Function:    OnQueryEndSession
//
// Purpose:     Ensure user is prompted to save changes when windows is
//              ended.
//
//
LRESULT WbMainWindow::OnQueryEndSession(void)
{
    HWND hwndPopup;

    if ((hwndPopup = ::GetLastActivePopup(m_hwnd)) != m_hwnd)
    {
        ::Message(NULL,  IDS_DEFAULT, IDS_CANTCLOSE );
        ::BringWindowToTop(hwndPopup);
        return( FALSE );
    }

    // If changes are required then prompt the user to save
    int iDoNew = IDYES;

    if (IsIdle())
    {
        iDoNew = QuerySaveRequired(TRUE);
        if (iDoNew == IDYES)
        {
            // Save the changes
            iDoNew = (int)OnSave(FALSE);
        }
    }

    // remember what we did so OnClose can act appropriately
    m_bQuerySysShutdown = (iDoNew != IDCANCEL);

    // If the user did not cancel, let windows exit
    return( m_bQuerySysShutdown );
}

//
//
// Function:    UnlockDrawingArea
//
// Purpose:     Unlock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::UnlockDrawingArea()
{
	m_drawingArea.Unlock();

    {
        EnableToolbar( TRUE );
	    m_AG.EnablePageCtrls(TRUE);

    }

    //
    // Show the tool attributes group.
    //
    m_AG.DisplayTool(m_pCurrentTool);
}



//
//
// Function:    LockDrawingArea
//
// Purpose:     Lock the drawing area and enable the appropriate buttons
//
//
//
void WbMainWindow::LockDrawingArea()
{
    m_drawingArea.Lock();

	if(g_pNMWBOBJ->m_LockerID != g_MyMemberID)
	{

		// Disable tool-bar buttons that cannot be used while locked
		EnableToolbar( FALSE );

		m_AG.EnablePageCtrls(FALSE);

		//
		// Hide the tool attributes
		//
		if (m_WG.m_hwnd != NULL)
		{
	        ::ShowWindow(m_WG.m_hwnd, SW_HIDE);
	    }
	    m_AG.Hide();
	}
}


void WbMainWindow::EnableToolbar( BOOL bEnable )
{
    if (bEnable)
    {
        m_TB.Enable(IDM_SELECT);

        // don't allow text editing in zoom mode
        if( m_drawingArea.Zoomed() )
            m_TB.Disable(IDM_TEXT);
        else
            m_TB.Enable(IDM_TEXT);

        m_TB.Enable(IDM_PEN);
        m_TB.Enable(IDM_HIGHLIGHT);

        m_TB.Enable(IDM_LINE);
        m_TB.Enable(IDM_ZOOM);
        m_TB.Enable(IDM_BOX);
        m_TB.Enable(IDM_FILLED_BOX);
        m_TB.Enable(IDM_ELLIPSE);
        m_TB.Enable(IDM_FILLED_ELLIPSE);
        m_TB.Enable(IDM_ERASER);

        m_TB.Enable(IDM_GRAB_AREA);
        m_TB.Enable(IDM_GRAB_WINDOW);

		//
		// If we are not synced we can't lock the other nodes
		//
		if(g_pDraw->IsSynced())
		{
			m_TB.PushDown(IDM_SYNC);
	        m_TB.Enable(IDM_LOCK);
	    }
	    else
	    {
			m_TB.PopUp(IDM_SYNC);
	        m_TB.Disable(IDM_LOCK);
	    }

		if(m_drawingArea.IsLocked())
		{
	        m_TB.Disable(IDM_SYNC);
	    }
	    else
	    {
	        m_TB.Enable(IDM_SYNC);
	    }

        m_TB.Enable(IDM_REMOTE);

    }
    else
    {
        m_TB.Disable(IDM_SELECT);
        m_TB.Disable(IDM_PEN);
        m_TB.Disable(IDM_HIGHLIGHT);
        m_TB.Disable(IDM_TEXT);
        m_TB.Disable(IDM_LINE);
        m_TB.Disable(IDM_ZOOM);
        m_TB.Disable(IDM_BOX);
        m_TB.Disable(IDM_FILLED_BOX);
        m_TB.Disable(IDM_ELLIPSE);
        m_TB.Disable(IDM_FILLED_ELLIPSE);
        m_TB.Disable(IDM_ERASER);
        m_TB.Disable(IDM_REMOTE);

        m_TB.Disable(IDM_GRAB_AREA);
        m_TB.Disable(IDM_GRAB_WINDOW);
        m_TB.Disable(IDM_LOCK);
        m_TB.Disable(IDM_SYNC);
    }
}




//
//
// Function:    UpdatePageButtons
//
// Purpose:     Enable or disable the page buttons, according to the current
//              state.
//
//
//
void WbMainWindow::UpdatePageButtons()
{
	BOOL bEnable = TRUE;
	if(!g_pCurrentWorkspace)
	{
		g_numberOfWorkspaces = 0;
		bEnable = FALSE;
	}
	else
	{
		//
		// Can we update this workspace
		//
		bEnable = g_pCurrentWorkspace->GetUpdatesEnabled();

		//
		// If it is locked, is it locked by us
		//
		if(!bEnable)
		{
			bEnable |= g_pNMWBOBJ->m_LockerID == g_MyMemberID;
		}
	}


    m_AG.EnablePageCtrls(bEnable);

	WBPOSITION pos;
	WorkspaceObj * pWorkspace;
	UINT pageNumber = 0;

	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pageNumber++;
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		if(g_pCurrentWorkspace == pWorkspace)
		{
			break;
		}
	}

    m_AG.SetCurrentPageNumber(pageNumber);
    m_AG.SetLastPageNumber(g_numberOfWorkspaces);

    EnableToolbar( bEnable );
}

//
//
// Function:    CancelLoad
//
// Purpose:     Cancel any load in progress
//
//
void WbMainWindow::CancelLoad(BOOL bReleaseLock)
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::CancelLoad");

    // reset file name to untitled
    ZeroMemory(m_strFileName, sizeof(m_strFileName));

    // reset the whiteboard substate
    SetSubstate(SUBSTATE_IDLE);
}

//
//
// Function:    IsIdle
//
// Purpose:     Returns true if the main window is idle (in a call and not
//              loading a file/performing a new)
//
//
BOOL WbMainWindow::IsIdle()
{

    return(m_uiSubState == SUBSTATE_IDLE);
}

//
//
// Function:    SetSubstate
//
// Purpose:     Sets the substate, informing the page sorter dialog of the
//              change, if necessary.
//
//
void WbMainWindow::SetSubstate(UINT newSubState)
{
  MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::SetSubstate");

  // substate only valid if in a call
  if (newSubState != m_uiSubState)
  {
	DBG_SAVE_FILE_LINE
    m_uiSubState = newSubState;

    // Trace the substate change
    switch (m_uiSubState)
    {
      case SUBSTATE_IDLE:
        TRACE_DEBUG(("set substate to IDLE"));
        break;

      case SUBSTATE_LOADING:
        TRACE_DEBUG(("set substate to LOADING"));
        break;

      case SUBSTATE_SAVING:
        TRACE_DEBUG(("set substate to SAVING"));
        break;

      case SUBSTATE_NEW_IN_PROGRESS:
        TRACE_DEBUG(("set substate to NEW_IN_PROGRESS"));
        break;

      default:
        ERROR_OUT(("Unknown substate %hd",m_uiSubState));
        break;
    }

    // update the page buttons (may have become enabled/disabled)
    UpdatePageButtons();
  }

}

//
//
// Function:    PositionUpdated
//
// Purpose:     Called when the drawing area position has changed.
//              change, if necessary.
//
//
void WbMainWindow::PositionUpdated()
{
	RECT rectDraw;
    m_drawingArea.GetVisibleRect(&rectDraw);
	g_pDraw->InvalidateSurfaceRect(&rectDraw,FALSE);
}

//
//
// Function : OnEndSession
//
// Purpose  : Called when Windows is exiting
//
//
void WbMainWindow::OnEndSession(BOOL bEnding)
{
    if (bEnding)
    {
        ::PostQuitMessage(0);
    }
    else
    {
        m_bQuerySysShutdown = FALSE; // never mind, cancel OnClose special handling
    }
}


//
// Function: OnCancelMode()
//
// Purpose:  Called whenever a WM_CANCELMODE message is sent to the frame
//           window.
//           WM_CANCELMODE is sent when another app or dialog receives the
//           input focus.  The frame simply records that a WM_CANCELMODE
//           message has been sent.  This fact is used by the SelectWindow
//           code to determine if it should cancel the selecting of a
//           window
//
//
void WbMainWindow::OnCancelMode()
{
    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::OnCancelMode");

    m_cancelModeSent = TRUE;

    //
    // Note: Not passed to the default handler as the default action on
    //       WM_CANCELMODE is to release mouse capture - we shall do this
    //       explicitly.
    //


    // blow off any dragging that might be in progress (bug 573)
    POINT   pt;
    ::GetCursorPos( &pt );
    ::ScreenToClient(m_drawingArea.m_hwnd, &pt);
    ::SendMessage(m_drawingArea.m_hwnd, WM_LBUTTONUP, 0, MAKELONG( pt.x, pt.y ) );

}



void WbMainWindow::LoadCmdLine(LPCSTR szFilename)
{
    int iOnSave;

    if (szFilename && *szFilename)
    {
        if( UsersMightLoseData( NULL, NULL ) ) // bug NM4db:418
            return;

        // Don't prompt to save file if we're already loading
        if (m_uiSubState != SUBSTATE_LOADING )
        {
            // Check whether there are changes to be saved
            iOnSave = QuerySaveRequired(TRUE);
        }
        else
        {
            return;
        }

        if (iOnSave == IDYES)
        {
            // User wants to save the drawing area contents
            int iResult = (int)OnSave(TRUE);

            if( iResult == IDOK )
            {
            }
            else
            {
                // cancelled out of save, so cancel the open operation
                return;
            }
        }

        // load filename
        if( iOnSave != IDCANCEL )
            LoadFile(szFilename);
    }
}



//
// OnNotify()
// Handles TTN_NEEDTEXTA and TTN_NEEDTEXTW
//
void WbMainWindow::OnNotify(UINT id, NMHDR * pNM)
{
    UINT    nID;
    HWND    hwnd = NULL;
    POINT ptCurPos;
    UINT  nTipStringID;

    if (!pNM)
        return;

    if (pNM->code == TTN_NEEDTEXTA)
    {
        TOOLTIPTEXTA *pTA = (TOOLTIPTEXTA *)pNM;

        // get id and hwnd
        if( pTA->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID);
        if (nTipStringID == 0)
            return;

        // give it to em
        pTA->lpszText = MAKEINTRESOURCE( nTipStringID );
        pTA->hinst = g_hInstance;
    }
    else if (pNM->code == TTN_NEEDTEXTW)
    {
        TOOLTIPTEXTW *pTW = (TOOLTIPTEXTW *)pNM;

        // get id and hwnd
        if( pTW->uFlags & TTF_IDISHWND )
        {
            // idFrom is actually the HWND of the tool
            hwnd = (HWND)pNM->idFrom;
            nID = ::GetDlgCtrlID(hwnd);
        }
        else
        {
            nID = (UINT)pNM->idFrom;
        }

        // get tip string id
        nTipStringID = GetTipId(hwnd, nID );
        if (nTipStringID == 0)
            return;

        // give it to em
        pTW->lpszText = (LPWSTR) MAKEINTRESOURCE( nTipStringID );
        pTW->hinst = g_hInstance;
    }
}




//
// GetTipId()
// Finds the tooltip for a control in Whiteboard
//
UINT WbMainWindow::GetTipId(HWND hwndTip, UINT nID)
{
    WbTool *  pTool;
    BOOL      bCheckedState;
    int       nTipID;
    int       nTipStringID;
    int       i;

    // find tip stuff relevant for nID
    nTipID = -1;
    for( i=0; i<((sizeof g_tipIDsArray)/(sizeof (TIPIDS) )); i++ )
    {
        if( g_tipIDsArray[i].nID == nID )
        {
            nTipID = i;
            break;
        }
    }

    // valid?
    if( nTipID < 0 )
        return( 0 );

    // get checked state
    switch( g_tipIDsArray[ nTipID ].nCheck )
    {
        case TB:
            bCheckedState =
                (::SendMessage(m_TB.m_hwnd, TB_ISBUTTONCHECKED, nID, 0) != 0);
            break;

        case BT:
            if (hwndTip != NULL)
            {
                bCheckedState =
                    (::SendMessage(hwndTip, BM_GETSTATE, 0, 0) & 0x0003) == 1;
            }
            else
                bCheckedState = FALSE;

            break;

        case NA:
        default:
            bCheckedState = FALSE;
            break;
    }

    // get tip string id
    if( bCheckedState )
        nTipStringID = g_tipIDsArray[ nTipID ].nDownTipID;
    else
        nTipStringID = g_tipIDsArray[ nTipID ].nUpTipID;

    // done
    return( nTipStringID );
}



// gets default path if no saves or opens have been done yet
// Returns FALSE if last default should be reused
BOOL WbMainWindow::GetDefaultPath(LPTSTR csDefaultPath , UINT size)
{
	DWORD dwType;
	DWORD dwBufLen = size;
	HKEY  hDefaultKey = NULL;
	BOOL bRet =FALSE;

	if( !lstrlen(m_strFileName) )
	{
		// a name has not been picked yet in this session, use path
		// to "My Documents"
		if( (RegOpenKeyEx( HKEY_CURRENT_USER,
			"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",
			0,
			KEY_READ,
			&hDefaultKey )
			!= ERROR_SUCCESS) ||
			(RegQueryValueEx( hDefaultKey,
			"Personal",
			NULL,
			&dwType,
			(BYTE *)csDefaultPath,
			&dwBufLen )
			!= ERROR_SUCCESS))
		{
			// reg failed, use desktop
			LPITEMIDLIST pidl;
			if(SUCCEEDED(SHGetSpecialFolderLocation(GetDesktopWindow(),CSIDL_DESKTOPDIRECTORY,&pidl)))
			{
				bRet= SHGetPathFromIDList(pidl,csDefaultPath);
			}

			if( hDefaultKey != NULL )
				RegCloseKey( hDefaultKey );
		}
		else
		{
			bRet = TRUE;
		}
	}
	return bRet;
}





void WbMainWindow::OnSysColorChange( void )
{
    if (g_pCurrentWorkspace != NULL)
    {
        PG_ReinitPalettes();

        ::InvalidateRect(m_hwnd, NULL, TRUE );
        ::UpdateWindow(m_hwnd);
    }

    m_TB.RecolorButtonImages();
    m_AG.RecolorButtonImages();
}



//
// posts a do-you-wana-do-that message if other users are in the conference
//
BOOL WbMainWindow::UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd )
{
	if (g_pNMWBOBJ->GetNumberOfMembers() > 0)
	{
		if( pbWasPosted != NULL )
			*pbWasPosted = TRUE;
			return( ::Message(hwnd,  IDS_DEFAULT, IDS_MSG_USERSMIGHTLOSE, MB_YESNO | MB_ICONEXCLAMATION ) != IDYES );
	}

	if( pbWasPosted != NULL )
        *pbWasPosted = FALSE;

    return( FALSE );
}


//
//
// Name:    ContentsSave
//
// Purpose: Save the contents of the WB.
//
// Returns: Error code
//
//
UINT WbMainWindow::ContentsSave(LPCSTR pFileName)
{
    UINT	result = 0;
    UINT	index;
    HANDLE	hFile;
    ULONG	cbSizeWritten;
    T126WB_FILE_HEADER  t126Header;
    WB_OBJ			endOfFile;

    MLZ_EntryOut(ZONE_FUNCTION, "WbMainWindow::ContentsSave");

    //
    // Open the file
    //
    m_hFile = CreateFile(pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        result = WB_RC_CREATE_FAILED;
        ERROR_OUT(("Error creating file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }

    //
    // Create the file header.
    //
	memcpy(t126Header.functionProfile, T126WB_FP_NAME,sizeof(T126WB_FP_NAME));
	t126Header.length = sizeof(T126WB_FILE_HEADER) + g_numberOfWorkspaces*sizeof(UINT);
	t126Header.version = T126WB_VERSION;
	t126Header.numberOfWorkspaces = g_numberOfWorkspaces;


 	//
    // Save the header
    //
    if (!WriteFile(m_hFile, (void *) &t126Header, sizeof(T126WB_FILE_HEADER), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }


	WorkspaceObj* pWorkspace;
	WBPOSITION pos;
	index = 0;

	pos = g_pListOfWorkspaces->GetHeadPosition();
	while(pos)
	{
		pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
		ASSERT(pWorkspace);


		UINT numberOfObjects = pWorkspace->EnumerateObjectsInWorkspace();


	 	//
	    // Save the number of objects in each page
    	//
	    if (!WriteFile(m_hFile, (void *) &numberOfObjects, sizeof(numberOfObjects), &cbSizeWritten, NULL))
    	{
	        result = WB_RC_WRITE_FAILED;
	        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
	        goto CleanUp;
	    }

		index++;
	}

	ASSERT(index == g_numberOfWorkspaces);


    //
    // Loop through the pages, saving each as we go
    //
    g_bSavingFile = TRUE;
	ResendAllObjects();

	//
	// The Last Object to be saved is the current workspace
	//
	g_pCurrentWorkspace->OnObjectEdit();

	//
    // If we have successfully written the contents, we write an end-of-page
    // marker to the file.
    //
    ZeroMemory(&endOfFile, sizeof(endOfFile));
    endOfFile.length = sizeof(endOfFile);
    endOfFile.type   = TYPE_T126_END_OF_FILE;

    //
    // Write the end-of-file object
    //
    if (!WriteFile(m_hFile, (void *) &endOfFile, sizeof(endOfFile), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto CleanUp;
    }


CleanUp:

    //
    // Close the file
    //
    if (m_hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hFile);
    }

    //
    // If an error occurred in saving the contents to file, and the file was
    // opened, then delete it.
    //
    if (result != 0)
    {
        //
        // If the file was opened successfully, delete it
        //
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            DeleteFile(pFileName);
        }
    }

    g_bSavingFile = FALSE;
    return(result);
}


//
//
// Name:    ObjectSave
//
// Purpose: Save a structure to file
//
// Returns: Error code
//
//
UINT WbMainWindow::ObjectSave(UINT type, LPBYTE pData, UINT length)
{
    ASSERT(m_hFile != INVALID_HANDLE_VALUE);

    UINT        result = 0;
    ULONG       cbSizeWritten;
	WB_OBJ objectHeader;

	objectHeader.length = sizeof(WB_OBJ) + length;
	objectHeader.type = type;

	//
	// Save the Header
	//
    if (! WriteFile(m_hFile, (void *) &objectHeader, sizeof(WB_OBJ), &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing length to file, win32 err=%d", GetLastError()));
        goto bail;
    }
    ASSERT(cbSizeWritten == sizeof(WB_OBJ));

    //
    // Save the object data
    //
    if (! WriteFile(m_hFile, pData, length, &cbSizeWritten, NULL))
    {
        result = WB_RC_WRITE_FAILED;
        ERROR_OUT(("Error writing data to file, win32 err=%d", GetLastError()));
        goto bail;
    }
    ASSERT(cbSizeWritten == length);

bail:
  return result;
}

//
//
// Function:    ContentsLoad
//
// Purpose:     Load a file and delete the current workspaces
//
//
UINT WbMainWindow::ContentsLoad(LPCSTR pFileName)
{
    BOOL        bRemote;
    UINT        result = 0;
	PT126WB_FILE_HEADER_AND_OBJECTS pHeader = NULL;

    //
    // Validate the file, and get a handle to it.
    // If there is an error, then no file handle is returned.
    //
	pHeader = ValidateFile(pFileName);
    if (pHeader == NULL)
    {
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }
    delete pHeader;

    //
    // Remember if remote pointer is on
    //
    bRemote = FALSE;
    if (m_pLocalRemotePointer)
    {
        // Remove remote pointer from pages
        bRemote = TRUE;
        OnRemotePointer();
    }

	//
	// Just before loading anything delete all the workspaces
	//
	::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
	DeleteAllWorkspaces(TRUE);

	result = ObjectLoad();

    //
    // Put remote pointer back if it was on
    //
    if (bRemote)
    {
        OnRemotePointer();
    }

	//
	// The workspaces may have being saved as locked
	// Unlock all workspaces, and make sure the drawing area is unlocked
	//
	TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
	UnlockDrawingArea();

	ResendAllObjects();

bail:

	if(INVALID_HANDLE_VALUE != m_hFile)
	{
		CloseHandle(m_hFile);
	}
    return(result);


}


//
//
// Function:    ObjectLoad
//
// Purpose:     Load t126 ASN1 objects from the file
//
//
UINT WbMainWindow::ObjectLoad(void)
{
	UINT		result = 0;
	LPSTR 		pData = NULL;
       UINT        length;

	DWORD		cbSizeRead;
	BOOL readFileOk = TRUE;
	WB_OBJ objectHeader;

	while(readFileOk)
	{

		//
		// Read objects header info
		//
		readFileOk = ReadFile(m_hFile, (void *) &objectHeader, sizeof(WB_OBJ), &cbSizeRead, NULL);
		if ( !readFileOk )
    	{
        	//
	        // Make sure we return a sensible error.
	        //
	        ERROR_OUT(("reading object length, win32 err=%d, length=%d", GetLastError(), sizeof(WB_OBJ)));
	        result = WB_RC_BAD_FILE_FORMAT;
	        goto bail;
	    }
		ASSERT(cbSizeRead ==  sizeof(WB_OBJ));

		//
		// Read the object's raw data
		//
		length = objectHeader.length - sizeof(WB_OBJ);
		DBG_SAVE_FILE_LINE
	    pData = (LPSTR)new BYTE[length];
	
		readFileOk = ReadFile(m_hFile, (LPBYTE) pData, length, &cbSizeRead, NULL);
    	
    	if(! readFileOk)
	    {
	        //
    	    // Make sure we return a sensible error.
        	//
	        ERROR_OUT(("Reading object from file: win32 err=%d, asked for %d got %d bytes", GetLastError(), length, cbSizeRead));
	        result = WB_RC_BAD_FILE_FORMAT;
    	    goto bail;
	    }
		ASSERT(cbSizeRead == length);

		//
		// It is an ASN1 t126 object
		//
		if(objectHeader.type == TYPE_T126_ASN_OBJECT)
		{
			//
			// Try decoding and adding it to the workspace
			//
			if(!T126_MCSSendDataIndication(length, (LPBYTE)pData, g_MyMemberID, TRUE))
		   	{
				result = WB_RC_BAD_FILE_FORMAT;
		   	    goto bail;
			}
		}
		//
		// If it is an end of file do a last check
		//
		else if(objectHeader.type == TYPE_T126_END_OF_FILE)
		{
			if(objectHeader.length != sizeof(WB_OBJ))
			{
				result = WB_RC_BAD_FILE_FORMAT;
			}
			goto bail;
		}
		else
		{
			ERROR_OUT(("Don't know object type =%d , size=%d  ; skipping to next object", objectHeader.type, length));
		}

	    delete [] pData;
	    pData = NULL;
    }


bail:

	if(pData)
	{
		delete [] pData;
	}
	
    return(result);
}


//
//
// Function:    ValidateFile
//
// Purpose:     Open a T126 file and check if it is valid, if it is the it will
//				return a pointer to the header structure
//
//
PT126WB_FILE_HEADER_AND_OBJECTS  WbMainWindow::ValidateFile(LPCSTR pFileName)
{
    UINT            result = 0;
    PT126WB_FILE_HEADER  pFileHeader = NULL;
	PT126WB_FILE_HEADER_AND_OBJECTS  pCompleteFileHeader = NULL;
    UINT            length;
    ULONG           cbSizeRead;
    BOOL            fileOpen = FALSE;


	DBG_SAVE_FILE_LINE
	pFileHeader = new T126WB_FILE_HEADER[1];

	if(pFileHeader == NULL)
	{
        WARNING_OUT(("Could not allocate memory to read the file header opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        goto bail;
	}

    //
    // Open the file
    //
    m_hFile = CreateFile(pFileName, GENERIC_READ, 0, NULL,
                            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (m_hFile == INVALID_HANDLE_VALUE)
    {
        WARNING_OUT(("Error opening file, win32 err=%d", GetLastError()));
        result = WB_RC_CREATE_FAILED;
        goto bail;
    }

    //
    // Show that we have opened the file successfully
    //
    fileOpen = TRUE;

    //
    // Read the file header
    //
    if (! ReadFile(m_hFile, (void *) pFileHeader, sizeof(T126WB_FILE_HEADER), &cbSizeRead, NULL))
    {
        WARNING_OUT(("Error reading file header, win32 err=%d", GetLastError()));
        result = WB_RC_READ_FAILED;
        goto bail;
    }

    if (cbSizeRead != sizeof(T126WB_FILE_HEADER))
    {
        WARNING_OUT(("Could not read file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

    //
    // Validate the file header
    //
    if (memcmp(pFileHeader->functionProfile, T126WB_FP_NAME, sizeof(T126WB_FP_NAME)))
    {
        WARNING_OUT(("Bad function profile in file header"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

	//
	// Check for version
	//
	if( pFileHeader->version < T126WB_VERSION)
	{
        WARNING_OUT(("Bad version number"));
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
	}
	DBG_SAVE_FILE_LINE
	pCompleteFileHeader = (PT126WB_FILE_HEADER_AND_OBJECTS) new BYTE[sizeof(T126WB_FILE_HEADER) + pFileHeader->numberOfWorkspaces*sizeof(UINT)];
	memcpy(pCompleteFileHeader, pFileHeader, sizeof(T126WB_FILE_HEADER));

    //
    // Read the rest of the file header
    //
    if(! ReadFile(m_hFile, (void *) &pCompleteFileHeader->numberOfObjects[0], pFileHeader->numberOfWorkspaces*sizeof(UINT), &cbSizeRead, NULL))
    {
		if(cbSizeRead != pFileHeader->numberOfWorkspaces)
        result = WB_RC_BAD_FILE_FORMAT;
        goto bail;
    }

		TRACE_DEBUG(("Opening file with %d workspaces", pFileHeader->numberOfWorkspaces));
#ifdef _DEBUG
		INT i;
		for(i = 0; i < (INT)pFileHeader->numberOfWorkspaces; i++)
		{
			TRACE_DEBUG(("Workspace %d contains %d objects", i+1, pCompleteFileHeader->numberOfObjects[i] ));
		}
#endif



bail:

    //
    // Close the file if there has been an error
    //
    if ( (fileOpen) && (result != 0))
    {
        CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
    }

	//
	// Delete allocated file header
	//
	if(pFileHeader)
	{
		delete [] pFileHeader;
	}

	//
	// if there was an error delete the return header
	//
	if(result != 0)
	{
		if(pCompleteFileHeader)
		{
			delete [] pCompleteFileHeader;
			pCompleteFileHeader = NULL;
		}
	}

	return pCompleteFileHeader;
}


//
//
// Function:    GetFileNameStr
//
// Purpose:     Return a plain file name string
//
//
LPSTR  WbMainWindow::GetFileNameStr(void)
{
	UINT size = 2*_MAX_FNAME;

	if(m_pTitleFileName)
	{
		delete m_pTitleFileName;
		m_pTitleFileName = NULL;
	}
	
	DBG_SAVE_FILE_LINE
	m_pTitleFileName = new TCHAR[size];
	if (!m_pTitleFileName)
    {
        ERROR_OUT(("GetWindowTitle: failed to allocate TitleFileName"));
        return(NULL);
    }

	// Set title to either the "Untitled" string, or the loaded file name
    if( (!lstrlen(m_strFileName))|| (GetFileTitle( m_strFileName, m_pTitleFileName, (WORD)size ) != 0) )
    {
		::LoadString(g_hInstance, IDS_UNTITLED , m_pTitleFileName, 2*_MAX_FNAME);
    }

	return (LPSTR)m_pTitleFileName;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\mwnd.hpp ===
//
// MWND.HPP
// Main WB Window
//
// Copyright Microsoft 1998-
//

#ifndef __MWND_HPP_
#define __MWND_HPP_

#define ARRAYSIZE(a)        (sizeof(a) / sizeof(a[0]))


#define T126WB_FP_NAME "Microsoft NetMeeting Whiteboard"
#define T126WB_VERSION 30	// for 3.0

//
// Workset type constants
//
#define TYPE_T126_ASN_OBJECT	0
#define TYPE_T126_DIB_OBJECT	1
#define TYPE_T126_TEXT_OBJECT	2
#define TYPE_T126_END_OF_FILE	1000

//
// Generic object
//
typedef struct tagWB_OBJ
{
  ULONG length;		// Total length of object
  UINT	type;		// Type of file object
} WB_OBJ;

typedef WB_OBJ*        PWB_OBJ;

//
// File header for Whiteboard format files
//
typedef struct tagT126WB_FILE_HEADER
{
  BYTE	functionProfile[sizeof(T126WB_FP_NAME)];
  UINT	length;
  UINT	version;
  UINT	numberOfWorkspaces;
} T126WB_FILE_HEADER;
typedef T126WB_FILE_HEADER *        PT126WB_FILE_HEADER;

typedef struct tagT126WB_FILE_HEADER_AND_OBJECTS
{
	T126WB_FILE_HEADER fileHeader;
	UINT	numberOfObjects[1];
}T126WB_FILE_HEADER_AND_OBJECTS;

typedef T126WB_FILE_HEADER_AND_OBJECTS* PT126WB_FILE_HEADER_AND_OBJECTS;

//
// The progress timer meter is kinda the heart beat of this thing
//
#define MAIN_PROGRESS_TIMER         1000


// Milliseconds
#define MAIN_DIALOG_DELAY           1500
#define MAIN_REGISTRATION_TIMEOUT   300000   // These are long, for modems
#define MAIN_LOCK_TIMEOUT           120000

//
// Timer IDs
//
#define TIMERID_PROGRESS_METER      4
#define TIMERID_MAXDISPLAY          10


//
// Timed dialog information
//
typedef struct tagTMDLG
{
    BOOL    bLockNotEvent;
    BOOL    bVisible;
    UINT    uiMaxDisplay;
}
TMDLG;


//				  This constant must only be defined in FAR EAST sdk
//				  since it is not in US version. In Sook Choi (Korea) says
//				  it is 40h so thats what I will use. Bug 3258.
#ifndef	CLIP_DFA_OVERRIDE
#define CLIP_DFA_OVERRIDE (0x40)
#endif


// Constants for width menu commands
#define TOOLSPOS_WIDTH      16



//
// Main state
//  STARTING      = Whiteboard just started, not ready for user input.
//                  In this state until registration dialog is cleared.
//  IN_CALL       = Whiteboard ready for input
//  ERROR_STATE   = a serious error has occurred, Whiteboard must be closed
//  JOINING       = joining a call (join call dialog is up)
//  JOINED        = Received join call indication, waiting for 'join call'
//                  dialog to be dismissed.
//  CLOSING       = Whiteboard is shutting down. Ignore all messages.
//
//
enum
{
    STARTING    = 0,
    IN_CALL,
    ERROR_STATE,
    JOINING,
    JOINED,
    CLOSING
};


//
// Substate - valid only when in call
//  IDLE            = Normal state - user can do anything permitted by
//                    current lock status.
//  LOADING         = Currently loading a file
//  NEW_IN_PROGRESS = Currently deleting contents
//
//
#define SUBSTATE_IDLE				0
#define SUBSTATE_LOADING			1
#define SUBSTATE_NEW_IN_PROGRESS	2
#define SUBSTATE_SAVING				3

//
// Capture options
//
#define CAPTURE_TO_SAME   0
#define CAPTURE_TO_NEW    1

//
// Border to be left around the checkmark in the color and width menus and
// width of items in these menus.
//
#define CHECKMARK_BORDER_X 3
#define CHECKMARK_BORDER_Y 5
#define COLOR_MENU_WIDTH   40


typedef struct tagWBFINDDIALOG
{
    HWND    hwndDialog;
    HWND    hwndOwner;
} WBFINDDIALOG;



#define MAX_FONT_SIZE       20
#define STATUSBAR_HEIGHT    (MAX_FONT_SIZE + 2*::GetSystemMetrics(SM_CYEDGE))

//
//
// Class:   WbMainWindow
//
// Purpose: Main Whiteboard window
//
//
class WbMainWindow
{

    friend LRESULT CALLBACK WbMainWindowProc(HWND, UINT, WPARAM, LPARAM);

    friend BOOL CALLBACK WbFindCurrentDialog(HWND hwnd, LPARAM);


public:
    //
    // Construction and destruction
    //
    WbMainWindow(void);
    ~WbMainWindow(void);

    BOOL    InitToolArray(void);
    void    DestroyToolArray(void);

    //
    // Initialization - display the window and its children
    //
    BOOL Open(int iCommand);
	VOID ShowWindow();	// For T126 we want to open but hide the ui


    void    OnMenuSelect(UINT uiItemID, UINT uiFlags, HMENU hSysMenu);
    void    OnCommand(UINT id, UINT code, HWND hwndCtl);
    void    OnInitMenuPopup(HMENU hMenu, UINT uiIndex, BOOL bSystem);
    void	SetMenuStates(HMENU hInitMenu);
	void 	UpdateWindowTitle(void);

    //
    // Popup context menu for drawing area
    //
    void PopupContextMenu(int x, int y);
    void UncheckMenuItem(UINT uiId);

    //
    // Check whether the application is idle (not opening or doing a new)
    //
    BOOL IsIdle(void);

	// widthbar needs access to the current tool to get the current widths
    WbTool *GetCurrentTool( void )
		{return( m_pCurrentTool );}


	BOOL IsToolBarOn( void )
		{return( m_bToolBarOn );}

	BOOL UsersMightLoseData( BOOL *pbWasPosted, HWND hwnd );

	//
	// Bring the main ui to top
	//
	void WbMainWindow::BringToFront(void);

    //
    // Update the page buttons disable/enable status
    //
    void UpdatePageButtons(void);

    //
    // Go to a specific page
    //
    void GotoPage(WorkspaceObj * pNewWorkspace, BOOL bResend = TRUE);
	void GoPage(WorkspaceObj * pNewWorkspace, BOOL bSend = TRUE);


    //
    // Handles tool tips and accelerators
    //
    BOOL    FilterMessage(MSG* pMsg);

    //
    // Global data
    //
    HWND        m_hwnd;
    WbTool *    m_ToolArray[TOOLTYPE_MAX];

    // Dropping files onto the window
    void	OnDropFiles(HDROP hDropInfo);

    //
    // HELP
    //
	LRESULT    ShowHelp();

    // Command handlers
	LRESULT OnAbout(void);
	LRESULT OnNew(void);
	LRESULT OnOpen(LPCSTR szLoadFileName = NULL);
	LRESULT OnClearPage(BOOL bClearAll = TRUE);
	LRESULT OnDelete(void);
	LRESULT OnUndelete(void);
	LRESULT OnCut(void);
	LRESULT OnCopy(void);
	LRESULT OnPaste(void);
	LRESULT OnSelectAll( void );
	LRESULT OnChooseFont(void);
	LRESULT OnToolBarToggle(void);
	LRESULT OnLock(void);
	LRESULT OnGrabWindow(void);
	LRESULT OnZoom(void);
	LRESULT OnSave(BOOL bPrompt);
	LRESULT OnPrint(void);
	LRESULT OnInsertPageAfter(void);
	LRESULT OnDeletePage(void);
	LRESULT OnGrabArea(void);
	LRESULT OnLButtonDown(void);
	LRESULT OnLButtonUp(void);
	LRESULT OnMouseMove(void);
	LRESULT OnRemotePointer(void);

	LRESULT OnSelectTool(UINT id);          // Select the current tool
	LRESULT OnSelectColor(void);            // Color changed in palette
	LRESULT OnSelectWidth(UINT id);         // Select pen width

    // Scrolling control (accessed via accelerators)
	LRESULT OnScrollAccelerator(UINT id);

    // Moving through the pages
	LRESULT OnFirstPage(void);
	LRESULT OnPrevPage(void);
	LRESULT OnNextPage(void);
	LRESULT OnLastPage(void);
	LRESULT OnGotoPage(void);
	LRESULT OnSync(void);
	void OnStatusBarToggle(void);



    // WindowProc handlers
    int     OnCreate(LPCREATESTRUCT lpcs);
    void    OnDestroy();
    void    OnClose(void);
    void    OnSize(UINT, int, int);
    void    OnSetFocus(void);
    void    OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT measureStruct);
    void    OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT drawStruct);
    void    OnGetMinMaxInfo(MINMAXINFO FAR* lpmmi);
    void    OnPaletteChanged(HWND hwndPalette);
    LRESULT OnQueryNewPalette(void);
    LRESULT OnQueryEndSession(void);
    LRESULT OnConfShutdown( WPARAM, LPARAM );
    void    OnEndSession(BOOL bEnding);
    void    OnParentNotify(UINT msg);
    LRESULT OnToolTipText(UINT, NMHDR*);

    void    OnDisplayError(WPARAM wParam, LPARAM lParam);

    void    LoadCmdLine(LPCSTR szFileName);

    // CancelMode processing
    void	OnCancelMode();
    void    OnNotify(UINT id, NMHDR* pNM);
	void	OnSysColorChange( void );

    BOOL                CLP_RenderFormat(int iFormat);

    BOOL            m_bToolBarOn;
	BitmapObj * 	m_pLocalRemotePointer;
	POINT			m_localRemotePointerPosition;

    //
    // Tool bar window
    //
    WbToolBar       m_TB;

    int             CLP_AcceptableClipboardFormat(void);


protected:
    void InvalidateActiveMenu();
    HMENU   m_hInitMenu;
    //
    // Tooltips
    //
    HWND        m_hwndToolTip;
    TOOLINFO    m_tiLastHit;
    int         m_nLastHit;

    int     OnToolHitTest(POINT pt, TOOLINFO* pTI) const;


	BOOL    m_bInitOk;

    //
    // Flag indicating that we are currently displaying a serious error
    // message.
    //
    BOOL    m_bDisplayingError;

    //
    // Domain ID of the call we are currently in
    //
    DWORD       m_dwDomain;

    //
    // Move to a given position in the page
    //
    void GotoPosition(int x, int y);

    //
    // Sync/unsync with other users.
    //
    void Sync(void);
    void Unsync(void);

    //
    // Clipboard access
    //
	BOOL 				PasteDIB( LPBITMAPINFOHEADER lpbi);
    BOOL			    CLP_Paste(void);
    BOOL                CLP_Copy(void);
    void                CLP_SaveDelayedGraphic(void);

    BOOL                CLP_RenderAllFormats(void);
    BOOL                CLP_RenderAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_DelayAllFormats(DCWbGraphic * pGraphic);
    BOOL                CLP_RenderPrivateFormat();
    BOOL                CLP_RenderPrivateSingleFormat(DCWbGraphic* pGraphic);
    BOOL                CLP_RenderAsImage();
    BOOL                CLP_RenderAsText();
    BOOL                CLP_RenderAsBitmap();

#ifdef RENDER_AS_MF
    BOOL                CLP_RenderMetafileFormat(DCWbGraphic* pGraphic);
#endif


    //
    // Insert a new page after the specified page
    //
    void InsertPageAfter(WorkspaceObj * pCurrentWorkspace);

public:
    //
    // Drawing pane window
    //
    WbDrawingArea m_drawingArea;

    //
    // Color palette, font, page controls
    //
    WbAttributesGroup   m_AG;

    //
    // Resize function for subpanes - called when the window is resized by
    // the user.
    //
    void ResizePanes(void);


    UINT GetSubState( void )
		{return(m_uiSubState );}

    //
    // Get a lock on the Whiteboard contents.  The first parameter
    // determines the type of lock, the second whether a visible or
    // invisible dialog is to be used (use SW_SHOW or SW_HIDE).
    //
    BOOL GetLock(UINT uiLockType, UINT uiHide = SW_SHOW);

    //
    // FRAME WINDOW VARS
    //
    HACCEL              m_hAccelTable;

    //
    // Get the window title
    //
    TCHAR * GetWindowTitle(void);

    WbWidthsGroup       m_WG;              // Pen Widths

	void EnableToolbar( BOOL bEnable );

    //
    // Dialog that asks whether to save changes.
    //
    HWND        m_hwndQuerySaveDlg;

    //
    // Get confirmation for destructive functions (new, clear)
    //
    int QuerySaveRequired(BOOL bCancelBtn);

    //
    // Timed dialogs that are running while the main window is waiting
    // for a specific event.
    //
    HWND        m_hwndWaitForEventDlg;
    HWND        m_hwndWaitForLockDlg;

    //
    // Lock/unlock the drawing area
    //
    void LockDrawingArea(void);
    void UnlockDrawingArea(void);


	HANDLE m_hFile;
	LPSTR  GetFileNameStr(void);
	UINT ObjectSave(UINT type, LPBYTE pData,UINT length);
	PT126WB_FILE_HEADER_AND_OBJECTS ValidateFile(LPCSTR pFileName);

	UINT ContentsLoad(LPCSTR pFileName);
	UINT ObjectLoad(void);

    UINT m_currentMenuTool;                   // Current tool menu Id

    //
    // Load a file
    //
	HRESULT WB_LoadFile(LPCTSTR szFile);
    void LoadFile(LPCSTR strLoadFileName);

    //
    // Ensure the attributes window is up to date
    //
    void OnUpdateAttributes(void)
                 { m_AG.DisplayTool(m_pCurrentTool); }


protected:

	
	UINT GetTipId(HWND hTipWnd, UINT nID);


    //
    // Current window size - normal, maximized or minimized
    //
    UINT                m_uiWindowSize;

    //
    // Save the current window position to the options file
    //
    void SaveWindowPosition(void);


    //
    // Menu selection functions
    //
    UINT m_currentMenuWidth;                  // Current width menu Id


    HWND                m_hwndSB;
    BOOL                m_bStatusBarOn;
    void                UpdateStatus(void);

    //
    // Current drawing tool
    //
    WbTool*           m_pCurrentTool;

    //
    // Menu update functions
    //
	void InitializeMenus(void);
    void CheckMenuItem(UINT uiId);
    BOOL CheckMenuItemRecursive(HMENU hMenu, UINT uiId, BOOL bCheck);
	HMENU GetMenuWithItem(HMENU hMenu, UINT uiID);

    //
    //
    // Select a window for grabbing
    //
    HWND SelectWindow(void);




    //
    // Add a captured bitmap to the contents
    //
    void AddCapturedImage(BitmapObj* dib);

    //
    // Get a file name for saving
    //
    int GetFileName();

	//
    // Registration state variables
    //
    UINT        m_uiSubState;

    //
    // Display a message box for an error
    //
    void DisplayError(UINT uiCaption, UINT uiMessage);

    //
    // Current file name for saving image
    //
    TCHAR     m_strFileName[2*_MAX_PATH];
	TCHAR 	* m_pTitleFileName;	// File Name in the title

    //
    // Grab an area of the screen into a bitmap
    //
    void GetGrabArea(LPRECT lprect);

    //
    // Hide/show the main window and its associated popups
    //
    void ShowAllWindows(int iShow);
    void ShowAllWindows(void) { ShowAllWindows(SW_RESTORE); }	
    void HideAllWindows(void) { ShowAllWindows(SW_MINIMIZE); }	

    //
    // Handle of alternative accelerator table for page and text edit fields
    //
    HACCEL      m_hAccelPagesGroup;
    HACCEL      m_hAccelTextEdit;

	//
    // Context menu for drawing area
    //
    HMENU           m_hContextMenuBar;
    HMENU			m_hEditContextMenu;
    HMENU           m_hContextMenu;
    HMENU           m_hGrobjContextMenuBar;
    HMENU           m_hGrobjContextMenu;

    //
    // Member function to create pop-up context menu for the drawing area
    //
    BOOL CreateContextMenus(void);


    // We remember if we're in a save dialog so we can canel it on certain events
    BOOL            m_bInSaveDialog;
    void            CancelSaveDialog(void);

    //
    // Cancel a load in progress
    //
    void CancelLoad(BOOL bReleaseLock = TRUE);


	UINT ContentsSave(LPCSTR pFileName);

    //
    // Set the application substate
    //
    void SetSubstate(UINT newSubState);

    //
    // Map of page handles to positions
    //
	typedef struct PAGEPOSITION
	{
		WORD    hPage;
	 	POINT   position;
	} PAGE_POSITION;

    COBLIST    m_pageToPosition;
    void PositionUpdated(void);

protected:


    //
    // Number of remote users
    //

	BOOL m_bSelectAllInProgress;

	BOOL GetDefaultPath( LPTSTR csDefaultPath, UINT size );

	
	BOOL m_bUnlockStateSettled;

	BOOL m_bQuerySysShutdown;

	
	BOOL m_bIsWin95;

    //
    // Interface for determining if a WM_CANCELMODE message has been sent
    //
protected:
    BOOL m_cancelModeSent;

public:
    void ResetCancelMode() { m_cancelModeSent = FALSE; };
    BOOL CancelModeSent()  { return m_cancelModeSent;  };
};


//
// Timed dialog proc
//
INT_PTR CALLBACK TimedDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// QuerySave dialog proc
//
INT_PTR CALLBACK QuerySaveDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectWindow dialog proc
//
INT_PTR CALLBACK WarnSelectWindowDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// WarnSelectArea dialog proc
//
INT_PTR CALLBACK WarnSelectAreaDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// About Box dialog proc
//
INT_PTR CALLBACK AboutDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // __MWND_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\nmwbobj.cpp ===
// NMWbObj.cpp : Implementation of CNMWbObj
#include "precomp.h"
#include <wbguid.h>
#include "wbcaps.h"
#include "NMWbObj.h"
#include <iappldr.h>

// Local prototypes
void CALLBACK T120AppletCallbackProc(T120AppletMsg *pMsg);
void CALLBACK T120SessionCallbackProc(T120AppletSessionMsg *pMsg);


/////////////////////////////////////////////////////////////////////////////////////////////////////
// CNMWbObj Construction and initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////

CNMWbObj*	g_pNMWBOBJ;
UINT		g_numberOfWorkspaces;
UINT		g_numberOfObjects;
CWBOBLIST*	g_pListOfWorkspaces;
BOOL		g_fWaitingForBufferAvailable;
CWBOBLIST*	g_pListOfObjectsThatRequestedHandles;
CWBOBLIST*	g_pRetrySendList;
CWBOBLIST*	g_pTrash;
ULONG		g_MyMemberID;
ULONG		g_RefresherID;
UINT		g_MyIndex;
BOOL 		g_bSavingFile;
BOOL		g_bContentsChanged;

GCCPREALOC 	g_GCCPreallocHandles[PREALLOC_GCC_BUFFERS];
UINT 		g_iGCCHandleIndex;
BOOL		g_WaitingForGCCHandles;

//
// T.126 protocol related
//
static const ULONG g_T126KeyNodes[] = {0,0,20,126,0,1};
static const T120ChannelID g_aStaticChannels[] = { _SI_CHANNEL_0 };


//
// T.120 capabilities
//
static GCCAppCap *g_CapPtrList[_iT126_MAX_COLLAPSING_CAPABILITIES];
static GCCAppCap g_CapArray[_iT126_MAX_COLLAPSING_CAPABILITIES];

//
// T.120 non-collapsing capabilities
//
#define MY_APP_STR              "_MSWB"
#define T126_TEXT_STRING        "NM 3 Text"
#define T126_24BIT_STRING       "NM 3 24BitMap"
static const OSTR s_AppData[_iT126_LAST_NON_COLLAPSING_CAPABILITIES] =
    {
        {
            sizeof(T126_TEXT_STRING),
            (LPBYTE) T126_TEXT_STRING
        },
        {
            sizeof(T126_24BIT_STRING),
            (LPBYTE) T126_24BIT_STRING
        },
    };

static GCCNonCollCap g_NCCapArray[2];
static const GCCNonCollCap *g_NCCapPtrList[2] = { &g_NCCapArray[0], &g_NCCapArray[1] };


//
// Member ID arrays, assuming 512 members
//
#define MAX_MEMBERS			512
static MEMBER_ID g_aMembers[MAX_MEMBERS];




CNMWbObj::CNMWbObj( void ) :
			// T.120 applet SAP
			m_pApplet(NULL),
			m_aMembers(&g_aMembers[0])
{
	DBGENTRY(CNMWbObj::CNMWbObj);

	DBG_SAVE_FILE_LINE
	g_pListOfWorkspaces = new CWBOBLIST();
    if(NULL == g_pListOfWorkspaces)
    {
        ERROR_OUT(("Failed to allocate g_pListOfWorkspaces"));
        return;
    }
    
	DBG_SAVE_FILE_LINE
	g_pListOfObjectsThatRequestedHandles = new CWBOBLIST();
    if(NULL == g_pListOfObjectsThatRequestedHandles)
    {
        ERROR_OUT(("Failed to allocate g_pListOfObjectsThatRequestedHandles"));
        return;
    }
    
	DBG_SAVE_FILE_LINE
	g_pTrash = new CWBOBLIST();
    if(NULL == g_pTrash)
    {
        ERROR_OUT(("Failed to allocate g_pTrash"));
        return;
    }
    
	DBG_SAVE_FILE_LINE
	g_pRetrySendList = new CWBOBLIST();
    if(NULL == g_pRetrySendList)
    {
        ERROR_OUT(("Failed to allocate g_pRetrySendList"));
        return;
    }
    
	g_pListOfWorkspaces->EmptyList();
	g_pListOfObjectsThatRequestedHandles->EmptyList();
	g_pRetrySendList->EmptyList();
	g_pTrash->EmptyList();
	g_numberOfWorkspaces = 0;
	g_numberOfObjects = 0;
	g_MyIndex = 0;
	g_bSavingFile = FALSE;
	g_bContentsChanged = FALSE;
	g_iGCCHandleIndex = 0;
	g_fWaitingForBufferAvailable = FALSE;
	g_WaitingForGCCHandles = FALSE;
    ::ZeroMemory(&g_GCCPreallocHandles, sizeof(g_GCCPreallocHandles));
    m_instanceNumber = 0;
    m_bConferenceOnlyNetmeetingNodes = TRUE;

	g_pNMWBOBJ = this;

	// Cleanup per-conference T.120 info
	CleanupPerConf();

	// T.120 Applet
	T120Error rc = ::T120_CreateAppletSAP(&m_pApplet);
	if (T120_NO_ERROR != rc)
	{
		ERROR_OUT(("CNMWbObj::CNMWbObj: cannot create applet SAP"));
		return;
	}
	ASSERT(NULL != m_pApplet);
	m_pApplet->Advise(T120AppletCallbackProc, this);

	//
	// Fill in the capabilities
	//
	BuildCaps();

    //
    // Load IMM32 if this is FE
    //
    ASSERT(!g_hImmLib);
    ASSERT(!g_fnImmGetContext);
    ASSERT(!g_fnImmNotifyIME);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        g_hImmLib = NmLoadLibrary("imm32.dll",TRUE);
        if (!g_hImmLib)
        {
            ERROR_OUT(("Failed to load imm32.dll"));
        }
        else
        {
            g_fnImmGetContext = (IGC_PROC)GetProcAddress(g_hImmLib, "ImmGetContext");
            if (!g_fnImmGetContext)
            {
                ERROR_OUT(("Failed to get ImmGetContext pointer"));
            }
            g_fnImmNotifyIME = (INI_PROC)GetProcAddress(g_hImmLib, "ImmNotifyIME");
            if (!g_fnImmNotifyIME)
            {
                ERROR_OUT(("Failed to get ImmNotifyIME pointer"));
            }
        }
    }

	DBG_SAVE_FILE_LINE
    g_pMain = new WbMainWindow();
    if (!g_pMain)
    {
        ERROR_OUT(("Can't create WbMainWindow"));
    }
    else
    {
	    //
    	// OK, now we're ready to create our HWND
	    //

    	if (!g_pMain->Open(SW_SHOWDEFAULT))
	    {
    	    ERROR_OUT(("Can't create WB windows"));
    	}
	}

	
	DBGEXIT(CNMWbObj::CNMWbObj);
}

CNMWbObj::~CNMWbObj( void ) 
{
	DBGENTRY(CNMWbObj::~CNMWbObj);

	//
	// If i'm the refresher, I have to release the token
	// And send an workspace refresh status pdu
	//
	if(m_bImTheT126Refresher)
	{
		::ZeroMemory(&m_tokenRequest, sizeof(m_tokenRequest));
		m_tokenRequest.eCommand = APPLET_RELEASE_TOKEN;
		m_tokenRequest.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
		T120Error rc = m_pAppletSession->TokenRequest(&m_tokenRequest);

		SendWorkspaceRefreshPDU(FALSE);
	
	}



	// no more T.120
	if (NULL != m_pAppletSession)
	{
		m_pAppletSession->ReleaseInterface();
		CleanupPerConf();
	}
	if (NULL != m_pApplet)
	{
		m_pApplet->ReleaseInterface();
		m_pApplet = NULL;
	}



	if(g_pMain)
	{
		delete g_pMain;
		g_pMain = NULL;
	}

	//
	// Delete all the global lists
	//
	DeleteAllWorkspaces(FALSE);
	g_pListOfWorkspaces->EmptyList();
	g_pListOfObjectsThatRequestedHandles->EmptyList();
	g_numberOfWorkspaces = 0;

	T126Obj* pGraphic;
	//
	// Burn trash
	//
	pGraphic = (T126Obj *)g_pTrash->RemoveTail();
	while (pGraphic != NULL)
	{
		delete pGraphic;
		pGraphic = (T126Obj *) g_pTrash->RemoveTail();
	}

	if(g_pTrash)
	{
		delete g_pTrash;
		g_pTrash = NULL;
	}

	if(g_pListOfWorkspaces)
	{
		delete g_pListOfWorkspaces;
		g_pListOfWorkspaces = NULL;
	}

	if(g_pListOfObjectsThatRequestedHandles)
	{
		delete g_pListOfObjectsThatRequestedHandles;
		g_pListOfObjectsThatRequestedHandles = NULL;
	}
	
	if(g_pRetrySendList)
	{
		delete g_pRetrySendList;
		g_pRetrySendList = NULL;
	}

	g_fnImmNotifyIME = NULL;
    g_fnImmGetContext = NULL;
    if (g_hImmLib)
    {
        FreeLibrary(g_hImmLib);
        g_hImmLib = NULL;
    }

	DBGEXIT(CNMWbObj::~CNMWbObj);
}


void 	CNMWbObj::BuildCaps(void)
{
	// Fill in the caps we support
	int i;

	for(i=0;i<_iT126_MAX_COLLAPSING_CAPABILITIES;i++)
	{
		g_CapArray[i].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
		g_CapArray[i].capability_id.standard_capability = GCCCaps[i].CapValue;
		g_CapArray[i].capability_class.eType = GCCCaps[i].Type;


		if( GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Width)
		{
			GCCCaps[i].MinValue = DRAW_WIDTH + 1;
			GCCCaps[i].MaxValue = DRAW_WIDTH - 1;
		}

		if(GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Height)
		{
			GCCCaps[i].MinValue = DRAW_HEIGHT + 1;
			GCCCaps[i].MaxValue = DRAW_HEIGHT - 1;
		}

		if(GCCCaps[i].CapValue == Soft_Copy_Workspace_Max_Planes)
		{
			GCCCaps[i].MinValue = WB_MAX_WORKSPACES + 1;
			GCCCaps[i].MaxValue = WB_MAX_WORKSPACES - 1;
		}


		if(GCCCaps[i].Type == GCC_UNSIGNED_MINIMUM_CAPABILITY)
		{
			g_CapArray[i].capability_class.nMinOrMax = GCCCaps[i].MinValue - 1;
		}
		else if ((GCCCaps[i].Type == GCC_UNSIGNED_MAXIMUM_CAPABILITY))
		{
			g_CapArray[i].capability_class.nMinOrMax = GCCCaps[i].MaxValue + 1;
		}
		else
		{
			g_CapArray[i].capability_class.nMinOrMax = 0;
		}

		g_CapArray[i].number_of_entities = 0;

		g_CapPtrList[i] = &g_CapArray[i];
	}

    //
    // Non-Collapsed Capabilities
	//
	g_NCCapArray[0].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
	g_NCCapArray[0].capability_id.standard_capability = _iT126_TEXT_CAPABILITY_ID;
	g_NCCapArray[0].application_data = (OSTR *) &s_AppData[0];

	//
	// How many bits per pixel can we handle?
	//
	HDC hDC = CreateCompatibleDC(NULL);

	if((GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES)) >= 24)
	{
		m_bICanDo24BitBitmaps = TRUE;
		g_NCCapArray[1].capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
		g_NCCapArray[1].capability_id.standard_capability = _iT126_24BIT_BITMAP_ID;
		g_NCCapArray[1].application_data = (OSTR *) &s_AppData[1];
	}
	else
	{
		m_bICanDo24BitBitmaps = FALSE;
	}

	if (hDC)
	{
		DeleteDC(hDC);
	}

}





//
// T120 Applet Functions
//


void CALLBACK T120AppletCallbackProc
(
	T120AppletMsg 		*pMsg
)
{
	CNMWbObj *pWBOBJ = (CNMWbObj *) pMsg->pAppletContext;
	if (pWBOBJ == g_pNMWBOBJ)
	{
		switch (pMsg->eMsgType)
		{
		case GCC_PERMIT_TO_ENROLL_INDICATION:
			pWBOBJ->OnPermitToEnroll(pMsg->PermitToEnrollInd.nConfID,
									 pMsg->PermitToEnrollInd.fPermissionGranted);
			break;

		case T120_JOIN_SESSION_CONFIRM:
		default:
			break;
		}
	}
}


void CALLBACK T120SessionCallbackProc
(
	T120AppletSessionMsg	*pMsg
)
{
	if(g_pNMWBOBJ == NULL)
	{
		return;
	}

	CNMWbObj *pSession = (CNMWbObj *) pMsg->pSessionContext;
    ASSERT(pMsg->pAppletContext == pMsg->pSessionContext);
	if (pSession == g_pNMWBOBJ)
	{
        ASSERT(pMsg->nConfID == pSession->GetConfID());
		switch (pMsg->eMsgType)
		{
        case MCS_UNIFORM_SEND_DATA_INDICATION:
		//
		// Check if we are receiving a indication from owrself
		//
		if(pMsg->SendDataInd.initiator == GET_USER_ID_FROM_MEMBER_ID(g_MyMemberID))
		{
			return;
		}
        case MCS_SEND_DATA_INDICATION:
				::T126_MCSSendDataIndication(
                        pMsg->SendDataInd.user_data.length,
                        pMsg->SendDataInd.user_data.value,
                        pMsg->SendDataInd.initiator,
                        FALSE);
            break;

		case MCS_TRANSMIT_BUFFER_AVAILABLE_INDICATION:
			g_fWaitingForBufferAvailable = FALSE;
			RetrySend();
			break;


        case GCC_APP_ROSTER_REPORT_INDICATION:
            pSession->OnRosterIndication((ULONG) pMsg->AppRosterReportInd.cRosters,
                                         pMsg->AppRosterReportInd.apAppRosters);
            break;

        case GCC_ALLOCATE_HANDLE_CONFIRM:
            pSession->OnAllocateHandleConfirm(&pMsg->RegAllocHandleConfirm);
            break;

		case T120_JOIN_SESSION_CONFIRM:
			pSession->OnJoinSessionConfirm(&pMsg->JoinSessionConfirm);
			break;


		case MCS_TOKEN_GRAB_CONFIRM:
			TRACE_DEBUG(("MCS_TOKEN_GRAB_CONFIRM result = %d",pMsg->TokenConfirm.eResult));

			if(pMsg->TokenConfirm.eResult == T120_RESULT_SUCCESSFUL)
			{
				TRACE_DEBUG((">>> I'm the T126 REFRESHER <<<"));
				g_pNMWBOBJ->m_bImTheT126Refresher = TRUE;

				//
				// Tell everybody I'm the refresher
				//
				SendWorkspaceRefreshPDU(TRUE);

				g_RefresherID = g_MyMemberID;
				
			}
			else
			{
				TRACE_DEBUG((">>> I'm NOT the  T126 REFRESHER <<<"));

				// if we are not the t126 refresher, we should save the previous work
				if (!g_pNMWBOBJ->m_bImTheT126Refresher)
				{

					if(!g_pNMWBOBJ->IsInConference())
					{
						if (g_pMain && (g_pMain->QuerySaveRequired(FALSE) == IDYES))
						{
							g_pMain->OnSave(FALSE);
						}
			
						//
						// If we were waiting on the save contents <yes> <no> dialog
						// and the whole conference and UI are exiting, g_pMain could be NULL
						// Or if  we are not in a call anymore, we don't need to delete all the local workspaces.
						// 
						if(g_pMain == NULL || !g_pNMWBOBJ->IsInConference())
						{
							return;
						}


						::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
						DeleteAllWorkspaces(FALSE);

						//
						// Fill up the GCC tank
						//
						TimeToGetGCCHandles(PREALLOC_GCC_HANDLES);
					}
					// ELSE
					// If we got here and we are in a call don't do a thing.
					// We just got here because the refresher went away. We tried
					// to grab the token and we lost it to a faster node.
					//
					
				}
			}

		    break;


		default:
			break;
		}
	}
}


void CNMWbObj::OnPermitToEnroll
(
	T120ConfID			nConfID,
	BOOL				fPermissionGranted
)
{
	if (fPermissionGranted)
	{
		// We are not in a conference, right?
		ASSERT(NULL == m_pAppletSession);

		m_bConferenceOnlyNetmeetingNodes = TRUE;

		// Create an applet session
		T120Error rc = m_pApplet->CreateSession(&m_pAppletSession, nConfID);
		if (T120_NO_ERROR == rc)
		{
			ASSERT(NULL != m_pAppletSession);
			m_pAppletSession->Advise(T120SessionCallbackProc, this, this);

			// get top provider information
			m_bImTheTopProvider = m_pAppletSession->IsThisNodeTopProvider();

			// Build join-sesion request
			::ZeroMemory(&m_JoinSessionReq, sizeof(m_JoinSessionReq));
			m_JoinSessionReq.dwAttachmentFlags = ATTACHMENT_DISCONNECT_IN_DATA_LOSS | ATTACHMENT_MCS_FREES_DATA_IND_BUFFER;
			m_JoinSessionReq.SessionKey.application_protocol_key.key_type = GCC_OBJECT_KEY;
			m_JoinSessionReq.SessionKey.application_protocol_key.object_id.long_string = (ULONG *) g_T126KeyNodes;
			m_JoinSessionReq.SessionKey.application_protocol_key.object_id.long_string_length = sizeof(g_T126KeyNodes) / sizeof(g_T126KeyNodes[0]);
			m_JoinSessionReq.SessionKey.session_id = _SI_CHANNEL_0;
			m_JoinSessionReq.fConductingCapable = FALSE;
			m_JoinSessionReq.nStartupChannelType =MCS_STATIC_CHANNEL;
			m_JoinSessionReq.cNonCollapsedCaps =1 + (m_bICanDo24BitBitmaps ? 1 : 0);
			m_JoinSessionReq.apNonCollapsedCaps = (GCCNonCollCap **) g_NCCapPtrList;
			m_JoinSessionReq.cCollapsedCaps = sizeof(g_CapPtrList) / sizeof(g_CapPtrList[0]);
			ASSERT(_iT126_MAX_COLLAPSING_CAPABILITIES == sizeof(g_CapPtrList) / sizeof(g_CapPtrList[0]));
			m_JoinSessionReq.apCollapsedCaps = g_CapPtrList;
			m_JoinSessionReq.cStaticChannels = sizeof(g_aStaticChannels) / sizeof(g_aStaticChannels[0]);
			m_JoinSessionReq.aStaticChannels = (T120ChannelID *) g_aStaticChannels;


			//
			// Token to grab
			//
			::ZeroMemory(&m_tokenResourceRequest, sizeof(m_tokenResourceRequest));
			m_tokenResourceRequest.eCommand = APPLET_GRAB_TOKEN_REQUEST;
			// m_tokenRequest.nChannelID = _SI_CHANNEL_0;
			m_tokenResourceRequest.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
            m_tokenResourceRequest.fImmediateNotification = TRUE;

			m_JoinSessionReq.cResourceReqs = 1;
			m_JoinSessionReq.aResourceReqs = &m_tokenResourceRequest;

			// Join now
			rc = m_pAppletSession->Join(&m_JoinSessionReq);
			if (T120_NO_ERROR == rc)
			{
                m_nConfID = nConfID;

				//
				// JOSEF NOW SET THE MAIN WINDOW STATUS
            }
            else
            {
				WARNING_OUT(("CNMWbObj::OnPermitToEnroll: cannot join conf=%u, rc=%u", nConfID, rc));
			}
		}
	}
	else
	{
		if (NULL != m_pAppletSession)
		{
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CNMWbObj::OnJoinSessionConfirm
(
	T120JoinSessionConfirm		*pConfirm
)
{
	if (NULL != m_pAppletSession)
	{
		ASSERT(m_pAppletSession == pConfirm->pIAppletSession);
		if (T120_RESULT_SUCCESSFUL == pConfirm->eResult)
		{
			m_uidMyself = pConfirm->uidMyself;
			m_sidMyself = pConfirm->sidMyself;
			m_eidMyself = pConfirm->eidMyself;
			m_nidMyself = pConfirm->nidMyself;

			// create member ID
			g_MyMemberID = MAKE_MEMBER_ID(m_nidMyself, m_uidMyself);

			if(g_pDraw && g_pDraw->IsLocked())
			{
				m_LockerID = g_MyMemberID;
			}

			// regardless, update the index anyway
			g_MyIndex = (m_uidMyself + NUMCOLS) % NUMCLRPANES;

			// we are now in the conference
			m_fInConference = TRUE;

			// allocate handles for all objects
			if (m_bImTheT126Refresher)
			{

				g_RefresherID = g_MyMemberID;

				//
				// Resend all objects
				//
				WBPOSITION pos;
				WBPOSITION posObj;
				WorkspaceObj* pWorkspace;
				T126Obj* pObj;

				pos = g_pListOfWorkspaces->GetHeadPosition();

				while(pos)
				{
					pWorkspace = (WorkspaceObj*)g_pListOfWorkspaces->GetNext(pos);
					g_pListOfObjectsThatRequestedHandles->AddHead(pWorkspace);
		
					posObj = pWorkspace->GetHeadPosition();
					while(posObj)
					{
						pObj = pWorkspace->GetNextObject(posObj);
						if(pObj)
						{
							g_pListOfObjectsThatRequestedHandles->AddHead(pObj);
						}
					}
				}


				//
				// Delete the fake handles we had
				//
				g_WaitingForGCCHandles = FALSE;
				g_GCCPreallocHandles[0].GccHandleCount = 0;
				g_GCCPreallocHandles[1].GccHandleCount = 0;
				TimeToGetGCCHandles(g_numberOfObjects + g_numberOfWorkspaces + PREALLOC_GCC_HANDLES);
			}
			else
			{
				::InvalidateRect(g_pDraw->m_hwnd, NULL, TRUE);
				DeleteAllWorkspaces(FALSE);
			}


		}
		else
		{
			WARNING_OUT(("CNMWbObj::OnJoinSessionConfirm: failed to join conference, result=%u. error=%u",
				pConfirm->eResult, pConfirm->eError));
			ASSERT(GCC_CONFERENCE_NOT_ESTABLISHED == pConfirm->eError);
			m_pAppletSession->ReleaseInterface();
			CleanupPerConf();
		}
	}
}


void CNMWbObj::OnAllocateHandleConfirm
(
    GCCRegAllocateHandleConfirm     *pConfirm
)
{
    if (T120_RESULT_SUCCESSFUL == pConfirm->nResult)
    {
	    ::T126_GCCAllocateHandleConfirm(pConfirm->nFirstHandle, pConfirm->cHandles);
    }
    else
    {
        ERROR_OUT(("CNMWbObj::OnAllocateHandleConfirm: failed to allocate %u handles, result=%u",
                pConfirm->cHandles, pConfirm->nResult));
    }
}


void CNMWbObj::OnRosterIndication
(
    ULONG           cRosters,
    GCCAppRoster    *apRosters[]
)
{
	if (IsInConference())
	{
		BOOL fAdded = FALSE;
		BOOL fRemoved = FALSE;
		ULONG cOtherMembers = 0;
		ULONG i, j, k;

		// Caculate how many members in this session
		for (i = 0; i < cRosters; i++)
		{
			GCCAppRoster *pRoster = apRosters[i];

			// bail out if this roster is not for this session
			if (pRoster->session_key.session_id != m_sidMyself)
			{
					continue;
			}

			// node added or removed?
			fAdded |= pRoster->nodes_were_added;
			fRemoved |= pRoster->nodes_were_removed;

			BOOL conferenceCanDo24BitBitmap = TRUE;
			BOOL conferenceCanDoText = TRUE;
			// parse the roster records
			for (j = 0; j < pRoster->number_of_records; j++)
			{
				GCCAppRecord *pRecord = pRoster->application_record_list[j];
				if (pRecord->is_enrolled_actively)
				{
					MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
					if (nMemberID != g_MyMemberID)
					{
						//
						// Only count T126 apps
						//
						if((pRoster->session_key.application_protocol_key.key_type == GCC_OBJECT_KEY &&
						pRoster->session_key.application_protocol_key.object_id.long_string_length == sizeof(g_T126KeyNodes) / sizeof(g_T126KeyNodes[0]) &&
						!memcmp (pRoster->session_key.application_protocol_key.object_id.long_string, g_T126KeyNodes, sizeof(g_T126KeyNodes))))
						{
							
							cOtherMembers++;
							m_instanceNumber = pRoster->instance_number;

							if(T120_GetNodeVersion(m_nConfID, pRecord->node_id) < 0x404)
							{
								m_bConferenceOnlyNetmeetingNodes = FALSE;
							}

						}
					}

					
					//
					// Can we do 24 color bitmap
					//
					BOOL nodeCanDo24BitBitmap = FALSE;
					BOOL nodeCanDoText = FALSE;
					for (k = 0; k < pRecord->number_of_non_collapsed_caps; k++)
					{
						//
						// Check if the node handles 24 bit bitmaps
						//
						if(pRecord->non_collapsed_caps_list[k]->application_data->length == sizeof(T126_24BIT_STRING))
						{
							if(!memcmp(pRecord->non_collapsed_caps_list[k]->application_data->value, T126_24BIT_STRING ,sizeof(T126_24BIT_STRING)))
							{
								nodeCanDo24BitBitmap = TRUE;
							}
						}

						//
						// Check if the node handles text
						//
						if(pRecord->non_collapsed_caps_list[k]->application_data->length == sizeof(T126_TEXT_STRING))
						{
							if(!memcmp(pRecord->non_collapsed_caps_list[k]->application_data->value, T126_TEXT_STRING ,sizeof(T126_TEXT_STRING)))
							{
								nodeCanDoText = TRUE;
							}
						}
						
					}

					conferenceCanDo24BitBitmap &= nodeCanDo24BitBitmap;
					conferenceCanDoText &= nodeCanDoText;
				}
				
			} // for

			m_bConferenceCanDo24BitBitmaps = conferenceCanDo24BitBitmap;
			m_bConferenceCanDoText = conferenceCanDoText;
		
		} // for




		// If there are changes, we then do the update
		if (fAdded || fRemoved || cOtherMembers != m_cOtherMembers)
		{
			MEMBER_ID aTempMembers[MAX_MEMBERS]; // scratch copy

			// make sure we are able to handle it
			if (cOtherMembers >= MAX_MEMBERS)
			{
				ERROR_OUT(("CNMWbObj::OnRosterIndication: we hit the max members limit, cOtherMembers=%u, max-members=%u",
						cOtherMembers, MAX_MEMBERS));
				cOtherMembers = MAX_MEMBERS;
			}

			// reset the flags for members added and removed
			fAdded = FALSE;
			fRemoved = FALSE;

			// copy the members
			ULONG idxTempMember = 0;
			for (i = 0; i < cRosters; i++)
			{
				GCCAppRoster *pRoster = apRosters[i];

				// bail out if this roster is not for this session
				if (pRoster->session_key.session_id != m_sidMyself)
				{
					continue;
				}

				// parse the roster records
				for (j = 0; j < pRoster->number_of_records; j++)
				{
					GCCAppRecord *pRecord = pRoster->application_record_list[j];
					if (pRecord->is_enrolled_actively)
					{
						MEMBER_ID nMemberID = MAKE_MEMBER_ID(pRecord->node_id, pRecord->application_user_id);
						if (nMemberID != g_MyMemberID && idxTempMember < cOtherMembers)
						{
							aTempMembers[idxTempMember++] = nMemberID;

							// let's see if it is an 'add' or a 'delete'
							for (k = 0; k < m_cOtherMembers; k++)
							{
								if (m_aMembers[k] == nMemberID)
								{
									m_aMembers[k] = 0;
									break;
								}
							}
							fAdded |= (k >= m_cOtherMembers); // not found, must be new
						}
					}
				} // for
			} // for

			// sanity check
			ASSERT(idxTempMember == cOtherMembers);

			// see if there are ones that are not in the new roster.
			// if so, they must be removed.
			for (k = 0; k < m_cOtherMembers; k++)
			{
				if (m_aMembers[k])
				{
					fRemoved = TRUE;

					ULONG memberID = GET_USER_ID_FROM_MEMBER_ID(m_aMembers[k]);

					TRACE_DEBUG(("OnRosterIndication removing RemotePointer from member =%x", memberID));

					RemoveRemotePointer(memberID);

					//
					// if the refresher went away
					//
					if(g_RefresherID == memberID)
					{
						GrabRefresherToken();
					}

					//
					// if node locking went away
					//
					if(m_LockerID == memberID)
					{
						TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
						g_pMain->UnlockDrawingArea();
						g_pMain->m_TB.PopUp(IDM_LOCK);
						g_pMain->UncheckMenuItem(IDM_LOCK);
						m_LockerID = 0;
					}
				}
			}

			// now, update the member array
			m_cOtherMembers = cOtherMembers;
			if (m_cOtherMembers)
			{
				ASSERT(sizeof(m_aMembers[0]) == sizeof(aTempMembers[0]));
				::CopyMemory(&m_aMembers[0], &aTempMembers[0], m_cOtherMembers * sizeof(m_aMembers[0]));
			}

			// if added, resend all objects
			if (fAdded && (m_bImTheT126Refresher))
			{
				//
				// Tell the new node that I'm the refresher
				//
				SendWorkspaceRefreshPDU(TRUE);

				//
				// Refresh the new node
				//
				ResendAllObjects();


				//
				// if node locking everybody went away
				//
				if(m_LockerID == g_MyMemberID)
				{
					TogleLockInAllWorkspaces(TRUE, TRUE); // Locked, send updates 
				}

				//
				// Syncronize it
				//
				if(g_pCurrentWorkspace)
				{
					g_pCurrentWorkspace->OnObjectEdit();
				}
			}

			// finally, update the caption
			if(g_pMain)
			{
				g_pMain->UpdateWindowTitle();
			}
		} // if any change
	} // if is in conf
}


void CNMWbObj::CleanupPerConf(void)
{
	m_fInConference = FALSE;
	m_pAppletSession = NULL;

	g_MyMemberID = 0;
	g_RefresherID = 0;

    m_nConfID = 0;      // Conf ID
	m_uidMyself = 0;	// User ID
	m_sidMyself = 0;	// Session ID
	m_eidMyself = 0;	// Entity ID
	m_nidMyself = 0;	// Node ID

	m_bImTheTopProvider = FALSE;
	m_bImTheT126Refresher = FALSE;
	m_bConferenceOnlyNetmeetingNodes = TRUE;
	
	m_cOtherMembers = 0;

	if(g_pMain)
	{
 
        g_pMain->UpdateWindowTitle();
		RemoveRemotePointer(0);
		DeleteAllRetryPDUS();
		g_pListOfObjectsThatRequestedHandles->EmptyList();

		ASSERT(g_pDraw);
		//
		// If we were locked
		//
		if(g_pDraw->IsLocked())
		{
			m_LockerID = g_MyMemberID;
			TogleLockInAllWorkspaces(FALSE, FALSE); // Not locked, don't send updates
			g_pMain->UnlockDrawingArea();
			g_pMain->m_TB.PopUp(IDM_LOCK);
			g_pMain->UncheckMenuItem(IDM_LOCK);
		}
	}
	m_LockerID = 0;
}


T120Error CNMWbObj::SendData
(
    T120Priority	ePriority,
    ULONG           cbDataSize,
    PBYTE           pbData
)
{
	T120Error rc;

	if (IsInConference())
	{
    	rc = m_pAppletSession->SendData(
                            UNIFORM_SEND_DATA,
                            _SI_CHANNEL_0,
                            ePriority,
                            pbData,
                            cbDataSize,
                            APP_ALLOCATION);
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


T120Error CNMWbObj::GrabRefresherToken(void)
{
	T120Error rc;

	if (IsInConference())
	{
	    T120TokenRequest Req;

		Req.eCommand = APPLET_GRAB_TOKEN;
		Req.nTokenID = _SI_WORKSPACE_REFRESH_TOKEN;
		Req.uidGiveTo = m_uidMyself;
		Req.eGiveResponse = T120_RESULT_SUCCESSFUL;

	    rc = m_pAppletSession->TokenRequest(&Req);
		if (T120_NO_ERROR != rc)
		{
			WARNING_OUT(("CNMWbObj::AllocateHandles: TokenRequest"));
		}
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}


T120Error CNMWbObj::AllocateHandles
(
    ULONG           cHandles
)
{
	T120Error rc;

	if ( cHandles > 0  && IsInConference())
	{
	    T120RegistryRequest Req;
	    Req.eCommand = APPLET_ALLOCATE_HANDLE;
	    Req.pRegistryKey = NULL;
	    Req.cHandles = cHandles;

	    rc = m_pAppletSession->RegistryRequest(&Req);
		if (T120_NO_ERROR != rc)
		{
			ERROR_OUT(("CNMWbObj::AllocateHandles: RegistryRequest(cHandles=%u), rc=%u", cHandles, rc));
		}
	}
	else
	{
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\page.hpp ===
//
// PAGE.HPP
// Page Class
//
// Copyright Microsoft 1998-
//
#ifndef __PAGE_HPP_
#define __PAGE_HPP_

//
// Purpose: Handler for page of graphic objects
//


class T126Obj;
class WorkspaceObj;

//
// Retrieving object data
//
T126Obj* PG_First(WorkspaceObj * pWorkSpc, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
T126Obj* PG_Next(WorkspaceObj * pWorkSpc, WBPOSITION& pos, LPCRECT lprcUpdate=NULL, BOOL bCheckReallyHit=FALSE);
T126Obj* PG_SelectLast(WorkspaceObj * pWorkSpc,POINT point);
T126Obj* PG_SelectPrevious(WorkspaceObj* pWorkspace,WBPOSITION& pos,POINT point);

//
// Draw the entire contents of the page into the device context
// specified.
//
void PG_Draw(WorkspaceObj*  pWorkspace, HDC hDC);

//
// Print an area of the page to the specified DC
//
void PG_Print(WorkspaceObj*  pWorkspace, HDC hdcPrinter, LPCRECT lprcArea);

//
// Return the palette to be used for displaying the page
//
HPALETTE    PG_GetPalette(void);
void        PG_InitializePalettes(void);
void        PG_ReinitPalettes(void);



#endif // __PAGE_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\ui\wb\precomp.h ===
//
// Precompiled header stuff
//


#define OEMRESOURCE
#define STRICT 1


#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <shellapi.h>                   // Includes drag drop interface
#include <imm.h>


//
// NM headers
//
#include <mlzdbg.h>
#include <confreg.h>
#include <oprahcom.h>
#include <indeopal.h>
#include <help_ids.h>
#include <endsesn.h>
#include <nmhelp.h>
#include <dllutil.h>


// macro for setting "match to palette colors" bits in a COLORREF
#define SET_PALETTERGB( c )  (0x02000000 | (0x00ffffff & c))


#ifdef _DEBUG
extern HDBGZONE ghZoneWb;

// UPDATE g_rgZonesWb IF THESE CHANGE
enum
{
    ZONE_WB_DEBUG = BASE_ZONE_INDEX,
    ZONE_WB_MSG,
    ZONE_WB_TIMER,
    ZONE_WB_EVENT,
    ZONE_WB_MAX
};
		
#define TRACE_DEBUG( s )	MLZ_TraceZoneEnabled(ZONE_WB_DEBUG) ? (MLZ_TraceOut s) : 0
#define TRACE_MSG( s )		MLZ_TraceZoneEnabled(ZONE_WB_MSG) ? (MLZ_TraceOut s) : 0
#define TRACE_TIMER( s )	MLZ_TraceZoneEnabled(ZONE_WB_TIMER) ? (MLZ_TraceOut s) : 0
#define TRACE_EVENT( s )	MLZ_TraceZoneEnabled(ZONE_WB_EVENT) ? (MLZ_TraceOut s) : 0

#else

#define MLZ_EntryOut(zone, func)

#define TRACE_DEBUG( a )
#define TRACE_MSG( a )
#define TRACE_TIMER( a )
#