 INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_TIMER
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <strnumer.hxx>

#include <adminapp.hxx> // for resource numbers

#include <propdlg.hxx>


/*******************************************************************

    NAME:       PERFORMER::PERFORMER

    SYNOPSIS:   Constructor for PERFORMER object

    ENTRY:      powin: Pointer to the parent window.  The parent window
                will be used if PerformSeries() needs to display any
                popup dialogs.

    HISTORY:
        JonN        18-Jul-1991     Created

********************************************************************/

PERFORMER::PERFORMER( const OWNER_WINDOW * powin )
    : _powin( powin ),
      _fWorkWasDone( FALSE )
{
    ASSERT( _powin != NULL );
}


/*******************************************************************

    NAME:       PERFORMER::~PERFORMER

    SYNOPSIS:   Destructor for PERFORMER object

    HISTORY:
        JonN        18-Jul-1991     Created

********************************************************************/

PERFORMER::~PERFORMER()
{
    ;
}


/*******************************************************************

    NAME:       PERFORMER::PerformSeries

    SYNOPSIS:   Performs series of PerformOne actions

    RETURNS:    TRUE iff _all_ PerformOne actions succeeded.  This may
                indicate to the caller that the property dialog can be
                closed.

    NOTES:      We may eventually add an "ignore future errors" option

    HISTORY:
        JonN        23-Jul-1991     Created

********************************************************************/

BOOL PERFORMER::PerformSeries( const OWNER_WINDOW * powinParent,
                               BOOL fOfferToContinue )
{
    AUTO_CURSOR autocur;
    BOOL fAllSucceeded = TRUE;

    UINT i;
    for ( i = 0; i < QueryObjectCount(); i++ )
    {
        BOOL fWorkWasDone = FALSE;
        APIERR errMsg;
        APIERR err = PerformOne( i, &errMsg, &fWorkWasDone );
        if ( fWorkWasDone )
            SetWorkWasDone();
        switch (err)
        {
        case NERR_Success:
            break;

        case IERR_CANCEL_NO_ERROR:
            fAllSucceeded = FALSE;
            i = QueryObjectCount(); // break out of loop
            break;

        default:
            fAllSucceeded = FALSE;
            BOOL fContinue = DisplayError(
                err,
                errMsg,
                QueryObjectName( i ),
                (fOfferToContinue && (i < QueryObjectCount()-1)),
                powinParent
                );
            if (!fContinue)
                return FALSE;
            break;
        }
    }

    return fAllSucceeded;
}


/*******************************************************************

    NAME:       PERFORMER::DisplayError

    SYNOPSIS:   Displays an error returned from a call to GetOne

    ENTRY:      errAPI: the NET, SYS or other error which occurred.
                        There should be an error message in the string
                        table with this number.
                errMsg: the PerformSeries error template.  The template
                        is the entry in the string table with this number.
                        See PERFORMER for a description of template format.
                pszObjectName: Insertion parameter for the error template.
                fOfferToContinue: if FALSE, this method always returns
                        FALSE.  if TRUE, the user will be given the
                        chance to continue the series.

    RETURNS:    Flag whether the caller should continue with the series

    NOTES:      The help topic is the topic corresponding to errMsg.

                Note that the APE_ error messages are all > MAX_NERR

                IMPORTANT: If fOfferToContinue==TRUE, then the errMsg used
                will be the one specified _plus one_.  This new message
                should contain an explanation of the meaning of the
                Yes/No buttons.  Be sure that string errMsg+1 is present
                whenever you perform multiselect change operations.

    HISTORY:
        JonN        02-Aug-1991 Created (templated from winprof.cxx)
        beng        23-Oct-1991 Win32 conversion
        beng        31-Mar-1992 Removed wsprintf
        JonN        18-Aug-1992 DisplayError fixes (1070)
        JonN        11-Oct-1992 fOfferToContinue extension

********************************************************************/

BOOL PERFORMER::DisplayError(
    APIERR               errAPI,
    APIERR               errMsg, // CODEWORK should be MSGID
    const TCHAR *        pszObjectName,
    BOOL                 fOfferToContinue,
    const OWNER_WINDOW * powinParent)
{
    ALIAS_STR nlsObjectName( pszObjectName );
    NLS_STR *apnlsParamStrings[2];
    apnlsParamStrings[0] = &nlsObjectName;
    apnlsParamStrings[1] = NULL;

    INT nButton = MsgPopup(
        powinParent,
        (fOfferToContinue) ? errMsg+1 : errMsg,
        errAPI,
        MPSEV_ERROR,
        (UINT)HC_NO_HELP, // BUGBUG use Ben's magic MsgPopup ErrMappingFn( errMsg )
        (fOfferToContinue) ? MP_YESNO : MP_OK,
        apnlsParamStrings
        ) ;

    return (nButton == IDYES); // will always be FALSE for MP_OK case

#if 0
    DEC_STR nlsErrorCode( errAPI, 4 );

    // We ignore error returns, just skip displaying string
    RESOURCE_STR nlsErrorString(errAPI);
    APIERR err = nlsErrorString.QueryError();
    if ( err != NERR_Success )
    {
        DBGEOL(   SZ("NETUI: PERFORMER::DisplayError(): Could not load error ")
               << errAPI
               << SZ(", failure code ")
               << err );
        nlsErrorString = NULL;
        err = nlsErrorString.QueryError();
    }
    if (err != NERR_Success)
    {
        MsgPopup( powinParent, err );
        return FALSE;
    }

    MSGID msgFormat;
    if ( errAPI < NERR_BASE )
        msgFormat = IDS_PROPDLG_FMT_SYS_error;
    else if ( errAPI <= MAX_NERR )
        msgFormat = IDS_PROPDLG_FMT_NET_error;
    else
        msgFormat = IDS_PROPDLG_FMT_other_error;

    const NLS_STR * apnlsParamStrings[3];
    apnlsParamStrings[0] = &nlsErrorCode;
    apnlsParamStrings[1] = &nlsErrorString;
    apnlsParamStrings[2] = NULL;

    // We ignore error returns, just skip displaying string
    // CODEWORK - should resource_str take params in ctor?
    RESOURCE_STR nlsErrorLine(msgFormat);
    if (!nlsErrorLine)
    {
        DBGEOL(   SZ("NETUI: PERFORMER::DisplayError(): Could not load message ")
               << msgFormat
               << SZ(", failure code ")
               << nlsErrorLine.QueryError() );
        MsgPopup( powinParent, nlsErrorLine.QueryError() );
        return FALSE;
    }
    nlsErrorLine.InsertParams( apnlsParamStrings );

    ALIAS_STR nlsObjectName ( pszObjectName );

    apnlsParamStrings[0] = &nlsErrorLine;
    apnlsParamStrings[1] = &nlsObjectName;
    apnlsParamStrings[2] = NULL;

    // BUGBUG here we should modify the string according to whether
    //  the user is asked to continue

    // CODEWORK MsgPopup takes a MSGID, not an APIERR, as its 3rd parm

    INT nButton = MsgPopup(
        powinParent,
        errMsg,
        MPSEV_ERROR,
        HC_NO_HELP, // BUGBUG use Ben's magic MsgPopup ErrMappingFn( errMsg )
        (fOfferToContinue) ? MP_YESNO : MP_OK,
        apnlsParamStrings
        ) ;

    return (nButton == IDYES); // will always be FALSE for MP_OK case

#endif // 0

}


/*******************************************************************

    NAME:       PERFORMER::QueryOwnerWindow

    SYNOPSIS:   Get the owner window

    RETURNS:    Returns pointer to ownerwindow

    HISTORY:
        o-SimoP 13-Aug-1991     Created

********************************************************************/

const OWNER_WINDOW * PERFORMER::QueryOwnerWindow() const
{
    return _powin;
}


/*******************************************************************

    NAME:       PERFORMER::SetWorkWasDone

    SYNOPSIS:   Records that work was done in this series

    HISTORY:
        JonN        15-Nov-1991     Created

********************************************************************/

VOID PERFORMER::SetWorkWasDone()
{
    _fWorkWasDone = TRUE;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::BASEPROP_DLG

    SYNOPSIS:   Constructor for Properties main dialog and subdialogs

    ENTRY:      pszResourceName: see DIALOG_WINDOW
                powin: see DIALOG_WINDOW

    HISTORY:
        JonN        17-Jul-1991     Created

********************************************************************/

BASEPROP_DLG::BASEPROP_DLG( const TCHAR * pszResourceName,
                            const OWNER_WINDOW * powin,
                            BOOL fAnsiDialog )

    : DIALOG_WINDOW( pszResourceName, powin->QueryHwnd(), fAnsiDialog ),
      PERFORMER( powin ),
      _pbCancelClose( this, IDCANCEL )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::~BASEPROP_DLG

    SYNOPSIS:   Destructor for Properties main dialog and subdialogs

    HISTORY:
        JonN        17-Jul-1991     Created

********************************************************************/

BASEPROP_DLG::~BASEPROP_DLG()
{
    ;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::PerformSeries

    SYNOPSIS:   Performs series of PerformOne actions

    RETURNS:    As PERFORMER::PerformSeries, but assumes that dialog is
                the parent for any error messages

    NOTES:      We may eventually add an "ignore future errors" option

    HISTORY:
        JonN        26-Jul-1991     Created

********************************************************************/

BOOL BASEPROP_DLG::PerformSeries( BOOL fOfferToContinue )
{
    return PERFORMER::PerformSeries( this, fOfferToContinue );
}


/*******************************************************************

    NAME:       BASEPROP_DLG::GetInfo

    SYNOPSIS:   Secondary constructor for Properties main dialogs
                and subdialogs

    RETURNS:    Do not Process() dialog if this is not TRUE.
                GetInfo() will report the error itself.

    NOTES:      If the error returned from GetOne is ERROR_BAD_NETPATH,
                it may be that admin-app focus is set to a domain and
                the PDC is down.  In this case, context-sensitive help
                should explain how to promote a backup DC to primary,
                as per User Manager FuncSpec (v1.3 section 5).

                If GetOne returns an error, we display a MsgPopup and
                return FALSE so that the dialog will be closed without
                being Process()ed.  However, error IERR_CANCEL_NO_CLOSE
                is handled specially; in this case, we skip the MsgPopup.

                BUGBUG Although the caller is not supposed to Process()
                the dialog if this returns FALSE, it is a known bug in
                BLT that all dialogs must be processed or else the
                ALT-ESC chain is trashed.

    HISTORY:
        JonN        18-Jul-1991     Created
        JonN        16-Dec-1991     Added IERR_CANCEL_NO_CLOSE

********************************************************************/

BOOL BASEPROP_DLG::GetInfo()
{
    //
    // If the dialog failed to construct, let Process() report the error.
    //
    if ( QueryError() )
        return TRUE;

    AUTO_CURSOR autocur;

    UINT i;
    APIERR err = NERR_Success;
    for ( i = 0; i < QueryObjectCount(); i++ )
    {
        /*
           If GetOne fails, report the error here and do not let
           Process() be called.  We set the message format to GEN_FAILURE
           initially because GetOne is virtual and might forget.
        */
        APIERR errMsg = ERROR_GEN_FAILURE; // should not appear!
        err = GetOne( i, &errMsg );
        if ( err != NERR_Success )
        {
            ASSERT( errMsg != ERROR_GEN_FAILURE );
            if ( err != IERR_CANCEL_NO_ERROR )
            {
                DisplayError(
                    err,
                    errMsg,
                    QueryObjectName( i ),
                    FALSE,
                    QueryOwnerWindow()
                    );
            }
            return FALSE;
        }
    }

    err = InitControls();
    if ( err != NERR_Success )
    {
        //
        // If the controls could not initialize, let Process() report
        // the error.
        //
        ReportError( err );
        return TRUE;
    }

    return TRUE;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::InitControls

    SYNOPSIS:   Initializes common controls and makes the dialog visible.

    NOTES:      Subdialogs will probably want to redefine InitControls()
                to initialize controls specific to the subclass, but
                should call down to their predecessor InitControl() if
                they successfully initialize their controls.

    HISTORY:
        JonN        02-Aug-1991     Created

********************************************************************/

APIERR BASEPROP_DLG::InitControls()
{
    return NERR_Success;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::CancelToCloseButton

    SYNOPSIS:   Changes name of the Cancel button to Close

    NOTES:      According to the UI Standards document, applications
                should change the name of this button as soon as they
                successfully write any changes to permanent storage.
                This informs the user that some changes made in this
                dialog cannot be rolled back.  The button in the Main
                Properties dialog should also be renamed when a
                subdialog writes information.

    HISTORY:
        JonN        15-Nov-1991     Created

********************************************************************/

APIERR BASEPROP_DLG::CancelToCloseButton()
{
    RESOURCE_STR resstr( IDS_PROPDLG_PB_Close );
    APIERR err = resstr.QueryError();
    if ( err != NERR_Success )
        return err;

    _pbCancelClose.SetText( resstr );

    return NERR_Success;
}


/*******************************************************************

    NAME:       BASEPROP_DLG::SetWorkWasDone

    SYNOPSIS:   Records that work was done by this dialog

    NOTES:      According to the UI Standards document, applications
                should change the name of this button as soon as they
                successfully write any changes to permanent storage.
                This informs the user that some changes made in this
                dialog cannot be rolled back.  The button in the Main
                Properties dialog should also be renamed when a
                subdialog writes information.

    HISTORY:
        JonN        15-Nov-1991     Created

********************************************************************/

VOID BASEPROP_DLG::SetWorkWasDone()
{
    if ( !QueryWorkWasDone() )
    {
       APIERR err = CancelToCloseButton();
       if ( err != NERR_Success )
       {
           DBGEOL("ERROR: Could not change Cancel to Close!! (errno " << err);
       }
    }

    PERFORMER::SetWorkWasDone();
}


/*******************************************************************

    NAME:       PROP_DLG::PROP_DLG

    SYNOPSIS:   Constructor for Properties main dialog

    ENTRY:      loc: LOCATION for all selected/new objects.  Pass NULL
                        if this does not apply.
                pszResourceName: see DIALOG_WINDOW
                powin: see DIALOG_WINDOW
                fNewVariant: TRUE iff this property dialog and its
                        subdialogs create a new object rather than
                        editing existing objects.

    HISTORY:
        JonN        17-Jul-1991     Created

********************************************************************/

PROP_DLG::PROP_DLG( const LOCATION &     loc,
                    const TCHAR *        pszResourceName,
                    const OWNER_WINDOW * powin,
                    BOOL                 fNewVariant,
                    BOOL                 fAnsiDialog )
    : BASEPROP_DLG( pszResourceName, powin, fAnsiDialog ),
      _locFocus( loc ),
      _fNewVariant( fNewVariant )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _locFocus.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       PROP_DLG::~PROP_DLG

    SYNOPSIS:   Destructor for Properties main dialog

    HISTORY:
        JonN        17-Jul-1991     Created

********************************************************************/

PROP_DLG::~PROP_DLG()
{
    ;
}


/*******************************************************************

    NAME:       PROP_DLG::QueryLocation

    SYNOPSIS:   Returns focus for property dialog

    HISTORY:
        JonN        15-Aug-1991     Created

********************************************************************/

const LOCATION & PROP_DLG::QueryLocation() const
{
    ASSERT( _locFocus.QueryError() == NERR_Success );
    return _locFocus;
}


/*******************************************************************

    NAME:       PROP_DLG::IsNewVariant

    SYNOPSIS:   Indicates whether this dialog is a New Object variant

    RETURNS:    see synopsis

    HISTORY:
        JonN        26-Aug-1991     Created

********************************************************************/

BOOL PROP_DLG::IsNewVariant() const
{
    return _fNewVariant;
}


/*******************************************************************

    NAME:       SUBPROP_DLG::SUBPROP_DLG

    SYNOPSIS:   Constructor for Properties subdialogs

    ENTRY:      ppropdlgParent: The parent window is required to be in
                        the BASEPROP_DLG hierarchy, either a main
                        property dialog or a (higher-level) subdialog.
                pszResourceName: See DIALOG_WINDOW

    HISTORY:
        JonN        29-Jul-1991     Created

********************************************************************/

SUBPROP_DLG::SUBPROP_DLG( BASEPROP_DLG * ppropdlgParent,
                          const TCHAR *  pszResourceName,
                          BOOL fAnsiDialog )
    : BASEPROP_DLG( pszResourceName, ppropdlgParent, fAnsiDialog),
      _ppropdlgParent( ppropdlgParent )
{
    ASSERT( _ppropdlgParent != NULL );

    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       SUBPROP_DLG::~SUBPROP_DLG

    SYNOPSIS:   Destructor for Properties subdialogs

    NOTES:      Automatically informs parent if work was done.

    HISTORY:
        JonN        29-Jul-1991     Created

********************************************************************/

SUBPROP_DLG::~SUBPROP_DLG()
{
    if ( QueryWorkWasDone() )
        _ppropdlgParent->SetWorkWasDone();
}


/*******************************************************************

    NAME:       SUBPROP_DLG::QueryLocation

    SYNOPSIS:   Returns focus for property subdialog, which is always
                the same as for the parent

    HISTORY:
        JonN        15-Aug-1991     Created

********************************************************************/

const LOCATION & SUBPROP_DLG::QueryLocation() const
{
    return _ppropdlgParent->QueryLocation();
}


/*******************************************************************

    NAME:       SUBPROP_DLG::QueryObjectCount

    SYNOPSIS:   Returns object count for property subdialog, which is
                always the same as for the parent

    HISTORY:
        JonN        30-Jul-1991     created

********************************************************************/

UINT SUBPROP_DLG::QueryObjectCount() const
{
    return _ppropdlgParent->QueryObjectCount();
}


/*******************************************************************

    NAME:       SUBPROP_DLG::QueryObjectName

    SYNOPSIS:   Returns object name for one of the objects being
                modified, always the same as for the parent

    HISTORY:
        JonN        30-Jul-1991     created

********************************************************************/

const TCHAR * SUBPROP_DLG::QueryObjectName( UINT iObject ) const
{
    return _ppropdlgParent->QueryObjectName( iObject );
}


/*******************************************************************

    NAME:       SUBPROP_DLG::IsNewVariant

    SYNOPSIS:   Indicates whether this dialog is a New Object variant,
                always the same as for the parent

    HISTORY:
        JonN        26-Aug-1991     Created

********************************************************************/

BOOL SUBPROP_DLG::IsNewVariant() const
{
    return _ppropdlgParent->IsNewVariant();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\bin\makefile.inc ===
COMBINE_SOURCELIBS=..\adminapp\$(O)\adminapp.lib   \
                   ..\setfocus\$(O)\setfocus.lib   \
                   ..\colwidth\$(O)\adcolw.lib

COMBINE_TARGETLIB=$(O)\uiadmin.lib

!include $(PROJECT_ROOT)\netui\common\src\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\colwidth\colwidth.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    headcolw.cxx
        Head column width class.

    FILE HISTORY:
        CongpaY     12-Jan-93   Created
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS

#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <string.hxx>

#include <uitrace.hxx>

#include <colwidth.hxx>

/*******************************************************************

    NAME:       ADMIN_COL_WIDTHS::ADMIN_COL_WIDTHS

    SYNOPSIS:   Constructor

    ENTRY:


    RETURN:

    HISTORY:
        congpay  12-Jan-93       Created

********************************************************************/

ADMIN_COL_WIDTHS::ADMIN_COL_WIDTHS (HWND               hWnd,
                                    HINSTANCE          hmod,
                                    const IDRESOURCE & idres,
                                    UINT               cColumns)
    :   LB_COL_WIDTHS (hWnd,
                       hmod,
                       idres,
                       cColumns),
        _pdxHeaderWidth( NULL )
{
    APIERR err = NERR_Success;

    do     //error break out.
    {
        if ((err = QueryError()) != NERR_Success)
        {
            break;
        }

        _pdxHeaderWidth = new UINT[(cColumns-1)];

        if (_pdxHeaderWidth == NULL)
        {
            ReportError (ERROR_NOT_ENOUGH_MEMORY);
            break;
        }

        CopyColumnWidths();

    } while (FALSE);
}

/*******************************************************************

    NAME:       ADMIN_COL_WIDTHS::~ADMIN_COL_WIDTHS

    SYNOPSIS:   destructor

    ENTRY:


    RETURN:

    HISTORY:
        congpay  12-Jan-93       Created

********************************************************************/

ADMIN_COL_WIDTHS::~ADMIN_COL_WIDTHS (void)
{
    delete (_pdxHeaderWidth);
    _pdxHeaderWidth = NULL;
}


/*******************************************************************

    NAME:       ADMIN_COL_WIDTHS::CopyColumnWidths

    SYNOPSIS:   Copies root column widths into new table

    ENTRY:


    RETURN:

    HISTORY:
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths

********************************************************************/

VOID ADMIN_COL_WIDTHS::CopyColumnWidths()
{
    UINT * pdxWidth = QueryColumnWidth();
    UIASSERT (pdxWidth != NULL);

    _pdxHeaderWidth[0] = pdxWidth[0] + pdxWidth[1];

    for (INT i=1; i<((INT)QueryCount()-1); i++)
    {
         _pdxHeaderWidth[i] = pdxWidth[i+1];
    }
}


/*******************************************************************

    NAME:       ADMIN_COL_WIDTHS::ReloadColumnWidths

    SYNOPSIS:   Reloads column widths.  Use this after changing fonts.

    ENTRY:      hmod  -         Hinstance.
                idres -         Resource id.
                cColumns -      Number of columns.

    HISTORY:
        JonN           23-Sep-1993 Added virtual ReloadColumnWidths

********************************************************************/

APIERR ADMIN_COL_WIDTHS::ReloadColumnWidths( HWND hWnd,
                                             HINSTANCE hmod,
                                             const IDRESOURCE & idres )
{
    ASSERT( QueryError() == NERR_Success );

    APIERR err = LB_COL_WIDTHS::ReloadColumnWidths( hWnd, hmod, idres );
    if (err == NERR_Success)
    {
        CopyColumnWidths();
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\adminapp\slowcach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    slowcach.cxx
    SLOW_MODE_CACHE module


    FILE HISTORY:
        jonn        22-Mar-1993     Created

*/


#define INCL_NET
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#include <slowcach.hxx>

#include <regkey.hxx>
#include <dbgstr.hxx>
#include <aini.hxx>

// committed to ErnestA to keep cache size at 20 -- CODEWORK contact him abt this
#define SLOW_MODE_CACHE_MAX_SIZE  100
#define SLOW_MODE_CACHE_SEPARATOR SZ(";")
#define SLOW_MODE_CACHE_CHAR_SLOW TCH('l')
#define SLOW_MODE_CACHE_CHAR_FAST TCH('h')
#define SLOW_MODE_CACHE_CHAR_UNKNOWN TCH('?')

#define SLOW_MODE_CACHE_REG_CLASS SZ("GenericClass")

// CODEWORK same as in adminapp.cxx
// BUGBUG BUGBUG change default mapping in registry to USR:Software...
#define AA_SHARED_SECTION       SZ("Shared Parameters")
#define AA_SLOW_MODE            SZ("Slow Mode")


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::SLOW_MODE_CACHE

    SYNOPSIS:  SLOW_MODE_CACHE constructor

    HISTORY:
        jonn        22-Mar-1993 Created

********************************************************************/

SLOW_MODE_CACHE::SLOW_MODE_CACHE() :
    _pstrlistCache ( NULL )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::~SLOW_MODE_CACHE

    SYNOPSIS:  SLOW_MODE_CACHE destructor

    HISTORY:
        jonn        22-Mar-1993 Created

********************************************************************/

SLOW_MODE_CACHE::~SLOW_MODE_CACHE()
{
    delete _pstrlistCache;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::Read

    SYNOPSIS:  Reads data from registry

    HISTORY:
        jonn        22-Mar-1993 Created

********************************************************************/

APIERR SLOW_MODE_CACHE::Read()
{
    APIERR err = NERR_Success;

    do { // error breakout loop

        NLS_STR nlsValue;
        if ( (err = nlsValue.QueryError()) != NERR_Success )
        {
            DBGEOL( "SLOW_MODE_CACHE::Read error allocating cache value " << err );
            break;
        }

        ADMIN_INI aini( AA_SHARED_SECTION );
        if (   (err = aini.QueryError()) != NERR_Success
            || (err = aini.Read( AA_SLOW_MODE, &nlsValue )) != NERR_Success
           )
        {
            DBGEOL( "SLOW_MODE_CACHE::Read: ignored error reading cache value " << err );
            err = NERR_Success;
            delete _pstrlistCache;
            _pstrlistCache = NULL;
            break;
        }

        TRACEEOL( "SLOW_MODE_CACHE::Read reads " << nlsValue );

        STRLIST * pstrlist = new STRLIST( nlsValue.QueryPch(),
                                          SLOW_MODE_CACHE_SEPARATOR );

        if ( pstrlist == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            DBGEOL( "SLOW_MODE_CACHE::Read error creating STRLIST " << err );
            break;
        }

        delete _pstrlistCache;
        _pstrlistCache = pstrlist;

    } while (FALSE); // error breakout loop

    return err;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::Write

    SYNOPSIS:  Writes data to registry

    HISTORY:
        jonn        23-Mar-1993 Created

********************************************************************/

APIERR SLOW_MODE_CACHE::Write()
{
    APIERR err = NERR_Success;

    do { // error breakout loop

        NLS_STR nlsValue;
        if ( (err = nlsValue.QueryError()) != NERR_Success )
        {
            DBGEOL( "SLOW_MODE_CACHE::Write error preparing cache calue " << err );
            break;
        }

        if ( _pstrlistCache != NULL )
        {
            ALIAS_STR nlsSeparator( SLOW_MODE_CACHE_SEPARATOR );
            ITER_STRLIST itersl( *_pstrlistCache );
            NLS_STR * pnls;
            BOOL fFirst = TRUE;
            while ( (pnls = itersl.Next()) != NULL )
            {
                ASSERT( pnls->QueryError() == NERR_Success );
                if (fFirst)
                {
                    fFirst = FALSE;
                }
                else
                {
                    err = nlsValue.Append( nlsSeparator );
                }
                if (   err != NERR_Success
                    || (err = nlsValue.Append( *pnls )) != NERR_Success
                   )
                {
                    DBGEOL( "SLOW_MODE_CACHE::Write error building cache value " << err );
                    break;
                }
            }
        }

        if (err != NERR_Success)
        {
            break;
        }
        TRACEEOL( "SLOW_MODE_CACHE::Write writes " << nlsValue );

        ADMIN_INI aini( AA_SHARED_SECTION );
        if (   (err = aini.QueryError()) != NERR_Success
            || (err = aini.Write( AA_SLOW_MODE, nlsValue.QueryPch() )) != NERR_Success
           )
        {
            DBGEOL( "SLOW_MODE_CACHE::Write error writing cache value " << err );
            break;
        }



    } while (FALSE); // error breakout loop

    return err;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::Query

    SYNOPSIS:  Queries cached data

    HISTORY:
        jonn        23-Mar-1993 Created

********************************************************************/

SLOW_MODE_CACHE_SETTING SLOW_MODE_CACHE::Query( const TCHAR * pchTarget ) const
{
    SLOW_MODE_CACHE_SETTING setting = SLOW_MODE_CACHE_UNKNOWN;

    ALIAS_STR nlsTarget( (pchTarget == NULL) ? SZ("") : pchTarget );

    if ( nlsTarget.strlen() == 0 )
    {
        TRACEEOL( "SLOW_MODE_CACHE::Query(): local focus always fast" );
        setting = SLOW_MODE_CACHE_FAST;
    }
    else if ( _pstrlistCache != NULL )
    {
        ITER_STRLIST itersl( *_pstrlistCache );
        NLS_STR * pnlsCachedTarget;
        NLS_STR * pnlsCachedValue;
        while (   (pnlsCachedTarget = itersl.Next()) != NULL
               && (pnlsCachedValue  = itersl.Next()) != NULL )
        {
            ASSERT(   (pnlsCachedTarget->QueryError() == NERR_Success)
                   && (pnlsCachedValue->QueryError() == NERR_Success) );

            if ( 0 == nlsTarget._stricmp( *pnlsCachedTarget ) )
            {
                setting = ( ( (pnlsCachedValue->QueryPch())[0]
                                    == SLOW_MODE_CACHE_CHAR_SLOW
                            ) ? SLOW_MODE_CACHE_SLOW
                              : SLOW_MODE_CACHE_FAST
                          );
                TRACEEOL( "SLOW_MODE_CACHE::Query found " << nlsTarget );
                break;
            }
        }
    }

    return setting;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::Set

    SYNOPSIS:  Sets cached data

    HISTORY:
        jonn        23-Mar-1993 Created

********************************************************************/

APIERR SLOW_MODE_CACHE::Set( const TCHAR * pchTarget,
                             SLOW_MODE_CACHE_SETTING setting )
{
    ALIAS_STR nlsTarget( (pchTarget == NULL) ? SZ("") : pchTarget );

    if ( nlsTarget.strlen() == 0 )
    {
        TRACEEOL( "SLOW_MODE_CACHE::Set(): local focus always fast" );
        return NERR_Success;
    }

    APIERR err = NERR_Success;

    STRLIST * pstrlist = new STRLIST();

    do { // error breakout loop

        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pstrlist == NULL
            || (err = W_Append( pstrlist, pchTarget, setting )) != NERR_Success
           )
        {
            DBGEOL( "SLOW_MODE_CACHE::Set error creating new cache " << err );
            break;
        }

        if ( _pstrlistCache != NULL )
        {
            ITER_STRLIST itersl( *_pstrlistCache );
            NLS_STR * pnlsCachedTarget;
            NLS_STR * pnlsCachedValue;
            INT nEntries = 1;
            while (   err == NERR_Success
                   && nEntries < SLOW_MODE_CACHE_MAX_SIZE
                   && (pnlsCachedTarget = itersl.Next()) != NULL
                   && (pnlsCachedValue  = itersl.Next()) != NULL
                  )
            {
                ASSERT(   pnlsCachedTarget->QueryError() == NERR_Success
                       && pnlsCachedValue->QueryError() == NERR_Success );

                if ( 0 != nlsTarget._stricmp( *pnlsCachedTarget ) )
                {
                    err = W_Append( pstrlist,
                                    pnlsCachedTarget->QueryPch(),
                                    pnlsCachedValue->QueryPch() );
                    nEntries++;
                }
            }
        }

    } while (FALSE); // error breakout loop

    if (err == NERR_Success)
    {
        delete _pstrlistCache;
        _pstrlistCache = pstrlist;
    }
    else
    {
        delete pstrlist;
    }

    return err;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::Write

    SYNOPSIS:  Reads, modified and writes cached data

    HISTORY:
        jonn        25-Mar-1993 Created

********************************************************************/

APIERR SLOW_MODE_CACHE::Write( const TCHAR * pchTarget, SLOW_MODE_CACHE_SETTING setting )
{
    SLOW_MODE_CACHE slowmodecache;
    APIERR err = NERR_Success;
    if (   (err = slowmodecache.QueryError()) != NERR_Success
        || (err = slowmodecache.Read()) != NERR_Success
        || (err = slowmodecache.Set( pchTarget, setting )) != NERR_Success
        || (err = slowmodecache.Write()) != NERR_Success
       )
    {
        DBGEOL( "SLOW_MODE_CACHE::Write() failed, error " << err );
    }

    return err;
}


/*******************************************************************

    NAME:      SLOW_MODE_CACHE::W_Append

    SYNOPSIS:  Append entry to end of specified STRLIST

    HISTORY:
        jonn        23-Mar-1993 Created

********************************************************************/

APIERR SLOW_MODE_CACHE::W_Append( STRLIST * pstrlist,
                                  const TCHAR * pchTarget,
                                  SLOW_MODE_CACHE_SETTING setting )
{
    TCHAR pchSetting[2];
    pchSetting[0] = SLOW_MODE_CACHE_CHAR_UNKNOWN;
    pchSetting[1] = TCH('\0');
    switch (setting)
    {
        case SLOW_MODE_CACHE_SLOW:
            pchSetting[0] = SLOW_MODE_CACHE_CHAR_SLOW;
            break;
        case SLOW_MODE_CACHE_FAST:
            pchSetting[0] = SLOW_MODE_CACHE_CHAR_FAST;
            break;
        case SLOW_MODE_CACHE_UNKNOWN:
        default:
            ASSERT( FALSE );
            DBGEOL( "SLOW_MODE_CACHE::W_Append(): bad setting" );
            break;
    }

    return W_Append( pstrlist, pchTarget, pchSetting );
}

APIERR SLOW_MODE_CACHE::W_Append( STRLIST * pstrlist,
                                  const TCHAR * pchTarget,
                                  const TCHAR * pchSetting )
{
    ASSERT( pstrlist != NULL );

    NLS_STR * pnlsTarget = new NLS_STR( pchTarget );
    NLS_STR * pnlsSetting = new NLS_STR( pchSetting );
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pnlsTarget == NULL
        || pnlsSetting == NULL
        || (err = pnlsTarget->QueryError()) != NERR_Success
        || (err = pnlsSetting->QueryError()) != NERR_Success
        || (err = pstrlist->Append( pnlsTarget )) != NERR_Success
        || (pnlsTarget = NULL, FALSE)
        || (err = pstrlist->Append( pnlsSetting )) != NERR_Success
       )
    {
        DBGEOL( "SLOW_MODE_CACHE::W_Append(): error " << err );
        delete pnlsTarget;
        delete pnlsSetting;
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\test\whoami\whoami.h ===
#define ID_APPICON      1
#define ID_APPMENU      1

#define IDM_ABOUT       100

#define IDS_WHOAMI_BASE IDS_UI_USRMGR_BASE

#define IDS_Text        (IDS_WHOAMI_BASE+0)
#define IDS_About       (IDS_WHOAMI_BASE+1)
#define IDS_Caption     (IDS_WHOAMI_BASE+2)
#define IDS_DefaultFont (IDS_WHOAMI_BASE+3)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\test\whoami\whoami.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    Whoami.cxx

    FILE HISTORY:
        beng        23-Jun-1992 Created
        beng        08-Aug-1992 After DLLization of BLT
*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <uimsg.h>
    #include <uirsrc.h>

    #include "whoami.h"
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CLIENT
#include <blt.hxx>

#include <uibuffer.hxx>
#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <aini.hxx>


const TCHAR *const szMainWindowTitle = SZ("Who Am I?");


class WHOAMI_WND: public APP_WINDOW
{
private:
    FONT    _font;      // To use when drawing...
    BOOL    _fResized;  // Font needs resizing
    NLS_STR _nlsText;   // Text to render in window

    BOOL    _fHasTitle; // Set if title bar visible

    XYPOINT     _xyRestored;
    XYDIMENSION _dxyRestored;

    VOID TrackPosition( const SIZE_EVENT & );
    VOID TrackPosition( const MOVE_EVENT & );

protected:
    // Redefinitions
    //
    virtual BOOL OnMenuCommand( MID mid );
    virtual BOOL OnResize( const SIZE_EVENT & );
    virtual BOOL OnMove( const MOVE_EVENT & );
    virtual BOOL OnLMouseButtonDblClick( const MOUSE_EVENT & );
    virtual BOOL OnPaintReq();
    virtual BOOL OnDestroy();
    virtual VOID OnShutdown();

    virtual LONG DispatchMessage( const EVENT & );

public:
    WHOAMI_WND();

    const XYPOINT & QueryRestoredPos() const
        { return _xyRestored; }
    const XYDIMENSION & QueryRestoredSize() const
        { return _dxyRestored; }

    VOID EnableTitle( BOOL fEnable, BOOL fShow = TRUE );

    const BOOL IsTitleEnabled() const
        { return _fHasTitle; }
};


class WHOAMI_APP: public APPLICATION
{
private:
    WHOAMI_WND _wndApp;

    static WHOAMI_APP * _vpapp;

public:
    WHOAMI_APP( HANDLE hInstance, INT nCmdShow, UINT, UINT, UINT, UINT );
    ~WHOAMI_APP();

    VOID OnExit();

    static WHOAMI_APP * QueryApp()
        { return _vpapp; }
};


WHOAMI_APP * WHOAMI_APP::_vpapp = NULL;



WHOAMI_APP::WHOAMI_APP( HANDLE hInst, INT nCmdShow,
                        UINT idMinR, UINT idMaxR, UINT idMinS, UINT idMaxS )
    : APPLICATION( hInst, nCmdShow, idMinR, idMaxR, idMinS, idMaxS ),
      _wndApp()
{
    if (QueryError())
        return;

    if (!_wndApp)
    {
        ReportError(_wndApp.QueryError());
        return;
    }

    _vpapp = this;

    ADMIN_INI ini(SZ("whoami"));

    if (!ini)
    {
        ReportError(ini.QueryError());
        return;
    }

    INT xPos, yPos, dxSize, dySize, fHasTitle;
    ini.Read(SZ("x"), &xPos, 0);
    ini.Read(SZ("y"), &yPos, 0);
    ini.Read(SZ("dx"), &dxSize, 200);
    ini.Read(SZ("dy"), &dySize, 40);
    ini.Read(SZ("fHasTitle"), &fHasTitle, 1);

    _wndApp.SetPos(XYPOINT(xPos, yPos), FALSE);
    _wndApp.SetSize(XYDIMENSION(dxSize, dySize), FALSE);
    _wndApp.EnableTitle(fHasTitle, FALSE);
    _wndApp.ShowFirst();
}


WHOAMI_APP::~WHOAMI_APP()
{
    OnExit();
    _vpapp = NULL;
}


VOID WHOAMI_APP::OnExit()
{
    ADMIN_INI ini(SZ("whoami"));

    XYPOINT xy = _wndApp.QueryRestoredPos();
    XYDIMENSION dxy = _wndApp.QueryRestoredSize();

    ini.Write(SZ("x"), (INT)xy.QueryX());
    ini.Write(SZ("y"), (INT)xy.QueryY());
    ini.Write(SZ("dx"), (INT)dxy.QueryWidth());
    ini.Write(SZ("dy"), (INT)dxy.QueryHeight());
    ini.Write(SZ("fHasTitle"), (INT)_wndApp.IsTitleEnabled());
}


WHOAMI_WND::WHOAMI_WND()
    : APP_WINDOW(szMainWindowTitle, ID_APPICON, ID_APPMENU ),
      _font( FONT_DEFAULT_BOLD ),
      _nlsText(),
      _fHasTitle(TRUE),
      _fResized(TRUE), // Start out by calculating true font size
      _xyRestored(0, 0),
      _dxyRestored(0, 0)
{
    if (QueryError())
        return;

    APIERR err;
    if (   (err = _font.QueryError()) != NERR_Success
        || (err = _nlsText.QueryError()) != NERR_Success )
    {
        ReportError(err);
        return;
    }

    TCHAR achUsername[512+1];
    DWORD cchUsername = 512;
    if (! ::GetUserName(achUsername, &cchUsername) )
    {
        ReportError(BLT::MapLastError(ERROR_GEN_FAILURE));
        return;
    }

    if ((err = _nlsText.CopyFrom(achUsername)) != NERR_Success)
    {
        ReportError(err);
        return;
    }
}


BOOL WHOAMI_WND::OnResize( const SIZE_EVENT & e )
{
    TrackPosition(e);
    Invalidate();
    return APP_WINDOW::OnResize(e);
}


BOOL WHOAMI_WND::OnMove( const MOVE_EVENT & e )
{
    TrackPosition(e);
    return APP_WINDOW::OnMove(e);
}


BOOL WHOAMI_WND::OnLMouseButtonDblClick( const MOUSE_EVENT & e )
{
    EnableTitle(!_fHasTitle);
    return TRUE;
}


BOOL WHOAMI_WND::OnDestroy()
{
    ::PostQuitMessage(0);
    return TRUE;
}


VOID WHOAMI_WND::OnShutdown()
{
#if 0
    ::PostQuitMessage(0);
#endif
    WHOAMI_APP::QueryApp()->OnExit();
}


LONG WHOAMI_WND::DispatchMessage( const EVENT & e )
{
    switch (e.QueryMessage())
    {
    case WM_NCLBUTTONDBLCLK: // If we have no title, let doubleclick restore
        if (_fHasTitle)      // it.  Otherwise, do whatever system mandates
            return FALSE;    // (e.g., zoom if on caption).
        else
        {
            EnableTitle(!_fHasTitle);
            return TRUE;
        }

    case WM_NCHITTEST:
        // If we have no title, then always return "caption" to allow
        // moving the window by dragging.

        if (!_fHasTitle && !IsMinimized())
        {
            UINT nHitZone = ::DefWindowProc(QueryHwnd(),
                                            e.QueryMessage(),
                                            e.QueryWParam(),
                                            e.QueryLParam());
            if (nHitZone == HTCLIENT)
                return HTCAPTION;
            else
                return nHitZone;
        }
        else
            return FALSE;

    default:
        break;
    }

    return APP_WINDOW::DispatchMessage(e);
}


BOOL WHOAMI_WND::OnMenuCommand( MID mid )
{
    switch (mid)
    {
    case IDM_ABOUT:
        MsgPopup(this, IDS_About, MPSEV_INFO);
        return TRUE;

    default:
        break;
    }

    // default
    return APP_WINDOW::OnMenuCommand(mid);
}


BOOL WHOAMI_WND::OnPaintReq()
{
    if (QueryError() != NERR_Success)
        return FALSE; // bail out!

    PAINT_DISPLAY_CONTEXT dc(this);
    XYRECT xyrClient(this);

    HBRUSH hbrZap = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
    if (hbrZap == NULL)
        return FALSE;
    ::FillRect(dc.QueryHdc(), (const RECT *)xyrClient, hbrZap);
    ::DeleteObject(hbrZap);

    dc.SelectFont(_font.QueryHandle());
    dc.SetBkColor( ::GetSysColor( COLOR_BTNFACE ) );
    dc.SetTextColor( ::GetSysColor( COLOR_BTNTEXT ) );
    dc.SetTextAlign( TA_LEFT );
    dc.DrawText( _nlsText, (RECT *)(const RECT *)xyrClient,
                 (DT_CENTER|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE) );

    return TRUE;
}


VOID WHOAMI_WND::EnableTitle( BOOL fEnable, BOOL fShow )
{
    if (fEnable == _fHasTitle) // redundancy check
        return;

    DWORD dwStyle = QueryStyle();
    if( !fEnable )
    {
        /* remove caption & menu bar, etc. */
        dwStyle &= ~(WS_DLGFRAME|WS_SYSMENU|WS_MINIMIZEBOX|WS_MAXIMIZEBOX);
        ::SetWindowLong( QueryHwnd(), GWL_ID, 0 );
    }
    else
    {
        /* put menu bar & caption back in */
        dwStyle = WS_TILEDWINDOW | dwStyle;
        ::SetWindowLong( QueryHwnd(), GWL_ID, (LONG)QueryMenu() );
    }

    SetStyle( dwStyle );
    _fHasTitle = fEnable;

    ::SetWindowPos( QueryHwnd(), NULL, 0, 0, 0, 0,
                    SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_FRAMECHANGED );
    if (fShow)
        ::ShowWindow( QueryHwnd(), SW_SHOW );
}


VOID WHOAMI_WND::TrackPosition( const SIZE_EVENT & e )
{
    if ( e.IsNormal() )
    {
        _xyRestored = QueryPos();
        _dxyRestored = QuerySize();
    }
}


VOID WHOAMI_WND::TrackPosition( const MOVE_EVENT & e )
{
    if (!IsMinimized() && !IsMaximized())
    {
        _xyRestored = QueryPos();
    }
}


SET_ROOT_OBJECT( WHOAMI_APP, IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                             IDS_UI_APP_BASE, IDS_UI_APP_LAST )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\setfocus\setfocus.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    setfocus.cxx
    Common dialog for setting the admin app's focus

    FILE HISTORY:
        kevinl      14-Jun-91   Created
        rustanl     04-Sep-1991 Modified to let this dialog do more
                                work (rather than letting ADMIN_APP
                                do the work after this dialog is
                                dismissed)
        KeithMo     06-Oct-1991 Win32 Conversion.
        terryk      18-Nov-1991 Change parent class to BASE_SET_FOCUS_DLG
        Yi-HsinS    18-May-1992 Added _errPrev and call IsDismissApp on
                                Cancel.

*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_NETERRORS
#define INCL_NETLIB
#define INCL_ICANON
#define INCL_NETSERVER
#include <lmui.hxx>

extern "C"
{
    #include <mnet.h>
}

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>
#include <string.hxx>
#include <focusdlg.hxx>
#include <uitrace.hxx>

#include <lmowks.hxx>
#include <lmosrv.hxx>

#include <adminapp.hxx>
#include <setfocus.hxx>
#include <slowcach.hxx> // SLOW_MODE_CACHE


/*******************************************************************

    NAME:       SET_FOCUS_DLG::SET_FOCUS_DLG

    SYNOPSIS:   Constructor

    ENTRY:      fAppAlreadyHasGoodFocus -   Specifies whether or not
                                            app has good focus at the
                                            time this dialog is brought
                                            up.

    RETURN:     An error value, which is NERR_Success on success.

    HISTORY:
        kevinl  14-Jun-91       Created
        terryk  18-Nov-91       Change parent class to BASE_SET_FOCUS_DLG


********************************************************************/

SET_FOCUS_DLG::SET_FOCUS_DLG( ADMIN_APP * paapp,
                              BOOL fAppAlreadyHasGoodFocus,
                              SELECTION_TYPE seltype,
                              ULONG maskDomainSources,
                              const TCHAR * pszDefaultSelection,
                              ULONG nHelpContext,
                              ULONG nServerTypes )
    :   BASE_SET_FOCUS_DLG( paapp->QueryHwnd(),
                            seltype,
                            maskDomainSources,
                            pszDefaultSelection,
                            nHelpContext,
                            NULL,
                            nServerTypes ),
        _fAppHasGoodFocus( fAppAlreadyHasGoodFocus ),
        _paapp( paapp ),
        _errPrev( NERR_Success ),
        _pslowmodecache( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( SupportsRasMode() )
    {
        _pslowmodecache = new SLOW_MODE_CACHE();
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pslowmodecache == NULL
            || (err = _pslowmodecache->QueryError()) != NERR_Success
            || (err = _pslowmodecache->Read()) != NERR_Success
           )
        {
            DBGEOL( "SET_FOCUS_DLG::ctor(): SLOW_MODE_CACHE failed " << err );
            ReportError( err );
            return;
        }

        SetRasMode( _paapp->InRasMode() );
    }
}

SET_FOCUS_DLG::~SET_FOCUS_DLG()
{
    delete _pslowmodecache;
    _pslowmodecache = NULL;
}


/*******************************************************************

    NAME:       SET_FOCUS_DLG::SetNetworkFocus

    SYNOPSIS:   call admin app refresh and set the AppHasGoodFocus variable

    RETURN:     NERR_Success - if operation succeed

    HISTORY:
        kevinl      14-Jun-1991     Created
        terryk      18-Nov-1991     Change parent class to BASE_SET_FOCUS_DLG

********************************************************************/

APIERR SET_FOCUS_DLG::SetNetworkFocus( HWND hwndOwner,
                                       const TCHAR * pszNetworkFocus,
                                       FOCUS_CACHE_SETTING setting )
{
    APIERR err;

    if ( ( err = _paapp->SetNetworkFocus( hwndOwner,
                                          pszNetworkFocus,
                                          setting )) != NERR_Success ||
         ( err = _paapp->OnRefreshNow( TRUE )) != NERR_Success )
    {
        // HandleFocusError should either handle the error or return
        // the error passed in if it is not handled
        APIERR err1 = _paapp->HandleFocusError( err, QueryHwnd() );
        switch ( err1 )
        {
            case NERR_Success:
                break;

            case IERR_DONT_DISMISS_FOCUS_DLG:
            default:
                _fAppHasGoodFocus = FALSE;     // assume that this stepped on
                                               // application's main window
                _errPrev = err;
                break;

        }
        err = err1;
    }

    if ( (err == NERR_Success) && SupportsRasMode() )
    {
        (void) SLOW_MODE_CACHE::Write( _paapp->QueryLocation(),
                                       (SLOW_MODE_CACHE_SETTING)
                                       ( _paapp->InRasMode()
                                             ? SLOW_MODE_CACHE_SLOW
                                             : SLOW_MODE_CACHE_FAST ));
    }

    return err;
}

/*******************************************************************

    NAME:       SET_FOCUS_DLG::OnCancel

    SYNOPSIS:   Called when user hits Cancel

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     05-Sep-1991     Created
        terryk      18-Nov-1991     Change parent class to BASE_SET_FOCUS_DLG

********************************************************************/

BOOL SET_FOCUS_DLG::OnCancel()
{
    if ( ! _fAppHasGoodFocus )
    {
        BOOL fDismissApp = _paapp->IsDismissApp( _errPrev );
        if ( fDismissApp )
        {

            //  This will cause the app to terminate.  Better confirm with
            //  user first.
            if ( IDCANCEL == ::MsgPopup( this,
                                         IDS_NO_FOCUS_QUIT_APP,
                                         MPSEV_WARNING,
                                         MP_OKCANCEL        ))
            {
                //  Return without dismissing dialog
                return TRUE;    // message was handled
            }
        }
        _fAppHasGoodFocus = !fDismissApp;
    }

    //  Dismiss the dialog, returning whether or not the app has good
    //  focus at this time
    Dismiss( _fAppHasGoodFocus );
    return TRUE;    // message was handled
}

/*******************************************************************

    NAME:       SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      UINT * pnRetVal         return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR SET_FOCUS_DLG::Process ( UINT * pnRetVal )
{
    ShowArea( SupportsRasMode() );
    return DIALOG_WINDOW::Process( pnRetVal ) ;
}


/*******************************************************************

    NAME:       SET_FOCUS_DLG::Process

    SYNOPSIS:   Run the dialog after first displaying it in its default
                (reduced) size.

    ENTRY:      BOOL * pfRetVal         BOOL return value from dialog

    EXIT:       APIERR  if failure to function

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/

APIERR SET_FOCUS_DLG::Process ( BOOL * pfRetVal )
{
    ShowArea( SupportsRasMode() );
    return DIALOG_WINDOW::Process( pfRetVal ) ;
}


/*******************************************************************

    NAME:       SET_FOCUS_DLG::ReadFocusCache

    HISTORY:
        jonn    24-Mar-1993     Created

********************************************************************/

FOCUS_CACHE_SETTING SET_FOCUS_DLG::ReadFocusCache( const TCHAR * pszFocus ) const
{
    FOCUS_CACHE_SETTING setting = FOCUS_CACHE_UNKNOWN;
    if (_pslowmodecache != NULL)
    {
        switch (_pslowmodecache->Query( pszFocus ))
        {
            case SLOW_MODE_CACHE_SLOW:
                setting = FOCUS_CACHE_SLOW;
                break;
            case SLOW_MODE_CACHE_FAST:
                setting = FOCUS_CACHE_FAST;
                break;
            case SLOW_MODE_CACHE_UNKNOWN:
                setting = FOCUS_CACHE_UNKNOWN;
                break;
            default:
                DBGEOL( "SET_FOCUS_DIALOG::ReadFocusCache: bad cache" );
                setting = FOCUS_CACHE_UNKNOWN;
                break;
        }
    }

    return setting;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\common\src\adminapp\test\testaapp.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    AdminApp.cxx

    This file contains the unit test for admin app

    FILE HISTORY:
	Johnl	14-May-1991	Created
	JonN	14-Oct-1991	Installed refresh lockcount

*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#include <blt.hxx>

#include <lmoloc.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>

#include <adminapp.hxx>

#include "testaapp.hxx"

MY_ADMIN_APP::MY_ADMIN_APP()
    : ADMIN_APP( IDS_TESTAPPNAME,
		 IDS_TESTOBJECTNAME,
		 IDS_TESTINISECTIONNAME,
		 IDS_TESTHELPFILENAME,
		 SZ("TestAppStartupDialog"),
		 SZ("TestAppAboutBox"),
		 SZ("TestAdminAppMenu"),
		 SZ("TestAdminAppAccel"),
		 SZ("TestAdminAppIcon")	)
{
    if ( QueryError() != NERR_Success )
    {
	UIDEBUG(SZ("MY_ADMIN_APP::MY_ADMIN_APP - Construction failed\n\r")) ;
	return ;
    }

    /* Do any necessary initialization (esp. network related) here before
     * calling startup.  The focus has *not* been set yet.
     */

    APIERR err = AdminAppInit( __argc, __argv ) ;

    if ( err != NERR_Success )
    {
	ReportError( err ) ;
	return ;
    }

}

/* menu messages come in here.	Make sure you call
 * ADMIN_APP::OnCommand for any messages you don't handle.
 */
BOOL MY_ADMIN_APP::OnMenuCommand( MID midMenuItem )
{
    switch ( midMenuItem )
    {
    case IDM_MY_APP_CUSTOM:
	MessageBox( QueryHwnd(), SZ("Custom Menu item event"), SZ("MY_ADMIN_APP"), IDOK ) ;
	return TRUE ;

    default:
	return ADMIN_APP::OnMenuCommand( midMenuItem ) ;
	break ;
    }

    return FALSE ;
}


void MY_ADMIN_APP::OnRefresh( void )
{
    static iRefreshCount = 0 ;

    DISPLAY_CONTEXT dc( QueryHwnd() ) ;
    char buff[100] ;
    ::wsprintf( buff, SZ("Refresh %d"), ++iRefreshCount ) ;
    ::TextOut( dc.QueryHdc(), 15, 15, buff, ::strlenf(buff) ) ;
}

MY_ADMIN_APP *pmyadminapp ;

BOOL APPSTART::Init(
    TCHAR * pszCmdLine,
    INT    nShow)
{
    UNREFERENCED(pszCmdLine);
    UNREFERENCED(nShow);

    /* Create a main window for this application instance.  */

    ::pmyadminapp = new MY_ADMIN_APP ;

    if (!pmyadminapp)
    {
	MsgPopup( (HWND)NULL, ERROR_NOT_ENOUGH_MEMORY, MPSEV_ERROR ) ;
	return FALSE;
    }

    if (pmyadminapp->QueryError() != NERR_Success )
    {
	if ( pmyadminapp->QueryError() != IERR_USERQUIT )
	    MsgPopup( (HWND)NULL, pmyadminapp->QueryError(), MPSEV_ERROR ) ;

	return FALSE;
    }

    pmyadminapp->Show();
    pmyadminapp->Repaint();
    pmyadminapp->RepaintNow();

    pmyadminapp->DismissStartupDialog() ;
    // should not be necessary to explicitly EnableRefresh()

    return TRUE;
}

VOID APPSTART::Term()
{
    delete pmyadminapp ;
}


ULONG MY_ADMIN_APP::QueryHelpContext( enum HELP_OPTIONS helpOptions )
{
    return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\h\nldlg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nldlg.h

    This file contains the ID constants used by the Domain Monitor.

    FILE HISTORY:
          Congpay           4-June-1993         Created.

*/

#ifndef _NLDLG_H_
#define _NLDLG_H_

#include <uimsg.h>

#define ID_APPICON   1
#define ID_APPMENU   1
#define ID_APPACCEL  1

// Menu IDs
//
#define IDM_DMAPP_BASE          IDM_ADMINAPP_LAST

#define IDM_REMOVE              (IDM_DMAPP_BASE+2)

#define IDM_INTERVALS           (IDM_DMAPP_BASE+3)
#define IDM_MONITORTD           (IDM_DMAPP_BASE+4)
#define IDM_LOCALREFRESH        (IDM_DMAPP_BASE+5)

//
// Main Window ListBox Control ID
//

#define IDC_MAINWINDOWLB        401

//
// Main Window ListBox Column Header Control ID
//

#define IDC_COLHEAD_DM      402

//
// Main Window ListBox Bitmap IDs
//

#define BMID_HEALTHY_TYPE    403
#define BMID_PROBLEM_TYPE    404
#define BMID_ILL_TYPE        405
#define BMID_DEAD_TYPE       406
#define BMID_UNKNOWN_TYPE    407
#define BMID_LB_ACPDC          408
#define BMID_LB_INPDC          409
#define BMID_LB_ACBDC          410
#define BMID_LB_INBDC          411
#define BMID_LB_ACLDC          412
#define BMID_LB_INLDC          413

//
// String ranges!
//

#define IDS_DMAPP_BASE          IDS_UI_APP_BASE
#define IDS_DMAPP_LAST          IDS_UI_APP_LAST

//
// Strings for main window
//

#define IDS_DMAPPNAME                     (IDS_DMAPP_BASE+1)
#define IDS_DMOBJECTNAME                  (IDS_DMAPP_BASE+2)
#define IDS_DMINISECTIONNAME              (IDS_DMAPP_BASE+3)
#define IDS_DMHELPFILENAME                (IDS_DMAPP_BASE+4)

//
// Strings for column headers
//

#define IDS_COL_HEADER_DM_DOMAIN          (IDS_DMAPP_BASE+5)
#define IDS_COL_HEADER_DM_PDC             (IDS_DMAPP_BASE+6)
#define IDS_COL_HEADER_DM_TD              (IDS_DMAPP_BASE+7)

#define IDS_CAPTION                       (IDS_DMAPP_BASE+8)
#define IDS_WAITING                       (IDS_DMAPP_BASE+9)
#define IDS_SPACE                         (IDS_DMAPP_BASE+10)
#define IDS_COMMA                         (IDS_DMAPP_BASE+11)
#define IDS_INSYNC                        (IDS_DMAPP_BASE+12)
#define IDS_INPROGRESS                    (IDS_DMAPP_BASE+13)
#define IDS_REPLREQUIRED                  (IDS_DMAPP_BASE+14)
#define IDS_UNKNOWN                       (IDS_DMAPP_BASE+15)
#define IDS_ONLINE                        (IDS_DMAPP_BASE+16)
#define IDS_OFFLINE                       (IDS_DMAPP_BASE+17)
#define IDS_SUCCESS                       (IDS_DMAPP_BASE+18)
#define IDS_ERROR                         (IDS_DMAPP_BASE+19)
#define IDS_ERROR_BAD_NETPATH             (IDS_DMAPP_BASE+20)

#define IDS_ERROR_LOGON_FAILURE             (IDS_DMAPP_BASE+22)
#define IDS_ERROR_ACCESS_DENIED             (IDS_DMAPP_BASE+23)
#define IDS_ERROR_NOT_SUPPORTED             (IDS_DMAPP_BASE+24)
#define IDS_ERROR_NO_LOGON_SERVERS          (IDS_DMAPP_BASE+25)
#define IDS_ERROR_NO_SUCH_DOMAIN            (IDS_DMAPP_BASE+26)
#define IDS_ERROR_NO_TRUST_LSA_SECRET       (IDS_DMAPP_BASE+27)
#define IDS_ERROR_NO_TRUST_SAM_ACCOUNT      (IDS_DMAPP_BASE+28)
#define IDS_ERROR_DOMAIN_TRUST_INCONSISTENT (IDS_DMAPP_BASE+29)
#define IDS_ERROR_FILE_NOT_FOUND            (IDS_DMAPP_BASE+30)
#define IDS_ERROR_INVALID_DOMAIN_ROLE       (IDS_DMAPP_BASE+31)
#define IDS_ERROR_INVALID_DOMAIN_STATE      (IDS_DMAPP_BASE+32)
#define IDS_ERROR_NO_BROWSER_SERVERS_FOUND  (IDS_DMAPP_BASE+33)
#define IDS_ERROR_NOT_ENOUGH_MEMORY         (IDS_DMAPP_BASE+34)
#define IDS_ERROR_NETWORK_BUSY              (IDS_DMAPP_BASE+35)
#define IDS_ERROR_REQ_NOT_ACCEP             (IDS_DMAPP_BASE+36)
#define IDS_ERROR_VC_DISCONNECTED           (IDS_DMAPP_BASE+37)
#define IDS_NERR_DCNotFound                 (IDS_DMAPP_BASE+38)
#define IDS_NERR_NetNotStarted              (IDS_DMAPP_BASE+39)
#define IDS_NERR_WkstaNotStarted            (IDS_DMAPP_BASE+40)
#define IDS_NERR_ServerNotStarted           (IDS_DMAPP_BASE+41)
#define IDS_NERR_BrowserNotStarted          (IDS_DMAPP_BASE+42)
#define IDS_NERR_ServiceNotInstalled        (IDS_DMAPP_BASE+43)
#define IDS_NERR_BadTransactConfig          (IDS_DMAPP_BASE+44)
#define IDS_NERR_BadServiceName             (IDS_DMAPP_BASE+45)
#define IDS_NERR_NoNetLogon                 (IDS_DMAPP_BASE+46)

#define IDS_LINK_STATUS                   (IDS_DMAPP_BASE+50)
#define IDS_TO_TRUSTED_DOMAIN             (IDS_DMAPP_BASE+51)

#define IDS_NO_PDC                        (IDS_DMAPP_BASE+52)
#define IDS_EMPTY_STRING                  (IDS_DMAPP_BASE+53)

// IDs for intervals dialog
#define IDD_INTERVALS_DIALOG                    100
#define IDID_INTERVALS                          101

// IDs for TDC dialog
#define IDD_DC_DIALOG                          200
#define IDDC_LISTBOX                           201

// IDs for DC dialog
#define IDD_DCTD_DIALOG                           300
#define IDDCTD_DC_LISTBOX                         301
#define IDDCTD_DCNAME                             308
#define IDDCTD_TD_LISTBOX                         309
#define IDDCTD_DISCONNECT                         313
#define IDDCTD_SHOW_TDC                           314

// ID for the main widow list box
#define ID_RESOURCE                             500

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\nlmon\nldc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nldc.cxx

    The domain controller's status dialog.

    FILE HISTORY:
        CongpaY         3-June-993      Created
*/

#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <strnumer.hxx>

extern "C"
{
    #include <nldlg.h>
    #include <nlmon.h>
    #include <nlhelp.h>
    #include <mnet.h>
}

#include <nldc.hxx>

#define NUM_DC_LISTBOX_COLUMNS 6
#define NUM_DCTD_LISTBOX_COLUMNS 7
#define NUM_TD_LISTBOX_COLUMNS 4

void ConvertError (NLS_STR * pnlsString, DWORD dwError);

/*******************************************************************

    NAME:       DC_LBI :: DC_LBI

    SYNOPSIS:   DC_LBI class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_LBI :: DC_LBI( PDC_ENTRY pDCEntryList,
                  BOOL      fDownLevel,
                  DMID_DTE * pdte)
  : BASE_DC_LBI ((pDCEntryList == NULL )? NULL : (pDCEntryList->DCName).Buffer),
    _fDownLevel (fDownLevel),
    _pdte (pdte),
    _nlsDCName ((pDCEntryList == NULL )? NULL : (pDCEntryList->DCName).Buffer)
{
    UIASSERT( pDCEntryList != NULL );
    UIASSERT( pdte != NULL );

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if (!_nlsDCName)
    {
        ReportError (_nlsDCName.QueryError());
        return;
    }

    // Set DCStatus to be OnLine or OffLine.
    if (pDCEntryList->State == DCOnLine)
    {
        _nlsState.Load (IDS_ONLINE);
    }
    else
    {
        _nlsState.Load (IDS_OFFLINE);
    }

    if (!_nlsState)
    {
        ReportError (_nlsState.QueryError());
        return;
    }

    ConvertError (&_nlsStatus, pDCEntryList->DCStatus);

    if (!fDownLevel) // We don't know the status. Just show blank space.
    {
        // Set the ReplStatus.
        if (pDCEntryList->ReplicationStatus == 0)
        {
            _nlsReplStatus.Load(IDS_INSYNC);
        }
        else if (pDCEntryList->ReplicationStatus & NETLOGON_REPLICATION_IN_PROGRESS)
        {
            _nlsReplStatus.Load(IDS_INPROGRESS);
        }
        else if (pDCEntryList->ReplicationStatus & NETLOGON_REPLICATION_NEEDED)
        {
            _nlsReplStatus.Load(IDS_REPLREQUIRED);
        }
        else
        {
            _nlsReplStatus.Load(IDS_UNKNOWN);
        }

        if (!_nlsReplStatus)
        {
            ReportError (_nlsReplStatus.QueryError());
            return;
        }

        // Set the PDCLinkStatus.
        ConvertError (&_nlsPDCLinkStatus, pDCEntryList->PDCLinkStatus);
    }
}

/*******************************************************************

    NAME:       DC_LBI :: ~DC_LBI

    SYNOPSIS:   DC_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_LBI :: ~DC_LBI()
{
    _pdte = NULL;

}

/*******************************************************************

    NAME:       DC_LBI :: Paint

    SYNOPSIS:   Draw an entry in DC_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
VOID DC_LBI :: Paint( LISTBOX *        plb,
                      HDC              hdc,
                      const RECT     * prect,
                      GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteDCName( _nlsDCName);
    STR_DTE dteState ( _nlsState );
    STR_DTE dteStatus (_nlsStatus);

    DISPLAY_TABLE dtab( NUM_DC_LISTBOX_COLUMNS,
                        ((DC_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = _pdte;
    dtab[1] = &dteDCName;
    dtab[2] = &dteState;
    dtab[3] = &dteStatus;

    if (!_fDownLevel)
    {
        STR_DTE dteReplStatus ( _nlsReplStatus.QueryPch() );
        STR_DTE dtePDCLinkStatus ( _nlsPDCLinkStatus.QueryPch() );

        dtab[4] = &dteReplStatus;
        dtab[5] = &dtePDCLinkStatus;
    }

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // DC_LBI :: Paint


/*******************************************************************

    NAME:       DCTD_LBI :: DCTD_LBI

    SYNOPSIS:   DCTD_LBI class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DCTD_LBI :: DCTD_LBI( PDC_ENTRY pDCEntryList,
                      BOOL      fDownLevel,
                      DMID_DTE * pdte)
  : DC_LBI (pDCEntryList, FALSE, pdte),
    _fDownLevel (fDownLevel)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    if (!fDownLevel)
    {
        // Set the TDCLinkStatus.
        _nlsTDCLinkStatus.Load (pDCEntryList->TDCLinkState? IDS_SUCCESS : IDS_ERROR);

        if (!_nlsTDCLinkStatus)
        {
            ReportError (_nlsTDCLinkStatus.QueryError());
        }
    }
}

/*******************************************************************

    NAME:       DCTD_LBI :: ~DCTD_LBI

    SYNOPSIS:   DCTD_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DCTD_LBI :: ~DCTD_LBI()
{
}

/*******************************************************************

    NAME:       DCTD_LBI :: Paint

    SYNOPSIS:   Draw an entry in DC_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
VOID DCTD_LBI :: Paint( LISTBOX *        plb,
                      HDC              hdc,
                      const RECT     * prect,
                      GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteDCName( QueryDCName().QueryPch());
    STR_DTE dteState ( QueryState().QueryPch() );
    STR_DTE dteStatus (QueryStatus().QueryPch());

    DISPLAY_TABLE dtab( NUM_DCTD_LISTBOX_COLUMNS,
                        ((DC_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = QueryPDTE();
    dtab[1] = &dteDCName;
    dtab[2] = &dteState;
    dtab[3] = &dteStatus;

    if (!_fDownLevel)
    {
        STR_DTE dteReplStatus ( QueryReplStatus().QueryPch() );
        STR_DTE dtePDCLinkStatus (QueryPDCLinkStatus().QueryPch());
        STR_DTE dteTDCLinkStatus ( _nlsTDCLinkStatus);

        dtab[4] = &dteReplStatus;
        dtab[5] = &dtePDCLinkStatus;
        dtab[6] = &dteTDCLinkStatus;
    }

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // DCTD_LBI :: Paint

/*******************************************************************

    NAME:       DC_LISTBOX :: DC_LISTBOX

    SYNOPSIS:   DC_LISTBOX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_LISTBOX :: DC_LISTBOX( OWNER_WINDOW   * powOwner,
                                CID              cid,
                                NLS_STR          nlsDomain,
                                const TCHAR *    lpTrustedDomain)
  : BASE_DC_LISTBOX( powOwner,
                     cid,
                     (lpTrustedDomain == NULL) ?
                      NUM_DCTD_LISTBOX_COLUMNS:
                      NUM_DC_LISTBOX_COLUMNS,
                     nlsDomain),
    _dteACPDC( BMID_LB_ACPDC ),
    _dteINPDC( BMID_LB_INPDC ),
    _dteACBDC( BMID_LB_ACBDC ),
    _dteINBDC( BMID_LB_INBDC ),
    _dteACLDC( BMID_LB_ACLDC),
    _dteINLDC( BMID_LB_INLDC),
    _nlsDomain (nlsDomain),
    _nlsTrustedDomain (lpTrustedDomain),
    _fDCTDDialog ((lpTrustedDomain == NULL)? TRUE : FALSE)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _dteACPDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteINPDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteACBDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteINBDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteACLDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteINLDC.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsDomain.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsTrustedDomain.QueryError()    ) != NERR_Success ) )
    {
        ReportError( err );
    }

}   // DC_LISTBOX :: DC_LISTBOX


/*******************************************************************

    NAME:       DC_LISTBOX :: ~DC_LISTBOX

    SYNOPSIS:   DC_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_LISTBOX :: ~DC_LISTBOX()
{
}

/*******************************************************************

    NAME:       DC_LISTBOX :: Fill


    SYNOPSIS:   Fills the listbox with the available dc status.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
APIERR DC_LISTBOX :: Fill( VOID )
{
    APIERR err = NERR_Success;
    PLIST_ENTRY pDCList;

    LOCK_LISTS();

    if (_fDCTDDialog) // DC_LISTBOX in DCTD_DIALOG
    {
        pDCList = QueryDCList ((const LPTSTR)_nlsDomain.QueryPch());
    }
    else  // DC_LISTBOX in DC_DIALOG
    {
        pDCList = QueryTDCList ((const LPTSTR)_nlsDomain.QueryPch(),
                                (const LPTSTR)_nlsTrustedDomain.QueryPch());
    }

    if( pDCList == NULL)
    {
         UNLOCK_LISTS();
         return (ERROR_DC_NOT_FOUND);
    }

    SetRedraw( FALSE );
    DeleteAllItems();

    PLIST_ENTRY pNextEntry;
    PDC_ENTRY pDCEntry;
    //
    //  For iterating the available dc
    //
    for (pNextEntry = pDCList->Flink;
         pNextEntry != pDCList;
         pNextEntry = pNextEntry->Flink)
    {
        pDCEntry = (PDC_ENTRY) pNextEntry;

        DMID_DTE * pdte = NULL;

        BOOL fActive = (pDCEntry->State == DCOnLine);

        BOOL fDownLevel = FALSE;

        // Initialize the dc type icon.
        switch( pDCEntry->Type)
        {
        case NTPDC:
            pdte = fActive? &_dteACPDC : &_dteINPDC;
            break;

        case NTBDC:
            pdte = fActive? &_dteACBDC : &_dteINBDC;
            break;

        case LMBDC:
            fDownLevel = TRUE;
            pdte = fActive? &_dteACLDC : &_dteINLDC;
            break;

        default:
            pdte = NULL;
            break;
        }

        DC_LBI * pslbi = _fDCTDDialog? new DCTD_LBI( pDCEntry, fDownLevel, pdte)
                                   : new DC_LBI( pDCEntry, fDownLevel, pdte);

        if( AddItem( pslbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    UNLOCK_LISTS();

    SetRedraw( TRUE );
    Invalidate( TRUE );

    if (QueryCount() > 0)
    {
        SelectItem(0);
    }

    return err;

}   // DC_LISTBOX :: Fill


/*******************************************************************

    NAME:       DC_DIALOG :: DC_DIALOG

    SYNOPSIS:   DC_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_DIALOG :: DC_DIALOG( HWND             hWndOwner,
                          const TCHAR *    pszResourceName,
                          UINT             idCaption,
                          CID              cidDCListBox,
                          NLS_STR          nlsDomain,
                          NLS_STR          nlsTrustedDomain)
  :BASE_DC_DIALOG ( hWndOwner,
                    pszResourceName,
                    idCaption,
                    &_lbDC,
                    nlsTrustedDomain),
   _lbDC ( this, cidDCListBox, nlsDomain, nlsTrustedDomain.QueryPch())
{
    if (QueryError() != NERR_Success)
    {
        return;
    }

    APIERR err;

    if ((err = _lbDC.Fill()) != NERR_Success)
    {
        ReportError (err);
    }
}

/*******************************************************************

    NAME:       DC_DIALOG :: ~DC_DIALOG

    SYNOPSIS:   DC_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DC_DIALOG:: ~DC_DIALOG()
{
}

/*******************************************************************

    NAME:       DC_DIALOG:: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
ULONG DC_DIALOG :: QueryHelpContext( void )
{
    return HC_DC_DIALOG;

}   //DC_DIALOG :: QueryHelpContext

/*******************************************************************

    NAME:       TD_LBI :: TD_LBI

    SYNOPSIS:   TD_LBI class constructor. Showes the trusted domains.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
TD_LBI :: TD_LBI( PTD_LINK pTDLink)
  : BASE_DC_LBI ((pTDLink == NULL)? NULL : (pTDLink->TDName).Buffer)
{
    UIASSERT (pTDLink != NULL);

    if (QueryError() != NERR_Success)
    {
        return;
    }

    APIERR err;
    TCHAR szDomain[DNLEN+1];

    err = ::I_MNetNameCanonicalize (NULL,
                                    (pTDLink->TDName).Buffer,
                                    szDomain,
                                    sizeof (szDomain)-2,
                                    NAMETYPE_DOMAIN,
                                    0L);
    if (err != NERR_Success)
    {
        ReportError (err);
        return;
    }
    else
    {
        _nlsTD.CopyFrom (szDomain);
    }

    if ((err = _nlsTD.QueryError()) != NERR_Success)
    {
        ReportError(err);
        return;
    }

    // Set Trusted Domain's Domain Controller.
    if ((pTDLink->DCName).Length == 0)
    {
        _nlsTDC.Load (IDS_UNKNOWN);
    }
    else
    {
        _nlsTDC.CopyFrom ((pTDLink->DCName).Buffer);
    }

    if ((err = _nlsTDC.QueryError()) != NERR_Success)
    {
        ReportError(err);
    }

    ConvertError (&_nlsTSCStatus, pTDLink->SecureChannelStatus);
}

/*******************************************************************

    NAME:       TD_LBI :: ~TD_LBI

    SYNOPSIS:   TD_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
TD_LBI :: ~TD_LBI()
{

}

/*******************************************************************

    NAME:       TD_LBI :: Paint

    SYNOPSIS:   Draw an entry in TD_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
VOID TD_LBI :: Paint( LISTBOX *        plb,
                      HDC              hdc,
                      const RECT     * prect,
                      GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteTD ( _nlsTD);
    STR_DTE dteTDC ( _nlsTDC );
    STR_DTE dteTSCStatus ( _nlsTSCStatus.QueryPch() );

    DISPLAY_TABLE dtab( NUM_TD_LISTBOX_COLUMNS,
                        ((TD_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[1] = &dteTD;
    dtab[2] = &dteTDC;
    dtab[3] = &dteTSCStatus;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // TD_LBI :: Paint


/*******************************************************************

    NAME:       TD_LISTBOX :: TD_LISTBOX

    SYNOPSIS:   TD_LISTBOX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
TD_LISTBOX :: TD_LISTBOX( OWNER_WINDOW   * powOwner,
                          CID              cid,
                          NLS_STR          nlsDomain,
                          NLS_STR          nlsDCName)
  : BASE_DC_LISTBOX( powOwner, cid, NUM_TD_LISTBOX_COLUMNS, nlsDomain ),
    _nlsDomain (nlsDomain),
    _nlsDCName (nlsDCName),
    _sltDCName (powOwner, IDDCTD_DCNAME)
{
    if (QueryError() != NERR_Success)
    {
        return;
    }

    APIERR err;
    if( ((err = _nlsDomain.QueryError()) != NERR_Success) ||
        ((err = _nlsDCName.QueryError()) != NERR_Success) )
    {
        ReportError(err);
    }
}   // TD_LISTBOX :: TD_LISTBOX

/*******************************************************************

    NAME:       TD_LISTBOX :: ~TD_LISTBOX

    SYNOPSIS:   TD_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
TD_LISTBOX :: ~TD_LISTBOX()
{
}

/*******************************************************************

    NAME:       TD_LISTBOX :: SetDCName

    SYNOPSIS:   It's called when user select a different dc in the DC_LISTBOX

    EXIT:

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
APIERR TD_LISTBOX :: SetDCName(const NLS_STR & nlsDCName)
{
    return _nlsDCName.CopyFrom (nlsDCName);
}

/*******************************************************************

    NAME:       TD_LISTBOX :: Fill

    SYNOPSIS:   Fills the listbox with the trusted domain entries

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
APIERR TD_LISTBOX :: Fill( VOID )
{
    LOCK_LISTS();

    PLIST_ENTRY pTDLink = QueryTDLink ((const LPTSTR) _nlsDomain.QueryPch(),
                                       (const LPTSTR) _nlsDCName.QueryPch());

    if( pTDLink == NULL)
    {
        UNLOCK_LISTS();
        return (NERR_Success);
    }


    SetRedraw( FALSE );
    DeleteAllItems();

    PLIST_ENTRY pNextEntry;
    PTD_LINK pTDLinkEntry;
    //
    //  For iterating the available trusted domain.
    //

    APIERR err = NERR_Success;

    for (pNextEntry = pTDLink->Flink;
         pNextEntry != pTDLink;
         pNextEntry = pNextEntry->Flink)
    {
        pTDLinkEntry = (PTD_LINK) pNextEntry;

        TD_LBI * pslbi = new TD_LBI( pTDLinkEntry);

        if( AddItem( pslbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    UNLOCK_LISTS();

    if (QueryCount() > 0)
    {
        SelectItem(0);
    }

    // Try to make a complete sentence.
    NLS_STR nlsToTrustedDomain;
    nlsToTrustedDomain.Load (IDS_TO_TRUSTED_DOMAIN);

    if ((err= nlsToTrustedDomain.QueryError()) == NERR_Success)
    {
        NLS_STR nlsTemp;
        nlsTemp.Load (IDS_LINK_STATUS);
        nlsTemp.Append (_nlsDCName);
        nlsTemp.Append (nlsToTrustedDomain);

        if ((err= nlsTemp.QueryError()) == NERR_Success)
        {
            _sltDCName.SetText(nlsTemp);
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // TD_LISTBOX :: Fill



/*******************************************************************

    NAME:       DCTD_DIALOG ::DCTD_DIALOG

    SYNOPSIS:   DCTD_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DCTD_DIALOG :: DCTD_DIALOG( HWND             hWndOwner,
                        const TCHAR *    pszResourceName,
                        UINT             idCaption,
                        CID              cidDCListBox,
                        CID              cidTDListBox,
                        NLS_STR          nlsDomain,
                        BOOL             fMonitorTD)
  :BASE_DC_DIALOG (hWndOwner,
                   pszResourceName,
                   idCaption,
                   &_lbDC,
                   nlsDomain),
   _lbDC (this, cidDCListBox, nlsDomain, NULL),
   _lbTD (this, cidTDListBox, nlsDomain, nlsDomain),
   _fMonitorTD (fMonitorTD),
   _nlsDomain (nlsDomain),
   _pbDisconnect (this, IDDCTD_DISCONNECT),
   _pbShowTD (this, IDDCTD_SHOW_TDC)
{
    if (QueryError() != NERR_Success)
    {
        return;
    }

    // Fill the top list box - DC_LISTBOX.
    APIERR err = NERR_Success;
    if (((err = _nlsDomain.QueryError()) != NERR_Success) ||
        ((err = _lbDC.Fill()) != NERR_Success) )
    {
        ReportError (err);
        return;
    }

    DC_LBI * plbi =  (DC_LBI *) _lbDC.QueryItem();

    // Fil the bottom list box - TD_LISTBOX.
    if (plbi != NULL)
    {
        if ( ((err = _lbTD.SetDCName (plbi->QueryDCName())) != NERR_Success) ||
             ((err = _lbTD.Fill()) != NERR_Success) )
        {
            ReportError (err);
            return;
        }
    }

    SetPushButton();
}

/*******************************************************************

    NAME:       DCTD_DIALOG :: ~DCTD_DIALOG

    SYNOPSIS:   DCTD_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
DCTD_DIALOG:: ~DCTD_DIALOG()
{
}

/*******************************************************************

    NAME:       DCTD_DIALOG:: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
ULONG DCTD_DIALOG :: QueryHelpContext( void )
{
    return HC_DCTD_DIALOG;

}   //DCTD_DIALOG :: QueryHelpContext

/*******************************************************************

    NAME:       DCTD_DIALOG :: SetPushButton

    SYNOPSIS:   DCTD_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
VOID DCTD_DIALOG:: SetPushButton(VOID)
{
    if (_lbTD.QueryCount() < 1)
    {
        _pbDisconnect.Enable(FALSE);
        _pbShowTD.Enable(FALSE);
    }
    else
    {
        _pbShowTD.Enable(_fMonitorTD);
        _pbDisconnect.Enable(TRUE);
    }
}

/*******************************************************************

    NAME:       DCTD_DIALOG :: OnCommand

    SYNOPSIS:

    EXIT:

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
BOOL DCTD_DIALOG::OnCommand (const CONTROL_EVENT & event)
{
    AUTO_CURSOR autocur;

    switch (event.QueryCid())
    {
    case IDDCTD_DC_LISTBOX:
        if (event.QueryCode() == LBN_SELCHANGE)
        {
            OnSelChange();
        }

        return TRUE;

    case IDDCTD_DISCONNECT:
        OnDisconnect();

        return TRUE;

    case IDDCTD_TD_LISTBOX:
        if ((event.QueryCode() != LBN_DBLCLK) ||
            (!_fMonitorTD ))
        {
            break;
        }

    case IDDCTD_SHOW_TDC:
        OnShowTrustedDomain();
        return TRUE;

    default:
        return (DIALOG_WINDOW::OnCommand(event));
    }

    return FALSE;
}

/*******************************************************************

    NAME:       DCTD_DIALOG :: OnSelChange()

    SYNOPSIS:   It's called when user select a different dc in the
                DC_LISTBOX.

    RETURNS:

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/

VOID DCTD_DIALOG::OnSelChange (VOID)
{
    DC_LBI * plbi = (DC_LBI *) _lbDC.QueryItem();

    if (plbi == NULL)
    {
        UIASSERT (FALSE);
        return;
    }

    APIERR err;
    if (((err = _lbTD.SetDCName (plbi->QueryDCName())) != NERR_Success) ||
        ((err = _lbTD.Fill()) != NERR_Success) )
    {
        ::MsgPopup (this, err);
        return;
    }

    SetPushButton();
}

/*******************************************************************

    NAME:       DCTD_DIALOG :: OnDisConnect()

    SYNOPSIS:   Disconnect the link to the trusted dc. Replace with
                a new successful link to the trusted domain.

    RETURNS:

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/

VOID DCTD_DIALOG :: OnDisconnect( void )
{
    DC_LBI * plbiDC = (DC_LBI * ) _lbDC.QueryItem();
    TD_LBI * plbiTD = (TD_LBI * ) _lbTD.QueryItem();

    if ((plbiDC == NULL) ||
        (plbiTD == NULL) )
    {
        ::MsgPopup (this, ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    APIERR err;

    if ( ((err = DisConnect ((const LPTSTR)_nlsDomain.QueryPch(),
                             (const LPTSTR)(plbiDC->QueryDCName()).QueryPch(),
                             (const LPTSTR)(plbiTD->QueryTD()).QueryPch())) != NERR_Success) ||
         ((err = _lbTD.Fill()) != NERR_Success) )
    {
        ::MsgPopup (this, err);
    }
}

/*******************************************************************

    NAME:       DCTD_DIALOG :: OnShowTrustedDomain()

    SYNOPSIS:   Show the dc status of the trusted domain.

    RETURNS:

    HISTORY:
        CongpaY         3-June-993      Created

********************************************************************/
VOID DCTD_DIALOG :: OnShowTrustedDomain( void )
{
    TD_LBI * plbi = (TD_LBI *) _lbTD.QueryItem();

    if (plbi == NULL)
    {
        ::MsgPopup (this, ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    NLS_STR nlsTD (plbi->QueryTD());

    APIERR err;
    if ((err = nlsTD.QueryError()) != NERR_Success)
    {
        ::MsgPopup (this, err);
    }

    // Pop up a new dialog which shows all the domain controllers status
    // of the trusted domain.
    DC_DIALOG * pdlg = new DC_DIALOG (this->QueryHwnd(),
                                      MAKEINTRESOURCE (IDD_DC_DIALOG),
                                      IDS_CAPTION,
                                      IDDC_LISTBOX,
                                      _nlsDomain,
                                      nlsTD);

    err = (pdlg == NULL)? ERROR_NOT_ENOUGH_MEMORY
                        : pdlg->Process();

    if (err != NERR_Success)
    {
        ::MsgPopup (this, err);
    }

    delete pdlg;
}

void ConvertError (NLS_STR * pnlsString, DWORD dwError)
{
    switch (dwError)
    {
    case ERROR_SUCCESS:
        pnlsString->Load (IDS_SUCCESS);
        break;
    case ERROR_BAD_NETPATH:
    case ERROR_SEM_TIMEOUT:
    case ERROR_REM_NOT_LIST:
        pnlsString->Load (IDS_ERROR_BAD_NETPATH);
        break;

    case ERROR_LOGON_FAILURE:
        pnlsString->Load (IDS_ERROR_LOGON_FAILURE);
        break;

    case ERROR_ACCESS_DENIED:
        pnlsString->Load (IDS_ERROR_ACCESS_DENIED);
        break;

    case ERROR_NOT_SUPPORTED:
        pnlsString->Load (IDS_ERROR_NOT_SUPPORTED);
        break;

    case ERROR_NO_LOGON_SERVERS:
        pnlsString->Load (IDS_ERROR_NO_LOGON_SERVERS);
        break;

    case ERROR_NO_SUCH_DOMAIN:
        pnlsString->Load (IDS_ERROR_NO_SUCH_DOMAIN);
        break;

    case ERROR_NO_TRUST_LSA_SECRET:
        pnlsString->Load (IDS_ERROR_NO_TRUST_LSA_SECRET);
        break;

    case ERROR_NO_TRUST_SAM_ACCOUNT:
        pnlsString->Load (IDS_ERROR_NO_TRUST_SAM_ACCOUNT);
        break;

    case ERROR_DOMAIN_TRUST_INCONSISTENT:
        pnlsString->Load (IDS_ERROR_DOMAIN_TRUST_INCONSISTENT);
        break;

    case ERROR_FILE_NOT_FOUND:
        pnlsString->Load (IDS_ERROR_FILE_NOT_FOUND);
        break;

    case ERROR_INVALID_DOMAIN_ROLE:
        pnlsString->Load (IDS_ERROR_INVALID_DOMAIN_ROLE);
        break;

    case ERROR_INVALID_DOMAIN_STATE:
        pnlsString->Load (IDS_ERROR_INVALID_DOMAIN_STATE);
        break;

    case ERROR_NO_BROWSER_SERVERS_FOUND:
        pnlsString->Load (IDS_ERROR_NO_BROWSER_SERVERS_FOUND);
        break;

    case ERROR_NOT_ENOUGH_MEMORY:
        pnlsString->Load (IDS_ERROR_NOT_ENOUGH_MEMORY);
        break;

    case ERROR_NETWORK_BUSY:
        pnlsString->Load (IDS_ERROR_NETWORK_BUSY);
        break;

    case ERROR_REQ_NOT_ACCEP:
        pnlsString->Load (IDS_ERROR_REQ_NOT_ACCEP);
        break;

    case ERROR_VC_DISCONNECTED:
        pnlsString->Load (IDS_ERROR_VC_DISCONNECTED);
        break;

    case NERR_DCNotFound:
        pnlsString->Load (IDS_NERR_DCNotFound);
        break;

    case NERR_NetNotStarted:
        pnlsString->Load (IDS_NERR_NetNotStarted);
        break;

    case NERR_WkstaNotStarted:
        pnlsString->Load (IDS_NERR_WkstaNotStarted);
        break;

    case NERR_ServerNotStarted:
        pnlsString->Load (IDS_NERR_ServerNotStarted);
        break;

    case NERR_BrowserNotStarted:
        pnlsString->Load (IDS_NERR_BrowserNotStarted);
        break;

    case NERR_ServiceNotInstalled:
        pnlsString->Load (IDS_NERR_ServiceNotInstalled);
        break;

    case NERR_BadTransactConfig:
        pnlsString->Load (IDS_NERR_BadTransactConfig);
        break;

    case NERR_BadServiceName:
        pnlsString->Load (IDS_NERR_BadServiceName);
        break;

    case RPC_S_UNKNOWN_IF:
        pnlsString->Load (IDS_NERR_NoNetLogon);
        break;

    default:
        {
        DEC_STR nlsTemp (dwError);
        pnlsString->CopyFrom (nlsTemp);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\h\nlhelp.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nlhelp.h

    This file contains the ID for help files

    FILE HISTORY:
          Congpay           4-June-1993         Created.

*/

#ifndef _NLHELP_H_
#define _NLHELP_H_

#include <uihelp.h>

// Help contexts for the various dialogs.
#define HC_DM_BASE                      HC_UI_BASE+13000
#define HC_DM_LAST                      HC_UI_BASE+13999
#define HC_DM_INTERVALS_DIALOG          (HC_DM_BASE+1)
#define HC_DC_DIALOG                    (HC_DM_BASE+2)
#define HC_DCTD_DIALOG                  (HC_DM_BASE+3)
#define HC_DM_SELECT_DIALOG             (HC_DM_BASE+20)

#define HC_DOMAIN_ADD                   (HC_DM_BASE+4)
#define HC_DOMAIN_REMOVE                (HC_DM_BASE+5)
#define HC_DOMAIN_PROPERTIES            (HC_DM_BASE+6)
#define HC_DOMAIN_EXIT                  (HC_DM_BASE+7)
#define HC_VIEW_REFRESH                 (HC_DM_BASE+8)
#define HC_OPTIONS_INTERVALS            (HC_DM_BASE+9)
#define HC_OPTIONS_MONITORTD            (HC_DM_BASE+10)
#define HC_OPTIONS_SAVE_SETTINGS_ON_EXIT (HC_DM_BASE+15)
#define HC_HELP_CONTENTS                (HC_DM_BASE+11)
#define HC_HELP_SEARCH                  (HC_DM_BASE+12)
#define HC_HELP_HOWTOUSE                (HC_DM_BASE+13)
#define HC_HELP_ABOUT                   (HC_DM_BASE+14)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\nlmon\nldmlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nldmlb.cxx
    DM_LISTBOX and DM_LBI module

    FILE HISTORY:
        Congpay      5-June-1993     Created
*/
#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB

#include <lmui.hxx>

#define INCL_BLT_TIMER
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif //DEBUG

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <strnumer.hxx>

extern "C"
{
    #include <nlmon.h>
    #include <nldlg.h>
    #include <mnet.h>
}

#include <adminapp.hxx>

#include <nldmlb.hxx>
#include <nlmain.hxx>

#define NUM_DM_HEADER_COL  3
#define NUM_DM_LBI_COL     4

/*******************************************************************

    NAME:          DM_LBI::DM_LBI

    SYNOPSIS:      Constructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_LBI::DM_LBI( const TCHAR * lpDomain, DM_LISTBOX *pdmlb )
    : _nlsDomain( lpDomain ),
      _pdm( NULL )
{
    if ( QueryError() != NERR_Success )
       return ;

    if (!_nlsDomain)
    {
        ReportError (_nlsDomain.QueryError());
        return;
    }

    UIASSERT( pdmlb != NULL );

    DOMAIN_STATE dwHealth = QueryHealth ((const LPTSTR)_nlsDomain.QueryPch());

    // Set the healthy state bitmap.
    SetTypeBitmap(dwHealth, pdmlb );

    // Set the PDC name of the domain.
    LPTSTR lpPDC = ::QueryPDC ((const LPTSTR)_nlsDomain.QueryPch());
    if (lpPDC != NULL)
    {
        _nlsPDC.CopyFrom(lpPDC);
        NetpMemoryFree (lpPDC);
    }
    else
    {
        if (dwHealth == DomainUnknown)
        {
            _nlsPDC.Load(IDS_WAITING);
        }
        else
        {
            _nlsPDC.Load(IDS_NO_PDC);
        }
    }

    APIERR err;

    if ((err = _nlsPDC.QueryError()) != NERR_Success)
    {
        ReportError(err);
        return;
    }

    // Find all the trusted domains of the select domain and and
    // put them in a string seperated by double spaces.
    if (GlobalInitialized)
    {
        LOCK_LISTS();
        PLIST_ENTRY pTDList = ::QueryTrustedDomain ((const LPTSTR)_nlsDomain.QueryPch());
        PLIST_ENTRY pNextEntry;
        PTRUSTED_DOMAIN_ENTRY pTDEntry;

        if ((pTDList != NULL) && (pTDList->Flink != pTDList))
        {
            NLS_STR nlsSpace;
            nlsSpace.Load(IDS_SPACE);
            if (!nlsSpace)
            {
                UNLOCK_LISTS();
                ReportError(nlsSpace.QueryError());
                return;
            }

            for (pNextEntry = pTDList->Flink;
                 pNextEntry!= pTDList;
                 pNextEntry = pNextEntry->Flink)
            {
                pTDEntry = (PTRUSTED_DOMAIN_ENTRY) pNextEntry;

                TCHAR szDomain[MAX_PATH+1];

                err = ::I_MNetNameCanonicalize ( NULL,
                                               (pTDEntry->Name).Buffer,
                                               szDomain,
                                               sizeof (szDomain) - 2,
                                               NAMETYPE_DOMAIN,
                                               0L);
                if (err == NERR_Success)
                {
                    _nlsTrustedDomain.Append (szDomain);
                    _nlsTrustedDomain.Append (nlsSpace);
                }
                else
                {
                    UNLOCK_LISTS();
                    ReportError(err);
                    return;
                }
            }
        }
        else
        {
            if (dwHealth == DomainUnknown)
            {
                _nlsTrustedDomain.Load(IDS_WAITING);
            }
            else
            {
                _nlsTrustedDomain.Load(IDS_EMPTY_STRING);
            }

        }

        UNLOCK_LISTS();
    }
    else
    {
        _nlsTrustedDomain.Load(IDS_WAITING);
    }

    if ((err = _nlsTrustedDomain.QueryError()) != NERR_Success)
    {
        ReportError(err);
    }
}

/*******************************************************************

    NAME:          DM_LBI::~DM_LBI

    SYNOPSIS:      Destructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_LBI::~DM_LBI()
{
    _pdm = NULL;
}

/*******************************************************************

    NAME:          DM_LBI::SetTypeBitmap

    SYNOPSIS:      Set the type bitmap associated with the domain

    ENTRY:         pdmlb     - Pointer to the domain listbox

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

VOID DM_LBI::SetTypeBitmap(DOMAIN_STATE dwHealth, DM_LISTBOX *pdmlb )
{
    switch ( dwHealth )
    {
        case DomainSuccess:
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMHealthy();
            break;

        case DomainProblem:
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMProblem();
            break;

        case DomainSick:
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMIll();
            break;

        case DomainDown:
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMDead();
            break;

        case DomainUnknown:
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMUnknown();
            break;

        default:
            UIASSERT (FALSE);
            _pdm = (DISPLAY_MAP *)pdmlb->QueryDMUnknown();
            break;
    }

    UIASSERT (_pdm != NULL);
}

/*******************************************************************

    NAME:          DM_LBI::Paint

    SYNOPSIS:      Paints the listbox entry to the screen

    ENTRY:         plb     - Pointer to the listbox containing this lbi
                   hdc     - Handle to device context
                   prect   - Size
                   pGUILTT - guiltt info

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

VOID DM_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                    GUILTT_INFO * pGUILTT ) const
{
    STR_DTE strdteDomain    ( _nlsDomain );
    STR_DTE strdtePDC       ( _nlsPDC );
    STR_DTE strdteTrustedDomain  ( _nlsTrustedDomain );

    ((DM_LBI *) this)->SetTypeBitmap (QueryHealth((const LPTSTR)_nlsDomain.QueryPch()), (DM_LISTBOX *) plb);
    DM_DTE dmdteType (_pdm);

    DISPLAY_TABLE cdt(NUM_DM_LBI_COL , (((DM_LISTBOX *) plb)->QueryadColWidths())->QueryColumnWidth());

    cdt[ 0 ] = &dmdteType;
    cdt[ 1 ] = &strdteDomain;
    cdt[ 2 ] = &strdtePDC;
    cdt[ 3 ] = &strdteTrustedDomain;

    cdt.Paint( plb, hdc, prect, pGUILTT );
}

/*******************************************************************

    NAME:          DM_LBI::QueryLeadingChar

    SYNOPSIS:      Used by adminapp for sorting the main windows listbox.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

WCHAR DM_LBI::QueryLeadingChar (void) const
{
    ISTR istr (_nlsDomain);

    return _nlsDomain.QueryChar (istr);
}

/*******************************************************************

    NAME:          DM_LBI::Compare

    SYNOPSIS:      This is a pure virtual function in ADMIN_LBI.
                   Used by AddRefreshItem in adminapp.
    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

INT DM_LBI::Compare (const LBI * plbi) const
{
    return _nlsDomain._stricmp ( ((const DM_LBI *) plbi)->_nlsDomain);
}

/*******************************************************************

    NAME:          DM_LBI::QueryName

    SYNOPSIS:      This is a pure virtual function in ADMIN_LBI.
                   Used by AddRefreshItem in adminapp.
    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

const TCHAR * DM_LBI::QueryName (void) const
{
    return _nlsDomain.QueryPch();
}

/*******************************************************************

    NAME:          DM_LBI::CompareAll

    SYNOPSIS:      This is a pure virtual function in ADMIN_LBI.
                   Used by AddRefreshItem in adminapp.
    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

BOOL DM_LBI::CompareAll (const ADMIN_LBI * plbi)
{
    if ((_nlsDomain.strcmp(((const DM_LBI *)plbi)->_nlsDomain) == 0) &&
        (_nlsPDC.strcmp(((const DM_LBI *)plbi)->_nlsPDC) == 0) &&
        (_nlsTrustedDomain.strcmp(((const DM_LBI *)plbi)->_nlsTrustedDomain) == 0) &&
        (_pdm == ((const DM_LBI *)plbi)->_pdm) )
    {
        return TRUE;
    }

    return FALSE;
}

/*******************************************************************

    NAME:       DM_LISTBOX::DM_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      paappwin - Pointer to the main window app
                cid      - Control id of the listbox
                xy       - Starting point of the listbox
                dxy      - Dimension of the listbox
                fMultSel - Multiselect or not

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_LISTBOX::DM_LISTBOX( DM_ADMIN_APP * paappwin, CID cid,
                        XYPOINT xy, XYDIMENSION dxy, BOOL fMultSel, INT dAge )
    :  ADMIN_LISTBOX (paappwin, cid, xy, dxy, fMultSel, dAge),
       _paappwin   ( paappwin ),
       _dmHealthy  (BMID_HEALTHY_TYPE),
       _dmProblem  (BMID_PROBLEM_TYPE),
       _dmIll      (BMID_ILL_TYPE),
       _dmDead     (BMID_DEAD_TYPE),
       _dmUnknown  (BMID_UNKNOWN_TYPE)
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( paappwin != NULL );

    _padColWidths = new ADMIN_COL_WIDTHS (QueryHwnd(),
                                          paappwin->QueryInstance(),
                                          ID_RESOURCE,
                                          NUM_DM_LBI_COL);

    if (_padColWidths == NULL)
    {
        ReportError (ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    APIERR err;

    if ((err = _padColWidths->QueryError()) != NERR_Success)
    {
        ReportError (err);
        return;
    }
}

/*******************************************************************

    NAME:       DM_LISTBOX::~DM_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_LISTBOX::~DM_LISTBOX()
{
   delete _padColWidths;

   _padColWidths = NULL;
}

/*******************************************************************

    NAME:       DM_LISTBOX::ShowEntries

    SYNOPSIS:   Initialize the list box in the main window.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

APIERR DM_LISTBOX::ShowEntries(NLS_STR nlsDomainList)
{
    NLS_STR nlsComma;
    nlsComma.Load (IDS_COMMA);

    if (!nlsComma)
    {
        return (nlsComma.QueryError());
    }

    // The nlsDomainList contains all the domains seperated by comma.
    // We created this strlist in order to get each domain out of the
    // list.
    STRLIST strlist(nlsDomainList, nlsComma, TRUE);
    ITER_STRLIST iterstrlist(strlist);

    NLS_STR * pnlsDomain;
    DM_LBI * plbi;
    APIERR err = NERR_Success;

    // Show each domain in the listbox.
    while ((err == NERR_Success) && ((pnlsDomain = iterstrlist.Next()) != NULL))
    {
        plbi = new DM_LBI ( (*pnlsDomain).QueryPch(), this);

        err = (plbi == NULL)? ERROR_NOT_ENOUGH_MEMORY
                            : AddRefreshItem (plbi);
    }

    return err;
}
/*******************************************************************

    NAME:       DM_LISTBOX::CreateNewRefreshInstance

    SYNOPSIS:   Called by OnRefreshNow.
                It will update the main window's listbox.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

APIERR DM_LISTBOX::CreateNewRefreshInstance(VOID)
{
    APIERR err = NERR_Success;
    DM_LBI * plbi;
    DM_LBI * plbitmp;
    INT i;
    for (i = 0; (err == NERR_Success)&&(i < QueryCount()); i++)
    {
        plbitmp = (DM_LBI *) QueryItem (i);

        if (plbitmp != NULL)
        {
            plbi = new DM_LBI ((plbitmp->QueryDomain()).QueryPch() , this);

            err = (plbi == NULL)? ERROR_NOT_ENOUGH_MEMORY
                                : AddRefreshItem (plbi);
        }
        else
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break;
        }
    }

    return err;
}

/*******************************************************************

    NAME:       DM_LISTBOX::RefreshNext

    SYNOPSIS:   Pure virtual in ADMIN_LISTBOX.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

APIERR DM_LISTBOX::RefreshNext(VOID)
{
    return NERR_Success;
}

/*******************************************************************

    NAME:       DM_LISTBOX::DeleteRefreshInstance

    SYNOPSIS:   Pure virtual in ADMIN_LISTBOX.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

VOID DM_LISTBOX::DeleteRefreshInstance(VOID )
{
    ;
}


/*******************************************************************

    NAME:       DM_COLUMN_HEADER::DM_COLUMN_HEADER

    SYNOPSIS:   Constructor

    ENTRY:      powin - Owner window
                cid   - Control id of the resource
                xy    - Start position of the column header
                dxy   - Size of the column header
                pdmlb - Pointer to the event listbox

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_COLUMN_HEADER::DM_COLUMN_HEADER( OWNER_WINDOW *powin,
                                          CID cid,
                                          XYPOINT xy,
                                          XYDIMENSION dxy,
                                          const DM_LISTBOX *pdmlb )
    : ADMIN_COLUMN_HEADER( powin, cid, xy, dxy ),
      _pdmlb      ( pdmlb ),
      _nlsDomain  ( IDS_COL_HEADER_DM_DOMAIN ),
      _nlsPDC     ( IDS_COL_HEADER_DM_PDC),
      _nlsTD      ( IDS_COL_HEADER_DM_TD)
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pdmlb != NULL );

    APIERR err;
    if (  (( err = _nlsDomain.QueryError()) != NERR_Success )
       || (( err = _nlsPDC.QueryError()) != NERR_Success )
       || (( err = _nlsTD.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       DM_COLUMN_HEADER::~DM_COLUMN_HEADER

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

DM_COLUMN_HEADER::~DM_COLUMN_HEADER()
{
}

/*******************************************************************

    NAME:       DM_COLUMN_HEADER::OnPaintReq

    SYNOPSIS:   Paints the column header control

    ENTRY:

    EXIT:

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        Congpay      5-June-1993     Created

********************************************************************/

BOOL DM_COLUMN_HEADER::OnPaintReq( VOID )
{
    PAINT_DISPLAY_CONTEXT dc( this );

    METALLIC_STR_DTE strdteDomain    ( _nlsDomain.QueryPch());
    METALLIC_STR_DTE strdtePDC    ( _nlsPDC.QueryPch());
    METALLIC_STR_DTE strdteTD  ( _nlsTD.QueryPch());

    DISPLAY_TABLE cdt(NUM_DM_HEADER_COL , (_pdmlb->QueryadColWidths())->QueryColHeaderWidth());

    cdt[ 0 ] = &strdteDomain;
    cdt[ 1 ] = &strdtePDC;
    cdt[ 2 ] = &strdteTD;

    XYRECT xyrect( this );

    cdt.Paint( NULL, dc.QueryHdc(), xyrect );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\nlmon\nlmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nlmain.cxx
    Domain Monitor: main application module

    FILE HISTORY:
        Congpay         3-June-1993     Created
*/

#include <ntincl.hxx>
#include <ntlsa.h>

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_TIME_DATE
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <strnumer.hxx>
extern "C"
{
    #include <uimsg.h>
    #include <uirsrc.h>
    #include <mnet.h>
    #include <limits.h>
    #include <nlmon.h>
    #include "nlhelp.h"
    #include "nldlg.h"
}

#include <slist.hxx>
#include <string.hxx>

#include <ctime.hxx>

#include <netname.hxx>
#include <lmoloc.hxx>
#include <lmowks.hxx>
#include <lmosrv.hxx>
#include <lmsvc.hxx>

#include <adminapp.hxx>
#include <fontedit.hxx>
#include <getfname.hxx>
#include <focusdlg.hxx>
#include <ellipsis.hxx>

#include <nldmlb.hxx>
#include <nlmain.hxx>
#include <nldc.hxx>

#define AA_INIKEY_DOMAIN SZ("DOMAINLIST")
#define AA_INIKEY_INTERVALS SZ("INTERVALS")
#define AA_INIKEY_MONITORTD SZ("MONITOR_TRUSTED_DOMAIN")

#define DEFAULT_INTERVALS      900   // in second.
#define DEFAULT_MONITORTD      FALSE // Monitor trusted domain

#define BUFFERSIZE          128
#define APPNAME             SZ("Domain Monitor")
#define FILENAME            SZ("NTNET.INI")

/*******************************************************************

    NAME:          DM_ADMIN_APP::DM_ADMIN_APP

    SYNOPSIS:      Constructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

DM_ADMIN_APP::DM_ADMIN_APP( HINSTANCE  hInstance,
                            INT     nCmdShow,
                            UINT    idMinR,
                            UINT    idMaxR,
                            UINT    idMinS,
                            UINT    idMaxS )
    : ADMIN_APP( hInstance,
                 nCmdShow,
                 IDS_DMAPPNAME,
                 IDS_DMOBJECTNAME,
                 IDS_DMINISECTIONNAME,
                 IDS_DMHELPFILENAME,
                 idMinR, idMaxR, idMinS, idMaxS,
                 ID_APPMENU,
                 ID_APPACCEL,
                 ID_APPICON,
                 FALSE,             // Don't get PDC
                 0,                 // Refresh time. It's not used.
                 SEL_DOM_ONLY,
                 FALSE,
                 BROWSE_LOCAL_DOMAINS,
                 HC_DM_SELECT_DIALOG),
      _lbMainWindow ( this, IDC_MAINWINDOWLB,
                      XYPOINT(0, 0), XYDIMENSION(200, 300), FALSE, INT_MAX),
      _colheadDM( this, IDC_COLHEAD_DM,
                  XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ), &_lbMainWindow ),
      // The dimension in _lbMainWindow or _colheadEvents above is not used.
      // It will be set correctly later on.
      _dyMargin (1),
      _dyFixed (2*_dyMargin+(UINT)_colheadDM.QueryHeight()),
      _menuitemAdd        ( this, IDM_SETFOCUS ),
      _menuitemRemove     ( this, IDM_REMOVE ),
      _menuitemProperties ( this, IDM_PROPERTIES),
      _menuitemIntervals  ( this, IDM_INTERVALS ),
      _menuitemMonitorTD  ( this, IDM_MONITORTD )
{
    if ( QueryError() != NERR_Success )
       return;

    // Register the help file name and range.
    // Read setup values from registry.

    INT nMonitorTD;
    INT nIntervals;

    APIERR err;
    if (((err = BLT::RegisterHelpFile( hInstance,
                                       IDS_DMHELPFILENAME,
                                       HC_DM_BASE,
                                       HC_DM_LAST )) != NERR_Success) ||
        ((err = BASE_ELLIPSIS::Init()) != NERR_Success) ||
        //((err = Read (AA_INIKEY_DOMAIN, &_nlsDomainList)) != NERR_Success)||
        ((err = Read (AA_INIKEY_INTERVALS, &nIntervals, DEFAULT_INTERVALS)) != NERR_Success)||
        ((err = Read (AA_INIKEY_MONITORTD, &nMonitorTD, DEFAULT_MONITORTD? 1: 0)) != NERR_Success))
    {
        ReportError (err);
        return;
    }

    // Take away if admin_app is fixed.
    INT nSize = BUFFERSIZE;
    INT n = 0;
    LPTSTR lpBuf;
    do
    {
        lpBuf = (LPTSTR) LocalAlloc (LPTR, nSize);
        n = ::GetPrivateProfileString ((TCHAR *) APPNAME,
                                       (TCHAR *) AA_INIKEY_DOMAIN,
                                       NULL,
                                       lpBuf,
                                       nSize/2,
                                       (TCHAR *) FILENAME);
        if (n != nSize/2 -1)
        {
            _nlsDomainList.CopyFrom (lpBuf);
            LocalFree (lpBuf);
            break;
        }
        LocalFree (lpBuf);
        nSize *= 2;
    } while (TRUE);
    // Ended here.

    if ((err = _nlsDomainList.QueryError()) != NERR_Success)
    {
        ReportError (err);
        return;
    }

    _dwIntervals = (DWORD) nIntervals;
    _fMonitorTD = (nMonitorTD == 0)? FALSE : TRUE;

    // Kick off a thread to get domain status.
    HANDLE hWorkThread;
    DWORD  ThreadHandle;
    GlobalInitialized = FALSE;

    hWorkThread = CreateThread ( NULL,
                                 0,
                                 (LPTHREAD_START_ROUTINE) MonitorThread,
                                 (LPVOID) this,
                                 0,
                                 &ThreadHandle);

    if (hWorkThread == NULL)
    {
        ReportError (GetLastError());
        return;
    }

    // Call LockRefresh() so that the timer is never enabled.
    LockRefresh();

    // Show the main window.
    _lbMainWindow.SetSize( QuerySize() );
    _colheadDM.Show();
    _lbMainWindow.Show();
    _lbMainWindow.ClaimFocus();

    // Fill the main window listbox.
    _lbMainWindow.ShowEntries(_nlsDomainList);

    InitializeMenu();

    _menuitemMonitorTD.SetCheck(_fMonitorTD);
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::~DM_ADMIN_APP

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created


********************************************************************/

DM_ADMIN_APP::~DM_ADMIN_APP()
{
    BASE_ELLIPSIS::Term();

    if (IsSavingSettingsOnExit())
    {
        NLS_STR nlsDomainList;
        NLS_STR nlsComma;
        nlsComma.Load(IDS_COMMA);
        APIERR err;

        if ( ((err = nlsDomainList.QueryError()) != NERR_Success) ||
             ((err = nlsComma.QueryError()) != NERR_Success) )
        {
            ::MsgPopup (this, err);
            return;
        }

        INT i;

        // Get the domains that were monited.
        for (i = 0; i < _lbMainWindow.QueryCount(); i++)
        {
            nlsDomainList.Append( ((DM_LBI *)_lbMainWindow.QueryItem(i))->QueryDomain());
            nlsDomainList.Append (nlsComma);
        }

        if ((err = nlsDomainList.QueryError()) != NERR_Success)
        {
            ::MsgPopup (this, err);
            return;
        }

        INT nIntervals = _dwIntervals;

        // Store setup values.
        if( ((err = Write (AA_INIKEY_DOMAIN, nlsDomainList)) != NERR_Success)||
            ((err = Write (AA_INIKEY_INTERVALS, nIntervals)) != NERR_Success)||
            ((err = Write (AA_INIKEY_MONITORTD, _fMonitorTD? 1:0)) != NERR_Success) )
        {
            ::MsgPopup (this, err);
        }
    }

    UnlockRefresh();

    StopMonitor();
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::MonitorThread

    SYNOPSIS:   The thread that start monitor and translate setevent to
                postmessage. The mail window will refresh when it receives
                this message.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created


********************************************************************/
VOID DM_ADMIN_APP::MonitorThread(LPVOID lpParam)
{
    DM_ADMIN_APP * pThis = (DM_ADMIN_APP *) lpParam;

    APIERR err = (APIERR) ::StartMonitor (pThis->QueryDomainList(),
                                          pThis->QueryInterval()*1000,
                                          pThis->QueryMonitorTD() );

    if (err != NERR_Success)
    {
        ::MsgPopup (pThis, err);
        return;
    }

    while (TRUE)
    {
        WaitForSingleObject (GlobalUpdateEvent, INFINITE);

        PostMessage (pThis->QueryHwnd(),
                     WM_COMMAND,
                     IDM_LOCALREFRESH,
                     NULL);
    }
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::SizeListboxes

    SYNOPSIS:   Resizes the main window listboxes and column headers

    ENTRY:      xydimWindow - dimensions of the main window client area

    EXIT:       Listboxes and column headers are resized appropriately

    NOTES:      This method is *not* trying to be overly efficient.  It
                is written so as to maximize readability and
                understandability.  The method is not called very often,
                and when it is, the time needed to redraw the main window
                and its components exceeds the computations herein by far.

    HISTORY:
        Congpay         3-June-1993     Copied from eventvwr.

********************************************************************/

//  A macro specialized for the SizeListboxes method
#define SET_CONTROL_SIZE_AND_POS( ctrl, dyCtrl )        \
            ctrl.SetPos( XYPOINT( dxMargin, yCurrent ));       \
            ctrl.SetSize( dx, dyCtrl );       \
            yCurrent += dyCtrl;

VOID DM_ADMIN_APP::SizeListboxes( XYDIMENSION dxyWindow )
{
    UINT dxMainWindow = dxyWindow.QueryWidth();
    UINT dyMainWindow = dxyWindow.QueryHeight();

    //  The left and right margins are each dxMargin.  The width of
    //  each control is thus the width of the main window client area
    //  less twice dxMargin.
    //  The width thus looks like:
    //      Left Margin         Control         Right Margin
    //       (dxMargin)          (dx)            (dxMargin)

    const UINT dxMargin = 1;                // width of left/right margins
    UINT dx = dxMainWindow - 2 * dxMargin;

    //  Height looks like:
    //      Top margin                  _dyMargin
    //      Server Column Header        _colheadEvents.QueryHeight()
    //      Server Listbox              variable area
    //      Bottom margin               _dyMargin


    UINT dyDMListbox = dyMainWindow - _dyFixed;

    //  Set all the sizes and positions.

    UINT yCurrent = _dyMargin;

    SET_CONTROL_SIZE_AND_POS( _colheadDM, _colheadDM.QueryHeight() );
    SET_CONTROL_SIZE_AND_POS( _lbMainWindow,  dyDMListbox );
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::OnResize()

    SYNOPSIS:   It's called when user change window size.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/
BOOL DM_ADMIN_APP::OnResize (const SIZE_EVENT & se)
{
     SizeListboxes (XYDIMENSION (se.QueryWidth(), se.QueryHeight()));

     _colheadDM.Invalidate();

     return ADMIN_APP::OnResize(se);

}

/*******************************************************************

    NAME:       DM_ADMIN_APP::OnFocus()

    SYNOPSIS:   Pass focus to the mail window.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/
BOOL DM_ADMIN_APP::OnFocus (const FOCUS_EVENT & event)
{
     _lbMainWindow.ClaimFocus();

     return ADMIN_APP::OnFocus(event);
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::InitializeMenu()

    SYNOPSIS:   It's called when the main window needs to be repainted.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

VOID DM_ADMIN_APP::InitializeMenu (VOID)
{
    BOOL fEmpty = (_lbMainWindow.QueryCount() < 1);

    _menuitemRemove.Enable (!fEmpty);
    _menuitemProperties.Enable (!fEmpty);
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::OnRefreshNow()

    SYNOPSIS:   It's called when the main window needs to be repainted.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/
APIERR DM_ADMIN_APP::OnRefreshNow( BOOL fClearFirst)
{
    APIERR err = _lbMainWindow.RefreshNow();

    if ((_lbMainWindow.QueryCurrentItem() < 0) &&
        (_lbMainWindow.QueryCount() > 0))
    {
        _lbMainWindow.SelectItem (0);
    }

    return err;
}

/*******************************************************************

    NAME:       DM_ADMIN_APP::SetNetworkFocus()

    SYNOPSIS:   Add domain to the list.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/
APIERR DM_ADMIN_APP::SetNetworkFocus (HWND hwndOwner,
                                      const TCHAR * pchDomain,
                                      FOCUS_CACHE_SETTING setting)
{
    APIERR err = NERR_Success;

    if ((pchDomain == NULL) || (*pchDomain == 0))
        return err;

    AddDomainToList((const LPTSTR) pchDomain);

    DM_LBI * plbi = new DM_LBI (pchDomain, &_lbMainWindow);

    err = (plbi == NULL)? ERROR_NOT_ENOUGH_MEMORY
                        : _lbMainWindow.AddRefreshItem (plbi);

    return err;
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnCommand

    SYNOPSIS:      Command message handler - only need to handle
                   the case when the user double clicks on a listbox
                   item

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

BOOL DM_ADMIN_APP::OnCommand( const CONTROL_EVENT & event )
{
    if (( event.QueryCid() == IDC_MAINWINDOWLB ) &&
        ( event.QueryCode() == LBN_DBLCLK ) &&
        ( _lbMainWindow.QueryCount() != 0 ))
    {
        AUTO_CURSOR autocur;
        OnPropertiesMenuSel();
        return TRUE;
    }

    return APP_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnMenuCommand

    SYNOPSIS:      Control messages and menu messages come here

    ENTRY:         midMenuItem - the menu item that the user selected

    EXIT:

    RETURN:        Returns TRUE if it handled the message

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

BOOL DM_ADMIN_APP::OnMenuCommand( MID midMenuItem )
{
    AUTO_CURSOR autocur;

    switch ( midMenuItem )
    {
        case IDM_SETFOCUS:
        {
            return OnAddDomain();
        }
        case IDM_REMOVE:
        {
            OnRemoveDomain();
            break;
        }
        case IDM_INTERVALS:
        {
            OnIntervals();
            break;
        }
        case IDM_MONITORTD:
        {
            OnMonitorTD();
            break;
        }
        case IDM_LOCALREFRESH:
        {
            OnRefreshNow(TRUE);
            break;
        }
        case IDM_REFRESH:
        {
            SetEvent (GlobalRefreshEvent);
            WaitForSingleObject (GlobalRefreshDoneEvent, INFINITE);
            break;
        }
        default:
        {
            return ADMIN_APP::OnMenuCommand( midMenuItem ) ;
        }
    }

    return TRUE;
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnAddDomain()

    SYNOPSIS:      Calls SetNetworkFocus. Add a domain to the domain
                   monitor list.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/
BOOL DM_ADMIN_APP::OnAddDomain(VOID)
{
    BOOL fReturn = ADMIN_APP::OnMenuCommand (IDM_SETFOCUS);

    if (fReturn)
    {
        InitializeMenu();
    }

    //_colheadDM.Invalidate(TRUE);
    return fReturn;
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnRemoveDomain()

    SYNOPSIS:      Remove a domain from the domain monitor list.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

VOID DM_ADMIN_APP::OnRemoveDomain (VOID)
{
    INT iSelected = _lbMainWindow.QueryCurrentItem();

    DM_LBI * plbi = (DM_LBI *) _lbMainWindow.QueryItem();

    UIASSERT (plbi != NULL)

    RemoveDomainFromList((const LPTSTR)(plbi->QueryDomain()).QueryPch());

    delete plbi;
    plbi = NULL;

    _lbMainWindow.RemoveItem();

    INT nEntries =  _lbMainWindow.QueryCount();

    if (nEntries == 0)
    {
        _menuitemRemove.Enable(FALSE);
        _menuitemProperties.Enable(FALSE);
    }
    else if (iSelected >= nEntries)
    {
        _lbMainWindow.SelectItem ( nEntries-1 );
    }
    else
    {
        _lbMainWindow.SelectItem (iSelected);
    }
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnPropertiesMenuSel()

    SYNOPSIS:      Brings up the Domain Controller's status dialog.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

VOID DM_ADMIN_APP::OnPropertiesMenuSel(VOID)
{
    DM_LBI * plbi = (DM_LBI *) _lbMainWindow.QueryItem();

    UIASSERT (plbi != NULL);

    NLS_STR nlsDomain(plbi->QueryDomain());
    APIERR err;

    if ((err = nlsDomain.QueryError()) != NERR_Success)
    {
        ::MsgPopup (this, err);
        return;
    }

    DCTD_DIALOG * pdlg = new DCTD_DIALOG (this->QueryHwnd(),
                                          MAKEINTRESOURCE (IDD_DCTD_DIALOG),
                                          IDS_CAPTION,
                                          IDDCTD_DC_LISTBOX,
                                          IDDCTD_TD_LISTBOX,
                                          nlsDomain,
                                          _fMonitorTD);

    BOOL fUserPressedOK = FALSE;

    if ( (err = (pdlg == NULL)? ERROR_NOT_ENOUGH_MEMORY
                               : pdlg->Process (&fUserPressedOK)) != NERR_Success)
    {
        ::MsgPopup (this, err);
        return;
    }

    delete pdlg;
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnIntervals()

    SYNOPSIS:      Brings up the dialog to let user change the intervals
                   between every checking.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

VOID DM_ADMIN_APP::OnIntervals (VOID)
{
    INTERVALS_DIALOG * pdlg = (INTERVALS_DIALOG *) new INTERVALS_DIALOG (this->QueryHwnd(),
                                                                     MAKEINTRESOURCE (IDD_INTERVALS_DIALOG));


    BOOL fUserPressedOK = FALSE;

    APIERR err = (pdlg == NULL) ? ERROR_NOT_ENOUGH_MEMORY
                                : pdlg->Process (&fUserPressedOK);

    delete pdlg;

    if (err != NERR_Success)
    {
        ::MsgPopup (this, err);
    }

    if (fUserPressedOK)
    {
        _dwIntervals = GlobalUpdateTimeMSec/1000;
    }
}

/*******************************************************************

    NAME:          DM_ADMIN_APP::OnMonitorTD()

    SYNOPSIS:      Let user choose to check Trusted Domains or not.

    ENTRY:

    EXIT:

    RETURN:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

VOID DM_ADMIN_APP::OnMonitorTD (VOID)
{
    if (_fMonitorTD)
    {
        _menuitemMonitorTD.SetCheck(FALSE);
        _fMonitorTD = FALSE;
        GlobalMonitorTrust = FALSE;
    }
    else
    {
        _menuitemMonitorTD.SetCheck(TRUE);
        _fMonitorTD = TRUE;
        GlobalMonitorTrust = TRUE;
    }
}

/*******************************************************************

    NAME:          INTERVALS_DIALOG::INTERVALS_DIALOG

    SYNOPSIS:      Constructor

    ENTRY:         hwndParent  - Handle of the parent window
                   idrsrcDialog - Resource ID

    EXIT:

    RETURNS:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

INTERVALS_DIALOG::INTERVALS_DIALOG ( HWND         hwndParent,
                                     const IDRESOURCE & idrsrcDialog)
    : DIALOG_WINDOW ( idrsrcDialog, hwndParent ),
      _sleIntervals ( this, IDID_INTERVALS)
{
    if (QueryError() != NERR_Success)
    {
        return;
    }

    DEC_STR nlsIntervals (GlobalUpdateTimeMSec/1000);

    if (nlsIntervals.QueryError() != NERR_Success)
    {
        return;
    }

    _sleIntervals.SetText (nlsIntervals);
}

/*******************************************************************

    NAME:          INTERVALS_DIALOG::~INTERVALS_DIALOG

    SYNOPSIS:      Destructor

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

INTERVALS_DIALOG::~INTERVALS_DIALOG ()
{
}

/*******************************************************************

    NAME:          INTERVALS_DIALOG::OnOK

    SYNOPSIS:      Set the interval time.

    ENTRY:

    EXIT:

    RETURNS:

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

BOOL INTERVALS_DIALOG::OnOK ()
{
    NLS_STR nlsIntervals;
    APIERR err = _sleIntervals.QueryText(&nlsIntervals);
    if (err != NERR_Success)
        return (FALSE);

    GlobalUpdateTimeMSec = (DWORD) nlsIntervals.atoi()*1000;
    return DIALOG_WINDOW::OnOK();
}

/*******************************************************************

    NAME:          INTERVALS_DIALOG::QueryHelpContext

    SYNOPSIS:      Get the help context of this dialog

    ENTRY:

    EXIT:

    RETURNS:       Returns the help context

    HISTORY:
        Congpay         3-June-1993     Created

********************************************************************/

ULONG INTERVALS_DIALOG::QueryHelpContext( VOID )
{
    return HC_DM_INTERVALS_DIALOG;
}


SET_ROOT_OBJECT (DM_ADMIN_APP,
                 IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                 IDS_UI_APP_BASE, IDS_UI_APP_LAST);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\nlmon\nlmon\nldcbase.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    nldcbase.cxx

    FILE HISTORY:
        CongpaY         3-June-1993     Created.
*/

#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <nldcbase.hxx>

/*******************************************************************

    NAME:       BASE_DC_DIALOG ::BASE_DC_DIALOG

    SYNOPSIS:   BASE_DC_DIALOG class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_DIALOG :: BASE_DC_DIALOG( HWND             hWndOwner,
                                  const TCHAR *    pszResourceName,
                                  UINT             idCaption,
                                  BASE_DC_LISTBOX * plbDCBase,
                                  NLS_STR          nlsDomain)
  :DIALOG_WINDOW ( pszResourceName, hWndOwner),
   _nlsDomain( nlsDomain),
   _plbDCBase (plbDCBase)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if ((err = _nlsDomain.QueryError()) != NERR_Success)
    {
        ReportError (err);
    }

    NLS_STR nlsCaption;

    nlsCaption.Load (idCaption);
    nlsCaption.Append (nlsDomain);

    if ((err = nlsCaption.QueryError()) != NERR_Success)
    {
        ReportError (err);
    }

    SetText (nlsCaption.QueryPch());
}

/*******************************************************************

    NAME:       BASE_DC_DIALOG :: ~BASE_DC_DIALOG

    SYNOPSIS:   BASE_DC_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_DIALOG:: ~BASE_DC_DIALOG()
{
}

/*******************************************************************

    NAME:       BASE_DC_LISTBOX :: BASE_DC_LISTBOX

    SYNOPSIS:   BASE_DC_LISTBOX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_LISTBOX :: BASE_DC_LISTBOX( OWNER_WINDOW   * powOwner,
                                    CID              cid,
                                    UINT             cColumns,
                                    NLS_STR          nlsDomain)
  : BLT_LISTBOX( powOwner, cid ),
    _nlsDomain (nlsDomain)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if ((err = _nlsDomain.QueryError()) != NERR_Success)
    {
        ReportError(err);
        return;
    }

    DISPLAY_TABLE::CalcColumnWidths (_adx,
                                     cColumns,
                                     powOwner,
                                     cid,
                                     TRUE);

}   // BASE_DC_LISTBOX :: BASE_DC_LISTBOX


/*******************************************************************

    NAME:       BASE_DC_LISTBOX :: ~BASE_DC_LISTBOX

    SYNOPSIS:   BASE_DC_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_LISTBOX :: ~BASE_DC_LISTBOX()
{
}

/*******************************************************************

    NAME:       BASE_DC_LBI :: DC_LBI

    SYNOPSIS:   BASE_DC_LBI class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_LBI :: BASE_DC_LBI( const TCHAR * pszDC)
  : _nlsDCName (pszDC)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    if (!_nlsDCName)
    {
         ReportError (_nlsDCName.QueryError());
         return;
    }
}

/*******************************************************************

    NAME:       BASE_DC_LBI :: ~BASE_DC_LBI

    SYNOPSIS:   BASE_DC_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         3-June-1993     Created.

********************************************************************/
BASE_DC_LBI :: ~BASE_DC_LBI()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\bin\srvmgr.c ===
/* srvmgr.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\cpl\srvmcpl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvmcpl.cxx
    This is the main module for the Server Manager Control Panel Applet.
    It contains the "LibMain" and "CplApplet" functions.


    FILE HISTORY:
        KeithMo     22-Apr-1992 Templated from DavidHov's NCPACPL.CXX.
        KeithMo     02-Jun-1992 Added "Start the Server?" option.
        KeithMo     10-Jun-1992 Allow other process to start the server
                                "behind our back".
        KeithMo     03-Aug-1992 Folded in the Service Manager (SVCMGR.CPL).
        JonN        26-Jun-2000 CPlApplet takes HWND, UINT, LPARAM, LPARAM

*/


#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

//
//  #defining this macro enables certain "unique" behaviour in the
//  SVCCNTL_DIALOG dialog.  The "standard" dialog will bail-out when
//  the user stops the server service.  If this macro is #defined,
//  then the dialog won't bail out (SVCCNTL_DIALOG does not require
//  that the server service be running).
//

#define MINI_SERVER_MANAGER_APPLET

#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>
#include <lmosrv.hxx>
#include <lmoloc.hxx>

extern "C"
{
    #include <cpl.h>                            // Multimedia CPL defs
    #include <srvmgr.h>
    #include <mnet.h>

    #include <uimsg.h>
    #include <uirsrc.h>
}

#include <srvprop.hxx>
#include <srvsvc.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <lsaaccnt.hxx>
#include <svccntl.hxx>
#include <devcntl.hxx>


extern "C"
{
    //
    //  Control Panel Applet entry point.
    //

    LONG FAR PASCAL CPlApplet( HWND   hwndCPl,
                               UINT   nMsg,
                               LPARAM lParam1,
                               LPARAM lparam2 );

    //
    //  DLL load/unload entry point.
    //

    BOOL DllMain( HINSTANCE hInstance, DWORD nReason, LPVOID pReserved );

    //
    //  Globals.
    //

    HINSTANCE _hCplInstance = NULL;

}   // extern "C"


//
//  This is the "type" for an applet startup function.
//

typedef APIERR (* PCPL_APPLET_FUNC)( HWND hWnd );


//
//  We'll keep one of these structures for each applet in this DLL.
//

typedef struct _CPL_APPLET
{
    int                 idIcon;
    int                 idName;
    int                 idInfo;
    int                 idHelpFile;
    DWORD               dwHelpContext;
    LONG                lData;
    PCPL_APPLET_FUNC    pfnApplet;

} CPL_APPLET;


//
//  Forward reference prototypes.
//

APIERR RunSrvMgr( HWND hWnd );
APIERR RunSvcMgr( HWND hWnd );
APIERR RunDevMgr( HWND hWnd );


//
//  Our applet descriptors.
//

CPL_APPLET CplApplets[] = {
                                    {           // Server applet
                                        IDI_SMCPA_ICON,
                                        IDS_SMCPA_NAME_STRING,
                                        IDS_SMCPA_INFO_STRING,
                                        IDS_SMCPA_HELPFILENAME,
                                        HC_SERVER_PROPERTIES,
                                        0L,
                                        &RunSrvMgr
                                    },

                                    {           // Services applet
                                        IDI_SVCCPA_ICON,
                                        IDS_SVCCPA_NAME_STRING,
                                        IDS_SVCCPA_INFO_STRING,
                                        IDS_SMCPA_HELPFILENAME,
                                        HC_SVCCNTL_DIALOG,
                                        0L,
                                        &RunSvcMgr
                                    },

                                    {           // Devices applet
                                        IDI_DEVCPA_ICON,
                                        IDS_DEVCPA_NAME_STRING,
                                        IDS_DEVCPA_INFO_STRING,
                                        IDS_SMCPA_HELPFILENAME,
                                        HC_DEVCNTL_DIALOG,
                                        0L,
                                        &RunDevMgr
                                    }
                                 };

LONG cActiveApplets = sizeof(CplApplets) / sizeof(CplApplets[0]);


/*******************************************************************

    NAME:       GetLocalServerName

    SYNOPSIS:   Returns the name of the current server (\\server).

    ENTRY:      nlsServerName           - Will receive the server name.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     22-Apr-1992 Created.

********************************************************************/
APIERR GetLocalServerName( NLS_STR & nlsServerName )
{
    APIERR err = nlsServerName.QueryError();

    if( err == NERR_Success )
    {
        err = nlsServerName.CopyFrom( SZ("\\\\") );
    }

    SERVER_INFO_100 * psrvi100;

    if( err == NERR_Success )
    {
        err = ::MNetServerGetInfo( NULL,
                                   100,
                                   (BYTE **)&psrvi100 );
    }

    if( err == NERR_Success )
    {
        ALIAS_STR nlsRawName( (const TCHAR *)psrvi100->sv100_name );
        err = nlsServerName.Append( nlsRawName );

        ::MNetApiBufferFree( (BYTE **)&psrvi100 );
    }

    return err;

}   // GetLocalServerName


/*******************************************************************

    NAME:       StartServer

    SYNOPSIS:   Starts the server on the local machine.

    ENTRY:      hWnd                    - "Owning" window handle.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     02-Jun-1992 Created.

********************************************************************/
APIERR StartServer( HWND hWnd )
{
    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDisplayName.QueryError();
    }

    if( err == NERR_Success )
    {
        err = loc.QueryDisplayName( &nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        GENERIC_SERVICE * psvc = new GENERIC_SERVICE( hWnd,
                                                      NULL,
                                                      nlsDisplayName,
                                                      (const TCHAR *)SERVICE_SERVER );

        err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : psvc->QueryError();

        if( err == NERR_Success )
        {
            err = psvc->Start();
        }

        delete psvc;
    }

    return err;

}   // StartServer


/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance               - Program instance of the caller.

    EXIT:       If this is the first initialization request for this
                process, then all necessary BLT initializers have
                been invoked.

    RETURNS:    BOOL                    - TRUE  = Initialization OK.
                                          FALSE = Initialization failed.

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        beng        04-Aug-1992 Changes to BLT::Init

********************************************************************/
BOOL InitializeDll( HINSTANCE hInstance )
{
    //
    //  Save the instance handle.
    //

    _hCplInstance = hInstance;

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        beng        04-Aug-1992 Changes to BLT::Term

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hCplInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       InitializeAllApplets

    SYNOPSIS:   Called before applet runs.

    ENTRY:      hWnd                    - Window handle of parent window.

    RETURNS:    BOOL                    - TRUE  = Applet should be installed.
                                          FALSE = Applet cannot be installed.

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        KeithMo     10-Jun-1992 Moved "guts" to RunSrvMgr.
        JonN        30-Aug-1994 Added lParam parameters to CPL_INIT, CPL_TERM
        JonN        22-Sep-1995 Only called when applet runs

********************************************************************/
BOOL InitializeAllApplets( HWND hWnd, LPARAM lParam1, LPARAM lParam2 )
{
    TRACEEOL( "SRVMGR.CPL: InitializeAllApplets enter" );
    //
    //  Initialize all of the NetUI goodies.
    //

    APIERR err = BLT::Init( _hCplInstance,
                            IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                            IDS_UI_APP_BASE, IDS_UI_SRVMGR_LAST );

    TRACEEOL( "SRVMGR.CPL: InitializeAllApplets BLT::Init returns " << err );

    if( err == NERR_Success )
    {
        TRACEEOL( "SRVMGR.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init next" );

        err = BLT_MASTER_TIMER::Init();

        TRACEEOL( "SRVMGR.CPL: InitializeAllApplets BLT::_MASTER_TIMER::Init returns " << err );

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( _hCplInstance );
        }
    }

    if( err == NERR_Success )
    {
        err = BLT::RegisterHelpFile( _hCplInstance,
                                     IDS_SMCPA_HELPFILENAME,
                                     HC_UI_SRVMGR_BASE,
                                     HC_UI_SRVMGR_LAST );

        if( err != NERR_Success )
        {
            //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //

            ::MsgPopup( hWnd, err );
        }
    }

    TRACEEOL( "SRVMGR.CPL: InitializeAllApplets exit" );

    return err == NERR_Success;

}   // InitializeAllApplets


/*******************************************************************

    NAME:       TerminateAllApplets

    SYNOPSIS:   Called after applet runs.

    ENTRY:      hWnd                    - Window handle of parent window.

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        JonN        30-Aug-1994 Added lParam parameters to CPL_INIT, CPL_TERM
        JonN        22-Sep-1995 Only called when applet runs

********************************************************************/
VOID TerminateAllApplets( HWND hWnd, LPARAM lParam1, LPARAM lParam2 )
{
    UNREFERENCED(hWnd);

    TRACEEOL( "SRVMGR.CPL: TerminateAllApplets enter" );
    //
    //  Kill the NetUI goodies.
    //

    TRACEEOL( "SRVMGR.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term next" );
    BLT_MASTER_TIMER::Term();
    TRACEEOL( "SRVMGR.CPL: TerminateAllApplets BLT::_MASTER_TIMER::Term complete" );

    BLT::Term( _hCplInstance );

    TRACEEOL( "SRVMGR.CPL: TerminateAllApplets exit" );

}   // TerminateAllApplets


/*******************************************************************

    NAME:       RunSrvMgr

    SYNOPSIS:   Invoke the main dialog of the Server Manager Control
                Panel Applet.

    ENTRY:      hWnd                    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        KeithMo     10-Jun-1992 Robustified server startup code.

********************************************************************/
APIERR RunSrvMgr( HWND hWnd )
{
#ifdef DEBUG_SMCPA
    DebugBreak();
#endif  // DEBUG_SMCPA

    POPUP::SetCaption( IDS_CAPTION_PROPERTIES );

    //
    //  Let's see if the server is running.
    //

    NLS_STR nlsServerName;
    BOOL    fServerRunning = FALSE;                   // until proven otherwise
    APIERR  err = GetLocalServerName( nlsServerName );

    if( err == NERR_Success )
    {
        fServerRunning = TRUE;
    }
    else
    if( err == NERR_ServerNotStarted )
    {
        //
        //  The server is not started.  Let's see if the user
        //  wants us to start it.
        //

        if( MsgPopup( hWnd,
                      IDS_START_SERVER_NOW,
                      MPSEV_WARNING,
                      MP_YESNO,
                      MP_YES ) != IDYES )
        {
            //
            //  The user doesn't want to play right now.
            //

            err = NERR_Success;
        }
        else
        {
            //
            //  Start the server & re-retrieve the server name.
            //

            err = StartServer( hWnd );

            if( err == NERR_Success )
            {
                err = GetLocalServerName( nlsServerName );
            }

            fServerRunning = ( err == NERR_Success );
        }
    }

    if( ( err == NERR_Success ) && fServerRunning )
    {
        //
        //  Invoke the Main Property Sheet.
        //

        BOOL fDummy;

        SERVER_PROPERTIES * pDlg = new SERVER_PROPERTIES( hWnd,
                                                          nlsServerName,
                                                          &fDummy );

        if (pDlg == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if ( (err = pDlg->QueryError()) == NERR_Success)
        {
            err = pDlg->Process();
        }

        delete pDlg;
    }

    if( err != NERR_Success )
    {
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();

    return err;

}   // RunSrvMgr


/*******************************************************************

    NAME:       RunSvcMgr

    SYNOPSIS:   Invoke the main dialog of the Service Manager Control
                Panel Applet.

    ENTRY:      hWnd                    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        KeithMo     06-Jul-1992 Created.

********************************************************************/
APIERR RunSvcMgr( HWND hWnd )
{
    POPUP::SetCaption( IDS_CAPTION_SVCCNTL );

    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDisplayName.QueryError();
    }

    if( err == NERR_Success )
    {
        err = loc.QueryDisplayName( &nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        SVCCNTL_DIALOG * pDlg = new SVCCNTL_DIALOG( hWnd,
                                                    NULL,
                                                    nlsDisplayName,
                                                    SV_TYPE_NT );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process();
        delete pDlg;
    }

    if( err != NERR_Success )
    {
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();

    return err;

}   // RunSvcMgr


/*******************************************************************

    NAME:       RunDevMgr

    SYNOPSIS:   Invoke the main dialog of the Device Manager Control
                Panel Applet.

    ENTRY:      hWnd                    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR RunDevMgr( HWND hWnd )
{
    POPUP::SetCaption( IDS_CAPTION_DEVCNTL );

    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDisplayName.QueryError();
    }

    if( err == NERR_Success )
    {
        err = loc.QueryDisplayName( &nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        DEVCNTL_DIALOG * pDlg = new DEVCNTL_DIALOG( hWnd,
                                                    NULL,
                                                    nlsDisplayName,
                                                    SV_TYPE_NT );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process();
        delete pDlg;
    }

    if( err != NERR_Success )
    {
        ::MsgPopup( hWnd, err );
    }

    POPUP::ResetCaption();

    return err;

}   // RunDevMgr


BOOL strLoad( INT idString, WCHAR * pszBuffer, INT cchBuffer )
{
    int result = ::LoadString( ::_hCplInstance,
                                idString,
                                pszBuffer,
                                cchBuffer );

    return ( result > 0 ) && ( result < cchBuffer );

}   // strLoad


/*******************************************************************

    NAME:       CPlApplet

    SYNOPSIS:   Exported function to start the Server Manager Control
                Panel Applet.

    ENTRY:      hwndCPl                 - Window handle of parent.

                nMsg                    - CPL user message (see CPL.H
                                          in WINDOWS\SHELL\CONTROL\H).

                lParam1                 - Message-specific pointer.

                lParam2                 - Message-specific pointer.

    RETURNS:    LONG

    HISTORY:
        KeithMo     22-Apr-1992 Created.
        JonN        30-Aug-1994 Added lParam parameters to CPL_INIT, CPL_TERM
        JonN        26-Jun-2000 CPlApplet takes HWND, UINT, LPARAM, LPARAM

********************************************************************/
LONG FAR PASCAL CPlApplet( HWND hwndCPl,
                           UINT nMsg,
                           LPARAM lParam1,
                           LPARAM lParam2 )
{
    LPCPLINFO    pCplInfo;
    LPNEWCPLINFO pNewInfo;
    LONG         nResult = 0;

    switch( nMsg )
    {
    case CPL_INIT:
        //
        //  This message is sent to indicate that CPlApplet() was found.
        //
        //  lParam1 is not used, but we pass it anyway.
        //
        //  lParam2 is -1 iff the DLL will be used only to confirm the
        //  number of applets.
        //
        //
        //  Return TRUE if applet should be installed, FALSE otherwise.
        //

        return TRUE;

    case CPL_GETCOUNT:
        //
        //  This message is set to determine the number of applets contained
        //  in this DLL.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return the number of applets contained in this DLL.
        //

        return cActiveApplets;

    case CPL_INQUIRE:
        //
        //  This message is sent once per applet to retrieve information
        //  about each applet.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a CPLINFO structure.  The CPLINFO
        //  structure's idIcon, idName, idInfo, and lData fields should
        //  be initialized as appropriate for the applet.
        //
        //  There is no return value.
        //

        pCplInfo = (LPCPLINFO)lParam2;

        if( lParam1 < cActiveApplets )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pCplInfo->idIcon = pApplet->idIcon;
            pCplInfo->idName = pApplet->idName;
            pCplInfo->idInfo = pApplet->idInfo;
            pCplInfo->lData  = pApplet->lData;
        }
        break;

    case CPL_SELECT:
        //
        //  This message is sent when the applet's icon has been
        //  selected.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_DBLCLK:
        //
        //  This message is sent when the applet's icon has been
        //  double-clicked.  This message should initiate the
        //  applet's dialog box.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        if( lParam1 < cActiveApplets )
        {
            if ( (LONG)InitializeAllApplets( hwndCPl, lParam1, lParam2 ) )
            {
                (CplApplets[lParam1].pfnApplet)( hwndCPl );
                TerminateAllApplets( hwndCPl, lParam1, lParam2 );
            }
            else
            {
                ASSERT( FALSE );
            }
        }
        break;

    case CPL_STOP:
        //
        //  This message is sent once for each applet when the
        //  control panel is shutting down.  This message should
        //  initiate applet specific cleanup.
        //
        //  lParam1 is the applet number being stopped.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_EXIT:
        //
        //  This message is sent just before the control panel calls
        //  FreeLibrary.  This message should initiate non applet
        //  specific cleanup.
        //
        //  lParam1 is not used, but we pass it anyway.
        //
        //  lParam2 is -1 iff the DLL was used only to confirm the
        //  number of applets.
        //
        //  There is no return value.
        //

        break;

    case CPL_NEWINQUIRE:
        //
        //  This message is basically the same as CPL_INQUIRE, except
        //  lParam2 points to a NEWCPLINFO structure.  This message will
        //  be sent *before* CPL_INQUIRE.  If the applet returns a non
        //  zero value, then CPL_INQUIRE will not be sent.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a NEWCPLINFO structure.
        //
        //  Return TRUE this message was handled, otherwise return FALSE.
        //

        pNewInfo = (LPNEWCPLINFO)lParam2;

        if( lParam1 < cActiveApplets )
        {
            CPL_APPLET * pApplet = &CplApplets[lParam1];

            pNewInfo->dwSize        = sizeof(*pNewInfo);
            pNewInfo->dwFlags       = 0;
            pNewInfo->dwHelpContext = pApplet->dwHelpContext;
            pNewInfo->lData         = pApplet->lData;

            pNewInfo->hIcon = ::LoadIcon( ::_hCplInstance,
                                          MAKEINTRESOURCE( pApplet->idIcon ) );

            if( ( pNewInfo->hIcon != NULL ) &&
                strLoad( pApplet->idName,
                         pNewInfo->szName,
                         sizeof(pNewInfo->szName) ) &&
                strLoad( pApplet->idInfo,
                         pNewInfo->szInfo,
                         sizeof(pNewInfo->szInfo) ) &&
                strLoad( pApplet->idHelpFile,
                         pNewInfo->szHelpFile,
                         sizeof(pNewInfo->szHelpFile) ) )
            {
                nResult = TRUE;
            }
        }
        break;

    default:
        //
        //  Who knows.  Ignore it.
        //

        break;
    }

    return nResult;

}   // CPlApplet



/*******************************************************************

    NAME:       DllMain

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance               - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     22-Apr-1992 Created.

********************************************************************/

BOOL DllMain( HINSTANCE hInstance, DWORD  nReason, LPVOID pReserved )
{
    BOOL fResult = TRUE;

    UNREFERENCED(pReserved);

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        DisableThreadLibraryCalls(hInstance);
        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\h\srvhelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    srvhelp.h
    Server Manager include file for help numbers

    FILE HISTORY:
        ChuckC    27-Feb-1992   Split off from srvmgr.h.
        KeithMo   13-Aug-1992   Contexts based on HC_UI_SRVMGR_BASE.
        Yi-Hsin   09-Oct-1992   Add the help contexts for share dialogs

*/


#ifndef _SRVHELP_H_
#define _SRVHELP_H_


#include <uihelp.h>

//
//  Range HC_UI_SRVMGR_BASE - HC_UI_SRVMGR_BASE+99 are reserved for
//  the share dialogs.
//

//
//  Reserved Help context for share management dialog and all subdialogs
//  that lives in ntlanman.dll.
//
//  IMPORTANT: Do not change the numbers listed here unless you
//             change help contexts in server manager help file,
//             file manager help file and shell\h\helpnums.h
//

// #define HC_SHARE_PROPERTY            (HC_UI_SRVMGR_BASE + 1)
// #define HC_SHARE_NEWSHARE            (HC_UI_SRVMGR_BASE + 2)
// #define HC_SHARE_MANAGEMENT          (HC_UI_SRVMGR_BASE + 3)

// #define HC_SHARE_CURRENTUSERSWARNING (HC_UI_SRVMGR_BASE + 4)
// #define HC_SHARE_LMSHARELEVELPERMS   (HC_UI_SRVMGR_BASE + 5)
// #define HC_SHARE_PASSWORDPROMPT      (HC_UI_SRVMGR_BASE + 9)
// #define HC_SHARE_NTSHAREPERMS        (HC_UI_SRVMGR_BASE + 11)
// #define HC_SHARE_ADDUSER             (HC_UI_SRVMGR_BASE + 12)
// #define HC_SHARE_ADDUSER_LOCALGROUP  (HC_UI_SRVMGR_BASE + 13)
// #define HC_SHARE_ADDUSER_GLOBALGROUP (HC_UI_SRVMGR_BASE + 14)
// #define HC_SHARE_ADDUSER_FINDUSER    (HC_UI_SRVMGR_BASE + 15)

//
//  Reserved help contexts for message popups in the share dialogs.
//  IMPORTANT: Do not change these numbers unless you also change the
//             help contexts in server manager.
//
//  #define HC_SHAREREMOTEADMINNOTSUPPORTED (HC_UI_SRVMGR_BASE + 50)
//  #define HC_SHAREINVALIDPERMISSIONS      (HC_UI_SRVMGR_BASE + 51)
//  #define HC_SHAREINVALIDCOMMENT          (HC_UI_SRVMGR_BASE + 52)
//  #define HC_SHAREINVALIDSHAREPATH        (HC_UI_SRVMGR_BASE + 53)
//  #define HC_SHAREINVALIDLOCALPATH        (HC_UI_SRVMGR_BASE + 54)
//  #define HC_SHAREINVALIDSHARE            (HC_UI_SRVMGR_BASE + 55)
//  #define HC_SHAREINVALIDUSERLIMIT        (HC_UI_SRVMGR_BASE + 56)
//  #define HC_SPECIALSHAREINVALIDPATH      (HC_UI_SRVMGR_BASE + 57)
//  #define HC_SPECIALSHAREINVALIDCOMMENT   (HC_UI_SRVMGR_BASE + 58)
//  #define HC_SPECIALSHARECANNOTCHANGEPATH (HC_UI_SRVMGR_BASE + 59)
//  #define HC_SHAREPROPCHANGEPASSWDWARN    (HC_UI_SRVMGR_BASE + 60)
//  #define HC_CHANGEPATHWARNING            (HC_UI_SRVMGR_BASE + 61)
//  #define HC_SHARENOTACCESSIBLEFROMDOS    (HC_UI_SRVMGR_BASE + 62)
//  #define HC_CANNOTSETPERMONLMUSERSERVER  (HC_UI_SRVMGR_BASE + 63)
//


//
//  Help contexts for the message popups.
//

#define HC_VERIFY_ROLE_CHANGE       (HC_UI_SRVMGR_BASE + 100)
#define HC_VERIFY_DC_RESYNC         (HC_UI_SRVMGR_BASE + 101)
#define HC_CANNOT_FIND_SERVER       (HC_UI_SRVMGR_BASE + 102)
#define HC_DISCONNECT_USER          (HC_UI_SRVMGR_BASE + 103)
#define HC_FORCE_CLOSE              (HC_UI_SRVMGR_BASE + 104)
#define HC_WARN_NO_PDC              (HC_UI_SRVMGR_BASE + 105)
#define HC_CANNOT_FIND_PDC          (HC_UI_SRVMGR_BASE + 106)
#define HC_VERIFY_DOMAIN_RESYNC     (HC_UI_SRVMGR_BASE + 107)
#define HC_CLOSE_ALL                (HC_UI_SRVMGR_BASE + 108)
#define HC_CANNOT_REMOVE_SERVER     (HC_UI_SRVMGR_BASE + 109)
#define HC_CANNOT_REMOVE_WKSTA      (HC_UI_SRVMGR_BASE + 110)
#define HC_DISCONNECT_USER_OPEN     (HC_UI_SRVMGR_BASE + 111)
#define HC_DISCONNECT_USERS         (HC_UI_SRVMGR_BASE + 112)
#define HC_DISCONNECT_USERS_OPEN    (HC_UI_SRVMGR_BASE + 113)
#define HC_DISCONNECT_ALL           (HC_UI_SRVMGR_BASE + 114)
#define HC_DISCONNECT_ALL_OPEN      (HC_UI_SRVMGR_BASE + 115)
#define HC_DISCONNECT_COMPUTER      (HC_UI_SRVMGR_BASE + 116)
#define HC_DISCONNECT_COMPUTER_OPEN (HC_UI_SRVMGR_BASE + 117)


//
//  Help contexts for the various dialogs.
//

#define HC_SERVER_PROPERTIES        (HC_UI_SRVMGR_BASE + 200)
#define HC_SVCCNTL_DIALOG           (HC_UI_SRVMGR_BASE + 201)
#define HC_SESSIONS_DIALOG          (HC_UI_SRVMGR_BASE + 202)
#define HC_FILES_DIALOG             (HC_UI_SRVMGR_BASE + 203)
#define HC_OPENS_DIALOG             (HC_UI_SRVMGR_BASE + 204)
#define HC_REPL_MAIN_BOTH_DIALOG    (HC_UI_SRVMGR_BASE + 205)
#define HC_REPL_EXPORT_DIALOG       (HC_UI_SRVMGR_BASE + 206)
#define HC_REPL_IMPORT_DIALOG       (HC_UI_SRVMGR_BASE + 207)
#define HC_REPL_ADD_DIALOG          (HC_UI_SRVMGR_BASE + 208)
#define HC_ALERTS_DIALOG            (HC_UI_SRVMGR_BASE + 209)
#define HC_PASSWORD_DIALOG          (HC_UI_SRVMGR_BASE + 210)
#define HC_SVC_DEP_DIALOG           (HC_UI_SRVMGR_BASE + 211)
#define HC_NT_ALERTS_DLG            (HC_UI_SRVMGR_BASE + 212)
#define HC_SEND_MSG_DLG             (HC_UI_SRVMGR_BASE + 213)
#define HC_ADD_COMPUTER_DLG         (HC_UI_SRVMGR_BASE + 214)
#define HC_SVCCFG_DIALOG            (HC_UI_SRVMGR_BASE + 215)
#define HC_SETFOCUS_DIALOG          (HC_UI_SRVMGR_BASE + 216)
#define HC_REPL_SETFOCUS_DIALOG     (HC_UI_SRVMGR_BASE + 218)
#define HC_REPL_MAIN_IMPONLY_DIALOG (HC_UI_SRVMGR_BASE + 219)

#define HC_USERBROWSER_DIALOG              (HC_UI_SRVMGR_BASE + 220)
#define HC_USERBROWSER_DIALOG_LOCALGROUP   (HC_UI_SRVMGR_BASE + 221)
#define HC_USERBROWSER_DIALOG_GLOBALGROUP  (HC_UI_SRVMGR_BASE + 222)
#define HC_USERBROWSER_DIALOG_FINDUSER     (HC_UI_SRVMGR_BASE + 223)

#define HC_DEVCNTL_DIALOG           (HC_UI_SRVMGR_BASE + 224)
#define HC_DEVCFG_DIALOG            (HC_UI_SRVMGR_BASE + 225)

#define HC_SVC_HWPROFILE_DLG            (HC_UI_SRVMGR_BASE + 226)
#define HC_DEV_HWPROFILE_DLG            (HC_UI_SRVMGR_BASE + 227)

#define HC_USERBROWSER_DIALOG_MEMBERSHIP   (HC_UI_SRVMGR_BASE + 14)
#define HC_USERBROWSER_DIALOG_SEARCH       (HC_UI_SRVMGR_BASE + 15)


//
//  Help context for the various menu items.
//

#define HC_COMPUTER_PROPERTIES      (HC_UI_SRVMGR_BASE + 300)
#define HC_COMPUTER_SHARES          (HC_UI_SRVMGR_BASE + 301)
#define HC_COMPUTER_SVCCNTL         (HC_UI_SRVMGR_BASE + 302)
#define HC_COMPUTER_SENDMSG         (HC_UI_SRVMGR_BASE + 303)
#define HC_COMPUTER_PROMOTE         (HC_UI_SRVMGR_BASE + 304)
#define HC_COMPUTER_SYNC_WITH_DC    (HC_UI_SRVMGR_BASE + 305)
#define HC_COMPUTER_SYNC_DOMAIN     (HC_UI_SRVMGR_BASE + 306)
#define HC_COMPUTER_ADD_COMPUTER    (HC_UI_SRVMGR_BASE + 307)
#define HC_COMPUTER_REMOVE_COMPUTER (HC_UI_SRVMGR_BASE + 308)
#define HC_COMPUTER_SET_FOCUS       (HC_UI_SRVMGR_BASE + 309)
#define HC_COMPUTER_EXIT            (HC_UI_SRVMGR_BASE + 310)
#define HC_COMPUTER_DEMOTE          (HC_UI_SRVMGR_BASE + 311)

#define HC_VIEW_SERVERS             (HC_UI_SRVMGR_BASE + 400)
#define HC_VIEW_WORKSTATIONS        (HC_UI_SRVMGR_BASE + 401)
#define HC_VIEW_ALL                 (HC_UI_SRVMGR_BASE + 402)
#define HC_VIEW_REFRESH             (HC_UI_SRVMGR_BASE + 403)
#define HC_VIEW_MEMBERS_ONLY        (HC_UI_SRVMGR_BASE + 404)

#define HC_OPTIONS_SAVE_SETTINGS    (HC_UI_SRVMGR_BASE + 500)
#define HC_OPTIONS_RAS_MODE         (HC_UI_SRVMGR_BASE + 501)

#define HC_HELP_KEYBSHORTCUTS       (HC_UI_SRVMGR_BASE + 600)
#define HC_HELP_CONTENTS            (HC_UI_SRVMGR_BASE + 601)
#define HC_HELP_SEARCH              (HC_UI_SRVMGR_BASE + 602)
#define HC_HELP_HOWTOUSE            (HC_UI_SRVMGR_BASE + 603)
#define HC_HELP_ABOUT               (HC_UI_SRVMGR_BASE + 604)


#endif  // _SRVHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\h\srvmgr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvmgr.h
    Server Manager include file.

    This file contains the ID constants used by the Server Manager.


    FILE HISTORY:
        ?????       ??-???-???? Created.
        chuckc      27-Feb-1992 cleaned up number ranges
        beng        04-Aug-1992 Move ordinals into official ranges
*/


#ifndef _SRVMGR_H_
#define _SRVMGR_H_

#include "uimsg.h"      // for IDS_UI_SRVMGR_BASE

#define ID_APPMENU  10
#define ID_APPACCEL 11
#define ID_RESOURCE 300

//
// string ID's
//
#define IDS_SMAPP_BASE          IDS_UI_SRVMGR_BASE

#define IDS_SMAPPNAME           (IDS_SMAPP_BASE+1)
#define IDS_SMOBJECTNAME        (IDS_SMAPP_BASE+2)
#define IDS_SMINISECTIONNAME    (IDS_SMAPP_BASE+3)
#define IDS_SMHELPFILENAME      (IDS_SMAPP_BASE+4)
#define IDS_SMCPA_HELPFILENAME  (IDS_SMAPP_BASE+5)
#define IDS_SMX_LIST            (IDS_SMAPP_BASE+6)

//
// Menu ID's
//
#define IDM_SMAPP_BASE          IDM_ADMINAPP_LAST
// IDM_PROPERTIES defined in adminapp.h
#define IDM_SENDMSG             (IDM_SMAPP_BASE+1)
#define IDM_PROMOTE             (IDM_SMAPP_BASE+2)
#define IDM_RESYNC              (IDM_SMAPP_BASE+3)
#define IDM_ADDCOMPUTER         (IDM_SMAPP_BASE+4)
#define IDM_REMOVECOMPUTER      (IDM_SMAPP_BASE+5)
// IDM_SETFOCUS defined in adminapp.h
// IDM_EXIT defined in adminapp.h
#define IDM_VIEW_SERVERS        (IDM_SMAPP_BASE+6)
#define IDM_VIEW_WORKSTATIONS   (IDM_SMAPP_BASE+7)
#define IDM_VIEW_ALL            (IDM_SMAPP_BASE+8)
#define IDM_SVCCNTL             (IDM_SMAPP_BASE+9)
#define IDM_SHARES              (IDM_SMAPP_BASE+10)
#define IDM_VIEW_ACCOUNTS_ONLY  (IDM_SMAPP_BASE+11)


//
// Bitmap ID's for Main Window ListBox
//

#define IDBM_ACTIVE_PRIMARY     81
#define IDBM_INACTIVE_PRIMARY   82
#define IDBM_ACTIVE_SERVER      83
#define IDBM_INACTIVE_SERVER    84
#define IDBM_ACTIVE_WKSTA       85
#define IDBM_INACTIVE_WKSTA     86
#define IDBM_UNKNOWN            87


//
// Main Window ListBox Control ID
//

#define IDC_MAINWINDOWLB                190

//
// Main Window ListBox Column Header Control ID
//

#define IDC_COLHEAD_SERVERS             191

//
// Strings for column headers.
//

#define IDS_COL_HEADER_SERVER_NAME      (IDS_SMAPP_BASE+10)
#define IDS_COL_HEADER_SERVER_TYPE      (IDS_SMAPP_BASE+11)
#define IDS_COL_HEADER_SERVER_COMMENT   (IDS_SMAPP_BASE+12)

//
// User connection sub-property
//

#define IDD_USER_CONNECTIONS        4000
#define IDDUC_DISC_GRP              4001
#define IDDUC_USER_DISC             4002
#define IDDUC_RESOURCE_DISC         4003
#define IDDUC_USER_CONN             4004
#define IDDUC_REFRESH               4008
#define ID_DISCONNECT               4009
#define ID_DISCONNECT_ALL           4010
#define IDUC_USERS_CONNECTED        4012
#define IDDUC_USER_CONNLIST         4013
#define IDDUC_RESOURCE_LIST         4021


//
//  For DLGEDIT.EXE's benefit.
//

#ifndef IDHELPBLT
#error The *real* IDHELPBLT is defined in BLTRC.H.  Use it instead!
    //
    //  The following is just a bogus number used to keep the
    //  dialog editor happy.  It may or may not correspond to
    //  the actual number used in BLT.
    //
#define IDHELPBLT                      80
#endif  // IDHELPBLT


//
//  Icon IDs for domain role transition progress indicator.
//
//  NOTE:  These IDs MUST be contiguous!
//

#define IDI_PROGRESS_ICON_0         160
#define IDI_PROGRESS_ICON_1         161
#define IDI_PROGRESS_ICON_2         162
#define IDI_PROGRESS_ICON_3         163
#define IDI_PROGRESS_ICON_4         164
#define IDI_PROGRESS_ICON_5         165
#define IDI_PROGRESS_ICON_6         166
#define IDI_PROGRESS_ICON_7         167
#define IDI_PROGRESS_ICON_8         168
#define IDI_PROGRESS_ICON_9         169
#define IDI_PROGRESS_ICON_10        170
#define IDI_PROGRESS_ICON_11        171
#define IDI_PROGRESS_NUM_ICONS      12      // number of icons in cycle

#define IDI_SMCPA_ICON              150
#define IDI_SVCCPA_ICON             151
#define IDI_SRVMGR_ICON             152
#define IDI_DEVCPA_ICON             153


//
//  Message Pop-up string IDs.
//

#define IDS_VERIFY_ROLE_CHANGE      (IDS_SMAPP_BASE+101)
#define IDS_VERIFY_DC_RESYNC        (IDS_SMAPP_BASE+102)
#define IDS_VERIFY_DOMAIN_RESYNC    (IDS_SMAPP_BASE+103)
#define IDS_CANNOT_FIND_SERVER      (IDS_SMAPP_BASE+104)
#define IDS_DISCONNECT_USER         (IDS_SMAPP_BASE+105)
#define IDS_DISCONNECT_USER_OPEN    (IDS_SMAPP_BASE+106) // IDS_DISCONNECT_USER+1
#define IDS_FORCE_CLOSE             (IDS_SMAPP_BASE+107)
#define IDS_CLOSE_ALL               (IDS_SMAPP_BASE+108)
#define IDS_DISCONNECT_ALL          (IDS_SMAPP_BASE+109)
#define IDS_DISCONNECT_ALL_OPEN     (IDS_SMAPP_BASE+110)
#define IDS_DISCONNECT_USERS        (IDS_SMAPP_BASE+111)
#define IDS_DISCONNECT_USERS_OPEN   (IDS_SMAPP_BASE+112)
#define IDS_VERIFY_DEMOTE           (IDS_SMAPP_BASE+113)
#define IDS_CANNOT_UPDATE_ALERTS    (IDS_SMAPP_BASE+114)
#define IDS_DISCONNECT_COMPUTER     (IDS_SMAPP_BASE+115) // IDS_DISCONNECT_USER+10
#define IDS_DISCONNECT_COMPUTER_OPEN (IDS_SMAPP_BASE+116) // IDS_DISCONNECT_USER+11

#define IDS_DOMAIN_RESYNC_ERROR     (IDS_SMAPP_BASE+119)    // <<
#define IDS_DOMAIN_START_ERROR      (IDS_SMAPP_BASE+120)    // << These must
#define IDS_DOMAIN_STOP_ERROR       (IDS_SMAPP_BASE+121)    // << match the
#define IDS_DOMAIN_ROLE_ERROR       (IDS_SMAPP_BASE+122)    // << AC_*
#define IDS_DOMAIN_MODALS_ERROR     (IDS_SMAPP_BASE+123)    // << action
#define IDS_DOMAIN_PASSWORD_ERROR   (IDS_SMAPP_BASE+124)    // << codes!!

#define IDS_AC_RESYNCING            (IDS_SMAPP_BASE+125)    // <<
#define IDS_AC_STARTING             (IDS_SMAPP_BASE+126)    // << These must
#define IDS_AC_STOPPING             (IDS_SMAPP_BASE+127)    // << match the
#define IDS_AC_ROLE                 (IDS_SMAPP_BASE+128)    // << AC_*
#define IDS_AC_MODALS               (IDS_SMAPP_BASE+129)    // << action
#define IDS_AC_PASSWORD             (IDS_SMAPP_BASE+130)    // << codes!!

#define IDS_WARN_NO_PDC             (IDS_SMAPP_BASE+135)

#define IDS_YES                     (IDS_SMAPP_BASE+140)
#define IDS_NO                      (IDS_SMAPP_BASE+141)
#define IDS_CANNOT_FIND_PDC         (IDS_SMAPP_BASE+142)
#define IDS_STOPPED                 (IDS_SMAPP_BASE+151)
#define IDS_STARTED                 (IDS_SMAPP_BASE+152)
#define IDS_PAUSED                  (IDS_SMAPP_BASE+153)

#define IDS_BUTTON_USERS            (IDS_SMAPP_BASE+171)
#define IDS_BUTTON_FILES            (IDS_SMAPP_BASE+172)
#define IDS_BUTTON_OPENRES          (IDS_SMAPP_BASE+173)
#define IDS_BUTTON_REPL             (IDS_SMAPP_BASE+175)
#define IDS_BUTTON_ALERTS           (IDS_SMAPP_BASE+176)
#define IDS_BUTTON_CLOSE            (IDS_SMAPP_BASE+177)

#define IDS_ROLE_PRIMARY            (IDS_SMAPP_BASE+180)
#define IDS_ROLE_BACKUP             (IDS_SMAPP_BASE+181)
#define IDS_ROLE_WKSTA              (IDS_SMAPP_BASE+182)
#define IDS_ROLE_UNKNOWN            (IDS_SMAPP_BASE+183)
#define IDS_TYPE_FORMAT             (IDS_SMAPP_BASE+184)
#define IDS_TYPE_FORMAT_UNKNOWN     (IDS_SMAPP_BASE+185)
#define IDS_ROLE_SERVER             (IDS_SMAPP_BASE+186)
#define IDS_ROLE_LMSERVER           (IDS_SMAPP_BASE+187)
#define IDS_ROLE_WKSTA_OR_SERVER    (IDS_SMAPP_BASE+188)

#define IDS_SERVICE_STARTING        (IDS_SMAPP_BASE+190)
#define IDS_SERVICE_STOPPING        (IDS_SMAPP_BASE+191)
#define IDS_SERVICE_PAUSING         (IDS_SMAPP_BASE+192)
#define IDS_SERVICE_CONTINUING      (IDS_SMAPP_BASE+193)

#define IDS_STOP_WARNING            (IDS_SMAPP_BASE+200)
#define IDS_STOP_SUCCESS            (IDS_SMAPP_BASE+201)
#define IDS_CANNOT_START            (IDS_SMAPP_BASE+202)
#define IDS_CANNOT_STOP             (IDS_SMAPP_BASE+203)
#define IDS_CANNOT_PAUSE            (IDS_SMAPP_BASE+204)
#define IDS_CANNOT_CONTINUE         (IDS_SMAPP_BASE+205)
#define IDS_SERVICE_TIMEOUT         (IDS_SMAPP_BASE+206)
#define IDS_SERVICE_UNEXP_STATE     (IDS_SMAPP_BASE+207)
#define IDS_CANNOT_SENDALL          (IDS_SMAPP_BASE+208)
#define IDS_REMOVE_EXPORT_TARGET    (IDS_SMAPP_BASE+209)
#define IDS_REMOVE_IMPORT_TARGET    (IDS_SMAPP_BASE+210)
#define IDS_REMOVE_EXPORT_DIR       (IDS_SMAPP_BASE+211)
#define IDS_REMOVE_IMPORT_DIR       (IDS_SMAPP_BASE+212)
#define IDS_NEED_TEXT_TO_SEND       (IDS_SMAPP_BASE+213)
#define IDS_START_SERVER_NOW        (IDS_SMAPP_BASE+214)
#define IDS_CANT_REMOTE_ADMIN       (IDS_SMAPP_BASE+215)
#define IDS_DIR_ALREADY_EXISTS      (IDS_SMAPP_BASE+216)

#define IDS_CAPTION_DEVCNTL         (IDS_SMAPP_BASE+218)
#define IDS_CAPTION_DEVCFG          (IDS_SMAPP_BASE+219)
#define IDS_CAPTION_PROPERTIES      (IDS_SMAPP_BASE+220)
#define IDS_CAPTION_SVCCNTL         (IDS_SMAPP_BASE+221)
#define IDS_CAPTION_USERS           (IDS_SMAPP_BASE+222)
#define IDS_CAPTION_FILES           (IDS_SMAPP_BASE+223)
#define IDS_CAPTION_OPENRES         (IDS_SMAPP_BASE+224)
#define IDS_CAPTION_REPL            (IDS_SMAPP_BASE+226)
#define IDS_CAPTION_ALERTS          (IDS_SMAPP_BASE+227)
#define IDS_CAPTION_SVC_DEP         (IDS_SMAPP_BASE+228)
#define IDS_CAPTION_SVCCFG          (IDS_SMAPP_BASE+229)

#define IDS_PASSWORD_INVALID        (IDS_SMAPP_BASE+230)
#define IDS_PASSWORD_MISMATCH       (IDS_SMAPP_BASE+231)
#define IDS_COMPUTERNAME_INVALID    (IDS_SMAPP_BASE+232)
#define IDS_ACCOUNT_NAME_INVALID    (IDS_SMAPP_BASE+233)
#define IDS_LOGON_SCRIPT_INVALID    (IDS_SMAPP_BASE+234)
#define IDS_ALERT_TARGET_INVALID    (IDS_SMAPP_BASE+235)

#define IDS_CANNOT_START_DEV        (IDS_SMAPP_BASE+236)
#define IDS_CANNOT_STOP_DEV         (IDS_SMAPP_BASE+237)

#define IDS_CAPTION_DEV_CONTROL     (IDS_SMAPP_BASE+238)
#define IDS_CAPTION_SVC_CONTROL     (IDS_SMAPP_BASE+239)

#define IDS_CAPTION_MAIN_WKSTAS     (IDS_SMAPP_BASE+240)
#define IDS_CAPTION_MAIN_SERVERS    (IDS_SMAPP_BASE+241)
#define IDS_CAPTION_MAIN_ALL        (IDS_SMAPP_BASE+242)
#define IDS_CAPTION_MAIN_EXTENSION  (IDS_SMAPP_BASE+243)

#define IDS_EXPORT_PATH_INVALID     (IDS_SMAPP_BASE+244)
#define IDS_IMPORT_PATH_INVALID     (IDS_SMAPP_BASE+245)

#define IDS_SYSTEM_VOLUME_INVALID   (IDS_SMAPP_BASE+246)

#define IDS_SVC_STOP_WARN           (IDS_SMAPP_BASE+300)
#define IDS_SVC_PAUSE_WARN          (IDS_SMAPP_BASE+301)
#define IDS_DEV_STOP_WARN           (IDS_SMAPP_BASE+302)
#define IDS_DEV_CHANGE_WARN         (IDS_SMAPP_BASE+303)

#define IDS_IDIR_OK                 (IDS_SMAPP_BASE+400)
#define IDS_IDIR_NO_MASTER          (IDS_SMAPP_BASE+401)
#define IDS_IDIR_NO_SYNC            (IDS_SMAPP_BASE+402)
#define IDS_IDIR_NEVER_REPLICATED   (IDS_SMAPP_BASE+403)

#define IDS_SMCPA_NAME_STRING       (IDS_SMAPP_BASE+410)
#define IDS_SMCPA_INFO_STRING       (IDS_SMAPP_BASE+411)

#define IDS_SVCCPA_NAME_STRING      (IDS_SMAPP_BASE+412)
#define IDS_SVCCPA_INFO_STRING      (IDS_SMAPP_BASE+413)

#define IDS_DEVCPA_NAME_STRING      (IDS_SMAPP_BASE+414)
#define IDS_DEVCPA_INFO_STRING      (IDS_SMAPP_BASE+415)

#define IDS_SYNC_WITH_DC            (IDS_SMAPP_BASE+420)
#define IDS_SYNC_ENTIRE_DOMAIN      (IDS_SMAPP_BASE+421)
#define IDS_PROMOTE_TO_CONTROLLER   (IDS_SMAPP_BASE+422)
#define IDS_DEMOTE_TO_SERVER        (IDS_SMAPP_BASE+423)

#define IDS_ADDED_COMPUTER_WARN     (IDS_SMAPP_BASE+431)
#define IDS_REMOVE_SERVER_WARNING   (IDS_SMAPP_BASE+432)
#define IDS_REMOVE_WKSTA_WARNING    (IDS_SMAPP_BASE+433)
#define IDS_REMOVE_SERVER_DONE      (IDS_SMAPP_BASE+434)
#define IDS_REMOVE_WKSTA_DONE       (IDS_SMAPP_BASE+435)
#define IDS_CANNOT_REMOVE_SERVER    (IDS_SMAPP_BASE+436)
#define IDS_CANNOT_REMOVE_WKSTA     (IDS_SMAPP_BASE+437)
#define IDS_CANNOT_ADD_MACHINE      (IDS_SMAPP_BASE+438)

#define IDS_STARTING                (IDS_SMAPP_BASE+450)
#define IDS_STOPPING                (IDS_SMAPP_BASE+451)
#define IDS_PAUSING                 (IDS_SMAPP_BASE+452)
#define IDS_CONTINUING              (IDS_SMAPP_BASE+453)
#define IDS_STARTING_NONAME         (IDS_SMAPP_BASE+454)
#define IDS_STARTING_DEV            (IDS_SMAPP_BASE+455)
#define IDS_STOPPING_DEV            (IDS_SMAPP_BASE+456)

#define IDS_SERVER_TYPE_WINNT       (IDS_SMAPP_BASE+460)
#define IDS_SERVER_TYPE_LANMAN      (IDS_SMAPP_BASE+461)
#define IDS_SERVER_TYPE_WFW         (IDS_SMAPP_BASE+462)
#define IDS_SERVER_TYPE_WINDOWS95   (IDS_SMAPP_BASE+463)
#define IDS_SERVER_TYPE_UNKNOWN     (IDS_SMAPP_BASE+464)
#define IDS_TYPE_FORMAT_WIN2000     (IDS_SMAPP_BASE+465)
#define IDS_TYPE_FORMAT_FUTURE      (IDS_SMAPP_BASE+466)

#define IDS_BOOT                    (IDS_SMAPP_BASE+499)
#define IDS_SYSTEM                  (IDS_SMAPP_BASE+500)
#define IDS_AUTOMATIC               (IDS_SMAPP_BASE+501)
#define IDS_MANUAL                  (IDS_SMAPP_BASE+502)
#define IDS_DISABLED                (IDS_SMAPP_BASE+503)
#define IDS_SERVICE_SPECIFIC_CODE   (IDS_SMAPP_BASE+504)
#define IDS_CANNOT_LOAD_EXTENSION   (IDS_SMAPP_BASE+505)
#define IDS_CANNOT_LOAD_EXTENSION2  (IDS_SMAPP_BASE+506)
#define IDS_DEVICE_SPECIFIC_CODE    (IDS_SMAPP_BASE+507)

#define IDS_ADDED_PRIVILEGE                     (IDS_SMAPP_BASE+510)
#define IDS_ADDED_TO_LOCAL_GROUP                (IDS_SMAPP_BASE+511)
#define IDS_ADDED_PRIVILEGE_AND_TO_LOCAL_GROUP  (IDS_SMAPP_BASE+512)

#define IDS_CANNOT_ADJUST_PRIVILEGE             (IDS_SMAPP_BASE+520)
#define IDS_CANNOT_CONFIGURE_SERVICE            (IDS_SMAPP_BASE+521)

#define IDS_RESYNC_DONE             (IDS_SMAPP_BASE+525)
#define IDS_RESYNC_ENTIRE_DONE      (IDS_SMAPP_BASE+526)

#define IDS_SRVPROP_PARAM_UNKNOWN   (IDS_SMAPP_BASE+530)
#define IDS_SESSIONS_PARAM_UNKNOWN  (IDS_SMAPP_BASE+531)

#define IDS_CANNOT_ADMIN_WIN95      (IDS_SMAPP_BASE+540)

#define IDS_HWPROF_ENABLED          (IDS_SMAPP_BASE+550)
#define IDS_HWPROF_DISABLED         (IDS_SMAPP_BASE+551)
#define IDS_DEVICE_CAPTION          (IDS_SMAPP_BASE+552)

#define IDS_HWPROF_ENABLE_SERVICE_ERROR   (IDS_SMAPP_BASE+555)
#define IDS_HWPROF_DISABLE_SERVICE_ERROR  (IDS_SMAPP_BASE+556)
#define IDS_HWPROF_ENABLE_DEVICE_ERROR    (IDS_SMAPP_BASE+557)
#define IDS_HWPROF_DISABLE_DEVICE_ERROR   (IDS_SMAPP_BASE+558)

#define IDS_HWPROF_SERVICE_NOT_CONFIGURABLE (IDS_SMAPP_BASE+560)
#define IDS_HWPROF_DEVICE_NOT_CONFIGURABLE  (IDS_SMAPP_BASE+561)

//
// Replacement error codes for CFGMGR32 errors (19600 + CFGMGR32 error)
// This table occupies the entire SRVMGR namespace from
// IDS_CFGMGR32_BASE to IDS_UI_SRVMGR_LAST.
//

#define IDS_CFGMGR32_BASE                    (IDS_SMAPP_BASE+600)



//
//  Button-Bar Bitmap IDs
//

#define IDBM_USERS                  501
#define IDBM_FILES                  502
#define IDBM_OPENRES                503
#define IDBM_REPL                   505
#define IDBM_ALERTS                 506
#define IDBM_REPL_DISABLED          507


//
//  ListBox Bitmap IDs
//

#define IDBM_LB_USER                610
#define IDBM_LB_SHARE               611
#define IDBM_LB_FILE                612
#define IDBM_LB_COMM                613
#define IDBM_LB_PIPE                614
#define IDBM_LB_PRINT               615
#define IDBM_LB_UNKNOWN             616
#define IDBM_LB_IPC                 617

#define IDBM_LB_SVC_DISABLED        620
#define IDBM_LB_SVC_STARTED         621
#define IDBM_LB_SVC_STOPPED         622
#define IDBM_LB_SVC_PAUSED          623


//
//  Service Dialog Template IDs
//

#define IDSVC_SERVER_NAME           900
#define IDSVC_STOPPED               901
#define IDSVC_RUNNING               902


//
//  Server Properties.
//

#define IDD_SERVER_PROPERTIES       100

#define IDSP_ICON                   2101
#define IDSP_COMMENT                2102

#define IDSP_SESSIONS               2120
#define IDSP_PRINTJOBS              2121
#define IDSP_NAMEDPIPES             2123
#define IDSP_OPENFILES              2126
#define IDSP_FILELOCKS              2127
#define IDSP_REFRESH                2128

#define IDSP_SHARE_RESOURCES        2200
#define IDSP_ALLOW_NEW_SESSIONS     2201

#define IDSP_BUTTON_LIST            2300

#define IDSP_USERS_BUTTON           2901
#define IDSP_FILES_BUTTON           2902
#define IDSP_OPENRES_BUTTON         2903
#define IDSP_REPL_BUTTON            2905
#define IDSP_ALERTS_BUTTON          2906


//
//  Common Sub-Property IDs.
//

#define IDCS_SHARES_LIST            3500
#define IDCS_CONNECTIONS_LIST       3501
#define IDCS_FILES_LIST             3502

#define IDCS_OPENS_BUTTON           3700
#define IDCS_DISCONNECT_BUTTON      3701
#define IDCS_CLOSE_BUTTON           3702


//
//  Specific Sub-Property IDs.
//

#define IDD_SHARED_FILES            101
#define IDSF_OPENFILES              5001
#define IDSF_FILELOCKS              5002
#define IDSF_SHARESLIST             5003        // NOTE:  IDSF_SHARESLIST,
#define IDSF_SHARENAME              5004        // IDSF_SHARENAME, IDSF_USES,
#define IDSF_USES                   5005        // and IDSF_PATH must use
#define IDSF_PATH                   5006        // sequential ID numbers.
#define IDSF_DISCONNECT             5011
#define IDSF_DISCONNECTALL          5012
#define IDSF_USERS                  5013
#define IDSF_USERLIST               5020        // NOTE:  IDSF_USERLIST,
#define IDSF_CONNUSER               5021        // IDSF_CONNUSER, IDSF_TIME,
#define IDSF_TIME                   5022        // and IDSF_INUSE must use
#define IDSF_INUSE                  5023        // sequential ID numbers.

#define IDD_OPEN_RESOURCES          102
#define IDOR_OPENFILES              5101
#define IDOR_FILELOCKS              5102
#define IDOR_CLOSE                  5103
#define IDOR_CLOSEALL               5104
#define IDOR_OPENLIST               5105        // NOTE:  IDOR_OPENLIST,
#define IDOR_OPENEDBY               5106        // IDOR_OPENEDBY,
#define IDOR_OPENMODE               5107        // IDOR_OPENMODE, IDOR_LOCKS
#define IDOR_LOCKS                  5108        // and IDOR_PATH must use
#define IDOR_PATH                   5109        // sequential ID numbers.
#define IDOR_REFRESH                5110

#define IDD_SVCCNTL_DIALOG          103
#define IDSC_SERVICES               5301        // NOTE:  IDSC_SERVICES,
#define IDSC_SERVICE_LABEL          5302        // IDSC_SERVICE_LABEL, and
#define IDSC_STATUS_LABEL           5303        // IDSC_STATUS_LABEL, and
#define IDSC_STARTUP_LABEL          5304        // IDSC_STARTUP_LABEL are seq!
#define IDSC_PARAMETERS             5305
#define IDSC_START                  5310
#define IDSC_STOP                   5311
#define IDSC_PAUSE                  5312
#define IDSC_CONTINUE               5313
#define IDSC_CONFIGURE              5314
#define IDSC_HWPROFILE              5315

#define IDD_SVCCFG_DIALOG           104
#define IDSC_START_AUTO             5401        // IDSC_START_AUTO,
#define IDSC_START_DEMAND           5402        // _DEMAND, and _DISABLED
#define IDSC_START_DISABLED         5403        // must have sequential IDs!
#define IDSC_SYSTEM_ACCOUNT         5404
#define IDSC_THIS_ACCOUNT           5405
#define IDSC_ACCOUNT_NAME           5406
#define IDSC_USER_BROWSER           5407
#define IDSC_PASSWORD               5408
#define IDSC_CONFIRM_PASSWORD       5409
#define IDSC_PASSWORD_LABEL         5410
#define IDSC_CONFIRM_LABEL          5411
#define IDSC_SERVICE_NAME           5412
#define IDSC_SERVICE_INTERACTIVE    5413

#define IDD_DEVCNTL_DIALOG          125
#define IDDC_DEVICES                5501        // NOTE:  IDDC_DEVICES,
#define IDDC_DEVICE_LABEL           5502        // IDDC_DEVICE_LABEL,
#define IDDC_STATUS_LABEL           5503        // IDDC_STATUS_LABEL, and
#define IDDC_STARTUP_LABEL          5504        // IDDC_STARTUP_LABEL are seq!
#define IDDC_START                  5505
#define IDDC_STOP                   5506
#define IDDC_CONFIGURE              5507
#define IDDC_HWPROFILE              5508

#define IDD_DEVCFG_DIALOG           126
#define IDDC_START_BOOT             5601        // IDDC_START_BOOT,
#define IDDC_START_SYSTEM           5602        // _SYSTEM, _AUTO,
#define IDDC_START_AUTO             5603        // _DEMAND, and _DISABLED
#define IDDC_START_DEMAND           5604        // must have
#define IDDC_START_DISABLED         5605        // sequential IDs!
#define IDDC_DEVICE_NAME            5606

// both the Service and Device varieties
#define IDD_HWPROFILE_DIALOG        127
#define IDHW_PROFILES               5710        // NOTE:  IDHW_PROFILES,
#define IDHW_STATUS_LABEL           5711        // IDHW_STATUS_LABEL, and
#define IDHW_PROFILE_LABEL          5712        // IDHW_PROFILE_LABEL and
#define IDHW_DEVINST_LABEL          5713        // IDHW_DEVINST_LABEL are seq!
#define IDHW_ENABLE                 5720
#define IDHW_DISABLE                5721
#define IDHW_SVC_OR_DEV             5722
#define IDHW_SVC_OR_DEV_NAME        5723
#define IDHW_DESCRIPTION_LABEL      5724
#define IDHW_DESCRIPTION            5725


//
//  Password dialog.
//

#define IDD_PASSWORD_DIALOG         105

#define IDPW_SERVER                 6001
#define IDPW_SRVPASSWORD            6002


//
//  Service control in progress dialog.
//
#define IDD_SERVICE_CTRL_DIALOG     106
#define IDSCD_PROGRESS              6201
#define IDSCD_MESSAGE               6202

//
//  Stop dependent services confirmation dialog
//
#define IDD_SVC_DEP_DIALOG          107
#define IDSDD_DEP_SERVICES          6251
#define IDSDD_PARENT_SERVICE        6252


//
//  Dialog showing current sessions
//
#define IDD_CURRENT_SESS_DIALOG     108
#define IDCU_SESSIONSLISTBOX        6301
#define IDCU_SERVERNAME             6302


//
//  Send Message dialog.
//
#define IDD_SEND_MSG_DIALOG         109
#define IDSD_USERNAME               6401
#define IDSD_MSGTEXT                6402


//
//  Server Promotion dialog.
//
#define IDD_PROMOTE_DIALOG          110
#define IDPD_MESSAGE1               7001
#define IDPD_MESSAGE2               7002
#define IDPD_MESSAGE3               7003
#define IDPD_PROGRESS               7004


//
//  Server Resync dialog.
//
#define IDD_RESYNC_DIALOG           111
#define IDRD_MESSAGE1               7101
#define IDRD_MESSAGE2               7102
#define IDRD_MESSAGE3               7103
#define IDRD_PROGRESS               7104

//
//  Replicator main admin dialog.
//
#define IDD_REPL_MAIN                   112
#define IDRM_CLOSE                      8001
#define IDRM_EXPORT_GROUP               8010
#define IDRM_EXPORT_NO                  8011
#define IDRM_EXPORT_YES                 8012
#define IDRM_EXPORT_MANAGE              8013
#define IDRM_EXPORT_PATH                8014
#define IDRM_EXPORT_LIST                8015
#define IDRM_EXPORT_ADD                 8016
#define IDRM_EXPORT_REMOVE              8017
#define IDRM_EXPORT_PATH_LABEL          8018
#define IDRM_EXPORT_LIST_LABEL          8019
#define IDRM_IMPORT_GROUP               8020
#define IDRM_IMPORT_NO                  8021
#define IDRM_IMPORT_YES                 8022
#define IDRM_IMPORT_MANAGE              8023
#define IDRM_IMPORT_PATH                8024
#define IDRM_IMPORT_LIST                8025
#define IDRM_IMPORT_ADD                 8026
#define IDRM_IMPORT_REMOVE              8027
#define IDRM_IMPORT_PATH_LABEL          8028
#define IDRM_IMPORT_LIST_LABEL          8029
#define IDRM_EDIT_LOGON_SCRIPT_OR_SYSVOL 8030
#define IDRM_STATIC_LOGON_SCRIPT        8031
#define IDRM_STATIC_SYSVOL              8032

#define IDD_MINI_REPL_MAIN              113


//
//  Replicator add subdirectory dialog.
//
#define IDD_REPL_ADD                    114
#define IDRA_PATH                       8101
#define IDRA_SUBDIR                     8102


//
//  Replicator export/import manage dialogs.  Items starting with IDIE_
//  are common to both the export & import management dialogs.  Items
//  starting with IDEM_ are private to the export management dialog.
//  Items starting with IDIM_ are private to the import management dialog.
//
//  The IDIE_LABELx constants are used for the static text controls that
//  contain the listbox column labels.  The constants are used as follows:
//
//      constant        export          import
//      --------        ------          ------
//      IDIE_LABEL0     dirname         dirname
//      IDIE_LABEL1     lock            lock
//      IDIE_LABEL2     stabilize       status
//      IDIE_LABEL3     subtree         date/time
//      IDIE_LABEL4     date/time       (unused)
//
//  Yes, this is somewhat confusing, but allows us to use common code
//  for the column width generation while preventing ID collision (the
//  dialog editor gets real upset at ID collisions).  Anyway, it's
//  not too bad.  None of the label constants are ever used in the
//  exeutable code, just in the dialog templates.
//

#define IDD_EXPORT_MANAGE               115
#define IDD_IMPORT_MANAGE               116
#define IDIE_PATH                       8210
#define IDIE_SUBDIR                     8211
#define IDIE_ADDLOCK                    8212
#define IDIE_REMOVELOCK                 8215
#define IDIE_ADDDIR                     8213
#define IDIE_REMOVEDIR                  8214

#define IDIE_DIRLIST                    8220    // <** The following six items
#define IDIE_LABEL0                     8221    // <** *must* have contiguous
#define IDIE_LABEL1                     8222    // <** control IDs!!
#define IDIE_LABEL2                     8223    // <**
#define IDIE_LABEL3                     8224    // <**
#define IDIE_LABEL4                     8225    // <**

#define IDEM_STABILIZE                  8226
#define IDEM_SUBTREE                    8227


//
//  Add Computer To Domain dialog.
//
#define IDD_ADD_COMPUTER            117
#define IDAC_WORKSTATION            7201
#define IDAC_SERVER                 7202
#define IDAC_COMPUTERNAME           7203
#define IDAC_PASSWORD               7204
#define IDAC_CONFIRMPASSWORD        7205

//
// NT Alerts dialog manifests
//
#define IDD_ALERTS_DIALOG           118
#define IDC_ALERTS_BUTTON_ADD       8302
#define IDC_ALERTS_BUTTON_REMOVE    8303
#define IDC_ALERTS_SLE_INPUT        8304
#define IDC_ALERTS_LISTBOX          8305

#define IDS_SERVICE_DB_LOCKED_ON_WRITE  8310
#define IDS_SERVICE_DB_LOCKED_ON_READ   8311

//
// help context
//
#include <srvhelp.h>


#endif  // _SRVMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\alertdlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    alertdlg.cxx

    This file contains the implementation for the NT Alerts dialog



    FILE HISTORY:
        JohnL   13-Apr-1992     Created
        KeithMo 09-Jun-1992     Gracefully handle missing AlertNames
                                value.  Also fixed COMPUTER_ALERTS_NODE.
*/

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <dbgstr.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>
#include <string.hxx>
#include <strlst.hxx>
#include <groups.hxx>
#include <lmosrv.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <lmocnfg.hxx>

#include <srvbase.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <winsvc.h>
    #include <confname.h>
    #include <mnet.h>
    #include <icanon.h>
}

#include <alertdlg.hxx>

/* Registry node where the list of computers resides and the value name the
 * list is contained in.
 *
 */
#define COMPUTER_ALERTS_NODE         SZ("System\\CurrentControlSet\\Services\\Alerter\\Parameters")
#define COMPUTER_ALERTS_VALUE_NAME   SZ("AlertNames")

/* This is the character that separaters computer names in the list in the
 * registry
 */
#define COMP_NAME_DELIM TCH(' ')

/* The name of the Service Control Database to open
 */
#ifdef UNICODE
    #define SC_ACTIVE_SERVICES_DB_NAME SERVICES_ACTIVE_DATABASEW
#else
    #define SC_ACTIVE_SERVICES_DB_NAME SERVICES_ACTIVE_DATABASEA
#endif

//
//  Delimiters for the AlertNames list in downlevel LANMAN.INI file.
//

#define ALERTNAMES_DELIMITER_SZ SZ(",")
#define ALERTNAMES_DELIMITER_CH TCH(',')


//
//  Change this value to non-zero to enable the old-style service
//  database locking that was causing problems for Server Operators.
//

#define USE_SERVICE_DATABASE_LOCK       0


/*******************************************************************

    NAME:       ALERTS_DIALOG::ALERTS_DIALOG

    SYNOPSIS:   Typical constructor/destructor.

    ENTRY:      hDlg - Window handle of our parent window
                pszServerName - Name of the server to set the alerts on

    NOTES:

    HISTORY:
        Johnl   13-Apr-1992     Created

********************************************************************/

ALERTS_DIALOG::ALERTS_DIALOG( HWND hDlg, SERVER_2 * pServer2 )
    : DIALOG_WINDOW   ( MAKEINTRESOURCE( IDD_ALERTS_DIALOG ), hDlg ),
      _lbComputerNames( this, IDC_ALERTS_LISTBOX ),
      _sleInput       ( this, IDC_ALERTS_SLE_INPUT, LM20_UNLEN ),
      _pbAdd          ( this, IDC_ALERTS_BUTTON_ADD ),
      _pbRemove       ( this, IDC_ALERTS_BUTTON_REMOVE ),
      _pbOK           ( this, IDOK ),
      _StrLBGroup     ( this, &_sleInput, &_lbComputerNames,
                              &_pbAdd,    &_pbRemove ),
      _pServer2       ( pServer2 ),
      _hscServices    ( NULL ),
      _hlockServices  ( NULL )
{
    //
    //  This may take a while...
    //

    AUTO_CURSOR NiftyCursor;

    if ( QueryError() )
        return ;

    APIERR err ;
    STRLIST strlistComputers ;
    if ( (err = _StrLBGroup.QueryError() ) ||
         (err = SRV_BASE_DIALOG::SetCaption( this,
                                             IDS_CAPTION_ALERTS,
                                             pServer2->QueryName() )) ||
         (err = GetComputerList( &strlistComputers,
                                 _pServer2->QueryName() )) ||
         (err = _StrLBGroup.Init( &strlistComputers ))  )
    {
        ReportError( err ) ;
        return ;
    }
}



/*******************************************************************

    NAME:       ALERTS_DIALOG::~ALERTS_DIALOG

    SYNOPSIS:   Attempts to set the computer list in the registry and
                dismisses the dialog if successful.

    NOTES:

    HISTORY:
        DavidHov    20-Oct-1992     Remove call to obsolete
                                    REG_KEY::DestroyAccessPoints()
********************************************************************/
ALERTS_DIALOG::~ALERTS_DIALOG()
{
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::OnOK

    SYNOPSIS:   Attempts to set the computer list in the registry and
                dismisses the dialog if successful.

    NOTES:

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

BOOL ALERTS_DIALOG::OnOK( void )
{
    APIERR err ;
    if ( (err = SetComputerList( _StrLBGroup.QueryStrLB(),
                                 _pServer2->QueryName()) ))
    {
        if( ( err == ERROR_NOT_SUPPORTED) &&
            ( ( _pServer2->QueryServerType() & SV_TYPE_NT ) == 0 ) )
        {
            //
            //  Some downlevel servers don't accept the NetConfigSet API.
            //

            ::MsgPopup( this, IDS_CANNOT_UPDATE_ALERTS );
        }
        else
        if( err == ERROR_LOCK_FAILED )
        {
            //
            //  SetComputerListInRegistry will automatically
            //  display the error if the lock failed.
            //
        }
        else
        {
            ::MsgPopup( this, (MSGID)err );
        }
    }
    else
    {
        Dismiss( TRUE ) ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::GetComputerList

    SYNOPSIS:   Retrieves the list of computers & users that should
                receive alerts.

    ENTRY:      pstrlistComputers       - Will receive the list.

                pszFocusServer          - Name of the target server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 03-Aug-1992     Created.

********************************************************************/
APIERR ALERTS_DIALOG::GetComputerList( STRLIST     * pstrlistComputers,
                                       const TCHAR * pszFocusServer )
{
    UIASSERT( pstrlistComputers != NULL );

    //
    //  If our target server is NT, we get the list from the
    //  registry.  Otherwise, we get the list from LANMAN.INI.
    //

    if( _pServer2->QueryServerType() & SV_TYPE_NT )
    {
        return GetComputerListFromRegistry( pstrlistComputers,
                                            pszFocusServer );
    }
    else
    {
        return GetComputerListFromLanmanIni( pstrlistComputers,
                                             pszFocusServer );
    }

}   // ALERTS_DIALOG::GetComputerList

/*******************************************************************

    NAME:       ALERTS_DIALOG::SetComputerList

    SYNOPSIS:   Sets the list of computers & users that should
                receive alerts.

    ENTRY:      plbComputerNames        - Pointer to string listbox that
                                          contains the list of computer &
                                          user names to set.

                pszFocusServer          - Name of the target server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 03-Aug-1992     Created.

********************************************************************/
APIERR ALERTS_DIALOG::SetComputerList( STRING_LISTBOX * plbComputerNames,
                                       const TCHAR    * pszFocusServer )
{
    UIASSERT( plbComputerNames != NULL );

    //
    //  If our target server is NT, we set the list in the
    //  registry.  Otherwise, we set the list in LANMAN.INI.
    //

    if( _pServer2->QueryServerType() & SV_TYPE_NT )
    {
        return SetComputerListInRegistry( plbComputerNames,
                                          pszFocusServer );
    }
    else
    {
        return SetComputerListInLanmanIni( plbComputerNames,
                                           pszFocusServer );
    }

}   // ALERTS_DIALOG::SetComputerList

/*******************************************************************

    NAME:       ALERTS_DIALOG::GetComputerListFromRegistry

    SYNOPSIS:   Retrieves the list of computers that should receive alerts
                from the registry

    ENTRY:      pstrlistComputers - STRLIST to receive the list
                pszFocusServer - Name of the server to enumerate the
                    computers from (can be NULL for local).

    EXIT:       pstrlistComputers will contain the list of computers
                    enumerated from the registry.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the services database cannot be locked, then
                ERROR_LOCK_FAILED will be returned, however this
                method will already have warned the user, thus there
                is no need to display the error again.

    HISTORY:
        Johnl   13-Apr-1992     Implemented
        KeithMo 09-Jun-1992     If the AlertsName value is not in the
                                registry, use an empty list by default.
        KeithMo 31-Aug-1992     AlertNames value changed from REG_SZ to
                                REG_MULTI_SZ.
        DavidHov 20-Oct-1992    Remove call to obsolete
                                REG_KEY::DestroyAccessPoints()

********************************************************************/

APIERR ALERTS_DIALOG::GetComputerListFromRegistry(
                                          STRLIST     * pstrlistComputers,
                                          const TCHAR * pszFocusServer )
{
    APIERR err = NERR_Success ;
    REG_KEY *pRegKeyFocusServer = NULL;     // Delete my memory if not
                                            // local machine key
    BOOL     fIsServicesDBOpened = FALSE ;

    do { // error breakout

        /* Attempt to lock the services database where the computer alert
         * names are stored
         */
        BOOL fServicesDBIsLocked ;
        if ( err = LockServiceDatabase( pszFocusServer,
                                         &fServicesDBIsLocked ))
        {
            break ;
        }

        if ( fServicesDBIsLocked )
        {
            DisplayDBLockMessage( IDS_SERVICE_DB_LOCKED_ON_READ ) ;
            err = ERROR_LOCK_FAILED ;
            break ;
        }
        fIsServicesDBOpened = TRUE ;

        /* Traverse the registry and get the list of computer alert
         * names.
         */
        if ( pszFocusServer == NULL )
            pRegKeyFocusServer = REG_KEY::QueryLocalMachine();
        else
            pRegKeyFocusServer = new REG_KEY( HKEY_LOCAL_MACHINE,
                                              (TCHAR *) pszFocusServer );

        if (  ( pRegKeyFocusServer == NULL ) ||
              ((err = pRegKeyFocusServer->QueryError())) )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        ALIAS_STR nlsRegKeyName( COMPUTER_ALERTS_NODE ) ;
        REG_KEY regkeyComputerAlertsNode( *pRegKeyFocusServer, nlsRegKeyName );
        REG_KEY_INFO_STRUCT regKeyInfo;
        REG_VALUE_INFO_STRUCT regValueInfo ;

        if (  (err = regkeyComputerAlertsNode.QueryError())             ||
              (err = regkeyComputerAlertsNode.QueryInfo( &regKeyInfo ))   )
        {
            DBGEOL("ALERTS_DIALOG::GetComputerListFromRegistry - Error " <<
                   (ULONG) err << " Calling REG_KEY::QueryInfo") ;
            break ;
        }

        BUFFER buf( (UINT) regKeyInfo.ulMaxValueLen ) ;

        regValueInfo.nlsValueName = COMPUTER_ALERTS_VALUE_NAME ;
        if ( (err = buf.QueryError() ) ||
             (err = regValueInfo.nlsValueName.QueryError()) )
        {
            break;
        }

        DBGEOL("ALERTS_DIALOG::GetComputerListFromRegistry - Value info buffer size = " <<
                buf.QuerySize() << " Max value size = " << regKeyInfo.ulMaxValueLen ) ;
        regValueInfo.pwcData = buf.QueryPtr();
        regValueInfo.ulDataLength = buf.QuerySize() ;

        if ( (err = regkeyComputerAlertsNode.QueryValue( &regValueInfo )))
        {
            //
            //  The REG_KEY will return ERROR_FILE_NOT_FOUND if
            //  the value is not in the registry.  This is OK,
            //  we'll just use an empty AlertsName list.
            //

            if( err == ERROR_FILE_NOT_FOUND )
            {
                DBGEOL( "ALERTS_DIALOG::GetComputerListFromRegistry - " <<
                        "Alerter\\Parameters\\AlertNames value not found." );
                DBGEOL( "Assuming empty AlertNames list." );

                err = NO_ERROR;
                break;
            }
            else
            {
                DBGEOL("ALERTS_DIALOG::GetComputerListFromRegistry - Error " <<
                       (ULONG) err << " Calling QueryValue ") ;
                break;
            }
        }

        /* Here we have the code to dissect the computer name list
         * depending on what format it is in.
         *
         * Currently the string will be stored as
         *      "Computer1\0Computer2\0Computer3\0\0".
         */
        const TCHAR * pszAlertTarget = (const TCHAR *)buf.QueryPtr();

        while( ( err == NERR_Success ) && ( *pszAlertTarget != TCH('\0') ) )
        {
            //
            //  Create a new NLS_STR for the current target.
            //

            NLS_STR * pnls = new NLS_STR( pszAlertTarget );

            err = ( pnls == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : pnls->QueryError();

            if( err != NERR_Success )
            {
                break;
            }

            //
            //  Since our lovely set control uses a STRING_LISTBOX,
            //  and STRING_LISTBOX uses the standard case-sensitive
            //  sorting order, upcase the name to make everything
            //  look pretty.
            //

            pnls->_strupr();

            //
            //  Add the current target to the list.
            //

            err = pstrlistComputers->Add( pnls );

            if( err != NERR_Success )
            {
                break;
            }

            //
            //  Adjust the target pointer.
            //

            pszAlertTarget += ::strlenf( pszAlertTarget ) + 1;
        }

    } while ( FALSE ) ;

    delete pRegKeyFocusServer ;
    pRegKeyFocusServer = NULL ;

    if ( fIsServicesDBOpened )
    {
        /* Ignore the return code, there isn't much we can do
         */
        (VOID) UnlockServiceDatabase() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::SetComputerListInRegistry

    SYNOPSIS:   Sets the list of computers that will receive alerts in the
                Alert service node of the registry.

    ENTRY:      plbComputerNames - Pointer to string listbox that contains
                    the list of computer names to set
                pszFocusServer - Pointer to server of the registry we are
                    modifying

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the services database cannot be locked, then
                ERROR_LOCK_FAILED will be returned, however this
                method will already have warned the user, thus there
                is no need to display the error again.

    HISTORY:
        Johnl   15-Apr-1992     Created
        KeithMo 09-Jun-1992     If the AlertsName value is not in the
                                registry, create it.
        KeithMo 31-Aug-1992     AlertNames value changed from REG_SZ to
                                REG_MULTI_SZ.
        DavidHov 20-Oct-1992    Remove call to obsolete
                                REG_KEY::DestroyAccessPoints()

********************************************************************/

APIERR ALERTS_DIALOG::SetComputerListInRegistry(
                              STRING_LISTBOX * plbComputerNames,
                              const TCHAR    * pszFocusServer    )
{
    //
    //  First, calculate the required size of the REG_MULTI_SZ buffer.
    //

    INT cbBuffer = sizeof(TCHAR);       // For the terminating NULL.
    INT cItems = plbComputerNames->QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        INT cbItem = plbComputerNames->QueryItemSize( i );
        UIASSERT( cbItem > 0 );

        cbBuffer += cbItem;
    }

    //
    //  Create the buffer.
    //

    BUFFER buffer( (UINT)cbBuffer );

    APIERR err = buffer.QueryError();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Fill the buffer with the target names.  The format is:
    //
    //  Target1\0Target2\0Target3\0\0
    //

    TCHAR * pszNextTarget = (TCHAR *)buffer.QueryPtr();
    INT     cbRemaining   = cbBuffer;

    for( i = 0 ; i < cItems ; i++ )
    {
        INT cbItem = plbComputerNames->QueryItemSize( i );
        UIASSERT( cbItem > 0 );

        REQUIRE( plbComputerNames->QueryItemText( pszNextTarget,
                                                  cbRemaining,
                                                  i ) == NERR_Success );

        pszNextTarget += cbItem / sizeof(TCHAR);
        cbRemaining   -= cbItem;
        UIASSERT( cbRemaining >= sizeof(TCHAR) );
    }

    UIASSERT( cbRemaining == sizeof(TCHAR) );

    *pszNextTarget = TCH('\0');

    BOOL fIsServicesDBOpened = FALSE ;
    REG_KEY *pRegKeyFocusServer = NULL;     // Delete my memory!

    do { // error breakout

        /* Attempt to lock the services database where the computer alert
         * names are stored
         */
        BOOL fServicesDBIsLocked ;
        if ( err = LockServiceDatabase( pszFocusServer,
                                        &fServicesDBIsLocked ))
        {
            break ;
        }

        if ( fServicesDBIsLocked )
        {
            DisplayDBLockMessage( IDS_SERVICE_DB_LOCKED_ON_WRITE ) ;
            err = ERROR_LOCK_FAILED ;
            break ;
        }
        fIsServicesDBOpened = TRUE ;

        /* Traverse the registry in preparation for setting the list of
         * computer names.
         */
        if ( pszFocusServer == NULL )
            pRegKeyFocusServer = REG_KEY::QueryLocalMachine();
        else
            pRegKeyFocusServer = new REG_KEY( HKEY_LOCAL_MACHINE,
                                              (TCHAR *) pszFocusServer );

        if (  ( pRegKeyFocusServer == NULL ) ||
              ((err = pRegKeyFocusServer->QueryError())) )
        {
            err = err? err : ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        ALIAS_STR nlsRegKeyName( COMPUTER_ALERTS_NODE ) ;
        REG_KEY regkeyComputerAlertsNode( *pRegKeyFocusServer, nlsRegKeyName );
        REG_KEY_INFO_STRUCT regKeyInfo;
        REG_VALUE_INFO_STRUCT regValueInfo ;

        if (  (err = regkeyComputerAlertsNode.QueryError())             ||
              (err = regkeyComputerAlertsNode.QueryInfo( &regKeyInfo ))   )
        {
            DBGEOL("ALERTS_DIALOG::SetComputerListFromRegistry - Error " <<
                   (ULONG) err << " Calling REG_KEY::QueryInfo") ;
            break ;
        }

        /* Query the value then set the fields we want to change.  This
         * assumes the value already exists in the node
         */
        BUFFER buf( (UINT) regKeyInfo.ulMaxValueLen ) ;

        regValueInfo.nlsValueName = COMPUTER_ALERTS_VALUE_NAME ;
        if ( (err = buf.QueryError() ) ||
             (err = regValueInfo.nlsValueName.QueryError()) )
        {
            break;
        }

        DBGEOL("ALERTS_DIALOG::SetComputerListFromRegistry - Value info buffer size = " <<
                buf.QuerySize() << " Max value size = " << regKeyInfo.ulMaxValueLen ) ;
        regValueInfo.pwcData = buf.QueryPtr();
        regValueInfo.ulDataLength = buf.QuerySize() ;

        if ( (err = regkeyComputerAlertsNode.QueryValue( &regValueInfo )))
        {
            //
            //  REG_KEY will return ERROR_FILE_NOT_FOUND if the value
            //  was not in the registry.  We'll ignore this error, and
            //  the SetValue() method should create a new value.
            //

            if( err == ERROR_FILE_NOT_FOUND )
            {
                DBGEOL( "ALERTS_DIALOG::SetComputerListInRegistry - " <<
                        "Alerter\\Parameters\\AlertNames value not found." );
                DBGEOL( "Creating new value." );

                regValueInfo.ulTitle = 0L;
                regValueInfo.ulType  = REG_MULTI_SZ;

                err = NO_ERROR;
            }
            else
            {
                DBGEOL("ALERTS_DIALOG::SetComputerListFromRegistry - Error " <<
                       (ULONG) err << " Calling QueryValue ") ;
                break;
            }
        }

        regValueInfo.ulDataLength = buffer.QuerySize();
        regValueInfo.pwcData      = (BYTE *)buffer.QueryPtr();

        if ( (err = regkeyComputerAlertsNode.SetValue( &regValueInfo )))
        {
            DBGEOL("ALERTS_DIALOG::SetComputerListFromRegistry - Error " <<
                   (ULONG) err << " Calling SetValue ") ;
            break;
        }

    } while ( FALSE ) ;

    delete pRegKeyFocusServer ;
    pRegKeyFocusServer = NULL ;

    if ( fIsServicesDBOpened )
    {
        /* Ignore the return code, there isn't much we can do
         */
        (VOID) UnlockServiceDatabase() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::GetComputerListFromLanmanIni

    SYNOPSIS:   Retrieves the list of computers that should receive alerts
                from LANMAN.INI.

    ENTRY:      pstrlistComputers - STRLIST to receive the list

                pszFocusServer - Name of the server to enumerate the
                    computers from.

    EXIT:       pstrlistComputers will contain the list of computers
                    enumerated from the registry.

    RETURNS:    NERR_Success if successful, error code otherwise

    HISTORY:
        KeithMo 03-Aug-1992     Created.

********************************************************************/
APIERR ALERTS_DIALOG::GetComputerListFromLanmanIni(
                                          STRLIST     * pstrlistComputers,
                                          const TCHAR * pszFocusServer )
{
    LM_CONFIG lmconfig( pszFocusServer,
                        (const TCHAR *)SECT_LM20_SERVER,
                        (const TCHAR *)ALERTER_KEYWORD_ALERTNAMES );
    NLS_STR nlsAlertList;

    //
    //  Ensure everything constructed properly.
    //

    APIERR err = lmconfig.QueryError();

    if( err == NERR_Success )
    {
        err = nlsAlertList.QueryError();
    }

    //
    //  Read the alert list.
    //

    if( err == NERR_Success )
    {
        err = lmconfig.QueryValue( &nlsAlertList, SZ("") );
    }

    //
    //  Parse the string & add them to the list.
    //

    if( err == NERR_Success )
    {
        STRLIST strlist( nlsAlertList.QueryPch(),
                         ALERTNAMES_DELIMITER_SZ,
                         FALSE );
        ITER_STRLIST iter( strlist );
        NLS_STR * pnls;

        while( ( pnls = iter.Next() ) != NULL )
        {
            pnls->_strupr();

            err = pstrlistComputers->Add( pnls );

            if( err != NERR_Success )
            {
                break;
            }
        }
    }

    return err;

}   // ALERTS_DIALOG::GetComputerListFromLanmanIni

/*******************************************************************

    NAME:       ALERTS_DIALOG::SetComputerListInLanmanIni

    SYNOPSIS:   Sets the list of computers that will receive alerts in the
                Alerts section of LANMAN.INI.

    ENTRY:      plbComputerNames - Pointer to string listbox that contains
                    the list of computer names to set

                pszFocusServer - Pointer to server of the registry we are
                    modifying

    RETURNS:    NERR_Success if successful, error code otherwise

    HISTORY:
        KeithMo 03-Aug-1992     Created.

********************************************************************/

APIERR ALERTS_DIALOG::SetComputerListInLanmanIni(
                              STRING_LISTBOX * plbComputerNames,
                              const TCHAR    * pszFocusServer    )
{
    LM_CONFIG lmconfig( pszFocusServer,
                        (const TCHAR *)SECT_LM20_SERVER,
                        (const TCHAR *)ALERTER_KEYWORD_ALERTNAMES );
    NLS_STR nlsAlertList;
    NLS_STR nlsName;

    //
    //  Ensure everything constructed properly.
    //

    APIERR err = lmconfig.QueryError();

    if( err == NERR_Success )
    {
        err = nlsAlertList.QueryError();
    }

    if( err == NERR_Success )
    {
        err = nlsName.QueryError();
    }

    //
    //  Build the list.
    //

    if( err == NERR_Success )
    {
        INT cItems = plbComputerNames->QueryCount();

        for( INT i = 0 ; i < cItems ; i++ )
        {
            err = plbComputerNames->QueryItemText( &nlsName, i );

            if( err == NERR_Success )
            {
                err = nlsAlertList.Append( nlsName );
            }

            if( ( err == NERR_Success ) && ( i < ( cItems - 1 ) ) )
            {
                err = nlsAlertList.AppendChar( ALERTNAMES_DELIMITER_CH );
            }

            if( err != NERR_Success )
            {
                break;
            }
        }
    }

    //
    //  Update LANMAN.INI.
    //

    if( err == NERR_Success )
    {
        err = lmconfig.SetValue( &nlsAlertList );
    }

    return err;

}   // ALERTS_DIALOG::SetComputerListInLanmanIni

/*******************************************************************

    NAME:       ALERTS_DIALOG::LockServiceDatabase

    SYNOPSIS:   Opens and locks the service control database

    ENTRY:      pszFocusServer - Name of server (or NULL) to lock the services
                    database on for preparation in getting the alerts
                    computer list from
                pfIsLocked - Will be set to true if the database is already
                    locked

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If the lock is unsuccesful (error is returned or *pfIsLocked
                is set to TRUE) then this method will cleanup
                appropriately (no need to call UnlockServiceDatabase).

                The Service control and lock handle should be NULL coming
                in to this method.

    HISTORY:
        Johnl   15-Apr-1992     Created

********************************************************************/

APIERR ALERTS_DIALOG::LockServiceDatabase(
                              const TCHAR * pszFocusServer,
                              BOOL        * pfIsLocked )
{
#if USE_SERVICE_DATABASE_LOCK

    UIASSERT( _hscServices == NULL &&
              _hlockServices == NULL ) ;

    APIERR err = NERR_Success ;

    *pfIsLocked = FALSE ;
    if ( (_hscServices = ::OpenSCManager( (TCHAR *) pszFocusServer,
                                          (TCHAR *) SC_ACTIVE_SERVICES_DB_NAME,
                                       GENERIC_READ | GENERIC_EXECUTE ))==NULL)
    {
        err = ::GetLastError() ;
        DBGEOL("ALERTS_DIALOG::LockServicesDatabase - OpenSCManager failed with error " <<
                (ULONG) err ) ;
    }

    if ( !err &&
         (_hlockServices = ::LockServiceDatabase( _hscServices )) == NULL)
    {
        err = ::GetLastError() ;
        DBGEOL("ALERTS_DIALOG::LockServicesDatabase - LockServiceDatabase failed with error " <<
                (ULONG) err ) ;

        if ( err == ERROR_SERVICE_DATABASE_LOCKED )
        {
            DBGEOL("ALERTS_DIALOG::LockServicesDatabase - Database is locked") ;
            *pfIsLocked = TRUE ;
        }

        if ( !::CloseServiceHandle( _hscServices ))
        {
            DBGEOL("ALERTS_DIALOG::LockServicesDatabase - Close failed with error " <<
                   (ULONG) ::GetLastError() ) ;
        }

        _hscServices = NULL ;
        return err ;
    }
    return err ;

#else   // !USE_SERVICE_DATABASE_LOCK

    UNREFERENCED(pszFocusServer);
    *pfIsLocked = FALSE;

    return NERR_Success;

#endif  // USE_SERVICE_DATABASE_LOCK
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::UnlockServiceDatabase

    SYNOPSIS:   Unlocks and closes the Services database.  This method should
                be called after any *successful* LockServiceDatabase call.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      We assume the data members _hscServices and _hlockServices
                have been properly set by calling LockServiceDatabase

    HISTORY:
        Johnl   15-Apr-1992     Created

********************************************************************/

APIERR ALERTS_DIALOG::UnlockServiceDatabase( void )
{
#if USE_SERVICE_DATABASE_LOCK

    UIASSERT( _hscServices != NULL &&
              _hlockServices != NULL ) ;

    APIERR err = NERR_Success ;

    if ( !::UnlockServiceDatabase( _hlockServices ))
    {
        err = ::GetLastError() ;
        DBGEOL("ALERTS_DIALOG::UnlockServicesDatabase - UnlockServiceDatabase failed with error " <<
                (ULONG) err ) ;

    }
    _hlockServices = NULL ;

    /* Note that regardless of whether the lock was succesful, we will always
     * try and close the database
     */
    if ( !::CloseServiceHandle( _hscServices ))
    {
        DBGEOL("ALERTS_DIALOG::UnlockServicesDatabase - Close failed with error " <<
               (ULONG) ::GetLastError() ) ;
    }
    _hscServices = NULL ;
    return err ;

#else   // !USE_SERVICE_DATABASE_LOCK

    return NERR_Success;

#endif  // USE_SERVICE_DATABASE_LOCK
}


/*******************************************************************

    NAME:       ALERTS_DIALOG::DisplayDBLockMessage

    SYNOPSIS:   Displays a message to the user indicating the services DB
                is locked, by whom it is locked and for how long it has
                been locked.

    ENTRY:      msgidDBLockedMessage - MSGID of the message to display.
                    Should contain to insert params:
                        %1 Should be the duration (shown in D hh:mm:ss)
                        %2 Should be the offending username

    NOTES:      This method will display any errors that occur within
                this method.

    HISTORY:
        Johnl   14-Apr-1992     Created

********************************************************************/

VOID ALERTS_DIALOG::DisplayDBLockMessage( MSGID msgidDBLockedMessage )
{
#if USE_SERVICE_DATABASE_LOCK

    APIERR err ;
    QUERY_SERVICE_LOCK_STATUS *pLockStatus ;
    INTL_PROFILE              intlprof ;
    NLS_STR                   nlsDuration( 30 ) ;
    BUFFER                    buffLockStatus( sizeof(QUERY_SERVICE_LOCK_STATUS)
                                              + 255 ) ;

    if ( ( err = intlprof.QueryError() )      ||
         ( err = nlsDuration.QueryError() )   ||
         ( err = buffLockStatus.QueryError())   )
    {
        MsgPopup( this, (MSGID) err ) ;
        return ;
    }

    /* Loop till we get a buffer size that works
     */
    do {
        DWORD cbNeeded ;
        if ( ::QueryServiceLockStatus( _hscServices,
                                       (QUERY_SERVICE_LOCK_STATUS*)
                                              buffLockStatus.QueryPtr(),
                                       buffLockStatus.QuerySize(),
                                       &cbNeeded))
        {
            if ( (err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
            {
                if ( err = buffLockStatus.Resize( cbNeeded ))
                {
                    break ;
                }
            }
        }
    } while ( err == ERROR_INSUFFICIENT_BUFFER ) ;

    if ( err )
    {
        MsgPopup( this, (MSGID) err ) ;
        return ;
    }

    pLockStatus = (QUERY_SERVICE_LOCK_STATUS*) buffLockStatus.QueryPtr() ;

    INT cDays = (INT) pLockStatus->dwLockDuration/60/60/24 ;
    pLockStatus->dwLockDuration -= cDays * 60*60*24 ;

    INT cHour = (INT) pLockStatus->dwLockDuration/60/60 ;
    pLockStatus->dwLockDuration -= cHour * 60*60 ;

    INT cMin = (INT) pLockStatus->dwLockDuration/60 ;
    pLockStatus->dwLockDuration -= cMin * 60 ;

    INT cSec = (INT) pLockStatus->dwLockDuration ;

    if ( err = intlprof.QueryDurationStr( cDays, cHour, cMin, cSec,
                                          &nlsDuration ))
    {
        MsgPopup( this, (MSGID) err ) ;
        return ;
    }

    MsgPopup( this,
              msgidDBLockedMessage,
              MPSEV_ERROR,
              MP_OK,
              nlsDuration,
              pLockStatus->lpLockOwner ) ;

#else   // !USE_SERVICE_DATABASE_LOCK

    //
    //  Since we're not using the service database lock, this
    //  routine should NEVER get called to display a "database
    //  locked" message.
    //

    UNREFERENCED(msgidDBLockedMessage);
    UIASSERT( FALSE );
    return;

#endif  // USE_SERVICE_DATABASE_LOCK
}

/*******************************************************************

    NAME:       ALERTS_DIALOG::QueryHelpContext

    SYNOPSIS:   Typical query help context

    HISTORY:
        Johnl   11-Apr-1992     Created

********************************************************************/

ULONG ALERTS_DIALOG::QueryHelpContext( void )
{
    return HC_NT_ALERTS_DLG ;
}


/*******************************************************************

    NAME:           ALERTS_DIALOG :: OnCommand

    SYNOPSIS:       Handle user commands.

    ENTRY:          cid                 - Control ID.
                    lParam              - lParam from the message.

    RETURNS:        BOOL                - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     18-Jan-1993 Created.

********************************************************************/
BOOL ALERTS_DIALOG::OnCommand( const CONTROL_EVENT & event )
{
    BOOL fResult = DIALOG_WINDOW::OnCommand( event );

    if( event.QueryCid() == IDC_ALERTS_BUTTON_REMOVE )
    {
        MakeOKButtonDefault();
    }

    return fResult;

}   // ALERTS_DIALOG :: OnCommand


//
//  ALERTS_STRLB_GROUP methods.
//

/*******************************************************************

    NAME:       ALERTS_STRLB_GROUP::ALERTS_STRLB_GROUP

    SYNOPSIS:   ALERTS_STRLB_GROUP class constructor.

    NOTES:      See SLE_STRLB_GROUP for details.

    HISTORY:
        KeithMo 12-Nov-1992     Created.

********************************************************************/
ALERTS_STRLB_GROUP::ALERTS_STRLB_GROUP( OWNER_WINDOW   * powin,
                                        SLE            * psleInput,
                                        STRING_LISTBOX * pStrLB,
                                        PUSH_BUTTON    * pbuttonAdd,
                                        PUSH_BUTTON    * pbuttonRemove )
  : SLE_STRLB_GROUP( powin,
                     psleInput,
                     pStrLB,
                     pbuttonAdd,
                     pbuttonRemove ),
    _powin( powin )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // ALERTS_STRLB_GROUP::ALERTS_STRLB_GROUP


/*******************************************************************

    NAME:       ALERTS_STRLB_GROUP::~ALERTS_STRLB_GROUP

    SYNOPSIS:   ALERTS_STRLB_GROUP class destructor.

    NOTES:      See SLE_STRLB_GROUP for details.

    HISTORY:
        KeithMo 12-Nov-1992     Created.

********************************************************************/
ALERTS_STRLB_GROUP::~ALERTS_STRLB_GROUP( VOID )
{
    _powin = NULL;

}   // ALERTS_STRLB_GROUP::~ALERTS_STRLB_GROUP


/*******************************************************************

    NAME:       ALERTS_STRLB_GROUP::W_Add

    SYNOPSIS:   Add a string to the listbox.

    ENTRY:      psz                     - The string to add.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      If the user is trying to add an invalid user/computer
                name, we'll display an appropriate error.

    HISTORY:
        KeithMo 12-Nov-1992     Created.

********************************************************************/
APIERR ALERTS_STRLB_GROUP::W_Add( const TCHAR * psz )
{
    //
    //  If the weenie user entered the (unwanted) leading
    //  backslashes, skip over them.
    //

    ALIAS_STR nls( psz );
    ISTR istr( nls );

    if( ::strncmpf( psz, SZ("\\\\"), 2 ) == 0 )
    {
        istr += 2;
    }

    psz = nls.QueryPch( istr );

    //
    //  If the name is either a valid user name or a valid computer
    //  name, then let SLE_STRLB_GROUP add the name to the listbox.
    //

    if( !I_MNetNameValidate( NULL, psz, NAMETYPE_USER,     0L ) ||
        !I_MNetNameValidate( NULL, psz, NAMETYPE_COMPUTER, 0L ) )
    {
        APIERR err = SLE_STRLB_GROUP::W_Add( psz );

        if( err == NERR_Success )
        {
            SetDefaultButton();
        }

        return err;
    }

    //
    //  The user entered an invalid name.  Display a message,
    //  then set the focus to the input SLE.
    //

    ::MsgPopup( _powin,
                IDS_ALERT_TARGET_INVALID );

    QueryInputSLE()->ClaimFocus();

    return NERR_Success;

}   // ALERTS_STRLB_GROUP::W_Add


/*******************************************************************

    NAME:       ALERTS_STRLB_GROUP::OnUserAction

    SYNOPSIS:   Moves the default button around in response to user
                input.

    RETURNS:

    HISTORY:
        KeithMo 18-Jan-1993     Created.

********************************************************************/
APIERR ALERTS_STRLB_GROUP::OnUserAction( CONTROL_WINDOW      * pcwin,
                                         const CONTROL_EVENT & e )
{
    APIERR err = SLE_STRLB_GROUP::OnUserAction( pcwin, e );

    if( ( err == NERR_Success ) && ( pcwin == QueryInputSLE() ) )
    {
        //
        //  The user made a change to the input SLE.
        //

        SetDefaultButton();
    }

    return err;

}   // ALERTS_STRLB_GROUP::OnUserAction


/*******************************************************************

    NAME:       ALERTS_STRLB_GROUP::SetDefaultButton

    SYNOPSIS:   Moves the default button around in response to user
                input.

    RETURNS:

    HISTORY:
        KeithMo 18-Jan-1993     Created.

********************************************************************/
VOID ALERTS_STRLB_GROUP::SetDefaultButton( VOID )
{
    if( QueryInputSLE()->QueryTextLength() == 0 )
    {
        //
        //  The SLE is empty. Make the OK button
        //  the default.
        //

        ((ALERTS_DIALOG *)_powin)->MakeOKButtonDefault();
    }
    else
    {
        //
        //  The SLE contains data.  Make the ADD
        //  button the default.
        //

        QueryAddButton()->MakeDefault();
    }

}   // ALERTS_STRLB_GROUP::SetDefaultButton
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\devcntl.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    devcntl.hxx
    Class definitions for the DEVCNTL_DIALOG class.

    The DEVCNTL_DIALOG allows the user to directly manipulate the
    device drivers on a remote server.  The user can start, stop,
    and configure the available devices.


    FILE HISTORY:
        KeithMo     22-Dec-1992 Created.

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETDOMAIN
#define INCL_ICANON
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <svcman.hxx>
#include <svclb.hxx>
#include <devcntl.hxx>
#include <hwprof.hxx> // for DEV_HWPROFILE_DIALOG
#include <srvsvc.hxx>
#include <dbgstr.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <usrbrows.hxx>
#include <strnumer.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <mnet.h>

}   // extern "C"



//
//  DEVCNTL_DIALOG methods
//

/*******************************************************************

    NAME:           DEVCNTL_DIALOG :: DEVCNTL_DIALOG

    SYNOPSIS:       DEVCNTL_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszServerName       - The target server's API name.

                    pszSrvDspName       - The target server's display name.

                    nServerType         - The target server's type bitmask.

    EXIT:           The object is constructed.

    NOTE:           Note that the device control buttons (Start, Stop,
                    Pause, and Continue) are disabled by default.  They
                    will be enabled by the SetupControlButtons method
                    if appropriate.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
DEVCNTL_DIALOG :: DEVCNTL_DIALOG( HWND          hWndOwner,
                                  const TCHAR * pszServerName,
                                  const TCHAR * pszSrvDspName,
                                  ULONG         nServerType )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_DEVCNTL_DIALOG ), hWndOwner ),
    _lbDevices( this,
                IDDC_DEVICES,
                pszServerName,
                nServerType,
                SERVICE_DRIVER ),
    _pbStart( this, IDDC_START ),
    _pbStop( this, IDDC_STOP ),
    _pbHWProfile( this, IDDC_HWPROFILE ),
    _pbClose( this, IDOK ),
    _pszServerName( pszServerName ),
    _nlsSrvDspName( pszSrvDspName ),
    _hCfgMgrHandle( NULL ),
    _fTargetServerIsLocal( TRUE )
{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSrvDspName )
    {
        ReportError( _nlsSrvDspName.QueryError() );
        return;
    }

    //
    //  Set the caption.
    //

    APIERR err = SRV_BASE_DIALOG::SetCaption( this,
                                              IDS_CAPTION_DEVCNTL,
                                              _nlsSrvDspName );

    //
    // We must do this before Refresh, otherwise the HW Profiles button
    // is always initially disabled.
    //
    if ( (err == NERR_Success) && (( nServerType & SV_TYPE_NT ) != 0) )
    {
        // an error here just means we should not enable the pushbutton
        err = HWPROFILE_DIALOG::GetHandle( pszServerName,
                                           &_hCfgMgrHandle );
        ASSERT( (err == NERR_Success) == (_hCfgMgrHandle != NULL) );
    }

    if( err == NERR_Success )
    {
        //
        //  Fill the Device Listbox.
        //

        err = Refresh();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // DEVCNTL_DIALOG :: DEVCNTL_DIALOG

/*******************************************************************

    NAME:           DEVCNTL_DIALOG :: DEVCNTL_DIALOG

    SYNOPSIS:       DEVCNTL_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pserver             - a SERVER_2 object representing the
                                          target server.

    EXIT:           The object is constructed.

    NOTE:           Note that the device control buttons (Start, Stop,
                    Pause, and Continue) are disabled by default.  They
                    will be enabled by the SetupControlButtons method
                    if appropriate.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
DEVCNTL_DIALOG :: DEVCNTL_DIALOG( HWND       hWndOwner,
                                  SERVER_2 * pserver )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_DEVCNTL_DIALOG ), hWndOwner ),
    _lbDevices( this,
                IDDC_DEVICES,
                pserver->QueryName(),
                pserver->QueryServerType(),
                SERVICE_DRIVER ),
    _pbStart( this, IDDC_START ),
    _pbStop( this, IDDC_STOP ),
    _pbHWProfile( this, IDDC_HWPROFILE ),
    _pbClose( this, IDOK ),
    _pszServerName( pserver->QueryName() ),
    _nlsSrvDspName(),
    _hCfgMgrHandle( NULL ),
    _fTargetServerIsLocal( FALSE )
{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSrvDspName )
    {
        ReportError( _nlsSrvDspName.QueryError() );
        return;
    }

    //
    //  Set the caption.
    //

    APIERR err = pserver->QueryDisplayName( &_nlsSrvDspName );

    if( err == NERR_Success )
    {
        err = SRV_BASE_DIALOG::SetCaption( this,
                                           IDS_CAPTION_DEVCNTL,
                                           _nlsSrvDspName );
    }

    //
    // We must do this before Refresh, otherwise the HW Profiles button
    // is always initially disabled.
    //
    if ( (err == NERR_Success) && (( pserver->QueryServerType() & SV_TYPE_NT ) != 0) )
    {
        // an error here just means we should not enable the pushbutton
        err = HWPROFILE_DIALOG::GetHandle( pserver->QueryName(),
                                           &_hCfgMgrHandle );
        ASSERT( (err == NERR_Success) == (_hCfgMgrHandle != NULL) );
    }

    if( err == NERR_Success )
    {
        //
        //  Fill the Device Listbox.
        //

        err = Refresh();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // DEVCNTL_DIALOG :: DEVCNTL_DIALOG


/*******************************************************************

    NAME:           DEVCNTL_DIALOG :: ~DEVCNTL_DIALOG

    SYNOPSIS:       DEVCNTL_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
DEVCNTL_DIALOG :: ~DEVCNTL_DIALOG( VOID )
{
    _pszServerName = NULL;
    HWPROFILE_DIALOG::ReleaseHandle( &_hCfgMgrHandle );

}   // DEVCNTL_DIALOG :: ~DEVCNTL_DIALOG


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCNTL_DIALOG :: Refresh( VOID )
{
    //
    //  We'll need these to restore the appearance of
    //  the listbox.
    //

    UINT iTop;
    UINT iSel;

    if( _lbDevices.QueryCount() == 0 )
    {
        //
        //  The listbox is currently empty.
        //  Therefore, its top index and selected
        //  item are both zero.
        //

        iTop = 0;
        iSel = 0;
    }
    else
    {
        //
        //  The listbox is not empty, so retrieve
        //  its top index and selected item index.
        //

        iTop = _lbDevices.QueryTopIndex();
        iSel = _lbDevices.QueryCurrentItem();
    }

    //
    //  Fill the listbox with that available devices.
    //

    _lbDevices.SetRedraw( FALSE );

    APIERR err = _lbDevices.Fill();

    if( err == NERR_Success )
    {
        //
        //  If there are any devices in the listbox, adjust
        //  its appearance to match the "pre-refresh" state.
        //  Also, setup the control buttons as appropriate for
        //  the current state & abilities of the selected device.
        //

        UINT cItems = _lbDevices.QueryCount();

        if( cItems > 0 )
        {
            if( ( iTop >= cItems ) ||
                ( iSel >= cItems ) )
            {
                //
                //  The number of devices in the listbox has changed,
                //  dropping below either the previous top index or
                //  the index of the previously selected item.  Just
                //  to be safe, we'll revert our selection to the first
                //  item in the listbox.
                //
                //  CODEWORK:  There's got to be a better strategy than
                //  just zapping back to the first listbox item.
                //  Perhaps we should display the *last* 'N' items in
                //  the listbox?  See ChuckC for details!
                //

                iTop = 0;
                iSel = 0;
            }

            _lbDevices.SetTopIndex( iTop );
            _lbDevices.SelectItem( iSel );

            SVC_LBI * plbi = _lbDevices.QueryItem();
            UIASSERT( plbi != NULL );

            if (plbi != NULL) // PREFIX bug 444939
                SetupControlButtons( plbi->QueryCurrentState(),
                                     plbi->QueryControlsAccepted(),
                                     plbi->QueryStartType() );
        }
        else
        {
            //
            //  No devices in the listbox.  Therfore, disable all of
            //  the control buttons.
            //

            DisableControlButtons();
        }
    }
    else
    {
        //
        //  An error occurred while filling the listbox, probably
        //  during the device enumeration.
        //

        DisableControlButtons();
    }

    //
    //  Allow listbox repaints, then force a repaint.
    //

    _lbDevices.SetRedraw( TRUE );
    _lbDevices.Invalidate( TRUE );

    return err;

}   // DEVCNTL_DIALOG :: Refresh


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
BOOL DEVCNTL_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    switch( event.QueryCid() )
    {
    case IDDC_START:
        DeviceControl( DevOpStart );
        return TRUE;

    case IDDC_STOP:
        DeviceControl( DevOpStop );
        return TRUE;

    case IDDC_DEVICES:
        //
        //  The SVC_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in SVC_LISTBOX.
            //

            SVC_LBI * plbi = _lbDevices.QueryItem();
            UIASSERT( plbi != NULL );

            if (plbi != NULL) // PREFIX bug 444940
                SetupControlButtons( plbi->QueryCurrentState(),
                                     plbi->QueryControlsAccepted(),
                                     plbi->QueryStartType() );
        }

        return TRUE;

    case IDDC_CONFIGURE:
    case IDDC_HWPROFILE:
        {
            BOOL fDoRefresh = FALSE;

            SVC_LBI * plbi = _lbDevices.QueryItem();
            UIASSERT( plbi != NULL );

            APIERR err = NERR_Success;
            if ( event.QueryCid() != IDDC_HWPROFILE )
            // must seperate these clauses since dlog dtor is not virtual
            {
                DEVCFG_DIALOG * pDlg =
                       new DEVCFG_DIALOG(        QueryHwnd(),
                                                 _pszServerName,
                                                 _nlsSrvDspName,
                                                 plbi->QueryServiceName(),
                                                 plbi->QueryDisplayName() );
                err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : pDlg->Process( &fDoRefresh );

                delete pDlg;
            } else {
                DEV_HWPROFILE_DIALOG * pDlg =
                   new DEV_HWPROFILE_DIALOG(     QueryHwnd(),
                                                 _pszServerName,
                                                 _nlsSrvDspName,
                                                 plbi->QueryServiceName(),
                                                 plbi->QueryDisplayName(),
                                                 _hCfgMgrHandle );
                err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : pDlg->Process( &fDoRefresh );

                delete pDlg;
            }

            if( err == NERR_Success )
            {
                if( fDoRefresh )
                {
                    Refresh();
                }
            }
            else
            {
                MsgPopup( this, err );
            }
        }

        return TRUE;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        break;
    }

    return FALSE;

}   // DEVCNTL_DIALOG :: OnCommand


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: SetupControlButtons

    SYNOPSIS:   This method enables & disables the various
                control buttons as appropriate for the device's
                current state and control abilities.

    ENTRY:      CurrentState            - The device's state.

                ControlsAccepted        - A bit mask representing
                                          the types of controls the
                                          device will respond to.

                StartType               - The start type for the device.

    EXIT:       The start, stop, pause, continue, and configure buttons
                are set as appropriate.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
VOID DEVCNTL_DIALOG :: SetupControlButtons( ULONG CurrentState,
                                            ULONG ControlsAccepted,
                                            ULONG StartType )
{
    //
    //  We'll assume that no operations are allowed
    //  unless proven otherwise.
    //

    BOOL fStop     = FALSE;
    BOOL fStart    = FALSE;

    switch( CurrentState )
    {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        //
        //  If the device is stopped, the only thing
        //  we can do is start it.
        //

        fStart = TRUE;
        break;

    case SERVICE_RUNNING:
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
        //
        //  If the device is started, we may be allowed
        //  to either stop it.
        //

        fStop  = ( ( ControlsAccepted & SERVICE_ACCEPT_STOP ) != 0 );
        break;

    default:
        //
        //  Bogus state.
        //

        UIASSERT( FALSE );
        break;
    }

    //
    //  Start is only allowed if the device is not disabled.
    //

    if( StartType == SERVICE_DISABLED )
    {
        fStart = FALSE;
    }

    _pbStop.Enable( fStop );
    _pbStart.Enable( fStart );
    _pbHWProfile.Enable( _hCfgMgrHandle != NULL );

}   // DEVCNTL_DIALOG :: SetupControlButtons


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: DisableControlButtons

    SYNOPSIS:   This method disables the various device control
                buttons.

    EXIT:       The start, stop, pause, and continue buttons
                are disabled.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
VOID DEVCNTL_DIALOG :: DisableControlButtons( VOID )
{
    _pbStop.Enable( FALSE );
    _pbStart.Enable( FALSE );
    _pbHWProfile.Enable( FALSE );

}   // DEVCNTL_DIALOG :: DisableControlButtons


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
ULONG DEVCNTL_DIALOG :: QueryHelpContext( VOID )
{
    return HC_DEVCNTL_DIALOG;

}   // DEVCNTL_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       DEVCNTL_DIALOG :: DeviceControl

    SYNOPSIS:   This method does most of the actual device control.

    ENTRY:      OpCode                  - Either DevOpStart or DevOpStop.

    EXIT:       Either the device has changed state or an error
                message has been presented to the user.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
VOID DEVCNTL_DIALOG :: DeviceControl( enum DeviceOperation OpCode )
{
    AUTO_CURSOR Cursor;

    //
    //  Determine exactly which device we'll be controlling.
    //

    SVC_LBI * plbi = _lbDevices.QueryItem();
    UIASSERT( plbi != NULL );

    //
    //  Create our device control object, check for errors.
    //

    MSGID  idFailure = 0;
    APIERR err;
    GENERIC_SERVICE * pSvc = new GENERIC_SERVICE( this,
                                                  _pszServerName,
                                                  _nlsSrvDspName,
                                                  plbi->QueryServiceName(),
                                                  plbi->QueryDisplayName(),
                                                  TRUE );

    if( pSvc == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        err = pSvc->QueryError();
    }

    if( err != NERR_Success )
    {
        delete pSvc;
        MsgPopup( this, err );
        return;
    }

    //
    //  Interpret the opcode.
    //

    switch( OpCode )
    {

    case DevOpStart:
        err = pSvc->Start( SZ("") );
        idFailure = IDS_CANNOT_START;
        break;

    case DevOpStop:
        //
        //  Before we stop the device, warn the user.
        //

        if( pSvc->StopWarning() )
        {
            delete pSvc;
            return;
        }

        BOOL fDummy;
        err = pSvc->Stop( &fDummy );
        idFailure = IDS_CANNOT_STOP;
        break;

    default:
        UIASSERT( FALSE );
        break;
    }

    UIASSERT( idFailure != 0 );

    //
    //  If the operation failed, give the user the bad news.
    //

    if( err == ERROR_SERVICE_SPECIFIC_ERROR )
    {
        DEC_STR nls( (ULONG)pSvc->QuerySpecificCode() );

        err = !nls ? nls.QueryError() : IDS_SERVICE_SPECIFIC_CODE;

        ::MsgPopup( this,
                    err,
                    MPSEV_ERROR,
                    MP_OK,
                    plbi->QueryDisplayName(),
                    nls.QueryPch() );
    }
    else
    if( err != NERR_Success )
    {
        ::DisplayGenericError( this,
                               idFailure,
                               err,
                               plbi->QueryDisplayName(),
                               _nlsSrvDspName,
                               MPSEV_ERROR );
    }

    //
    //  Now that we're done, delete the GENERIC_SERVICE
    //  object & refresh the dialog.
    //

    delete pSvc;

    Refresh();

    //
    //  If everything went well then we should set the input
    //  focus to the help button.
    //

    if( err == NERR_Success )
    {
        SetDialogFocus( _pbClose );
    }

    return;

}   // DEVCNTL_DIALOG :: DeviceControl



//
//  DEVCFG_DIALOG methods
//

/*******************************************************************

    NAME:           DEVCFG_DIALOG :: DEVCFG_DIALOG

    SYNOPSIS:       DEVCFG_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszServerName       - The API name for the target server.

                    pszSrvDspName       - The target server's display name.

                    pszDeviceName       - The name of the target device.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
DEVCFG_DIALOG :: DEVCFG_DIALOG( HWND          hWndOwner,
                                const TCHAR * pszServerName,
                                const TCHAR * pszSrvDspName,
                                const TCHAR * pszDeviceName,
                                const TCHAR * pszDisplayName )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_DEVCFG_DIALOG ), hWndOwner ),
    _sltDeviceName( this, IDDC_DEVICE_NAME ),
    _rgStartType( this, IDDC_START_BOOT, 5 ),
    _pscman( NULL ),
    _pscsvc( NULL ),
    _cLocks( 0 ),
    _pszServerName( pszServerName ),
    _pszSrvDspName( pszSrvDspName ),
    _pszDisplayName( pszDisplayName ),
    _nOriginalStartType( 0 )
{
    UIASSERT( pszSrvDspName != NULL );
    UIASSERT( pszDeviceName != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        //
        //  Set the dialog caption.
        //

        err = SetCaption( _pszSrvDspName, pszDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Connect to the target device.
        //

        err = ConnectToTargetDevice( pszDeviceName );
    }

    if( err == NERR_Success )
    {
        //
        //  Setup the dialog controls.
        //

        err = SetupControls();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // DEVCFG_DIALOG :: DEVCFG_DIALOG


/*******************************************************************

    NAME:           DEVCFG_DIALOG :: ~DEVCFG_DIALOG

    SYNOPSIS:       DEVCFG_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
DEVCFG_DIALOG :: ~DEVCFG_DIALOG( VOID )
{
    UIASSERT( _cLocks == 0 );

    //
    //  Note that _pscsvc *must* be deleted before _pscman!
    //

    delete _pscsvc;
    _pscsvc = NULL;

    delete _pscman;
    _pscman = NULL;

    _pszServerName  = NULL;
    _pszSrvDspName = NULL;

}   // DEVCFG_DIALOG :: ~DEVCFG_DIALOG


/*******************************************************************

    NAME:           DEVCFG_DIALOG :: LockServiceDatabase

    SYNOPSIS:       Locks the device database.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCFG_DIALOG :: LockServiceDatabase( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    //
    //  We only need to actually perform the lock
    //  if the database is currently unlocked.
    //

    if( ++_cLocks == 1 )
    {
        err = _pscman->Lock();

        if( err != NERR_Success )
        {
            //
            //  We were unable to actually lock the database,
            //  do decrement the reference counter accordingly.
            //

            _cLocks--;
        }
    }

    return err;

}   // DEVCFG_DIALOG :: LockServiceDatabase


/*******************************************************************

    NAME:           DEVCFG_DIALOG :: UnlockServiceDatabase

    SYNOPSIS:       Unlocks the device database.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCFG_DIALOG :: UnlockServiceDatabase( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );
    UIASSERT( _cLocks > 0 );

    APIERR err = NERR_Success;

    //
    //  We only need to actually perform the unlock
    //  if the database is currently locked.
    //

    if( --_cLocks == 0 )
    {
        err = _pscman->Unlock();
    }

    return err;

}   // DEVCFG_DIALOG :: UnlockServiceDatabase


/*******************************************************************

    NAME:           DEVCFG_DIALOG :: SetCaption

    SYNOPSIS:       Worker method called during construction to
                    setup the dialog caption.

    ENTRY:          pszServerName       - The name of the target server.

                    pszDeviceName      - The name of the target device.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCFG_DIALOG :: SetCaption( const TCHAR * pszServerName,
                                    const TCHAR * pszDeviceName )
{
    UIASSERT( pszServerName != NULL );
    UIASSERT( pszDeviceName != NULL );

    //
    //  Kruft up some NLS_STRs for our input parameters.
    //
    //  Note that the server name (should) still have the
    //  leading backslashes (\\).  They are not to be displayed.
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

    ALIAS_STR nlsDeviceName( pszDeviceName );
    UIASSERT( nlsDeviceName.QueryError() == NERR_Success );

#ifdef  DEBUG
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( nlsServerName );

        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
        ++istrDbg;
        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
    }
#endif  // DEBUG

    //
    //  Skip the backslashes.
    //
    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    //
    //  The insert strings for Load().
    //

    const NLS_STR * apnlsParams[3];

    apnlsParams[0] = &nlsWithoutPrefix;
    apnlsParams[1] = NULL;

    //
    //  Load the caption string.
    //

    NLS_STR nlsCaption;

    APIERR err = nlsCaption.QueryError();

    if( err == NERR_Success )
    {
        nlsCaption.Load( IDS_CAPTION_DEVCFG );
        nlsCaption.InsertParams( apnlsParams );

        err = nlsCaption.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Set the caption.
        //

        _sltDeviceName.SetText( nlsDeviceName );
        SetText( nlsCaption );
    }

    return err;

}   // DEVCFG_DIALOG :: SetCaption


/*******************************************************************

    NAME:           DEVCFG_DIALOG :: ConnectToTargetDevice

    SYNOPSIS:       Worker method called during construction to
                    connect to the target device.

    ENTRY:          pszDeviceName      - The name of the target device.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCFG_DIALOG :: ConnectToTargetDevice( const TCHAR * pszDeviceName )
{
    //
    //  This may take a few seconds...
    //

    AUTO_CURSOR NiftyCursor;

    //
    //  Connect to the target server's device controller.
    //

    _pscman = new SC_MANAGER( _pszServerName,
                              STANDARD_RIGHTS_REQUIRED |
                                  SC_MANAGER_CONNECT   |
                                  SC_MANAGER_LOCK,
                              ACTIVE );

    APIERR err = ( _pscman == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pscman->QueryError();

    if( err == NERR_Success )
    {
        //
        //  Lock the device database.
        //

        err = LockServiceDatabase();
    }

    if( err == NERR_Success )
    {
        //
        //  Connect to the target device.
        //

        _pscsvc = new SC_SERVICE( *_pscman,
                                  pszDeviceName,
                                  STANDARD_RIGHTS_REQUIRED  |
                                      SERVICE_QUERY_CONFIG  |
                                      SERVICE_CHANGE_CONFIG );

        err = ( _pscsvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : _pscsvc->QueryError();
    }

    return err;

}   // DEVCFG_DIALOG :: ConnectToTargetDevice


/*******************************************************************

    NAME:       DEVCFG_DIALOG :: SetupControls

    SYNOPSIS:   Initializes the various dialog controls to reflect
                the values returned by the device controller.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
APIERR DEVCFG_DIALOG :: SetupControls( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );
    UIASSERT( _pscsvc != NULL );
    UIASSERT( _pscsvc->QueryError() == NERR_Success );

    //
    //  Query the device configuration.
    //

    LPQUERY_SERVICE_CONFIG psvccfg;

    APIERR err = _pscsvc->QueryConfig( &psvccfg );

    if( err == NERR_Success )
    {
        UIASSERT( psvccfg != NULL );

        //
        //  Setup the start type radio group.
        //

        CID cidStartType = RG_NO_SEL;   // until proven otherwise...

        _nOriginalStartType = (ULONG)psvccfg->dwStartType;

        switch( _nOriginalStartType )
        {
        case SERVICE_BOOT_START:
            cidStartType = IDDC_START_BOOT;
            break;

        case SERVICE_SYSTEM_START:
            cidStartType = IDDC_START_SYSTEM;
            break;

        case SERVICE_AUTO_START:
            cidStartType = IDDC_START_AUTO;
            break;

        case SERVICE_DEMAND_START:
            cidStartType = IDDC_START_DEMAND;
            break;

        case SERVICE_DISABLED:
            cidStartType = IDDC_START_DISABLED;
            break;

        default:
            UIASSERT( FALSE );
            break;
        }

        _rgStartType.SetSelection( cidStartType );

        RADIO_BUTTON * prb = _rgStartType[cidStartType];
        UIASSERT( prb != NULL );

        if( prb != NULL )
        {
            prb->ClaimFocus();
        }
    }

    return err;

}   // DEVCFG_DIALOG :: SetupControls


/*******************************************************************

    NAME:       DEVCFG_DIALOG :: OnOK

    SYNOPSIS:   Dismiss the dialog when the user presses OK.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
BOOL DEVCFG_DIALOG :: OnOK( VOID )
{

    //
    //  Determine the new start type.
    //

    ULONG StartType = SERVICE_DISABLED;         // until proven otherwise...

    switch( _rgStartType.QuerySelection() )
    {
    case IDDC_START_BOOT:
        StartType = SERVICE_BOOT_START;
        break;

    case IDDC_START_SYSTEM:
        StartType = SERVICE_SYSTEM_START;
        break;

    case IDDC_START_AUTO:
        StartType = SERVICE_AUTO_START;
        break;

    case IDDC_START_DEMAND:
        StartType = SERVICE_DEMAND_START;
        break;

    case IDDC_START_DISABLED:
        StartType = SERVICE_DISABLED;
        break;

    default:
        UIASSERT( FALSE );  // bogus value from radio group!
        break;
    }

    INT    nChoice = IDYES;
    APIERR err     = NERR_Success;

    if( _nOriginalStartType != StartType )
    {
        //
        //  If this is a particularly nasty device, give the user
        //  the opportunity to bag out before we commit to the change.
        //

        if( ( _nOriginalStartType == SERVICE_BOOT_START ) ||
            ( _nOriginalStartType == SERVICE_SYSTEM_START ) )
        {
            nChoice = ::MsgPopup( this,
                                  IDS_DEV_CHANGE_WARN,
                                  MPSEV_WARNING,
                                  MP_YESNOCANCEL,
                                  _pszDisplayName,
                                  MP_NO );
        }

        if( nChoice == IDCANCEL )
        {
            //
            //  User is cancelling the change.
            //

            return TRUE;
        }

        if( nChoice == IDYES )
        {
            //
            //  This may take a few seconds...
            //

            AUTO_CURSOR NiftyCursor;

            err = _pscsvc->ChangeConfig( SERVICE_NO_CHANGE, // device type
                                         StartType,         // start type
                                         SERVICE_NO_CHANGE, // error ctrl
                                         NULL,              // image path
                                         NULL,              // load group
                                         NULL,              // dependencies
                                         NULL,              // logon account
                                         NULL );            // password
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Unlock the device database.
        //

        err = UnlockServiceDatabase();
    }

    if( err == NERR_Success )
    {
        //
        //  Dismiss the dialog.
        //

        Dismiss( ( nChoice == IDYES ) && ( _nOriginalStartType != StartType ) );
    }
    else
    {
        //
        //  Some error occurred along the way.
        //

        ::MsgPopup( this, err );
    }

    return TRUE;

}   // DEVCFG_DIALOG :: OnOK


/*******************************************************************

    NAME:       DEVCFG_DIALOG :: OnCancel

    SYNOPSIS:   Dismiss the dialog when the user presses Cancel.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
BOOL DEVCFG_DIALOG :: OnCancel( VOID )
{
    //
    //  Unlock the device database.
    //

    APIERR err = UnlockServiceDatabase();

    if( err != NERR_Success )
    {
        //
        //  Whoops.
        //

        MsgPopup( this, err );
    }
    else
    {
        //
        //  Dismiss the dialog.
        //

        Dismiss( FALSE );
    }

    return TRUE;

}   // DEVCFG_DIALOG :: OnCancel


/*******************************************************************

    NAME:       DEVCFG_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
ULONG DEVCFG_DIALOG :: QueryHelpContext( VOID )
{
    return HC_DEVCFG_DIALOG;

}   // DEVCFG_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\files.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    files.cxx
    Class declarations for the FILES_DIALOG, FILES_LISTBOX, and
    FILES_LBI classes.

    These classes implement the Server Manager Shared Files subproperty
    sheet.  The FILES_LISTBOX/FILES_LBI classes implement the listbox
    which shows the available sharepoints.  FILES_DIALOG implements the
    actual dialog box.


    FILE HISTORY:
        KeithMo     01-Aug-1991 Created.
        KeithMo     03-Sep-1991 Changes from code review attended by
                                ChuckC and JohnL.
        KeithMo     22-Sep-1991 Changed to the "New SrvMgr" look.
        KeithMo     06-Oct-1991 Win32 Conversion.

*/
#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmoenum.hxx>
#include <lmosrv.hxx>
#include <lmoesh.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"

#include <files.hxx>


//
//  FILES_DIALOG methods.
//

/*******************************************************************

    NAME:       FILES_DIALOG :: FILES_DIALOG

    SYNOPSIS:   FILES_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     04-Jun-1991 Created.
        KeithMo     03-Sep-1991 Changed _nlsNotAvailable constructor.

********************************************************************/
FILES_DIALOG :: FILES_DIALOG( HWND             hWndOwner,
                              const SERVER_2 * pserver )
  : BASE_RES_DIALOG( hWndOwner, MAKEINTRESOURCE( IDD_SHARED_FILES ),
                     IDS_CAPTION_FILES,
                     pserver, &_lbFiles,
                     IDSF_USERLIST, IDSF_USERS, IDSF_DISCONNECT,
                     IDSF_DISCONNECTALL ),
    _lbFiles( this, IDSF_SHARESLIST, pserver )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Refresh the dialog.
    //

    APIERR err = Refresh();

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // FILES_DIALOG :: FILES_DIALOG


/*******************************************************************

    NAME:       FILES_DIALOG :: ~FILES_DIALOG

    SYNOPSIS:   FILES_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
FILES_DIALOG :: ~FILES_DIALOG()
{
    //
    //  This space intentionally left blank.
    //

}   // FILES_DIALOG :: ~FILES_DIALOG


/*******************************************************************

    NAME:       FILES_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
ULONG FILES_DIALOG :: QueryHelpContext( void )
{
    return HC_FILES_DIALOG;

}   // FILES_DIALOG :: QueryHelpContext


//
//  FILES_LISTBOX methods.
//

/*******************************************************************

    NAME:       FILES_LISTBOX :: FILES_LISTBOX

    SYNOPSIS:   FILES_LISTBOX class constructor.

    ENTRY:      powOwner                - The owning window.

                cid                     - The listbox CID.

                pserver                 - The target server.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 Added constructors for the various
                                DMID_DTE flavors.

********************************************************************/
FILES_LISTBOX :: FILES_LISTBOX( OWNER_WINDOW   * powOwner,
                                CID              cid,
                                const SERVER_2 * pserver )
  : BASE_RES_LISTBOX( powOwner, cid, NUM_FILES_LISTBOX_COLUMNS, pserver ),
    _dteDisk( IDBM_LB_SHARE ),
    _dtePrint( IDBM_LB_PRINT ),
    _dteComm( IDBM_LB_COMM ),
    _dteIPC( IDBM_LB_IPC ),
    _dteUnknown( IDBM_LB_UNKNOWN )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _dteDisk.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dtePrint.QueryError()   ) != NERR_Success ) ||
        ( ( err = _dteComm.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteIPC.QueryError()     ) != NERR_Success ) ||
        ( ( err = _dteUnknown.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // FILES_LISTBOX :: FILES_LISTBOX


/*******************************************************************

    NAME:       FILES_LISTBOX :: ~FILES_LISTBOX

    SYNOPSIS:   FILES_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
FILES_LISTBOX :: ~FILES_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // FILES_LISTBOX :: ~FILES_LISTBOX


/*******************************************************************

    NAME:       FILES_LISTBOX :: Fill

    SYNOPSIS:   Fills the listbox with the available sharepoints.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.

********************************************************************/
APIERR FILES_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Our share enumerator.
    //

    SHARE2_ENUM enumShare2( (TCHAR *)QueryServer() );

    //
    //  See if the shares are available.
    //

    APIERR err = enumShare2.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Now that we know the share info is available,
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the available sharepoints.
    //

    SHARE2_ENUM_ITER iterShare2( enumShare2 );
    const SHARE2_ENUM_OBJ * pshi2;

    //
    //  Iterate the shares adding them to the listbox.
    //

    err = NERR_Success;

    while( ( err == NERR_Success ) && ( ( pshi2 = iterShare2() ) != NULL ) )
    {
        DMID_DTE * pdte = NULL;

        switch( pshi2->QueryType() & ~STYPE_SPECIAL )
        {
        case STYPE_DISKTREE :
            pdte = &_dteDisk;
            break;

        case STYPE_PRINTQ :
            pdte = &_dtePrint;
            break;

        case STYPE_DEVICE :
            pdte = &_dteComm;
            break;

        case STYPE_IPC :
            pdte = &_dteIPC;
            break;

        default :
            pdte = &_dteUnknown;
            break;
        }

        UIASSERT( pdte != NULL );

        FILES_LBI * pslbi = new FILES_LBI( pshi2->QueryName(),
                                           pshi2->QueryPath(),
                                           (ULONG)pshi2->QueryCurrentUses(),
                                           pdte );

        if( AddItem( pslbi ) < 0 )
        {
            //
            //  CODEWORK:  What should we do in error conditions?
            //  As currently spec'd, we do nothing.  If the data
            //  cannot be retrieved, we display "n/a" in the
            //  statistics strings.  Should we hide the listbox
            //  and display a message a'la WINNET??
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // FILES_LISTBOX :: Fill


//
//  FILES_LBI methods.
//

/*******************************************************************

    NAME:       FILES_LBI :: FILES_LBI

    SYNOPSIS:   FILES_LBI class constructor.

    ENTRY:      pszShareName            - The sharepoint name.

                pszPath                 - The path for this sharepoint.

                cUses                   - Number of uses for this share.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 Nuked _nlsShareName (this is now the
                                "target resource").  Changed _nlsUses
                                to preallocate CCH_LONG+1 characters.

********************************************************************/
FILES_LBI :: FILES_LBI( const TCHAR * pszShareName,
                        const TCHAR * pszPath,
                        ULONG         cUses,
                        DMID_DTE    * pdte )
  : BASE_RES_LBI( pszShareName ),
    _pdte( pdte ),
    _nlsPath( pszPath ),
    _nlsUses( cUses )
{
    UIASSERT( pszShareName != NULL );
    UIASSERT( pdte != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsPath.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsUses.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // FILES_LBI :: FILES_LBI


/*******************************************************************

    NAME:       FILES_LBI :: ~FILES_LBI

    SYNOPSIS:   FILES_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 NULL _pdte before terminating.

********************************************************************/
FILES_LBI :: ~FILES_LBI()
{
    _pdte = NULL;

}   // FILES_LBI :: ~FILES_LBI


/*******************************************************************

    NAME:       FILES_LBI :: Paint

    SYNOPSIS:   Draw an entry in FILES_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 dteShareName now constructs from
                                QueryResourceName() instead of _nlsShareName.
        KeithMo     06-Oct-1991 Now takes a const RECT *.
        beng        22-Apr-1992 Changes to LBI::Paint

********************************************************************/
VOID FILES_LBI :: Paint( LISTBOX *        plb,
                         HDC              hdc,
                         const RECT     * prect,
                         GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteShareName( QueryResourceName() );
    STR_DTE dteUses( _nlsUses.QueryPch() );
    STR_DTE dtePath( _nlsPath.QueryPch() );

    DISPLAY_TABLE dtab( NUM_FILES_LISTBOX_COLUMNS,
                        ((BASE_RES_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = _pdte;
    dtab[1] = &dteShareName;
    dtab[2] = &dteUses;
    dtab[3] = &dtePath;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // FILES_LBI :: Paint


/*******************************************************************

    NAME:       FILES_LBI :: NotifyNewUseCount

    SYNOPSIS:   Notifies the LBI that the "use" count has changed.

    ENTRY:      cUses                   - The new use count.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     08-Jul-1992 Created for Server Manager.

********************************************************************/
APIERR FILES_LBI :: NotifyNewUseCount( UINT cUses )
{
    DEC_STR nls( cUses );

    APIERR err = nls.QueryError();

    if( err == NERR_Success )
    {
        err = _nlsUses.CopyFrom( nls );
    }

    return err;

}   // FILES_LBI :: NotifyNewUseCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\addcomp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    addcomp.hxx
    This file contains the class definitions for the ADD_COMPUTER_DIALOG
    class.  The ADD_COMPUTER_DIALOG class is used to add a computer or
    server to a domain.  This file also contains a method to remove a
    computer or server from a domain.


    FILE HISTORY:
        jonn        21-Jan-1992 Created.
        KeithMo     09-Jun-1992 Added warning if new comp != current view.
        Yi-HsinS    20-Nov-1992 Make the dialog easier( got rid of passwords )

*/

#include <ntincl.hxx> // for ssi.h

#define INCL_NET
#define INCL_NETCONS
#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <ntuser.hxx>

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <mnet.h>
    #include <ntsam.h> // logonmsv.h needs this
    #include <crypt.h> // logonmsv.h needs this
    #include <logonmsv.h> // ssi.h needs this
    #include <ssi.h> // for SSI_ACCOUNT_NAME_POSTFIX
}   // extern "C"

#include <addcomp.hxx>


#define SM_MAX_COMPUTERNAME_LENGTH MAX_PATH
#define SM_MAX_PASSWORD_LENGTH     LM20_PWLEN


//
//  ADD_COMPUTER_DIALOG methods.
//

/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG :: ADD_COMPUTER_DIALOG

    SYNOPSIS:   ADD_COMPUTER_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

                pszDomainName           - The domain name.

    EXIT:       The object is constructed.

    HISTORY:
        jonn        21-Jan-1992 Created.
        KeithMo     09-Jun-1992 Constructor now takes SM_ADMIN_APP *.

********************************************************************/

ADD_COMPUTER_DIALOG :: ADD_COMPUTER_DIALOG( HWND hWndOwner,
                                            const TCHAR  * pszDomainName,
                                            BOOL fViewServers,
                                            BOOL fViewWkstas,
                                            BOOL * pfForceRefresh )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_ADD_COMPUTER ), hWndOwner,
#ifdef FE_SB
                FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
#else
                TRUE                   // Use Ansi form of dialog to
                                       // canonicalize the computernames
#endif
                ),
    _pszDomainName ( pszDomainName ),
    _rgComputerOrServer( this, IDAC_WORKSTATION, 2 ),
    _sleComputerName( this, IDAC_COMPUTERNAME, SM_MAX_COMPUTERNAME_LENGTH ),
    _buttonCancel  ( this, IDCANCEL ),
    _nlsClose      ( IDS_BUTTON_CLOSE ),
    _fAddedServers ( FALSE ),
    _fAddedWkstas  ( FALSE ),
    _fViewServers  ( fViewServers ),
    _fViewWkstas   ( fViewWkstas ),
    _pfForceRefresh( pfForceRefresh )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( pfForceRefresh != NULL );
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if ( _nlsClose.QueryError() != NERR_Success )
    {
        ReportError( _nlsClose.QueryError() );
        return;
    }

    _rgComputerOrServer.SetSelection( IDAC_WORKSTATION );
    _rgComputerOrServer.SetControlValueFocus();

    *_pfForceRefresh = FALSE;

}   // ADD_COMPUTER_DIALOG :: ADD_COMPUTER_DIALOG


/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG :: ~ADD_COMPUTER_DIALOG

    SYNOPSIS:   ADD_COMPUTER_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        jonn        21-Jan-1992 Created.

********************************************************************/

ADD_COMPUTER_DIALOG :: ~ADD_COMPUTER_DIALOG()
{
    //
    //  This space intentionally left blank.
    //

}   // ADD_COMPUTER_DIALOG :: ~ADD_COMPUTER_DIALOG


/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG :: OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
        jonn        21-Jan-1992 Created.
        JonN        09-May-1992 UNICODE build fix

********************************************************************/

BOOL ADD_COMPUTER_DIALOG :: OnOK()
{

#ifndef WIN32

    ::MsgPopup( ERROR_NOT_SUPPORTED );
    return TRUE;

#else // WIN32

    AUTO_CURSOR NiftyCursor;

    NLS_STR nlsAccountName;
    NLS_STR nlsBareAccountName;
    NLS_STR nlsPassword;
    ACCOUNT_TYPE accounttype = AccountType_WkstaTrust;
    BOOL fIsServer = FALSE;

    _sleComputerName.QueryText( &nlsAccountName );

    APIERR err = nlsAccountName.QueryError();
    if ( err == NERR_Success )
        err = nlsPassword.QueryError();
    if( err == NERR_Success )
        err = nlsBareAccountName.QueryError();
    if( err == NERR_Success )
        err = nlsBareAccountName.CopyFrom( nlsAccountName );

    // CODEWORK should use VALIDATED_DIALOG
    if (err != NERR_Success)
    {} // do nothing
    else if (NERR_Success != ::I_MNetNameValidate( NULL,
                                                   nlsAccountName,
                                                   NAMETYPE_COMPUTER,
                                                   0L ) )
    {
        _sleComputerName.SelectString();
        _sleComputerName.ClaimFocus();
        err = IDS_COMPUTERNAME_INVALID;
    }

    if ( err == NERR_Success )
        err = ADD_COMPUTER_DIALOG::GetMachineAccountPassword( nlsBareAccountName,
                                                              &nlsPassword );

    if ( err == NERR_Success )
    {
        switch ( _rgComputerOrServer.QuerySelection() )
        {
        case IDAC_WORKSTATION:
            accounttype = AccountType_WkstaTrust;
            break;
        case IDAC_SERVER:
            accounttype = AccountType_ServerTrust;
            fIsServer = TRUE;
            break;
        case RG_NO_SEL:
        default:
            ASSERT( FALSE ); // not a valid response
            return TRUE;
        }

        NLS_STR nlsAccountPostfix;

        if(   (err = nlsAccountPostfix.QueryError()) == NERR_Success
           && (err = nlsAccountPostfix.MapCopyFrom( (TCHAR *)SSI_ACCOUNT_NAME_POSTFIX )) == NERR_Success
          )
        {
            err = nlsAccountName.Append( nlsAccountPostfix );
        }

    }


    if ( err == NERR_Success )
    {
        USER_3 user3( nlsAccountName.QueryPch(), _pszDomainName );
        if (   (err = user3.QueryError()) == NERR_Success
            && (err = user3.CreateNew()) == NERR_Success
            && (err = user3.SetName( nlsAccountName )) == NERR_Success
            && (err = user3.SetPassword( nlsPassword )) == NERR_Success
            && (err = user3.SetAccountType( accounttype )) == NERR_Success
           )
        {
            AUTO_CURSOR cursor;
            err = user3.WriteNew();
        }

        RtlZeroMemory( (PVOID)nlsPassword.QueryPch(),
                       nlsPassword.QueryTextSize() );
    }

    if( err == NERR_UserExists )
    {
        ::MsgPopup( this,
                    IDS_CANNOT_ADD_MACHINE,
                    MPSEV_ERROR,
                    MP_OK,
                    nlsBareAccountName );
        _sleComputerName.SelectString();
        _sleComputerName.ClaimFocus();
    }
    else
    if( err != NERR_Success )
    {
        ::MsgPopup( this, err );
    }
    else
    {
        if ( !_fAddedServers )
            _fAddedServers = fIsServer;

        if ( !_fAddedWkstas )
            _fAddedWkstas = !fIsServer;

        _sleComputerName.ClearText();
        _sleComputerName.ClaimFocus();

        if ( !*_pfForceRefresh )
            _buttonCancel.SetText( _nlsClose );

        *_pfForceRefresh = TRUE;
    }

    return TRUE;

#endif // WIN32

}   // ADD_COMPUTER_DIALOG :: OnOK

/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG :: OnCancel

    SYNOPSIS:   Close button handler

    HISTORY:
        Yi-HsinS        19-Nov-1992 Created.

********************************************************************/

BOOL ADD_COMPUTER_DIALOG :: OnCancel()
{
    MSGID msgid;

    //
    //  If we're adding a server but we're not currently viewing
    //  servers, or we're adding a wksta and we're not currently
    //  viewing wkstas, then warn the user.
    //

    if( (  _fAddedServers && !_fViewServers ) ||
        (  _fAddedWkstas && !_fViewWkstas  ) )
    {
        ::MsgPopup( this,
                    IDS_ADDED_COMPUTER_WARN,
                    MPSEV_INFO );
    }

    Dismiss();
    return TRUE;

}   // ADD_COMPUTER_DIALOG :: OnCancel

/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG::GetMachineAccountPassword

    SYNOPSIS:   Generate the initial password of the domain's machine account
                for this computer.

    ENTRY:      pszServer  - The computer name

    EXIT:       pnlsPassword - Points to the generated password

    RETURNS:

    NOTES:      This is a STATIC method.

    HISTORY:
        Yi-HsinS   11/20/92    Created

********************************************************************/

APIERR ADD_COMPUTER_DIALOG::GetMachineAccountPassword( const TCHAR * pszServer,
                                                       NLS_STR     * pnlsPassword )
{
    const INT cchMax = LM20_PWLEN < MAX_PATH
                     ? LM20_PWLEN
                     : MAX_PATH ;

    TCHAR szPw [cchMax+1] ;

    szPw[ cchMax ] = 0;
    ::strncpyf( szPw, pszServer, cchMax );
    ::CharLowerBuff( szPw, ::strlenf( szPw ) ) ;

    return pnlsPassword->CopyFrom( szPw );
}

/*******************************************************************

    NAME:       ADD_COMPUTER_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     10-Jun-1992 Created.

********************************************************************/
ULONG ADD_COMPUTER_DIALOG :: QueryHelpContext( void )
{
    return HC_ADD_COMPUTER_DLG;

}   // ADD_COMPUTER_DIALOG :: QueryHelpContext


/*************************************************************************

    NAME:       RemoveComputer

    SYNOPSIS:   This function removes a computer from a domain.

    HISTORY:
        JonN        23-Jan-1992 Created.
        JonN        09-May-1992 UNICODE build fix
        KeithMo     09-Jun-1992 Added warnings.

**************************************************************************/

APIERR RemoveComputer(  HWND          hWndOwner,
                        const TCHAR * pchComputerName,
                        const TCHAR * pchDomainName,
                        BOOL          fIsServer,
                        BOOL          fIsNT,
                        BOOL        * pfForceRefresh )
{

#ifndef WIN32

    return ERROR_NOT_SUPPORTED;

#else // WIN32

    UIASSERT( pchComputerName != NULL );
    UIASSERT( pchDomainName != NULL );
    UIASSERT( pfForceRefresh != NULL );

    *pfForceRefresh = FALSE;

// We don't need to validate the computer name, it came from the enumerator

    if( ::MsgPopup( hWndOwner,
                    fIsServer ? IDS_REMOVE_SERVER_WARNING
                              : IDS_REMOVE_WKSTA_WARNING,
                    MPSEV_WARNING,
                    MP_YESNO,
                    pchComputerName,
                    pchDomainName,
                    MP_YES ) != IDYES )
    {
        return NERR_Success;
    }

    NLS_STR nlsAccountName( pchComputerName );

    APIERR err = nlsAccountName.QueryError();

    if( fIsNT && ( err == NERR_Success ) )
    {
        NLS_STR nlsAccountPostfix;

        err = err ? err : nlsAccountPostfix.QueryError();
        err = err ? err : nlsAccountPostfix.MapCopyFrom( (TCHAR *)SSI_ACCOUNT_NAME_POSTFIX );
        err = err ? err : nlsAccountName.Append( nlsAccountPostfix );
    }

    if( err == NERR_Success )
    {
        USER user( nlsAccountName, pchDomainName );
        if (   (err = user.QueryError()) == NERR_Success
           )
        {
            AUTO_CURSOR cursor;
            err = user.Delete();
        }
    }

    if( err == NERR_UserNotFound )
    {
        //
        //  The "user" was not in the SAM database.  This is probably
        //  due to a non-member being displayed in the main window, and
        //  the user tried to remove it.  Display an informative message
        //  and pretend it never happened.
        //

        ::MsgPopup( hWndOwner,
                    fIsServer ? IDS_CANNOT_REMOVE_SERVER
                              : IDS_CANNOT_REMOVE_WKSTA,
                    MPSEV_WARNING,
                    MP_OK,
                    pchComputerName,
                    pchDomainName );

        err = NERR_Success;
    }
    else
    if( err == NERR_Success )
    {
        ::MsgPopup( hWndOwner,
                    fIsServer ? IDS_REMOVE_SERVER_DONE
                              : IDS_REMOVE_WKSTA_DONE,
                    MPSEV_INFO,
                    MP_OK,
                    pchComputerName );

        *pfForceRefresh = TRUE;
    }

    return err;

#endif // WIN32

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\hwprof.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    hwprof.hxx
    Class definitions for the HWPROFILE_DIALOG class.

    The SVC_HWPROFILE_DIALOG allows the user to enable and disable
    services and devices for specific hardware profiles.


    FILE HISTORY:
        JonN        11-Oct-1995 Created

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETDOMAIN
#define INCL_ICANON
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <strnumer.hxx> // for DEC_STR
#include <hwprof.hxx> // for SVC_HWPROFILE_DIALOG
#include <lmowks.hxx>
#include <lmosrvmo.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <mnet.h>
    #include <cfgmgr32.h>       // CM_ APIs
    #include <regstr.h>         // CSCONFIGFLAG_DISABLED

}   // extern "C"



//
//  HWPROF_LBI methods
//

/*******************************************************************

    NAME:           HWPROF_LBI :: HWPROF_LBI

    SYNOPSIS:       HWPROF_LBI class constructor.

    ENTRY:          pszProfileName      - The profile name.

                    pszDevinstName      - The devinst name.

                    OriginalState       - The original state of the service.

    EXIT:           The object is constructed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROF_LBI :: HWPROF_LBI( const TCHAR * pszProfileDisplayName,
                          ULONG         ulProfileIndex,
                          ULONG         OriginalState,
                          const TCHAR * pszDevinstName,
                          const TCHAR * pszDevinstDisplayName )
  : _ulOriginalState( OriginalState ),
    _ulCurrentState( OriginalState ),
    _ulProfileIndex( ulProfileIndex ),
    _nlsProfileDisplayName( pszProfileDisplayName ),
    _nlsDevinstName( pszDevinstName ),
    _nlsDevinstDisplayName( pszDevinstDisplayName )
{
    UIASSERT( pszProfileDisplayName != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if (   (err = _nlsProfileDisplayName.QueryError()) != NERR_Success
        || (err = _nlsDevinstName.QueryError()) != NERR_Success
        || (err = _nlsDevinstDisplayName.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

}   // HWPROF_LBI :: HWPROF_LBI


/*******************************************************************

    NAME:           HWPROF_LBI :: ~HWPROF_LBI

    SYNOPSIS:       HWPROF_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROF_LBI :: ~HWPROF_LBI()
{
    // nothing to do here

}   // HWPROF_LBI :: ~HWPROF_LBI


/*******************************************************************

    NAME:           HWPROF_LBI :: Paint

    SYNOPSIS:       Draw an entry in HWPROF_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
VOID HWPROF_LBI :: Paint( LISTBOX *      plb,
                          HDC            hdc,
                          const RECT   * prect,
                          GUILTT_INFO  * pGUILTT ) const
{
    STR_DTE dteStateName(
                ((HWPROF_LISTBOX *)plb)->MapStateToName( _ulCurrentState ) );
    STR_DTE dteProfileDisplayName( _nlsProfileDisplayName );
    STR_DTE dteDevinstDisplayName( _nlsDevinstDisplayName );

    DISPLAY_TABLE dtab( ((HWPROF_LISTBOX *)plb)->QueryNumColumns(),
                        ((HWPROF_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteStateName;
    dtab[1] = &dteProfileDisplayName;
    if ( ((HWPROF_LISTBOX *)plb)->QueryNumColumns() > 2 )
        dtab[2] = &dteDevinstDisplayName;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // HWPROF_LBI :: Paint


/*******************************************************************

    NAME:       HWPROF_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
WCHAR HWPROF_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsProfileDisplayName );

    return _nlsProfileDisplayName.QueryChar( istr );

}   // HWPROF_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       HWPROF_LBI :: Compare

    SYNOPSIS:   Compare two HWPROF_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
INT HWPROF_LBI :: Compare( const LBI * plbi ) const
{
    INT i = _nlsProfileDisplayName._stricmp( ((const HWPROF_LBI *)plbi)->_nlsProfileDisplayName );
    if ( i == 0 )
    {
        i = _nlsDevinstDisplayName._stricmp( ((const HWPROF_LBI *)plbi)->_nlsDevinstDisplayName );
    }

    return i;

}   // HWPROF_LBI :: Compare


/*******************************************************************

    NAME:       HWPROF_LBI :: SetEnabled

    SYNOPSIS:   Enables this device/service for this profile+devinst

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
VOID HWPROF_LBI :: SetEnabled()
{
    _ulCurrentState &= ~CSCONFIGFLAG_DISABLED;

}   // HWPROF_LBI :: Enable


/*******************************************************************

    NAME:       HWPROF_LBI :: SetDisabled

    SYNOPSIS:   Disables this device/service for this profile+devinst

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
VOID HWPROF_LBI :: SetDisabled()
{
    _ulCurrentState |= CSCONFIGFLAG_DISABLED;

}   // HWPROF_LBI :: Enable


/*******************************************************************

    NAME:       HWPROF_LBI :: QueryOriginalEnabled
                              QueryCurrentEnabled

    SYNOPSIS:   Asks whether this device/service is enabled for this
                profile+devinst

    HISTORY:
        JonN        19-Oct-1995 Created

********************************************************************/
BOOL HWPROF_LBI :: QueryOriginalEnabled() const
{
    return !(_ulOriginalState & CSCONFIGFLAG_DISABLED);

}   // HWPROF_LBI :: Enable

BOOL HWPROF_LBI :: QueryCurrentEnabled() const
{
    return !(_ulCurrentState & CSCONFIGFLAG_DISABLED);

}   // HWPROF_LBI :: Enable


//
//  HWPROF_LISTBOX methods
//

/*******************************************************************

    NAME:           HWPROF_LISTBOX :: HWPROF_LISTBOX

    SYNOPSIS:       HWPROF_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    fDisplayInstanceColumn - TRUE iff the Devinst column
                                             should be displayed

    EXIT:           The object is constructed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROF_LISTBOX :: HWPROF_LISTBOX( OWNER_WINDOW * powner,
                                  CID            cid,
                                  BOOL           fDisplayInstanceColumn )
  : BLT_LISTBOX( powner, cid ),
    _nlsEnabled( IDS_HWPROF_ENABLED ),
    _nlsDisabled( IDS_HWPROF_DISABLED ),
    _ulNumColumns( (fDisplayInstanceColumn) ? NUM_HWPROF_LISTBOX_COLUMNS
                                            : (NUM_HWPROF_LISTBOX_COLUMNS - 1) )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsEnabled.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsDisabled.QueryError()   ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     _ulNumColumns,
                                     powner,
                                     cid,
                                     FALSE );

}   // HWPROF_LISTBOX :: HWPROF_LISTBOX


/*******************************************************************

    NAME:           HWPROF_LISTBOX :: ~HWPROF_LISTBOX

    SYNOPSIS:       HWPROF_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROF_LISTBOX :: ~HWPROF_LISTBOX( VOID )
{
    // nothing to do here

}   // HWPROF_LISTBOX :: ~HWPROF_LISTBOX


/*******************************************************************

    NAME:           HWPROF_LISTBOX :: MapStateToName

    SYNOPSIS:       Maps a state value to a human readable
                    representation.

    ENTRY:          State               - The state to map.

    RETURNS:        const TCHAR *       - The name of the state.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
const TCHAR * HWPROF_LISTBOX :: MapStateToName( ULONG State ) const
{
    if (State & CSCONFIGFLAG_DISABLED)
        return _nlsDisabled.QueryPch();
    else
        return _nlsEnabled.QueryPch();

}   // HWPROF_LISTBOX :: MapStateToName



//
//  HWPROFILE_DIALOG methods
//

/*******************************************************************

    NAME:           HWPROFILE_DIALOG :: HWPROFILE_DIALOG

    SYNOPSIS:       HWPROFILE_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszServerName       - The API name for the target server.

                    pszSrvDspName       - The target server's display name.

                    pszServiceName      - The name of the target service.

                    pszDisplayName      - The display name of the
                                          target service.

                    hCfgMgrHandle       - The CFGMGR32 handle obtained by
                                          the parent dialog

                    fDeviceCaptions     - TRUE iff the dialog configures
                                          a device as opposed to a service.

    EXIT:           The object is constructed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROFILE_DIALOG :: HWPROFILE_DIALOG( HWND          hWndOwner,
                                      const TCHAR * pszServerName,
                                      const TCHAR * pszSrvDspName,
                                      const TCHAR * pszServiceName,
                                      const TCHAR * pszDisplayName,
                                      HANDLE        hCfgMgrHandle,
                                      BOOL          fDeviceCaptions )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_HWPROFILE_DIALOG ), hWndOwner ),
    _sltServiceName( this, IDHW_SVC_OR_DEV_NAME ),
    _sltServiceDeviceCaption( this, IDHW_SVC_OR_DEV ),
    _sltInstanceHeading( this, IDHW_DEVINST_LABEL ),
    _plbProfiles( NULL ),
    _pbEnable( this, IDHW_ENABLE ),
    _pbDisable( this, IDHW_DISABLE ),
    _sltDescriptionHeading( this, IDHW_DESCRIPTION_LABEL),
    _sleDescription( this, IDHW_DESCRIPTION),
    _pszServerName( pszServerName ),
    _pszSrvDspName( pszSrvDspName ),
    _pszServiceName( pszServiceName ),
    _pszDisplayName( pszDisplayName ),
    _hCfgMgrHandle( hCfgMgrHandle ),
    _cDevinst( 0 ),
    _fDeviceCaptions( fDeviceCaptions )
{
    UIASSERT( pszSrvDspName != NULL );
    UIASSERT( pszServiceName != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        //
        //  Set the dialog caption.
        //

        err = SetCaption( _pszSrvDspName, pszDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Setup the dialog controls.
        //

        if (_fDeviceCaptions)
        {
            RESOURCE_STR resstrCaption( IDS_DEVICE_CAPTION );
            if ( (err = resstrCaption.QueryError()) != NERR_Success )
            {
                ReportError( err );
                return;
            }
            _sltServiceDeviceCaption.SetText( resstrCaption );
        }
        _sltServiceName.SetText( _pszDisplayName );
        err = CreateListbox();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // HWPROFILE_DIALOG :: HWPROFILE_DIALOG


/*******************************************************************

    NAME:           HWPROFILE_DIALOG :: ~HWPROFILE_DIALOG

    SYNOPSIS:       HWPROFILE_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
HWPROFILE_DIALOG :: ~HWPROFILE_DIALOG( VOID )
{
    delete _plbProfiles;
    _plbProfiles = NULL;
    _pszServerName = NULL;
    _pszSrvDspName = NULL;
    _pszServiceName = NULL;
    _pszDisplayName = NULL;

}   // HWPROFILE_DIALOG :: ~HWPROFILE_DIALOG


/*******************************************************************

    NAME:           HWPROFILE_DIALOG :: SetCaption

    SYNOPSIS:       Worker method called during construction to
                    setup the dialog caption.

    ENTRY:          pszServerName       - The name of the target server.

                    pszServiceName      - The name of the target service.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
APIERR HWPROFILE_DIALOG :: SetCaption( const TCHAR * pszServerName,
                                       const TCHAR * pszServiceName )
{
    UIASSERT( pszServerName  != NULL );
    UIASSERT( pszServiceName != NULL );

    //
    //  Kruft up some NLS_STRs for our input parameters.
    //
    //  Note that the server name (should) still have the
    //  leading backslashes (\\).  They are not to be displayed.
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

    ALIAS_STR nlsServiceName( pszServiceName );
    UIASSERT( nlsServiceName.QueryError() == NERR_Success );

#ifdef  DEBUG
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( nlsServerName );

        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
        ++istrDbg;
        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
    }
#endif  // DEBUG

    //
    //  Skip the backslashes.
    //
    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    //
    //  The insert strings for Load().
    //

    const NLS_STR * apnlsParams[3];

    apnlsParams[0] = &nlsWithoutPrefix;
    apnlsParams[1] = NULL;

    //
    //  Load the caption string.
    //

    NLS_STR nlsCaption;

    APIERR err = nlsCaption.QueryError();

    if( err == NERR_Success )
    {
        nlsCaption.Load( _fDeviceCaptions ? IDS_CAPTION_DEVCFG
                                          : IDS_CAPTION_SVCCFG );
        nlsCaption.InsertParams( apnlsParams );

        err = nlsCaption.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Set the caption.
        //

        _sltServiceName.SetText( nlsServiceName );
        SetText( nlsCaption );
    }

    return err;

}   // HWPROFILE_DIALOG :: SetCaption


#define DEVINSTPROP_INITIAL_SIZE (1024*sizeof(TCHAR))

/*******************************************************************

    NAME:           HWPROF_DIALOG :: CreateListbox

    SYNOPSIS:       Creates the listbox and fills it with the available
                    hardware profiles and devinsts.

    EXIT:           The listbox is created and filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
APIERR HWPROFILE_DIALOG :: CreateListbox( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Construct our service enumerator.
    //

    APIERR err = NERR_Success;

    do { // false loop

        ULONG cch = 0;
        CONFIGRET configret = ::CM_Get_Device_ID_List_Size_Ex(
                          &cch,
                          _pszServiceName,
                          CM_GETIDLIST_FILTER_SERVICE,
                          _hCfgMgrHandle );
        if ( (err = MapCfgMgr32Error( configret )) != NERR_Success )
        {
            TRACEEOL("SRVMGR: Get_Device_ID_List_Size returned " << configret );
            if (configret == CR_NO_SUCH_VALUE)
            {
                err = (_fDeviceCaptions) ? IDS_HWPROF_DEVICE_NOT_CONFIGURABLE
                                         : IDS_HWPROF_SERVICE_NOT_CONFIGURABLE;
            }
            break;
        }

        BUFFER bufDeviceIDs( cch*sizeof(TCHAR) );
        if ( (err = bufDeviceIDs.QueryError()) != NERR_Success )
            break;
        do {
            configret = ::CM_Get_Device_ID_List_Ex(
                          _pszServiceName,
                          (TCHAR *)(bufDeviceIDs.QueryPtr()),
                          bufDeviceIDs.QuerySize() / sizeof(TCHAR),
                          CM_GETIDLIST_FILTER_SERVICE,
                          _hCfgMgrHandle );
            if (configret == CR_BUFFER_SMALL)
            {
                cch *= 2;
                if ( (err = bufDeviceIDs.Resize(cch*sizeof(TCHAR))) != NERR_Success )
                    break;
            } else if (configret == CR_NO_SUCH_VALUE)
            {
                err = (_fDeviceCaptions) ? IDS_HWPROF_DEVICE_NOT_CONFIGURABLE
                                         : IDS_HWPROF_SERVICE_NOT_CONFIGURABLE;
            }
        } while (configret == CR_BUFFER_SMALL);

        if (   err != NERR_Success
            || (err = MapCfgMgr32Error( configret )) != NERR_Success
           )
        {
            TRACEEOL("SRVMGR: Get_Device_ID_List returned " << configret );
            break;
        }

        STRLIST slDeviceIDs( (PTCHAR)(bufDeviceIDs.QueryPtr()), TCH('\0') );

        //
        //  count device IDs
        //
        _cDevinst = 0;
        {
            const TCHAR * pchDeviceID = (const TCHAR *)bufDeviceIDs.QueryPtr();
            while ( *pchDeviceID != TCH('\0') )
            {
                _cDevinst += 1;
                pchDeviceID += ::strlenf(pchDeviceID) + 1;
            }
        }
        ASSERT( _cDevinst > 0 );

        BUFFER bufDeviceIDPointers( _cDevinst * sizeof(TCHAR *) );
        if ( (err = bufDeviceIDPointers.QueryError()) != NERR_Success )
            break;
        const TCHAR ** apchDeviceID = (const TCHAR **)bufDeviceIDPointers.QueryPtr();
        {
            const TCHAR * pchDeviceID = (const TCHAR *)bufDeviceIDs.QueryPtr();
            for ( UINT iDevinst = 0; iDevinst < _cDevinst; iDevinst++ )
            {
                apchDeviceID[iDevinst] = pchDeviceID;
                pchDeviceID += ::strlenf(pchDeviceID) + 1;
            }
        }

        //
        //  Get device display names
        //
        STRLIST slDevinstDisplay;
        {
            BUFFER bufDevinstDisplay( DEVINSTPROP_INITIAL_SIZE );
            if ( (err = bufDevinstDisplay.QueryError()) != NERR_Success )
                break;
            ULONG cbBuflen;
            for (UINT iDevinst = 0; iDevinst < _cDevinst; iDevinst++ )
            {
                // no need to free devinst handles
                DEVINST devinst = NULL;

                configret = ::CM_Locate_DevNode_Ex(
                                &devinst,
                                (DEVINSTID)(apchDeviceID[iDevinst]),
                                CM_LOCATE_DEVNODE_PHANTOM,
                                _hCfgMgrHandle );
                if ( (err = MapCfgMgr32Error( configret )) != NERR_Success )
                {
                    TRACEEOL("SRVMGR: Locate_DevNode returned " << configret );
                    break;
                }

                cbBuflen = bufDevinstDisplay.QuerySize();
                BOOL fFriendlyName = TRUE;
                configret = ::CM_Get_DevNode_Registry_Property_Ex(
                                devinst,
                                CM_DRP_FRIENDLYNAME,
                                NULL,
                                bufDevinstDisplay.QueryPtr(),
                                &cbBuflen,
                                0x0,
                                _hCfgMgrHandle );
                if (   configret == CR_NO_SUCH_VALUE
                    || configret == CR_INVALID_PROPERTY )
                {
                    TRACEEOL("SRVMGR: no friendly name for devinst " << iDevinst );
                    fFriendlyName = FALSE;
                    cbBuflen = bufDevinstDisplay.QuerySize();
                    configret = ::CM_Get_DevNode_Registry_Property_Ex(
                                    devinst,
                                    CM_DRP_DEVICEDESC,
                                    NULL,
                                    bufDevinstDisplay.QueryPtr(),
                                    &cbBuflen,
                                    0x0,
                                    _hCfgMgrHandle );
                }
                if (configret == CR_BUFFER_SMALL)
                {
                    if ( (err = bufDevinstDisplay.Resize( cbBuflen+10 )) != NERR_Success )
                        break;
                    cbBuflen = bufDevinstDisplay.QuerySize();
                    configret = ::CM_Get_DevNode_Registry_Property_Ex(
                                    devinst,
                                    (fFriendlyName) ? CM_DRP_FRIENDLYNAME
                                                    : CM_DRP_DEVICEDESC,
                                    NULL,
                                    bufDevinstDisplay.QueryPtr(),
                                    &cbBuflen,
                                    0x0,
                                    _hCfgMgrHandle );
                }
                const TCHAR * pchDescription = NULL;
                if (configret == CR_SUCCESS) {
                    pchDescription = (const TCHAR *)bufDevinstDisplay.QueryPtr();
                } else if (   configret == CR_NO_SUCH_VALUE
                           || configret == CR_INVALID_PROPERTY ) {
                    ASSERT( FALSE ); // they should all have a description
                    pchDescription = apchDeviceID[iDevinst];
                } else {
                    TRACEEOL("SRVMGR: Get_DevNode_Registry_Property returned " << configret );
                    err = MapCfgMgr32Error( configret );
                    ASSERT( err != NERR_Success );
                    break;
                }
                NLS_STR * pnlsNew = new NLS_STR( pchDescription );
                if ( (err = slDevinstDisplay.Append( pnlsNew )) != NERR_Success )
                    break;
            }
            if (err != NERR_Success)
                break;
        }

        _plbProfiles = new HWPROF_LISTBOX( this, IDHW_PROFILES, (_cDevinst > 1) );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _plbProfiles == NULL
            || (err = _plbProfiles->QueryError()) != NERR_Success
           )
        {
            TRACEEOL("SRVMGR: HWPROF listbox alloc returned " << err );
            break;
        }

        if (_cDevinst <= 1)
        {
            // disable listbox heading and description text and heading
            (void) _sltInstanceHeading.Show( FALSE );
            (void) _sltDescriptionHeading.Show( FALSE );
            (void) _sleDescription.Enable( FALSE );
            (void) _sleDescription.Show( FALSE );

            // resize dialog
            XYPOINT xyListboxPos = _plbProfiles->QueryPos();
            XYDIMENSION xyListboxSize = _plbProfiles->QuerySize();
            XYPOINT xyDescriptionPos = _sltDescriptionHeading.QueryPos();
            XYDIMENSION xyDescriptionSize = _sltDescriptionHeading.QuerySize();
            XYDIMENSION xyDialogSize = this->QuerySize();
            xyDialogSize.SetHeight(   xyDialogSize.QueryHeight()
                                    + (  xyListboxPos.QueryY()
                                       + xyListboxSize.QueryHeight() )
                                    - (  xyDescriptionPos.QueryY()
                                       + xyDescriptionSize.QueryHeight() )
                                  );
            this->SetSize( xyDialogSize, FALSE );

        }

        HWPROFILEINFO hwprofinfo;
        ULONG iProfileIndex = 0;
        do {
            configret = ::CM_Get_Hardware_Profile_Info_Ex(
                                iProfileIndex++,
                                &hwprofinfo,
                                0x0,
                                _hCfgMgrHandle );
            if (configret == CR_SUCCESS)
            {
                ITER_STRLIST iterslDevinstDisplay( slDevinstDisplay );
                NLS_STR * pnlsDevinstDisplay;
                for (UINT iDevinst = 0; iDevinst < _cDevinst; iDevinst++ )
                {
                    ULONG ulValue = 0;
                    configret = ::CM_Get_HW_Prof_Flags_Ex(
                                (DEVINSTID)(apchDeviceID[iDevinst]),
                                hwprofinfo.HWPI_ulHWProfile,
                                &ulValue,
                                0x0,
                                _hCfgMgrHandle );
                    if ( (err = MapCfgMgr32Error( configret )) != NERR_Success )
                    {
                        TRACEEOL(   "SRVMGR: Get_HW_Prof_Flags( \""
                                 << apchDeviceID[iDevinst] << "\", "
                                 << hwprofinfo.HWPI_ulHWProfile
                                 << " ) returned " << configret );
                        break;
                    }

                    REQUIRE( (pnlsDevinstDisplay =
                                        iterslDevinstDisplay.Next()) != NULL );

                    //
                    // If this profile/devinst combo is marked as REMOVED
                    // then don't display this.
                    //
                    if (ulValue & CSCONFIGFLAG_DO_NOT_CREATE)
                        continue;

                    HWPROF_LBI * plbi = new HWPROF_LBI(
                            hwprofinfo.HWPI_szFriendlyName,
                            hwprofinfo.HWPI_ulHWProfile,
                            ulValue,
                            apchDeviceID[iDevinst],
                            pnlsDevinstDisplay->QueryPch() );
                    if ( _plbProfiles->AddItem( plbi ) < 0 )
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }
                if (err != NERR_Success)
                    break;
                ASSERT( iterslDevinstDisplay.Next() == NULL );
            } else if (configret == CR_NO_MORE_HW_PROFILES
                    || configret == CR_NO_SUCH_VALUE)
            {
                configret = CR_SUCCESS;
                break;
            }
            else
            {
                TRACEEOL(   "SRVMGR: Get_Hardware_Profile_Info( "
                         << iProfileIndex-1
                         << " ) returned " << configret );
                err = MapCfgMgr32Error( configret );
                ASSERT( err != NERR_Success );
                break;
            }
        } while (configret == CR_SUCCESS);

    } while (FALSE); // false loop

    if (err == NERR_Success)
    {
        ASSERT( _plbProfiles != NULL );
        if (_plbProfiles->QueryCount() > 0)
            _plbProfiles->SelectItem( 0 );
        UpdateButtons();
    }

    //
    //  Finished!
    //

    return err;

}   // HWPROF_DIALOG :: CreateListbox


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: GetHandle
                HWPROFILE_DIALOG :: ReleaseHandle

    SYNOPSIS:   Claims and releases a Configuration Manager handle.
                The Services and Devices dialogs use GetHandle to
                determine whether to enable the HW Profiles button.

    NOTES:      There is currently bug 13610 where CM_Connect_Machine(NULL)
                returns success even when the Plug and Play service
                is not running.  This will cause the HW Profiles button
                to be enabled in the Services and Devices applets
                even when it shouldn't be enabled.

    HISTORY:
        JonN        13-Oct-1995 Created

********************************************************************/
APIERR HWPROFILE_DIALOG::GetHandle( const TCHAR * pszServerName,
                                    HANDLE * phandle )
{
    ASSERT( phandle != NULL );
    CONFIGRET configret = ::CM_Connect_Machine( pszServerName, phandle );
    TRACEEOL( "SRVMGR: CM_Connect_Machine returned " << configret << ", handle " << (UINT)(*phandle) );
    APIERR err = MapCfgMgr32Error( configret );
    ASSERT( err != NERR_Success || *phandle != NULL );
    return err;
}   // HWPROFILE_DIALOG :: GetHandle

VOID HWPROFILE_DIALOG::ReleaseHandle( HANDLE * phandle )
{
    ASSERT( phandle != NULL );
    if ( *phandle != NULL )
    {
        CONFIGRET configret = ::CM_Disconnect_Machine( *phandle );
        TRACEEOL( "SRVMGR: CM_Disconnect_Machine returned " << configret );
        ASSERT( configret == CR_SUCCESS );
        *phandle = NULL;
    }
}   // HWPROFILE_DIALOG :: ReleaseHandle


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: MapCfgMgr32Error

    SYNOPSIS:   This method returns an equivalent APIERR error number for
                error processing and reporting.

    HISTORY:
        JonN        16-Oct-1995 Created

********************************************************************/
APIERR HWPROFILE_DIALOG::MapCfgMgr32Error( DWORD dwCfgMgr32Error )
{
    APIERR err = IDS_CFGMGR32_BASE + dwCfgMgr32Error;
    switch (dwCfgMgr32Error)
    {

        case CR_SUCCESS              :
        // CR_NEED_RESTART is considered to be Success
        case CR_NEED_RESTART         :
            err = NERR_Success;
            break;

        case CR_OUT_OF_MEMORY        :
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;

        //
        //  These are supposedly for Windows 95 only!
        //
        case CR_INVALID_ARBITRATOR   :
        case CR_INVALID_NODELIST     :
        case CR_DLVXD_NOT_FOUND      :
        case CR_NOT_SYSTEM_VM        :
        case CR_NO_ARBITRATOR        :
        case CR_DEVLOADER_NOT_READY  :
            ASSERT( FALSE );
            // fall through

        default                      :
            break;
    }

    return err;

}   // HWPROFILE_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: UpdateButtons

    SYNOPSIS:   Enables/disables the Enable and Disable buttons.

    HISTORY:
        JonN        19-Oct-1995 Created

********************************************************************/
VOID HWPROFILE_DIALOG :: UpdateButtons( BOOL fToggle )
{
    ASSERT( _plbProfiles != NULL );
    BOOL fAllowEnable  = FALSE;
    BOOL fAllowDisable = FALSE;
    INT iItem = _plbProfiles->QueryCurrentItem();
    if (iItem >= 0)
    {
        HWPROF_LBI * plbi = _plbProfiles->QueryItem( iItem );
        ASSERT( plbi != NULL && plbi->QueryError() == NERR_Success );
        if( plbi == NULL || plbi->QueryError() != NERR_Success )
            return; // JonN 01/28/00: PREFIX bug 444931
        if (_cDevinst > 1)
        {
            (void) _sleDescription.SetText( plbi->QueryDevinstDisplayName() );
        }

        if ( fToggle )
        {
            if ( plbi->QueryCurrentEnabled() )
                plbi->SetDisabled();
            else
                plbi->SetEnabled();
            _plbProfiles->Invalidate();
        }
        if ( plbi->QueryCurrentEnabled() )
            fAllowDisable = TRUE;
        else
            fAllowEnable = TRUE;
    }
    _pbEnable.Enable(  fAllowEnable );
    _pbDisable.Enable( fAllowDisable );

}   // HWPROFILE_DIALOG :: UpdateButtons


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
BOOL HWPROFILE_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    BOOL fResult = FALSE;

    switch( event.QueryCid() )
    {
    case IDHW_PROFILES:
        switch ( event.QueryCode() )
        {
        case LBN_DBLCLK:
            UpdateButtons(TRUE);
            fResult = TRUE;
            break;
        case LBN_SELCHANGE:
            UpdateButtons(FALSE);
            fResult = TRUE;
            break;
        default:
            break;
        }
        break;

    case IDHW_ENABLE:
    case IDHW_DISABLE:
        UpdateButtons(TRUE);
        fResult = TRUE;
        break;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        break;
    }

    return fResult;

}   // HWPROFILE_DIALOG :: OnCommand


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: OnOK

    SYNOPSIS:   Dismiss the dialog when the user presses OK.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
BOOL HWPROFILE_DIALOG :: OnOK( VOID )
{
    ASSERT( _plbProfiles != NULL && _plbProfiles->QueryError() == NERR_Success );
    APIERR err = NERR_Success;
    UINT cLBIs = _plbProfiles->QueryCount();
    for ( UINT iLBI = 0; iLBI < cLBIs; iLBI++ )
    {
        HWPROF_LBI * plbi = _plbProfiles->QueryItem( iLBI );
        ASSERT( plbi != NULL && plbi->QueryError() == NERR_Success );
        if( plbi == NULL || plbi->QueryError() != NERR_Success )
            continue; // JonN 01/28/00: PREFIX bug 444932
        BOOL fCurrentState = plbi->QueryCurrentEnabled();
        if ( fCurrentState == plbi->QueryOriginalEnabled() )
            continue;

        //
        //  We must now change the state of the profile/devinst
        //

        CONFIGRET configret = ::CM_Set_HW_Prof_Flags_Ex(
                        (DEVINSTID)(plbi->QueryDevinstName()),
                        plbi->QueryProfileIndex(),
                        plbi->QueryCurrentState(),
                        0x0,
                        _hCfgMgrHandle );
        //
        // This is liable to return CR_NEED_RESTART, the mapping function
        // changes this to NERR_Success.
        //
        err = MapCfgMgr32Error( configret );
        if ( err != NERR_Success )
        {
            TRACEEOL("SRVMGR: Set_HW_Prof_Flags returned " << configret );
            MSGID msgid = (plbi->QueryCurrentEnabled())
                ? ( (_fDeviceCaptions) ? IDS_HWPROF_ENABLE_DEVICE_ERROR
                                       : IDS_HWPROF_ENABLE_SERVICE_ERROR )
                : ( (_fDeviceCaptions) ? IDS_HWPROF_DISABLE_DEVICE_ERROR
                                       : IDS_HWPROF_DISABLE_SERVICE_ERROR );

            ALIAS_STR nlsProfileName( plbi->QueryProfileDisplayName() );
            // We don't bother with the devinst name in the error message
            ALIAS_STR nlsServiceName( _pszDisplayName );
            DEC_STR nlsCM_Error( configret );
            NLS_STR *apnlsParamStrings[4];
            apnlsParamStrings[0] = &nlsServiceName;
            apnlsParamStrings[1] = &nlsProfileName;
            apnlsParamStrings[2] = &nlsCM_Error;
            apnlsParamStrings[3] = NULL;

            //
            //  CODEWORK -- we could get fancy here and allow
            //  optional continuation
            //
            (void) MsgPopup(
                this,
                msgid,
                err,
                MPSEV_ERROR,
                (UINT)HC_NO_HELP,
                MP_OK,
                apnlsParamStrings
                ) ;

            return TRUE; // do not Dismiss
        }

    }

    Dismiss( FALSE ); // BUGBUG do we ever need to refresh parent?
    return TRUE;

}   // HWPROFILE_DIALOG :: OnOK


/*******************************************************************

    NAME:       HWPROFILE_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
ULONG HWPROFILE_DIALOG :: QueryHelpContext( VOID )
{
    return HC_SVC_HWPROFILE_DLG;

}   // HWPROFILE_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       DEV_HWPROFILE_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        JonN        11-Oct-1995 Created

********************************************************************/
ULONG DEV_HWPROFILE_DIALOG :: QueryHelpContext( VOID )
{
    return HC_DEV_HWPROFILE_DLG;

}   // HWPROFILE_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\lmdomain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmdomain.cxx
    Class definitions for the LM_DOMAIN class.

    The LM_DOMAIN class represents a network domain.  This class is used
    primarily for performing domain role transitions and resyncing servers
    with their Primary.


    FILE HISTORY:
        KeithMo     30-Sep-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     21-Oct-1991 Remove direct LanMan API calls.
        KeithMo     04-Nov-1991 Added ResyncServer() code.
*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETDOMAIN
#define INCL_ICANON
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

extern "C"
{
    #include <stdlib.h>     // rand(), srand()
    #include <time.h>       // clock()

    #include <lmaccess.h>
    #include <mnet.h>

    #include <crypt.h>          // required by logonmsv.h
    #include <logonmsv.h>       // required by ssi.h
    #include <ssi.h>            // for SSI_ACCOUNT_NAME_POSTFIX

    #include <bltrc.h>
    #include <srvmgr.h>

}   // extern "C"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <lmosrv.hxx>
#include <lmosrvmo.hxx>
#include <lmdomain.hxx>
#include <svcman.hxx>
#include <ntuser.hxx>
#include <uintlsax.hxx>
#include <addcomp.hxx>


//
//  This is the amount of time to "fake" activity after a domain
//  role transition has completed.  This will give NetLogon & the
//  Browser some time to quiesce after the fireworks are over.
//

#define FAKE_ACTIVITY_PERIOD  2000      // milliseconds


//
//  This is the key name of the NetLogon service.
//

const TCHAR * _pszNetLogonKeyName = (const TCHAR *)SERVICE_NETLOGON;


//
//  The major operations of this class, SetPrimary() and ResyncServer(),
//  are quite lengthy.  Because of their length, they could cause problems
//  for the 16-bit DOS Windows environment (WIN16).  To lessen their impact
//  on the WIN16 environment, these operations are implemented as finite
//  state machines.
//
//  These ENUMs represent the various states for the SetPrimary() and
//  ResyncServer() operations.  States that start with the SPS_ prefix
//  are relevant to the SetPrimary() operation.  States that start with
//  the RSS_ prefix are relevant to the ResyncServer() operation.  Those
//  states that end in _RB are used to "rollback" from error conditions.
//

typedef enum _SETPRIMARYSTATES
{
    SPS_Invalid = -1,

    SPS_First = 0,                  // Must always be first state!

    SPS_NewResyncSamInit,           // Initiating SAM resync.
    SPS_NewResyncSamWait,           // Waiting for SAM resync to complete.
    SPS_NewStopInit,                // About to stop NewPrimary's NetLogon.
    SPS_NewStopWait,                // Waiting for NetLogon to stop.
    SPS_OldStopInit,                // About to stop OldPrimary's NetLogon.
    SPS_OldStopWait,                // Waiting for NetLogon to stop.
    SPS_OldSetModals,               // About to set OldPrimary to Server.
    SPS_NewSetModals,               // About to set NewPrimary to Primary.
    SPS_OldStartInit,               // About to start OldPrimary's NetLogon.
    SPS_OldStartWait,               // Waiting for NetLogon to start.
    SPS_NewStartInit,               // About to start NewPrimary's NetLogon.
    SPS_NewStartWait,               // Waiting for NetLogon to start.
    SPS_FakeActivity,               // Fake activity so things settle down.

    SPS_OldStopInit_RB,             // About to stop OldPrimary's NetLogon.
    SPS_OldStopWait_RB,             // Waiting for NetLogon to stop.
    SPS_NewSetModals_RB,            // About to set NewPrimary to Server.
    SPS_OldSetModals_RB,            // About to set OldPrimary to Primary
    SPS_OldStartInit_RB,            // About to start OldPrimary's NetLogon.
    SPS_OldStartWait_RB,            // Waiting for NetLogon to start.
    SPS_NewStartInit_RB,            // About to start NewPrimary's NetLogon.
    SPS_NewStartWait_RB,            // Waiting for NetLogon to start.

    SPS_FirstTerminal,              // Not actually a state, but marks
                                    // the boundary between action
                                    // states and terminal states.

    SPS_Abort,                      // Early failure, no rollback.
    SPS_Success,                    // Successful server promotion.
    SPS_Terminate,                  // Terminated, but promotion complete.
    SPS_Terminate_RB,               // Rollback terminated, no promotion.
    SPS_Trouble,                    // *Really* bad news...

    SPS_Last                        // Must always be last state!

} SETPRIMARYSTATES;


typedef enum _RESYNCSERVERSTATES
{
    RSS_Invalid = -1,

    RSS_First = 0,                  // Must always be first state!

    RSS_ServerGetModals,            // About to retrieve current modals.
    RSS_ServerStopInit,             // About to stop server's NetLogon.
    RSS_ServerStopWait,             // Waiting for NetLogon to stop.
    RSS_ServerSetModals,            // About to set server to Primary.
    RSS_ChangePwdAtServer,          // About to change password @ server.
    RSS_ChangePwdAtPrimary,         // About to change password @ Primary.
    RSS_ServerResetModals,          // About to reset server to server.
    RSS_ServerStartInit,            // About to start server's NetLogon.
    RSS_ServerStartWait,            // Waiting for NetLogon to start.

    RSS_ServerResetModals_RB,       // About to reset server to server.
    RSS_ServerStartInit_RB,         // About to start server's NetLogon.
    RSS_ServerStartWait_RB,         // Waiting for NetLogon to start.

    RSS_FirstTerminal,              // Not actually a state, but marks
                                    // the boundary between action
                                    // states and terminal state.

    RSS_Abort,                      // Early failure, no rollback.
    RSS_Success,                    // Successful server resync.
    RSS_Terminate,                  // Terminated, resync partially complete.
    RSS_Terminate_RB,               // Rollback terminate, no resync.

    RSS_Last                        // Must always be last state!

} RESYNCSERVERSTATES;


//
//  This ENUM represents the current operation in progress.  This is
//  used to prevent multiple invocations of SetPrimary() or ResyncServer().
//

typedef enum _OPERATION
{
    OP_First = 0,                   // Must always be first state!

    OP_Idle,                        // No operation currently in progress.
    OP_SetPrimary,                  // Processing SetPrimary request.
    OP_ResyncServer,                // Processing ResyncServer request.

    OP_Last                         // Must always be last state!

} OPERATION;


//
//  These arrays contains the SetPrimary() state transitions which
//  occur after a successful API.
//

SETPRIMARYSTATES    NtSetPrimarySuccess[] =
                        // target state         // source state
                    {
                        SPS_Invalid,            // SPS_First
                        SPS_NewResyncSamWait,   // SPS_NewResyncSamInit
                        SPS_NewStopInit,        // SPS_NewResyncSamWait
                        SPS_NewStopWait,        // SPS_NewStopInit
                        SPS_OldStopInit,        // SPS_NewStopWait
                        SPS_OldStopWait,        // SPS_OldStopInit
                        SPS_OldSetModals,       // SPS_OldStopWait
                        SPS_NewSetModals,       // SPS_OldSetModals
                        SPS_OldStartInit,       // SPS_NewSetModals
                        SPS_OldStartWait,       // SPS_OldStartInit
                        SPS_NewStartInit,       // SPS_OldStartWait
                        SPS_NewStartWait,       // SPS_NewStartInit
                        SPS_FakeActivity,       // SPS_NewStartWait
                        SPS_Success,            // SPS_FakeActivity
                        SPS_OldStopWait_RB,     // SPS_OldStopInit_RB
                        SPS_NewSetModals_RB,    // SPS_OldStopWait_RB
                        SPS_OldSetModals_RB,    // SPS_NewSetModals_RB
                        SPS_OldStartInit_RB,    // SPS_OldSetModals_RB
                        SPS_OldStartWait_RB,    // SPS_OldStartInit_RB
                        SPS_NewStartInit_RB,    // SPS_OldStartWait_RB
                        SPS_NewStartWait_RB,    // SPS_NewStartInit_RB
                        SPS_Terminate_RB,       // SPS_NewStartWait_RB
                        SPS_Invalid,            // SPS_FirstTerminal
                        SPS_Invalid,            // SPS_Abort
                        SPS_Invalid,            // SPS_Success
                        SPS_Invalid,            // SPS_Terminate
                        SPS_Invalid,            // SPS_Terminate_RB
                        SPS_Invalid,            // SPS_Trouble
                        SPS_Invalid             // SPS_Last
                    };

SETPRIMARYSTATES    LmSetPrimarySuccess[] =
                        // target state         // source state
                    {
                        SPS_Invalid,            // SPS_First
                        SPS_Invalid,            // SPS_NewResyncSamInit
                        SPS_Invalid,            // SPS_NewResyncSamWait
                        SPS_NewStopWait,        // SPS_NewStopInit
                        SPS_NewSetModals,       // SPS_NewStopWait
                        SPS_OldStopWait,        // SPS_OldStopInit
                        SPS_NewStartInit,       // SPS_OldStopWait
                        SPS_OldStartInit,       // SPS_OldSetModals
                        SPS_OldStopInit,        // SPS_NewSetModals
                        SPS_OldStartWait,       // SPS_OldStartInit
                        SPS_FakeActivity,       // SPS_OldStartWait
                        SPS_NewStartWait,       // SPS_NewStartInit
                        SPS_OldSetModals,       // SPS_NewStartWait
                        SPS_Success,            // SPS_FakeActivity
                        SPS_Invalid,            // SPS_OldStopInit_RB
                        SPS_Invalid,            // SPS_OldStopWait_RB
                        SPS_NewStartInit_RB,    // SPS_NewSetModals_RB
                        SPS_Invalid,            // SPS_OldSetModals_RB
                        SPS_OldStartWait_RB,    // SPS_OldStartInit_RB
                        SPS_NewSetModals_RB,    // SPS_OldStartWait_RB
                        SPS_NewStartWait_RB,    // SPS_NewStartInit_RB
                        SPS_Terminate_RB,       // SPS_NewStartWait_RB
                        SPS_Invalid,            // SPS_FirstTerminal
                        SPS_Invalid,            // SPS_Abort
                        SPS_Invalid,            // SPS_Success
                        SPS_Invalid,            // SPS_Terminate
                        SPS_Invalid,            // SPS_Terminate_RB
                        SPS_Invalid,            // SPS_Trouble
                        SPS_Invalid             // SPS_Last
                    };


//
//  These arrays contains the SetPrimary() state transitions which
//  occur after a failed API.
//

SETPRIMARYSTATES    NtSetPrimaryFailure[] =
                        // target state         // source state
                    {
                        SPS_Invalid,            // SPS_First
                        SPS_Abort,              // SPS_NewResyncSamInit
                        SPS_Abort,              // SPS_NewResyncSamWait
                        SPS_NewStartInit_RB,    // SPS_NewStopInit
                        SPS_NewStartInit_RB,    // SPS_NewStopWait
                        SPS_OldStartInit_RB,    // SPS_OldStopInit
                        SPS_OldStartInit_RB,    // SPS_OldStopWait
                        SPS_OldStartInit_RB,    // SPS_OldSetModals
                        SPS_OldSetModals_RB,    // SPS_NewSetModals
                        SPS_OldStopInit_RB,     // SPS_OldStartInit
                        SPS_OldStopInit_RB,     // SPS_OldStartWait
                        SPS_OldStopInit_RB,     // SPS_NewStartInit
                        SPS_OldStopInit_RB,     // SPS_NewStartWait
                        SPS_Terminate,          // SPS_FakeActivity
                        SPS_Trouble,            // SPS_OldStopInit_RB
                        SPS_Trouble,            // SPS_OldStopWait_RB
                        SPS_Trouble,            // SPS_NewSetModals_RB
                        SPS_Trouble,            // SPS_OldSetModals_RB
                        SPS_Trouble,            // SPS_OldStartInit_RB
                        SPS_Trouble,            // SPS_OldStartWait_RB
                        SPS_Terminate_RB,       // SPS_NewStartInit_RB
                        SPS_Terminate_RB,       // SPS_NewStartWait_RB
                        SPS_Invalid,            // SPS_FirstTerminal
                        SPS_Invalid,            // SPS_Abort
                        SPS_Invalid,            // SPS_Success
                        SPS_Invalid,            // SPS_Terminate
                        SPS_Invalid,            // SPS_Terminate_RB
                        SPS_Invalid,            // SPS_Trouble
                        SPS_Invalid             // SPS_Last
                    };

SETPRIMARYSTATES    LmSetPrimaryFailure[] =
                        // target state         // source state
                    {
                        SPS_Invalid,            // SPS_First
                        SPS_Invalid,            // SPS_NewResyncSamInit
                        SPS_Invalid,            // SPS_NewResyncSamWait
                        SPS_NewStartInit_RB,    // SPS_NewStopInit
                        SPS_NewStartInit_RB,    // SPS_NewStopWait
                        SPS_NewSetModals_RB,    // SPS_OldStopInit
                        SPS_NewSetModals_RB,    // SPS_OldStopWait
                        SPS_Terminate,          // SPS_OldSetModals
                        SPS_NewStartInit_RB,    // SPS_NewSetModals
                        SPS_Terminate,          // SPS_OldStartInit
                        SPS_Terminate,          // SPS_OldStartWait
                        SPS_OldStartInit_RB,    // SPS_NewStartInit
                        SPS_OldStartInit_RB,    // SPS_NewStartWait
                        SPS_Terminate,          // SPS_FakeActivity
                        SPS_Trouble,            // SPS_OldStopInit_RB
                        SPS_Trouble,            // SPS_OldStopWait_RB
                        SPS_Trouble,            // SPS_NewSetModals_RB
                        SPS_Trouble,            // SPS_OldSetModals_RB
                        SPS_Trouble,            // SPS_OldStartInit_RB
                        SPS_Trouble,            // SPS_OldStartWait_RB
                        SPS_Terminate_RB,       // SPS_NewStartInit_RB
                        SPS_Terminate_RB,       // SPS_NewStartWait_RB
                        SPS_Invalid,            // SPS_FirstTerminal
                        SPS_Invalid,            // SPS_Abort
                        SPS_Invalid,            // SPS_Success
                        SPS_Invalid,            // SPS_Terminate
                        SPS_Invalid,            // SPS_Terminate_RB
                        SPS_Invalid,            // SPS_Trouble
                        SPS_Invalid             // SPS_Last
                    };


//
//  This array contains the ResyncServer() state transitions which
//  occur after a successful API.
//

RESYNCSERVERSTATES  ResyncServerSuccess[] =
                        // target state         // source state
                    {
                        RSS_Invalid,            // RSS_First
                        RSS_ServerStopInit,     // RSS_ServerGetModals
                        RSS_ServerStopWait,     // RSS_ServerStopInit
                        RSS_ServerSetModals,    // RSS_ServerStopWait
                        RSS_ChangePwdAtServer,  // RSS_ServerSetModals
                        RSS_ChangePwdAtPrimary, // RSS_ChangePwdAtServer
                        RSS_ServerResetModals,  // RSS_ChangePwdAtPrimary
                        RSS_ServerStartInit,    // RSS_ServerResetModals
                        RSS_ServerStartWait,    // RSS_ServerStartInit
                        RSS_Success,            // RSS_ServerStartWait
                        RSS_ServerStartInit_RB, // RSS_ServerResetModals_RB
                        RSS_ServerStartWait_RB, // RSS_ServerStartInit_RB
                        RSS_Terminate_RB,       // RSS_ServerStartWait_RB
                        RSS_Invalid,            // RSS_FirstTerminal
                        RSS_Invalid,            // RSS_Abort
                        RSS_Invalid,            // RSS_Success
                        RSS_Invalid,            // RSS_Terminate
                        RSS_Invalid,            // RSS_Terminat_RB
                        RSS_Invalid             // RSS_Last
                    };

//
//  This array contains the ResyncServer() state transitions which
//  occur after a failed API.
//

RESYNCSERVERSTATES  ResyncServerFailure[] =
                        // target state         // source state
                    {
                        RSS_Invalid,            // RSS_First
                        RSS_Abort,              // RSS_ServerGetModals
                        RSS_Abort,              // RSS_ServerStopInit
                        RSS_Abort,              // RSS_ServerStopWait
                        RSS_ServerStartInit_RB, // RSS_ServerSetModals
                        RSS_ServerResetModals_RB, // RSS_ChangePwdAtServer
                        RSS_ServerResetModals_RB, // RSS_ChangePwdAtPrimary
                        RSS_Terminate,          // RSS_ServerResetModals
                        RSS_Terminate,          // RSS_ServerStartInit
                        RSS_Terminate,          // RSS_ServerStartWait
                        RSS_Terminate_RB,       // RSS_ServerResetModals_RB
                        RSS_Terminate_RB,       // RSS_ServerStartInit_RB
                        RSS_Terminate_RB,       // RSS_ServerStartWait_RB
                        RSS_Invalid,            // RSS_FirstTerminal
                        RSS_Invalid,            // RSS_Abort
                        RSS_Invalid,            // RSS_Success
                        RSS_Invalid,            // RSS_Terminate
                        RSS_Invalid,            // RSS_Terminat_RB
                        RSS_Invalid             // RSS_Last
                    };


//
//  LM_DOMAIN_SVC class & methods.
//

class LM_DOMAIN_SVC : public GENERIC_SERVICE
{
private:
    LM_SERVICE_STATUS _statOriginal;
    UINT              _nSleepTime;
    UINT              _nMaxTries;

protected:

public:
    LM_DOMAIN_SVC( const TCHAR * pszServer,
                   const TCHAR * pszServiceKeyName,
                   const TCHAR * pszServiceDisplayName,
                   UINT          nSleepTime = DEFAULT_SLEEP_TIME,
                   UINT          nMaxTries  = 1 );

    APIERR Start( VOID )
        { return LM_SERVICE::Start( NULL, _nSleepTime, _nMaxTries ); }

    APIERR Stop( VOID )
        { return LM_SERVICE::Stop( _nSleepTime, _nMaxTries ); }

    APIERR Pause( VOID )
        { return LM_SERVICE::Pause( _nSleepTime, _nMaxTries ); }

    LM_SERVICE_STATUS QueryOriginalStatus( VOID ) const
        { return _statOriginal; }

    BOOL WasPaused( VOID ) const
        { return ( _statOriginal == LM_SVC_PAUSED  ) ||
                 ( _statOriginal == LM_SVC_PAUSING ); }

};  // class LM_DOMAIN_SVC


/*******************************************************************

    NAME:       LM_DOMAIN_SVC :: LM_DOMAIN_SVC

    SYNOPSIS:   LM_DOMAIN_SVC class constructor.

    ENTRY:      pszServer               - Name of the target server.

                pszServiceKeyName       - Service's key name.

                pszServiceDisplayName   - Service's display name (NULL
                                          if not known).

                nSleepTime              - Polling interval.

                nMaxTries               - Maximum retries before failing
                                          a polled operation.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     27-May-1993 Created.

********************************************************************/
LM_DOMAIN_SVC :: LM_DOMAIN_SVC( const TCHAR * pszServer,
                                const TCHAR * pszServiceKeyName,
                                const TCHAR * pszServiceDisplayName,
                                UINT          nSleepTime,
                                UINT          nMaxTries )
  : GENERIC_SERVICE( (HWND)NULL,
                     pszServer,
                     pszServer,
                     pszServiceKeyName,
                     pszServiceDisplayName,
                     FALSE ),
    _statOriginal( LM_SVC_STATUS_UNKNOWN ),
    _nSleepTime( nSleepTime ),
    _nMaxTries( nMaxTries )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Determine the "original" status.
    //

    APIERR err = NERR_Success;

    _statOriginal = QueryStatus( &err );

    if( err != NERR_Success )
    {
        _statOriginal = LM_SVC_STATUS_UNKNOWN;
        ReportError( err );
        return;
    }

}   // LM_DOMAIN_SVC :: LM_DOMAIN_SVC



//
//  LM_DOMAIN methods.
//

/*******************************************************************

    NAME:       LM_DOMAIN :: LM_DOMAIN

    SYNOPSIS:   LM_DOMAIN class constructor.

    ENTRY:      pszDomainName           - Name of the target domain.

                fIsNtDomain             - TRUE is this is an NT domain.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
LM_DOMAIN :: LM_DOMAIN( const TCHAR * pszDomainName,
                        BOOL          fIsNtDomain )
  : _nlsDomainName( pszDomainName ),
    _fIsNtDomain( fIsNtDomain ),
    _uOperation( OP_Idle ),
    _uState( SPS_Success ),
    _pNewModals( NULL ),
    _pOldModals( NULL ),
    _pServerModals( NULL ),
    _pnlsPrimary( NULL ),
    _pnlsPassword( NULL ),
    _pServerNetLogon( NULL ),
    _puserPrimary( NULL ),
    _puserServer( NULL ),
    _roleServer( 0 ),
    _errFatal( NERR_Success ),
    _nlsNewPrimaryName(),
    _nlsOldPrimaryName(),
    _apNewServices( NULL ),
    _apOldServices( NULL ),
    _psvcNext( NULL ),
    _cNewServices( 0 ),
    _cOldServices( 0 ),
    _iNewService( 0 ),
    _iOldService( 0 ),
    _nlsPrimaryRole( IDS_ROLE_PRIMARY ),
    _nlsServerRole( IDS_ROLE_BACKUP ),
    _nFakeActivity( FAKE_ACTIVITY_PERIOD )
{
    UIASSERT( pszDomainName != NULL );

    //
    //  Ensure we constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsDomainName.QueryError();
    err = err ? err : _nlsOldPrimaryName.QueryError();
    err = err ? err : _nlsNewPrimaryName.QueryError();
    err = err ? err : _nlsPrimaryRole.QueryError();
    err = err ? err : _nlsServerRole.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Validate the domain name.
    //

    if( ::I_MNetNameValidate( NULL,
                              _nlsDomainName.QueryPch(),
                              NAMETYPE_DOMAIN,
                              0L ) != NERR_Success )
    {
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

}   // LM_DOMAIN :: LM_DOMAIN


/*******************************************************************

    NAME:       LM_DOMAIN :: ~LM_DOMAIN

    SYNOPSIS:   LM_DOMAIN class destructor.

    ENTRY:      None.

    EXIT:       The object is destroyed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
LM_DOMAIN :: ~LM_DOMAIN()
{
    I_Cleanup();

}   // LM_DOMAIN :: ~LM_DOMAIN


/*******************************************************************

    NAME:       LM_DOMAIN :: QueryPrimary

    SYNOPSIS:   Returns the name of the Primary for this domain.

    ENTRY:      pnlsCurrentPrimary      - Points to a NLS_STR which
                                          receive the Primary name.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      The Primary name is not stored in this class.  It
                is retrieved via the GetDCName() API everytime this
                method is invoked.  Therefore, this method may take
                a while to execute.

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: QueryPrimary( NLS_STR * pnlsCurrentPrimary ) const
{
    UIASSERT( pnlsCurrentPrimary != NULL );
    UIASSERT( pnlsCurrentPrimary->QueryError() == NERR_Success );

    //
    //  Pointer to the Primary name.
    //

    TCHAR * pszPrimary = NULL;

    //
    //  Retrieve the Primary name.
    //

    APIERR err = ::MNetGetDCName( NULL,
                                  QueryName(),
                                  (BYTE **)&pszPrimary );

    if( err == NERR_Success )
    {
        //
        //  Verify that the PDC really exists.
        //

        SERVER_1 srv1( pszPrimary );

        err = srv1.GetInfo();

        if( err == ERROR_BAD_NETPATH )
        {
            //
            //  NetGetDCName must have returned stale data.
            //

            err = NERR_DCNotFound;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Put the Primary name into the NLS_STR, then
        //  check the string's status.
        //

        err = pnlsCurrentPrimary->CopyFrom( pszPrimary );
    }

    ::MNetApiBufferFree( (BYTE **)&pszPrimary );

    return err;

}   // LM_DOMAIN :: QueryPrimary


/*******************************************************************

    NAME:       LM_DOMAIN :: SetPrimary

    SYNOPSIS:   Sets the Primary for this domain to the specified
                Server.

    ENTRY:      pFeedback               - Points to a class derived
                                          from DOMAIN_FEEDBACK.  This
                                          is used to notify/warn the
                                          user about milestones and
                                          errors.

                nlsNewPrimary           - The name of a Server that
                                          will be promoted to Primary.

                uPollingInterval        - This is the approximate time
                                          (in milliseconds) that the
                                          client will wait between
                                          calls to the Poll() method.

    EXIT:       ??

    RETURNS:    APIERR                  - The first error encountered.
                                          Will be DOMAIN_STATUS_PENDING
                                          if the operation is deferred.

    NOTES:      Unless something goes horribly wrong, this method will
                return DOMAIN_STATUS_PENDING.  It is the client's
                responsibility to call LM_DOMAIN::Poll() periodically
                until a status other than DOMAIN_STATUS_PENDING is
                returned.

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: SetPrimary( DOMAIN_FEEDBACK * pFeedback,
                                const NLS_STR   & nlsNewPrimary,
                                UINT              uPollingInterval )
{
    UIASSERT( pFeedback != NULL );
    UIASSERT( nlsNewPrimary.QueryError() == NERR_Success );
    UIASSERT( _uOperation == OP_Idle );

    //
    //  Setup.
    //

    _fIgnoreOldPrimary = FALSE;
    _uPollingInterval  = uPollingInterval;
    _uOperation        = OP_SetPrimary;
    _iNewService       = 0;
    _iOldService       = 0;
    _nFakeActivity     = FAKE_ACTIVITY_PERIOD;

    //
    //  Retrieve the current Primary's name.
    //

    APIERR err = QueryPrimary( &_nlsOldPrimaryName );

    if( err != NERR_Success )
    {
        if( pFeedback->Warning( WC_CannotFindPrimary ) )
        {
            _fIgnoreOldPrimary = TRUE;
            err = NERR_Success;
        }
    }
    else
    {
        //
        //  If _nlsOldPrimaryName == nlsNewPrimary, then the user
        //  is trying to promote the current PDC.  This is a degenerate
        //  case caused by either funky network settings (such as a bad
        //  LMHOSTS file) or a malicious user.  In any case, we'll just
        //  pretend the promotion succeeded.
        //

        if( !::I_MNetComputerNameCompare( _nlsOldPrimaryName, nlsNewPrimary ) )
        {
            TRACEEOL( "SetPrimary: old PDC == new PDC " << nlsNewPrimary );
            _uState = SPS_Success;
            return DOMAIN_STATUS_PENDING;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Save away the new primary's name.
        //

        err = _nlsNewPrimaryName.CopyFrom( nlsNewPrimary );
    }

    //
    //  Allocate our SERVER_MODALS and LM_DOMAIN_SVC objects.
    //

    if( err == NERR_Success )
    {
        err = CreateServerData( _nlsNewPrimaryName,
                                &_pNewModals,
                                &_apNewServices,
                                &_cNewServices );
    }

    if( !_fIgnoreOldPrimary && ( err == NERR_Success ) )
    {
        err = CreateServerData( _nlsOldPrimaryName,
                                &_pOldModals,
                                &_apOldServices,
                                &_cOldServices );
    }

    if( ( err == NERR_Success ) && !_fIgnoreOldPrimary && _fIsNtDomain )
    {
        //
        //  Ensure the old primary's secret is in sync with
        //  it's machine account password.
        //

        err = LM_DOMAIN::ResetMachinePasswords( QueryName(),
                                                _nlsOldPrimaryName );
    }

    //
    //  Retrieve the new primary's current domain role.
    //

    if( err == NERR_Success )
    {
        err = _pNewModals->QueryServerRole( &_roleServer );
    }

    //
    //  Setup the necessary state/operation info.
    //

    if( err == NERR_Success )
    {
        UIASSERT( _cNewServices > 0 );
        UIASSERT( _fIgnoreOldPrimary || ( _cOldServices > 0 ) );

        if( _fIsNtDomain && !_fIgnoreOldPrimary )
        {
            _uState = SPS_NewResyncSamInit;
        }
        else
        {
            _uState = SPS_NewStopInit;
        }

        err = DOMAIN_STATUS_PENDING;
    }

    return err;

}   // LM_DOMAIN :: SetPrimary


/*******************************************************************

    NAME:       LM_DOMAIN :: ResyncServer

    SYNOPSIS:   Resyncs a server with the Primary.

    ENTRY:      pFeedback               - Points to a class derived
                                          from DOMAIN_FEEDBACK.  This
                                          is used to notify/warn the
                                          user about milestones and
                                          errors.

                nlsServer               - The name of the server to
                                          resync with the Primary.

                uPollingInterval        - This is the approximate time
                                          (in milliseconds) that the
                                          client will wait between
                                          calls to the Poll() method.

    EXIT:       ??

    RETURNS:    APIERR                  - The first error encountered.
                                          Will be DOMAIN_STATUS_PENDING
                                          if the operation is deferred.

    NOTES:      Unless something goes horribly wrong, this method will
                return DOMAIN_STATUS_PENDING.  It is the client's
                responsibility to call LM_DOMAIN::Poll() periodically
                until a status other than DOMAIN_STATUS_PENDING is
                returned.

    HISTORY:
        KeithMo     04-Nov-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: ResyncServer( DOMAIN_FEEDBACK * pFeedback,
                                  const NLS_STR   & nlsServer,
                                  UINT              uPollingInterval )
{
    UIASSERT( pFeedback != NULL );
    UIASSERT( nlsServer.QueryError() == NERR_Success );
    UIASSERT( _uOperation == OP_Idle );

    //
    //  Retrieve the current Primary's name.
    //

    _pnlsPrimary  = new NLS_STR;
    _pnlsPassword = new NLS_STR;

    if( ( _pnlsPrimary  == NULL ) ||
        ( _pnlsPassword == NULL ) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    APIERR err;

    if( ( ( err = _pnlsPrimary->QueryError() )  != NERR_Success ) ||
        ( ( err = _pnlsPassword->QueryError() ) != NERR_Success ) )
    {
        return err;
    }

    err = QueryPrimary( _pnlsPrimary );

    if( err != NERR_Success )
    {
        pFeedback->Warning( WC_CannotFindPrimary );
        return err;
    }

    //
    //  Build our random password.
    //

    err = BuildRandomPassword( _pnlsPassword );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Allocate our SERVER_MODALS, LM_SERVICE, and USER_2 objects.
    //

    _pServerModals = new SERVER_MODALS( nlsServer.QueryPch() );

    ISTR istrNew( nlsServer );
    istrNew += 2;

    NLS_STR nlsServerAccount( nlsServer.QueryPch( istrNew ) );

    err = nlsServerAccount.QueryError();

    if( ( err == NERR_Success ) && _fIsNtDomain )
    {
        NLS_STR nlsAccountPostfix;

        err = nlsAccountPostfix.QueryError();

        if( err == NERR_Success )
        {
            err = nlsAccountPostfix.MapCopyFrom( (TCHAR *)SSI_ACCOUNT_NAME_POSTFIX );
        }

        if( err == NERR_Success )
        {
            err = nlsServerAccount.Append( nlsAccountPostfix );
        }
    }

    if( err != NERR_Success )
    {
        return err;
    }

    _pServerNetLogon = new LM_SERVICE( nlsServer,
                                       (const TCHAR *)SERVICE_NETLOGON );

    _puserPrimary = new USER_2( nlsServerAccount,
                                _pnlsPrimary->QueryPch() );

    _puserServer  = new USER_2( nlsServerAccount,
                                nlsServer.QueryPch() );

    //
    //  Ensure they allocated/constructed properly.
    //

    if( ( _pServerModals   == NULL ) ||
        ( _pServerNetLogon == NULL ) ||
        ( _puserPrimary    == NULL ) ||
        ( _puserServer     == NULL ) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if( ( ( err = _pServerModals->QueryError() )   != NERR_Success ) ||
        ( ( err = _pServerNetLogon->QueryError() ) != NERR_Success ) ||
        ( ( err = _puserPrimary->GetInfo() )       != NERR_Success ) ||
        ( ( err = _puserServer->GetInfo() )        != NERR_Success ) )
    {
        return err;
    }

    //
    //  Setup the necessary state/operation info.
    //

    _uOperation        = OP_ResyncServer;
    _uState            = RSS_ServerGetModals;
    _uPollingInterval  = uPollingInterval;

    return DOMAIN_STATUS_PENDING;

}   // LM_DOMAIN :: SetPrimary


/*******************************************************************

    NAME:       LM_DOMAIN :: Poll

    SYNOPSIS:   This is the main "pump" used to drive the state
                machines.

    ENTRY:      pFeedback               - Points to a DOMAIN_FEEDBACK
                                          object which implements the
                                          UI for this operation.

    EXIT:       ?

    RETURNS:    APIERR                  - The first error encountered.
                                          Will be DOMAIN_STATUS_PENDING
                                          if the operation is deferred.

    NOTES:

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: Poll( DOMAIN_FEEDBACK * pFeedback )
{
    UIASSERT( pFeedback != NULL );
    UIASSERT( _uOperation != OP_Idle );

    switch( _uOperation )
    {
        case OP_SetPrimary:
            return I_SetPrimary( pFeedback );

        case OP_ResyncServer:
            return I_ResyncServer( pFeedback );

        default:
            UIASSERT( !"Invalid _uOperation" );
            return ERROR_INVALID_PARAMETER;
    }

}   // LM_DOMAIN :: Poll


/*******************************************************************

    NAME:       LM_DOMAIN :: I_SetPrimary

    SYNOPSIS:   This private method implements the SetPrimary()
                state machine.

    ENTRY:      pFeedback               - Points to a DOMAIN_FEEDBACK
                                          object which implements the
                                          UI for this operation.

    EXIT:       ?

    RETURNS:    APIERR                  - Any error encountered.
                                          Will be DOMAIN_STATUS_PENDING
                                          if the operation is deferred.

    NOTES:      *** add notes! ***

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: I_SetPrimary( DOMAIN_FEEDBACK * pFeedback )
{
    UIASSERT( _uState > SPS_First );
    UIASSERT( _uState < SPS_Last  );
    UIASSERT( _uOperation == OP_SetPrimary );

    APIERR err      = NERR_Success;
    BOOL   fDone    = FALSE;
    BOOL   fAdvance = TRUE;

    NETLOGON_INFO_1 * pnetlog1 = NULL;

#if defined(DEBUG) && defined(TRACE)
    const TCHAR * apszStates[] =
                    {
                        SZ("SPS_Invalid"),
                        SZ("SPS_First"),            SZ("SPS_NewResyncSamInit"),
                        SZ("SPS_NewResyncSamWait"), SZ("SPS_NewStopInit"),
                        SZ("SPS_NewStopWait"),      SZ("SPS_OldStopInit"),
                        SZ("SPS_OldStopWait"),      SZ("SPS_OldSetModals"),
                        SZ("SPS_NewSetModals"),     SZ("SPS_OldStartInit"),
                        SZ("SPS_OldStartWait"),     SZ("SPS_NewStartInit"),
                        SZ("SPS_NewStartWait"),     SZ("SPS_FakeActivity"),
                        SZ("SPS_OldStopInit_RB"),   SZ("SPS_OldStopWait_RB"),
                        SZ("SPS_NewSetModals_RB"),  SZ("SPS_OldSetModals_RB"),
                        SZ("SPS_OldStartInit_RB"),  SZ("SPS_OldStartWait_RB"),
                        SZ("SPS_NewStartInit_RB"),  SZ("SPS_NewStartWait_RB"),
                        SZ("SPS_FirstTerminal"),    SZ("SPS_Abort"),
                        SZ("SPS_Success"),          SZ("SPS_Terminate"),
                        SZ("SPS_Terminate_RB"),     SZ("SPS_Trouble"),
                        SZ("SPS_Last")
                    };

    TRACEEOL( "I_SetPrimary: old state == " << apszStates[_uState+1] );
#endif  // DEBUG && TRACE

    //
    //  Perform the appropriate action based on the current state.
    //

    switch( _uState )
    {
        //
        //  SPS_NewResyncSamInit
        //
        //  Initiate a resync of the SAM databases.
        //

        case SPS_NewResyncSamInit :
            err = ::I_MNetLogonControl( _nlsNewPrimaryName,
                                        NETLOGON_CONTROL_REPLICATE,
                                        1,
                                        (BYTE **)&pnetlog1 );

            pFeedback->Notify( err,
                               AC_ResyncingSam,
                               _nlsNewPrimaryName );

            ::MNetApiBufferFree( (BYTE **)&pnetlog1 );
            break;

        //
        //  SPS_NewResyncSamWait
        //
        //  Wait for the SAM database resync to complete.
        //

        case SPS_NewResyncSamWait :
            err = ::I_MNetLogonControl( _nlsNewPrimaryName,
                                        NETLOGON_CONTROL_QUERY,
                                        1,
                                        (BYTE **)&pnetlog1 );

            if( ( err == NERR_Success ) &&
                !( pnetlog1->netlog1_flags & NETLOGON_REPLICATION_IN_PROGRESS ) &&
                ( pnetlog1->netlog1_flags & NETLOGON_REPLICATION_NEEDED ) )
            {
                //
                //  NetLogon is telling us that the replication is
                //  complete, yet is still required.  This (generally)
                //  indicates that the replication failed.
                //

                err = NERR_SyncRequired;
            }

            pFeedback->Notify( err,
                               AC_ResyncingSam,
                               _nlsNewPrimaryName );

            if( ( err == NERR_Success ) &&
                ( pnetlog1->netlog1_flags & NETLOGON_REPLICATION_IN_PROGRESS ) )
            {
                fAdvance = FALSE;
            }

            ::MNetApiBufferFree( (BYTE **)&pnetlog1 );
            break;

        //
        //  SPS_NewStopInit
        //
        //  Initiate the stop of the next service in the service
        //  list on the new primary.
        //

        case SPS_NewStopInit :
            UIASSERT( ( _iNewService >= 0 ) && ( _iNewService < _cNewServices ) );
            _psvcNext = _apNewServices[_iNewService++];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: stopping " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Stop();

            if( err == NERR_ServiceNotInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_NewStopWait
        //
        //  Wait for the current service to stop on the new primary.
        //  If there are additional services to stop, initiate the
        //  stop for the next service.
        //

        case SPS_NewStopWait :
            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && ( _iNewService < _cNewServices ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_NewStopInit;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_OldStopInit
        //
        //  Initiate the stop of the next service in the service
        //  list on the old primary.
        //

        case SPS_OldStopInit :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( ( _iOldService >= 0 ) && ( _iOldService < _cOldServices ) );
            _psvcNext = _apOldServices[_iOldService++];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: stopping " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Stop();

            if( err == NERR_ServiceNotInstalled )
            {
                err = NERR_Success;

            }
            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_OldStopWait
        //
        //  Wait for the current service to stop on the old primary.
        //  If there are additional services to stop, initiate the
        //  stop for the next service.
        //

        case SPS_OldStopWait :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && ( _iOldService < _cOldServices ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_OldStopInit;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_OldSetModals
        //
        //  Change the role of the old primary to BDC.
        //

        case SPS_OldSetModals :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            err = _pOldModals->SetServerRole( UAS_ROLE_BACKUP );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _nlsOldPrimaryName,
                               _nlsServerRole );
            break;

        //
        //  SPS_NewSetModals
        //
        //  Change the role of the new primary to PDC.
        //

        case SPS_NewSetModals :
            err = _pNewModals->SetServerRole( UAS_ROLE_PRIMARY );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _nlsNewPrimaryName,
                               _nlsPrimaryRole );
            break;

        //
        //  SPS_OldStartInit
        //
        //  Initiate a start of the next service on the old primary.
        //

        case SPS_OldStartInit :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( ( _iOldService > 0 ) && ( _iOldService <= _cOldServices ) );
            _psvcNext = _apOldServices[--_iOldService];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: starting " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Start();

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_OldStartWait
        //
        //  Wait for the current service to start on the old primary.
        //  If there are additional services to start, initiate the
        //  start for the next service.
        //

        case SPS_OldStartWait :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && _psvcNext->WasPaused() )
                {
                    //
                    //  The service was originally paused when we initiated
                    //  the promotion.  Now that we have the service started,
                    //  we'll initiate a pause.  We'll ignore any errors, and
                    //  we'll *not* wait for the pause to complete.
                    //

                    TRACEEOL( "I_SetPrimary: pausing " << _psvcNext->QueryServiceDisplayName() );

                    _psvcNext->Pause();
                }

                if( fDone && ( _iOldService > 0 ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_OldStartInit;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_NewStartInit
        //
        //  Initiate a start of the next service on the new primary.
        //

        case SPS_NewStartInit :
            UIASSERT( ( _iNewService > 0 ) && ( _iNewService <= _cNewServices ) );
            _psvcNext = _apNewServices[--_iNewService];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: starting " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Start();

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_NewStartWait
        //
        //  Wait for the current service to start on the new primary.
        //  If there are additional services to start, initiate the
        //  start for the next service.
        //

        case SPS_NewStartWait :
            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && _psvcNext->WasPaused() )
                {
                    //
                    //  The service was originally paused when we initiated
                    //  the promotion.  Now that we have the service started,
                    //  we'll initiate a pause.  We'll ignore any errors, and
                    //  we'll *not* wait for the pause to complete.
                    //

                    TRACEEOL( "I_SetPrimary: pausing " << _psvcNext->QueryServiceDisplayName() );

                    _psvcNext->Pause();
                }

                if( fDone && ( _iNewService > 0 ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_NewStartInit;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_FakeActivity
        //
        //  Delays the completion of the promotion for a few seconds
        //  to give the Browser a chance to "catch its breath".
        //

        case SPS_FakeActivity :
            err = NERR_Success;
            pFeedback->Notify( err,
                               AC_StartingService,
                               _psvcNext->QueryServerName(),
                               _psvcNext->QueryServiceDisplayName() );

            _nFakeActivity -= (LONG)_uPollingInterval;

            if( _nFakeActivity > 0 )
            {
                fAdvance = FALSE;
            }
            break;

        //
        //  SPS_OldStopInit_RB
        //
        //  Initiate the stop of the next service in the service
        //  list on the old primary.
        //

        case SPS_OldStopInit_RB :
            if( _fIgnoreOldPrimary || _iOldService >= _cOldServices )
            {
                err = NERR_Success;
                _uState = SPS_OldStopWait_RB;
                break;
            }

            UIASSERT( ( _iOldService >= 0 ) && ( _iOldService < _cOldServices ) );
            _psvcNext = _apOldServices[_iOldService++];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: stopping " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Stop();

            if( err == NERR_ServiceNotInstalled )
            {
                err = NERR_Success;

            }
            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_OldStopWait_RB
        //
        //  Wait for the current service to stop on the old primary.
        //  If there are additional services to stop, initiate the
        //  stop for the next service.
        //

        case SPS_OldStopWait_RB :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StoppingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && ( _iOldService < _cOldServices ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_OldStopInit_RB;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_NewSetModals_RB
        //
        //  Change the role of the new primary back to BDC.
        //

        case SPS_NewSetModals_RB :
            err = _pNewModals->SetServerRole( UAS_ROLE_BACKUP );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _nlsNewPrimaryName,
                               _nlsServerRole );
            break;

        //
        //  SPS_OldSetModals_RB
        //
        //  Change the role of the old primary back to PDC.
        //

        case SPS_OldSetModals_RB :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            err = _pOldModals->SetServerRole( UAS_ROLE_PRIMARY );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _nlsOldPrimaryName,
                               _nlsPrimaryRole );
            break;

        //
        //  SPS_OldStartInit_RB
        //
        //  Initiate a start of the next service on the old primary.
        //

        case SPS_OldStartInit_RB :
            if( _fIgnoreOldPrimary || ( _iOldService == 0 ) )
            {
                err     = NERR_Success;
                _uState = _fIsNtDomain ? NtSetPrimarySuccess[_uState]
                                       : LmSetPrimarySuccess[_uState];
                break;
            }

            UIASSERT( ( _iOldService > 0 ) && ( _iOldService <= _cOldServices ) );
            _psvcNext = _apOldServices[--_iOldService];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: starting " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Start();

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_OldStartWait_RB
        //
        //  Wait for the current service to start on the old primary.
        //  If there are additional services to start, initiate the
        //  start for the next service.
        //

        case SPS_OldStartWait_RB :
            if( _fIgnoreOldPrimary )
            {
                err = NERR_Success;
                break;
            }

            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsOldPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && _psvcNext->WasPaused() )
                {
                    //
                    //  The service was originally paused when we initiated
                    //  the promotion.  Now that we have the service started,
                    //  we'll initiate a pause.  We'll ignore any errors, and
                    //  we'll *not* wait for the pause to complete.
                    //

                    TRACEEOL( "I_SetPrimary: pausing " << _psvcNext->QueryServiceDisplayName() );

                    _psvcNext->Pause();
                }

                if( fDone && ( _iOldService > 0 ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_OldStartInit_RB;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_NewStartInit_RB
        //
        //  Initiate a start of the next service on the new primary.
        //

        case SPS_NewStartInit_RB :
            if( _iNewService == 0 )
            {
                err     = NERR_Success;
                _uState = _fIsNtDomain ? NtSetPrimarySuccess[_uState]
                                       : LmSetPrimarySuccess[_uState];
                break;
            }

            UIASSERT( ( _iNewService > 0 ) && ( _iNewService <= _cNewServices ) );
            _psvcNext = _apNewServices[--_iNewService];
            UIASSERT( _psvcNext != NULL );

            TRACEEOL( "I_SetPrimary: starting " << _psvcNext->QueryServiceDisplayName() );

            err = _psvcNext->Start();

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );
            break;

        //
        //  SPS_NewStartWait_RB
        //
        //  Wait for the current service to start on the new primary.
        //  If there are additional services to start, initiate the
        //  start for the next service.
        //

        case SPS_NewStartWait_RB :
            UIASSERT( _psvcNext != NULL );
            err = _psvcNext->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _nlsNewPrimaryName,
                               _psvcNext->QueryServiceDisplayName() );

            if( err == NERR_Success )
            {
                if( fDone && _psvcNext->WasPaused() )
                {
                    //
                    //  The service was originally paused when we initiated
                    //  the promotion.  Now that we have the service started,
                    //  we'll initiate a pause.  We'll ignore any errors, and
                    //  we'll *not* wait for the pause to complete.
                    //

                    TRACEEOL( "I_SetPrimary: pausing " << _psvcNext->QueryServiceDisplayName() );

                    _psvcNext->Pause();
                }

                if( fDone && ( _iNewService > 0 ) )
                {
                    fDone   = FALSE;
                    _uState = SPS_NewStartInit_RB;
                }

                fAdvance = fDone;
            }
            break;

        //
        //  SPS_Success
        //
        //  This state is only entered directy if the promotion
        //  was short-circuited at a very early stage.  This will
        //  occur if the new PDC == old PDC.  See the comments
        //  in SetPrimary() for details.
        //

        case SPS_Success :
            err = NERR_Success;
            fAdvance = FALSE;
            break;

        default :
            UIASSERT( !"Invalid _uState" );
            break;
    }

    //
    //  Check the API status.
    //

    if( err != NERR_Success )
    {
        //
        //  The API failed.  If this is the *first* failure
        //  (_errFatal == NERR_Success) then save the API status
        //  in _errFatal.  Regardless, perform a failure-mode
        //  state transition.
        //

        if( _errFatal == NERR_Success )
        {
            _errFatal = err;
        }

        if( fAdvance )
        {
            _uState = _fIsNtDomain ? NtSetPrimaryFailure[_uState]
                                   : LmSetPrimaryFailure[_uState];
        }
    }
    else
    {
        //
        //  The API was successful.  Perform a success-mode
        //  state transition.
        //

        if( fAdvance )
        {
            _uState = _fIsNtDomain ? NtSetPrimarySuccess[_uState]
                                   : LmSetPrimarySuccess[_uState];
        }
    }

    if( _uState > SPS_FirstTerminal )
    {
        //
        //  We are now at a terminal state.  Cleanup the state
        //  machine and return an appropriate status.
        //

        err = _errFatal;

        I_Cleanup();
    }
    else
    {
        //
        //  We're at some intermediate state, so return
        //  DOMAIN_STATUS_PENDING.
        //

        err = DOMAIN_STATUS_PENDING;
    }

#if defined(DEBUG) && defined(TRACE)
    if( ( err != NERR_Success ) && ( err != DOMAIN_STATUS_PENDING ) )
    {
        TRACEEOL( "I_SetPrimary: error " << err );
    }

    TRACEEOL( "I_SetPrimary: new state == " << apszStates[_uState+1] );
#endif  // DEBUG && TRACE

    return err;

}   // LM_DOMAIN :: I_SetPrimary


/*******************************************************************

    NAME:       LM_DOMAIN :: I_ResyncServer

    SYNOPSIS:   This private method implements the ResyncServer()
                state machine.

    ENTRY:      pFeedback               - Points to a DOMAIN_FEEDBACK
                                          object which implements the
                                          UI for this operation.

    EXIT:       ?

    RETURNS:    APIERR                  - Any error encountered.
                                          Will be DOMAIN_STATUS_PENDING
                                          if the operation is deferred.

    NOTES:      *** add notes! ***

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: I_ResyncServer( DOMAIN_FEEDBACK * pFeedback )
{
    UIASSERT( _uState > RSS_First );
    UIASSERT( _uState < RSS_Last  );
    UIASSERT( _uOperation == OP_ResyncServer );

    APIERR err      = NERR_Success;
    BOOL   fDone    = FALSE;
    BOOL   fAdvance = TRUE;

    //
    //  Perform the appropriate action based on the current state.
    //

    switch( _uState )
    {
        case RSS_ServerGetModals :
            err = _pServerModals->QueryServerRole( &_roleServer );

            pFeedback->Notify( err,
                               AC_GettingModals,
                               _pServerModals->QueryName() );
            break;

        case RSS_ServerStopInit :
            err = _pServerNetLogon->Stop( _uPollingInterval );

            if( err == NERR_ServiceNotInstalled )
            {
                err = NERR_Success;

            }
            pFeedback->Notify( err,
                               AC_StoppingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );
            break;

        case RSS_ServerStopWait :
            err = _pServerNetLogon->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StoppingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );

            if( ( err == NERR_Success ) && !fDone )
            {
                fAdvance = FALSE;
            }
            break;

        case RSS_ServerSetModals :
            err = _pServerModals->SetServerRole( UAS_ROLE_PRIMARY );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _pServerModals->QueryName(),
                               _nlsPrimaryRole );
            break;

        case RSS_ChangePwdAtServer :
            err = _puserServer->SetPassword( _pnlsPassword->QueryPch() );

            if( err == NERR_Success )
            {
                err = _puserServer->WriteInfo();
            }

            pFeedback->Notify( err,
                               AC_ChangingPassword,
                               _pServerModals->QueryName() );
            break;

        case RSS_ChangePwdAtPrimary :
            err = _puserPrimary->SetPassword( _pnlsPassword->QueryPch() );

            if( err == NERR_Success )
            {
                err = _puserPrimary->WriteInfo();
            }

            pFeedback->Notify( err,
                               AC_ChangingPassword,
                               _pServerModals->QueryName() );
            break;

        case RSS_ServerResetModals :
            err = _pServerModals->SetServerRole( _roleServer );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _pServerModals->QueryName(),
                               _nlsServerRole );
            break;

        case RSS_ServerStartInit :
            err = _pServerNetLogon->Start( NULL, _uPollingInterval );

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );
            break;

        case RSS_ServerStartWait :
            err = _pServerNetLogon->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );

            if( ( err == NERR_Success ) && !fDone )
            {
                fAdvance = FALSE;
            }
            break;

        case RSS_ServerResetModals_RB :
            err = _pServerModals->SetServerRole( _roleServer );

            pFeedback->Notify( err,
                               AC_ChangingRole,
                               _pServerModals->QueryName(),
                               _nlsServerRole );
            break;

        case RSS_ServerStartInit_RB :
            err = _pServerNetLogon->Start( NULL, _uPollingInterval );

            if( err == NERR_ServiceInstalled )
            {
                err = NERR_Success;

            }

            pFeedback->Notify( err,
                               AC_StartingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );
            break;

        case RSS_ServerStartWait_RB :
            err = _pServerNetLogon->Poll( &fDone );

            pFeedback->Notify( err,
                               AC_StartingService,
                               _pServerModals->QueryName(),
                               _pServerNetLogon->QueryName() );

            if( ( err == NERR_Success ) && !fDone )
            {
                fAdvance = FALSE;
            }
            break;

        default :
            UIASSERT( !"Invalid _uState" );
            break;
    }

    //
    //  Check the API status.
    //

    if( err != NERR_Success )
    {
        //
        //  The API failed.  If this is the *first* failure
        //  (_errFatal == NERR_Success) then save the API status
        //  in _errFatal.  Regardless, perform a failure-mode
        //  state transition.
        //

        if( _errFatal == NERR_Success )
        {
            _errFatal = err;
        }

        if( fAdvance )
        {
            _uState = ResyncServerFailure[_uState];
        }
    }
    else
    {
        //
        //  The API was successful.  Perform a success-mode
        //  state transition.
        //

        if( fAdvance )
        {
            _uState = ResyncServerSuccess[_uState];
        }
    }

    if( _uState > RSS_FirstTerminal )
    {
        //
        //  We are now at a terminal state.  Cleanup the state
        //  machine and return an appropriate status.
        //

        err = _errFatal;

        I_Cleanup();
    }
    else
    {
        //
        //  We're at some intermediate state, so return
        //  DOMAIN_STATUS_PENDING.
        //

        err = DOMAIN_STATUS_PENDING;
    }

    return err;

}   // LM_DOMAIN :: I_ResyncServer


/*******************************************************************

    NAME:       LM_DOMAIN :: I_Cleanup

    SYNOPSIS:   Cleanup the state machines.

    EXIT:       The state machines are in an idle state.

    HISTORY:
        KeithMo     30-Sep-1991 Created.

********************************************************************/
VOID LM_DOMAIN :: I_Cleanup( VOID )
{
    delete _pNewModals;
    _pNewModals = NULL;

    delete _pOldModals;
    _pOldModals = NULL;

    if( _apNewServices != NULL )
    {
        LM_DOMAIN_SVC ** ppscan = _apNewServices;

        for( LONG i = 0 ; i < _cNewServices ; i++ )
        {
            delete *ppscan;
            *ppscan++ = NULL;
        }

        delete _apNewServices;
        _apNewServices = NULL;
    }

    if( _apOldServices != NULL )
    {
        LM_DOMAIN_SVC ** ppscan = _apOldServices;

        for( LONG i = 0 ; i < _cOldServices ; i++ )
        {
            delete *ppscan;
            *ppscan++ = NULL;
        }

        delete _apOldServices;
        _apOldServices = NULL;
    }

    delete _pnlsPrimary;
    _pnlsPrimary = NULL;

    if( _pnlsPassword != NULL )
    {
        RtlZeroMemory( (PVOID)_pnlsPassword->QueryPch(),
                       _pnlsPassword->QueryTextSize() );

        delete _pnlsPassword;
        _pnlsPassword = NULL;
    }

    delete _pServerModals;
    _pServerModals = NULL;

    delete _pServerNetLogon;
    _pServerNetLogon = NULL;

    delete _puserPrimary;
    _puserPrimary = NULL;

    delete _puserServer;
    _puserServer = NULL;

    _uOperation = OP_Idle;
    _uState     = (UINT)SPS_Invalid;
    _errFatal   = NERR_Success;

}   // LM_DOMAIN :: I_Cleanup


/*******************************************************************

    NAME:       LM_DOMAIN :: BuildRandomPassword

    SYNOPSIS:   Creates a new random password for an out-of-sync
                server.  This method is only used during resync
                operations.

    ENTRY:      pnls                    - Pointer to an NLS_STR which will
                                          receive the random password.

    EXIT:       *pnls contains a valid random password.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     04-Nov-1991 Created.

********************************************************************/
APIERR LM_DOMAIN :: BuildRandomPassword( NLS_STR * pnls )
{
    TCHAR   szPassword[LM20_PWLEN+1];
    TCHAR * psz = szPassword;
    UINT    uSeed;

    uSeed  = (UINT)clock();
    uSeed ^= (UINT)((ULONG_PTR)pnls + ((ULONG_PTR)pnls >> 16));
    srand( uSeed );

    for( UINT i = 0 ; i < LM20_PWLEN ; i++ )
    {
        *psz++ = 'A' + (TCHAR)( rand() % 26 );
    }

    *psz = '\0';

    APIERR err = pnls->CopyFrom( szPassword );

    RtlZeroMemory( szPassword, sizeof(szPassword) );

    return err;

}   // LM_DOMAIN :: BuildRandomPassword


/*******************************************************************

    NAME:       LM_DOMAIN :: CreateServerData

    SYNOPSIS:   Creates the necessary private members required for
                a server promotion.

    ENTRY:      pszServer               - Name of the target server.

                ppmodals                - Will receive a newly alloced
                                          SERVER_MODALS object.

                papServices             - Will receive a pointer to an
                                          array of pointers to LM_DOMAIN_SVC
                                          objects.  There will be one
                                          object for each service that is
                                          dependent on NetLogon, and an
                                          additional object for the NetLogon
                                          service itself.

                pcServices              - Will receive the total number of
                                          services in the papServices array.

    RETURNS:    APIERR                  - Any errors encountered.  If this
                                          is !0, then it is up to the caller
                                          to free any allocated objects by
                                          calling I_Cleanup().

    HISTORY:
        KeithMo     11-May-1993 Created.

********************************************************************/
APIERR LM_DOMAIN :: CreateServerData( const TCHAR     * pszServer,
                                      SERVER_MODALS  ** ppmodals,
                                      LM_DOMAIN_SVC *** papServices,
                                      LONG            * pcServices )
{
    ENUM_SERVICE_STATUS * psvcstat  = NULL;
    LONG                  cServices = 0L;

    UIASSERT( ppmodals     != NULL );
    UIASSERT( papServices  != NULL );
    UIASSERT( pcServices   != NULL );

    //
    //  Put everything into a consistent state.
    //

    *ppmodals    = NULL;
    *papServices = NULL;
    *pcServices  = 0;

    //
    //  Start by allocating a new modals object.
    //

    *ppmodals = new SERVER_MODALS( pszServer );

    APIERR err = ( *ppmodals == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : (*ppmodals)->QueryError();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Enumerate the service dependencies.
    //

    SC_MANAGER   scman( pszServer, GENERIC_READ );
    SC_SERVICE * pscsvc = NULL;

    err = scman.QueryError();

    if( err != NERR_Success )
    {
        //
        //  Cannot connect to the target server's service
        //  controller, probably downlevel.  In any case,
        //  pretend there are no service dependencies.
        //

        err = NERR_Success;
    }
    else
    {
        pscsvc = new SC_SERVICE( scman,
                                 _pszNetLogonKeyName,
                                 GENERIC_READ | SERVICE_ENUMERATE_DEPENDENTS );

        err = ( pscsvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                 : pscsvc->QueryError();

        if( err == NERR_Success )
        {
            err = pscsvc->EnumDependent( SERVICE_ACTIVE,
                                         &psvcstat,
                                         (DWORD *)&cServices );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Allocate the LM_DOMAIN_SVC object array.  Be sure
        //  to leave an additional slot for the NetLogon
        //  service itself.
        //

        LM_DOMAIN_SVC ** apServices = new LM_DOMAIN_SVC *[cServices+1];

        if( apServices == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            //  Return the array & count to the caller.
            //

            *pcServices  = cServices+1;
            *papServices = apServices;

            //
            //  Fill the LM_DOMAIN_SVC array.
            //

            LM_DOMAIN_SVC ** ppsvc = apServices;

            for( LONG i = 0 ; i < cServices ; i++ )
            {
                *ppsvc = new LM_DOMAIN_SVC( pszServer,
                                            psvcstat->lpServiceName,
                                            psvcstat->lpDisplayName,
                                            _uPollingInterval );

                err = ( *ppsvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                         : (*ppsvc)->QueryError();

                if( err != NERR_Success )
                {
                    break;
                }

                psvcstat++;
                ppsvc++;
            }

            if( err == NERR_Success )
            {
                //
                //  Append NetLogon to the list.
                //

                UIASSERT( i == cServices );

                *ppsvc = new LM_DOMAIN_SVC( pszServer,
                                            _pszNetLogonKeyName,
                                            NULL,
                                            _uPollingInterval );

                err = ( *ppsvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                         : (*ppsvc)->QueryError();
            }

            if( err != NERR_Success )
            {
                //
                //  NULL out the remainder of the array.
                //

                for( ; i < cServices+1 ; i++ )
                {
                    apServices[i] = NULL;
                }
            }
        }
    }

    delete pscsvc;

    return err;

}   // LM_DOMAIN :: CreateServerData


/*******************************************************************

    NAME:       LM_DOMAIN :: ResetMachinePassword

    SYNOPSIS:   Resets the machine account passwords @ the domain's
                PDC and at the target machine.

    ENTRY:      pszDomainName           - Name of the target domain.

                pszServerName           - Name of the target server
                                          whose password should be
                                          reset.

    EXIT:       If successful, the machine passwords are in sync.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     27-May-1993     Stolen from SM_ADMIN_APP.

********************************************************************/
APIERR LM_DOMAIN :: ResetMachinePasswords( const TCHAR * pszDomainName,
                                           const TCHAR * pszServerName )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( pszServerName != NULL );

    TRACEEOL( "resetting machine account password on " << pszServerName );

    //
    //  Build a number of strings.
    //

    ALIAS_STR nlsServer( pszServerName );
    ISTR istrServer( nlsServer );
    istrServer += 2;        // skip leading backslashes...
    const TCHAR * pszServerNoPrefix = nlsServer.QueryPch( istrServer );

    NLS_STR nlsMachineAccount( pszServerNoPrefix );
    NLS_STR nlsMachinePassword;
    NLS_STR nlsAccountPostfix;
    NLS_STR nlsSecretName;

    //
    //  Ensure the strings constructed properly.
    //

    APIERR err = nlsMachineAccount.QueryError();
    err = err ? err : nlsMachinePassword.QueryError();
    err = err ? err : nlsAccountPostfix.QueryError();
    err = err ? err : nlsSecretName.QueryError();

    //
    //  Build the machine account name.
    //

    err = err ? err : nlsAccountPostfix.MapCopyFrom( (TCHAR *)SSI_ACCOUNT_NAME_POSTFIX );
    err = err ? err : nlsMachineAccount.Append( nlsAccountPostfix );

    //
    //  Choose a new machine account password
    //

    err = err ? err : ADD_COMPUTER_DIALOG::GetMachineAccountPassword(
                                                    pszServerNoPrefix,
                                                    &nlsMachinePassword );

    //
    //  Build the secret name.
    //

    err = err ? err : nlsSecretName.MapCopyFrom( (WCHAR *)SSI_SECRET_NAME );

    //
    //  Reset the machine account password on the
    //  machine's secret object.
    //

    if( err == NERR_Success )
    {
        LSA_POLICY policy( pszServerName, POLICY_ALL_ACCESS );

        err = policy.QueryError();

        if( err == NERR_Success )
        {
            {
                void* pdummy;
                NTSTATUS hr = ::LsaQueryInformationPolicy(
                        policy.QueryHandle(),
                        PolicyDnsDomainInformation,
                        &pdummy );
                if( SUCCEEDED(hr) )
                {
                    TRACEEOL( pszServerName << ", the DC for domain " <<
                              pszDomainName << ", is W2K" );
                    LsaFreeMemory( pdummy );
                    return NERR_Success;
                }
            }

            LSA_SECRET secret( nlsSecretName );

            err = secret.QueryError();

            if( err == NERR_Success )
            {
                err = secret.Open( policy, SECRET_READ | SECRET_WRITE );

                if( err == ERROR_FILE_NOT_FOUND )
                {
                    //
                    //  Secret doesn't exist, so create it.
                    //

                    err = secret.Create( policy );
                }
            }

            if( err == NERR_Success )
            {
                err = secret.SetInfo( &nlsMachinePassword );
            }
        }
    }

    //
    //  Update the password at the domain's PDC.
    //

    if( err == NERR_Success )
    {
        USER_3 usr3( nlsMachineAccount, pszDomainName );

        err = usr3.QueryError();
        err = err ? err : usr3.GetInfo();

        if( err == NERR_UserNotFound )
        {
            //
            //  No machine account exists, so create one.
            //

            TRACEEOL( "creating machine account: " << nlsMachineAccount );

            err = usr3.CreateNew();
            err = err ? err : usr3.SetAccountType( AccountType_ServerTrust );
        }

        err = err ? err : usr3.SetPassword( nlsMachinePassword );
        err = err ? err : usr3.Write();

        RtlZeroMemory( (PVOID)nlsMachinePassword.QueryPch(),
                       nlsMachinePassword.QueryTextSize() );

        if( err == NERR_DCNotFound )
        {
            //
            //  DC is dead.
            //

            TRACEEOL( "DC for " <<
                      pszDomainName <<
                      " is dead, cannot manipulate machine account " <<
                      nlsMachineAccount );

            err = NERR_Success;
        }
    }

    return err;

}   // LM_DOMAIN :: ResetMachinePasswords
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\lmosrvmo.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmosrvmo.cxx
    Class definitions for the SERVER_MODALS class.

    The SERVER_MODALS class is used for retrieving & setting a server's
    server role.  This class is used primarily for performing domain role
    transitions.


    FILE HISTORY:
        KeithMo     13-Sep-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     21-Oct-1991 Remove direct LanMan API calls.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

extern "C"
{
    #include <mnet.h>

}   // extern "C"

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <uibuffer.hxx>

#include <lmosrvmo.hxx>


//
//  SERVER_MODALS methods.
//

/*******************************************************************

    NAME:       SERVER_MODALS :: SERVER_MODALS

    SYNOPSIS:   SERVER_MODALS class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     13-Sep-1991 Created.

********************************************************************/
SERVER_MODALS :: SERVER_MODALS( const TCHAR * pszServerName )
  : _nlsServerName( pszServerName )
{
    //
    //  See if everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsServerName )
    {
        ReportError( _nlsServerName.QueryError() );
        return;
    }

#ifdef  DEBUG
    if( ( pszServerName != NULL ) && ( *pszServerName != TCH('\0') ) )
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( _nlsServerName );

        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == '\\' );
        ++istrDbg;
        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == '\\' );
    }
#endif  // DEBUG

    if( ( pszServerName != NULL ) && ( *pszServerName != TCH('\0') ) )
    {
        //
        //  Validate the server name.
        //

        ISTR istr( _nlsServerName );

        istr += 2;

        if( ::I_MNetNameValidate( NULL,
                                  (TCHAR *)_nlsServerName.QueryPch( istr ),
                                  NAMETYPE_COMPUTER,
                                  0L ) != NERR_Success )
        {
            ReportError( ERROR_INVALID_PARAMETER );
            return;
        }
    }

}   // SERVER_MODALS :: SERVER_MODALS


/*******************************************************************

    NAME:       SERVER_MODALS :: ~SERVER_MODALS

    SYNOPSIS:   SERVER_MODALS class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     13-Sep-1991 Created.

********************************************************************/
SERVER_MODALS :: ~SERVER_MODALS()
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_MODALS :: ~SERVER_MODALS


/*******************************************************************

    NAME:       SERVER_MODALS :: QueryServerRole

    SYNOPSIS:   Returns the server role of the target server.

    ENTRY:      pusRole                 - Pointer to a UINT which
                                          will receive the server role.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      *pusRole is only valid if this method returns success.

    HISTORY:
        KeithMo     13-Sep-1991 Created.

********************************************************************/
APIERR SERVER_MODALS :: QueryServerRole( UINT * puRole )
{
    UIASSERT( puRole != NULL );

    //
    //  Pointer to the modals info.
    //

    struct user_modals_info_1 * pmodals1 = NULL;

    APIERR err = ::MNetUserModalsGet( _nlsServerName.QueryPch(),
                                      1,
                                      (BYTE **)&pmodals1 );

    if( err != NERR_Success )
    {
        ::MNetApiBufferFree( (BYTE **)&pmodals1 );

        return err;
    }

    *puRole = (UINT)pmodals1->usrmod1_role;

    ::MNetApiBufferFree( (BYTE **)&pmodals1 );

    return err;

}   // SERVER_MODALS :: QueryServerRole


/*******************************************************************

    NAME:       SERVER_MODALS :: SetServerRole

    SYNOPSIS:   Sets the server role for the target server.

    ENTRY:      usRole                  - The new server role.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     13-Sep-1991 Created.

********************************************************************/
APIERR SERVER_MODALS :: SetServerRole( UINT uRole )
{
    UIASSERT( ( uRole == UAS_ROLE_MEMBER  ) ||
              ( uRole == UAS_ROLE_BACKUP  ) ||
              ( uRole == UAS_ROLE_PRIMARY ) );

#if defined(WIN32)

    USER_MODALS_INFO_1006 usrmod1006;

    usrmod1006.usrmod1006_role = (DWORD)uRole;

    APIERR err = ::MNetUserModalsSet( _nlsServerName,
                                      MODALS_ROLE_INFOLEVEL,
                                      (BYTE *)&usrmod1006,
                                      sizeof(usrmod1006),
                                      PARMNUM_ALL );

#else   // !WIN32

    APIERR err = ::MNetUserModalsSet( _nlsServerName,
                                      1,
                                      (BYTE *)&uRole,
                                      sizeof(uRole),
                                      MODAL1_PARMNUM_ROLE );

#endif

    return err;

}   // SERVER_MODALS :: SetServerRole
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\password.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    password.cxx
    Class definitions for the PASSWORD_DIALOG class.

    This file contains the class definitions for the PASSWORD_DIALOG
    class.  This class is used to retrieve a server password from the
    user.

    FILE HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"

#include <password.hxx>


//
//  PASSWORD_DIALOG methods.
//

/*******************************************************************

    NAME:       PASSWORD_DIALOG :: PASSWORD_DIALOG

    SYNOPSIS:   PASSWORD_DIALOG class constructor.

    ENTRY:      hWndOwner               - The "owning" window.

                pszServerName           - The name of the target server.

                pnlsPassword            - This string will receive the
                                          password as entered by the user.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

********************************************************************/
PASSWORD_DIALOG :: PASSWORD_DIALOG( HWND         hWndOwner,
                                    const TCHAR * pszServerName,
                                    NLS_STR    * pnlsPassword )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_PASSWORD_DIALOG ), hWndOwner ),
    _sltServerName( this, IDPW_SERVER ),
    _pnlsPassword( pnlsPassword ),
    _password( this, IDPW_SRVPASSWORD, PWLEN+1 )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Display the target server name.
    //

    _sltServerName.SetText( pszServerName );

}   // PASSWORD_DIALOG :: PASSWORD_DIALOG


/*******************************************************************

    NAME:       PASSWORD_DIALOG :: ~PASSWORD_DIALOG

    SYNOPSIS:   PASSWORD_DIALOG class destructor.

    ENTRY:      None.

    EXIT:       The object is destroyed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
PASSWORD_DIALOG :: ~PASSWORD_DIALOG()
{
    //
    //  This space intentionally left blank.
    //

}   // PASSWORD_DIALOG :: ~PASSWORD_DIALOG


/*******************************************************************

    NAME:       PASSWORD_DIALOG :: OnOK

    SYNOPSIS:   This method is called then the user presses the
                [OK] button.

    ENTRY:      None.

    EXIT:       The password buffer is updated.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    NOTES:

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

********************************************************************/
BOOL PASSWORD_DIALOG :: OnOK( VOID )
{
    //
    //  Save the user's password.
    //

    _password.QueryText( _pnlsPassword );

    Dismiss( TRUE );

    return TRUE;

}   // PASSWORD_DIALOG :: OnOK


/*******************************************************************

    NAME:       PASSWORD_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    ENTRY:      None.

    EXIT:       None.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    NOTES:

    HISTORY:
        KeithMo     22-Jul-1991 Created for the Server Manager.

********************************************************************/
ULONG PASSWORD_DIALOG :: QueryHelpContext( void )
{
    return HC_PASSWORD_DIALOG;

}   // PASSWORD_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\repladd.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    repladd.cxx
    Class definitions for the Replicator "Add Sub-Directory" dialog.

    The REPL_ADD_DIALOG class implements the "Add Sub-Directory" dialog
    that is invoked from the REPL_EXPORT_DIALOG and REPL_IMPORT_DIALOG
    dialogs.  The REPL_ADD_DIALOG is used to add a new subdirectory to
    list of subdirectories exported/imported.

    The classes are structured as follows:

        DIALOG_WINDOW
            REPL_ADD_DIALOG


    FILE HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <srvbase.hxx>

#include <dbgstr.hxx>

extern "C" {

    #include <srvmgr.h>
    #include <lmrepl.h>

}   // extern "C"

#include <repladd.hxx>



//
//  REPL_ADD_DIALOG methods
//

/*******************************************************************

    NAME:           REPL_ADD_DIALOG :: REPL_ADD_DIALOG

    SYNOPSIS:       REPL_ADD_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszPath             - The export/import path.

                    pnlsNewSubDir       - Will receive the new sub-
                                          directory.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_ADD_DIALOG :: REPL_ADD_DIALOG( HWND         hWndOwner,
                                    const TCHAR * pszPath,
                                    NLS_STR    * pnlsNewSubDir )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_REPL_ADD ), hWndOwner ),
    _sleSubDir( this, IDRA_SUBDIR ),
    _sltPath( this, IDRA_PATH ),
    _pbOK( this, IDOK ),
    _pnlsNewSubDir( pnlsNewSubDir )
{
    UIASSERT( pszPath != NULL );
    UIASSERT( pnlsNewSubDir != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "REPL_ADD_DIALOG :: REPL_ADD_DIALOG Failed!" );
        return;
    }

    //
    //  Initialize the Path SLT.
    //

    _sltPath.SetText( pszPath );

    //
    //  Since we just constructed, we know that the edit field
    //  must be empty.  Ergo, we'll disable the OK button.
    //

    _pbOK.Enable( FALSE );

}   // REPL_ADD_DIALOG :: REPL_ADD_DIALOG


/*******************************************************************

    NAME:           REPL_ADD_DIALOG :: ~REPL_ADD_DIALOG

    SYNOPSIS:       REPL_ADD_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_ADD_DIALOG :: ~REPL_ADD_DIALOG( VOID )
{
    _pnlsNewSubDir = NULL;

}   // REPL_ADD_DIALOG :: ~REPL_ADD_DIALOG


/*******************************************************************

    NAME:       REPL_ADD_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_ADD_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    switch( event.QueryCid() )
    {
    case IDRA_SUBDIR :
        //
        //  The "Sub-Directory" edit field is trying to tell us something.
        //

        if( event.QueryCode() == EN_CHANGE )
        {
            //
            //  Something has changed in the edit field.
            //
            //  We'll enable the OK button only if there is some
            //  text in the edit field.
            //

            _pbOK.Enable( _sleSubDir.QueryTextLength() > 0 );
        }

        return TRUE;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        return FALSE;
    }

}   // REPL_ADD_DIALOG :: OnCommand


/*******************************************************************

    NAME:       REPL_ADD_DIALOG :: OnOK

    SYNOPSIS:   Invoked whenever the user presses the "OK" button.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_ADD_DIALOG :: OnOK( VOID )
{
    _sleSubDir.QueryText( _pnlsNewSubDir );

    Dismiss( TRUE );
    return TRUE;

}   // REPL_ADD_DIALOG :: OnOK


/*******************************************************************

    NAME:       REPL_ADD_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
ULONG REPL_ADD_DIALOG :: QueryHelpContext( VOID )
{
    return HC_REPL_ADD_DIALOG;

}   // REPL_ADD_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\promote.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    promote.cxx
    This file contains the class definitions for the PROMOTE_DIALOG
    class.

    The PROMOTE_DIALOG class is used to promote a given server to
    Primary, while demoting the current Primary to Server.


    FILE HISTORY:
        KeithMo     01-Oct-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"

#include <promote.hxx>


//
//  PROMOTE_DIALOG methods.
//

#define PROMOTION_POLLING_INTERVAL  1000

/*******************************************************************

    NAME:       PROMOTE_DIALOG :: PROMOTE_DIALOG

    SYNOPSIS:   PROMOTE_DIALOG class constructor.

    ENTRY:      hWndOwner               - Handle to the owning window.

                pszDomainName           - The domain name.

                pszNewPrimaryName       - The name of the server being
                                          promoted to Primary.

                fIsNtDomain             - TRUE is this is an NT domain.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     01-Oct-1991 Created.

********************************************************************/
PROMOTE_DIALOG :: PROMOTE_DIALOG( HWND          hWndOwner,
                                  const TCHAR * pszDomainName,
                                  const TCHAR * pszNewPrimaryName,
                                  BOOL          fIsNtDomain )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_PROMOTE_DIALOG ), hWndOwner ),
    _domain( pszDomainName, fIsNtDomain ),
    _timer( this, PROMOTION_POLLING_INTERVAL, FALSE ),
    _slt1( this, IDPD_MESSAGE1 ),
    _slt2( this, IDPD_MESSAGE2 ),
    _slt3( this, IDPD_MESSAGE3 ),
    _progress( this, IDPD_PROGRESS, IDI_PROGRESS_ICON_0, IDI_PROGRESS_NUM_ICONS ),
    _menuClose( this, SC_CLOSE )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( pszNewPrimaryName != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _domain.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Disable the "Close" item in the system menu.
    //

    _menuClose.Enable( FALSE );

    //
    //  Initiate the promotion.
    //

    const ALIAS_STR nlsNewWithoutPrefix( pszNewPrimaryName );
    UIASSERT( nlsNewWithoutPrefix.QueryError() == NERR_Success );

    NLS_STR nlsNewWithPrefix( SZ("\\\\") );

    err = nlsNewWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    nlsNewWithPrefix.strcat( nlsNewWithoutPrefix );

    err = nlsNewWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  This may take a while...
    //

    AUTO_CURSOR cursor;

    err = _domain.SetPrimary( this,
                              nlsNewWithPrefix,
                              PROMOTION_POLLING_INTERVAL );

    if( err != DOMAIN_STATUS_PENDING )
    {
        ReportError( err );
        return;
    }

    //
    //  Now that everything is setup, we can enable our timer.
    //

    _timer.Enable( TRUE );

}   // PROMOTE_DIALOG :: PROMOTE_DIALOG


/*******************************************************************

    NAME:       PROMOTE_DIALOG :: ~PROMOTE_DIALOG

    SYNOPSIS:   PROMOTE_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     01-Oct-1991 Created.

********************************************************************/
PROMOTE_DIALOG :: ~PROMOTE_DIALOG()
{
    //
    //  This space intentionally left blank.
    //

}   // PROMOTE_DIALOG :: ~PROMOTE_DIALOG


/*******************************************************************

    NAME:       PROMOTE_DIALOG :: OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        KeithMo     01-Oct-1991 Created.

********************************************************************/
VOID PROMOTE_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
    }

    //
    //  Check the SetPrimary() progress.
    //

    APIERR err = _domain.Poll( this );

    if( err != DOMAIN_STATUS_PENDING )
    {
        Dismiss( err );
    }

}   // PROMOTE_DIALOG :: OnTimerNotification


/*******************************************************************

    NAME:       PROMOTE_DIALOG :: Notify

    SYNOPSIS:   Notify the user that either a milestone was reached
                or an error has occurred.

    ENTRY:      err                     - The error code.  Will be
                                          NERR_Success if this is
                                          a milestone notification.

                action                  - An ACTIONCODE, specifying
                                          the type of operation
                                          being performed.

                pszParam1               - First parameter (always
                                          a target server name).

                pszParam2               - Second parameter (either a
                                          role name or service name).

    HISTORY:
        KeithMo     01-Oct-1991 Created.

********************************************************************/
VOID PROMOTE_DIALOG :: Notify( APIERR        err,
                               ACTIONCODE    action,
                               const TCHAR * pszParam1,
                               const TCHAR * pszParam2 )
{
    UIASSERT( action > AC_First );
    UIASSERT( action < AC_Last  );

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  Display the notification.
    //

    ALIAS_STR nlsServer( pszParam1+2 );
    ALIAS_STR nlsParam2( SZ("") );

    if( pszParam2 != NULL )
    {
        nlsParam2 = pszParam2;
    }

    const NLS_STR * apnlsParams[3];

    apnlsParams[0] = &nlsServer;
    apnlsParams[1] = &nlsParam2;
    apnlsParams[2] = NULL;

    NLS_STR nlsMsg;

    nlsMsg.Load( IDS_AC_RESYNCING + (INT)action - 1 );
    nlsMsg.InsertParams( apnlsParams );

    _slt2.SetText( nlsMsg.QueryPch() );

    if( err != NERR_Success )
    {
        DisplayGenericError( this,
                             IDS_DOMAIN_RESYNC_ERROR + (INT)action - 1,
                             err,
                             nlsServer,
                             nlsParam2 );
    }

}   // PROMOTE_DIALOG :: Notify


/*******************************************************************

    NAME:       PROMOTE_DIALOG :: Warning

    SYNOPSIS:   Warn the user of potential error conditions.

    ENTRY:      warning                 - A WARNINGCODE which specifies
                                          the type of warning being
                                          presented.

    RETURN:     BOOL                    - TRUE if it is safe to continue
                                          the domain role transition.

                                          FALSE if the role transition
                                          should be aborted.

    HISTORY:
        KeithMo     04-Oct-1991 Created.

********************************************************************/
BOOL PROMOTE_DIALOG :: Warning( WARNINGCODE warning )
{
    UIASSERT( warning > WC_First );
    UIASSERT( warning < WC_Last  );

    //
    //  This callback may get invoked during the initial
    //  setup for the promotion operation.  Therefore,
    //  we must ensure that the current cursor is an arrow.
    //

    AUTO_CURSOR Cursor( IDC_ARROW );

    switch( warning )
    {
    case WC_CannotFindPrimary :
        if( MsgPopup( this,
                      IDS_WARN_NO_PDC,
                      MPSEV_WARNING,
                      MP_OKCANCEL,
                      _domain.QueryName() ) == IDOK )
        {
            return TRUE;
        }
        break;

    default:
        UIASSERT( 0 );
        break;
    }

    //
    //  If we've made it this far, then we'll abort the promotion.
    //

    return FALSE;

}   // PROMOTE_DIALOG :: Warning
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\opendlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    openlb.cxx
    Class definitions for the OPENS_DIALOG, OPENS_LISTBOX, and
    OPENS_LBI classes.

    The OPENS_DIALOG is used to show the remotely open files on a
    particular server.  This listbox contains a [Close] button to
    allow the admin to close selected files.


    FILE HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        terryk      25-Aug-1991 Remove ::NetFileClose2 BUG-BUG
        KeithMo     26-Aug-1991 Changes from code review attended by
                                RustanL and EricCh.
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     04-Nov-1991 Added "Refresh" button.
        ChuckC      31-Dec-1991 Now uses OPENFILE from applib

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmosrv.hxx>

extern "C"
{
    #include <srvmgr.h>
}

#include <opendlg.hxx>
#include <prefix.hxx>
#include <ellipsis.hxx>

//
//  OPENS_DIALOG methods.
//

/*******************************************************************

    NAME:       OPENS_DIALOG :: OPENS_DIALOG

    SYNOPSIS:   OPENS_DIALOG class constructor.

    ENTRY:      hwndOwner               - The "owning" dialog.

                pszServer               - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        KeithMo     20-Aug-1991 Now inherits from PSEUDOSERVICE_DIALOG.
        KeithMo     20-Aug-1991 Now inherits from SRVPROP_OTHER_DIALOG.
        KeithMo     05-Feb-1992 Now takes SERVER_2 * instead of a TCHAR *.

********************************************************************/
OPENS_DIALOG :: OPENS_DIALOG( HWND       hwndOwner,
                              SERVER_2 * pserver )
  : OPEN_DIALOG_BASE( hwndOwner,
                      IDD_OPEN_RESOURCES,
                      IDOR_OPENFILES,
                      IDOR_FILELOCKS,
                      IDOR_CLOSE,
                      IDOR_CLOSEALL,
                      pserver->QueryName(),
                      SZ(""),
                      &_lbFiles),
    _lbFiles( this, IDOR_OPENLIST, _nlsServer, _nlsBasePath ),
    _pbRefresh( this, IDOR_REFRESH )
{
    //
    //  Let's make sure everything constructed OK.
    //
    if( QueryError() != NERR_Success )
        return;

    //
    //  Set the caption.
    //
    APIERR err = SRV_BASE_DIALOG::SetCaption( this,
                                              IDS_CAPTION_OPENRES,
                                              pserver->QueryName() ) ;
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Refresh the dialog.
    //
    Refresh();

    err = BASE_ELLIPSIS::Init();
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }
}   // OPENS_DIALOG :: OPENS_DIALOG


/*******************************************************************

    NAME:       OPENS_DIALOG :: ~OPENS_DIALOG

    SYNOPSIS:   OPENS_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
OPENS_DIALOG :: ~OPENS_DIALOG()
{
    BASE_ELLIPSIS::Term();
}   // OPENS_DIALOG :: ~OPENS_DIALOG


/*******************************************************************

    NAME:       OPENS_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      cid                     - Control ID.

                lParam                  - lParam from the message.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.
        KeithMo     06-Oct-1991 Now takes a CONTROL_EVENT.

********************************************************************/
BOOL OPENS_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    //
    //  Determine the control which is sending the command.
    //

    switch( event.QueryCid() )
    {
    case IDOR_REFRESH:
        Refresh();
        return TRUE;

    default:
        return (OPEN_DIALOG_BASE::OnCommand(event)) ;
    }

    return FALSE;

}   // OPENS_DIALOG :: OnCommand


/*******************************************************************

    NAME:       OPENS_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
ULONG OPENS_DIALOG :: QueryHelpContext( void )
{
    return HC_OPENS_DIALOG;

}   // OPENS_DIALOG :: QueryHelpContext


//
//  OPENS_LISTBOX methods.
//

/*******************************************************************

    NAME:       OPENS_LISTBOX :: OPENS_LISTBOX

    SYNOPSIS:   OPENS_LISTBOX class constructor.

    ENTRY:      powOwner                - The "owning" window.

                cid                     - The listbox CID.

                nlsServer               - Name of target server

                nlsBasePath             - Base Path of File Enum

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     01-Aug-1991 Created for the Server Manager.

********************************************************************/
OPENS_LISTBOX :: OPENS_LISTBOX( OWNER_WINDOW   * powOwner,
                                CID              cid,
                                const NLS_STR  & nlsServer,
                                const NLS_STR  & nlsBasePath)
  : OPEN_LBOX_BASE( powOwner, cid, nlsServer, nlsBasePath ),
    _dteFile( IDBM_LB_FILE ),
    _dteComm( IDBM_LB_COMM ),
    _dtePipe( IDBM_LB_PIPE ),
    _dtePrint( IDBM_LB_PRINT ),
    _dteUnknown( IDBM_LB_UNKNOWN )
{
    //
    //  Ensure we constructed properly.
    //
    if( QueryError() != NERR_Success )
        return;

    APIERR err;
    if( ( ( err = _dteFile.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dteComm.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dtePipe.QueryError()    ) != NERR_Success ) ||
        ( ( err = _dtePrint.QueryError()   ) != NERR_Success ) ||
        ( ( err = _dteUnknown.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Build the column width table to be used by
    //  OPENS_LBI :: Paint().
    //
    DISPLAY_TABLE::CalcColumnWidths(_adx,
                                    5,
                                    powOwner,
                                    cid,
                                    TRUE) ;

}   // OPENS_LISTBOX :: OPENS_LISTBOX


/*******************************************************************

    NAME:       OPENS_LISTBOX :: ~OPENS_LISTBOX

    SYNOPSIS:   OPENS_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
OPENS_LISTBOX :: ~OPENS_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // OPENS_LISTBOX :: ~OPENS_LISTBOX


/*******************************************************************

    NAME:       OPENS_LISTBOX :: CreateFileEntry

    SYNOPSIS:   Create the appropriate LBI for base dialog to use

    EXIT:

    RETURNS:    Pointer to the newly created LBI

    HISTORY:
        ChuckC      29-Dec-1991 Redid this code to be virtual method so that
                                parent can use it.

********************************************************************/
OPEN_LBI_BASE *OPENS_LISTBOX :: CreateFileEntry( const FILE3_ENUM_OBJ *pfi3 )
{
    //
    //  Determine the DMID_DTE appropriate for
    //  this resource type.
    //
    DMID_DTE * pdte;

    if( IS_FILE( pfi3->QueryPathName() ) )
    {
        pdte = &_dteFile;
    }
    else
    if( IS_COMM( pfi3->QueryPathName() ) )
    {
        pdte = &_dteComm;
    }
    else
    if( IS_PIPE( pfi3->QueryPathName() ) )
    {
        pdte = &_dtePipe;
    }
    else
    if( IS_PRINT( pfi3->QueryPathName() ) )
    {
        pdte = &_dtePrint;
    }
    else
    {
        pdte = &_dteUnknown;
    }

    return
        new OPENS_LBI( pfi3->QueryUserName(),
                       pfi3->QueryPermissions(),
                       pfi3->QueryNumLocks(),
                       pfi3->QueryPathName(),
                       pfi3->QueryFileId(),
                       pdte );

}   // OPENS_LISTBOX :: CreateFileEntry



//
//  OPENS_LBI methods.
//

/*******************************************************************

    NAME:       OPENS_LBI :: OPENS_LBI

    SYNOPSIS:   OPENS_LBI class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                usPermissions           - Open permissions.

                cLocks                  - Number of locks.

                pszPath                 - The open pathname.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Use DMID_DTE passed into constructor.

********************************************************************/
OPENS_LBI :: OPENS_LBI( const TCHAR * pszUserName,
                        ULONG        uPermissions,
                        ULONG        cLocks,
                        const TCHAR * pszPath,
                        ULONG        ulFileID,
                        DMID_DTE   * pdte )
  : OPEN_LBI_BASE( pszUserName,
                   pszPath,
                   uPermissions,
                   cLocks,
                   ulFileID),
    _pdte( pdte )
{
    ; // nothing more to do.
}


/*******************************************************************

    NAME:       OPENS_LBI :: ~OPENS_LBI

    SYNOPSIS:   OPENS_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.

********************************************************************/
OPENS_LBI :: ~OPENS_LBI()
{
    ;
}


/*******************************************************************

    NAME:       OPENS_LBI :: Paint

    SYNOPSIS:   Draw an entry in OPENS_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Use DMID_DTE passed into constructor.
        KeithMo     06-Oct-1991 Now takes a const RECT *.
        beng        22-Apr-1992 Changes to LBI::Paint

********************************************************************/
VOID OPENS_LBI :: Paint( LISTBOX *     plb,
                         HDC           hdc,
                         const RECT  * prect,
                         GUILTT_INFO * pGUILTT ) const
{
    STR_DTE dteUserName( _nlsUserName.QueryPch() );
    STR_DTE dteAccess( _nlsAccess.QueryPch() );
    STR_DTE dteLocks( _nlsLocks.QueryPch() );
    STR_DTE_ELLIPSIS dtePath( _nlsPath.QueryPch(), plb, ELLIPSIS_PATH );

    DISPLAY_TABLE dtab( 5, ((OPENS_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = _pdte;
    dtab[1] = &dteUserName;
    dtab[2] = &dteAccess;
    dtab[3] = &dteLocks;
    dtab[4] = &dtePath;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // OPENS_LBI :: Paint


/*******************************************************************

    NAME:       OPENS_LBI :: Compare

    SYNOPSIS:   Compare two OPENS_LBI items.

    ENTRY:      plbi                    - The "other" item.

    RETURNS:    INT                     -  0 if the items match.
                                          -1 if we're < the other item.
                                          +1 if we're > the other item.

    HISTORY:
        KeithMo     31-May-1991 Created for the Server Manager.

********************************************************************/
INT OPENS_LBI :: Compare( const LBI * plbi ) const
{
    const NLS_STR * pnls = &(((const OPENS_LBI *)plbi)->_nlsUserName);
    INT       nResult = _nlsUserName._stricmp( *pnls );

    if( nResult == 0 )
    {
        pnls    = &(((const OPENS_LBI *)plbi)->_nlsPath);
        nResult = _nlsPath._stricmp( *pnls );
    }

    return nResult;

}   // OPENS_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\replimp.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    replimp.cxx
    Class definitions for Replicator Admin Import Management dialog.

    The REPL_IMPORT_* classes implement the Replicator Import Management
    dialog.  This dialog is invoked from the REPL_MAIN_DIALOG.

    The classes are structured as follows:

        LBI
            EXPORT_IMPORT_LBI
                REPL_IMPORT_LBI

        BLT_LISTBOX
            EXPORT_IMPORT_LISTBOX
                REPL_IMPORT_LISTBOX

        DIALOG_WINDOW
            EXPORT_IMPORT_DIALOG
                REPL_IMPORT_DIALOG


    FILE HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmorepli.hxx>
#include <srvbase.hxx>
#include <strnumer.hxx>
#include <dbgstr.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C" {

    #include <srvmgr.h>
    #include <lmrepl.h>
    #include <time.h>

}   // extern "C"

#include <replimp.hxx>



//
//  Defaults for AddDefaultDir.
//

#define DEFAULT_STATE           REPL_STATE_NO_MASTER
#define DEFAULT_LOCK_COUNT      0
#define DEFAULT_LOCK_TIME       0
#define DEFAULT_UPDATE_TIME     0



//
//  REPL_IMPORT_DIALOG methods
//

/*******************************************************************

    NAME:           REPL_IMPORT_DIALOG :: REPL_IMPORT_DIALOG

    SYNOPSIS:       REPL_IMPORT_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pserver             - A SERVER_2 object representing
                                          the target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_IMPORT_DIALOG :: REPL_IMPORT_DIALOG( HWND          hWndOwner,
                                          SERVER_2    * pserver,
                                          const TCHAR * pszImportPath )
  : EXPORT_IMPORT_DIALOG( hWndOwner,
                          MAKEINTRESOURCE( IDD_IMPORT_MANAGE ),
                          IDS_CAPTION_REPL,
                          pserver,
                          pszImportPath,
                          &_lbImportList,
                          FALSE ),
    _lbImportList( this, pserver )
{
    UIASSERT( pserver != NULL );
    UIASSERT( pszImportPath != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "REPL_IMPORT_DIALOG :: REPL_IMPORT_DIALOG Failed!" );
        return;
    }

    //
    //  Call the Phase II constructor.
    //

    APIERR err = CtAux();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Fill the listbox.
    //

    err = _lbImportList.Fill();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UpdateTextAndButtons();

}   // REPL_IMPORT_DIALOG :: REPL_IMPORT_DIALOG


/*******************************************************************

    NAME:           REPL_IMPORT_DIALOG :: ~REPL_IMPORT_DIALOG

    SYNOPSIS:       REPL_IMPORT_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_IMPORT_DIALOG :: ~REPL_IMPORT_DIALOG( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IMPORT_DIALOG :: ~REPL_IMPORT_DIALOG


/*******************************************************************

    NAME:       REPL_IMPORT_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    NOTES:      This method should *always* fall through to
                EXPORT_IMPORT_DIALOG::OnCommand().

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_IMPORT_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    //
    //  All command events must be passed up to the base class!
    //

    return EXPORT_IMPORT_DIALOG :: OnCommand( event );

}   // REPL_IMPORT_DIALOG :: OnCommand


/*******************************************************************

    NAME:       REPL_IMPORT_DIALOG :: OnOK

    SYNOPSIS:   Invoked whenever the user presses the "OK" button.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_IMPORT_DIALOG :: OnOK( VOID )
{
    AUTO_CURSOR NiftyCursor;

    //
    //  We'll use this iterator to scan the list of
    //  removed directories.
    //

    ITER_SL_OF( NLS_STR ) iter( _slistRemoved );
    NLS_STR * pnls;

    //
    //  Scan _slistRemoved, removing the named directories.
    //

    APIERR err = NERR_Success;

    while( ( pnls = iter.Next() ) != NULL )
    {
        REPL_IDIR_0 idir( QueryServerName(), pnls->QueryPch() );

        err = idir.QueryError();

        if( err == NERR_Success )
        {
            err = idir.Delete();

            //
            //  If Delete will return NERR_UnknownDevDir if
            //  the directory does not exist.  We'll map this
            //  to NERR_Success, since the user wanted this
            //  directory deleted anyway.
            //

            if( err == NERR_UnknownDevDir )
            {
                err = NERR_Success;
            }
        }

        if( err != NERR_Success )
        {
            break;
        }
    }

    if( err != NERR_Success )
    {
        //
        //  Error deleting a directory.
        //

        MsgPopup( this, err );
        return FALSE;
    }

    //
    //  Scan the listbox.
    //

    INT cItems = _lbImportList.QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        REPL_IMPORT_LBI * plbi = _lbImportList.QueryItem( i );
        UIASSERT( plbi != NULL );

        //
        //  If the directory isn't dirty, don't bother updating.
        //

        if( !plbi || !plbi->IsDirty() ) // JonN 01/28/00: PREFIX bug 444938
        {
            continue;
        }

        //
        //  Create our replicator import directory object.
        //

        REPL_IDIR_1 idir( QueryServerName(), plbi->QuerySubDirectory() );

        err = idir.QueryError();

        if( err == NERR_Success )
        {
            //
            //  If this IS a pre-existing directory, then we just
            //  invoke GetInfo() on the object.  Otherwise, we must
            //  Create() the new object.
            //

            if( plbi->IsPreExisting() )
            {
                err = idir.GetInfo();
            }
            else
            {
                err = idir.CreateNew();

                if( err == NERR_Success )
                {
                    err = idir.WriteNew();
                }
            }
        }

        if( err == NERR_Success )
        {
            //
            //  Set the attributes from the listbox item.
            //

            idir.SetLockBias( plbi->QueryLockBias() );

            //
            //  Update the directory.
            //

            err = idir.WriteInfo();
        }

        if( err != NERR_Success )
        {
            break;
        }
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
        return FALSE;
    }

    Dismiss( TRUE );
    return TRUE;

}   // REPL_IMPORT_DIALOG :: OnOK


/*******************************************************************

    NAME:       REPL_IMPORT_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
ULONG REPL_IMPORT_DIALOG :: QueryHelpContext( VOID )
{
    return HC_REPL_IMPORT_DIALOG;

}   // REPL_IMPORT_DIALOG :: QueryHelpContext



//
//  REPL_IMPORT_LISTBOX methods
//

/*******************************************************************

    NAME:           REPL_IMPORT_LISTBOX :: REPL_IMPORT_LISTBOX

    SYNOPSIS:       REPL_IMPORT_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_IMPORT_LISTBOX :: REPL_IMPORT_LISTBOX( OWNER_WINDOW * powner,
                                            SERVER_2     * pserver )
  : EXPORT_IMPORT_LISTBOX( powner, REPL_IMPORT_LISTBOX_COLUMNS, pserver ),
    _nlsOK( IDS_IDIR_OK ),
    _nlsNoMaster( IDS_IDIR_NO_MASTER ),
    _nlsNoSync( IDS_IDIR_NO_SYNC ),
    _nlsNeverReplicated( IDS_IDIR_NEVER_REPLICATED )
{
    UIASSERT( pserver != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsOK )
    {
        ReportError( _nlsOK.QueryError() );
        return;
    }

    if( !_nlsNoMaster )
    {
        ReportError( _nlsNoMaster.QueryError() );
        return;
    }

    if( !_nlsNoSync )
    {
        ReportError( _nlsNoSync.QueryError() );
        return;
    }

    if( !_nlsNeverReplicated )
    {
        ReportError( _nlsNeverReplicated.QueryError() );
        return;
    }

}   // REPL_IMPORT_LISTBOX :: REPL_IMPORT_LISTBOX


/*******************************************************************

    NAME:           REPL_IMPORT_LISTBOX :: ~REPL_IMPORT_LISTBOX

    SYNOPSIS:       REPL_IMPORT_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
REPL_IMPORT_LISTBOX :: ~REPL_IMPORT_LISTBOX( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IMPORT_LISTBOX :: ~REPL_IMPORT_LISTBOX


/*******************************************************************

    NAME:           REPL_IMPORT_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_IMPORT_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    REPL_IDIR1_ENUM enumIdir( QueryServerName() );

    APIERR err = enumIdir.GetInfo();

    if( err == NERR_Success )
    {
        REPL_IDIR1_ENUM_ITER iterIdir( enumIdir );
        const REPL_IDIR1_ENUM_OBJ * pIdir;

        while( ( pIdir = iterIdir() ) != NULL )
        {
            REPL_IMPORT_LBI * plbi;

            plbi = new REPL_IMPORT_LBI( pIdir->QueryDirName(),
                                        pIdir->QueryState(),
                                        MapStateToName( pIdir->QueryState() ),
                                        pIdir->QueryLockCount(),
                                        pIdir->QueryLockTime(),
                                        pIdir->QueryLastUpdateTime(),
                                        TRUE );

            if( AddItem( plbi ) < 0 )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

        }
    }

    if( ( err == NERR_Success ) && ( QueryCount() > 0 ) )
    {
        SelectItem( 0 );
    }

    return err;

}   // REPL_IMPORT_LISTBOX :: Fill


/*******************************************************************

    NAME:           REPL_IMPORT_LISTBOX :: AddDefaultSubDir

    SYNOPSIS:       Adds a new subdirectory to the listbox using
                    default parameters.

    ENTRY:          pszSubDirectory     - The name of the target subdir.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_IMPORT_LISTBOX :: AddDefaultSubDir( const TCHAR * pszSubDirectory,
                                                BOOL          fPreExisting )
{
    REPL_IMPORT_LBI * plbi = new REPL_IMPORT_LBI( pszSubDirectory,
                                                  DEFAULT_STATE,
                                                  MapStateToName( DEFAULT_STATE ),
                                                  DEFAULT_LOCK_COUNT,
                                                  DEFAULT_LOCK_TIME,
                                                  DEFAULT_UPDATE_TIME,
                                                  fPreExisting );

    APIERR err = NERR_Success;

    INT iItem = AddItem( plbi );

    if( iItem >= 0 )
    {
        SelectItem( iItem );
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;

}   // REPL_IMPORT_LISTBOX :: AddDefaultSubDir


/*******************************************************************

    NAME:           REPL_IMPORT_LISTBOX :: MapStateToName

    SYNOPSIS:       Maps a Replicator import directory state (such as
                    REPL_STATE_NO_MASTER) to a displayable form (such
                    as "No Master").

    ENTRY:          State               - The state to map.

    RETURNS         const TCHAR *       - The name of the state.

    HISTORY:
        KeithMo     20-Feb-1992     Created for the Server Manager.

********************************************************************/
const TCHAR * REPL_IMPORT_LISTBOX :: MapStateToName( ULONG State )
{
    switch( State )
    {
    case REPL_STATE_OK :
        return _nlsOK.QueryPch();
        break;

    case REPL_STATE_NO_MASTER :
        return _nlsNoMaster.QueryPch();
        break;

    case REPL_STATE_NO_SYNC :
        return _nlsNoSync.QueryPch();
        break;

    case REPL_STATE_NEVER_REPLICATED :
        return _nlsNeverReplicated.QueryPch();
        break;

    default :
        UIASSERT( FALSE );
        return SZ("??");
        break;
    }

}   // REPL_IMPORT_LISTBOX



//
//  REPL_IMPORT_LBI methods
//

/*******************************************************************

    NAME:           REPL_IMPORT_LBI :: REPL_IMPORT_LBI

    SYNOPSIS:       REPL_IMPORT_LBI class constructor.

    ENTRY:          pszSubDirectory     - The name of the target entity.  This
                                          will be either a server name or a
                                          domain name in either the export
                                          list or the import list.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_IMPORT_LBI :: REPL_IMPORT_LBI( const TCHAR * pszSubDirectory,
                                    ULONG         lState,
                                    const TCHAR * pszStateName,
                                    ULONG         lLockCount,
                                    ULONG         lLockTime,
                                    ULONG         lUpdateTime,
                                    BOOL          fPreExisting )
  : EXPORT_IMPORT_LBI( pszSubDirectory, lLockCount, lLockTime, fPreExisting ),
    _lState( lState ),
    _pszStateName( pszStateName ),
    _nlsUpdateTime()
{
    UIASSERT( pszSubDirectory != NULL );
    UIASSERT( pszStateName != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsUpdateTime )
    {
        ReportError( _nlsUpdateTime.QueryError() );
        return;
    }

    //
    //  Build the more complex display strings.
    //

    APIERR err = NERR_Success;

    if( lUpdateTime > 0 )
    {
        WIN_TIME     wintime( lUpdateTime );
        INTL_PROFILE intlprof;
        NLS_STR      nlsTime;

        err = wintime.QueryError();

        if( err == NERR_Success )
        {
            err = intlprof.QueryError();
        }

        if( err == NERR_Success )
        {
            err = nlsTime.QueryError();
        }

        if( err == NERR_Success )
        {
            err = intlprof.QueryShortDateString( wintime, &_nlsUpdateTime );
        }

        if( err == NERR_Success )
        {
            err = intlprof.QueryTimeString( wintime, &nlsTime );
        }

        if( err == NERR_Success )
        {
            err = _nlsUpdateTime.Append( SZ(" ") );
        }

        if( err == NERR_Success )
        {
            err = _nlsUpdateTime.Append( nlsTime );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // REPL_IMPORT_LBI :: REPL_IMPORT_LBI


/*******************************************************************

    NAME:           REPL_IMPORT_LBI :: ~REPL_IMPORT_LBI

    SYNOPSIS:       REPL_IMPORT_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_IMPORT_LBI :: ~REPL_IMPORT_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IMPORT_LBI :: ~REPL_IMPORT_LBI


/*******************************************************************

    NAME:           REPL_IMPORT_LBI :: Paint

    SYNOPSIS:       Draw an entry in REPL_IMPORT_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        beng        22-Apr-1992     Changes to LBI::Paint

********************************************************************/
VOID REPL_IMPORT_LBI :: Paint( LISTBOX *          plb,
                               HDC                hdc,
                               const RECT       * prect,
                               GUILTT_INFO      * pGUILTT ) const
{
    REPL_IMPORT_LISTBOX * pMylb = (REPL_IMPORT_LISTBOX *)plb;

    DEC_STR nlsLockCount( QueryVirtualLockCount() );

    STR_DTE dteSubDirectory( QuerySubDirectory() );
    STR_DTE dteLockCount( nlsLockCount );
    STR_DTE dteState( QueryStateName() );
    STR_DTE dteLockTime( QueryLockTimeString() );
    STR_DTE dteUpdateTime( QueryUpdateTimeString() );

    DISPLAY_TABLE dtab( REPL_IMPORT_LISTBOX_COLUMNS,
                        pMylb->QueryColumnWidths() );

    dtab[0] = &dteSubDirectory;
    dtab[1] = &dteLockCount;
    dtab[2] = &dteState;
    dtab[3] = &dteUpdateTime;
    dtab[4] = &dteLockTime;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // REPL_IMPORT_LBI :: Paint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\replbase.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    replbase.cxx
    Abstrace base class definitions for Replicator Admin Export/Import
    Management dialogs.

    The EXPORT_IMPORT_* classes implement the common base behaviour that
    is shared between the REPL_EXPORT_* and REPL_IMPORT_* classes.

    The classes are structured as follows:

        LBI
            EXPORT_IMPORT_LBI

        BLT_LISTBOX
            EXPORT_IMPORT_LISTBOX

        DIALOG_WINDOW
            EXPORT_IMPORT_DIALOG


    FILE HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <srvbase.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

#include <dbgstr.hxx>

extern "C" {

    #include <srvmgr.h>
    #include <lmrepl.h>

}   // extern "C"

#include <replbase.hxx>



//
//  EXPORT_IMPORT_DIALOG needs a list of NLS_STR.
//  So here it is.
//

DEFINE_EXT_SLIST_OF(NLS_STR);



//
//  EXPORT_IMPORT_DIALOG methods.
//

/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: EXPORT_IMPORT_DIALOG

    SYNOPSIS:       EXPORT_IMPORT_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    cid                 - The control ID for this
                                          dialog.

                    idCaption           - The string ID for this dialog's
                                          caption bar.

                    pserver             - A SERVER_2 object representing
                                          the target server.

                    plb                 - An EXPORT_IMPORT_LISTBOX *
                                          representing the appropriate
                                          directory listbox.

                    fExport             - TRUE if this is an EXPORT dialog,
                                          FALSE if it is an IMPORT dialog.

    EXIT:           The object is constructed.

    NOTES:          At the time this constructor is called, the listbox
                    pointed to by plb is NOT YET FULLY CONSTRUCTED!  Do
                    *NOT* manipulate this listbox in any way from within
                    this constructor!!

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
EXPORT_IMPORT_DIALOG :: EXPORT_IMPORT_DIALOG( HWND                    hWndOwner,
                                              const TCHAR           * pszResource,
                                              MSGID                   idCaption,
                                              SERVER_2              * pserver,
                                              const TCHAR           * pszPath,
                                              EXPORT_IMPORT_LISTBOX * plb,
                                              BOOL                    fExport )
  : DIALOG_WINDOW( pszResource, hWndOwner ),
    _sltPath( this, IDIE_PATH ),
    _sltSubDir( this, IDIE_SUBDIR ),
    _plbList( plb ),
    _pbAddLock( this, IDIE_ADDLOCK ),
    _pbRemoveLock( this, IDIE_REMOVELOCK ),
    _pbAddDir( this, IDIE_ADDDIR ),
    _pbRemoveDir( this, IDIE_REMOVEDIR ),
    _pserver( pserver ),
    _fExport( fExport ),
    _slistRemoved(),
    _nlsDisplayName()
{
    UIASSERT( pserver != NULL );
    UIASSERT( plb != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "EXPORT_IMPORT_DIALOG :: EXPORT_IMPORT_DIALOG Failed!" );
        return;
    }

    APIERR err = _nlsDisplayName.QueryError();

    if( err == NERR_Success )
    {
        err = _pserver->QueryDisplayName( &_nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Display the export/import path.
        //

        _sltPath.SetText( pszPath );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // EXPORT_IMPORT_DIALOG :: EXPORT_IMPORT_DIALOG


/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: ~EXPORT_IMPORT_DIALOG

    SYNOPSIS:       EXPORT_IMPORT_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
EXPORT_IMPORT_DIALOG :: ~EXPORT_IMPORT_DIALOG( VOID )
{
    _pserver = NULL;
    _plbList = NULL;

}   // EXPORT_IMPORT_DIALOG :: ~EXPORT_IMPORT_DIALOG


/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: CtAux

    SYNOPSIS:       EXPORT_IMPORT_DIALOG auxiliary constructor.

    EXIT:           Phase II construction is complete.

    NOTES:          This should be the *FIRST* method called from
                    the derived subclass's constructor.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR EXPORT_IMPORT_DIALOG :: CtAux( VOID )
{
    UIASSERT( _plbList->QueryCid() == IDIE_DIRLIST );

    return NERR_Success;

}   // EXPORT_IMPORT_DIALOG :: CtAux


/*******************************************************************

    NAME:       EXPORT_IMPORT_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        JonN        27-Feb-1995     RemoveLock does not destroy focus

********************************************************************/
BOOL EXPORT_IMPORT_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    switch( event.QueryCid() )
    {
    case IDIE_ADDLOCK :
       {
        EXPORT_IMPORT_LBI * plbi = _plbList->QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444928

        plbi->AddLock();
        _pbRemoveLock.Enable( plbi->QueryVirtualLockCount() > 0 );

        _plbList->InvalidateItem( _plbList->QueryCurrentItem(), TRUE );
        return TRUE;
        break;
       }
    case IDIE_REMOVELOCK :
       {
        EXPORT_IMPORT_LBI * plbi = _plbList->QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444927

        plbi->RemoveLock();
        // This is liable to disable the button while it has focus,
        // so move focus elsewhere
        if ( plbi->QueryVirtualLockCount() == 0 )
        {
            TRACEEOL( "Srvmgr EXPORT_IMPORT_DIALOG::OnCommand(): focus fix" );
            SetDialogFocus( _pbAddLock );
        }
        _pbRemoveLock.Enable( plbi->QueryVirtualLockCount() > 0 );

        _plbList->InvalidateItem( _plbList->QueryCurrentItem(), TRUE );
        return TRUE;
        break;
       }
    case IDIE_ADDDIR :
       {
        AddNewSubDirectory();
        return TRUE;
        break;
       }
    case IDIE_REMOVEDIR :
       {
        RemoveSubDirectory();
        return TRUE;
        break;
       }
    case IDIE_DIRLIST :
       {
        //
        //  The listbox is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The use has changed the selection in the listbox.
            //
            //  Update the various controls.
            //

            UpdateTextAndButtons();
        }
        return TRUE;
        break;
       }
    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //
       {
        return FALSE;
        break;
       }
    }

}   // EXPORT_IMPORT_DIALOG :: OnCommand


/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: AddNewSubDirectory

    SYNOPSIS:       This method is invoked whenever the user presses
                    the 'Add' button in either the Export Manager or
                    Import Manage dialogs.

    EXIT:

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID EXPORT_IMPORT_DIALOG :: AddNewSubDirectory( VOID )
{
    NLS_STR nlsPath;
    NLS_STR nlsNewSubDir;
    BOOL    fGotDir;

    _sltPath.QueryText( &nlsPath );

    APIERR err = nlsPath.QueryError();

    if( err == NERR_Success )
    {
        REPL_ADD_DIALOG * pDlg = new REPL_ADD_DIALOG( QueryHwnd(),
                                                      nlsPath.QueryPch(),
                                                      &nlsNewSubDir );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fGotDir );

        delete pDlg;
    }

    if( ( err == NERR_Success ) && fGotDir )
    {
        err = nlsNewSubDir.QueryError();
    }

    //
    //  Let's see if the directory already exists.
    //

    if( ( err == NERR_Success ) && fGotDir )
    {
        INT cItems = _plbList->QueryCount();

        for( INT i = 0 ; i < cItems ; i++ )
        {
            EXPORT_IMPORT_LBI * plbi = _plbList->QueryItem( i );
            UIASSERT( plbi != NULL );

            if( nlsNewSubDir._stricmp( plbi->QuerySubDirectory() ) == 0 )
            {
                ::MsgPopup( this,
                            IDS_DIR_ALREADY_EXISTS,
                            MPSEV_WARNING,
                            MP_OK,
                            nlsNewSubDir.QueryPch() );

                fGotDir = FALSE;
            }
        }
    }

    if( ( err == NERR_Success ) && fGotDir )
    {
        NLS_STR * pnls = _slistRemoved.Remove( nlsNewSubDir );

        err = _plbList->AddDefaultSubDir( nlsNewSubDir.QueryPch(),
                                          pnls != NULL );
    }

    if( ( err == NERR_Success ) && fGotDir )
    {
        UpdateTextAndButtons();
    }

    if( err != NERR_Success )
    {
        ::MsgPopup( this, err );
    }

}   // EXPORT_IMPORT_DIALOG :: AddNewSubDirectory


/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: RemoveSubDirectory

    SYNOPSIS:       This method is invoked whenever the user presses
                    the 'Remove' button in either the Export Manager
                    or Import Manage dialogs.

    EXIT:           If the user confirms the operation, then the
                    directory has been removed from the listbox.
                    Also, the directory name is added to _slistRemoved.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID EXPORT_IMPORT_DIALOG :: RemoveSubDirectory( VOID )
{
    EXPORT_IMPORT_LBI * plbi = _plbList->QueryItem();
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  _fExport ? IDS_REMOVE_EXPORT_DIR : IDS_REMOVE_IMPORT_DIR,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QuerySubDirectory(),
                  MP_NO ) == IDYES )
    {
        //
        //  Before we remove the item, add the directory's name
        //  to _slistRemoved, but only if this is a pre-existing
        //  directory.
        //

        APIERR err = NERR_Success;

        if( plbi->IsPreExisting() )
        {
            NLS_STR * pnls = new NLS_STR( plbi->QuerySubDirectory() );

            err = ( pnls == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : pnls->QueryError();

            if( err == NERR_Success )
            {
                err = _slistRemoved.Add( pnls );
            }
        }

        if( err == NERR_Success )
        {
            INT iCurrent = _plbList->QueryCurrentItem();

            REQUIRE( _plbList->DeleteItem( iCurrent ) >= 0 );

            if( _plbList->QueryCount() > 0 )
            {
                if( iCurrent >= _plbList->QueryCount() )
                {
                    iCurrent--;
                }

                _plbList->SelectItem( iCurrent );
            }

            UpdateTextAndButtons();
        }

        if( err != NERR_Success )
        {
            MsgPopup( this, err );
        }
    }

}   // EXPORT_IMPORT_DIALOG :: RemoveSubDirectory


/*******************************************************************

    NAME:           EXPORT_IMPORT_DIALOG :: UpdateTextAndButtons

    SYNOPSIS:       This method is invoked whenever _plbList's
                    selection state has changed.  This method is
                    responsible for updating _sltSubDir and _cbLocked.

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.
        JonN        27-Feb-1995     Manage disabling item with focus

********************************************************************/
void EXPORT_IMPORT_DIALOG :: UpdateTextAndButtons( VOID )
{
    EXPORT_IMPORT_LBI * plbi = _plbList->QueryItem();

    if( plbi == NULL )
    {
        if (   _pbRemoveDir.HasFocus()
            || _pbAddLock.HasFocus()
            || _pbRemoveLock.HasFocus()
           )
        {
            TRACEEOL( "Srvmgr EXPORT_IMPORT_DIALOG::UpdateTextAndButtons(): focus fix" );
            SetDialogFocus( _pbAddDir );
        }
        _pbRemoveDir.Enable( FALSE );

        _pbAddLock.Enable( FALSE );
        _pbRemoveLock.Enable( FALSE );
        _sltSubDir.SetText( SZ("") );
    }
    else
    {
        _pbRemoveDir.Enable( TRUE );

        _pbAddLock.Enable( TRUE );
        _pbRemoveLock.Enable( plbi->QueryVirtualLockCount() > 0 );
        _sltSubDir.SetText( plbi->QuerySubDirectory() );
    }

}   // EXPORT_IMPORT_DIALOG :: UpdateTextAndButtons



//
//  EXPORT_IMPORT_LISTBOX methods.
//

/*******************************************************************

    NAME:           EXPORT_IMPORT_LISTBOX :: EXPORT_IMPORT_LISTBOX

    SYNOPSIS:       EXPORT_IMPORT_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cColumns            - The number of columns in the
                                          listbox.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
EXPORT_IMPORT_LISTBOX :: EXPORT_IMPORT_LISTBOX( OWNER_WINDOW * powner,
                                                UINT           cColumns,
                                                SERVER_2     * pserver )
  : BLT_LISTBOX( powner, IDIE_DIRLIST ),
    _pserver( pserver ),
    _nlsYes( IDS_YES ),
    _nlsNo( IDS_NO ),
    _nlsDisplayName()
{
    UIASSERT( pserver != NULL );
    UIASSERT( cColumns <= MAX_EXPORT_IMPORT_COLUMNS );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsYes.QueryError();

    if( err == NERR_Success )
    {
        err = _nlsNo.QueryError();
    }

    if( err == NERR_Success )
    {
        err = _nlsDisplayName.QueryError();
    }

    if( err == NERR_Success )
    {
        err = _pserver->QueryDisplayName( &_nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Build our column width table.
        //

        DISPLAY_TABLE::CalcColumnWidths( _adx,
                                         cColumns,
                                         powner,
                                         IDIE_DIRLIST,
                                         FALSE );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // EXPORT_IMPORT_LISTBOX :: EXPORT_IMPORT_LISTBOX


/*******************************************************************

    NAME:           EXPORT_IMPORT_LISTBOX :: ~EXPORT_IMPORT_LISTBOX

    SYNOPSIS:       EXPORT_IMPORT_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
EXPORT_IMPORT_LISTBOX :: ~EXPORT_IMPORT_LISTBOX( VOID )
{
    _pserver = NULL;

}   // EXPORT_IMPORT_LISTBOX :: ~EXPORT_IMPORT_LISTBOX


//
//  EXPORT_IMPORT_LBI methods
//

/*******************************************************************

    NAME:           EXPORT_IMPORT_LBI :: EXPORT_IMPORT_LBI

    SYNOPSIS:       EXPORT_IMPORT_LBI class constructor.

    ENTRY:          pszSubDirectory     - The subdirectory name.

                    lLockCount          - Current lock count.

                    lLockTime           - Time of first lock.

                    fPreExisting        - TRUE if this directory
                                          currently exists.  FALSE
                                          if it must be added.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
EXPORT_IMPORT_LBI :: EXPORT_IMPORT_LBI( const TCHAR * pszSubDirectory,
                                        ULONG         lLockCount,
                                        ULONG         lLockTime,
                                        BOOL          fPreExisting )
  : _nlsSubDirectory( pszSubDirectory ),
    _lLockCount( lLockCount ),
    _lLockTime( lLockTime ),
    _fPreExisting( fPreExisting ),
    _lLockBias( 0 ),
    _nlsLockTime()
{
    UIASSERT( pszSubDirectory != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSubDirectory )
    {
        ReportError( _nlsSubDirectory.QueryError() );
        return;
    }

    if( !_nlsLockTime )
    {
        ReportError( _nlsLockTime.QueryError() );
        return;
    }

    //
    //  Build the more complex display strings.
    //

    APIERR err = NERR_Success;

    if( lLockTime > 0 )
    {
        WIN_TIME     wintime( lLockTime );
        INTL_PROFILE intlprof;
        NLS_STR      nlsTime;

        err = wintime.QueryError();
        if ( err == NERR_Success )
        {
            err = intlprof.QueryError();
        }

        if( err == NERR_Success )
        {
            err = nlsTime.QueryError();
        }

        if( err == NERR_Success )
        {
            err = intlprof.QueryShortDateString( wintime, &_nlsLockTime );
        }

        if( err == NERR_Success )
        {
            err = intlprof.QueryTimeString( wintime, &nlsTime );
        }

        if( err == NERR_Success )
        {
            err = _nlsLockTime.Append( SZ(" ") );
        }

        if( err == NERR_Success )
        {
            err = _nlsLockTime.Append( nlsTime );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // EXPORT_IMPORT_LBI :: EXPORT_IMPORT_LBI


/*******************************************************************

    NAME:           EXPORT_IMPORT_LBI :: ~EXPORT_IMPORT_LBI

    SYNOPSIS:       EXPORT_IMPORT_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
EXPORT_IMPORT_LBI :: ~EXPORT_IMPORT_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // EXPORT_IMPORT_LBI :: ~EXPORT_IMPORT_LBI


/*******************************************************************

    NAME:       EXPORT_IMPORT_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
WCHAR EXPORT_IMPORT_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsSubDirectory );

    return _nlsSubDirectory.QueryChar( istr );

}   // EXPORT_IMPORT_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       EXPORT_IMPORT_LBI :: Compare

    SYNOPSIS:   Compare two EXPORT_IMPORT_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
INT EXPORT_IMPORT_LBI :: Compare( const LBI * plbi ) const
{
    const EXPORT_IMPORT_LBI * pMyLbi = (const EXPORT_IMPORT_LBI *)plbi;
    return _nlsSubDirectory._stricmp( pMyLbi->_nlsSubDirectory );

}   // EXPORT_IMPORT_LBI :: Compare


/*******************************************************************

    NAME:       EXPORT_IMPORT_LBI :: IsDirty

    SYNOPSIS:   Determines if the current LBI is dirty and thus the
                target directory needs to be updated.

    RETURNS:    BOOL                    - TRUE if the LBI is dirty.

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL EXPORT_IMPORT_LBI :: IsDirty( VOID )
{
    return ( _lLockBias != 0 ) || !_fPreExisting;

}   // EXPORT_IMPORT_LBI :: IsDirty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\resbase.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    resbase.cxx
    Class definitions for the BASE_RES_DIALOG, BASE_RES_LISTBOX, and
    BASE_RES_LBI classes.

    The abstract BASE_RES_DIALOG class is subclassed to form the
    FILES_DIALOG and PRINTERS_DIALOG classes.

    The abstract BASE_RES_LISTBOX class is subclassed to form the
    FILES_LISTBOX and PRINTERS_LISTBOX classes.

    The abstract BASE_RES_LBI class is subclassed to form the
    FILES_LBI and PRINTERS_LBI classes.


    FILE HISTORY:
        KeithMo     25-Jul-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 Changes from code review attended by
                                ChuckC and JohnL.
        TerryK      09-Sep-1991 Change NetSessionDel to LM_SESSION
                                object
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     04-Nov-1991 Added "Disconnect All" button.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmosrv.hxx>
#include <lmosess.hxx>
#include <lmsrvres.hxx>
#include <lmoenum.hxx>
#include <lmoersm.hxx>
#include <lmoeconn.hxx>
#include <lmoefile.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"

#include <resbase.hxx>


//
//  BASE_RES_DIALOG methods.
//

/*******************************************************************

    NAME:       BASE_RES_DIALOG :: BASE_RES_DIALOG

    SYNOPSIS:   BASE_RES_DIALOG class constructor.

    ENTRY:      powner                  - Points to the "owning" window.

                pszResourceName         - The name of the resource
                                          dialog template.

                idCaption               - String resource ID for the
                                          dialog caption, with '%1' for
                                          the server name.  For example,
                                          "Shared Files on %1".

                pserver                 - Points to the server object
                                          representing the target server.

                plbResource             - Points to the resource listbox
                                          for this dialog.

                cidUsersListbox         - The CID of the connected users
                                          listbox.

                cidUsersCount           - The CID of the SLT which displays
                                          the count of connected users.

                cidDisconnect           - The CID of the "Disconnect"
                                          push button.

                cidDisconnectAll        - The CID of the "Disconnect All"
                                          push button.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     25-Jul-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 Now inherits from SRVPROP_OTHER_DIALOG.
                                Also added initial UIASSERTs.

********************************************************************/
BASE_RES_DIALOG :: BASE_RES_DIALOG( HWND                hWndOwner,
                                    const TCHAR       * pszResourceName,
                                    UINT                idCaption,
                                    const SERVER_2    * pserver,
                                    BASE_RES_LISTBOX  * plbResource,
                                    CID                 cidUsersListbox,
                                    CID                 cidUsersCount,
                                    CID                 cidDisconnect,
                                    CID                 cidDisconnectAll )
  : SRV_BASE_DIALOG( (TCHAR *)pszResourceName, hWndOwner ),
    _pserver( pserver ),
    _plbResource( plbResource ),
    _lbUsers( this, cidUsersListbox, pserver ),
    _sltUsersCount( this, cidUsersCount ),
    _pbDisconnect( this,  cidDisconnect ),
    _pbDisconnectAll( this,  cidDisconnectAll ),
    _pbOK( this, IDOK ),
    _nlsDisplayName()
{
    UIASSERT( pserver != NULL );
    UIASSERT( pszResourceName != NULL );
    UIASSERT( plbResource != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsDisplayName.QueryError();

    if( err == NERR_Success )
    {
        err = _pserver->QueryDisplayName( &_nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Set the caption to "Foo on Server".
        //

       err = SetCaption( this,
                         idCaption,
                         QueryDisplayName() );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // BASE_RES_DIALOG :: BASE_RES_DIALOG


/*******************************************************************

    NAME:       BASE_RES_DIALOG :: ~BASE_RES_DIALOG

    SYNOPSIS:   BASE_RES_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        KeithMo     03-Sep-1991 NULL _plbResource before terminating.

********************************************************************/
BASE_RES_DIALOG :: ~BASE_RES_DIALOG()
{
    _plbResource = NULL;

}   // BASE_RES_DIALOG :: ~BASE_RES_DIALOG


/*******************************************************************

    NAME:       BASE_RES_DIALOG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

                lParam                  - Varies.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
        KeithMo     25-Jul-1991 Created for the Server Manager.
        KeithMo     03-Sep-1991 Tossed in a few quasi-random UIASSERTs :-)
        KeithMo     06-Oct-1991 Now takes a CONTROL_EVENT.

********************************************************************/
BOOL BASE_RES_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    if( event.QueryCid() == _plbResource->QueryCid() )
    {
        //
        //  The BASE_RES_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in the BASE_RES_LISTBOX.
            //

            BASE_RES_LBI * plbi = _plbResource->QueryItem();
            UIASSERT( plbi != NULL );
            if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444942

            _lbUsers.Fill( plbi->QueryResourceName() );

            UINT cUses = (UINT)_lbUsers.QueryCount();

            (VOID)plbi->NotifyNewUseCount( cUses );
            _plbResource->InvalidateItem( _plbResource->QueryCurrentItem() );

            _sltUsersCount.SetValue( cUses );

            if( cUses > 0 )
            {
                _lbUsers.SelectItem( 0 );
            }

            _pbDisconnect.Enable( cUses > 0 );
            _pbDisconnectAll.Enable( cUses > 0 );
        }

        return TRUE;
    }

    if( event.QueryCid() == _pbDisconnect.QueryCid() )
    {
        //
        //  The user pressed the Disconnect button.  Blow off the
        //  selected user.
        //

        USERS_LBI * plbi = _lbUsers.QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444942

        const TCHAR * pszApiUser     = plbi->QueryUserName();
        const TCHAR * pszApiComputer = plbi->QueryComputerName();

        const TCHAR * pszUser = pszApiUser;

        MSGID idMsg = IDS_DISCONNECT_USER;

        if( ( plbi->QueryNumOpens() > 0 ) ||
            DoesUserHaveAnyOpens( plbi->QueryComputerName() ) )
        {
            idMsg = IDS_DISCONNECT_USER_OPEN;
        }

        if( ( pszApiUser == NULL ) || ( *pszApiUser == TCH('\0') ) )
        {
            pszUser = pszApiComputer;
            pszApiUser = NULL;
            idMsg += 10; // use IDS_DISCONNECT_COMPUTER[_OPEN]
        }

        if ( MsgPopup( this,
                       idMsg,
                       MPSEV_WARNING,
                       MP_YESNO,
                       pszUser,
                       pszApiComputer,
                       MP_NO ) == IDYES )
        {
            AUTO_CURSOR Cursor;

            //
            //  Blow off the user.
            //

            APIERR err = LM_SRVRES::NukeUsersSession( QueryServer(),
                                                      pszApiComputer,
                                                      pszApiUser );

            if( err != NERR_Success )
            {
                //
                //  The session delete failed.  Tell the user the bad news.
                //

                MsgPopup( this, err );
            }

            //
            //  Refresh the dialog.
            //

            Refresh();
        }

        return TRUE;
    }

    if( event.QueryCid() == _pbDisconnectAll.QueryCid() )
    {
        //
        //  The user pressed the "Disconnect All" button.
        //  Blow off all of the connected users.
        //

        UIASSERT( _lbUsers.QueryCount() > 0 );

        BASE_RES_LBI * plbi = _plbResource->QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444942

        MSGID idMsg = IDS_DISCONNECT_ALL;

        if( _lbUsers.AreResourcesOpen() || DoAnyUsersHaveAnyOpens() )
        {
            idMsg = IDS_DISCONNECT_ALL_OPEN;
        }

        if( MsgPopup( this,
                      idMsg,
                      MPSEV_WARNING,
                      MP_YESNO,
                      plbi->QueryResourceName(),
                      MP_NO ) == IDYES )
        {
            AUTO_CURSOR Cursor;

            //
            //  Blow off the users.
            //

            for( UINT i = 0 ; i < (UINT)_lbUsers.QueryCount() ; i++ )
            {
                USERS_LBI * plbi = _lbUsers.QueryItem( i );
                UIASSERT( plbi != NULL );
                if (!plbi) continue; // JonN 01/28/00 PREFIX bug 444942

                const TCHAR * pszApiUser     = plbi->QueryUserName();
                const TCHAR * pszApiComputer = plbi->QueryComputerName();

                if( ( pszApiUser == NULL ) || ( *pszApiUser == TCH('\0') ) )
                {
                    pszApiUser = NULL;
                }

                APIERR err =
                    LM_SRVRES::NukeUsersSession( QueryServer(),
                                                 pszApiComputer,
                                                 pszApiUser );

                if( err != NERR_Success )
                {
                    //
                    //  The session delete failed.
                    //  Tell the user the bad news.
                    //

                    Cursor.TurnOff();
                    MsgPopup( this, err );
                    Cursor.TurnOn();
                }
            }

            //
            //  Refresh the dialog.
            //

            Refresh();
        }

        return TRUE;
    }

    //
    //  If we made it this far, then we're not
    //  interested in the command.
    //

    return FALSE;

}   // BASE_RES_DIALOG :: OnCommand


/*******************************************************************

    NAME:       BASE_RES_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     25-Jul-1991 Created for the Server Manager.
        KeithMo     29-Aug-1991 Fixed "disappearing LBI" problem.

********************************************************************/
APIERR BASE_RES_DIALOG :: Refresh( VOID )
{
    //
    //  This is the currently selected item.
    //

    BASE_RES_LBI * plbiOld = _plbResource->QueryItem();

    NLS_STR nlsOld( (plbiOld == NULL ) ? NULL : plbiOld->QueryResourceName() );

    APIERR err = nlsOld.QueryError();

    //
    //  Refresh the resource listbox.
    //

    if( err == NERR_Success )
    {
        err = _plbResource->Refresh();
    }

    if( err != NERR_Success )
    {
        //
        //  There was an error refreshing the resource listbox.
        //  So, nuke everything in the resource & user listboxen,
        //  then disable the Disconnect[All] buttons.
        //

        _plbResource->DeleteAllItems();
        _lbUsers.DeleteAllItems();

        SetDialogFocus( _pbOK );

        _pbDisconnect.Enable( FALSE );
        _pbDisconnectAll.Enable( FALSE );

        return err;
    }

    //
    //  Get the "new" currently selected item (after the refresh).
    //

    BASE_RES_LBI * plbiNew = _plbResource->QueryItem();

    ALIAS_STR nlsNew( (plbiNew == NULL) ? SZ("") : plbiNew->QueryResourceName() );
    UIASSERT( nlsNew.QueryError() == NERR_Success );

    if( plbiNew == NULL )
    {
        //
        //  There is no current selection, so clear the users listbox.
        //

        _lbUsers.Fill( NULL );
    }
    else
    if( ( plbiOld == NULL ) || ( nlsNew._stricmp( nlsOld ) != 0 ) )
    {
        //
        //  Either there was no selection before the refresh, OR
        //  the current selection does not match the previous
        //  selection.  Therefore, fill the users listbox with
        //  the current selection.
        //

        _lbUsers.Fill( plbiNew->QueryResourceName() );

        if( _lbUsers.QueryCount() > 0 )
        {
            _lbUsers.SelectItem( 0 );
        }
    }
    else
    {
        //
        //  There was no selection change after refresh.  Therefore,
        //  refresh the users listbox.
        //

        _lbUsers.Refresh();
    }

    _sltUsersCount.SetValue( _lbUsers.QueryCount() );

    if( _lbUsers.QuerySelCount() > 0 )
    {
        _pbDisconnect.Enable( TRUE );
    }
    else
    {
        if( _pbDisconnect.HasFocus() )
        {
            SetDialogFocus( _pbOK );
        }

        _pbDisconnect.Enable( FALSE );
    }

    if( _lbUsers.QueryCount() > 0 )
    {
        _pbDisconnectAll.Enable( TRUE );
    }
    else
    {
        if( _pbDisconnectAll.HasFocus() )
        {
            SetDialogFocus( _pbOK );
        }

        _pbDisconnectAll.Enable( FALSE );
    }

    //
    //  Success!
    //

    return NERR_Success;

}   // BASE_RES_DIALOG :: Refresh


/*******************************************************************

    NAME:       BASE_RES_DIALOG :: DoesUserHaveAnyOpens

    SYNOPSIS:   Determines if this computer has any files open.

    ENTRY:      pszComputerName         - The computer to check.

    RETURNS:    BOOL

    HISTORY:
        KeithMo     22-Jan-1993 Created for the Server Manager.

********************************************************************/
BOOL BASE_RES_DIALOG :: DoesUserHaveAnyOpens( const TCHAR * pszComputerName )
{
    UIASSERT( pszComputerName != NULL );

    BOOL fResult = FALSE;

    //
    //  Build the target server name w/ leading backslashes.
    //

    ISTACK_NLS_STR( nlsTarget, MAX_PATH+1, SZ("\\\\") );
    UIASSERT( !!nlsTarget );
    ALIAS_STR nlsTmp( pszComputerName );
    UIASSERT( !!nlsTmp );
    REQUIRE( nlsTarget.Append( nlsTmp ) == NERR_Success );

    //
    //  Enumerate the connections.
    //

    CONN1_ENUM enumConn( _pserver->QueryName(), nlsTarget );

    APIERR err = enumConn.GetInfo();

    if( err == NERR_Success )
    {
        CONN1_ENUM_ITER iterConn( enumConn );
        const CONN1_ENUM_OBJ * pceo;

        while( ( pceo = iterConn() ) != NULL )
        {
            if( pceo->QueryNumOpens() > 0 )
            {
                fResult = TRUE;
                break;
            }
        }
    }

    return fResult;

}   // BASE_RES_DIALOG :: DoesUserHaveAnyOpens


/*******************************************************************

    NAME:       BASE_RES_DIALOG :: DoAnyUsersHaveAnyOpens

    SYNOPSIS:   Determines if any user(s) have any files open.

    RETURNS:    BOOL

    HISTORY:
        KeithMo     22-Jan-1993 Created for the Server Manager.

********************************************************************/
BOOL BASE_RES_DIALOG :: DoAnyUsersHaveAnyOpens( VOID )
{
    BOOL fResult = FALSE;

    BASE_RES_LBI * plbi = _plbResource->QueryItem();
    UIASSERT( plbi != NULL );
    if (!plbi) return FALSE; // JonN 01/28/00 PREFIX bug 444942

    //
    //  Enumerate the connections, looking for opens.
    //

    CONN1_ENUM enumConn( _pserver->QueryName(), plbi->QueryResourceName() );

    APIERR err = enumConn.GetInfo();

    if( err == NERR_Success )
    {
        CONN1_ENUM_ITER iterConn( enumConn );
        const CONN1_ENUM_OBJ * pceo;

        while( ( pceo = iterConn() ) != NULL )
        {
            if( DoesUserHaveAnyOpens( pceo->QueryNetName() ) )
            {
                fResult = TRUE;
                break;
            }
        }
    }

    return fResult;

}   // BASE_RES_DIALOG :: DoAnyUsersHaveAnyOpens



//
//  BASE_RES_LISTBOX methods.
//

/*******************************************************************

    NAME:       BASE_RES_LISTBOX :: BASE_RES_LISTBOX

    SYNOPSIS:   BASE_RES_LISTBOX class constructor.

    ENTRY:      powner                  - Pointer to the "owning" window.

                cid                     - CID for this listbox.

                cColumns                - The number of columns in the
                                          listbox.

                pserver                 - SERVER_2 object.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Jul-1991 Created for Server Manager.
        KeithMo     03-Sep-1991 Added initial UIASSERTs.

********************************************************************/
BASE_RES_LISTBOX :: BASE_RES_LISTBOX( OWNER_WINDOW   * powner,
                                      CID              cid,
                                      UINT             cColumns,
                                      const SERVER_2 * pserver )
  : BLT_LISTBOX( powner, cid ),
    _pserver( pserver ),
    _nlsDisplayName()
{
    UIASSERT( cColumns <= MAX_DISPLAY_TABLE_ENTRIES );
    UIASSERT( pserver != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsDisplayName.QueryError();

    if( err == NERR_Success )
    {
        err = _pserver->QueryDisplayName( &_nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Build our column width table.
        //

        DISPLAY_TABLE::CalcColumnWidths(_adx,
                                        cColumns,
                                        powner,
                                        cid,
                                        TRUE) ;
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // BASE_RES_LISTBOX :: BASE_RES_LISTBOX


/*******************************************************************

    NAME:       BASE_RES_LISTBOX :: ~BASE_RES_LISTBOX

    SYNOPSIS:   BASE_RES_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.
        KeithMo     03-Sep-1991 NULL _pserver before terminating.

********************************************************************/
BASE_RES_LISTBOX :: ~BASE_RES_LISTBOX()
{
    _pserver = NULL;

}   // BASE_RES_LISTBOX :: ~BASE_RES_LISTBOX


/*******************************************************************

    NAME:       BASE_RES_LISTBOX :: Refresh

    SYNOPSIS:   Refresh the listbox, maintaining (as much as
                possible) the current selection state.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    APIERR                  - Any errors we encounter.

    HISTORY:
        KeithMo     30-Jul-1991 Created for Server Manager.

********************************************************************/
APIERR BASE_RES_LISTBOX :: Refresh( VOID )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    APIERR err = Fill();

    if( err != NERR_Success )
    {
        return err;
    }

    if( QueryCount() > 0 )
    {
        SetTopIndex( ( iTop < 0 ) ? 0 : iTop );
        SelectItem( ( iCurrent < 0 ) ? 0 : iCurrent );
    }

    return NERR_Success;

}   // BASE_RES_LISTBOX :: Refresh


//
//  BASE_RES_LBI methods.
//

/*******************************************************************

    NAME:       BASE_RES_LBI :: BASE_RES_LBI

    SYNOPSIS:   BASE_RES_LBI class constructor.

    ENTRY:      pszResource             - Resource name for this item.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     30-Jul-1991 Created for Server Manager.
        KeithMo     03-Sep-1991 Added initial UIASSERT.

********************************************************************/
BASE_RES_LBI :: BASE_RES_LBI( const TCHAR * pszResource )
    : _nlsResource( pszResource )
{
    UIASSERT( pszResource != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsResource )
    {
        ReportError( _nlsResource.QueryError() );
        return;
    }

}   // BASE_RES_LBI :: BASE_RES_LBI


/*******************************************************************

    NAME:       BASE_RES_LBI :: ~BASE_RES_LBI

    SYNOPSIS:   BASE_RES_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
BASE_RES_LBI :: ~BASE_RES_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // BASE_RES_LBI :: ~BASE_RES_LBI


/*******************************************************************

    NAME:       BASE_RES_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     30-Jul-1991 Created for Server Manager.
        KeithMo     03-Sep-1991 Simplified greatly now that the
                                target resource is in a NLS_STR.

********************************************************************/
WCHAR BASE_RES_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsResource );

    return _nlsResource.QueryChar( istr );

}   // BASE_RES_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       BASE_RES_LBI :: Compare

    SYNOPSIS:   Compare two BASE_RES_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     30-Jul-1991 Created for Server Manager.
        KeithMo     03-Sep-1991 Simplified greatly now that the
                                target resource is in a NLS_STR.

********************************************************************/
INT BASE_RES_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsResource._stricmp( ((const BASE_RES_LBI *)plbi)->_nlsResource );

}   // BASE_RES_LBI :: Compare


/*******************************************************************

    NAME:       BASE_RES_LBI :: NotifyNewUseCount

    SYNOPSIS:   Notifies the LBI that the "use" count has changed.

    ENTRY:      cUses                   - The new use count.

    RETURNS:    APIERR                  - Any errors that occur.

    HISTORY:
        KeithMo     08-Jul-1992 Created for Server Manager.

********************************************************************/
APIERR BASE_RES_LBI :: NotifyNewUseCount( UINT cUses )
{
    UNREFERENCED( cUses );

    return NERR_Success;

}   // BASE_RES_LBI :: NotifyNewUseCount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\replexp.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    replexp.cxx
    Class definitions for Replicator Admin Export Management dialog.

    The REPL_EXPORT_* classes implement the Replicator Export Management
    dialog.  This dialog is invoked from the REPL_MAIN_DIALOG.

    The classes are structured as follows:

        LBI
            EXPORT_IMPORT_LBI
                REPL_EXPORT_LBI

        BLT_LISTBOX
            EXPORT_IMPORT_LISTBOX
                REPL_EXPORT_LISTBOX

        DIALOG_WINDOW
            EXPORT_IMPORT_DIALOG
                REPL_EXPORT_DIALOG


    FILE HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmoreple.hxx>
#include <srvbase.hxx>
#include <strnumer.hxx>
#include <dbgstr.hxx>

extern "C" {

    #include <srvmgr.h>
    #include <lmrepl.h>
    #include <time.h>

}   // extern "C"

#include <replexp.hxx>



//
//  Defaults for AddDefaultDir.
//

#define DEFAULT_STABILIZE       TRUE
#define DEFAULT_SUBTREE         TRUE
#define DEFAULT_LOCK_COUNT      0
#define DEFAULT_LOCK_TIME       0



//
//  REPL_EXPORT_DIALOG methods
//

/*******************************************************************

    NAME:           REPL_EXPORT_DIALOG :: REPL_EXPORT_DIALOG

    SYNOPSIS:       REPL_EXPORT_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pserver             - A SERVER_2 object representing
                                          the target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_EXPORT_DIALOG :: REPL_EXPORT_DIALOG( HWND          hWndOwner,
                                          SERVER_2    * pserver,
                                          const TCHAR * pszExportPath )
  : EXPORT_IMPORT_DIALOG( hWndOwner,
                          MAKEINTRESOURCE( IDD_EXPORT_MANAGE ),
                          IDS_CAPTION_REPL,
                          pserver,
                          pszExportPath,
                          &_lbExportList,
                          TRUE ),
    _lbExportList( this, pserver ),
    _cbStabilize( this, IDEM_STABILIZE ),
    _cbSubTree( this, IDEM_SUBTREE )
{
    UIASSERT( pserver != NULL );
    UIASSERT( pszExportPath != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "REPL_EXPORT_DIALOG :: REPL_EXPORT_DIALOG Failed!" );
        return;
    }

    //
    //  Call the Phase II constructor.
    //

    APIERR err = CtAux();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Fill the listbox.
    //

    err = _lbExportList.Fill();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UpdateTextAndButtons();

}   // REPL_EXPORT_DIALOG :: REPL_EXPORT_DIALOG


/*******************************************************************

    NAME:           REPL_EXPORT_DIALOG :: ~REPL_EXPORT_DIALOG

    SYNOPSIS:       REPL_EXPORT_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_EXPORT_DIALOG :: ~REPL_EXPORT_DIALOG( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EXPORT_DIALOG :: ~REPL_EXPORT_DIALOG


/*******************************************************************

    NAME:       REPL_EXPORT_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    NOTES:      This method should *always* fall through to
                EXPORT_IMPORT_DIALOG::OnCommand().

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_EXPORT_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    REPL_EXPORT_LBI * plbi = NULL;

    switch( event.QueryCid() )
    {
    case IDEM_STABILIZE :
        plbi = _lbExportList.QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444929

        plbi->WaitForStabilize( _cbStabilize.QueryCheck() );
        _lbExportList.InvalidateItem( _lbExportList.QueryCurrentItem(), TRUE );
        return TRUE;

    case IDEM_SUBTREE :
        plbi = _lbExportList.QueryItem();
        UIASSERT( plbi != NULL );
        if (!plbi) return TRUE; // JonN 01/28/00 PREFIX bug 444930

        plbi->ExportSubTree( _cbSubTree.QueryCheck() );
        _lbExportList.InvalidateItem( _lbExportList.QueryCurrentItem(), TRUE );
        return TRUE;

    default :
        //
        //  All unprocessed command events must be
        //  passed up to the base class!
        //

        return EXPORT_IMPORT_DIALOG :: OnCommand( event );
        break;
    }

}   // REPL_EXPORT_DIALOG :: OnCommand


/*******************************************************************

    NAME:       REPL_EXPORT_DIALOG :: OnOK

    SYNOPSIS:   Invoked whenever the user presses the "OK" button.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_EXPORT_DIALOG :: OnOK( VOID )
{
    AUTO_CURSOR NiftyCursor;

    //
    //  We'll use this iterator to scan the list of
    //  removed directories.
    //

    ITER_SL_OF( NLS_STR ) iter( _slistRemoved );
    NLS_STR * pnls;

    //
    //  Scan _slistRemoved, removing the named directories.
    //

    APIERR err = NERR_Success;

    while( ( pnls = iter.Next() ) != NULL )
    {
        REPL_EDIR_0 edir( QueryServerName(), pnls->QueryPch() );

        err = edir.QueryError();

        if( err == NERR_Success )
        {
            err = edir.GetInfo();
        }

        if( err == NERR_Success )
        {
            err = edir.Delete();

            //
            //  If Delete will return NERR_UnknownDevDir if
            //  the directory does not exist.  We'll map this
            //  to NERR_Success, since the user wanted this
            //  directory deleted anyway.
            //

            if( err == NERR_UnknownDevDir )
            {
                err = NERR_Success;
            }
        }

        if( err != NERR_Success )
        {
            break;
        }
    }

    if( err != NERR_Success )
    {
        //
        //  Error deleting a directory.
        //

        MsgPopup( this, err );
        return FALSE;
    }

    //
    //  Scan the listbox.
    //

    INT cItems = _lbExportList.QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        REPL_EXPORT_LBI * plbi = _lbExportList.QueryItem( i );
        UIASSERT( plbi != NULL );

        //
        //  If the directory isn't dirty, don't bother updating.
        //

        if( !plbi || !plbi->IsDirty() ) // JonN 01/28/00: PREFIX bug 444926
        {
            continue;
        }

        //
        //  Create our replicator export directory object.
        //

        REPL_EDIR_2 edir( QueryServerName(), plbi->QuerySubDirectory() );

        err = edir.QueryError();

        if( err == NERR_Success )
        {
            //
            //  If this IS a pre-existing directory, then we just
            //  invoke GetInfo() on the object.  Otherwise, we must
            //  Create() the new object.
            //

            if( plbi->IsPreExisting() )
            {
                err = edir.GetInfo();
            }
            else
            {
                err = edir.CreateNew();

                if( err == NERR_Success )
                {
                    err = edir.WriteNew();
                }
            }
        }

        if( err == NERR_Success )
        {
            //
            //  Set the attributes from the listbox item.
            //

            edir.SetIntegrity( plbi->DoesWaitForStabilize()
                                    ? REPL_INTEGRITY_TREE
                                    : REPL_INTEGRITY_FILE );

            edir.SetExtent( plbi->DoesExportSubTree()
                                    ? REPL_EXTENT_TREE
                                    : REPL_EXTENT_FILE );

            edir.SetLockBias( plbi->QueryLockBias() );

            //
            //  Update the directory.
            //

            err = edir.WriteInfo();
        }

        if( err != NERR_Success )
        {
            break;
        }
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
        return FALSE;
    }

    Dismiss( TRUE );
    return TRUE;

}   // REPL_EXPORT_DIALOG :: OnOK


/*******************************************************************

    NAME:       REPL_EXPORT_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
ULONG REPL_EXPORT_DIALOG :: QueryHelpContext( VOID )
{
    return HC_REPL_EXPORT_DIALOG;

}   // REPL_EXPORT_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:           REPL_EXPORT_DIALOG :: UpdateTextAndButtons

    SYNOPSIS:       This method is invoked whenever _lbExportList's
                    selection state has changed.  This method is
                    responsible for updating _cbStabilize and _cbSubTree.

    NOTES:          This method *must* invoke the corresponding parent
                    class method (in EXPORT_IMPORT_DIALOG).

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.
        JonN        27-Feb-1995     Manage disabling item with focus

********************************************************************/
void REPL_EXPORT_DIALOG :: UpdateTextAndButtons( VOID )
{
    REPL_EXPORT_LBI * plbi = _lbExportList.QueryItem();

    if( plbi == NULL )
    {
        if (   _cbStabilize.HasFocus()
            || _cbSubTree.HasFocus()
           )
        {
            TRACEEOL( "Srvmgr REPL_EXPORT_DIALOG::UpdateTextAndButtons(): focus fix" );
            SetDialogFocus( _pbAddDir );
        }
        _cbStabilize.SetCheck( FALSE );
        _cbStabilize.Enable( FALSE );
        _cbSubTree.SetCheck( FALSE );
        _cbSubTree.Enable( FALSE );
    }
    else
    {
        _cbStabilize.Enable( TRUE );
        _cbStabilize.SetCheck( plbi->DoesWaitForStabilize() );
        _cbSubTree.Enable( TRUE );
        _cbSubTree.SetCheck( plbi->DoesExportSubTree() );
    }

    EXPORT_IMPORT_DIALOG::UpdateTextAndButtons();

}   // REPL_EXPORT_DIALOG :: UpdateTextAndButtons



//
//  REPL_EXPORT_LISTBOX methods
//

/*******************************************************************

    NAME:           REPL_EXPORT_LISTBOX :: REPL_EXPORT_LISTBOX

    SYNOPSIS:       REPL_EXPORT_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_EXPORT_LISTBOX :: REPL_EXPORT_LISTBOX( OWNER_WINDOW * powner,
                                            SERVER_2     * pserver )
  : EXPORT_IMPORT_LISTBOX( powner, REPL_EXPORT_LISTBOX_COLUMNS, pserver )
{
    UIASSERT( pserver != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // REPL_EXPORT_LISTBOX :: REPL_EXPORT_LISTBOX


/*******************************************************************

    NAME:           REPL_EXPORT_LISTBOX :: ~REPL_EXPORT_LISTBOX

    SYNOPSIS:       REPL_EXPORT_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
REPL_EXPORT_LISTBOX :: ~REPL_EXPORT_LISTBOX( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EXPORT_LISTBOX :: ~REPL_EXPORT_LISTBOX


/*******************************************************************

    NAME:           REPL_EXPORT_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_EXPORT_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    REPL_EDIR2_ENUM enumEdir( QueryServerName() );

    APIERR err = enumEdir.GetInfo();

    if( err == NERR_Success )
    {
        REPL_EDIR2_ENUM_ITER iterEdir( enumEdir );
        const REPL_EDIR2_ENUM_OBJ * pEdir;

        while( ( pEdir = iterEdir() ) != NULL )
        {
            REPL_EXPORT_LBI * plbi;

            plbi = new REPL_EXPORT_LBI( pEdir->QueryDirName(),
                                        pEdir->QueryIntegrity() == REPL_INTEGRITY_TREE,
                                        pEdir->QueryExtent() == REPL_EXTENT_TREE,
                                        pEdir->QueryLockCount(),
                                        pEdir->QueryLockTime(),
                                        TRUE );

            if( AddItem( plbi ) < 0 )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

        }
    }

    if( ( err == NERR_Success ) && ( QueryCount() > 0 ) )
    {
        SelectItem( 0 );
    }

    return err;

}   // REPL_EXPORT_LISTBOX :: Fill


/*******************************************************************

    NAME:           REPL_EXPORT_LISTBOX :: AddDefaultSubDir

    SYNOPSIS:       Adds a new subdirectory to the listbox using
                    default parameters.

    ENTRY:          pszSubDirectory     - The name of the target subdir.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_EXPORT_LISTBOX :: AddDefaultSubDir( const TCHAR * pszSubDirectory,
                                                BOOL          fPreExisting )
{
    REPL_EXPORT_LBI * plbi = new REPL_EXPORT_LBI( pszSubDirectory,
                                                  DEFAULT_STABILIZE,
                                                  DEFAULT_SUBTREE,
                                                  DEFAULT_LOCK_COUNT,
                                                  DEFAULT_LOCK_TIME,
                                                  fPreExisting );

    APIERR err = NERR_Success;

    INT iItem = AddItem( plbi );

    if( iItem >= 0 )
    {
        SelectItem( iItem );
    }
    else
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    return err;

}   // REPL_EXPORT_LISTBOX :: AddDefaultSubDir



//
//  REPL_EXPORT_LBI methods
//

/*******************************************************************

    NAME:           REPL_EXPORT_LBI :: REPL_EXPORT_LBI

    SYNOPSIS:       REPL_EXPORT_LBI class constructor.

    ENTRY:          pszTarget           - The name of the target entity.  This
                                          will be either a server name or a
                                          domain name in either the export
                                          list or the import list.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_EXPORT_LBI :: REPL_EXPORT_LBI( const TCHAR * pszSubDirectory,
                                    BOOL          fStabilize,
                                    BOOL          fSubTree,
                                    ULONG         lLockCount,
                                    ULONG         lLockTime,
                                    BOOL          fPreExisting )
  : EXPORT_IMPORT_LBI( pszSubDirectory, lLockCount, lLockTime, fPreExisting ),
    _fStabilize( fStabilize ),
    _fSubTree( fSubTree ),
    _fOrgStabilize( fStabilize ),
    _fOrgSubTree( fSubTree )
{
    UIASSERT( pszSubDirectory != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // REPL_EXPORT_LBI :: REPL_EXPORT_LBI


/*******************************************************************

    NAME:           REPL_EXPORT_LBI :: ~REPL_EXPORT_LBI

    SYNOPSIS:       REPL_EXPORT_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_EXPORT_LBI :: ~REPL_EXPORT_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EXPORT_LBI :: ~REPL_EXPORT_LBI


/*******************************************************************

    NAME:           REPL_EXPORT_LBI :: Paint

    SYNOPSIS:       Draw an entry in REPL_EXPORT_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        beng        22-Apr-1992     Changes to LBI::Paint

********************************************************************/
VOID REPL_EXPORT_LBI :: Paint( LISTBOX *          plb,
                               HDC                hdc,
                               const RECT       * prect,
                               GUILTT_INFO      * pGUILTT ) const
{
    REPL_EXPORT_LISTBOX * pMylb = (REPL_EXPORT_LISTBOX *)plb;

    DEC_STR nlsLockCount( QueryVirtualLockCount() );

    STR_DTE dteSubDirectory( QuerySubDirectory() );
    STR_DTE dteLockCount( nlsLockCount );
    STR_DTE dteStabilize( pMylb->MapBoolean( DoesWaitForStabilize() ) );
    STR_DTE dteSubTree( pMylb->MapBoolean( DoesExportSubTree() ) );
    STR_DTE dteLockTime( QueryLockTimeString() );

    DISPLAY_TABLE dtab( REPL_EXPORT_LISTBOX_COLUMNS,
                        pMylb->QueryColumnWidths() );

    dtab[0] = &dteSubDirectory;
    dtab[1] = &dteLockCount;
    dtab[2] = &dteStabilize;
    dtab[3] = &dteSubTree;
    dtab[4] = &dteLockTime;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // REPL_EXPORT_LBI :: Paint


/*******************************************************************

    NAME:       REPL_EXPORT_LBI :: IsDirty

    SYNOPSIS:   Determines if the current LBI is dirty and thus the
                target directory needs to be updated.

    RETURNS:    BOOL                    - TRUE if the LBI is dirty.

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_EXPORT_LBI :: IsDirty( VOID )
{
    if( ( _fOrgStabilize != _fStabilize ) || ( _fOrgSubTree != _fSubTree ) )
    {
        return TRUE;
    }

    return EXPORT_IMPORT_LBI::IsDirty();

}   // REPL_EXPORT_LBI :: IsDirty
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\replmain.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    replmain.cxx
    Class definitions for Main Replicator Admin dialog.

    The REPL_MAIN_* classes implement the Main Replicator Admin dialog.
    This dialog is invoked from the Server Manager Main Property Sheet.

    The classes are structured as follows:

        LBI
            REPL_MAIN_LBI

        BLT_LISTBOX
            REPL_MAIN_LISTBOX

        DIALOG_WINDOW
            REPL_MAIN_DIALOG


    FILE HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        KeithMo     19-Feb-1992     Added target add/remove code.
        KeithMo     27-Aug-1992     Added REPL$ ACL code.
        JonN        06-Sup-1997     can have either Logon Script Path or System Volume

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <focusdlg.hxx>
#include <srvsvc.hxx>
#include <srvbase.hxx>
#include <lmoshare.hxx>
#include <dbgstr.hxx>
#include <uatom.hxx>
#include <regkey.hxx>
#include <security.hxx>
#include <ntacutil.hxx>

extern "C" {

    #include <srvmgr.h>
    #include <lmrepl.h>
    #include <mnet.h>
    #include <icanon.h>

}   // extern "C"

#include <replmain.hxx>
#include <replexp.hxx>
#include <replimp.hxx>



//
//  This defines an invalid replicator service role.  This
//  value *must* not collide with any of the REPL_ROLE_* values
//  defined in LMREPL.H.
//

#define REPL_ROLE_NOT_RUNNING   1000

//
//  This is the separator used in the import/export lists.
//

#define EXPORT_IMPORT_SEPARATOR SZ(";")

//
//  This is the name of the sharepoint used by the export side
//  of the replicator service.  I couldn't find a manifest constant
//  for this in any public place, so I created my own.
//

const TCHAR * pszReplShare = SZ("REPL$");


//
//  This is the registry node that contains the logon scripts path
//  or the System Volume path.
//

const TCHAR * pszLogonScriptOrSysvolPathKeyName =
    SZ("System\\CurrentControlSet\\Services\\Netlogon\\Parameters");

const TCHAR * pszLogonScriptPathValueName =
    SZ("Scripts");

const TCHAR * pszSystemVolumePathValueName =
    SZ("SysVol");


//
//  This is the registry node that contains the %SystemRoot% path.
//

const TCHAR * pszSystemRootKeyName =
    SZ("Software\\Microsoft\\Windows NT\\CurrentVersion");

const TCHAR * pszSystemRootValueName =
    SZ("SystemRoot");

//
//  The %SystemRoot% environment variable.
//

const TCHAR * pszSystemRootEnvVar =
    SZ("%SystemRoot%");

//
//  Maximum ULONG, just in case it's not already defined.
//

#ifndef MAXULONG
#define MAXULONG ((ULONG)-1L)
#endif


//
//  REPL_MAIN_DIALOG methods
//

/*******************************************************************

    NAME:           REPL_MAIN_DIALOG :: REPL_MAIN_DIALOG

    SYNOPSIS:       REPL_MAIN_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pserver             - A SERVER_2 object representing
                                          the target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_MAIN_DIALOG :: REPL_MAIN_DIALOG( HWND       hWndOwner,
                                      SERVER_2 * pserver,
                                      BOOL       fIsLanmanNT )
  : DIALOG_WINDOW( fIsLanmanNT ? MAKEINTRESOURCE( IDD_REPL_MAIN )
                               : MAKEINTRESOURCE( IDD_MINI_REPL_MAIN ),
                   hWndOwner ),
    _pmgExport( NULL ),
    _ppbExportManage( NULL ),
    _ppbExportAdd( NULL ),
    _ppbExportRemove( NULL ),
    _psleExportPath( NULL ),
    _plbExportTargets( NULL ),
    _pnlsOldExportPath( NULL ),
    _nlsOldImportPath(),
    _psleLogonScriptOrSysvolPath( NULL ),
    _psltLogonScriptText( NULL ),
    _psltSysvolText( NULL ),
    _fSysvolNotLogonScript( FALSE ),
    _fNeitherSysvolNorLogonScript( FALSE ),
    _mgImport( this, IDRM_IMPORT_NO, 2, IDRM_IMPORT_NO ),
    _pbImportManage( this, IDRM_IMPORT_MANAGE ),
    _pbImportAdd( this, IDRM_IMPORT_ADD ),
    _pbImportRemove( this, IDRM_IMPORT_REMOVE ),
    _sltImportPathLabel( this, IDRM_IMPORT_PATH_LABEL ),
    _sltImportListLabel( this, IDRM_IMPORT_LIST_LABEL ),
    _sleImportPath( this, IDRM_IMPORT_PATH ),
    _lbImportTargets( this, IDRM_IMPORT_LIST ),
    _pserver( pserver ),
    _prepl( NULL ),
    _fIsLanmanNT( fIsLanmanNT ),
    _psltExportPathLabel( NULL ),
    _psltExportListLabel( NULL ),
    _nlsSystemRoot(),
    _pbOK( this, IDOK )
{
    UIASSERT( pserver != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSystemRoot )
    {
        ReportError( _nlsSystemRoot.QueryError() );
        return;
    }

    //
    //  This may take a few seconds.
    //

    AUTO_CURSOR NiftyCursor;

    APIERR err = _nlsOldImportPath.QueryError();

    if( ( err == NERR_Success ) && fIsLanmanNT )
    {
        err = GetSystemRoot();
    }

    if( ( err == NERR_Success ) && fIsLanmanNT )
    {
        _pmgExport = new MAGIC_GROUP( this, IDRM_EXPORT_NO, 2, IDRM_EXPORT_NO );
        _ppbExportManage = new PUSH_BUTTON( this, IDRM_EXPORT_MANAGE );
        _ppbExportAdd = new PUSH_BUTTON( this, IDRM_EXPORT_ADD );
        _ppbExportRemove = new PUSH_BUTTON( this, IDRM_EXPORT_REMOVE );
        _psleExportPath = new SLE( this, IDRM_EXPORT_PATH );
        _plbExportTargets = new REPL_MAIN_LISTBOX( this, IDRM_EXPORT_LIST );
        _pnlsOldExportPath = new NLS_STR;
        _psleLogonScriptOrSysvolPath = new SLE( this, IDRM_EDIT_LOGON_SCRIPT_OR_SYSVOL );
        _psltLogonScriptText = new SLT( this, IDRM_STATIC_LOGON_SCRIPT );
        _psltSysvolText = new SLT( this, IDRM_STATIC_SYSVOL );
        _psltExportPathLabel = new SLT( this, IDRM_EXPORT_PATH_LABEL );
        _psltExportListLabel = new SLT( this, IDRM_EXPORT_LIST_LABEL );

        if( ( _pmgExport           == NULL ) ||
            ( _ppbExportManage     == NULL ) ||
            ( _ppbExportAdd        == NULL ) ||
            ( _ppbExportRemove     == NULL ) ||
            ( _psleExportPath      == NULL ) ||
            ( _plbExportTargets    == NULL ) ||
            ( _pnlsOldExportPath   == NULL ) ||
            ( _psleLogonScriptOrSysvolPath == NULL ) ||
            ( _psltLogonScriptText == NULL ) ||
            ( _psltSysvolText == NULL ) ||
            ( _psltExportPathLabel == NULL ) ||
            ( _psltExportListLabel == NULL ) )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }

        if( err == NERR_Success )
        {
            err = QueryError();
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->QueryError();
        }

        if( err == NERR_Success )
        {
            err = _pnlsOldExportPath->QueryError();
        }
    }

    if( err == NERR_Success )
    {
        err = _mgImport.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Set the caption.
        //

        STACK_NLS_STR( nlsDisplayName, MAX_PATH + 1 );
        REQUIRE( _pserver->QueryDisplayName( &nlsDisplayName ) == NERR_Success );

        err = SRV_BASE_DIALOG::SetCaption( this,
                                           IDS_CAPTION_REPL,
                                           nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Read the replicator service information.
        //

        err = ReadReplInfo();
    }

    //
    //  Setup the magic group associations.
    //

    if( _fIsLanmanNT )
    {
        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _ppbExportManage );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _ppbExportAdd );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _ppbExportRemove );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _psleExportPath );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _plbExportTargets );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _psltExportPathLabel );
        }

        if( err == NERR_Success )
        {
            err = _pmgExport->AddAssociation( IDRM_EXPORT_YES,
                                              _psltExportListLabel );
        }
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_pbImportManage );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_pbImportAdd );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_pbImportRemove );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_sleImportPath );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_lbImportTargets );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_sltImportPathLabel );
    }

    if( err == NERR_Success )
    {
        err = _mgImport.AddAssociation( IDRM_IMPORT_YES,
                                        &_sltImportListLabel );
    }

    if( err == NERR_Success )
    {
        //
        //  Enable the remove buttons as appropriate.
        //

        if( _fIsLanmanNT )
        {
            _ppbExportRemove->Enable( _plbExportTargets->QueryCount() > 0 );
        }

        _pbImportRemove.Enable( _lbImportTargets.QueryCount() > 0 );
    }

    if( err == NERR_Success )
    {
        _pbOK.MakeDefault();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // REPL_MAIN_DIALOG :: REPL_MAIN_DIALOG


/*******************************************************************

    NAME:           REPL_MAIN_DIALOG :: ~REPL_MAIN_DIALOG

    SYNOPSIS:       REPL_MAIN_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_MAIN_DIALOG :: ~REPL_MAIN_DIALOG( VOID )
{
    _pserver = NULL;

    delete _prepl;
    _prepl = NULL;

    delete _psleLogonScriptOrSysvolPath;
    _psleLogonScriptOrSysvolPath = NULL;
    delete _psltLogonScriptText;
    _psltLogonScriptText = NULL;
    delete _psltSysvolText;
    _psltSysvolText = NULL;

    delete _pnlsOldExportPath;
    _pnlsOldExportPath = NULL;

    delete _plbExportTargets;
    _plbExportTargets = NULL;

    delete _psleExportPath;
    _psleExportPath = NULL;

    delete _ppbExportRemove;
    _ppbExportRemove = NULL;

    delete _ppbExportAdd;
    _ppbExportAdd = NULL;

    delete _ppbExportManage;
    _ppbExportManage = NULL;

    delete _pmgExport;
    _pmgExport = NULL;

    delete _psltExportPathLabel;
    _psltExportPathLabel = NULL;

    delete _psltExportListLabel;
    _psltExportListLabel = NULL;

}   // REPL_MAIN_DIALOG :: ~REPL_MAIN_DIALOG


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
BOOL REPL_MAIN_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    switch( event.QueryCid() )
    {

    case IDRM_EXPORT_ADD :
        UIASSERT( _fIsLanmanNT );
        AddNewTarget( _plbExportTargets,
                      _ppbExportRemove );
        return TRUE;

    case IDRM_EXPORT_REMOVE :
        UIASSERT( _fIsLanmanNT );
        RemoveExistingTarget( _plbExportTargets,
                              _ppbExportRemove,
                              IDS_REMOVE_EXPORT_TARGET );
        return TRUE;

    case IDRM_EXPORT_MANAGE :
        UIASSERT( _fIsLanmanNT );
        ExportManageDialog();
        return TRUE;

    case IDRM_IMPORT_ADD :
        AddNewTarget( &_lbImportTargets,
                      &_pbImportRemove );
        return TRUE;

    case IDRM_IMPORT_REMOVE :
        RemoveExistingTarget( &_lbImportTargets,
                              &_pbImportRemove,
                              IDS_REMOVE_IMPORT_TARGET );
        return TRUE;

    case IDRM_IMPORT_MANAGE :
        ImportManageDialog();
        return TRUE;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        return FALSE;
    }

}   // REPL_MAIN_DIALOG :: OnCommand


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: OnOK

    SYNOPSIS:   Invoked whenever the user presses the "OK" button.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        KeithMo     09-Nov-1992     Validate logon script path.
        KeithMo     26-Jan-1993     Validate export & import paths.

********************************************************************/
BOOL REPL_MAIN_DIALOG :: OnOK( VOID )
{
    UIASSERT( _prepl != NULL );

    //
    //  This may take a few seconds.
    //

    AUTO_CURSOR NiftyCursor;

    //
    //  Before we proceed any further, validate the various
    //  paths the user has given.  We always validate the
    //  import path.  We only validate the export &
    //  logon script paths if we're focused on Lanman NT.
    //

    NLS_STR nlsTempPath;

    APIERR err = nlsTempPath.QueryError();

    if( err == NERR_Success )
    {
        TCHAR szCanon[MAX_PATH];
        ULONG type  = 0L;
        SLE * psle  = NULL;

        if( _fIsLanmanNT &&
            ( _pmgExport->QuerySelection() == IDRM_EXPORT_YES ) )
        {
            //
            //  Validate the export path.
            //

            err = _psleExportPath->QueryText( &nlsTempPath );

            if( err == NERR_Success )
            {
                err = ::I_MNetPathCanonicalize( NULL,
                                                nlsTempPath,
                                                szCanon,
                                                sizeof(szCanon),
                                                NULL,
                                                &type,
                                                0L );
            }

            if( ( err == ERROR_INVALID_NAME ) ||
                ( type & (ITYPE_UNC | ITYPE_DEVICE ) ) )
            {
                //
                //  The user gave us either an invalid (malformed)
                //  path, a UNC path, or a device name.
                //

                err  = IDS_EXPORT_PATH_INVALID;
                psle = _psleExportPath;
            }
        }

        if( ( err == NERR_Success ) &&
            ( _mgImport.QuerySelection() == IDRM_IMPORT_YES ) )
        {
            //
            //  Validate the import path.
            //

            err = _sleImportPath.QueryText( &nlsTempPath );

            if( err == NERR_Success )
            {
                err = ::I_MNetPathCanonicalize( NULL,
                                                nlsTempPath,
                                                szCanon,
                                                sizeof(szCanon),
                                                NULL,
                                                &type,
                                                0L );
            }

            if( ( err == ERROR_INVALID_NAME ) ||
                ( type & (ITYPE_UNC | ITYPE_DEVICE ) ) )
            {
                //
                //  The user gave us either an invalid (malformed)
                //  path, a UNC path, or a device name.
                //

                err  = IDS_IMPORT_PATH_INVALID;
                psle = &_sleImportPath;
            }
        }

        if( _fIsLanmanNT && !_fNeitherSysvolNorLogonScript && ( err == NERR_Success ) )
        {
            //
            //  Validate the logon script or system volume path.
            //

            err = _psleLogonScriptOrSysvolPath->QueryText( &nlsTempPath );

            if( err == NERR_Success )
            {
                err = ::I_MNetPathCanonicalize( NULL,
                                                nlsTempPath,
                                                szCanon,
                                                sizeof(szCanon),
                                                NULL,
                                                &type,
                                                0L );
            }

            if( ( err == ERROR_INVALID_NAME ) ||
                ( type & (ITYPE_UNC | ITYPE_DEVICE ) ) )
            {
                //
                //  The user gave us either an invalid (malformed)
                //  path, a UNC path, or a device name.
                //

                err  = (_fSysvolNotLogonScript) ? IDS_SYSTEM_VOLUME_INVALID
                                                : IDS_LOGON_SCRIPT_INVALID;
                psle = _psleLogonScriptOrSysvolPath;
            }
        }

        if( err != NERR_Success )
        {
            //
            //  Something failed validation.
            //

            ::MsgPopup( this, err );

            if( psle != NULL )
            {
                psle->ClaimFocus();
            }

            return TRUE;
        }
    }

    //
    //  Get the new role from the dialog.
    //

    ULONG nNewRole = REPL_ROLE_NOT_RUNNING;     // Until proven otherwise...

    if( _fIsLanmanNT && ( _pmgExport->QuerySelection() == IDRM_EXPORT_YES ) )
    {
        nNewRole = ( _mgImport.QuerySelection() == IDRM_IMPORT_YES )
                       ? REPL_ROLE_BOTH
                       : REPL_ROLE_EXPORT;
    }
    else
    {
        nNewRole = ( _mgImport.QuerySelection() == IDRM_IMPORT_YES )
                       ? REPL_ROLE_IMPORT
                       : REPL_ROLE_NOT_RUNNING;
    }

    //
    //  Get the old role from the replicator.
    //

    ULONG nOldRole;

    if( err == NERR_Success )
    {
        err = DetermineCurrentRole( &nOldRole );
    }

    //
    //  Update the replicator's role.
    //

    if( ( err == NERR_Success ) && ( nNewRole != REPL_ROLE_NOT_RUNNING ) )
    {
        _prepl->SetRole( nNewRole );
    }

    //
    //  Update the export & import paths.
    //

    if( ( err == NERR_Success ) && _fIsLanmanNT &&
        ( _pmgExport->QuerySelection() == IDRM_EXPORT_YES ) )
    {
        err = W_UpdatePath( &nOldRole, TRUE );
    }

    if( ( err == NERR_Success ) &&
        ( _mgImport.QuerySelection() == IDRM_IMPORT_YES ) )
    {
        err = W_UpdatePath( &nOldRole, FALSE );
    }

    //
    //  Update the export list & import lists.
    //

    NLS_STR nls;

    if( err == NERR_Success )
    {
        err = nls.QueryError();
    }

    if( ( err == NERR_Success ) && _fIsLanmanNT )
    {
        if( _pmgExport->QuerySelection() == IDRM_EXPORT_YES )
        {
            err = BuildExportImportList( &nls, _plbExportTargets );

            if( err == NERR_Success )
            {
                err = _prepl->SetExportList( nls.QueryPch() );
            }
        }
    }

    if( ( err == NERR_Success ) &&
        ( _mgImport.QuerySelection() == IDRM_IMPORT_YES ) )
    {
        err = BuildExportImportList( &nls, &_lbImportTargets );

        if( err == NERR_Success )
        {
            err = _prepl->SetImportList( nls.QueryPch() );
        }
    }

    //
    //  Write the new information to the replicator.
    //

    if( err == NERR_Success )
    {
        err = _prepl->WriteInfo();

#if 0
        //
        //  BETABUG!
        //
        //  There is a problem in either the replicator service,
        //  the service controller, or RPC that causes the
        //  NetReplSetInfo API to fail if invoked *immediately*
        //  after stopping the service.  As a work-around, we'll
        //  catch the offending error (RPC_S_CALL_FAILED), sleep
        //  a few seconds, and retry the API.
        //

        if( err == RPC_S_CALL_FAILED )
        {
            DBGEOL( "SRVMGR: NetReplSetInfo failed, sleeping 5 seconds and retrying" );
            ::Sleep( 5000 );
            err = _prepl->WriteInfo();
        }
#endif
    }

    if( ( err == NERR_Success ) && _fIsLanmanNT && !_fNeitherSysvolNorLogonScript )
    {
        //
        //  Update the logon script or system volume path.
        //

        err = WriteLogonScriptOrSysvolPath( &nlsTempPath );
    }

    //
    //  Setup the REPL$ sharepoint as appropriate.
    //

    if( ( err == NERR_Success ) && _fIsLanmanNT )
    {
        err = SetupReplShare();
    }

    //
    //  Start or stop the replicator service as appropriate.
    //
    //  A few words on the following IF statement:
    //
    //      We obviously don't want to touch the service if any of
    //      the preceeding methods have failed.
    //
    //      We obviously don't need to touch the service if the old
    //      replicator role matches the new desired role.
    //
    //      Not so obvious is that we only need to touch the service
    //      if either the old role or the new role are REPL_ROLE_NOT_RUNNING.
    //      This indicates that the user wants the replicator service
    //      to transition STOPPED <<-->> STARTED.
    //

    if( ( err == NERR_Success ) &&
        ( nNewRole != nOldRole ) &&
        ( ( nNewRole == REPL_ROLE_NOT_RUNNING ) ||
          ( nOldRole == REPL_ROLE_NOT_RUNNING ) ) )
    {
        err = ControlService( nNewRole != REPL_ROLE_NOT_RUNNING );
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
        return FALSE;
    }

    Dismiss( TRUE );
    return TRUE;

}   // REPL_MAIN_DIALOG :: OnOK


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: W_UpdatePath

    SYNOPSIS:   Updates either the export or import path based
                on the setting of a passed boolean.

    ENTRY:      pnOldRole               - Contains the old replicator role.
                                          may be changed by this method.

                fExport                 - TRUE if we're updating the export
                                          path.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method only updates the REPLICATOR_0 object
                associated with this dialog.  It does not actually
                write the new path to the replicator service.
                _prepl->WriteInfo() must be called after this method
                to update the service.

                Also, if the replicator service is running and the
                export or import path needs to be changed, the
                service must be stopped before updating the path.
                This method may stop the service, then update *pnOldRole
                before changing the path.

    HISTORY:
        KeithMo     29-Oct-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: W_UpdatePath( ULONG * pnOldRole,
                                         BOOL    fExport )
{
    UIASSERT( pnOldRole != NULL );
    UIASSERT( !fExport || _fIsLanmanNT );

    //
    //  This may take a while...
    //

    AUTO_CURSOR NiftyCursor;

    //
    //  Get some pointers to the appropriate data members.
    //

    const SLE * psle = ( fExport ) ? _psleExportPath
                                   : &_sleImportPath;

    const NLS_STR * pnls = ( fExport ) ? _pnlsOldExportPath
                                       : &_nlsOldImportPath;

    UIASSERT( psle != NULL );
    UIASSERT( pnls != NULL );

    //
    //  Get the current path from the SLE.
    //

    NLS_STR nlsNewPath;

    APIERR err = nlsNewPath.QueryError();

    if( err == NERR_Success )
    {
        err = psle->QueryText( &nlsNewPath );
    }

    //
    //  If the path has changed, update it at the replicator.
    //

    if( ( err == NERR_Success ) && ( pnls->_stricmp( nlsNewPath ) != 0 ) )
    {
        if( *pnOldRole != REPL_ROLE_NOT_RUNNING )
        {
            //
            //  The user wants to change either the import or
            //  export path while the replicator service is
            //  running.  Before we can change the path, we
            //  must first stop the replicator service.
            //

            NiftyCursor.TurnOff();
            err = ControlService( FALSE );
            NiftyCursor.TurnOn();

            if( err == NERR_Success )
            {
                //
                //  Now that we've stopped the replicator service,
                //  we'll pretent the "old" role was "not running".
                //  This will cause the service to get started
                //  just before we dismiss the dialog.
                //

                *pnOldRole = REPL_ROLE_NOT_RUNNING;
            }
        }

        if( err == NERR_Success )
        {
            //
            //  Update the appropriate export/import path.
            //

            err = ( fExport ) ? _prepl->SetExportPath( nlsNewPath )
                              : _prepl->SetImportPath( nlsNewPath );
        }
    }

    return err;

}   // REPL_MAIN_DIALOG :: W_UpdatePath


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: BuildExportImportList

    SYNOPSIS:   This method will read the contents of a particular
                listbox and create an export/import list.  The
                items in the list must be separated by semicolons.

    ENTRY:

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     02-Mar-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: BuildExportImportList( NLS_STR           * pnls,
                                                  REPL_MAIN_LISTBOX * plb )
{
    UIASSERT( pnls != NULL );
    UIASSERT( plb != NULL );

    //
    //  First, clear out the NLS_STR.
    //

    APIERR err = pnls->CopyFrom( SZ("") );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Since STRING::strcat takes an NLS_STR, we must create one
    //  for our semicolon.
    //

    ALIAS_STR nlsSeparator( EXPORT_IMPORT_SEPARATOR );
    UIASSERT( nlsSeparator.QueryError() == NERR_Success );

    INT cItems = plb->QueryCount();

    for( INT i = 0 ; ( i < cItems ) && ( err == NERR_Success ) ; i++ )
    {
        REPL_MAIN_LBI * plbi = plb->QueryItem( i );
        UIASSERT( plbi != NULL );

        if( i > 0 )
        {
            pnls->strcat( nlsSeparator );
            err = pnls->QueryError();
        }

        if( err == NERR_Success )
        {
            ALIAS_STR nlsTarget( plbi->QueryTarget() );
            UIASSERT( nlsTarget.QueryError() == NERR_Success );

            pnls->strcat( nlsTarget );
            err = pnls->QueryError();
        }
    }

    return err;

}   // REPL_MAIN_DIALOG :: BuildExportImportList


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
ULONG REPL_MAIN_DIALOG :: QueryHelpContext( VOID )
{
    return _fIsLanmanNT ? HC_REPL_MAIN_BOTH_DIALOG
                        : HC_REPL_MAIN_IMPONLY_DIALOG;

}   // REPL_MAIN_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ReadReplInfo

    SYNOPSIS:   This method is responsible for initializing the
                dialog items that represent information from the
                replicator service.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     26-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: ReadReplInfo( VOID )
{
    //
    //  Construct our REPLICATOR_0 object.
    //

    _prepl = new REPLICATOR_0( QueryServerName() );

    APIERR err = ( _prepl == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                    : _prepl->GetInfo();

    if( err == NERR_Success )
    {
        _sleImportPath.SetText( _prepl->QueryImportPath() );

        if( _fIsLanmanNT )
        {
            _psleExportPath->SetText( _prepl->QueryExportPath() );
            err = _plbExportTargets->Fill( _prepl->QueryExportList() );
        }
    }

    if( err == NERR_Success )
    {
        err = _lbImportTargets.Fill( _prepl->QueryImportList() );
    }

    if( err == NERR_Success )
    {
        err = _nlsOldImportPath.CopyFrom( _prepl->QueryImportPath() );
    }

    if( ( err == NERR_Success ) && _fIsLanmanNT )
    {
        err = _pnlsOldExportPath->CopyFrom( _prepl->QueryExportPath() );
    }

    //
    //  Determine the replicators current role.  If the service
    //  is not yet started, disable the import & export sides of
    //  the dialog.
    //

    ULONG nRole = REPL_ROLE_NOT_RUNNING;

    if( err == NERR_Success )
    {
        err = DetermineCurrentRole( &nRole );
    }

    if( err == NERR_Success )
    {
        CID cidExportSelection = IDRM_EXPORT_NO;        // until proven
        CID cidImportSelection = IDRM_IMPORT_NO;        // otherwise...

        switch( nRole )
        {
        case REPL_ROLE_NOT_RUNNING :
            //
            //  cidExportSelection & cidImportSelection already set.
            //
            break;

        case REPL_ROLE_IMPORT :
            //
            //  cidExportSelection already set.
            //
            cidImportSelection = IDRM_IMPORT_YES;
            break;

        case REPL_ROLE_EXPORT :
            //
            //  cidImportSelection already set.
            //
            cidExportSelection = IDRM_EXPORT_YES;
            break;

        case REPL_ROLE_BOTH :
            cidExportSelection = IDRM_EXPORT_YES;
            cidImportSelection = IDRM_IMPORT_YES;
            break;

        default :
            UIASSERT( FALSE );  // Invalid replicator role!
            break;
        }

        if( _fIsLanmanNT )
        {
            _pmgExport->SetSelection( cidExportSelection );
        }

        _mgImport.SetSelection( cidImportSelection );

#if 0
        //
        //  BETABUG!
        //
        //  There is a bug in the Beta version of the Replicator service
        //  that prevents APIs from executing on the "disabled" side.
        //  For example, if an "import" API is remoted to a replicator
        //  service that is running "export-only", the service will
        //  explode.  As a temporary work-around, the UI will prevent
        //  the user for doing anything that will cause such problems.
        //
        //  Basically, we only allow those operations that are valid
        //  when the dialog first comes up.  If the service is running
        //  "export-only", then we'll disable the "import manage" button.
        //

        RADIO_BUTTON * prb = NULL;

        if( _fIsLanmanNT )
        {
            _ppbExportManage->Enable( cidExportSelection == IDRM_EXPORT_YES );
            prb = (*_pmgExport)[cidExportSelection];
        }
        else
        {
            prb = _mgImport[cidImportSelection];
        }

        _pbImportManage.Enable( cidImportSelection == IDRM_IMPORT_YES );

        UIASSERT( prb != NULL );
        prb->ClaimFocus();
#endif
    }

    if( ( err == NERR_Success ) && _fIsLanmanNT )
    {
        //
        //  Read the logon script or system volume path.
        //

        NLS_STR nlsLogonScriptOrSysvolPath;

        err = nlsLogonScriptOrSysvolPath.QueryError();

        if( err == NERR_Success )
        {
            //
            // This API may set _fSysvolNotLogonScript
            // and/or _fNeitherSysvolNorLogonScript
            //
            err = ReadLogonScriptOrSysvolPath( &nlsLogonScriptOrSysvolPath );
        }

        if( !_fNeitherSysvolNorLogonScript && err == NERR_Success )
        {
            _psleLogonScriptOrSysvolPath->SetText( nlsLogonScriptOrSysvolPath );
        }
    }

    return err;

}   // REPL_MAIN_DIALOG :: ReadReplInfo


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ControlService

    SYNOPSIS:   This method will start/stop the replicator service.
                It presents a nifty progress indicator so the poor
                user won't feel neglected and ignored.

    ENTRY:      fStart                  - If TRUE, will start the service.
                                          Otherwise, stops the service.

    EXIT:       If successful, then the service has been started/stopped.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Apr-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: ControlService( BOOL fStart )
{
    //
    //  Create the service object.  This also contains the
    //  progress indicator for amusing the user.
    //

    STACK_NLS_STR( nlsDisplayName, MAX_PATH + 1 );
    REQUIRE( _pserver->QueryDisplayName( &nlsDisplayName ) == NERR_Success );

    GENERIC_SERVICE * psvc = new GENERIC_SERVICE( this,
                                                  _pserver->QueryName(),
                                                  nlsDisplayName,
                                                  (const TCHAR *)SERVICE_REPL );

    APIERR err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : psvc->QueryError();

    if( err == NERR_Success )
    {
        err = ( fStart ) ? psvc->Start()
                         : psvc->Stop();
    }

    delete psvc;

    return err;

}   // REPL_MAIN_DIALOG :: ControlService


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: SetupReplShare

    SYNOPSIS:   This method is responsible for setting up the
                REPL$ to the appropriate export path.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Apr-1992     Created for the Server Manager.
        KeithMo     27-Aug-1992     Now calls SetupReplACL to setup
                                    appropriate security descriptor.
        KeithMo     26-Jan-1993     Only delete old REPL$ if we're
                                    actually changing the export path.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: SetupReplShare( VOID )
{
    UIASSERT( _fIsLanmanNT );

    //
    //  Determine the new sharepoint path.  If the "export"
    //  side of the dialog is enabled, then retrieve the
    //  new export path from the SLE.  Otherwise, use the
    //  "old" export path.
    //

    NLS_STR nlsNewSharePath;

    APIERR err = nlsNewSharePath.QueryError();

    if( err == NERR_Success )
    {
        if( _pmgExport->QuerySelection() == IDRM_EXPORT_YES )
        {
            err = _psleExportPath->QueryText( &nlsNewSharePath );
        }
        else
        {
            err = nlsNewSharePath.CopyFrom( _pnlsOldExportPath->QueryPch() );
        }
    }

    //
    //  This represents the "old" sharepoint.
    //

    SHARE_2 shareOld( pszReplShare, _pserver->QueryName() );

    err = err ? err : shareOld.QueryError();
    err = err ? err : shareOld.GetInfo();

    BOOL fOldShareExists = ( err == NERR_Success );

    //
    //  Determine if we need to tear down & recreate
    //  a new REPL$ sharepoint.
    //

    if( ( err == NERR_NetNameNotFound ) ||
        ( ( err == NERR_Success ) &&
          ( ::stricmpf( shareOld.QueryPath(), nlsNewSharePath ) != 0 ) ) )
    {
        //
        //  Either the path's don't match or a REPL$ sharepoint
        //  doesn't already exist.  Create a new REPL$ sharepoint.
        //

        SHARE_2 shareNew( pszReplShare, _pserver->QueryName() );

        err = shareNew.QueryError();
        err = err ? err : shareNew.CreateNew();
        err = err ? err : shareNew.SetResourceType( STYPE_DISKTREE );
        err = err ? err : shareNew.SetPath( nlsNewSharePath );

        if( ( err == NERR_Success ) && fOldShareExists )
        {
            //
            //  Delete the old sharepoint.
            //

            err = shareOld.Delete();
        }

        if( err == NERR_Success )
        {
            //
            //  Create the new sharepoint.
            //

            err = shareNew.Write();
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Setup the appropriate ACL on the share.
        //

        err = SetupReplACL();
    }

    return err;

}   // REPL_MAIN_DIALOG :: SetupReplShare


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: SetupReplACL

    SYNOPSIS:   This method is responsible for setting the security
                ACL on the REPL$ share.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     27-Aug-1992     Created.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: SetupReplACL( VOID )
{
    UIASSERT( _fIsLanmanNT );

    //
    //  Various security objects.
    //

    OS_SECURITY_DESCRIPTOR * pOsSecDesc = NULL;
    OS_ACL                   aclDacl;
    OS_ACE                   osaceRepl;
    OS_ACE                   osaceAdmin;

    //
    //  Ensure everything constructed properly.
    //

    APIERR err = aclDacl.QueryError();

    err = err ? err : osaceRepl.QueryError();
    err = err ? err : osaceAdmin.QueryError();

    //
    //  Create the security descriptor.
    //

    if( err == NERR_Success )
    {
        pOsSecDesc = new OS_SECURITY_DESCRIPTOR( NULL );

        err = ( pOsSecDesc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : pOsSecDesc->QueryError();
    }

    //
    //  Setup the ACEs.
    //

    if( err == NERR_Success )
    {
        osaceRepl.SetAccessMask( GENERIC_READ | GENERIC_EXECUTE );
        osaceRepl.SetInheritFlags( 0 );
        osaceRepl.SetType( ACCESS_ALLOWED_ACE_TYPE );

        osaceAdmin.SetAccessMask( GENERIC_ALL );
        osaceAdmin.SetInheritFlags( 0 );
        osaceAdmin.SetType( ACCESS_ALLOWED_ACE_TYPE );
    }

    //
    //  Create the OS SIDs.
    //

    OS_SID ossidRepl;
    OS_SID ossidAdmin;

    err = err ? err : NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Replicator,
                                                           &ossidRepl );
    err = err ? err : NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
                                                           &ossidAdmin );

    //
    //  Set the security descriptor's owner & group.
    //

    err = err ? err : pOsSecDesc->SetGroup( ossidAdmin, TRUE );
    err = err ? err : pOsSecDesc->SetOwner( ossidAdmin, TRUE );

    //
    //  Add the SIDs to the ACEs.
    //

    err = err ? err : osaceRepl.SetSID( ossidRepl );
    err = err ? err : osaceAdmin.SetSID( ossidAdmin );

    //
    //  Add the ACEs to the ACL.
    //

    err = err ? err : aclDacl.AddACE( MAXULONG, osaceRepl );
    err = err ? err : aclDacl.AddACE( MAXULONG, osaceAdmin );

    //
    //  Put the ACL in the security descriptor.
    //

    err = err ? err : pOsSecDesc->SetDACL( TRUE, &aclDacl );

    //
    //  Now that we've got a valid security descriptor,
    //  apply it to the REPL$ sharepoint.
    //

    if( err == NERR_Success )
    {
        SHARE_INFO_1501 shi1501;
        ::ZeroMemory(&shi1501,sizeof(shi1501)); // JonN 01/28/00: PREFIX bug 444937

        shi1501.shi1501_security_descriptor = pOsSecDesc->QueryDescriptor();

        err = ::MNetShareSetInfo( _pserver->QueryName(),
                                  pszReplShare,
                                  1501,
                                  (BYTE FAR *)&shi1501,
                                  sizeof(shi1501),
                                  PARMNUM_ALL );

    }

    //
    //  Nuke the security descriptor we may have created.
    //

    delete pOsSecDesc;

    return err;

}   // REPL_MAIN_DIALOG :: SetupReplACL


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ExportManageDialog

    SYNOPSIS:   This method invokes the export management dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID REPL_MAIN_DIALOG :: ExportManageDialog( VOID )
{
    UIASSERT( _fIsLanmanNT );

    NLS_STR nlsPath;

    _psleExportPath->QueryText( &nlsPath );

    APIERR err = nlsPath.QueryError();

    if( err == NERR_Success )
    {
        REPL_EXPORT_DIALOG * pDlg = new REPL_EXPORT_DIALOG( QueryHwnd(),
                                                            _pserver,
                                                            nlsPath.QueryPch() );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process();

        delete pDlg;
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

}   // REPL_MAIN_DIALOG :: ExportManageDialog


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ImportManageDialog

    SYNOPSIS:   This method invokes the import management dialog.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID REPL_MAIN_DIALOG :: ImportManageDialog( VOID )
{
    NLS_STR nlsPath;

    _sleImportPath.QueryText( &nlsPath );

    APIERR err = nlsPath.QueryError();

    if( err == NERR_Success )
    {
        REPL_IMPORT_DIALOG * pDlg = new REPL_IMPORT_DIALOG( QueryHwnd(),
                                                            _pserver,
                                                            nlsPath.QueryPch() );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process();

        delete pDlg;
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

}   // REPL_MAIN_DIALOG :: ImportManageDialog


/*******************************************************************

    NAME:           REPL_MAIN_DIALOG :: AddNewTarget

    SYNOPSIS:       Adds a new export/import target to the appropriate
                    listbox.

    ENTRY:          plb                 - Points to either _lbExportTargets
                                          or _lbImportTargets;

                    ppb                 - Points to either _pbExportRemove
                                          or _pbImportRemove.  This is
                                          necessary to enable the remove
                                          button if the listbox becomes
                                          non empty.

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID REPL_MAIN_DIALOG :: AddNewTarget( REPL_MAIN_LISTBOX * plb,
                                       PUSH_BUTTON       * ppb )
{
    UIASSERT( plb != NULL );
    UIASSERT( ppb != NULL );

    APIERR  err;
    NLS_STR nlsTarget;
    BOOL    fGotTarget = FALSE;
    INT     iNewItem;

    //
    //  Ensure our NLS_STR constructed properly.
    //

    err = nlsTarget.QueryError();

    //
    //  Get the new target from the user.
    //

    if( err == NERR_Success )
    {
        STANDALONE_SET_FOCUS_DLG * pDlg =
                        new STANDALONE_SET_FOCUS_DLG( QueryHwnd(),
                                                      &nlsTarget,
                                                      HC_REPL_SETFOCUS_DIALOG,
                                                      SEL_SRV_AND_DOM,
                                                      BROWSE_LOCAL_DOMAINS );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fGotTarget );

        delete pDlg;
    }

    //
    //  Add the target to the appropriate listbox.
    //

    if( ( err == NERR_Success ) && fGotTarget )
    {
        ISTR istr( nlsTarget );

        if( nlsTarget.QueryChar( istr ) == L'\\' )
        {
            ++istr;
            UIASSERT( nlsTarget.QueryChar( istr ) == L'\\' );
            ++istr;
        }

        REPL_MAIN_LBI * plbi = new REPL_MAIN_LBI( nlsTarget.QueryPch( istr ) );

        iNewItem = plb->AddItemIdemp( plbi );

        if( iNewItem < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            plb->SelectItem( iNewItem );
            ppb->Enable( TRUE );
        }
    }

    //
    //  Report any errors which occurred.
    //

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

}   // REPL_MAIN_DIALOG :: AddNewTarget


/*******************************************************************

    NAME:           REPL_MAIN_DIALOG :: RemoveExistingTarget

    SYNOPSIS:       Removes an existing export/import target from the
                    appropriate listbox.

    ENTRY:          plb                 - Points to either _lbExportTargets
                                          or _lbImportTargets.

                    ppb                 - Points to either _pbExportRemove
                                          or _pbImportRemove.  This is
                                          necessary to grey the remove
                                          button if the listbox becomes
                                          empty.

                    idWarning           - The string resource ID of a
                                          warning message to be displayed
                                          before deleting the directory.

    HISTORY:
        KeithMo     19-Feb-1992     Created for the Server Manager.

********************************************************************/
VOID REPL_MAIN_DIALOG :: RemoveExistingTarget( REPL_MAIN_LISTBOX * plb,
                                               PUSH_BUTTON       * ppb,
                                               MSGID               idWarning )
{
    UIASSERT( plb != NULL );
    UIASSERT( ppb != NULL );

    //
    //  Retrieve the currently selected target.
    //

    REPL_MAIN_LBI * plbi = plb->QueryItem();
    UIASSERT( plbi != NULL );

    //
    //  Confirm the removal.
    //

    if( MsgPopup( this,
                  idWarning,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryTarget(),
                  MP_NO ) == IDYES )
    {
        INT iCurrent = plb->QueryCurrentItem();

        REQUIRE( plb->DeleteItem( iCurrent ) >= 0 );

        if( plb->QueryCount() > 0 )
        {
            if( iCurrent >= plb->QueryCount() )
            {
                iCurrent--;
            }

            plb->SelectItem( iCurrent );
        }

        ppb->Enable( plb->QuerySelCount() > 0 );
    }

}   // REPL_MAIN_DIALOG :: RemoveExistingTarget


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: DetermineCurrentRole

    SYNOPSIS:   This method will determine the current replicator
                role.

    ENTRY:      pRole                   - Will receive the current role.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     15-Jul-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: DetermineCurrentRole( ULONG * pRole )
{
    //
    //  Determine the replicator's current role.  If the service
    //  is not yet started, then return REPL_ROLE_NOT_RUNNING.
    //

    *pRole = REPL_ROLE_NOT_RUNNING;             // until proven otherwise...

    BOOL       fStarted;
    LM_SERVICE lmsvc( _pserver->QueryName(),
                      (const TCHAR *)SERVICE_REPL );

    APIERR err = lmsvc.QueryError();

    if( err == NERR_Success )
    {
        fStarted = lmsvc.IsStarted( &err );
    }

    if( ( err == NERR_Success ) && fStarted )
    {
        *pRole = _prepl->QueryRole();
    }

    return err;

}   // REPL_MAIN_DIALOG :: DetermineCurrentRole


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ReadLogonScriptOrSysvolPath

    SYNOPSIS:   This method will read the logon script path from
                the registry.

    ENTRY:      pnlsLogonScriptOrSysvolPath     - Pointer to an NLS_STR
                                          that will receive the
                                          logon script path.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     15-Jul-1992     Created for the Server Manager.
        DavidHov    20-Oct-1992     Remove call to obsolete
                                    REG_KEY::DestroyAccessPoints()
        KeithMo     09-Nov-1992     Use new & improved QueryValue method.
        JonN        06-Sup-1997     can have either Logon Script Path or System Volume

********************************************************************/
APIERR REPL_MAIN_DIALOG :: ReadLogonScriptOrSysvolPath( NLS_STR * pnlsLogonScriptOrSysvolPath )
{
    UIASSERT( _fIsLanmanNT );
    _fNeitherSysvolNorLogonScript = FALSE;
    _fSysvolNotLogonScript = FALSE;

    //
    //  Allocate a root REG_KEY object for the target server.
    //

    REG_KEY * pRootKey = new REG_KEY( HKEY_LOCAL_MACHINE,
                                     _pserver->QueryName() );

    APIERR err = ( pRootKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : pRootKey->QueryError();

    //
    //  Allocate a REG_KEY object for the specified key.
    //

    REG_KEY * pRegKey = NULL;
    ALIAS_STR nlsKeyName( pszLogonScriptOrSysvolPathKeyName );

    if( err == NERR_Success )
    {
        pRegKey = new REG_KEY( *pRootKey, nlsKeyName );

        err = ( pRegKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pRegKey->QueryError();
    }

    //
    //  Read the registry.
    //

    TCHAR                 szValue[MAX_PATH];
    REG_VALUE_INFO_STRUCT rvis;

    if( err == NERR_Success )
    {
        rvis.nlsValueName = pszLogonScriptPathValueName;
        rvis.ulTitle      = 0L;
        rvis.ulType       = 0L;
        rvis.pwcData      = (BYTE *)szValue;
        rvis.ulDataLength = sizeof(szValue);

        err = !rvis.nlsValueName ? rvis.nlsValueName.QueryError()
                                 : pRegKey->QueryValue( &rvis );

        //
        // If Logon Script is missing, try System Volume
        //
        if( err != NERR_Success )
        {
            _fSysvolNotLogonScript = TRUE;
            rvis.nlsValueName = pszSystemVolumePathValueName;
            rvis.ulTitle      = 0L;
            rvis.ulType       = 0L;
            rvis.pwcData      = (BYTE *)szValue;
            rvis.ulDataLength = sizeof(szValue);

            err = !rvis.nlsValueName ? rvis.nlsValueName.QueryError()
                                     : pRegKey->QueryValue( &rvis );
        }
    }


    if( err == NERR_Success )
    {
        szValue[rvis.ulDataLengthOut / sizeof(TCHAR)] = TCH('\0');

        err = pnlsLogonScriptOrSysvolPath->CopyFrom( szValue );
    }

    //
    //  Expand the %SystemRoot% environment variable.
    //

    if( err == NERR_Success )
    {
        err = ExpandSystemRoot( pnlsLogonScriptOrSysvolPath );
    }

    //
    // If neither can be retrieved, disable the edit field
    //
    _fNeitherSysvolNorLogonScript = (err != NERR_Success);

    //
    // Disable+hide either the Logon Script label or Sysvol label
    //
    _psltLogonScriptText->Show(   !_fNeitherSysvolNorLogonScript && !_fSysvolNotLogonScript );
    _psltLogonScriptText->Enable( !_fNeitherSysvolNorLogonScript && !_fSysvolNotLogonScript );
    _psltSysvolText->Show(        !_fNeitherSysvolNorLogonScript &&  _fSysvolNotLogonScript );
    _psltSysvolText->Enable(      !_fNeitherSysvolNorLogonScript &&  _fSysvolNotLogonScript );
    _psleLogonScriptOrSysvolPath->Show(   !_fNeitherSysvolNorLogonScript );
    _psleLogonScriptOrSysvolPath->Enable( !_fNeitherSysvolNorLogonScript );

    //
    //  Nuke our registry objects.
    //

    delete pRegKey;
    delete pRootKey;

    return NERR_Success;

}   // REPL_MAIN_DIALOG :: ReadLogonScriptOrSysvolPath

/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: WriteLogonScriptOrSysvolPath

    SYNOPSIS:   This method will write the logon script path to
                the registry.

    ENTRY:      pnlsLogonScriptOrSysvolPath     - Pointer to an NLS_STR
                                          that contains the new
                                          logon script path.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     15-Jul-1992     Created for the Server Manager.
        DavidHov    20-Oct-1992     Remove call to obsolete
                                    REG_KEY::DestroyAccessPoints()
        JonN        06-Sup-1997     can have either Logon Script Path or System Volume

********************************************************************/
APIERR REPL_MAIN_DIALOG :: WriteLogonScriptOrSysvolPath( NLS_STR * pnlsLogonScriptOrSysvolPath )
{
    UIASSERT( _fIsLanmanNT && !_fNeitherSysvolNorLogonScript );

    //
    //  Collapse the %SystemRoot% prefix.
    //

    APIERR err = CollapseSystemRoot( pnlsLogonScriptOrSysvolPath );

    //
    //  Allocate a root REG_KEY object for the target server.
    //

    REG_KEY * pRootKey = new REG_KEY( HKEY_LOCAL_MACHINE,
                                     _pserver->QueryName() );

    if( err == NERR_Success )
    {
        err = ( pRootKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : pRootKey->QueryError();
    }

    //
    //  Allocate a REG_KEY object for the specified key.
    //

    REG_KEY * pRegKey = NULL;
    ALIAS_STR nlsKeyName( pszLogonScriptOrSysvolPathKeyName );

    if( err == NERR_Success )
    {
        pRegKey = new REG_KEY( *pRootKey, nlsKeyName );

        err = ( pRegKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pRegKey->QueryError();
    }

    //
    //  Write to the registry.
    //

    if( err == NERR_Success )
    {
        err = pRegKey->SetValue( (_fSysvolNotLogonScript)
                                       ? pszSystemVolumePathValueName
                                       : pszLogonScriptPathValueName,
                                 pnlsLogonScriptOrSysvolPath,
                                 NULL,
                                 TRUE );
    }

    //
    //  Nuke our registry objects.
    //

    delete pRegKey;
    delete pRootKey;

    return err;

}   // REPL_MAIN_DIALOG :: WriteLogonScriptOrSysvolPath

/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: GetSystemRoot

    SYNOPSIS:   This method will determine the value of %SystemRoot%
                for the target server, storing the path into the
                _nlsSystemRoot member.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     18-Jan-1993     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: GetSystemRoot( VOID )
{
    UIASSERT( _fIsLanmanNT );

    //
    //  Allocate a root REG_KEY object for the target server.
    //

    REG_KEY * pRootKey = new REG_KEY( HKEY_LOCAL_MACHINE,
                                      _pserver->QueryName() );

    APIERR err = ( pRootKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : pRootKey->QueryError();

    //
    //  Allocate a REG_KEY object for the specified key.
    //

    REG_KEY * pRegKey = NULL;
    ALIAS_STR nlsKeyName( pszSystemRootKeyName );
    UIASSERT( !!nlsKeyName );

    if( err == NERR_Success )
    {
        pRegKey = new REG_KEY( *pRootKey, nlsKeyName );

        err = ( pRegKey == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pRegKey->QueryError();
    }

    //
    //  Read the registry.
    //

    if( err == NERR_Success )
    {
        err = pRegKey->QueryValue( pszSystemRootValueName,
                                   &_nlsSystemRoot );
    }

    //
    //  Nuke our registry objects.
    //

    delete pRegKey;
    delete pRootKey;

    return err;

}   // REPL_MAIN_DIALOG :: GetSystemRoot


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: ExpandSystemRoot

    SYNOPSIS:   This method will expand the %SystemRoot% environment
                variable within the given path string.

    ENTRY:      pnlsPath                - Pointer to an NLS_STR
                                          that contains the path.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     18-Jan-1993     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: ExpandSystemRoot( NLS_STR * pnlsPath )
{
    UIASSERT( pnlsPath != NULL );
    UIASSERT( pnlsPath->QueryError() == NERR_Success );

    //
    //  First determine if the path begins with %SystemRoot%.
    //

    UINT   cchEnvVar = ::strlenf( pszSystemRootEnvVar );
    UINT   cchPath   = pnlsPath->QueryTextLength();
    APIERR err       = NERR_Success;

    if( ( cchPath >= cchEnvVar ) &&
        ( ::strnicmpf( pnlsPath->QueryPch(),
                       pszSystemRootEnvVar,
                       cchEnvVar ) == 0 ) )
    {
        //
        //  Replace %SystemRoot% with the actual system root path.
        //

        ISTR istrStart( *pnlsPath );
        ISTR istrEnd( *pnlsPath );

        istrEnd += cchEnvVar;

        pnlsPath->ReplSubStr( _nlsSystemRoot, istrStart, istrEnd );

        //
        //  ReplSubStr may leave the string in an error state.
        //

        err = pnlsPath->QueryError();

        if( err == NERR_Success )
        {
            //
            //  %SystemRoot% replaced, guard against doubled
            //  backslashes.
            //

            UINT cchRoot = _nlsSystemRoot.QueryTextLength();

            if( cchRoot > 0 )
            {
                ISTR istrWhackStart( *pnlsPath );
                ISTR istrWhackStop( *pnlsPath );

                istrWhackStart += (INT)( cchRoot - 1 );
                istrWhackStop  += (INT)cchRoot;

                if( ( pnlsPath->QueryChar( istrWhackStart ) == L'\\' ) &&
                    ( pnlsPath->QueryChar( istrWhackStop  ) == L'\\' ) )
                {
                    //
                    //  Double backslashes.  Fix 'em.
                    //

                    pnlsPath->DelSubStr( istrWhackStart, istrWhackStop );
                }
            }
        }
    }

    return err;

}   // REPL_MAIN_DIALOG :: ExpandSystemRoot


/*******************************************************************

    NAME:       REPL_MAIN_DIALOG :: CollapseSystemRoot

    SYNOPSIS:   This method will collapse the %SystemRoot% environment
                variable within the given path string.

    ENTRY:      pnlsPath                - Pointer to an NLS_STR
                                          that contains the path.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     18-Jan-1993     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_DIALOG :: CollapseSystemRoot( NLS_STR * pnlsPath )
{
    UIASSERT( pnlsPath != NULL );
    UIASSERT( pnlsPath->QueryError() == NERR_Success );

    //
    //  First determine if the path begins with %SystemRoot%.
    //

    UINT   cchRoot   = _nlsSystemRoot.QueryTextLength();
    UINT   cchPath   = pnlsPath->QueryTextLength();
    APIERR err       = NERR_Success;

    if( ( cchPath >= cchRoot ) &&
        ( ::strnicmpf( pnlsPath->QueryPch(),
                       _nlsSystemRoot.QueryPch(),
                       cchRoot ) == 0 ) )
    {
        //
        //  The character immediately following %SystemRoot% (if any)
        //  *must* be a backslash.
        //

        ISTR istrStart( *pnlsPath );
        ISTR istrEnd( *pnlsPath );

        istrEnd += cchRoot;

        WCHAR wchEnd = pnlsPath->QueryChar( istrEnd );

        if( ( wchEnd == L'\0' ) || ( wchEnd == L'\\' ) )
        {
            //
            //  Collapse the path.
            //

            ALIAS_STR nlsEnvVar( pszSystemRootEnvVar );
            UIASSERT( !!nlsEnvVar );

            pnlsPath->ReplSubStr( nlsEnvVar, istrStart, istrEnd );

            //
            //  ReplSubStr may leave the string in an error state.
            //

            err = pnlsPath->QueryError();
        }
    }

    return err;

}   // REPL_MAIN_DIALOG :: CollapseSystemRoot



//
//  REPL_MAIN_LISTBOX methods
//

/*******************************************************************

    NAME:           REPL_MAIN_LISTBOX :: REPL_MAIN_LISTBOX

    SYNOPSIS:       REPL_MAIN_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_MAIN_LISTBOX :: REPL_MAIN_LISTBOX( OWNER_WINDOW * powner,
                                        CID            cid )
  : BLT_LISTBOX( powner, cid )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     REPL_MAIN_LISTBOX_COLUMNS,
                                     powner,
                                     cid,
                                     FALSE );

}   // REPL_MAIN_LISTBOX :: REPL_MAIN_LISTBOX


/*******************************************************************

    NAME:           REPL_MAIN_LISTBOX :: ~REPL_MAIN_LISTBOX

    SYNOPSIS:       REPL_MAIN_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
REPL_MAIN_LISTBOX :: ~REPL_MAIN_LISTBOX( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_MAIN_LISTBOX :: ~REPL_MAIN_LISTBOX


/*******************************************************************

    NAME:           REPL_MAIN_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    ENTRY:          pstrlst             - Points to a STRLIST that
                                          contains a semi-colon separated
                                          list of domains & servers.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
APIERR REPL_MAIN_LISTBOX :: Fill( STRLIST * pstrlst )
{
    UIASSERT( pstrlst != NULL );

    //
    //  Create our iterator.
    //

    ITER_STRLIST iter( *pstrlst );
    NLS_STR * pnls;

    //
    //  Disable listbox redraw, then nuke its contents.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  Scan the STRLIST, adding its contents to the listbox.
    //

    APIERR err = NERR_Success;

    while( ( pnls = iter.Next() ) != NULL )
    {
        REPL_MAIN_LBI * plbi = new REPL_MAIN_LBI( pnls->QueryPch() );

        if( AddItem( plbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    }

    //
    //  Select the first item.
    //

    if( QueryCount() > 0 )
    {
        SelectItem( 0 );
    }

    //
    //  Enable redraw, then force a repaint.
    //

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // REPL_MAIN_LISTBOX :: Fill



//
//  REPL_MAIN_LBI methods
//

/*******************************************************************

    NAME:           REPL_MAIN_LBI :: REPL_MAIN_LBI

    SYNOPSIS:       REPL_MAIN_LBI class constructor.

    ENTRY:          pszTarget           - The name of the target entity.  This
                                          will be either a server name or a
                                          domain name in either the export
                                          list or the import list.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_MAIN_LBI :: REPL_MAIN_LBI( const TCHAR * pszTarget )
  : _nlsTarget( pszTarget )
{
    UIASSERT( pszTarget != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsTarget )
    {
        ReportError( _nlsTarget.QueryError() );
        return;
    }

}   // REPL_MAIN_LBI :: REPL_MAIN_LBI


/*******************************************************************

    NAME:           REPL_MAIN_LBI :: ~REPL_MAIN_LBI

    SYNOPSIS:       REPL_MAIN_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
REPL_MAIN_LBI :: ~REPL_MAIN_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_MAIN_LBI :: ~REPL_MAIN_LBI


/*******************************************************************

    NAME:           REPL_MAIN_LBI :: Paint

    SYNOPSIS:       Draw an entry in REPL_MAIN_LISTBOX.

    ENTRY:          plb                 - Pointer to a LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.
        beng        22-Apr-1992     Changes to LBI::Paint

********************************************************************/
VOID REPL_MAIN_LBI :: Paint( LISTBOX      * plb,
                             HDC            hdc,
                             const RECT   * prect,
                             GUILTT_INFO  * pGUILTT ) const
{
    STR_DTE dteTarget( _nlsTarget.QueryPch() );

    DISPLAY_TABLE dtab( REPL_MAIN_LISTBOX_COLUMNS,
                        ((REPL_MAIN_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteTarget;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // REPL_MAIN_LBI :: Paint


/*******************************************************************

    NAME:       REPL_MAIN_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
WCHAR REPL_MAIN_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsTarget );

    return _nlsTarget.QueryChar( istr );

}   // REPL_MAIN_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       REPL_MAIN_LBI :: Compare

    SYNOPSIS:   Compare two REPL_MAIN_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     06-Feb-1992     Created for the Server Manager.

********************************************************************/
INT REPL_MAIN_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsTarget._stricmp( ((const REPL_MAIN_LBI *)plbi)->_nlsTarget );

}   // REPL_MAIN_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\resync.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    resync.cxx
    This file contains the class definitions for the RESYNC_DIALOG
    class.

    The RESYNC_DIALOG class is used to resync a given server with
    its Primary.


    FILE HISTORY:
        KeithMo     05-Nov-1991 Created.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"

#include <resync.hxx>


//
//  RESYNC_DIALOG methods.
//

#define RESYNC_POLLING_INTERVAL  1000

/*******************************************************************

    NAME:       RESYNC_DIALOG :: RESYNC_DIALOG

    SYNOPSIS:   RESYNC_DIALOG class constructor.

    ENTRY:      hWndOwner               - Handle to the owning window.

                pszDomainName           - The domain name.

                pszServerName           - The name of the server that
                                          needs to resync with its Primary.

                fIsNtDomain             - TRUE is this is an NT domain.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     05-Nov-1991 Created.

********************************************************************/
RESYNC_DIALOG :: RESYNC_DIALOG( HWND          hWndOwner,
                                const TCHAR * pszDomainName,
                                const TCHAR * pszServerName,
                                BOOL          fIsNtDomain )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_RESYNC_DIALOG ), hWndOwner ),
    _domain( pszDomainName, fIsNtDomain ),
    _timer( this, RESYNC_POLLING_INTERVAL, FALSE ),
    _slt1( this, IDRD_MESSAGE1 ),
    _slt2( this, IDRD_MESSAGE2 ),
    _slt3( this, IDRD_MESSAGE3 ),
    _progress( this, IDRD_PROGRESS, IDI_PROGRESS_ICON_0, IDI_PROGRESS_NUM_ICONS ),
    _menuClose( this, SC_CLOSE )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( pszServerName != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _domain.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Disable the "Close" item in the system menu.
    //

    _menuClose.Enable( FALSE );

    //
    //  Initiate the resync.
    //

    const ALIAS_STR nlsNameWithoutPrefix( pszServerName );
    UIASSERT( nlsNameWithoutPrefix.QueryError() == NERR_Success );

    NLS_STR nlsNameWithPrefix( SZ("\\\\") );

    err = nlsNameWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    nlsNameWithPrefix.strcat( nlsNameWithoutPrefix );

    err = nlsNameWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  This may take a while...
    //

    AUTO_CURSOR cursor;

    err = _domain.ResyncServer( this,
                                nlsNameWithPrefix,
                                RESYNC_POLLING_INTERVAL );

    if( err != DOMAIN_STATUS_PENDING )
    {
        ReportError( err );
        return;
    }

    //
    //  Now that everything is setup, we can enable our timer.
    //

    _timer.Enable( TRUE );

}   // RESYNC_DIALOG :: RESYNC_DIALOG


/*******************************************************************

    NAME:       RESYNC_DIALOG :: ~RESYNC_DIALOG

    SYNOPSIS:   RESYNC_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     05-Nov-1991 Created.

********************************************************************/
RESYNC_DIALOG :: ~RESYNC_DIALOG()
{
    //
    //  This space intentionally left blank.
    //

}   // RESYNC_DIALOG :: ~RESYNC_DIALOG


/*******************************************************************

    NAME:       RESYNC_DIALOG :: OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        KeithMo     05-Nov-1991 Created.

********************************************************************/
VOID RESYNC_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
    }

    //
    //  Check the ResyncServer() progress.
    //

    APIERR err = _domain.Poll( this );

    if( err != DOMAIN_STATUS_PENDING )
    {
        Dismiss( err );
    }

}   // RESYNC_DIALOG :: OnTimerNotification


/*******************************************************************

    NAME:       RESYNC_DIALOG :: Notify

    SYNOPSIS:   Notify the user that either a milestone was reached
                or an error has occurred.

    ENTRY:      err                     - The error code.  Will be
                                          NERR_Success if this is
                                          a milestone notification.

                action                  - An ACTIONCODE, specifying
                                          the type of operation
                                          being performed.

                pszParam1               - First parameter (always
                                          a target server name).

                pszParam2               - Second parameter (either a
                                          role name or service name).

    HISTORY:
        KeithMo     05-Nov-1991 Created.

********************************************************************/
VOID RESYNC_DIALOG :: Notify( APIERR        err,
                              ACTIONCODE    action,
                              const TCHAR * pszParam1,
                              const TCHAR * pszParam2 )
{
    UIASSERT( action > AC_First );
    UIASSERT( action < AC_Last  );

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  Display the notification.
    //

    ALIAS_STR nlsServer( pszParam1+2 );
    ALIAS_STR nlsParam2( SZ("") );

    if( pszParam2 != NULL )
    {
        nlsParam2 = pszParam2;
    }

    const NLS_STR * apnlsParams[3];

    apnlsParams[0] = &nlsServer;
    apnlsParams[1] = &nlsParam2;
    apnlsParams[2] = NULL;

    NLS_STR nlsMsg;

    nlsMsg.Load( IDS_AC_RESYNCING + (INT)action - 1 );
    nlsMsg.InsertParams( apnlsParams );

    _slt2.SetText( nlsMsg.QueryPch() );

    if( err != NERR_Success )
    {
        DisplayGenericError( this,
                             IDS_DOMAIN_RESYNC_ERROR + (INT)action - 1,
                             err,
                             nlsServer,
                             nlsParam2 );
    }

}   // RESYNC_DIALOG :: Notify


/*******************************************************************

    NAME:       RESYNC_DIALOG :: Warning

    SYNOPSIS:   Warn the user of potential error conditions.

    ENTRY:      warning                 - A WARNINGCODE which specifies
                                          the type of warning being
                                          presented.

    RETURN:     BOOL                    - TRUE if it is safe to continue
                                          the domain role transition.

                                          FALSE if the role transition
                                          should be aborted.

    HISTORY:
        KeithMo     04-Oct-1991 Created.

********************************************************************/
BOOL RESYNC_DIALOG :: Warning( WARNINGCODE warning )
{
    UIASSERT( warning > WC_First );
    UIASSERT( warning < WC_Last  );

    //
    //  This callback may get invoked during the initial
    //  setup for the promotion operation.  Therefore,
    //  we must ensure that the current cursor is an arrow.
    //

    AUTO_CURSOR Cursor( IDC_ARROW );

    switch( warning )
    {
    case WC_CannotFindPrimary :
        if( MsgPopup( this,
                      IDS_WARN_NO_PDC,
                      MPSEV_WARNING,
                      MP_OKCANCEL,
                      _domain.QueryName() ) == IDOK )
        {
            return TRUE;
        }
        break;

    default:
        UIASSERT( 0 );
        break;
    }

    //
    //  If we've made it this far, then we'll abort the promotion.
    //

    return FALSE;

}   // RESYNC_DIALOG :: Warning
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\sessions.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    users.cxx
    Class declarations for the SESSIONS_DIALOG, SESSIONS_LISTBOX, and
    SESSIONS_LBI classes.

    These classes implement the Server Manager Users subproperty
    sheet.  The SESSIONS_LISTBOX/SESSIONS_LBI classes implement the listbox
    which shows the connected users.  SESSIONS_DIALOG implements the
    actual dialog box.


    FILE HISTORY:
        KevinL      11-Aug-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <lmoenum.hxx>
#include <lmosrv.hxx>
#include <lmoesess.hxx>
#include <lmoeconn.hxx>
#include <lmsrvres.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C" {

#include <srvmgr.h>

}   // extern "C"

#include <bltnslt.hxx>
#include <sessions.hxx>
#include <lmoersm.hxx>
#include <opendlg.hxx>


//
//  Only do a full refresh of the dialog (especially the
//  sessions listbox) if the number of active sessions
//  to the server is LESS than this constant.
//

#define MAX_REFRESH_SESSIONS    100


//
//  SESSIONS_DIALOG methods
//

/*******************************************************************

    NAME:           SESSIONS_DIALOG :: SESSIONS_DIALOG

    SYNOPSIS:       SESSIONS_DIALOG class constructor.

    ENTRY:          hWndOwner       - The owning window.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      04-Aug-1991 Created.
        KeithMo     22-Sep-1991 Set the dialog caption to "User
                                Connections on FOO".

********************************************************************/
SESSIONS_DIALOG :: SESSIONS_DIALOG( HWND       hWndOwner,
                                    SERVER_2 * pserver )
  : SRV_BASE_DIALOG( MAKEINTRESOURCE( IDD_USER_CONNECTIONS ), hWndOwner ),
    _sltUsersConnected( this, IDUC_USERS_CONNECTED ),
    _pbDisc( this, ID_DISCONNECT ),
    _pbDiscAll( this, ID_DISCONNECT_ALL ),
    _pbClose( this, IDOK ),
#ifdef SRVMGR_REFRESH
    _pbRefresh( this, IDDUC_REFRESH ),
#endif
    _nlsParamUnknown( IDS_SESSIONS_PARAM_UNKNOWN ),
    _lbUsers( this, IDDUC_USER_CONNLIST, pserver ),
    _lbResources( this, IDDUC_RESOURCE_LIST, pserver ),
    _pServer( pserver )

{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "SESSIONS_DIALOG :: SESSIONS_DIALOG Failed!" );
        return;
    }

    //
    //  Set the caption.
    //

    STACK_NLS_STR( nlsDisplayName, MAX_PATH + 1 );
    REQUIRE( _pServer->QueryDisplayName( &nlsDisplayName ) == NERR_Success );

    APIERR err = SetCaption( this,
                             IDS_CAPTION_USERS,
                             nlsDisplayName );

    if (err == NERR_Success)
        err = _nlsParamUnknown.QueryError();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Fill the users Listbox.
    //

    err = Refresh();

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // SESSIONS_DIALOG :: SESSIONS_DIALOG


/*******************************************************************

    NAME:       SESSIONS_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    ENTRY:      fForced                 - TRUE if this is a forced
                                          (unconditional) refresh.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:

********************************************************************/
APIERR SESSIONS_DIALOG :: Refresh( BOOL fForced )
{

    //
    //  Otherwise the two listbox refreshes cause the cursor to flash
    //
    AUTO_CURSOR Cursor;

    //
    //  Remember the currently selection item & top index.
    //

    INT iCurrent = _lbUsers.QueryCurrentItem();
    INT iTopItem = _lbUsers.QueryTopIndex();

    //
    //  Determine if we can do a full refresh.
    //

    BOOL fFullRefresh = ( _lbUsers.QueryCount() < MAX_REFRESH_SESSIONS ) ||
                        fForced;

    //
    //  We'll use these to restore the current (if any) selection.
    //

    NLS_STR nlsUser;
    NLS_STR nlsComputer;

    APIERR err = nlsUser.QueryError();
    err = err ? err : nlsComputer.QueryError();

    if( ( err == NERR_Success ) && ( _lbUsers.QuerySelCount() > 0 ) )
    {
        //
        //  Retrieve the currently selected user & computer.
        //

        SESSIONS_LBI * plbi = _lbUsers.QueryItem();
        UIASSERT( plbi != NULL );

        err = nlsUser.CopyFrom( plbi->QueryUserName() );
        err = err ? err : nlsComputer.CopyFrom( plbi->QueryComputerName() );
    }

    if( fFullRefresh && ( err == NERR_Success ) )
    {
        //
        //  Fill the listbox.
        //

        err = _lbUsers.Fill();
    }

    if( fFullRefresh && ( err == NERR_Success ) )
    {
        //
        //  Only try to maintain selection if there's anything
        //  left in the listbox...
        //

        INT cItems = _lbUsers.QueryCount();

        if( cItems > 0 )
        {
            INT iSel = -1;      // until proven otherwise...

            if( ( iCurrent >= 0 ) && ( iCurrent < cItems ) )
            {
                //
                //  iCurrent is still valid.  Let's see if the item
                //  at this index matches the pre-refresh value.
                //

                SESSIONS_LBI * plbi = _lbUsers.QueryItem( iCurrent );
                UIASSERT( plbi != NULL );

                if( !::stricmpf( plbi->QueryUserName(), nlsUser ) &&
                    !::stricmpf( plbi->QueryComputerName(), nlsComputer ) )
                {
                    iSel = iCurrent;
                }
            }

            if( iSel < 0 )
            {
                //
                //  Either iCurrent was out of range, or the item
                //  does not match.  Search for it.
                //

                for( INT i = 0 ; i < cItems ; i++ )
                {
                    SESSIONS_LBI * plbi = _lbUsers.QueryItem( i );
                    UIASSERT( plbi != NULL );

                    if( !::stricmpf( plbi->QueryUserName(), nlsUser ) &&
                        !::stricmpf( plbi->QueryComputerName(), nlsComputer ) )
                    {
                        iSel = i;
                        break;
                    }
                }
            }

            if( iSel < 0 )
            {
                //
                //  No selection found, default = first item.
                //

                iSel = 0;
            }

            if( ( iTopItem < 0 ) ||  ( iTopItem >= cItems ) )
            {
                //
                //  The previous top index was out of range,
                //  default = first item.
                //

                iTopItem = 0;
            }

            _lbUsers.SetTopIndex( iTopItem );
            _lbUsers.SelectItem( iSel );
        }
    }

    if( err == NERR_Success )
    {
        if ( _lbUsers.QuerySelCount() > 0 )
        {
            SESSIONS_LBI * plbi = _lbUsers.QueryItem();
            UIASSERT( plbi != NULL );

            err = _lbResources.Fill( plbi->QueryComputerName() );
        }
        else
        {
            _lbResources.DeleteAllItems();
            _lbResources.Invalidate( TRUE );
        }
    }

    if( err != NERR_Success )
    {
        _lbUsers.DeleteAllItems();
        _lbUsers.Invalidate( TRUE );
        _lbResources.DeleteAllItems();
        _lbResources.Invalidate( TRUE );
        _sltUsersConnected.SetText( _nlsParamUnknown.QueryError() );
        _sltUsersConnected.Enable( FALSE );
    }
    else
    {
        _sltUsersConnected.Enable( TRUE );
        _sltUsersConnected.SetValue( _lbUsers.QueryCount() );
    }

    if( _lbUsers.QuerySelCount() > 0 )
    {
        _pbDisc.Enable( TRUE );
    }
    else
    {
        if( _pbDisc.HasFocus() )
        {
            SetDialogFocus( _pbClose );
        }

        _pbDisc.Enable( FALSE );
    }

    if( _lbUsers.QueryCount() > 0 )
    {
        _pbDiscAll.Enable( TRUE );
    }
    else
    {
        if( _pbDiscAll.HasFocus() )
        {
            SetDialogFocus( _pbClose );
        }

        _pbDiscAll.Enable( FALSE );
    }

    return err;

}   // SESSIONS_DIALOG :: Refresh


/*******************************************************************

    NAME:           SESSIONS_DIALOG :: OnCommand

    SYNOPSIS:       Handle user commands.

    ENTRY:          cid                 - Control ID.
                    lParam              - lParam from the message.

    EXIT:           None.

    RETURNS:        BOOL                - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    NOTES:

    HISTORY:
        KevinL      04-Aug-1991 Created.
        KeithMo     06-Oct-1991 Now takes a CONTROL_EVENT.

********************************************************************/
BOOL SESSIONS_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    if( event.QueryCid() == _lbUsers.QueryCid() )
    {
        //
        //  The SESSIONS_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in the SESSIONS_LISTBOX.
            //

            (void) Refresh( FALSE );
        }

        return TRUE;
    }

#ifdef SRVMGR_REFRESH
    if( event.QueryCid() == _pbRefresh.QueryCid() )
    {
        (void) Refresh();

        return TRUE;
    }
#endif

    if( event.QueryCid() == _pbDisc.QueryCid() )
    {
        //
        //  The user pressed the Disconnect button.  Blow off the
        //  selected user.
        //

        SESSIONS_LBI * plbi = _lbUsers.QueryItem();
        UIASSERT( plbi != NULL );

        // JonN 01/28/00: PREFIX bug 444936
        MSGID idMsg = ( plbi && plbi->QueryNumOpens() > 0 )
            ? IDS_DISCONNECT_USER_OPEN
            : IDS_DISCONNECT_USER;

        const TCHAR * pszApiUser     = plbi->QueryUserName();
        const TCHAR * pszApiComputer = plbi->QueryComputerName();

        const TCHAR * pszUser = pszApiUser;

        if( ( pszApiUser == NULL ) || ( *pszApiUser == TCH('\0') ) )
        {
            pszUser = pszApiComputer;
            pszApiUser = NULL;
            idMsg += 10; // use IDS_DISCONNECT_COMPUTER[_OPEN]
        }

        if ( MsgPopup( this,
                       idMsg,
                       MPSEV_WARNING,
                       MP_YESNO,
                       pszUser,
                       pszApiComputer,
                       MP_NO ) == IDYES )
        {
            AUTO_CURSOR Cursor;

            //
            //  Blow off the user.
            //

            APIERR err = LM_SRVRES::NukeUsersSession( _pServer->QueryName(),
                                                      pszApiComputer,
                                                      pszApiUser );

            if( err != NERR_Success )
            {
                //
                //  The session delete failed.  Tell the user the bad news.
                //

                MsgPopup( this, err );
            }

            //
            //  Refresh the dialog.
            //

            (void) Refresh();

        }

        return TRUE;
    }

    if( event.QueryCid() == _pbDiscAll.QueryCid() )
    {
        //
        //  The user pressed the Disconnect All button.  Blow off the
        //  users.
        //

        STACK_NLS_STR( nlsDisplayName, MAX_PATH + 1 );
        REQUIRE( _pServer->QueryDisplayName( &nlsDisplayName ) == NERR_Success );

        if ( MsgPopup( this,
                       ( _lbUsers.AreResourcesOpen() ) ? IDS_DISCONNECT_USERS_OPEN
                                                       : IDS_DISCONNECT_USERS,
                       MPSEV_WARNING,
                       MP_YESNO,
                       nlsDisplayName,
                       MP_NO ) == IDYES )
        {

            AUTO_CURSOR Cursor;

            SESSIONS_LBI * plbi;
            INT clbe = _lbUsers.QueryCount();                   // How many items?

            for (INT i = 0; i < clbe; i++)
            {
                plbi = _lbUsers.QueryItem( i ); // Get the lbi

                UIASSERT( plbi != NULL );

                const TCHAR * pszApiUser     = plbi->QueryUserName();
                const TCHAR * pszApiComputer = plbi->QueryComputerName();

                if( ( pszApiUser == NULL ) || ( *pszApiUser == TCH('\0') ) )
                {
                    pszApiUser = NULL;
                }

                //
                //  Blow off the user.
                //

                APIERR err =
                    LM_SRVRES::NukeUsersSession( _pServer->QueryName(),
                                                 pszApiComputer,
                                                 pszApiUser );

                if( err != NERR_Success )
                {
                    //
                    //  The session delete failed.  Tell the user the bad news.
                    //

                    Cursor.TurnOff();
                    MsgPopup( this, err );
                    Cursor.TurnOn();
                }

            }

            //
            //  Kill the Resource Listbox.
            //

            _lbResources.DeleteAllItems();
            _lbResources.Invalidate( TRUE );

            //
            //  Refresh the dialog.
            //

            (void) Refresh();

        }
        return TRUE;
    }


    return SRV_BASE_DIALOG :: OnCommand( event );

}   // SESSIONS_DIALOG :: OnCommand


/*******************************************************************

    NAME:       SESSIONS_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     05-Jun-1992 Created.

********************************************************************/
ULONG SESSIONS_DIALOG :: QueryHelpContext( void )
{
    return HC_SESSIONS_DIALOG;

}   // SESSIONS_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:           SESSIONS_LISTBOX :: SESSIONS_LISTBOX

    SYNOPSIS:       SESSIONS_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.
        KeithMo     14-Oct-1991         Validate construction, use
                                        INTL_PROFILE to get time separator.

********************************************************************/
SESSIONS_LISTBOX :: SESSIONS_LISTBOX( OWNER_WINDOW * powner,
                                       CID             cid,
                                       SERVER_2     * pserver )
  : BLT_LISTBOX( powner, cid ),
    _pserver( pserver ),
    _nlsYes( IDS_YES ),
    _nlsNo( IDS_NO )

{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsYes )
    {
        ReportError( _nlsYes.QueryError() );
        return;
    }

    if( !_nlsNo )
    {
        ReportError( _nlsNo.QueryError() );
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;

    if( !nlsTimeSep )
    {
        ReportError( nlsTimeSep.QueryError() );
        return;
    }

    INTL_PROFILE intl;

    if( !intl )
    {
        ReportError( intl.QueryError() );
        return;
    }

    APIERR err = intl.QueryTimeSeparator( &nlsTimeSep );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     7,
                                     powner,
                                     cid,
                                     TRUE) ;
}   // SESSIONS_LISTBOX :: SESSIONS_LISTBOX


/*******************************************************************

    NAME:           SESSIONS_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available sharepoints.

    ENTRY:          None.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
APIERR SESSIONS_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //
    AUTO_CURSOR Cursor;


    SetRedraw( FALSE );
    DeleteAllItems();

    /*
     * enumerate all sessions
     */
    SESSION1_ENUM enumSession1( (TCHAR *) _pserver->QueryName() );
    APIERR err = enumSession1.GetInfo();

    if( err != NERR_Success )
    {
        return ( err ) ;
    }

    /*
     *  We've got our enumeration, now find all users
     */
    SESSION1_ENUM_ITER iterSession1( enumSession1 );
    const SESSION1_ENUM_OBJ * psi1;


    while( ( err == NERR_Success ) && ( ( psi1 = iterSession1() ) != NULL ) )
    {
        SESSIONS_LBI * pulbi = new SESSIONS_LBI( psi1->QueryUserName(),
                                                 psi1->QueryComputerName(),
                                                 psi1->QueryNumOpens(),
                                                 psi1->QueryTime(),
                                                 psi1->QueryIdleTime(),
                                                 (psi1->QueryUserFlags() & SESS_GUEST) ?
                                                 _nlsYes.QueryPch() : _nlsNo.QueryPch(),
                                                 _chTimeSep );

        if( AddItem( pulbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }

    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    //
    //  Success!
    //

    return NERR_Success;

}   // SESSIONS_LISTBOX :: Fill


/*******************************************************************

    NAME:       SESSIONS_LISTBOX :: AreResourcesOpen

    SYNOPSIS:   Returns TRUE if any user in the listbox has any
                resources open.

    RETURNS:    BOOL

    HISTORY:
        KeithMo     01-Apr-1992 Created.

********************************************************************/
BOOL SESSIONS_LISTBOX :: AreResourcesOpen( VOID ) const
{
    INT cItems = QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        SESSIONS_LBI * plbi = QueryItem( i );

        if( plbi && plbi->QueryNumOpens() > 0 ) // JonN 01/28/00: PREFIX bug 444935
        {
            return TRUE;
        }
    }

    return FALSE;

}   // SESSIONS_LISTBOX :: AreResourcesOpen


/*******************************************************************

    NAME:           SESSIONS_LBI :: SESSIONS_LBI

    SYNOPSIS:       SESSIONS_LBI class constructor.

    ENTRY:          pszShareName        - The sharepoint name.

                    pszPath             - The path for this sharepoint.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.
        KeithMo     24-Sep-1991         Removed seconds from time.
        KeithMo     23-Mar-1992         Cleanup, use DEC_STR & ELAPSED_TIME_STR.

********************************************************************/
SESSIONS_LBI :: SESSIONS_LBI( const TCHAR * pszUserName,
                              const TCHAR * pszComputerName,
                              ULONG         cOpens,
                              ULONG         ulTime,
                              ULONG         ulIdle,
                              const TCHAR * pszGuest,
                              TCHAR         chTimeSep ) :
    _dteIcon( IDBM_LB_USER ),
    _nlsUserName( pszUserName ),
    _nlsComputerName( pszComputerName ),
    _sdteGuest( pszGuest ),
    _nlsOpens( CCH_LONG ),
    _nlsTime( CCH_LONG ),
    _nlsIdle( CCH_LONG ),
    _cOpens( cOpens ),
    _nTime( ulTime ),
    _nIdleTime( ulIdle ),
    _chTimeSep( chTimeSep )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsOpens.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsIdle.QueryError()   ) != NERR_Success ) ||
        ( ( err = SetNumOpens( cOpens )   ) != NERR_Success ) ||
        ( ( err = SetTime( ulTime, ulIdle ) != NERR_Success ) ) )
    {
        ReportError( err );
        return;
    }

}   // SESSIONS_LBI :: SESSIONS_LBI


/*******************************************************************

    NAME:           SESSIONS_LBI :: ~SESSIONS_LBI

    SYNOPSIS:       SESSIONS_LBI class destructor.

    ENTRY:          None.

    EXIT:           The object is destroyed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
SESSIONS_LBI :: ~SESSIONS_LBI()
{

}   // SESSIONS_LBI :: ~SESSIONS_LBI


/*******************************************************************

    NAME:           SESSIONS_LBI :: SetNumOpens

    SYNOPSIS:       Sets the number of opens for this entry.

    ENTRY:          cOpens              - The number of open resources.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     05-Oct-1992 Created.

********************************************************************/
APIERR SESSIONS_LBI :: SetNumOpens( ULONG cOpens )
{
    DEC_STR nls( cOpens );

    APIERR err = nls.QueryError();

    if( err == NERR_Success )
    {
        _nlsOpens.CopyFrom( nls );
    }

    return err;

}   // SESSIONS_LBI :: SetNumOpens


/*******************************************************************

    NAME:           SESSIONS_LBI :: SetTime

    SYNOPSIS:       Sets the connect & idle time for this entry.

    ENTRY:          nTime               - Connect time.

                    nIdle               - Idle time.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     05-Oct-1992 Created.

********************************************************************/
APIERR SESSIONS_LBI :: SetTime( ULONG nTime, ULONG nIdle )
{
    ELAPSED_TIME_STR nlsTime( nTime, _chTimeSep );
    ELAPSED_TIME_STR nlsIdle( nIdle, _chTimeSep );

    APIERR err = nlsTime.QueryError();

    if( err == NERR_Success )
    {
        err = nlsIdle.QueryError();
    }

    if( err == NERR_Success )
    {
        err = _nlsTime.CopyFrom( nlsTime );
    }

    if( err == NERR_Success )
    {
        err = _nlsIdle.CopyFrom( nlsIdle );
    }

    return err;

}   // SESSIONS_LBI :: SetTime


/*******************************************************************

    NAME:           SESSIONS_LBI :: Paint

    SYNOPSIS:       Draw an entry in SESSIONS_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.
                    hdc                 - The DC to draw upon.
                    prect               - Clipping rectangle.
                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991 Created.
        KeithMo     06-Oct-1991 Now takes a const RECT *.
        beng        22-Apr-1992 Changes to LBI::Paint

********************************************************************/
VOID SESSIONS_LBI :: Paint( LISTBOX *        plb,
                            HDC              hdc,
                            const RECT     * prect,
                            GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE     dteUserName( _nlsUserName.QueryPch() );
    STR_DTE     dteComputerName( _nlsComputerName.QueryPch() );
    STR_DTE     dteOpens( _nlsOpens.QueryPch() );
    STR_DTE     dteTime( _nlsTime.QueryPch() );
    STR_DTE     dteIdle( _nlsIdle.QueryPch() );

    DISPLAY_TABLE dtab( 7, ( (SESSIONS_LISTBOX *)plb )->QueryColumnWidths() );

    dtab[0] = (DMID_DTE *) &_dteIcon;
    dtab[1] = &dteUserName;
    dtab[2] = &dteComputerName;
    dtab[3] = &dteOpens;
    dtab[4] = &dteTime;
    dtab[5] = &dteIdle;
    dtab[6] = (STR_DTE *) &_sdteGuest;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // SESSIONS_LBI :: Paint


/*******************************************************************

    NAME:       SESSIONS_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
WCHAR SESSIONS_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );

}   // SESSIONS_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       SESSIONS_LBI :: Compare

    SYNOPSIS:   Compare two SESSIONS_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
INT SESSIONS_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsUserName._stricmp( ((const SESSIONS_LBI *)plbi)->_nlsUserName );

}   // SESSIONS_LBI :: Compare


/*******************************************************************

    NAME:           RESOURCES_LISTBOX :: RESOURCES_LISTBOX

    SYNOPSIS:       RESOURCES_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      30-May-1991 Created for the Server Manager.
        KeithMo     14-Oct-1991 Validate construction, use INTL_PROFILE
                                to get time separator.
        KeithMo     18-Feb-1992 Made the listbox read only.

********************************************************************/
RESOURCES_LISTBOX :: RESOURCES_LISTBOX( OWNER_WINDOW * powner,
                                        CID            cid,
                                        SERVER_2     * pserver )
  : BLT_LISTBOX( powner, cid, TRUE ),
    _pserver( pserver ),
    _nlsComputerName()

{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsComputerName )
    {
        ReportError( _nlsComputerName.QueryError() );
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;

    if( !nlsTimeSep )
    {
        ReportError( nlsTimeSep.QueryError() );
        return;
    }

    INTL_PROFILE intl;

    if( !intl )
    {
        ReportError( intl.QueryError() );
        return;
    }

    APIERR err = intl.QueryTimeSeparator( &nlsTimeSep );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     4,
                                     powner,
                                     cid,
                                     TRUE) ;
}   // RESOURCES_LISTBOX :: RESOURCES_LISTBOX


/*******************************************************************

    NAME:           RESOURCES_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available sharepoints.

    ENTRY:          None.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.
        KeithMo     05-Oct-1992         Added pcOpens.

********************************************************************/
APIERR RESOURCES_LISTBOX :: Fill( const TCHAR * pszComputerName,
                                  ULONG       * pcOpens,
                                  ULONG       * pnTime,
                                  ULONG       * pnIdle )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    NLS_STR nlsComputerName(SZ("\\\\"));

    nlsComputerName += pszComputerName;

    APIERR err = nlsComputerName.QueryError();

    if ( err != NERR_Success )
    {
        return err;
    }

    //
    //  Our connection enumerator.
    //

    CONN1_ENUM enumConn1( (TCHAR *)_pserver->QueryName(),
                          (TCHAR *)nlsComputerName.QueryPch() );

    //
    //  See if the connections are available.
    //

    err = enumConn1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Now that we know the connection info is available,
    //  let's nuke everything in the listbox, after first
    //  saving away the ComputerNamename.
    //

    _nlsComputerName = pszComputerName;

    if( !_nlsComputerName )
    {
        return _nlsComputerName.QueryError();
    }

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the available connections.
    //

    CONN1_ENUM_ITER iterConn1( enumConn1 );
    const CONN1_ENUM_OBJ * pconi1;

    //
    //  Iterate the connections adding them to the listbox.
    //

    ULONG cOpens = 0;
    ULONG nTime  = 0;

    while( ( err == NERR_Success ) && ( ( pconi1 = iterConn1() ) != NULL ) )
    {
        ULONG nTmp = pconi1->QueryTime();

        if( nTmp > nTime )
        {
            nTime = nTmp;
        }

        cOpens += pconi1->QueryNumOpens();

        RESOURCES_LBI * prlbi = new RESOURCES_LBI( pconi1->QueryNetName(),
                                                   pconi1->QueryType(),
                                                   pconi1->QueryNumOpens(),
                                                   nTmp,
                                                   _chTimeSep );

        if( AddItem( prlbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    if( pcOpens != NULL )
    {
        *pcOpens = cOpens;
    }

    if( pnTime != NULL )
    {
        *pnTime = nTime;
    }

    return err;

}   // RESOURCES_LISTBOX :: Fill


/*******************************************************************

    NAME:           RESOURCES_LBI :: RESOURCES_LBI

    SYNOPSIS:       RESOURCES_LBI class constructor.

    ENTRY:          pszResourceName     - The sharepoint name.

                    pszPath             - The path for this sharepoint.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
RESOURCES_LBI :: RESOURCES_LBI( const TCHAR * pszResourceName,
                                UINT          uType,
                                ULONG         cOpens,
                                ULONG         ulTime,
                                TCHAR         chTimeSep ) :
    _pdteBitmap( NULL ),
    _nlsResourceName( pszResourceName ),
    //_pdteBitmap( NULL ),
    _nlsOpens( cOpens ),
    _nlsTime( ulTime, chTimeSep )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsResourceName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsOpens.QueryError()        ) != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError()         ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    switch( uType )
    {
    case STYPE_DISKTREE:
         _pdteBitmap = new DMID_DTE( IDBM_LB_SHARE );
        break;

    case STYPE_PRINTQ:
         _pdteBitmap = new DMID_DTE( IDBM_LB_PRINT );
        break;

    case STYPE_DEVICE:
         _pdteBitmap = new DMID_DTE( IDBM_LB_COMM );
        break;

    case STYPE_IPC:
         _pdteBitmap = new DMID_DTE( IDBM_LB_IPC );
        break;

    default:
         _pdteBitmap = new DMID_DTE( IDBM_LB_UNKNOWN );
         break;
    }

    if( _pdteBitmap == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

}   // RESOURCES_LBI :: RESOURCES_LBI


/*******************************************************************

    NAME:           RESOURCES_LBI :: ~RESOURCES_LBI

    SYNOPSIS:       RESOURCES_LBI class destructor.

    ENTRY:          None.

    EXIT:           The object is destroyed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
RESOURCES_LBI :: ~RESOURCES_LBI()
{
    delete _pdteBitmap;
    _pdteBitmap = NULL;

}   // RESOURCES_LBI :: ~RESOURCES_LBI


/*******************************************************************

    NAME:           RESOURCES_LBI :: Paint

    SYNOPSIS:       Draw an entry in RESOURCES_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.
                    hdc                 - The DC to draw upon.
                    prect               - Clipping rectangle.
                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KevinL      15-Sep-1991         Created.
        KeithMo     06-Oct-1991         Now takes a const RECT *.
        beng        22-Apr-1992         Changes to LBI::Paint

********************************************************************/
VOID RESOURCES_LBI :: Paint( LISTBOX *     plb,
                             HDC           hdc,
                             const RECT  * prect,
                             GUILTT_INFO * pGUILTT ) const
{
    STR_DTE     dteResourceName( _nlsResourceName.QueryPch() );
    STR_DTE     dteOpens( _nlsOpens.QueryPch() );
    STR_DTE     dteTime( _nlsTime.QueryPch() );

    DISPLAY_TABLE dtab( 4, ( (RESOURCES_LISTBOX *)plb )->QueryColumnWidths() );

    dtab[0] = _pdteBitmap;
    dtab[1] = &dteResourceName;
    dtab[2] = &dteOpens;
    dtab[3] = &dteTime;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // RESOURCES_LBI :: Paint


/*******************************************************************

    NAME:       RESOURCES_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
WCHAR RESOURCES_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsResourceName );

    return _nlsResourceName.QueryChar( istr );

}   // RESOURCES_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       RESOURCES_LBI :: Compare

    SYNOPSIS:   Compare two RESOURCES_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KevinL      15-Sep-1991         Created.

********************************************************************/
INT RESOURCES_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsResourceName._stricmp( ((const RESOURCES_LBI *)plbi)->_nlsResourceName );

}   // RESOURCES_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\senddlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
 *      Windows/Network Interface
 *
 *  FILE HISTORY:
 *      ChuckC      19-Jul-1991     Culled from SHELL\SHELL\WNETDEV.CXX
 *
 */

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETSESSION
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>
#include <lmoenum.hxx>
#include <lmoesess.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>
}

#include <senddlg.hxx>


/*******************************************************************

    NAME:       SRV_SEND_MSG_DIALOG::SRV_SEND_MSG_DIALOG

    SYNOPSIS:   constructor for Server Manager Send Message Dialog

    ENTRY:      must have server selection

    EXIT:       usual construction stuff, slt set to contain
                server of current focus.

    HISTORY:
        ChuckC      19-Aug-1991     Created

********************************************************************/

SRV_SEND_MSG_DIALOG::SRV_SEND_MSG_DIALOG( HWND hDlg, const TCHAR *pszServer )
   : MSG_DIALOG_BASE(hDlg, MAKEINTRESOURCE(IDD_SEND_MSG_DIALOG), IDSD_MSGTEXT),
     _sltUsers( this, IDSD_USERNAME ),
     pslUsers(NULL),
     CT_INIT_NLS_STR(nlsServer, SZ("\\\\"))
{
    /*
     * must have selection
     */
    UIASSERT(pszServer != NULL) ;

    if ( QueryError() != NERR_Success )
        return;

    // SetText from control window returns void
    _sltUsers.SetText(pszServer) ;

    // guaranteed to succeed, since its a DECL_CLASS_NLS_STR
    nlsServer += pszServer ;
}


/*******************************************************************

    NAME:       SRV_SEND_MSG_DIALOG::QueryHelpContext

    SYNOPSIS:   Query help text for SRV_SEND_MSG_DIALOG

    HISTORY:
        ChuckC      19-Aug-1991     Created

********************************************************************/

ULONG SRV_SEND_MSG_DIALOG::QueryHelpContext( void )
{
    return HC_SEND_MSG_DLG;
}


/*******************************************************************

    NAME:       SRV_SEND_MSG_DIALOG::QueryUsers

    SYNOPSIS:   Virtual method that determines what users will
                receive the message. In this case, all users with
                sessions to the current server.

    ENTRY:

    EXIT:       STRLIST *pslUsers contains list of target users.

    HISTORY:
        ChuckC      19-Aug-1991     Created

********************************************************************/

APIERR SRV_SEND_MSG_DIALOG::QueryUsers( STRLIST *pslUsers )
{

    UIASSERT(pslUsers != NULL) ;

    /*
     * enumerate all sessions
     */
    SESSION0_ENUM enumSession0( (TCHAR *) nlsServer.QueryPch() );
    APIERR usErr = enumSession0.GetInfo();

    if( usErr != NERR_Success )
    {
        return (usErr) ;
    }

    /*
     *  We've got our enumeration, now find all users
     */
    SESSION0_ENUM_ITER iterSession0( enumSession0 );
    const SESSION0_ENUM_OBJ * psi0 = iterSession0();

    /*
     * Add all to strlist. Do not add duplicates, hence the check
     * for IsMember().
     */
    while( psi0 != NULL )
    {
        NLS_STR *pnlsComputername = new NLS_STR(psi0->QueryComputerName()) ;
        if (pnlsComputername == NULL)
            return( ERROR_NOT_ENOUGH_MEMORY ) ;

        if (pslUsers->IsMember( *pnlsComputername ))
        {
            /*
             * we need this delate, since we normally assume STRLIST
             * destructor to cleanup, but we aint adding to STRLIST.
             */
            delete pnlsComputername ;
            pnlsComputername = NULL ;
        }
        else
        {
            usErr = pslUsers->Add( pnlsComputername ) ;
            if (usErr != NERR_Success)
                return( ERROR_NOT_ENOUGH_MEMORY ) ;
        }

        psi0 = iterSession0() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       SRV_SEND_MSG_DIALOG::ActionOnError

    SYNOPSIS:   Virtual method that determines what happens when
                an error occurs.

    ENTRY:      err contains a system or net error.

    EXIT:       appropriate message displayed, dialog dismissed if
                necessary.

    HISTORY:
        ChuckC      19-Aug-1991     Created

********************************************************************/

BOOL SRV_SEND_MSG_DIALOG::ActionOnError( APIERR err )
{
    switch (err)
    {
        case NERR_Success:
            UIASSERT(0) ; // bogus dude, i should not be invoked on success
            break ;

        // innocent error, put out warning and dismiss
        case NERR_TruncatedBroadcast:
            MsgPopup ( this, err, MPSEV_WARNING );
            Dismiss(NERR_Success) ;
            break ;

        //
        //  This error is returned when the user press "OK"
        //  with an empty edit field.  This error code should probably
        //  be changed to something a little more reasonable.
        //

        case ERROR_GEN_FAILURE:
            MsgPopup( this, IDS_NEED_TEXT_TO_SEND );
            SetFocusToMLE();
            break;

        default:
            MsgPopup ( this, IDS_CANNOT_SENDALL ) ;
            Dismiss(err) ;
            break ;
    }

    return(TRUE) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\srvlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvlb.cxx
    SERVER_LISTBOX and SERVER_LBI module

    FILE HISTORY:
        kevinl     16-Jul-1991     Created from srvmain.cxx
        kevinl     12-Aug-1991     Added Refresh
        kevinl     04-Sep-1991     Code Rev Changes: JonN, RustanL, KeithMo,
                                                     DavidHov, ChuckC
        KeithMo    06-Oct-1991     Win32 Conversion.
        KeithMo    18-Mar-1992     Changed enumerator from SERVER1_ENUM
                                   to TRIPLE_SERVER_ENUM.

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>

}   // extern "C"

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#define INCL_BLT_MENU
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <strnumer.hxx>
#include <adminapp.hxx>
#include <lmodom.hxx>

#include <srvlb.hxx>
#include <srvmain.hxx>
#include <smx.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <mnet.h>

}   // extern "C"

#define CCOLUMNS 4

#ifdef ENABLE_PERIODIC_REFRESH

//
//  This is the maximum number of servers to retrieve during
//  the RefreshNext() method.  This value is only necessary
//  if periodic refresh is enabled.
//

#define MAX_ITEMS_PER_REFRESH   20

#endif  // ENABLE_PERIODIC_REFRESH


//
//  These manifests are the major/minor version numbers
//  returned by the initial release of Windows for Workgroups.
//

#define WFW_MAJOR_VER    1
#define WFW_MINOR_VER   50


//
//  This is the minimum version number necessary to
//  actually display a version number.  If we get a
//  machine with a major version number less that this
//  value, we don't display the version number.
//

#define MIN_DISPLAY_VER  2

//
// JonN 01/23/00
// 434889: SRVMGR: window 2000 machines in the domain show up as "NT5"
//
#define WINDOWS_2000_DISPLAY_VER 5


//
//  This is the default setting for whether a domain is considered to
//  have an NT PDC if the PDC could not be found.  It was changed from
//  FALSE to TRUE in January 1996.
//

#define DEFAULT_IS_NT_PRIMARY TRUE
#define DEFAULT_IS_NT5_PRIMARY FALSE



/*******************************************************************

    NAME:          SERVER_LBI::SERVER_LBI

    SYNOPSIS:      Constructor.  Sets the pointers for the domain role
                   bitmaps and strings.  These static members that are
                   pointed to have been initialized using SERVER_LBI::Init()

    ENTRY:         SERVER_LBI::Init has been successfully called and
                   dRole is valid.

    EXIT:          internal data has been initialized

    NOTES:         This ctor form is used for "suspected" LanMan servers.

    HISTORY:
       kevinl      21-May-1991     Created
       jonn        23-Jan-2000     Windows 2000 string

********************************************************************/
SERVER_LBI :: SERVER_LBI( const TCHAR * pszServer,
                          SERVER_TYPE   servertype,
                          SERVER_ROLE   serverrole,
                          UINT          verMajor,
                          UINT          verMinor,
                          const TCHAR * pszComment,
                          SERVER_LISTBOX& lbref,
                          DWORD         dwServerTypeMask )
  : _nlsServerName( pszServer ),
    _nlsComment( pszComment ),
    _nlsType(),
    _dteServer( NULL ),
    _dteComment( NULL ),
    _pdmdteRole( lbref.QueryRoleBitmap( serverrole, servertype ) ),
    _servertype( servertype ),
    _serverrole( serverrole ),
    _dwServerTypeMask( dwServerTypeMask ),
    _verMajor( verMajor & MAJOR_VERSION_MASK ),
    _verMinor( verMinor ),
    _fIsLanMan( TRUE )
{

    UIASSERT( pszServer != NULL );
    UIASSERT( pszComment != NULL );

    if( QueryError() != NERR_Success )
    {
        return ;
    }

    if ( servertype == Windows95ServerType || verMajor < MIN_DISPLAY_VER )
        _nlsType = lbref._nlsTypeFormatUnknown;
    else if ( verMajor < WINDOWS_2000_DISPLAY_VER )
        _nlsType = lbref._nlsTypeFormat;
    else if ( verMajor == WINDOWS_2000_DISPLAY_VER && verMinor == 0 )
        _nlsType = lbref._nlsTypeFormatWin2000;
    else
        _nlsType = lbref._nlsTypeFormatFuture;

    APIERR err;

    if( ( ( err = _nlsServerName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsComment.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsType.QueryError()       ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    _dteServer.SetPch( _nlsServerName.QueryPch() );
    _dteComment.SetPch( _nlsComment.QueryPch() );

    //
    //  Format the type/role stuff.
    //

    ALIAS_STR nlsServerType( lbref.QueryTypeString( servertype ) );
    UIASSERT( nlsServerType.QueryError() == NERR_Success );

    ALIAS_STR nlsServerRole( lbref.QueryRoleString( serverrole, servertype ) );
    UIASSERT( nlsServerRole.QueryError() == NERR_Success );

    DEC_STR nlsMajor( (ULONG)verMajor );
    DEC_STR nlsMinor( (ULONG)verMinor );

    if( ( ( err = nlsMajor.QueryError() ) != NERR_Success ) ||
        ( ( err = nlsMinor.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    const NLS_STR * apnlsParams[5];

    apnlsParams[0] = &nlsServerType;
    apnlsParams[1] = &nlsMajor;
    apnlsParams[2] = &nlsMinor;
    apnlsParams[3] = &nlsServerRole;
    apnlsParams[4] = NULL;

    err = _nlsType.InsertParams( apnlsParams );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}


/*******************************************************************

    NAME:          SERVER_LBI::SERVER_LBI

    SYNOPSIS:      Constructor.  Sets the pointers for the domain role
                   bitmaps and strings.  These static members that are
                   pointed to have been initialized using SERVER_LBI::Init()

    ENTRY:         SERVER_LBI::Init has been successfully called and
                   dRole is valid.

    EXIT:          internal data has been initialized

    NOTES:         This ctor form is used for known non-LanMan servers.

    HISTORY:
       keithmo      07-Dec-1992     Created.

********************************************************************/
SERVER_LBI :: SERVER_LBI( const TCHAR * pszServer,
                          const TCHAR * pszType,
                          const TCHAR * pszComment,
                          DMID_DTE    * pdmdteRole )
  : _nlsServerName( pszServer ),
    _nlsComment( pszComment ),
    _nlsType( pszType ),
    _dteServer( NULL ),
    _dteComment( NULL ),
    _pdmdteRole( pdmdteRole ),
    _servertype( UnknownServerType ),
    _serverrole( UnknownRole ),
    _dwServerTypeMask( 0 ),
    _verMajor( 0 ),
    _verMinor( 0 ),
    _fIsLanMan( TRUE )
{
    UIASSERT( pszServer != NULL );
    UIASSERT( pszType != NULL );
    UIASSERT( pdmdteRole != NULL );

    if( QueryError() != NERR_Success )
    {
        return ;
    }

    APIERR err;

    if( ( ( err = _nlsServerName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsComment.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsType.QueryError()       ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    _dteServer.SetPch( _nlsServerName.QueryPch() );
    _dteComment.SetPch( _nlsComment.QueryPch() );
}


/*******************************************************************

    NAME:          SERVER_LBI::~SERVER_LBI

    SYNOPSIS:      Class destructor

    HISTORY:
       kevinl      21-May-1991     Created

********************************************************************/
SERVER_LBI::~SERVER_LBI()
{
    _pdmdteRole = NULL;

}


/*******************************************************************

    NAME:          SERVER_LBI::Paint

    SYNOPSIS:      Paints the listbox entry to the screen.

    ENTRY:         The item has been constructed successfully.

    HISTORY:
       kevinl      21-May-1991     Created
       KeithMo     06-Oct-1991     Now takes a const RECT *.
       beng        22-Apr-1992     Changes to LBI::Paint

********************************************************************/
VOID SERVER_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                        GUILTT_INFO * pGUILTT ) const
{
    DISPLAY_TABLE dtab( 4, (((SERVER_LISTBOX *)plb)->QuerypadColWidths())->QueryColumnWidth());

    STR_DTE dteType( _nlsType.QueryPch() );

    dtab[0] = _pdmdteRole;
    dtab[1] = (STR_DTE *)&_dteServer;
    dtab[2] = &dteType;
    dtab[3] = (STR_DTE *)&_dteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:          SERVER_LBI::QueryLeadingChar

    SYNOPSIS:      Returns the first letter in the server name.

    HISTORY:
       kevinl      21-May-1991     Created

********************************************************************/
WCHAR SERVER_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsServerName );

    return _nlsServerName.QueryChar( istr );

}


/*******************************************************************

    NAME:          SERVER_LBI::Compare

    SYNOPSIS:      Compares server names - used for sorting the listbox.

    HISTORY:
       kevinl      21-May-1991     Created

********************************************************************/
INT SERVER_LBI::Compare( const LBI * plbi ) const
{
    return _nlsServerName._stricmp( ((const SERVER_LBI *)plbi)->_nlsServerName );

}


/*******************************************************************

    NAME:          SERVER_LBI::QueryServer

    SYNOPSIS:      Returns the server name from the listbox entry.

    HISTORY:
       kevinl      21-May-1991     Created

********************************************************************/
const TCHAR * SERVER_LBI::QueryServer() const
{
    return _nlsServerName.QueryPch();
}


/*******************************************************************

    NAME:          SERVER_LBI::CompareAll

    SYNOPSIS:      Returns TRUE if the LBI is identical in value
                    to the one being passed in.  FALSE otherwise.

    HISTORY:
       kevinl      04-Sep-1991     Created

********************************************************************/
BOOL SERVER_LBI::CompareAll(const ADMIN_LBI * plbi)
{
    const SERVER_LBI * psrvlbi = (const SERVER_LBI *)plbi;

    if( ( _nlsServerName.strcmp( psrvlbi->_nlsServerName )  == 0  ) &&
        ( _nlsComment.strcmp( psrvlbi->_nlsComment )        == 0  ) &&
        ( _nlsType.strcmp( psrvlbi->_nlsType )              == 0  ) &&
        ( QueryServerType() == psrvlbi->QueryServerType()         ) &&
        ( QueryServerRole() == psrvlbi->QueryServerRole()         ) &&
        ( QueryServerTypeMask() == psrvlbi->QueryServerTypeMask() ) )
    {
        return TRUE;
    }

    TRACEOUT( "SRVMGR: Data changed for " );
    TRACEEOL( _nlsServerName.QueryPch() );

    return FALSE;
}


/*******************************************************************

    NAME:       SERVER_LBI::QueryName

    SYNOPSIS:   Returns the name of the LBI

    RETURNS:    Pointer to name of the LBI

    NOTES:      This is a virtual replacement from the ADMIN_LBI class

    HISTORY:
       kevinl      21-May-1991     Created

********************************************************************/

const TCHAR * SERVER_LBI::QueryName( void ) const
{
    return QueryServer();

}  // SERVER_LBI::QueryName


/*******************************************************************

    NAME:       SERVER_LISTBOX::SERVER_LISTBOX

    SYNOPSIS:   SERVER_LISTBOX constructor

    HISTORY:
        rustanl     01-Jul-1991     Created
        beng        31-Jul-1991     Control error handling changed

********************************************************************/

SERVER_LISTBOX::SERVER_LISTBOX( SM_ADMIN_APP * paappwin, CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                BOOL fMultSel, INT dAge )
  : ADMIN_LISTBOX( paappwin, cid, xy, dxy, fMultSel, dAge ),
    _penum( NULL ),
    _piter( NULL ),
    _psi1( NULL ),
    _pSv1Enum( NULL ),
    _pSv1Iter( NULL ),
    _paappwin( paappwin ),
    _nlsPrimary( IDS_ROLE_PRIMARY ),
    _nlsBackup( IDS_ROLE_BACKUP ),
    _nlsLmServer( IDS_ROLE_LMSERVER ),
    _nlsServer( IDS_ROLE_SERVER ),
    _nlsWksta( IDS_ROLE_WKSTA ),
    _nlsWkstaOrServer( IDS_ROLE_WKSTA_OR_SERVER ),
    _nlsUnknown( IDS_ROLE_UNKNOWN ),
    _nlsTypeWinNT( IDS_SERVER_TYPE_WINNT ),
    _nlsTypeLanman( IDS_SERVER_TYPE_LANMAN ),
    _nlsTypeWfw( IDS_SERVER_TYPE_WFW ),
    _nlsTypeWindows95( IDS_SERVER_TYPE_WINDOWS95 ),
    _nlsTypeUnknown( IDS_SERVER_TYPE_UNKNOWN ),
    _nlsTypeFormat( IDS_TYPE_FORMAT ),
    _nlsTypeFormatUnknown( IDS_TYPE_FORMAT_UNKNOWN ),
    _nlsTypeFormatWin2000( IDS_TYPE_FORMAT_WIN2000 ),
    _nlsTypeFormatFuture( IDS_TYPE_FORMAT_FUTURE ),
    _nlsCurrentDomain(),
    _fIsNtPrimary( DEFAULT_IS_NT_PRIMARY ),
    _fIsNt5Primary( DEFAULT_IS_NT5_PRIMARY ),
    _fIsPDCAvailable( FALSE ),
    _fAreAnyNtBDCsAvailable( FALSE ),
    _fAreAnyLmBDCsAvailable( FALSE ),
    _nlsExtType(),
    _nlsExtComment(),
    _fAlienServer( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err ;
    if ( ( err = _nlsPrimary.QueryError() ) ||
         ( err = _nlsBackup.QueryError()  ) ||
         ( err = _nlsLmServer.QueryError()  ) ||
         ( err = _nlsServer.QueryError()  ) ||
         ( err = _nlsWksta.QueryError()   ) ||
         ( err = _nlsWkstaOrServer.QueryError()   ) ||
         ( err = _nlsUnknown.QueryError() ) ||
         ( err = _nlsTypeWinNT.QueryError() ) ||
         ( err = _nlsTypeLanman.QueryError() ) ||
         ( err = _nlsTypeWfw.QueryError() ) ||
         ( err = _nlsTypeWindows95.QueryError() ) ||
         ( err = _nlsTypeUnknown.QueryError() ) ||
         ( err = _nlsTypeFormat.QueryError() ) ||
         ( err = _nlsTypeFormatUnknown.QueryError() ) ||
         ( err = _nlsTypeFormatWin2000.QueryError() ) ||
         ( err = _nlsTypeFormatFuture.QueryError() ) ||
         ( err = _nlsCurrentDomain.QueryError() ) ||
         ( err = _nlsExtType.QueryError() ) ||
         ( err = _nlsExtComment.QueryError() ) )
    {
       ReportError( err ) ;
       return ;
    }

    _pdmdteActivePrimary   = new DMID_DTE( IDBM_ACTIVE_PRIMARY );
    _pdmdteInactivePrimary = new DMID_DTE( IDBM_INACTIVE_PRIMARY );
    _pdmdteActiveServer    = new DMID_DTE( IDBM_ACTIVE_SERVER );
    _pdmdteInactiveServer  = new DMID_DTE( IDBM_INACTIVE_SERVER );
    _pdmdteActiveWksta     = new DMID_DTE( IDBM_ACTIVE_WKSTA );
    _pdmdteInactiveWksta   = new DMID_DTE( IDBM_INACTIVE_WKSTA );
    _pdmdteUnknown         = new DMID_DTE( IDBM_UNKNOWN );

    if( ( _pdmdteActivePrimary   == NULL ) ||
        ( _pdmdteInactivePrimary == NULL ) ||
        ( _pdmdteActiveServer    == NULL ) ||
        ( _pdmdteInactiveServer  == NULL ) ||
        ( _pdmdteActiveWksta     == NULL ) ||
        ( _pdmdteInactiveWksta   == NULL ) ||
        ( _pdmdteUnknown         == NULL ) )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if( ( ( err = _pdmdteActivePrimary->QueryError()   ) != NERR_Success ) ||
        ( ( err = _pdmdteInactivePrimary->QueryError() ) != NERR_Success ) ||
        ( ( err = _pdmdteActiveServer->QueryError()    ) != NERR_Success ) ||
        ( ( err = _pdmdteInactiveServer->QueryError()  ) != NERR_Success ) ||
        ( ( err = _pdmdteActiveWksta->QueryError()     ) != NERR_Success ) ||
        ( ( err = _pdmdteInactiveWksta->QueryError()   ) != NERR_Success ) ||
        ( ( err = _pdmdteUnknown->QueryError()         ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    _padColWidths = new ADMIN_COL_WIDTHS( QueryHwnd(),
                                          paappwin->QueryInstance(),
                                          ID_RESOURCE,
                                          CCOLUMNS);
    if (_padColWidths == NULL)
    {
        ReportError (ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    if ( (err = _padColWidths->QueryError() ) != NERR_Success)
    {
        ReportError (err);
        return;
    }
}  // SERVER_LISTBOX::SERVER_LISTBOX


/*******************************************************************

    NAME:       SERVER_LISTBOX::~SERVER_LISTBOX

    SYNOPSIS:   SERVER_LISTBOX destructor

    HISTORY:
        rustanl     01-Jul-1991     Created

********************************************************************/

SERVER_LISTBOX::~SERVER_LISTBOX()
{
    delete _pdmdteActivePrimary;
    delete _pdmdteInactivePrimary;
    delete _pdmdteActiveServer;
    delete _pdmdteInactiveServer;
    delete _pdmdteActiveWksta;
    delete _pdmdteInactiveWksta;
    delete _pdmdteUnknown;
    delete _padColWidths;

    _pdmdteActivePrimary   = NULL;
    _pdmdteInactivePrimary = NULL;
    _pdmdteActiveServer    = NULL;
    _pdmdteInactiveServer  = NULL;
    _pdmdteActiveWksta     = NULL;
    _pdmdteInactiveWksta   = NULL;
    _pdmdteUnknown         = NULL;
    _padColWidths          = NULL;

}  // SERVER_LISTBOX::~SERVER_LISTBOX


/*******************************************************************

    NAME:       SERVER_LISTBOX::QueryRoleBitmap

    SYNOPSIS:

    ENTRY:      Domain Role

    RETURNS:    DMID_DTE * which points to the appropriate bitmap.


    HISTORY:
        kevinl     04-Sep-1991     Created

********************************************************************/

DMID_DTE * SERVER_LISTBOX::QueryRoleBitmap( SERVER_ROLE Role,
                                            SERVER_TYPE Type )
{
    DMID_DTE * pdmdte = NULL;
    BOOL       fActive = ( Type == ActiveNtServerType ) ||
                         ( Type == ActiveLmServerType ) ||
                         ( Type == WfwServerType )      ||
                         ( Type == Windows95ServerType );

    switch( Role )
    {
    case PrimaryRole :
        pdmdte = fActive ? _pdmdteActivePrimary
                         : _pdmdteInactivePrimary;
        break;

    case DeadPrimaryRole :
        pdmdte = _pdmdteInactivePrimary;
        break;

    case BackupRole :
    case LmServerRole :
    case ServerRole :
        pdmdte = fActive ? _pdmdteActiveServer
                         : _pdmdteInactiveServer;
        break;

    case DeadBackupRole :
        pdmdte = _pdmdteInactiveServer;
        break;

    case WkstaRole :
    case WkstaOrServerRole :
        pdmdte = fActive ? _pdmdteActiveWksta
                         : _pdmdteInactiveWksta;
        break;

    case UnknownRole :
        pdmdte = _pdmdteUnknown;
        break;

    default :
        UIASSERT( FALSE );      // invalid server role!
        pdmdte = _pdmdteUnknown;
        break;
    }

    UIASSERT( pdmdte != NULL );

    return pdmdte;

}  // SERVER_LISTBOX::QueryRoleBitmap


/*******************************************************************

    NAME:       SERVER_LISTBOX::QueryRoleString

    SYNOPSIS:

    ENTRY:      Domain Role

    RETURNS:    const TCHAR * which points to the appropriate string.

    HISTORY:
        kevinl     04-Sep-1991     Created

********************************************************************/
const TCHAR * SERVER_LISTBOX::QueryRoleString( SERVER_ROLE Role,
                                               SERVER_TYPE Type )
{
    const TCHAR * pszRole;

    if( Type == WfwServerType )
    {
        pszRole = SZ("");
    }
    else // includes Windows95ServerType
    {
        switch( Role )
        {
        case PrimaryRole :
        case DeadPrimaryRole :
            pszRole = _nlsPrimary;
            break;

        case ServerRole :
            pszRole = _nlsServer;
            break;

        case LmServerRole :
            pszRole = _nlsLmServer;
            break;

        case BackupRole :
        case DeadBackupRole :
            pszRole = _nlsBackup;
            break;

        case WkstaRole :
            pszRole = _nlsWksta;
            break;

        case WkstaOrServerRole :
            pszRole = _nlsWkstaOrServer;
            break;

        case UnknownRole :
            pszRole = _nlsUnknown;
            break;

        default :
            UIASSERT( !"Invalid Server Role!" );
            pszRole = _nlsUnknown;
            break;
        }
    }

    return pszRole;

}  // SERVER_LISTBOX::QueryRoleString


/*******************************************************************

    NAME:       SERVER_LISTBOX::QueryTypeString

    SYNOPSIS:

    ENTRY:      server type

    RETURNS:    const TCHAR * which points to the appropriate string.

    HISTORY:
        keithmo     19-Mar-1992 Created
        beng        01-Apr-1992 Unicode fix

********************************************************************/

const TCHAR * SERVER_LISTBOX::QueryTypeString( SERVER_TYPE Type )
{
    const TCHAR * pszType = NULL;

    switch( Type )
    {
    case ActiveNtServerType :
    case InactiveNtServerType :
        pszType = _nlsTypeWinNT;
        break;

    case ActiveLmServerType :
    case InactiveLmServerType :
        pszType = _nlsTypeLanman;
        break;

    case WfwServerType :
        pszType = _nlsTypeWfw;
        break;

    case Windows95ServerType :
        pszType = _nlsTypeWindows95;
        break;

    case UnknownServerType :
    default :
        pszType = _nlsTypeUnknown;
        break;
    }

    ASSERT( pszType != NULL );

    return pszType;

}  // SERVER_LISTBOX::QueryTypeString


/*******************************************************************

    NAME:       SERVER_LISTBOX::CreateNewRefreshInstance

    SYNOPSIS:

    RETURNS:    APIERR

    NOTES:      This is a virtual replacement from the ADMIN_LISTBOX class

    HISTORY:
        kevinl     22-Aug-1991     Created
        KeithMo    13-Mar-1992     Moved grunt work into
                                   CreateServerFocusInstance() and
                                   CreateDomainFocusInstance() workers.

********************************************************************/

APIERR SERVER_LISTBOX :: CreateNewRefreshInstance()
{
    //
    //  Retrieve the current focus.  This string will be either
    //  a server name (\\SERVER) or a domain name.
    //

    NLS_STR nlsCurrentFocus;

    APIERR err = nlsCurrentFocus.QueryError();

    if( err == NERR_Success )
    {
        err = _paappwin->QueryCurrentFocus( &nlsCurrentFocus );
    }

    if( err == NERR_Success )
    {
        //
        //  Create the appropriate focus object(s).
        //

        switch ( _paappwin->QueryFocusType() )
        {
        case FOCUS_DOMAIN:
            err = CreateDomainFocus( nlsCurrentFocus.QueryPch() );
            break;

        case FOCUS_SERVER:
            err = CreateServerFocus( nlsCurrentFocus.QueryPch() );
            break;

        default:
            err = ERROR_GEN_FAILURE;
            UIASSERT( !"Invalid focus type!" );
            break;
        }
    }

    return err;

}   // SERVER_LISTBOX :: CreateNewRefreshInstance


/*******************************************************************

    NAME:       SERVER_LISTBOX::RefreshNext

    SYNOPSIS:

    RETURNS:    APIERR

    NOTES:      This is a virtual replacement from the ADMIN_LISTBOX class

    HISTORY:
        kevinl     22-Aug-1991     Created
        KeithMo    19-Jan-1992     Added default selection of first item.
        KeithMo    13-Mar-1992     Moved grunt work into RefreshDomainFocus
                                   and RefreshServerFocus worker methods.

********************************************************************/

APIERR SERVER_LISTBOX::RefreshNext()
{
    APIERR err;

    switch ( _paappwin->QueryFocusType() )
    {
    case FOCUS_DOMAIN:
        err = RefreshDomainFocus();
        break;

    case FOCUS_SERVER:
        err = RefreshServerFocus();
        break;

    default:
         err = ERROR_GEN_FAILURE;
         UIASSERT( !"Invalid focus type!!" );
         break;
    }

    //
    //  If nothing is currently selected and the listbox
    //  is not empty, the select the first item by default.
    //

    if( ( QuerySelCount() == 0 ) && ( QueryCount() > 0 ) )
    {
        SelectItem( 0 );
    }

    return err;
}


/*******************************************************************

    NAME:       SERVER_LISTBOX::DeleteRefreshInstance

    SYNOPSIS:   Deletes refresh enumerators

    HISTORY:
        kevinl     04-Sep-1991     Created

********************************************************************/

VOID SERVER_LISTBOX::DeleteRefreshInstance()
{
    delete _piter;
    delete _penum;
    delete _psi1;
    delete _pSv1Iter;
    delete _pSv1Enum;

    _piter    = NULL;
    _penum    = NULL;
    _psi1     = NULL;
    _pSv1Iter = NULL;
    _pSv1Enum = NULL;

}  // SERVER_LISTBOX::DeleteRefreshInstance


/*******************************************************************

    NAME:       SERVER_LISTBOX :: CreateDomainFocus

    SYNOPSIS:   This method will create a new domain focus instance
                whenever the app is focused on a domain.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo    13-Mar-1992     Created from KevinL's
                                   CreateNewRefreshInstance().

********************************************************************/
APIERR SERVER_LISTBOX :: CreateDomainFocus( const TCHAR * pszDomainName )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( _penum == NULL );
    UIASSERT( _piter == NULL );

    //
    //  Determine the domain's primary.
    //

    const TCHAR * pszPDCName = NULL;
    DOMAIN domain( pszDomainName );
    APIERR err = domain.GetInfo();

    if( err == NERR_Success )
    {
        SERVER_1 srv1( domain.QueryPDC() );

        err = srv1.GetInfo();

        if( err == ERROR_BAD_NETPATH )
        {
            //
            //  NetGetDCName returned a (seemingly) valid
            //  PDC name, but NetServerGetInfo couldn't find
            //  it.  Map the error to NERR_DCNotFound so we
            //  can continue as if the PDC doesn't exist.
            //

            err = NERR_DCNotFound;
        }

        if( err == NERR_Success )
        {
            _fIsNtPrimary = ( srv1.QueryServerType() & SV_TYPE_NT ) != 0;
            _fIsNt5Primary = ( srv1.QueryMajorVer() & MAJOR_VERSION_MASK ) >= 5;
        }
    }

    if( err == NERR_Success )
    {
        _fIsPDCAvailable = TRUE;
        pszPDCName = domain.QueryPDC();
    }
    else
    if( err == NERR_DCNotFound )
    {
        //
        //  We need to be careful here.  This request may have
        //  come from the setfocus dialog.  If it did, this
        //  msgpopup should be owned by the setfocus dialog, not
        //  the app window.
        //

        HWND hwnd = ::GetLastActivePopup( _paappwin->QueryHwnd() );
        if( hwnd == NULL )
            hwnd = _paappwin->QueryHwnd();

        _fIsPDCAvailable = FALSE;
        _fIsNtPrimary    = DEFAULT_IS_NT_PRIMARY;
        _fIsNt5Primary    = DEFAULT_IS_NT5_PRIMARY;

        ::MsgPopup( hwnd,
                    IDS_CANNOT_FIND_PDC,
                    MPSEV_WARNING,
                    MP_OK,
                    pszDomainName );
    }
    else
    {
        return err;
    }

    //
    //  Note that pszPDCName may be NULL (if NetGetDCName returned
    //  NERR_DCNotFound).  DetermineRasMode must do the "right thing"
    //  in this case.
    //

    _paappwin->DetermineRasMode( pszPDCName );

    if( !_fIsNtPrimary && ( _paappwin->QueryExtensionView() == 0 ) )
    {
        //
        //  We have no NT primary, and the view is not
        //  set to an extension, so set the app view to All.
        //

        _paappwin->SetView( TRUE, TRUE );
        err = _paappwin->SetAdminCaption();

        if( err != NERR_Success )
        {
            return err;
        }
    }

    //
    //  This may take a while...
    //

    AUTO_CURSOR NiftyCursor;

    //
    //  Create the enumerator.
    //

    if( _paappwin->QueryExtensionView() != 0 )
    {
        _pSv1Enum = new SERVER1_ENUM( NULL,
                                      pszDomainName,
                                      (ULONG)_paappwin->QueryViewedServerTypeMask() );

        err = ( _pSv1Enum == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                    : _pSv1Enum->QueryError();

        if( err == NERR_Success )
        {
            err = _pSv1Enum->GetInfo();
        }

        if( err == NERR_Success )
        {
            //
            //  Now, create the associated iterator.
            //

            _pSv1Iter = new SERVER1_ENUM_ITER( *_pSv1Enum );

            if( _pSv1Iter == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        if( ( err == ERROR_BAD_NETPATH )    ||
            ( err == ERROR_FILE_NOT_FOUND ) ||
            ( err == ERROR_NO_BROWSER_SERVERS_FOUND ) )
        {
            _pSv1Iter = NULL;
            err = NERR_Success;
        }
    }
    else
    {
        _penum = new TRIPLE_SERVER_ENUM( pszDomainName,
                                         pszPDCName,
                                         _fIsNtPrimary,
                                         ((SM_ADMIN_APP *)_paappwin)->ViewWkstas(),
                                         ((SM_ADMIN_APP *)_paappwin)->ViewServers(),
                                         ((SM_ADMIN_APP *)_paappwin)->ViewAccountsOnly() |
                                         ((SM_ADMIN_APP *)_paappwin)->InRasMode() );

        err = ( _penum == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                 : _penum->QueryError();

        if( err == NERR_Success )
        {
            err = _penum->GetInfo();
        }

        if( err == NERR_Success )
        {
            //
            //  Now, create the associated iterator.
            //

            _piter = new TRIPLE_SERVER_ENUM_ITER( *_penum );

            if( _piter == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    _fAreAnyNtBDCsAvailable = FALSE;
    _fAreAnyLmBDCsAvailable = FALSE;

    return err;

}   // SERVER_LISTBOX :: CreateDomainFocus


/*******************************************************************

    NAME:       SERVER_LISTBOX :: CreateServerFocus

    SYNOPSIS:   This method will create a new server focus instance
                whenever the app is focused on an individual server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo    13-Mar-1992     Created from KevinL's
                                   CreateNewRefreshInstance().

********************************************************************/
APIERR SERVER_LISTBOX :: CreateServerFocus( const TCHAR * pszServerName )
{
    UIASSERT( pszServerName != NULL );
    UIASSERT( _psi1 == NULL );

    //
    //  Create the server object.
    //

    _fAlienServer = FALSE;

    _psi1 = new SERVER_1( pszServerName );

    APIERR err = ( _psi1 == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : _psi1->GetInfo();

    if( err == ERROR_BAD_NETPATH )
    {
        //
        //  The server was not found.  Might be an "alien"
        //  server, so give the extensions an opportunity
        //  to claim it.
        //

        APIERR errOriginal = err;
        BOOL   fValid      = FALSE;

        //
        //  Enumerate the extension objects, sending validation
        //  requests.
        //

        ITER_SL_OF( UI_EXT ) iter( * ( _paappwin->QueryExtensions() ) );
        SM_MENU_EXT * pExt;

        while( ( pExt = (SM_MENU_EXT *)(iter.Next()) ) != NULL )
        {
            err = pExt->Validate( &fValid,
                                  pszServerName,
                                  &_nlsExtType,
                                  &_nlsExtComment );

            if( fValid && ( err == NERR_Success ) )
            {
                //
                //  Found one!
                //

                err = NERR_Success;
                _fAlienServer = TRUE;
                break;
            }
        }

        if( !fValid )
        {
            //
            //  No one claimed this server, so revert to the
            //  original error.
            //

            err = errOriginal;
        }
    }

    return err;

}   // SERVER_LISTBOX :: CreateServerFocus


/*******************************************************************

    NAME:       SERVER_LISTBOX :: RefreshDomainFocus

    SYNOPSIS:   This method will enumerate the servers in the
                domain the app is focused on, adding those servers
                to the main listbox.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo    13-Mar-1992     Created from KevinL's RefreshNext().
        JonN       29-Apr-1992     Fixed zero-loop bug

********************************************************************/
APIERR SERVER_LISTBOX :: RefreshDomainFocus( VOID )
{
    UIASSERT( ( _penum != NULL ) || ( _pSv1Enum != NULL ) );

#ifdef ENABLE_PERIODIC_REFRESH

    //
    //  If periodic refresh is enabled, we'll use this counter
    //  to ensure that we don't add more than MAX_ITEMS_PER_REFRESH
    //  to the listbox.
    //

    UINT cItemsAdded = 0;

#endif  // ENABLE_PERIODIC_REFRESH

    APIERR err = NERR_Success;

    if( _paappwin->QueryExtensionView() != 0 )
    {
        if( _pSv1Iter == NULL )
        {
            return NERR_Success;
        }

        //
        //  Pointers of this type are returned from the iterator.
        //

        const SERVER1_ENUM_OBJ * pSv1EnumObj;

        while( ( pSv1EnumObj = (*_pSv1Iter)() ) != NULL )
        {
            //
            //  Get the server's type mask.
            //

            DWORD dwTypeMask = (DWORD)pSv1EnumObj->QueryServerType();

            //
            //  Determine the server's type (NT, LM, etc) and role.
            //

            SERVER_TYPE svtype;
            SERVER_ROLE svrole;

            if( dwTypeMask & SV_TYPE_NT )
            {
                svtype = ActiveNtServerType;
            }
            else
            if( dwTypeMask & SV_TYPE_WINDOWS )
            {
                svtype = Windows95ServerType;
            }
            else
            if( dwTypeMask & SV_TYPE_WFW )
            {
                svtype = WfwServerType;
            }
            else
            {
                svtype = ActiveLmServerType;
            }

            if( dwTypeMask & SV_TYPE_DOMAIN_CTRL )
            {
                svrole = PrimaryRole;
            }
            else
            if( dwTypeMask & SV_TYPE_DOMAIN_BAKCTRL )
            {
                svrole = BackupRole;
            }
            else
            if( dwTypeMask & SV_TYPE_SERVER_NT )
            {
                svrole = ServerRole;
            }
            else
            {
                svrole = WkstaRole;
            }

            //
            //  This will make the "update bdc flag" code a little cleaner.
            //

            BOOL fIsDC = ( svrole == PrimaryRole ) || ( svrole == BackupRole );

            //
            //  Update our "BDCs Available" flags.
            //

            if( !_fAreAnyNtBDCsAvailable && fIsDC && ( svtype == ActiveNtServerType ) )
            {
                _fAreAnyNtBDCsAvailable = TRUE;
            }

            if( !_fAreAnyLmBDCsAvailable && fIsDC && ( svtype == ActiveLmServerType ) )
            {
                _fAreAnyLmBDCsAvailable = TRUE;
            }

            //
            //  Add the LBI.  Note that we DO need to check for a
            //  NULL pointer
            //  ADMIN_LISTBOX::AddRefreshItem()...
            //

            UINT verMajor = pSv1EnumObj->QueryMajorVer() & MAJOR_VERSION_MASK;
            UINT verMinor = pSv1EnumObj->QueryMinorVer();

            SERVER_LBI * plbi = new SERVER_LBI(
                                    pSv1EnumObj->QueryName(),
                                    svtype,
                                    svrole,
                                    verMajor,
                                    verMinor,
                                    pSv1EnumObj->QueryComment(),
                                    *this,
                                    dwTypeMask );

            if ( plbi == NULL )
                err = ERROR_NOT_ENOUGH_MEMORY;
            else if ( (err = plbi->QueryError()) == NERR_Success )
                err = AddRefreshItem( plbi );

            if( err != NERR_Success )
            {
                break;
            }

#ifdef ENABLE_PERIODIC_REFRESH

            //
            //  Update our item counter.  If we've reached our limit,
            //  bag out.
            //

            if( ++cItemsAdded >= MAX_ITEMS_PER_REFRESH )
            {
                break;
            }

#endif  // ENABLE_PERIODIC_REFRESH

        }

        //
        //  If we didn't encounter any errors in the above code, then
        //  we need to check the state of penumobj.  If penumobj is
        //  NULL, then we have exhausted the enumeration and everything's
        //  just ducky.  If penumobj is NOT NULL, then we reached our
        //  limit on items to add in a single refresh, and we know there
        //  are more items remaining in the enumeration, so we'll return
        //  ERROR_MORE_DATA.
        //

        if( ( err == NERR_Success ) && ( pSv1EnumObj != NULL ) )
        {
            err = ERROR_MORE_DATA;
        }
    }
    else
    {
        //
        //  Pointers of this type are returned from the iterator.
        //

        const TRIPLE_SERVER_ENUM_OBJ * penumobj;

        while( ( penumobj = (*_piter)() ) != NULL )
        {
            //
            //  Update our "BDCs Available" flags.
            //

            if( !_fAreAnyNtBDCsAvailable &&
                ( penumobj->QueryRole() == BackupRole ) &&
                ( ( penumobj->QueryType() == ActiveNtServerType ) ||
                  ( penumobj->QueryType() == InactiveNtServerType ) ) )
            {
                _fAreAnyNtBDCsAvailable = TRUE;
            }

            if( !_fAreAnyLmBDCsAvailable &&
                ( ( penumobj->QueryType() == InactiveLmServerType ) ||
                    ( ( penumobj->QueryType() == ActiveLmServerType ) &&
                      ( penumobj->QueryRole() == BackupRole ) ) ) )
            {
                _fAreAnyLmBDCsAvailable = TRUE;
            }

            //
            //  Add the LBI.  Note that we DO need to check for a
            //  NULL pointer
            //  ADMIN_LISTBOX::AddRefreshItem()...
            //

            UINT verMajor = penumobj->QueryMajorVer() & MAJOR_VERSION_MASK;
            UINT verMinor = penumobj->QueryMinorVer();

            SERVER_LBI * plbi = new SERVER_LBI(
                                    penumobj->QueryName(),
                                    penumobj->QueryType(),
                                    penumobj->QueryRole(),
                                    verMajor,
                                    verMinor,
                                    penumobj->QueryComment(),
                                    *this,
                                    penumobj->QueryTypeMask() );

            if ( plbi == NULL )
                err = ERROR_NOT_ENOUGH_MEMORY;
            else if ( (err = plbi->QueryError()) == NERR_Success )
                err = AddRefreshItem( plbi );

            if( err != NERR_Success )
            {
                break;
            }

#ifdef ENABLE_PERIODIC_REFRESH

            //
            //  Update our item counter.  If we've reached our limit,
            //  bag out.
            //

            if( ++cItemsAdded >= MAX_ITEMS_PER_REFRESH )
            {
                break;
            }

#endif  // ENABLE_PERIODIC_REFRESH

        }

        //
        //  If we didn't encounter any errors in the above code, then
        //  we need to check the state of penumobj.  If penumobj is
        //  NULL, then we have exhausted the enumeration and everything's
        //  just ducky.  If penumobj is NOT NULL, then we reached our
        //  limit on items to add in a single refresh, and we know there
        //  are more items remaining in the enumeration, so we'll return
        //  ERROR_MORE_DATA.
        //

        if( ( err == NERR_Success ) && ( penumobj != NULL ) )
        {
            err = ERROR_MORE_DATA;
        }
    }

    return err;

}   // SERVER_LISTBOX :: RefreshDomainFocus


/*******************************************************************

    NAME:       SERVER_LISTBOX :: RefreshServerFocus

    SYNOPSIS:   This method will add an appropriate LBI to the main
                listbox whenever the app is focused on an individual
                server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo    13-Mar-1992     Created from KevinL's RefreshNext().

********************************************************************/
APIERR SERVER_LISTBOX :: RefreshServerFocus( VOID )
{
    UIASSERT( _psi1 != NULL );

    //
    //  Get the current focus.  The current focus should be
    //  a server name of the form \\SERVER.
    //

    NLS_STR nlsCurrentFocus;

    APIERR err = nlsCurrentFocus.QueryError();

    if( err == NERR_Success )
    {
        err = _paappwin->QueryCurrentFocus( &nlsCurrentFocus );
    }

    if( err == NERR_Success )
    {
        //
        //  Skip the leading backslashes.
        //

        ISTR istr( nlsCurrentFocus );
        istr += 2;

        SERVER_LBI * plbi = NULL;

        //
        //  Is this a native or alien server?
        //

        if( _fAlienServer )
        {
            plbi = new SERVER_LBI( nlsCurrentFocus[istr],
                                   _nlsExtType,
                                   _nlsExtComment,
                                   _pdmdteActiveWksta );

        }
        else
        {
            //
            //  Determine the server's role & type.
            //

            SERVER_ROLE Role;
            SERVER_TYPE Type;
            UINT        LmServerType = _psi1->QueryServerType();

            Type =   ( LmServerType & SV_TYPE_NT  ) ? ActiveNtServerType
                   : ( LmServerType & SV_TYPE_WINDOWS ) ? Windows95ServerType
                   : ( LmServerType & SV_TYPE_WFW ) ? WfwServerType
                                                    : ActiveLmServerType;

            if( ( Type == ActiveLmServerType ) &&
                ( _psi1->QueryMajorVer() == WFW_MAJOR_VER ) &&
                ( _psi1->QueryMinorVer() >= WFW_MINOR_VER ) )
            {
                //
                //  Note: Windows For Workgroups doesn't set
                //  the WFW bit in the type field returned
                //  by NetServerGetInfo.  We'll just assume
                //  that any LANMan server with version 1.5
                //  must be WFW.
                //

                Type = WfwServerType;
            }

            if( LmServerType & SV_TYPE_DOMAIN_CTRL )
            {
                Role = PrimaryRole;
            }
            else
            if( LmServerType & SV_TYPE_DOMAIN_BAKCTRL )
            {
                Role = BackupRole;
            }
            else
            if( LmServerType & SV_TYPE_SERVER_NT )
            {
                Role = ServerRole;
            }
            else
            {
                Role = WkstaRole;
            }

            //
            //  Add the LBI.  Note that we DO need to check for a
            //  NULL pointer
            //  ADMIN_LISTBOX::AddRefreshItem()...
            //

            UINT verMajor = _psi1->QueryMajorVer();
            UINT verMinor = _psi1->QueryMinorVer();

            plbi = new SERVER_LBI( nlsCurrentFocus[istr],
                                   Type,
                                   Role,
                                   verMajor,
                                   verMinor,
                                   _psi1->QueryComment(),
                                    *this,
                                   (DWORD)_psi1->QueryServerType() );
        }

        if ( plbi == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;
        else if ( (err = plbi->QueryError()) == NERR_Success )
            err = AddRefreshItem( plbi );
    }

    return err;

}   // SERVER_LISTBOX :: RefreshServerFocus


/*******************************************************************

    NAME:       SERVER_LISTBOX::ChangeFont

    SYNOPSIS:   Makes all changes associated with a font change

    HISTORY:
        jonn        23-Sep-1993     Created

********************************************************************/

APIERR SERVER_LISTBOX::ChangeFont( HINSTANCE hmod, FONT & font )
{
    ASSERT(   font.QueryError() == NERR_Success
           && _padColWidths != NULL
           && _padColWidths->QueryError() == NERR_Success
           );

    SetFont( font, TRUE );

    APIERR err = _padColWidths->ReloadColumnWidths( QueryHwnd(),
                                                    hmod,
                                                    ID_RESOURCE );
    if (   err != NERR_Success
        || (err = CalcSingleLineHeight()) != NERR_Success
       )
    {
        DBGEOL( "SERVER_LISTBOX::ChangeFont: reload/calc error " << err );
    }
    else
    {
        (void) Command( LB_SETITEMHEIGHT,
                        (WPARAM)0,
                        (LPARAM)QuerySingleLineHeight() );
    }

    return err;
}


/*******************************************************************

    NAME:       SERVER_COLUMN_HEADER::SERVER_COLUMN_HEADER

    SYNOPSIS:   SERVER_COLUMN_HEADER constructor

    HISTORY:
        rustanl     22-Jul-1991     Created
        kevinl      20-Aug-1991     Adapted to Server Manager

********************************************************************/

SERVER_COLUMN_HEADER::SERVER_COLUMN_HEADER( OWNER_WINDOW * powin, CID cid,
                                          XYPOINT xy, XYDIMENSION dxy,
                                          const SERVER_LISTBOX * psrvlb )
    :   ADMIN_COLUMN_HEADER( powin, cid, xy, dxy ),
        _psrvlb( psrvlb )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _psrvlb != NULL );

    APIERR err;
    if ( ( err = _nlsServerName.QueryError()) != NERR_Success ||
         ( err = _nlsRole.QueryError()) != NERR_Success  ||
         ( err = _nlsComment.QueryError()) != NERR_Success )
    {
        DBGEOL( "SERVER_COLUMN_HEADER ct:  String ct failed" );
        ReportError( err );
        return;
    }

    //  NLS_STR::Load expands the string buffer to be able to
    //  hold any resource string.  Since these strings will stay around
    //  for some time, it would be nice to be able to trim off any
    //  space not needed.  This is achieved by calling Load on
    //  a temporary intermediate NLS_STR object, and then assigning into
    //  the real data members.
    NLS_STR nls;
    if ( ( err = nls.Load( IDS_COL_HEADER_SERVER_NAME )) != NERR_Success ||
         ( err = ( _nlsServerName = nls, _nlsServerName.QueryError())) != NERR_Success ||
         ( err = nls.Load( IDS_COL_HEADER_SERVER_TYPE )) != NERR_Success ||
         ( err = ( _nlsRole = nls, _nlsRole.QueryError())) != NERR_Success  ||
         ( err = nls.Load( IDS_COL_HEADER_SERVER_COMMENT )) != NERR_Success ||
         ( err = ( _nlsComment = nls, _nlsComment.QueryError())) != NERR_Success )
    {
        DBGEOL( "SERVER_COLUMN_HEADER ct:  Loading resource strings failed" );
        ReportError( err );
        return;
    }

}  // SERVER_COLUMN_HEADER::SERVER_COLUMN_HEADER


/*******************************************************************

    NAME:       SERVER_COLUMN_HEADER::~SERVER_COLUMN_HEADER

    SYNOPSIS:   SERVER_COLUMN_HEADER destructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

SERVER_COLUMN_HEADER::~SERVER_COLUMN_HEADER()
{
    // do nothing else

}  // SERVER_COLUMN_HEADER::~SERVER_COLUMN_HEADER


/*******************************************************************

    NAME:       SERVER_COLUMN_HEADER::OnPaintReq

    SYNOPSIS:   Paints the column header control

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     22-Jul-1991 Created
        kevinl      20-Aug-1991 Adapted to Server Manager
        beng        08-Nov-1991 Unsigned widths; resolve BUG-BUGs

********************************************************************/

BOOL SERVER_COLUMN_HEADER::OnPaintReq( void )
{
    PAINT_DISPLAY_CONTEXT dc(this);

    METALLIC_STR_DTE strdteServerName( _nlsServerName.QueryPch());
    METALLIC_STR_DTE strdteRole( _nlsRole.QueryPch());
    METALLIC_STR_DTE strdteComment( _nlsComment.QueryPch());

    XYRECT xyrect(this);

    DISPLAY_TABLE cdt( 3, ((_psrvlb)->QuerypadColWidths())->QueryColHeaderWidth() );
    cdt[ 0 ] = &strdteServerName;
    cdt[ 1 ] = &strdteRole;
    cdt[ 2 ] = &strdteComment;
    cdt.Paint( NULL, dc.QueryHdc(), xyrect );

    return TRUE;

}  // SERVER_COLUMN_HEADER::OnPaintReq
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\srvprop.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvprop.cxx
    Class definitions for the SERVER_PROPERTIES and PROPERTY_SHEET
    classes.

    This file contains the class declarations for the SERVER_PROPERTIES
    and PROPERTY_SHEET classes.  The SERVER_PROPERTIES class implements
    the Server Manager main property sheet.  The PROPERTY_SHEET class
    is used as a wrapper to SERVER_PROPERTIES so that user privilege
    validation can be performed *before* the dialog is invoked.

    FILE HISTORY:
        KeithMo     21-Jul-1991 Created, based on the old PROPERTY.CXX,
                                PROPCOMN.CXX, and PROPSNGL.CXX.
        KeithMo     26-Jul-1991 Code review cleanup.
        terryk      26-Sep-1991 Change NetServerSetInfo to
                                SERVER.WRITE_INFO
        KeithMo     02-Oct-1991 Removed domain role transition stuff
                                (It's now a menu item...)
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     22-Nov-1991 Moved server service control to the property
                                sheet (from the main menu bar).
        KeithMo     15-Jan-1992 Added Service Control button.
        KeithMo     23-Jan-1992 Removed server service control checkboxes.
        KeithMo     29-Jul-1992 Removed Service Control button.
        KeithMo     24-Sep-1992 Removed bogus PROPERTY_SHEET class.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <lmosrv.hxx>
#include <lmouser.hxx>
#include <lmosrvmo.hxx>
#include <lmsvc.hxx>
#include <lmsrvres.hxx>
#include <groups.hxx>
#include <lmoeusr.hxx>

extern "C"
{
    #include <uilmini.h>
    #include <srvmgr.h>

}   // extern "C"

#include <files.hxx>
#include <srvprop.hxx>
#include <password.hxx>
#include <opendlg.hxx>
#include <prefix.hxx>
#include <sessions.hxx>
#include <replmain.hxx>
#include <alertdlg.hxx>


//
//  This is the maximum valid length of a server comment.
//

#define SM_MAX_COMMENT_LENGTH   LM20_MAXCOMMENTSZ

//
//  The admin$ share name.
//

#define PATH_SEPARATOR          TCH('\\')
#define ADMIN_SHARE             SZ("ADMIN$")


//
//  This macro is used in the SERVER_PROPERTIES::OnCommand() method to
//  invoke the appropriate dialog when one of the graphical buttons is
//  pressed.  If DIALOG_WINDOW's destructor were virtual, we could do
//  all of this in a common worker function, thus reducing code size.
//
//  NOTE:  This macro assumes that the dialog constructor takes an HWND
//         and a SERVER_2 *.  This macro further assumes that there is
//         a variable named _pserver of type SERVER_2 * in some visible
//         scope.
//

#define SUBPROPERTY( DlgClass )                                         \
    if( TRUE )                                                          \
    {                                                                   \
        DlgClass * pDlg = new DlgClass( QueryHwnd(), _pserver );        \
                                                                        \
        APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY         \
                                      : pDlg->Process();                \
                                                                        \
        if( err != NERR_Success )                                       \
        {                                                               \
            MsgPopup( this, err );                                      \
        }                                                               \
                                                                        \
        delete pDlg;                                                    \
                                                                        \
        RepaintNow();                                                   \
        Refresh();                                                      \
                                                                        \
        return TRUE;                                                    \
    }                                                                   \
    else


//
//  SERVER_PROPERTIES methods.
//

/*******************************************************************

    NAME:       SERVER_PROPERTIES :: SERVER_PROPERTIES

    SYNOPSIS:   SERVER_PROPERTIES class constructor.

    ENTRY:      hWndOwner               - Handle to the "owning" window.

                pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:      All SERVER_PROPERTIES methods assume that the current
                user has sufficient privilege to adminster the target
                server.

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     21-Oct-1991 Removed HBITMAP bulls**t.
        KeithMo     15-Jan-1992 Added constructor for _gbServices.

********************************************************************/
SERVER_PROPERTIES :: SERVER_PROPERTIES( HWND          hWndOwner,
                                        const TCHAR * pszServerName,
                                        BOOL        * pfDontDisplayError )
  : SRV_BASE_DIALOG( MAKEINTRESOURCE( IDD_SERVER_PROPERTIES ), hWndOwner ),
    _pserver( NULL ),
    _sltSessions( this, IDSP_SESSIONS ),
    _sltOpenNamedPipes( this, IDSP_NAMEDPIPES ),
    _sltOpenFiles( this, IDSP_OPENFILES ),
    _sltFileLocks( this, IDSP_FILELOCKS ),
    _nlsParamUnknown( IDS_SRVPROP_PARAM_UNKNOWN ),
#ifdef SRVMGR_REFRESH
    _pbRefresh( this, IDSP_REFRESH ),
#endif
    _sleComment( this, IDSP_COMMENT, SM_MAX_COMMENT_LENGTH ),
    _fontHelv( FONT_DEFAULT ),
    _gbUsers( this,
               IDSP_USERS_BUTTON,
               MAKEINTRESOURCE( IDBM_USERS ) ),
    _gbFiles( this,
              IDSP_FILES_BUTTON,
              MAKEINTRESOURCE( IDBM_FILES ) ),
    _gbOpenRes( this,
                IDSP_OPENRES_BUTTON,
                MAKEINTRESOURCE( IDBM_OPENRES ) ),
    _gbRepl( this,
             IDSP_REPL_BUTTON,
             MAKEINTRESOURCE( IDBM_REPL ),
             MAKEINTRESOURCE( IDBM_REPL_DISABLED ) ),
    _gbAlerts( this,
               IDSP_ALERTS_BUTTON,
               MAKEINTRESOURCE( IDBM_ALERTS ) ),
    _pPromptDlg( NULL )
{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_fontHelv )
    {
        DBGEOL( "SERVER_PROPERTIES -- _fontHelv Failed!" );
        ReportError( _fontHelv.QueryError() );
        return;
    }

    if( !_nlsParamUnknown )
    {
        DBGEOL( "SERVER_PROPERTIES -- _nlsParamUnknown Failed!" );
        ReportError( _nlsParamUnknown.QueryError() );
        return;
    }

    //
    //  Let the user know this may take a while . . .
    //

    AUTO_CURSOR AutoCursor;

    //
    //  Connect to the target server.
    //
    //  Note that ConnectToServer *must* be called before
    //  we call any other method that expects _pserver to
    //  be valid!
    //

    APIERR err = ConnectToServer( hWndOwner, pszServerName, pfDontDisplayError );

    if( err != NERR_Success )
    {
        DBGEOL( "SERVER_PROPERTIES -- cannot connect to server" );
        ReportError( err );
        return;
    }

    //
    //  Retrieve the static server info.
    //

    err = ReadInfoFromServer();

    if( err != NERR_Success )
    {
        DBGEOL( "SERVER_PROPERTIES -- ReadInfoFromServer Failed!" );
        ReportError( err );
        return;
    }

    //
    //  Display the dynamic server data.
    //

    Refresh();

    //
    //  Initialize our magic button bar.
    //

    err = SetupButtonBar();

    if( err != NERR_Success )
    {
        DBGEOL( "SERVER_PROPERTIES -- SetupButtonBar Failed!" );
        ReportError( err );
        return;
    }

    //
    //  Set the dialog caption.
    //

    STACK_NLS_STR( nlsDisplayName, MAX_PATH + 1 );
    REQUIRE( _pserver->QueryDisplayName( &nlsDisplayName ) == NERR_Success );

    err = SetCaption( this,
                      IDS_CAPTION_PROPERTIES,
                      nlsDisplayName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if( ( _pserver->QueryServerType() & SV_TYPE_NT ) == 0 )
    {
        //
        //  Since we're focused on a downlevel server, and
        //  we really don't want to support the replicator
        //  admin on downlevel machines, disable the replicator
        //  button.
        //

        _gbRepl.Enable( FALSE );
    }

}   // SERVER_PROPERTIES :: SERVER_PROPERTIES


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: ~SERVER_PROPERTIES

    SYNOPSIS:   SERVER_PROPERTIES class destructor.

    ENTRY:      None.

    EXIT:       The object is destroyed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     21-Oct-1991 Removed HBITMAP bulls**t.

********************************************************************/
SERVER_PROPERTIES :: ~SERVER_PROPERTIES()
{
    delete _pPromptDlg;
    _pPromptDlg = NULL;

    delete _pserver;
    _pserver = NULL;

}   // SERVER_PROPERTIES :: ~SERVER_PROPERTIES


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: ConnectToServer

    SYNOPSIS:   Establishes a connection to the target server.

    ENTRY:      hWndOwner               - The window that will "own"
                                          any popup dialogs.

                pszServerName           - Name of the target server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     24-Sep-1992 Created.

********************************************************************/
APIERR SERVER_PROPERTIES :: ConnectToServer( HWND          hWndOwner,
                                             const TCHAR * pszServerName,
                                             BOOL        * pfDontDisplayError )
{
    UIASSERT( _pserver == NULL );
    UIASSERT( pfDontDisplayError != NULL );

    *pfDontDisplayError = FALSE;

    //
    //  Let's see if we can connect to the target server.
    //

    _pserver = new SERVER_2( pszServerName );

    APIERR errOriginal = ( _pserver == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                              : _pserver->QueryError();

    if( errOriginal == NERR_Success )
    {
        errOriginal = _pserver->GetInfo();
    }

    if( errOriginal == NERR_Success )
    {
        //
        //  Good news.
        //

        return NERR_Success;
    }

    //
    //  Something fatal happened.  We don't need _pserver anymore.
    //

    delete _pserver;
    _pserver = NULL;

    if( ( errOriginal != ERROR_INVALID_PASSWORD ) &&
        ( errOriginal != ERROR_ACCESS_DENIED ) )
    {
        //
        //  Something not related to share-levelness occurred.
        //

        return errOriginal;
    }

    //
    //  Determine if the machine is user- or share-level security.
    //

    BOOL fIsShareLevel = FALSE;         // until proven otherwise...
    APIERR err;

    {
        LOCATION loc( pszServerName );
        BOOL fIsNT;

        err = loc.QueryError();

        if( err == NERR_Success )
        {
            err = loc.CheckIfNT( &fIsNT );
        }

        if( err == NERR_Success )
        {
            if( fIsNT )
            {
                //
                //  NT is *always* user-level security.
                //

                err = errOriginal;
            }
            else
            {
                //
                //  NetUserEnum is unsupported on share-level
                //  servers.  If this returns ERROR_NOT_SUPPORTED,
                //  then we *know* it's a share-level server.
                //

                USER0_ENUM usr0( pszServerName );

                err = usr0.QueryError();

                if( err == NERR_Success )
                {
                    err = usr0.GetInfo();

                    if( err == ERROR_NOT_SUPPORTED )
                    {
                        fIsShareLevel = TRUE;
                        err = NERR_Success;
                    }
                    else
                    {
                        DBGEOL( "SERVER_PROPERTIES::ConnectToServer:USER0_ENUM error" << err );
                        err = errOriginal;
                        DBGEOL( "SERVER_PROPERTIES::ConnectToServer: non-share-level error" << err );
                    }
                }
            }
        }
    }

    if( !fIsShareLevel )
    {
        return err;
    }

    //
    //  At this point, we know that the target server
    //  is share-level.  Create the appropriate path to
    //  the ADMIN$ share (\\server\admin$), prompt for
    //  a password, and connect.
    //

    NLS_STR nlsAdmin( pszServerName );
    ALIAS_STR nlsAdminShare( ADMIN_SHARE );

    err = nlsAdmin.QueryError();

    if( err == NERR_Success )
    {
        err = nlsAdmin.AppendChar( PATH_SEPARATOR );
    }

    if( err == NERR_Success )
    {
        err = nlsAdmin.Append( nlsAdminShare );
    }

    if( err == NERR_Success )
    {
        _pPromptDlg = new PROMPT_AND_CONNECT( hWndOwner,
                                              nlsAdmin,
                                              HC_PASSWORD_DIALOG,
                                              SHPWLEN );

        err = ( _pPromptDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : _pPromptDlg->QueryError();

        if( err == NERR_Success )
        {
            err = _pPromptDlg->Connect();
        }

        if( err == NERR_Success )
        {
            if( _pPromptDlg->IsConnected() )
            {
                UIASSERT( _pserver == NULL );

                _pserver = new SERVER_2( pszServerName );

                err = ( _pserver == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                           : _pserver->GetInfo();
            }
            else
            {
                err = errOriginal;
            }
        }
    }

    return err;

}   // SERVER_PROPERTIES :: ConnectToServer


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.  In this case, we're
                only interested in commands sent as a result of the
                user clicking one of the graphical buttons.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

                lParam                  - Varies.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     06-Oct-1991 Now takes a CONTROL_EVENT.
        KeithMo     15-Jan-1992 Added support for Service Control dialog.
        KeithMo     05-Feb-1992 Added Repl & Alerts dialog.  Changed to
                                use new SUBPROPERTY macro.
        JonN        22-Sep-1993 Added Refresh pushbutton

********************************************************************/
BOOL SERVER_PROPERTIES :: OnCommand( const CONTROL_EVENT & event )
{
    switch ( event.QueryCid() )
    {
#ifdef SRVMGR_REFRESH
    case IDSP_REFRESH:
        //
        //  The Refresh pushbutton
        //

        Refresh();
        break;
#endif

    case IDSP_USERS_BUTTON:
        //
        //  The Users dialog.
        //

        SUBPROPERTY( SESSIONS_DIALOG );
        break;

    case IDSP_FILES_BUTTON:
        //
        //  The Files dialog.
        //

        SUBPROPERTY( FILES_DIALOG );
        break;

    case IDSP_OPENRES_BUTTON:
        //
        //  The In Use dialog.
        //

        SUBPROPERTY( OPENS_DIALOG );
        break;

    case IDSP_REPL_BUTTON:
        //
        //  The Replicator dialog.
        //

        {
            LOCATION loc( _pserver->QueryName() );
            BOOL fIsNT;
            enum LOCATION_NT_TYPE locnttype;

            APIERR err = loc.QueryError();

            if( err == NERR_Success )
            {
                err = loc.CheckIfNT( &fIsNT, &locnttype );
            }

            if( err == NERR_Success )
            {
                BOOL fIsLanmanNT = ( locnttype == LOC_NT_TYPE_LANMANNT
                                     || locnttype == LOC_NT_TYPE_SERVERNT );

                REPL_MAIN_DIALOG * pDlg = new REPL_MAIN_DIALOG( QueryHwnd(),
                                                                _pserver,
                                                                fIsLanmanNT );

                err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : pDlg->Process();

                delete pDlg;
            }

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }

            RepaintNow();
            Refresh();
        }
        break;

    case IDSP_ALERTS_BUTTON:
        //
        //  The Alerts dialog.
        //

        {
            ALERTS_DIALOG * pDlg = new ALERTS_DIALOG( QueryHwnd(), _pserver );
            APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                          : pDlg->Process();

            if( err != NERR_Success && err != ERROR_LOCK_FAILED )
            {
                MsgPopup( this, err );
            }

            delete pDlg;

            RepaintNow();
            Refresh();
        }
        break;

    default:
        //
        //  If we made it this far, then we're not interested
        //  in the command.
        //

        return FALSE;
    }

    return TRUE;

}   // SERVER_PROPERTIES :: OnCommand


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: OnOK

    SYNOPSIS:   This method is called whenever the [OK] button is
                pressed.  It is responsible for updating the server
                information.

    ENTRY:      None.

    EXIT:       The server information has been updated and the
                property sheet dialog has been dismissed.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle the
                                          command.

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     22-Nov-1991 Added code to stop/pause/continue the
                                server service based on the state of
                                the two checkboxen.
        KeithMo     23-Jan-1992 Removed stop/pause/continue buttons/code.

********************************************************************/
BOOL SERVER_PROPERTIES :: OnOK( VOID )
{
    NLS_STR nlsComment;

    APIERR err = _sleComment.QueryText( &nlsComment );

    if( ( err == NERR_Success ) &&
        ( ::stricmpf( nlsComment.QueryPch(), _pserver->QueryComment() ) != 0 ) )
    {
        err = _pserver->SetComment( nlsComment.QueryPch() );

        if( err == NERR_Success )
        {
            err = _pserver->WriteInfo();
        }
    }

    if( err == NERR_Success )
    {
        Dismiss( TRUE );
    }
    else
    {
        MsgPopup( this, err );
    }

    return TRUE;

}   // SERVER_PROPERTIES :: OnOK


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    ENTRY:      None.

    EXIT:       None.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.

********************************************************************/
ULONG SERVER_PROPERTIES :: QueryHelpContext( void )
{
    return HC_SERVER_PROPERTIES;

}   // SERVER_PROPERITES :: QueryHelpContext


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: ReadInfoFromServer

    SYNOPSIS:   This method retrieves & displays server data which
                will not be automatically refreshed during the
                lifetime of the properties dialog.  This includes
                the server name and the domain role.

    ENTRY:      None.

    EXIT:       The server info has been read.

    RETURNS:    APIERR                  - Any error we encounter.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     15-Aug-1991 Removed SERVER_1 (required functionality
                                is now also in the SERVER_2 object).
        KeithMo     05-Feb-1992 Removed icon stuff.

********************************************************************/
APIERR SERVER_PROPERTIES :: ReadInfoFromServer( VOID )
{
    //
    //  Retrieve the server comment.
    //

    _sleComment.SetText( _pserver->QueryComment() );

    //
    //  Success!
    //

    return NERR_Success;

}   // SERVER_PROPERTIES :: ReadInfoFromServer


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: Refresh

    SYNOPSIS:   This method will display any server data which may
                need to be refreshed during the lifetime of the
                properties dialog.  This includes the number of
                active sessions, open files, etc.

    ENTRY:      None.

    EXIT:       The dynamic server data has been displayed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.
        KeithMo     01-Jun-1992 Only display stats if *all* are available,
                                otherwise display "??" in place of all stats.

********************************************************************/
VOID SERVER_PROPERTIES :: Refresh( VOID )
{
    //
    //  This may take a while...
    //

    AUTO_CURSOR Cursor;

    //
    //  This string will contain our "??" string.
    //

    const TCHAR * pszNotAvail = _nlsParamUnknown.QueryPch();

    //
    //  File statistics.
    //

    ULONG cOpenFiles;
    ULONG cFileLocks;
    ULONG cOpenNamedPipes;
    ULONG cOpenCommQueues;
    ULONG cOpenPrintQueues;
    ULONG cOtherResources;

    APIERR err = LM_SRVRES::GetResourceCount( _pserver->QueryName(),
                                              &cOpenFiles,
                                              &cFileLocks,
                                              &cOpenNamedPipes,
                                              &cOpenCommQueues,
                                              &cOpenPrintQueues,
                                              &cOtherResources );


    //
    //  Active sessions count.
    //

    ULONG cSessions;

    if( err == NERR_Success )
    {
        err = LM_SRVRES::GetSessionsCount( _pserver->QueryName(),
                                           &cSessions );
    }

    if( err == NERR_Success )
    {
        _sltOpenNamedPipes.Enable( TRUE );
        _sltOpenNamedPipes.SetValue( cOpenNamedPipes );

        _sltOpenFiles.Enable( TRUE );
        _sltOpenFiles.SetValue( cOpenFiles );

        _sltFileLocks.Enable( TRUE );
        _sltFileLocks.SetValue( cFileLocks );

        _sltSessions.Enable( TRUE );
        _sltSessions.SetValue( cSessions );
    }
    else
    {
        _sltOpenNamedPipes.SetText( pszNotAvail );
        _sltOpenNamedPipes.Enable( FALSE );

        _sltOpenFiles.SetText( pszNotAvail );
        _sltOpenFiles.Enable( FALSE );

        _sltFileLocks.SetText( pszNotAvail );
        _sltFileLocks.Enable( FALSE );

        _sltSessions.SetText( pszNotAvail );
        _sltSessions.Enable( FALSE );
    }

}   // SERVER_PROPERTIES :: Refresh


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: SetupButtonBar

    SYNOPSIS:   The method initializes the magic scrolling button bar.

    ENTRY:      None.

    EXIT:       The button bar has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     21-Jul-1991 Created.

********************************************************************/
APIERR SERVER_PROPERTIES :: SetupButtonBar( VOID )
{
    //
    //  Setup the graphical buttons.
    //

    InitializeButton( &_gbUsers,    IDS_BUTTON_USERS,    NULL );
    InitializeButton( &_gbFiles,    IDS_BUTTON_FILES,    NULL );
    InitializeButton( &_gbOpenRes,  IDS_BUTTON_OPENRES,  NULL );
    InitializeButton( &_gbRepl,     IDS_BUTTON_REPL,     NULL );
    InitializeButton( &_gbAlerts,   IDS_BUTTON_ALERTS,   NULL );

    //
    //  Success!
    //

    return NERR_Success;

}   // SERVER_PROPERTIES :: SetupButtonBar


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: InitializeButton

    SYNOPSIS:   Initialize a single graphical button for use in
                the graphical button bar.

    ENTRY:      pgb                     - Pointer to a GRAPHICAL_BUTTON.

                msg                     - The resource ID of the string
                                          to be used as button text.

                bmid                    - The bitmap ID for the button
                                          status bitmap.  This is the
                                          tiny bitmap displayed in the
                                          upper left corner of the button.

    EXIT:       The button has been initialized.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        KeithMo     26-Jul-1991 Created.

********************************************************************/
VOID SERVER_PROPERTIES :: InitializeButton( GRAPHICAL_BUTTON * pgb,
                                            MSGID              msg,
                                            BMID               bmid )
{
    //
    //  This NLS_STR is used to retrieve strings
    //  from the resource string table.
    //

    STACK_NLS_STR( nlsButtonText, MAX_RES_STR_LEN );

    nlsButtonText.Load( msg );
    UIASSERT( nlsButtonText.QueryError() == NERR_Success );

    pgb->SetFont( _fontHelv );
    pgb->SetStatus( bmid );
    pgb->SetText( nlsButtonText.QueryPch() );

}   // SERVER_PROPERTIES :: InitializeButton
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\smx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    smx.cxx
    This file contains the class definitions for the classes related
    to the Server Manager Extensions.


    FILE HISTORY:
        KeithMo     19-Oct-1992     Created.

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>

}   // extern "C"

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#define INCL_BLT_MENU
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <adminapp.hxx>
#include <lmodom.hxx>

#include <srvlb.hxx>
#include <srvmain.hxx>
#include <smx.hxx>

extern "C"
{
    #include <adminapp.h>
    #include <srvmgr.h>

}   // extern "C"


//
//  SM_MENU_EXT methods.
//

/*******************************************************************

    NAME:       SM_MENU_EXT :: SM_MENU_EXT

    SYNOPSIS:   SM_MENU_EXT class constructor.

    ENTRY:      psmaapp                 - The "owning" app.

                pszExtensionDll         - The name of the extension DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

                hWnd                    - The "owning" app window.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
SM_MENU_EXT :: SM_MENU_EXT( SM_ADMIN_APP * psmaapp,
                            const TCHAR  * pszExtensionDll,
                            DWORD          dwDelta,
                            HWND           hWnd )
  : AAPP_MENU_EXT( pszExtensionDll, dwDelta ),
    _psmaapp( psmaapp ),
    _dwServerType( 0 ),
    _psmxLoad( NULL ),
    _psmxGetError( NULL ),
    _psmxUnload( NULL ),
    _psmxMenuInit( NULL ),
    _psmxRefresh( NULL ),
    _psmxActivate( NULL ),
    _psmxValidate( NULL )
{
    UIASSERT( psmaapp != NULL );
    UIASSERT( pszExtensionDll != NULL );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "SM_MENU_EXT failed to construct" );
        return;
    }

    //
    //  Let's see if we can load the DLL.
    //

    HMODULE hDll = ::LoadLibraryEx( pszExtensionDll,
                                    NULL,
                                    LOAD_WITH_ALTERED_SEARCH_PATH );

    if( hDll == NULL )
    {
        DBGEOL( "SM_MENU_EXT : cannot load " << pszExtensionDll );
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetDllHandle( hDll );

    //
    //  Let's see if the entrypoints are available.
    //

    _psmxLoad     = (PSMX_LOADMENU)
                        ::GetProcAddress( hDll, SZ_SME_LOADMENU );
    _psmxGetError = (PSMX_GETEXTENDEDERRORSTRING)
                        ::GetProcAddress( hDll, SZ_SME_GETEXTENDEDERRORSTRING );
    _psmxUnload   = (PSMX_UNLOADMENU)
                        ::GetProcAddress( hDll, SZ_SME_UNLOADMENU );
    _psmxMenuInit = (PSMX_INITIALIZEMENU)
                        ::GetProcAddress( hDll, SZ_SME_INITIALIZEMENU );
    _psmxRefresh  = (PSMX_REFRESH)
                        ::GetProcAddress( hDll, SZ_SME_REFRESH );
    _psmxActivate = (PSMX_MENUACTION)
                        ::GetProcAddress( hDll, SZ_SME_MENUACTION );
    _psmxValidate = (PSMX_VALIDATE)
                        ::GetProcAddress( hDll, SZ_SME_VALIDATE );

    if( ( _psmxLoad     == NULL ) ||
        ( _psmxGetError == NULL ) ||
        ( _psmxUnload   == NULL ) ||
        ( _psmxMenuInit == NULL ) ||
        ( _psmxRefresh  == NULL ) ||
        ( _psmxActivate == NULL ) ||
        ( _psmxValidate == NULL ) )
    {
        DBGEOL( "SM_MENU_EXT : entrypoint(s) missing from " << pszExtensionDll );
        ReportError( ERROR_PROC_NOT_FOUND );
        return;
    }

    //
    //  Send a load notification.
    //

    SMS_LOADMENU smsload;

    smsload.dwVersion   = SM_MENU_EXT_VERSION;
    smsload.dwMenuDelta = dwDelta;

    APIERR err = I_Load( hWnd, &smsload );

    if( err != NERR_Success )
    {
        DBGEOL( "SM_MENU_EXT : load notification returned " << err );
        ReportError( err );

        if( err == ERROR_EXTENDED_ERROR )
        {
            //
            //  We get to do the notification ourselves.
            //

            ::MsgPopup( hWnd,
                        IDS_CANNOT_LOAD_EXTENSION2,
                        MPSEV_ERROR,
                        MB_OK,
                        pszExtensionDll,
                        I_GetError() );
        }

        return;
    }

    //
    //  Save the extension's version number.
    //

    SetVersion( smsload.dwVersion );

    //
    //  Save other data from the extension.
    //

    SetMenuHandle( smsload.hMenu );
    SetServerType( smsload.dwServerType );

    err = SetMenuName( smsload.szMenuName );

    if( err == NERR_Success )
    {
        err = SetHelpFileName( smsload.szHelpFileName );
    }

    //
    //  Adjust the menu IDs.
    //

    err = BiasMenuIds( dwDelta );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SM_MENU_EXT :: SM_MENU_EXT


/*******************************************************************

    NAME:       SM_MENU_EXT :: ~SM_MENU_EXT

    SYNOPSIS:   SM_MENU_EXT class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
SM_MENU_EXT :: ~SM_MENU_EXT( VOID )
{
    if( _psmxUnload != NULL )
    {
        I_Unload();
    }

    _psmxLoad     = NULL;
    _psmxGetError = NULL;
    _psmxUnload   = NULL;
    _psmxMenuInit = NULL;
    _psmxRefresh  = NULL;
    _psmxActivate = NULL;

}   // SM_MENU_EXT :: ~SM_MENU_EXT


/*******************************************************************

    NAME:       SM_MENU_EXT :: Refresh

    SYNOPSIS:   Sends a refresh notification to the extension.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID SM_MENU_EXT :: Refresh( HWND hwndParent ) const
{
    I_Refresh( hwndParent );

}   // SM_MENU_EXT :: Refresh


/*******************************************************************

    NAME:       SM_MENU_EXT :: MenuInit

    SYNOPSIS:   Sends a menu init notification to the extension.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID SM_MENU_EXT :: MenuInit( VOID ) const
{
    I_MenuInit();

}   // SM_MENU_EXT :: MenuInit


/*******************************************************************

    NAME:       SM_MENU_EXT :: Activate

    SYNOPSIS:   Activates the extension.

    ENTRY:      dwId                    - The id for this activation.

    HISTORY:
        KeithMo     19-Oct-1992     Created.

********************************************************************/
VOID SM_MENU_EXT :: Activate( HWND hwndParent, DWORD dwId ) const
{
    if( dwId == VMID_VIEW_EXT )
    {
        //
        //  The user is changing the view to an "extension" view.
        //

        _psmaapp->SetExtensionView( (MID)( dwId + QueryDelta() ),
                                    QueryServerType() );
    }
    else
    {
        //
        //  This is a "normal" activation.
        //

        UIASSERT( ( dwId > 0 ) && ( dwId < 100 ) )
        I_Activate( hwndParent, dwId );
    }

}   // SM_MENU_EXT :: Activate


/*******************************************************************

    NAME:       SM_MENU_EXT :: Validate

    SYNOPSIS:   Validate a potential "alien" server.

    ENTRY:      pfValid                 - Will receive TRUE if the
                                          server was recognized,
                                          FALSE otherwise.

                pszServerName           - The name of the server to
                                          validate.

                pnlsType                - Will receive the type string
                                          describing the server.

                pnlsComment             - Will receive the comment
                                          (description) of the server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     07-Dec-1992     Created.

********************************************************************/
APIERR SM_MENU_EXT :: Validate( BOOL        * pfValid,
                                const TCHAR * pszServerName,
                                NLS_STR     * pnlsType,
                                NLS_STR     * pnlsComment )
{
    UIASSERT( pfValid != NULL );
    UIASSERT( pszServerName != NULL );
    UIASSERT( pnlsType != NULL );
    UIASSERT( pnlsComment != NULL );
    UIASSERT( pnlsType->QueryError() == NERR_Success );
    UIASSERT( pnlsComment->QueryError() == NERR_Success );

    //
    //  Until proven otherwise...
    //

    *pfValid = FALSE;

    //
    //  Send the request to the extension.
    //
    SMS_VALIDATE smsvalidate;

    smsvalidate.pszServer  = pszServerName;
    smsvalidate.pszType    = NULL;
    smsvalidate.pszComment = NULL;

    if( !I_Validate( &smsvalidate ) )
    {
        //
        //  Not recognized.
        //  *pfValid already set appropriately.
        //

        return NERR_Success;
    }

    if( ( smsvalidate.pszType == NULL ) ||
        ( smsvalidate.pszComment == NULL ) )
    {
        //
        //  Recognized, but required fields not updated.
        //  *pfValid already set appropriately.
        //

        return NERR_Success;
    }

    //
    //  Copy the type & comment strings.
    //

    APIERR err = pnlsType->MapCopyFrom( smsvalidate.pszType );

    if( err == NERR_Success )
    {
        err = pnlsComment->MapCopyFrom( smsvalidate.pszComment );
    }

    if( err == NERR_Success )
    {
        //
        //  Server was recognized & strings copied successfully.
        //

        *pfValid = TRUE;
    }

    return err;

}   // SM_MENU_EXT :: Validate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\srvmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvmain.cxx
    Server Manager: main application module

    FILE HISTORY:
       kevinl          12-Apr-1991     created
       kevinl          21-May-1991     Conformed to ADMIN_APP and APP_WINDOW
       chuckc          19-Aug-1991     Added service/sendmsg stuff.
       chuckc          23-Sep-1991     Code review changes for Service related
                                       code, as attended by JimH, KeithMo,
                                       EricCh, O-SimoP.
       jonn            14-Oct-1991     Installed refresh lockcount
       KeithMo         22-Nov-1991     Moved server control to property sheet.
       jonn            23-Jan-1992     Added prototype Add/Remove Computer
*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>

}   // extern "C"

#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_TIMER
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_MENU
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmoesrv.hxx>
#include <lmosrv.hxx>
#include <lmowksu.hxx>
#include <lmoloc.hxx>
#include <lmodom.hxx>
#include <lmsvc.hxx>
#include <srvsvc.hxx>
#include <lmosrvmo.hxx>
#include <ntuser.hxx>
#include <uintlsax.hxx>
#include <apisess.hxx>

#include <dbgstr.hxx>

extern "C"
{
    #include <srvmgr.h>
    #include <lmaccess.h>
    #include <mnet.h>
    #include <string.h>

    #include <uimsg.h>
    #include <uirsrc.h>
    #include <sharefmx.hxx>

    #include <crypt.h>          // logonmsv.h needs this
    #include <logonmsv.h>       // ssi.h needs this
    #include <ssi.h>            // for SSI_ACCOUNT_NAME_PREFIX
}

#include <srvprop.hxx>      // Include Property sheet class definition
#include <srvlb.hxx>
#include <srvmain.hxx>

#define DO_HEAPCHECKS
#include <uiassert.hxx>

#include <senddlg.hxx>
#include <promote.hxx>
#include <resync.hxx>
#include <addcomp.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <svccntl.hxx>
#include <smx.hxx>
#include <slowcach.hxx>
#include <lmdomain.hxx>


//
//  This is the maximum age a listbox item may attain before
//  it is "retired" (i.e. deleted from the listbox).  If periodic
//  refresh is enabled, then we'll allow the items to age a bit
//  before they're deleted.  Otherwise (no periodic refresh) then
//  stale items will always be immediately purged.
//

#ifdef ENABLE_PERIODIC_REFRESH

#define MAX_ITEM_AGE    4

#else   // !ENABLE_PERIODIC_REFRESH

#define MAX_ITEM_AGE    0

#endif  // ENABLE_PERIODIC_REFRESH


//
//  These are the names of the .ini keys used to store
//  data private to the Server Manager.
//

const TCHAR * pszIniKeyView         = SZ("View");
const TCHAR * pszIniKeyAccountsOnly  = SZ("AccountsOnly");
const TCHAR * pszIniKeyExt          = SZ("ViewExtension");

//
//  These are the bits stored in the View bitmask.
//

#define INI_VIEW_WKSTAS_BIT     0x01
#define INI_VIEW_SERVERS_BIT    0x02


//
//  These are the default values for ViewWkstas & ViewServers.
//

#define DEFAULT_VIEW_ALL        0x03    // wkstas is bit 0, servers is bit 1
#define DEFAULT_VIEW_SERVERS    0x02


//
//  Some handy macros.
//

#define IS_NT(x) (((x) == ActiveNtServerType) || ((x) == InactiveNtServerType))
#define IS_LM(x) (((x) == ActiveLmServerType) || ((x) == InactiveLmServerType))
#define IS_WFW(x) ((x) == WfwServerType)

#define PATH_SEPARATOR          TCH('\\')
#define ADMIN_SHARE             SZ("ADMIN$")



/*******************************************************************

    NAME:          SM_ADMIN_APP::SM_ADMIN_APP

    SYNOPSIS:      Server Manager Admin App class constructor

    ENTRY:         app in startup

    EXIT:          Object Constructed

    HISTORY:
        kevinl      21-May-1991 Created
        rustanl     11-Sep-1991 Adjusted since ADMIN_APP now multiply
                                inherits from APPLICATION
        beng        07-May-1992 No longer show startup dialog; use system
                                about box
        beng        03-Aug-1992 App ctor changed

********************************************************************/

SM_ADMIN_APP::SM_ADMIN_APP( HINSTANCE  hInstance,
                            INT     nCmdShow,
                            UINT    idMinR,
                            UINT    idMaxR,
                            UINT    idMinS,
                            UINT    idMaxS )
    : ADMIN_APP( hInstance,
                 nCmdShow,
                 IDS_SMAPPNAME,
                 IDS_SMOBJECTNAME,
                 IDS_SMINISECTIONNAME,
                 IDS_SMHELPFILENAME,
                 idMinR, idMaxR, idMinS, idMaxS,
                 ID_APPMENU,
                 ID_APPACCEL,
                 IDI_SRVMGR_ICON,
                 FALSE,
                 DEFAULT_ADMINAPP_TIMER_INTERVAL,
                 SEL_DOM_ONLY,
                 FALSE,
                 BROWSE_LOCAL_DOMAINS,
                 HC_SETFOCUS_DIALOG,
                 SV_TYPE_ALL,
                 IDS_SMX_LIST ),
      _hNtLanmanDll( NULL ),
      _pfnShareManage( NULL ),
      _lbMainWindow( this, IDC_MAINWINDOWLB,
                     XYPOINT(0, 0), XYDIMENSION(200, 300), FALSE, MAX_ITEM_AGE ),
      _colheadServers( this, IDC_COLHEAD_SERVERS,
                       XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ),
                       &_lbMainWindow ),
      _dyMargin( 1 ),
      _dyColHead( _colheadServers.QueryHeight()),
      _dyFixed( 2 * _dyMargin + _dyColHead),
      _fViewWkstas( FALSE ),
      _fViewServers( FALSE ),
      _fViewAccountsOnly( FALSE ),
      _menuitemProperties(this, IDM_PROPERTIES),
      _menuitemSendMsg(this, IDM_SENDMSG),
      _menuitemPromote(this, IDM_PROMOTE),
      _menuitemResync(this, IDM_RESYNC),
      _menuitemAddComputer(this, IDM_ADDCOMPUTER),
      _menuitemRemoveComputer(this, IDM_REMOVECOMPUTER),
      _menuitemViewWkstas( this, IDM_VIEW_WORKSTATIONS ),
      _menuitemViewServers( this, IDM_VIEW_SERVERS ),
      _menuitemViewAll( this, IDM_VIEW_ALL ),
      _menuitemViewAccountsOnly( this, IDM_VIEW_ACCOUNTS_ONLY ),
      _menuitemSelectDomain( this, IDM_SETFOCUS ),
      _menuitemServices( this, IDM_SVCCNTL ),
      _menuitemShares( this, IDM_SHARES ),
      _nlsSyncDC( IDS_SYNC_WITH_DC ),
      _nlsSyncDomain( IDS_SYNC_ENTIRE_DOMAIN ),
      _nlsPromote( IDS_PROMOTE_TO_CONTROLLER ),
      _nlsDemote( IDS_DEMOTE_TO_SERVER ),
      _fSyncDCMenuEnabled( TRUE ),
      _fPromoteMenuEnabled( TRUE ),
      _nlsComputerName(),
      _fLoggedOnLocally( FALSE ),
      _fHasWkstaDomain( TRUE ),
      _midView( 0 ),
      _menuView( ::GetSubMenu( ::GetMenu( QueryHwnd() ), 1 ) ),
      _fDelaySlowModeDetection( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
       DBGEOL("SM_ADMIN_APP::SM_ADMIN_APP - Construction failed") ;
       return ;
    }

    APIERR err = BLT::RegisterHelpFile( hInstance,
                                        IDS_SMHELPFILENAME,
                                        HC_UI_SRVMGR_BASE,
                                        HC_UI_SRVMGR_LAST );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if( ( ( err = _nlsSyncDC.QueryError()       ) != NERR_Success ) ||
        ( ( err = _nlsSyncDomain.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsPromote.QueryError()      ) != NERR_Success ) ||
        ( ( err = _nlsDemote.QueryError()       ) != NERR_Success ) ||
        ( ( err = _nlsComputerName.QueryError() ) != NERR_Success ) ||
        ( ( err = _menuView.QueryError()        ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    err = GetWkstaInfo();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  We need to load the extensions *before* we set the view,
    //  since one of the loaded extensions may be the active view.
    //

    LoadExtensions();

    //
    //  nView is a bitmask for the _fView* flags.  _fViewWkstas
    //  is in bit position 0, _fViewServers is in bit position 1.
    //
    //  If nView is NULL, then "ViewExtension" should contain the
    //  name of an extension DLL.  If this DLL is not loaded, then
    //  we revert to the default view.
    //

    INT nView = InRasMode() ? DEFAULT_VIEW_SERVERS : DEFAULT_VIEW_ALL;

    if( Read( pszIniKeyView, &nView, nView ) == NERR_Success )
    {
        if( nView == 0 )
        {
            //
            //  Get the extension DLL.
            //

            NLS_STR nlsDll;

            err = nlsDll.QueryError();

            if( err == NERR_Success )
            {
                err = Read( pszIniKeyExt, &nlsDll, SZ("") );
            }

            if( err == NERR_Success )
            {
                SM_MENU_EXT * pExt = (SM_MENU_EXT *)FindExtensionByName( nlsDll );

                if( pExt != NULL )
                {
                    //
                    //  The extension was loaded.
                    //

                    _midView = (MID)( pExt->QueryDelta() + VMID_VIEW_EXT );
                    _dwViewedServerTypeMask = pExt->QueryServerType();
                }
            }

            //
            //  Ignore any error we got retrieving the "viewed"
            //  extension name.
            //

            err = NERR_Success;
        }
    }

    //
    //  Ensure that we got a sane value.
    //

    if( ( nView == 0 ) && ( _midView == 0 ) )
    {
        nView = InRasMode() ? DEFAULT_VIEW_SERVERS : DEFAULT_VIEW_ALL;
    }

    _fViewWkstas  = ( ( nView & INI_VIEW_WKSTAS_BIT  ) != 0 );
    _fViewServers = ( ( nView & INI_VIEW_SERVERS_BIT ) != 0 );

    INT nAccountsOnly = 0 ;

    if( Read( pszIniKeyAccountsOnly,
              &nAccountsOnly,
              nAccountsOnly ) == NERR_Success )
    {
        _fViewAccountsOnly = (nAccountsOnly != 0) ;
    }

    UIASSERT( _fViewWkstas || _fViewServers || ( _midView != 0 ) );

    //
    //  Now that we have our view settings, we can refresh the
    //  listbox.
    //

//    RefreshMainListbox( TRUE );

    _lbMainWindow.SetSize( QuerySize() );

    _colheadServers.Show();
    _lbMainWindow.Show();
    _lbMainWindow.ClaimFocus();

//    if ( _lbMainWindow.QueryCount() > 0 )
//         _lbMainWindow.SelectItem( 0 );
}


/*******************************************************************

    NAME:       SM_ADMIN_APP::~SM_ADMIN_APP

    SYNOPSIS:   SM_ADMIN_APP destructor

    HISTORY:
        rustanl     11-Sep-1991     Created

********************************************************************/

SM_ADMIN_APP::~SM_ADMIN_APP()
{
    if( IsSavingSettingsOnExit() )
    {
        INT nView = 0;
        const TCHAR * pszViewedDll = NULL;

        if( _midView != 0 )
        {
            AAPP_MENU_EXT * pExt = FindExtensionByDelta( _midView );
            UIASSERT( pExt != NULL );
            pszViewedDll = pExt->QueryDllName();
        }
        else
        {
            if( _fViewWkstas )
            {
                nView |= INI_VIEW_WKSTAS_BIT;
            }

            if( _fViewServers )
            {
                nView |= INI_VIEW_SERVERS_BIT;
            }
        }

        Write( pszIniKeyView, nView );
        Write( pszIniKeyAccountsOnly, (ViewAccountsOnly() ? 1 : 0) );
        Write( pszIniKeyExt, pszViewedDll );
    }

    //
    //  Free NTLANMAN.DLL.
    //

    _pfnShareManage = NULL;
    ::FreeLibrary( _hNtLanmanDll );
    _hNtLanmanDll = NULL;
}


void SM_ADMIN_APP::OnRefresh( void )
{
#ifdef ENABLE_PERIODIC_REFRESH

    _lbMainWindow.KickOffRefresh();

#endif  // ENABLE_PERIODIC_REFRESH
}


/*******************************************************************

    NAME:       SM_ADMIN_APP::OnRefreshNow

    SYNOPSIS:   Called to synchronously refresh the data in the main window

    ENTRY:      fClearFirst -       TRUE indicates that main window should
                                    be cleared before any refresh operation
                                    is done; FALSE indicates an incremental
                                    refresh that doesn't necessarily
                                    require first clearing the main window

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     12-Sep-1991     Created

********************************************************************/

APIERR SM_ADMIN_APP::OnRefreshNow( BOOL fClearFirst )
{
    if ( fClearFirst )
    {
        _lbMainWindow.DeleteAllItems();
    }

    INT dAge = _lbMainWindow.QueryAgeOfRetirement();

    _lbMainWindow.SetAgeOfRetirement( 0 );
    APIERR err = _lbMainWindow.RefreshNow();
    _lbMainWindow.SetAgeOfRetirement( dAge );

    return err;

}  // SM_ADMIN_APP::OnRefreshNow


/*******************************************************************

    NAME:       SM_ADMIN_APP::StopRefresh

    SYNOPSIS:   Called to force all automatic refresh cycles to
                terminate

    HISTORY:
        rustanl     12-Sep-1991     Created

********************************************************************/

VOID SM_ADMIN_APP::StopRefresh()
{
    _lbMainWindow.StopRefresh();

}  // SM_ADMIN_APP::StopRefresh


/*******************************************************************

    NAME:       SM_ADMIN_APP::SizeListboxes

    SYNOPSIS:   Resizes the main window listboxes and column headers

    ENTRY:      xydimWindow - dimensions of the main window client area

    EXIT:       Listboxes and column headers are resized appropriately

    NOTES:      This method is *not* trying to be overly efficient.  It
                is written so as to maximize readability and
                understandability.  The method is not called very often,
                and when it is, the time needed to redraw the main window
                and its components exceeds the computations herein by far.

    HISTORY:
        gregj       24-May-1991     Created
        rustanl     22-Jul-1991     Added column header logic

********************************************************************/

//  A macro specialized for the SizeListboxes method
#define SET_CONTROL_SIZE_AND_POS( ctrl, dyCtrl )        \
            ctrl.SetPos( XYPOINT( dxMargin, yCurrent ));       \
            ctrl.SetSize( dx, dyCtrl );       \
            yCurrent += dyCtrl;

void SM_ADMIN_APP::SizeListboxes( XYDIMENSION dxyWindow )
{
    UINT dxMainWindow = dxyWindow.QueryWidth();
    UINT dyMainWindow = dxyWindow.QueryHeight();

    //  The left and right margins are each dxMargin.  The width of
    //  each control is thus the width of the main window client area
    //  less twice dxMargin.
    //  The width thus looks like:
    //      Left Margin         Control         Right Margin
    //       (dxMargin)          (dx)            (dxMargin)

    const UINT dxMargin = 1;                // width of left/right margins
    UINT dx = dxMainWindow - 2 * dxMargin;

    //  Height looks like:
    //      Top margin                  _dyMargin
    //      Server Column Header                _dyColHead
    //      Server Listbox              variable area
    //      Bottom margin               _dyMargin


    UINT dyServerListbox = dyMainWindow - _dyFixed;

    //  Set all the sizes and positions.

    UINT yCurrent = _dyMargin;

    SET_CONTROL_SIZE_AND_POS( _colheadServers, _dyColHead );
    SET_CONTROL_SIZE_AND_POS( _lbMainWindow, dyServerListbox );
}


/*******************************************************************

    NAME:          SM_ADMIN_APP::OnResize

    SYNOPSIS:      Resizes the Main Window Listbox to fit the new
                   window size.

    ENTRY:         Object constructed

    EXIT:          Returns TRUE if it handled the message

    HISTORY:
       kevinl      27-May-1991     Created

********************************************************************/

BOOL SM_ADMIN_APP::OnResize( const SIZE_EVENT & se )
{
    SizeListboxes( XYDIMENSION( se.QueryWidth(), se.QueryHeight()));

    //  Since the column headers draw different things depending on
    //  the right margin, invalidate the controls so they get
    //  completely repainted.
    _colheadServers.Invalidate();

    return ADMIN_APP::OnResize( se );
}

/*******************************************************************

    NAME:          SM_ADMIN_APP::OnFocus

    SYNOPSIS:      Passes focus on to the Main Window so that the
                   keyboard will work.

    ENTRY:         Object constructed

    EXIT:          Returns TRUE if it handled the message

    HISTORY:
       kevinl      4-Jun-1991     Created

********************************************************************/

BOOL SM_ADMIN_APP::OnFocus( const FOCUS_EVENT & event )
{
    _lbMainWindow.ClaimFocus();

    return ADMIN_APP::OnFocus( event );
}


/*******************************************************************

    NAME:       SM_ADMIN_APP::OnMenuInit

    SYNOPSIS:   Enables or disables menu items according to which
                menu items can be selected at this time.  This method
                is called when a menu is about to be accessed.

    ENTRY:      me -        Menu event

    EXIT:       Menu items have been enabled/disabled according to
                available functionality, which is determined by
                examining the selection of the listboxes.

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     05-Sep-1991     Created
        jonn        23-Jan-1992     Added prototype Add/Remove Computer

********************************************************************/

BOOL SM_ADMIN_APP::OnMenuInit( const MENU_EVENT & me )
{
    SERVER_LBI * plbiSelect ;

    /*
     * Call parent class, but ignore return code, since we know for
     * sure that this method will handle the message
     */
    ADMIN_APP::OnMenuInit( me );

    //
    //  Notify the extensions.
    //

    MenuInitExtensions();

    /*
     * This menu item has nothing to do with the listbox selection
     */
    _menuitemAddComputer.Enable( ( QueryFocusType() == FOCUS_DOMAIN ) &&
                                 ( _lbMainWindow.IsNtPrimary() ) );

    //
    //  We need to determine the appropriate "resync" menu item text
    //  and resync/promote menu item state.
    //

    _fSyncDCMenuEnabled  = TRUE;
    _fPromoteMenuEnabled = TRUE;

    const TCHAR * pszSyncText    = _nlsSyncDC;
    const TCHAR * pszPromoteText = _nlsPromote;
    BOOL          fEnablePromote = FALSE;
    BOOL          fEnableResync  = FALSE;

    /*
     * check for empty listbox, no selection
     */

    plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();

    if( ( plbiSelect == NULL ) ||
        !(plbiSelect->IsLanMan()) )
    {
        _menuitemProperties.Enable(FALSE) ;
        _menuitemSendMsg.Enable(FALSE) ;
        _menuitemRemoveComputer.Enable(FALSE) ;
        _menuitemServices.Enable( FALSE );
        _menuitemShares.Enable( FALSE );
    }
    else
    {
        _menuitemProperties.Enable(TRUE) ;
        _menuitemSendMsg.Enable(TRUE) ;
        _menuitemServices.Enable( TRUE );
        _menuitemShares.Enable( TRUE );

        SERVER_ROLE roleSel = plbiSelect->QueryServerRole();
        SERVER_TYPE typeSel = plbiSelect->QueryServerType();

        //
        //  Only enable the "Remove Computer" menu item if all of the
        //  following are TRUE:
        //
        //      We're focused on a DOMAIN.
        //      The selected machine is either a Server or a NT Wksta.
        //

        if( ( QueryFocusType() == FOCUS_DOMAIN ) &&
            ( IS_NT( typeSel ) || IS_LM( typeSel ) ) &&
            ( ( roleSel == BackupRole )     ||
              ( roleSel == DeadBackupRole ) ||
              ( IS_NT( typeSel ) &&
                (   ( roleSel == WkstaRole )
                 || ( roleSel == ServerRole )
                 || ( roleSel == WkstaOrServerRole )) ) ) )
        {
            _menuitemRemoveComputer.Enable( TRUE );
        }
        else
        {
            _menuitemRemoveComputer.Enable( FALSE );
        }

        if( QueryFocusType() == FOCUS_DOMAIN )
        {
            //
            //  Promote & Resync are only valid for domains.
            //

            if( _lbMainWindow.IsPDCAvailable() )
            {
                //
                //  The PDC is available.  This makes life
                //  a little easier...
                //

                BOOL fEnableDomainOps = FALSE;

                if( _lbMainWindow.IsNtPrimary() )
                {
                    //
                    //  This is an NT domain (with an NT PDC), so
                    //  domain operations are only allowed for NT
                    //  machines.
                    //

                    fEnableDomainOps = IS_NT( typeSel );

                    if( roleSel == PrimaryRole )
                    {
                        pszSyncText         = _nlsSyncDomain;
                        _fSyncDCMenuEnabled = FALSE;
                    }
                    else
                    if( roleSel == DeadPrimaryRole )
                    {
                        pszPromoteText       = _nlsDemote;
                        _fPromoteMenuEnabled = FALSE;
                    }
                }
                else
                {
                    //
                    //  This is an LM domain, domain operations
                    //  are only allowed for LM machines.
                    //

                    fEnableDomainOps = !IS_NT( typeSel );
                }

                //
                //  Promote is only valid for servers and dead primaries
                //  (demote).  Resync is only valid for servers & NT
                //  primaries.
                //

                fEnablePromote = ( fEnableDomainOps &&
                                   ( ( roleSel == BackupRole ) ||
                                     ( roleSel == DeadBackupRole ) ) ) ||
                                 !_fPromoteMenuEnabled;

#ifdef CODEWORK_ALLOW_OS2_RESYNC
                //
                //  We can resync a LanMan server to an NT domain
                //
                fEnableResync  = (fEnableDomainOps || _lbMainWindow.IsNtPrimary())
                              && ( ( roleSel == BackupRole ) ||
#else
                fEnableResync  = fEnableDomainOps &&
                                 ( ( roleSel == BackupRole ) ||
#endif
                                   ( roleSel == DeadBackupRole ) ||
                                   ( IS_NT( typeSel ) &&
                                     ( roleSel == PrimaryRole ) ) );
            }
            else
            {
                //
                //  No PDC available.  We must be careful to
                //  prevent the user from totally screwing the domain.
                //  Note that if the PDC is unavailable, then Resync
                //  is *always* disabled.
                //

                if( _lbMainWindow.AreAnyNtBDCsAvailable() )
                {
                    fEnablePromote = IS_NT( typeSel ) &&
                                     ( roleSel == BackupRole );
                }
                else
                if( _lbMainWindow.AreAnyLmBDCsAvailable() )
                {
                    fEnablePromote = !IS_NT( typeSel );
                }
            }
        }

        //
        // JonN 11/3/99
        // Disable promotion for NT5 domains and BDCs
        // Disable resync for NT5 BDCs
        //
        if ( 5 <= plbiSelect->QueryMajorVer() )
        {
            fEnableResync = FALSE;
            fEnablePromote = FALSE;
        }
        else if ( _lbMainWindow.IsNt5Primary() )
            fEnablePromote = FALSE;

    }

    _menuitemResync.SetText( pszSyncText );
    _menuitemResync.Enable( fEnableResync );
    _menuitemPromote.SetText( pszPromoteText );
    _menuitemPromote.Enable( fEnablePromote );
    _menuitemSelectDomain.Enable( _fHasWkstaDomain );

    //
    //  Determine the appropriate state for the "view" menu items.
    //

    UINT cViewItems = _menuView.QueryItemCount();

    if( QueryFocusType() == FOCUS_DOMAIN )
    {
        BOOL fEnableStandardView = FALSE;
        MID  midViewToCheck      = QueryExtensionView(); // until proven otherwise...

        if( _lbMainWindow.IsNtPrimary() )
        {
            fEnableStandardView = TRUE;

            if( midViewToCheck == 0 )
            {
                //
                //  A "normal" view is selected.
                //

                if( ViewWkstas() )
                {
                    if( ViewServers() )
                    {
                        midViewToCheck = IDM_VIEW_ALL;
                    }
                    else
                    {
                        midViewToCheck = IDM_VIEW_WORKSTATIONS;
                    }
                }
                else
                {
                    UIASSERT( ViewServers() );
                    midViewToCheck = IDM_VIEW_SERVERS;
                }
            }
        }
        else
        {
            if( midViewToCheck == 0 )
            {
                midViewToCheck = IDM_VIEW_ALL;
            }
        }

        //
        //  Enable the standard items.
        //

        _menuitemViewWkstas.Enable( fEnableStandardView );
        _menuitemViewServers.Enable( fEnableStandardView );

        //
        // set the view accounts only menuitem as appropriate
        //

        _menuitemViewAccountsOnly.Enable( TRUE );
        _menuitemViewAccountsOnly.SetCheck( ViewAccountsOnly() );

        //
        //  Enable all of the extension items.  While we're at it,
        //  check the appropriate item and uncheck all others.
        //  We use -4 since the last 2 are Separator & Refresh, and
        //  before that is the Separator & AccountsOnly menuitem.
        //

        for( UINT i = 0 ; i < cViewItems - 4 ; i++ )
        {
            UINT idItem = _menuView.QueryItemID( i );

            _menuView.CheckItem( idItem, idItem == (UINT)midViewToCheck );

            if( i > 1 )
            {
                _menuView.EnableItem( idItem );
            }
        }
    }
    else
    {
        //
        //  Focus is on a single server.  Disable all view items.
        //
        //  We use "- 2" because the last two menu items are a
        //  separator and the "Refresh" item.
        //

        for( UINT i = 0 ; i < cViewItems - 2 ; i++ )
        {
            _menuView.EnableItem( i, FALSE, MF_BYPOSITION );
        }
    }

    return TRUE;

}  // UM_ADMIN_APP::OnMenuInit



/*******************************************************************

    NAME:          SM_ADMIN_APP::OnMenuCommand

    SYNOPSIS:      Control messages and menu messages come here

    ENTRY:         Object constructed

    EXIT:          Returns TRUE if it handled the message

    HISTORY:
       kevinl       21-May-1991     Created
       rustanl      12-Sep-1991     Moved asserts into IDM_SENDMSG case
       jonn         14-Oct-1991     Installed refresh lockcount
       jonn         23-Jan-1992     Added prototype Add/Remove Computer

********************************************************************/

BOOL SM_ADMIN_APP::OnMenuCommand( MID midMenuItem )
{

    LockRefresh();
    // Now don't return before UnlockRefresh()!

    //
    // Check whether the server name is valid or not if we need to use it.
    // The server name may have been a name added to the SERVER group which
    // does not actually represents a valid server name.
    //
    switch ( midMenuItem )
    {
    case IDM_SHARES:
    case IDM_SVCCNTL:
    case IDM_SENDMSG:
    case IDM_PROMOTE:
    case IDM_RESYNC:
    case IDM_REMOVECOMPUTER:
        {
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            if (NERR_Success != ::I_MNetNameValidate( NULL,
                                                      plbiSelect->QueryServer(),
                                                      NAMETYPE_COMPUTER,
                                                      0L ) )
            {
                ::MsgPopup( this, ERROR_BAD_NETPATH );
                UnlockRefresh();
                return TRUE;
            }
            break;
        }

    default:
            break;
    }

    switch ( midMenuItem )
    {
    case IDM_SHARES:
        {
            if( _pfnShareManage == NULL )
            {
                //
                //  Either NTLANMAN has not been loaded or we had
                //  an error trying to load it previously.
                //

                UIASSERT( _hNtLanmanDll == NULL );

                APIERR err = NERR_Success;

                //
                //  Try to load it.
                //

                _hNtLanmanDll = ::LoadLibrary( NTLANMAN_DLL_SZ );
                if( _hNtLanmanDll == NULL )
                {
                    //
                    //  Nope, can't find it.
                    //

                    err = (APIERR)::GetLastError();
                }
                else
                {
                    //
                    //  Got the library, now try to find the
                    //  share management entrypoint.
                    //

                    _pfnShareManage =
                            (PSHARE_MANAGE)::GetProcAddress( _hNtLanmanDll,
                                                             SHARE_MANAGE_SZ );

                    if( _pfnShareManage == NULL )
                    {
                        //
                        //  Bad news.  Free the library before
                        //  continuing.
                        //

                        err = (APIERR)::GetLastError();
                        ::FreeLibrary( _hNtLanmanDll );
                        _hNtLanmanDll = NULL;
                    }
                }

                if( err != NERR_Success )
                {
                    UIASSERT( ( _hNtLanmanDll == NULL ) &&
                              ( _pfnShareManage == NULL ) );

                    ::MsgPopup( this, err );
                    break;
                }
            }

            //
            //  Invoke the "Create Shares" dialog via NTLANMAN.
            //
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            APIERR err;

            NLS_STR nlsWithPrefix( SZ("\\\\") );
            if ( (err = nlsWithPrefix.QueryError()) == NERR_Success )
            {
                err = nlsWithPrefix.Append( plbiSelect->QueryServer() );
            }

            if ( err == NERR_Success )
            {
                UIASSERT( _pfnShareManage != NULL );
                (_pfnShareManage)( QueryHwnd(), nlsWithPrefix );
            }

            if ( err != NERR_Success )
                ::MsgPopup( this, err );

        }
        break;

    case IDM_SVCCNTL:
        {
            AUTO_CURSOR NiftyCursor;
            PROMPT_AND_CONNECT * pPromptDlg = NULL ;

            //
            //  Create the server name *with* the leading backslashes.
            //

            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            BOOL fRefresh = FALSE;

            NLS_STR nlsWithPrefix( SZ("\\\\") );

            APIERR err = nlsWithPrefix.QueryError();

            if( err == NERR_Success )
            {
                err = nlsWithPrefix.Append( plbiSelect->QueryServer() );
            }

            if( err == NERR_Success )
            {
                //
                //  Create the SERVER_2 object for the
                //  target server.
                //

                SERVER_2 srv2( nlsWithPrefix.QueryPch() );
                err = srv2.QueryError();

                if ( err != NERR_Success )
                {
                    ::MsgPopup( this, err );
                    break;
                }

                err = srv2.GetInfo();

                if ( (err == ERROR_ACCESS_DENIED) ||
                     (err == ERROR_INVALID_PASSWORD) )
                {
                    //
                    //  Determine if the machine is user- or share-level.
                    //
                    BOOL fIsShareLevel = FALSE;    // until proven otherwise...
                    LOCATION loc( srv2.QueryName() );
                    BOOL fIsNT;
                    APIERR err1 ;

                    err1 = loc.QueryError();
                    if( err1 == NERR_Success )
                        err1 = loc.CheckIfNT( &fIsNT );

                    if( err1 == NERR_Success &&  !fIsNT )
                    {
                        //
                        //  Not NT. see if share level. Do so by calling
                        //  NetUserEnum which is unsupported on share-level
                        //
                        USER0_ENUM usr0( srv2.QueryName() );
                        err1 = usr0.QueryError();

                        if( err1 == NERR_Success )
                        {
                            err1 = usr0.GetInfo();

                            if( err1 == ERROR_NOT_SUPPORTED )
                                fIsShareLevel = TRUE;
                        }
                    }

                    if( fIsShareLevel )
                    {
                        //
                        //  At this point, we know that it is share-level.
                        //  Connect to ADMIN$ share (prompt for password).
                        //
                        NLS_STR nlsAdmin(  nlsWithPrefix.QueryPch() );
                        nlsAdmin.AppendChar( PATH_SEPARATOR );
                        nlsAdmin.strcat( ADMIN_SHARE );

                        if( nlsAdmin.QueryError() == NERR_Success )
                        {
                            pPromptDlg =
                                new PROMPT_AND_CONNECT( QueryHwnd(),
                                                        nlsAdmin,
                                                        HC_PASSWORD_DIALOG,
                                                        SHPWLEN );

                            err1 = (pPromptDlg == NULL)
                                       ? ERROR_NOT_ENOUGH_MEMORY
                                       : pPromptDlg->QueryError();

                            if( err1 == NERR_Success )
                                err1 = pPromptDlg->Connect();

                            //
                            //  If we're really connected, retry
                            //  the GetInfo().  Otherwise, assume
                            //  the user bagged-out.
                            //

                            if ( (err1 == NERR_Success) &&
                                 pPromptDlg->IsConnected() )
                            {
                                 err = srv2.GetInfo();
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                }

                if( err == NERR_Success )
                {
                    //
                    //  Invoke the Service Control dialog.
                    //

                    SVCCNTL_DIALOG * pDlg = new SVCCNTL_DIALOG( QueryHwnd(),
                                                                &srv2 );

                    err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                           : pDlg->Process( &fRefresh );

                    delete pDlg;
                }

                if (pPromptDlg)
                {
                    delete pPromptDlg ;
                    pPromptDlg = NULL ;
                }
            }

            if( fRefresh && ( err == NERR_Success ) )
            {
                err = RefreshMainListbox();
            }

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }
        }
        break;

    case IDM_SENDMSG:
        {
            AUTO_CURSOR NiftyCursor;
            PROMPT_AND_CONNECT * pPromptDlg = NULL ;

            //
            //  Create the server name *with* the leading backslashes.
            //

            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            NLS_STR nlsWithPrefix( SZ("\\\\") );

            APIERR err = nlsWithPrefix.QueryError();

            if( err == NERR_Success )
            {
                err = nlsWithPrefix.Append( plbiSelect->QueryServer() );
            }

            if( err == NERR_Success )
            {
                //
                //  Create the SERVER_2 object for the
                //  target server.
                //

                SERVER_2 srv2( nlsWithPrefix.QueryPch() );
                err = srv2.QueryError();

                if ( err != NERR_Success )
                {
                    ::MsgPopup( this, err );
                    break;
                }

                err = srv2.GetInfo();

                if ( (err == ERROR_ACCESS_DENIED) ||
                     (err == ERROR_INVALID_PASSWORD) )
                {
                    //
                    //  Determine if the machine is user- or share-level.
                    //
                    BOOL fIsShareLevel = FALSE;    // until proven otherwise...
                    LOCATION loc( srv2.QueryName() );
                    BOOL fIsNT;
                    APIERR err1 ;

                    err1 = loc.QueryError();
                    if( err1 == NERR_Success )
                        err1 = loc.CheckIfNT( &fIsNT );

                    if( err1 == NERR_Success &&  !fIsNT )
                    {
                        //
                        //  Not NT. see if share level. Do so by calling
                        //  NetUserEnum which is unsupported on share-level
                        //
                        USER0_ENUM usr0( srv2.QueryName() );
                        err1 = usr0.QueryError();

                        if( err1 == NERR_Success )
                        {
                            err1 = usr0.GetInfo();

                            if( err1 == ERROR_NOT_SUPPORTED )
                                fIsShareLevel = TRUE;
                        }
                    }

                    if( fIsShareLevel )
                    {
                        //
                        //  At this point, we know that it is share-level.
                        //  Connect to ADMIN$ share (prompt for password).
                        //
                        NLS_STR nlsAdmin(  nlsWithPrefix.QueryPch() );
                        nlsAdmin.AppendChar( PATH_SEPARATOR );
                        nlsAdmin.strcat( ADMIN_SHARE );

                        if( nlsAdmin.QueryError() == NERR_Success )
                        {
                            pPromptDlg =
                                new PROMPT_AND_CONNECT( QueryHwnd(),
                                                        nlsAdmin,
                                                        HC_PASSWORD_DIALOG,
                                                        SHPWLEN );

                            err1 = (pPromptDlg == NULL)
                                       ? ERROR_NOT_ENOUGH_MEMORY
                                       : pPromptDlg->QueryError();

                            if( err1 == NERR_Success )
                                err1 = pPromptDlg->Connect();

                            //
                            //  If we're really connected, retry
                            //  the GetInfo().  Otherwise, assume
                            //  the user bagged-out.
                            //

                            if ( (err1 == NERR_Success) &&
                                 pPromptDlg->IsConnected() )
                            {
                                 err = srv2.GetInfo();
                            }
                            else
                            {
                                break;
                            }
                        }
                    }

                }

                if( err == NERR_Success )
                {
                    //
                    //  Invoke the Send Message dialog.
                    //

                    SRV_SEND_MSG_DIALOG * pDlg =
                            new SRV_SEND_MSG_DIALOG( QueryHwnd(),
                                                     plbiSelect->QueryServer() );

                    err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                           : pDlg->Process();

                    delete pDlg;
                }

                if (pPromptDlg)
                {
                    delete pPromptDlg ;
                    pPromptDlg = NULL ;
                }
            }

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }
            break;
        }

    case IDM_PROMOTE:
        {
            UIASSERT( _lbMainWindow.QueryCount() > 0 );
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            APIERR err = _fPromoteMenuEnabled ? Promote( plbiSelect )
                                              : Demote( plbiSelect );

            if( err != NERR_Success )
            {
                ::MsgPopup( this, err );
            }

            break;
        }

    case IDM_RESYNC:
        {
            UIASSERT( _lbMainWindow.QueryCount() > 0 );
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            APIERR err = _fSyncDCMenuEnabled ? ResyncWithDC( plbiSelect )
                                             : ResyncEntireDomain();

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }

            break;
        }

    case IDM_ADDCOMPUTER:
        {
            ASSERT(QueryFocusType() == FOCUS_DOMAIN) ;

            STACK_NLS_STR( nlsFocus, MAX_PATH );
            REQUIRE( QueryCurrentFocus( &nlsFocus ) == NERR_Success );
            BOOL fRefresh;

            ADD_COMPUTER_DIALOG * pDlg = new ADD_COMPUTER_DIALOG( QueryHwnd(),
                                                                  nlsFocus,
                                                                  ViewServers(),
                                                                  ViewWkstas(),
                                                                  &fRefresh );

            APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                          : pDlg->Process();

            delete pDlg;

            if( ( err == NERR_Success ) && fRefresh )
            {
                err = RefreshMainListbox();
            }

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }

            break;
        }

    case IDM_REMOVECOMPUTER:
        {
            ASSERT(QueryFocusType() == FOCUS_DOMAIN) ;
            UIASSERT( _lbMainWindow.QueryCount() > 0 );
            INT iCurrent = _lbMainWindow.QueryCurrentItem();
            UIASSERT( iCurrent >= 0 );
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();
            UIASSERT( plbiSelect != NULL );

            STACK_NLS_STR( nlsFocus, MAX_PATH );
            REQUIRE( QueryCurrentFocus( &nlsFocus ) == NERR_Success );

            SERVER_ROLE role = plbiSelect->QueryServerRole();
            UIASSERT(   ( role == BackupRole )
                     || ( role == DeadBackupRole )
                     || ( role == WkstaRole )
                     || ( role == ServerRole )
                     || ( role == WkstaOrServerRole ) );

            BOOL fRefresh;
            APIERR err = ::RemoveComputer( QueryHwnd(),
                                           plbiSelect->QueryServer(),
                                           nlsFocus.QueryPch(),
                                           ( role == BackupRole ) ||
                                               ( role == DeadBackupRole ),
                                           IS_NT( plbiSelect->QueryServerType() ),
                                           &fRefresh );

            if( ( err == NERR_Success ) && fRefresh )
            {
                err = RefreshMainListbox();

                if( err == NERR_Success )
                {
                    //
                    //  Ensure we have a listbox item selected.
                    //

                    if( iCurrent > 0 )
                    {
                        iCurrent--;
                    }

                    INT cItems = _lbMainWindow.QueryCount();

                    if( ( iCurrent >= cItems ) && ( cItems > 0 ) )
                    {
                        iCurrent = cItems - 1;
                    }

                    if( ( cItems > 0 ) && ( iCurrent >= 0 ) )
                    {
                        _lbMainWindow.SelectItem( iCurrent );
                    }
                }
            }

            if( err != NERR_Success )
            {
                MsgPopup( this, err );
            }

            break;
        }

    case IDM_VIEW_WORKSTATIONS :
        _midView = 0;
        if( !( _fViewWkstas && !_fViewServers ) )
        {
            _fViewWkstas  = TRUE;
            _fViewServers = FALSE;
            SetAdminCaption();
            RefreshMainListbox( TRUE );
        }
        break;

    case IDM_VIEW_SERVERS :
        _midView = 0;
        if( !( !_fViewWkstas && _fViewServers ) )
        {
            _fViewWkstas  = FALSE;
            _fViewServers = TRUE;
            SetAdminCaption();
            RefreshMainListbox( TRUE );
        }
        break;

    case IDM_VIEW_ALL :
        _midView = 0;
        if( !( _fViewWkstas && _fViewServers ) )
        {
            _fViewWkstas  = TRUE;
            _fViewServers = TRUE;
            SetAdminCaption();
            RefreshMainListbox( TRUE );
        }
        break;

    case IDM_VIEW_ACCOUNTS_ONLY :
        _fViewAccountsOnly = ! _fViewAccountsOnly ;
        RefreshMainListbox( TRUE );
        break;

    default:
       break ;
    }

    UnlockRefresh();

    return ADMIN_APP::OnMenuCommand( midMenuItem ) ;
}

/*******************************************************************

    NAME:       SM_ADMIN_APP::Mid2HC

    SYNOPSIS:   Maps a given menu ID to a help context.  Overrides
                the mapping for IDM_RESYNC, since this menu item
                changes based on the current selection.

    ENTRY:      mid                     - The menu ID to map.

                phc                     - Will receive the help context
                                          if this method is successful.

    RETURNS:    BOOL                    - TRUE  if *phc is valid (mapped),
                                          FALSE if could not map.

    HISTORY:
        KeithMo     23-Oct-1992     Created.


********************************************************************/
BOOL SM_ADMIN_APP::Mid2HC( MID mid, ULONG * phc ) const
{
    UIASSERT( phc != NULL );

    ULONG hc = 0;

    switch( mid )
    {
    case IDM_RESYNC :
        hc = _fSyncDCMenuEnabled ? HC_COMPUTER_SYNC_WITH_DC
                                 : HC_COMPUTER_SYNC_DOMAIN;
        break;

    case IDM_PROMOTE :
        hc = _fPromoteMenuEnabled ? HC_COMPUTER_PROMOTE
                                  : HC_COMPUTER_DEMOTE;
        break;

    default :
        return ADMIN_APP::Mid2HC( mid, phc );
    }

    UIASSERT( hc != 0 );

    *phc = hc;
    return TRUE;
}

/*******************************************************************

    NAME:          SM_ADMIN_APP :: ResyncWithDC

    SYNOPSIS:      Resyncs a specific server with its domain controller.

    ENTRY:         plbi                 - The selected listbox item.

    EXIT:          Server's SAM database is in sync.

    RETURNS:       APIERR               - Any errors encountered.

    HISTORY:
        KeithMo     30-Apr-1992     Created.
        KeithMo     07-Jan-1993     Reset machine passwords if necessary.

********************************************************************/
APIERR SM_ADMIN_APP :: ResyncWithDC( const SERVER_LBI * plbi )
{
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  IDS_VERIFY_DC_RESYNC,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryName(),
                  MP_NO ) != IDYES )
    {
        return NERR_Success;
    }

    //
    //  This may take a few seconds...
    //

    AUTO_CURSOR NiftyCursor;

    //
    // Remember server name since it won't be valid after refresh. JonN 8/4/94
    //

    NLS_STR nlsServerName( plbi->QueryName() );
    APIERR err = nlsServerName.QueryError();
    if (err != NERR_Success)
        return err;

    if( IS_NT( plbi->QueryServerType() ) )
    {
        //
        //  Resync an NT server with its PDC.
        //

        NLS_STR nlsServer( SZ("\\\\") );

        err = nlsServer.QueryError();

        if( err == NERR_Success )
        {
            ALIAS_STR nlsWithoutPrefix( plbi->QueryName() );
            err = nlsServer.Append( nlsWithoutPrefix );
        }

        if( err == NERR_Success )
        {
            //
            //  The machine may need its password reset before
            //  the resync can be performed.
            //

            err = ResetPasswordsAndStartNetLogon( nlsServer );
        }

        if( err == NERR_Success )
        {
            //
            //  CODEWORK: We need LMOBJ support for this API!
            //

            NETLOGON_INFO_1 * pnetlog1 = NULL;

            err = ::I_MNetLogonControl( nlsServer,
                                        NETLOGON_CONTROL_REPLICATE,
                                        1,
                                        (BYTE **)&pnetlog1 );

            //
            //  We'll ignore the returned information, just free it.
            //

            if( err == NERR_Success )
            {
                ::MNetApiBufferFree( (BYTE **)&pnetlog1 );
            }
        }
    }
    else
    {
        //
        //  Resync an LM server with its PDC.
        //

        NLS_STR nlsFocus;

        err = nlsFocus.QueryError();

        if( err == NERR_Success )
        {
            err = QueryCurrentFocus( &nlsFocus );
        }

        if( err == NERR_Success )
        {
            RESYNC_DIALOG * pdlg = new RESYNC_DIALOG( QueryHwnd(),
                                                      nlsFocus,
                                                      plbi->QueryName(),
                                                      _lbMainWindow.IsNtPrimary() );

            err = ( pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : pdlg->Process();

            delete pdlg;
        }
    }

    if( err == NERR_Success )
    {
        err = RefreshMainListbox();
        MsgPopup( this, IDS_RESYNC_DONE, MPSEV_INFO, MP_OK,
                  nlsServerName.QueryPch() );
    }

    return err;

}   // SM_ADMIN_APP :: ResyncWithDC

/*******************************************************************

    NAME:          SM_ADMIN_APP :: ResetPasswordsAndStartNetLogon

    SYNOPSIS:      Check to see if the machine needs its passwords
                   reset.  If so, reset the passwords @ the domain's
                   PDC and at the target machine.

    ENTRY:         pszServerName        - The target server whose
                                          account password should
                                          be reset.

    EXIT:          If successful, the machine passwords are in sync.
                   This may result in the netlogon service getting
                   started.

    RETURNS:       APIERR               - Any errors encountered.

    HISTORY:
        KeithMo     07-Jan-1993     Created.

********************************************************************/
APIERR SM_ADMIN_APP :: ResetPasswordsAndStartNetLogon(
                                                const TCHAR * pszServerName )
{
    //
    //  If we're trying to reset the password on a machine
    //  that cannot start its NETLOGON service because the
    //  server/workstation trust relationship has broken down,
    //  the we'll need a NULL session to the target server.
    //

    API_SESSION apisess( pszServerName );

    APIERR err = apisess.QueryError();

    //
    //  First, let's check the state of the NETLOGON service.
    //

    GENERIC_SERVICE svc( this,
                         pszServerName,
                         pszServerName,
                         (TCHAR *)SERVICE_NETLOGON );

    err = err ? err : svc.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Reset the machine account passwords.
        //

        NLS_STR nlsDomain;

        err = nlsDomain.QueryError();
        err = err ? err : QueryCurrentFocus( &nlsDomain );
        err = err ? err : LM_DOMAIN::ResetMachinePasswords( nlsDomain,
                                                            pszServerName );
    }

    if( err == NERR_Success )
    {
        //
        //  Start the NETLOGON service.
        //

        err = svc.Start();

        if( err == NERR_ServiceInstalled )
        {
            //
            //  The service was already running.
            //

            err = NERR_Success;
        }
    }

    return err;

}   // SM_ADMIN_APP :: ResetPasswordsAndStartNetLogon

/*******************************************************************

    NAME:          SM_ADMIN_APP :: ResyncEntireDomain

    SYNOPSIS:      Resyncs an entire domain.

    EXIT:          Server's SAM database is in sync.

    RETURNS:       APIERR               - Any errors encountered.

    HISTORY:
        KeithMo     30-Apr-1992     Created.

********************************************************************/
APIERR SM_ADMIN_APP :: ResyncEntireDomain( VOID )
{
    UIASSERT( QueryFocusType() == FOCUS_DOMAIN );
    UIASSERT( _lbMainWindow.IsNtPrimary() );
    NLS_STR nlsFocus;

    APIERR err = nlsFocus.QueryError();

    if( err == NERR_Success )
    {
        err = QueryCurrentFocus( &nlsFocus );
    }

    if( err == NERR_Success )
    {
        DOMAIN domain( nlsFocus );

        err = domain.GetInfo();

        if( err == NERR_Success )
        {
            if( MsgPopup( this,
                          IDS_VERIFY_DOMAIN_RESYNC,
                          MPSEV_WARNING,
                          MP_YESNO,
                          nlsFocus,
                          MP_NO ) == IDYES )
            {
                //
                //  This may take a few seconds...
                //

                AUTO_CURSOR NiftyCursor;

                //
                //  CODEWORK: We need LMOBJ support for this API!
                //

                NETLOGON_INFO_1 * pnetlog1 = NULL;

                err = ::I_MNetLogonControl( domain.QueryPDC(),
                                            NETLOGON_CONTROL_PDC_REPLICATE,
                                            1,
                                            (BYTE **)&pnetlog1 );

                //
                //  We'll ignore the returned information, just free it.
                //

                if( err == NERR_Success )
                {
                    ::MNetApiBufferFree( (BYTE **)&pnetlog1 );
                    MsgPopup( this, IDS_RESYNC_ENTIRE_DONE, MPSEV_INFO );
                }
            }
        }
    }

    return err;

}   // SM_ADMIN_APP :: ResyncEntireDomain

/*******************************************************************

    NAME:          SM_ADMIN_APP :: Promote

    SYNOPSIS:      Promotes the selected machine to domain controller.

    ENTRY:         plbi                 - The selected listbox item.

    EXIT:          The machine has been promoted.

    RETURNS:       APIERR               - Any errors encountered.

    HISTORY:
        KeithMo     13-Nov-1992     Created.

********************************************************************/
APIERR SM_ADMIN_APP :: Promote( const SERVER_LBI * plbi )
{
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  IDS_VERIFY_ROLE_CHANGE,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryName(),
                  MP_NO ) != IDYES )
    {
        return NERR_Success;
    }

    STACK_NLS_STR( nlsFocus, MAX_PATH+1 );
    REQUIRE( QueryCurrentFocus( &nlsFocus ) == NERR_Success );

    APIERR err = NERR_Success;

    if( IS_NT(plbi->QueryServerType()) && _lbMainWindow.IsNtPrimary() )
    {
        //
        //  Reset the machine passwords if necessary.
        //

        NLS_STR nlsWithPrefix( SZ("\\\\") );
        err = nlsWithPrefix.QueryError();
        ALIAS_STR nlsNoPrefix( plbi->QueryName() );
        err = err ? err : nlsWithPrefix.Append( nlsNoPrefix );

        if( err == NERR_Success )
        {
            AUTO_CURSOR NiftyCursor;

            err = ResetPasswordsAndStartNetLogon( nlsWithPrefix );
        }
    }

    if( err == NERR_Success )
    {
        PROMOTE_DIALOG * pdlg = new PROMOTE_DIALOG( QueryHwnd(),
                                                    nlsFocus.QueryPch(),
                                                    plbi->QueryName(),
                                                    _lbMainWindow.IsNtPrimary() );

        err = ( pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pdlg->Process();

        delete pdlg;
    }

    if( err == NERR_Success )
    {
        err = RefreshMainListbox();
    }

    return err;

}   // SM_ADMIN_APP :: Promote

/*******************************************************************

    NAME:          SM_ADMIN_APP :: Demote

    SYNOPSIS:      Demotes the selected machine to server.

    ENTRY:         plbi                 - The selected listbox item.

    EXIT:          The machine has been demoted.

    RETURNS:       APIERR               - Any errors encountered.

    HISTORY:
        KeithMo     13-Nov-1992     Created.

********************************************************************/
APIERR SM_ADMIN_APP :: Demote( const SERVER_LBI * plbi )
{
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  IDS_VERIFY_DEMOTE,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryName(),
                  MP_NO ) != IDYES )
    {
        return NERR_Success;
    }

    //
    //  Get a proper UNC server name.
    //

    ISTACK_NLS_STR( nlsUNC, MAX_PATH, SZ("\\\\") );
    UIASSERT( !!nlsUNC );
    ALIAS_STR nlsBare( plbi->QueryName() );
    UIASSERT( !!nlsBare );
    nlsUNC.strcat( nlsBare );
    UIASSERT( !!nlsUNC );

    //
    //  Change the machine's role to SERVER.
    //

    AUTO_CURSOR NiftyCursor;

    SERVER_MODALS modals( nlsUNC );

    APIERR err = modals.QueryError();

    if( err == NERR_Success )
    {
        err = modals.SetServerRole( UAS_ROLE_BACKUP );
    }

    if( ( err == NERR_Success ) && _lbMainWindow.IsNtPrimary() )
    {
        //
        //  Restart the machine's NETLOGON service.
        //

        err = ResetPasswordsAndStartNetLogon( nlsUNC );
    }

    if( err == NERR_Success )
    {
        err = RefreshMainListbox();
    }

    return err;

}   // SM_ADMIN_APP :: Demote

/*******************************************************************

    NAME:          SM_ADMIN_APP::OnPropertiesMenuSel

    SYNOPSIS:      Called when the properties sheet should be invoked

    ENTRY:         Object constructed

    EXIT:          Properties dialog shown

    HISTORY:
       kevinl      21-May-1991     Created
       KeithMo     29-Sep-1991     Fixed memory leak.
       jonn        14-Oct-1991     Installed refresh lockcount

********************************************************************/
VOID SM_ADMIN_APP::OnPropertiesMenuSel()
{
    UIASSERT( _lbMainWindow.QueryCount() > 0 ); // Works only in SS model
    //
    //  Retrieve the text of the selected item.
    //

    SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();

    if ( plbiSelect == NULL )
    {
        UIASSERT( FALSE );
        return;                 // Must have something selected.
    }

    //
    //  For now, just construct a SERVER_2 object
    //  representing the selected server name.
    //
    ALIAS_STR nlsWithoutPrefix( plbiSelect->QueryServer() );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    NLS_STR nlsWithPrefix( SZ("\\\\") );
    nlsWithPrefix.strcat( nlsWithoutPrefix );

    if( nlsWithPrefix.QueryError() != NERR_Success )
    {
        MsgPopup( this, nlsWithPrefix.QueryError() );
        return;
    }

    if (NERR_Success != ::I_MNetNameValidate( NULL,
                                              nlsWithoutPrefix,
                                              NAMETYPE_COMPUTER,
                                              0L ) )
    {
        ::MsgPopup( this, ERROR_BAD_NETPATH );
        return;
    }

    LockRefresh();

    //
    //  Our server property sheet object.
    //

    BOOL fUserPressedOK = FALSE;
    BOOL fDontDisplayError;

    SERVER_PROPERTIES * pdlg = new SERVER_PROPERTIES( QueryHwnd(),
                                                      nlsWithPrefix.QueryPch(),
                                                      &fDontDisplayError );

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pdlg != NULL
        && (err = pdlg->QueryError()) == NERR_Success
       )
    {
        err = pdlg->Process( &fUserPressedOK );
    }

    delete pdlg;

    UnlockRefresh();
    RepaintNow();

    if( err == ERROR_INVALID_LEVEL )
    {
        //
        //  Could be either WinBall or LM 1.x.
        //

        ::MsgPopup( this,
                    IDS_CANT_REMOTE_ADMIN,
                    MPSEV_ERROR,
                    MP_OK,
                    nlsWithoutPrefix.QueryPch() );
    }
    else
    if( err != NERR_Success )
    {
        if( !fDontDisplayError )
        {
            //
            // NT Server Manager cannot administer Windows 95 servers.
            //
            if (plbiSelect->QueryServerType() == Windows95ServerType)
            {
                TRACEEOL( "SM_ADMIN_APP::OnPropertiesMenuSel(): admin Win95 error " << err );
                err = IDS_CANNOT_ADMIN_WIN95;
            }
            ::MsgPopup( this, err );
        }
    }
    else
    if( IsRefreshEnabled() && fUserPressedOK )
    {
        RefreshMainListbox();
    }

}


/*******************************************************************

    NAME:       SM_ADMIN_APP::OnFontPickChange

    SYNOPSIS:   Called to set font in applicable listboxes

    HISTORY:
        jonn        27-Sep-1993     Created

********************************************************************/

void SM_ADMIN_APP::OnFontPickChange( FONT & font )
{
    ADMIN_APP::OnFontPickChange( font );

    APIERR err = NERR_Success;

    if (   (err = _lbMainWindow.ChangeFont( QueryInstance(), font )) != NERR_Success
        || (_colheadServers.Invalidate( TRUE ), FALSE)
       )
    {
        DBGEOL( "UM_ADMIN_APP::OnFontPickChange:: _lbMainWindow error " << err );
    }

}   // UM_ADMIN_APP::OnFontPickChange


/*******************************************************************

    NAME:          SM_ADMIN_APP::OnCommand

    SYNOPSIS:      Command message handler

    ENTRY:         Object constructed

    HISTORY:
       kevinl      4-Jun-1991     Created

********************************************************************/
BOOL SM_ADMIN_APP::OnCommand( const CONTROL_EVENT & event )
{
    if ( event.QueryCid() == IDC_MAINWINDOWLB &&
         event.QueryCode() == LBN_DBLCLK)
        OnPropertiesMenuSel();

    return APP_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:       SM_ADMIN_APP::OnUserMessage

    SYNOPSIS:   Invoked for messages >= WM_USER+100.  We use this to
                see if an extension is trying to communicate.

    HISTORY:
        KeithMo     20-Oct-1992     Created.

********************************************************************/
BOOL SM_ADMIN_APP::OnUserMessage( const EVENT &event )
{
    //
    //  Let ADMIN_APP have a crack at it.
    //

    if( ADMIN_APP::OnUserMessage( event ) )
    {
        return TRUE;
    }

    //
    //  Let's see if an extension is trying to communicate...
    //

    switch( event.QueryMessage() )
    {
    case SM_GETSERVERSEL :
    case SM_GETSERVERSEL2 :
       {
        {
            PSMS_GETSERVERSEL psel = (PSMS_GETSERVERSEL)event.QueryLParam();
            PSMS_GETSERVERSEL2 psel2 = (PSMS_GETSERVERSEL2)psel;
            BOOL fVersion2 = (event.QueryMessage() == SM_GETSERVERSEL2);
            SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();

            if( ( psel == NULL ) ||
                ( event.QueryWParam() != 0 ) ||
                ( plbiSelect == NULL ) )
            {
                return FALSE;
            }

            NLS_STR nls( SZ("\\\\") );

            APIERR err = nls.QueryError();

            if( err == NERR_Success )
            {
                ALIAS_STR nlsTmp( plbiSelect->QueryServer() );
                err = nls.Append( nlsTmp );
            }

            if( err == NERR_Success )
            {
                if (fVersion2) {
                    err = nls.MapCopyTo( psel2->szServerName,
                                         sizeof(psel2->szServerName) );
                } else {
                    err = nls.MapCopyTo( psel->szServerName,
                                         sizeof(psel->szServerName) );
                }
            }

            if( err == NERR_Success )
            {
                if (fVersion2) {
                    psel2->dwServerType = plbiSelect->QueryServerTypeMask();
                } else {
                    psel->dwServerType = plbiSelect->QueryServerTypeMask();
                }
            }

            return ( err == NERR_Success );
        }
        break;
       }
    case SM_GETSELCOUNT :
       {
        PSMS_GETSELCOUNT pselcount = (PSMS_GETSELCOUNT)event.QueryLParam();

        if( ( pselcount == NULL ) || ( event.QueryWParam() != 0 ) )
        {
            return FALSE;
        }

        pselcount->dwItems = (DWORD)_lbMainWindow.QuerySelCount();
        return TRUE;
       }
    case SM_GETCURFOCUS :
    case SM_GETCURFOCUS2 :
       {
        {
            PSMS_GETCURFOCUS pcurfocus = (PSMS_GETCURFOCUS)event.QueryLParam();
            PSMS_GETCURFOCUS2 pcurfocus2 = (PSMS_GETCURFOCUS2)pcurfocus;
            BOOL fVersion2 = (event.QueryMessage() == SM_GETCURFOCUS2);

            if( ( pcurfocus == NULL ) || ( event.QueryWParam() != 0 ) )
            {
                return FALSE;
            }

            //
            //  Determine the focus type.
            //

            DWORD dwFocusType = 0;

            if( QueryFocusType() == FOCUS_DOMAIN )
            {
                if( _lbMainWindow.IsNtPrimary() )
                {
                    dwFocusType = SM_FOCUS_TYPE_NT_DOMAIN;
                }
                else
                if( _lbMainWindow.IsPDCAvailable() )
                {
                    dwFocusType = SM_FOCUS_TYPE_LM_DOMAIN;
                }
                else
                {
                    dwFocusType = SM_FOCUS_TYPE_UNKNOWN_DOMAIN;
                }
            }
            else
            {
                SERVER_LBI * plbiSelect = (SERVER_LBI *)_lbMainWindow.QueryItem();

                if( plbiSelect == NULL )
                {
                    return FALSE;
                }

                SERVER_TYPE srvtype = plbiSelect->QueryServerType();

                if( IS_NT( srvtype ) )
                {
                    dwFocusType = SM_FOCUS_TYPE_NT_SERVER;
                }
                else
                if( IS_LM( srvtype ) )
                {
                    dwFocusType = SM_FOCUS_TYPE_LM_SERVER;
                }
                if( IS_WFW( srvtype ) )
                {
                    dwFocusType = SM_FOCUS_TYPE_WFW_SERVER;
                }
                else
                {
                    dwFocusType = SM_FOCUS_TYPE_UNKNOWN_SERVER;
                }
            }

            UIASSERT( dwFocusType != 0 );
            if (fVersion2) {
                pcurfocus2->dwFocusType = dwFocusType;
            } else {
                pcurfocus->dwFocusType = dwFocusType;
            }

            //
            //  Retrieve the current focus.
            //

            NLS_STR nlsFocus;

            APIERR err = QueryCurrentFocus( &nlsFocus );

            if( ( err == NERR_Success ) && ( QueryFocusType() == FOCUS_DOMAIN ) )
            {
                ALIAS_STR nlsPrefix( SZ("\\\\") );
                ISTR istrStart( nlsFocus );

                if( !nlsFocus.InsertStr( nlsPrefix, istrStart ) )
                {
                    err = nlsFocus.QueryError();
                }
            }

            if( err == NERR_Success )
            {
                if (fVersion2) {
                    err = nlsFocus.MapCopyTo( pcurfocus2->szFocus,
                                              sizeof(pcurfocus2->szFocus) );
                } else {
                    err = nlsFocus.MapCopyTo( pcurfocus->szFocus,
                                              sizeof(pcurfocus->szFocus) );
                }
            }

            return ( err == NERR_Success );
        }
        break;
       }
    case SM_GETOPTIONS :
       {
        PSMS_GETOPTIONS poptions = (PSMS_GETOPTIONS)event.QueryLParam();

        if( ( poptions == NULL ) || ( event.QueryWParam() != 0 ) )
        {
            return FALSE;
        }

        poptions->fSaveSettingsOnExit = IsSavingSettingsOnExit();
        poptions->fConfirmation       = IsConfirmationOn();

        return TRUE;
       }
    }

    return FALSE;
}

/*******************************************************************

    NAME:          SM_ADMIN_APP::QueryHelpContext

    SYNOPSIS:      Returns help context for selected item.

    EXIT:          Returns help context

    HISTORY:
       kevinl      21-May-1991     Created
       KeithMo     16-Aug-1992     Made it work.

********************************************************************/
ULONG SM_ADMIN_APP::QueryHelpContext( enum HELP_OPTIONS helpOptions )
{
    return ( helpOptions == ADMIN_HELP_KEYBSHORTCUTS )
                                ? HC_HELP_KEYBSHORTCUTS
                                : ADMIN_APP::QueryHelpContext( helpOptions );
}


/*******************************************************************

    NAME:       SM_ADMIN_APP::SetAdminCaption

    SYNOPSIS:   Sets the correct caption of the main window

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 02-Apr-1992 Created from ADMIN_APP::SetAdminCaption().

********************************************************************/
APIERR SM_ADMIN_APP :: SetAdminCaption( VOID )
{
    MSGID          idsCaptionText;
    const TCHAR  * pszFocus;
    RESOURCE_STR   nlsLocal( IDS_LOCAL_MACHINE );
    const LOCATION     & loc = QueryLocation();


    if( !nlsLocal )
    {
        return nlsLocal.QueryError();
    }

    if( IsServer() )
    {
        idsCaptionText = IDS_CAPTION_MAIN_ALL;
        pszFocus       = loc.QueryServer();

        if( pszFocus == NULL  )
        {
            pszFocus = nlsLocal.QueryPch();
        }
    }
    else
    {
        //
        //  A LOCATION object should either be a server or a domain.
        //
        UIASSERT( IsDomain());

        if( QueryExtensionView() != 0 )
        {
            idsCaptionText = IDS_CAPTION_MAIN_EXTENSION;
        }
        else
        {
            if( ViewWkstas() )
            {
                idsCaptionText = ViewServers() ? IDS_CAPTION_MAIN_ALL
                                               : IDS_CAPTION_MAIN_WKSTAS;
            }
            else
            {
                UIASSERT( ViewServers() );
                idsCaptionText = IDS_CAPTION_MAIN_SERVERS;
            }
        }

        pszFocus = loc.QueryDomain();
    }

    NLS_STR nlsCaption( MAX_RES_STR_LEN );

    if( !nlsCaption )
    {
        return nlsCaption.QueryError();
    }

    const ALIAS_STR nlsFocus( pszFocus );

    const NLS_STR *apnlsParams[2];
    apnlsParams[0] = &nlsFocus;
    apnlsParams[1] = NULL;

    APIERR err = nlsCaption.Load( idsCaptionText );

    if( err == NERR_Success )
    {
        err = nlsCaption.InsertParams( apnlsParams );
    }

    if( err != NERR_Success )
    {
        return err;
    }

    SetText( nlsCaption );

    return NERR_Success;

}   // SM_ADMIN_APP :: SetAdminCaption


/*******************************************************************

    NAME:       SM_ADMIN_APP :: SetNetworkFocus

    SYNOPSIS:   Sets the focus for the Server Manager.

    ENTRY:      pchServDomain           - Either a server name (\\SERVER),
                                          a domain name (DOMAIN),
                                          or NULL (the logon domain).

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      Should probably call through to either W_SetNetworkFocus
                or ADMIN_APP::SetNetworkFocus.

    HISTORY:
        KeithMo 05-Jun-1992 Created.

********************************************************************/
APIERR SM_ADMIN_APP :: SetNetworkFocus( HWND hwndOwner,
                                        const TCHAR * pchServDomain,
                                        FOCUS_CACHE_SETTING setting )
{
    //
    //  If (the new focus is (NULL or EMPTY) && we're logged on locally)
    //  or if the new focus matches the local machine name, then we
    //  change the focus from MACHINENAME to \\MACHINENAME.
    //

    BOOL fUseLocalMachine = FALSE;

    if( ( pchServDomain == NULL ) || ( *pchServDomain == TCH('\0') ) )
    {
        fUseLocalMachine = _fLoggedOnLocally;
    }
    else
    {
        fUseLocalMachine = !::I_MNetComputerNameCompare( _nlsComputerName,
                                                         pchServDomain );
    }

    APIERR err = NERR_Success;

    if( fUseLocalMachine )
    {
        //
        //  If we're to use the local machine, let's see if
        //  the server is actually running.
        //

        BOOL fServerStarted;

        err = CheckServer( &fServerStarted );

        if( ( err == NERR_Success ) && !fServerStarted )
        {
            //
            //  The server is not started.  Let's see if the user
            //  wants us to start it.
            //

            if( MsgPopup( this,
                          IDS_START_SERVER_NOW,
                          MPSEV_WARNING,
                          MP_YESNO,
                          MP_YES ) != IDYES )
            {
                //
                //  The user doesn't want to play right now.
                //

                err = NERR_ServerNotStarted;
            }
            else
            {
                //
                //  Start the server.
                //

                err = StartServer();
            }
        }
    }


    //
    //  Now we just need to pass the appropriate focus up to the
    //  parent method.
    //

    if( err == NERR_Success )
    {
        err = fUseLocalMachine ? ADMIN_APP :: SetNetworkFocus( hwndOwner,
                                                               _nlsComputerName,
                                                               setting )
                               : ADMIN_APP :: SetNetworkFocus( hwndOwner,
                                                               pchServDomain,
                                                               setting );
    }

    if (   (err == NERR_Success)
        && (setting == FOCUS_CACHE_UNKNOWN)
        && (!_lbMainWindow.IsPDCAvailable())
       )
    {
//
// It may be that ADMIN_APP::SetNetworkFocus read the cache and found
// an entry there.  If so, we do not want to come back and detect slow mode.
//
        TRACEEOL( "SM_ADMIN_APP::SetNetworkFocus: extra cache read" );
        SLOW_MODE_CACHE cache;
        APIERR errTemp;
        if (   (errTemp = cache.QueryError()) != NERR_Success
            || (errTemp = cache.Read()) != NERR_Success
           )
        {
            TRACEEOL( "SM_ADMIN_APP::SetNetworkFocus: cache read failure " << errTemp );
        }
        else if (cache.Query( QueryLocation() ) == FOCUS_CACHE_UNKNOWN)
        {
            _fDelaySlowModeDetection = TRUE;
        }
    }

    return err;

}   // SM_ADMIN_APP :: SetNetworkFocus


/*******************************************************************

    NAME:       SM_ADMIN_APP :: GetWkstaInfo

    SYNOPSIS:   Retrieves the computer name, checks to see if we're
                logged on locally, checks to see if we have a
                workstation domain.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 05-Jun-1992 Created.

********************************************************************/
APIERR SM_ADMIN_APP :: GetWkstaInfo( VOID )
{
    //
    //  Retrieve the local computer name.
    //

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

    APIERR err = ::GetComputerName( szComputerName, &cchBuffer )
                    ? NERR_Success
                    : ::GetLastError();

    if( err == NERR_Success )
    {
        err = _nlsComputerName.CopyFrom( SZ("\\\\") );
    }

    if( err == NERR_Success )
    {
        ALIAS_STR nlsName( szComputerName );
        err = _nlsComputerName.Append( nlsName );
    }

    //
    //  Retrieve the logon domain.
    //

    WKSTA_USER_1 wku1;

    if( err == NERR_Success )
    {
        err = wku1.QueryError();
    }

    if( err == NERR_Success )
    {
        err = wku1.GetInfo();
    }

    if( err == NERR_Success )
    {
        _fLoggedOnLocally =
                        !::I_MNetComputerNameCompare( szComputerName,
                                                      wku1.QueryLogonDomain() );
    }

    //
    //  CODEWORK: Determine if we're part of a larger domain.
    //

    _fHasWkstaDomain = TRUE;

    return err;

}   // SM_ADMIN_APP :: GetWkstaInfo


/*******************************************************************

    NAME:       SM_ADMIN_APP :: CheckServer

    SYNOPSIS:   Determine if the local server is running.

    ENTRY:      pfStarted               - Will receive TRUE if the
                                          server is running.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 10-Jun-1992 Created.

********************************************************************/
APIERR SM_ADMIN_APP :: CheckServer( BOOL * pfStarted )
{
    UIASSERT( pfStarted != NULL );

    *pfStarted = FALSE;         // until proven otherwise

    //
    //  We'll use a SERVER_0 object with a NULL server name to
    //  represent the local server.  If the GetInfo() succeeds,
    //  then we know the server is running.
    //

    SERVER_0 srv0( NULL );

    APIERR err = srv0.QueryError();

    if( err == NERR_Success )
    {
        err = srv0.GetInfo();
    }

    if( err == NERR_Success )
    {
        //
        //  The server is running and everything looks cool.
        //

        *pfStarted = TRUE;
    }
    else
    if( err == NERR_ServerNotStarted )
    {
        //
        //  The server is not running.  We'll map this
        //  to NERR_Success, but *pfStarted will be FALSE.
        //

        err = NERR_Success;
    }

    return err;

}   // SM_ADMIN_APP :: CheckServer


/*******************************************************************

    NAME:       SM_ADMIN_APP :: StartServer

    SYNOPSIS:   Starts the server on the local machine.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 10-Jun-1992 Created.

********************************************************************/
APIERR SM_ADMIN_APP :: StartServer( VOID )
{
    LOCATION loc( LOC_TYPE_LOCAL );
    NLS_STR  nlsDisplayName;

    APIERR err = loc.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDisplayName.QueryError();
    }

    if( err == NERR_Success )
    {
        err = loc.QueryDisplayName( &nlsDisplayName );
    }

    if( err == NERR_Success )
    {
        GENERIC_SERVICE * psvc = new GENERIC_SERVICE( QueryHwnd(),
                                                      NULL,
                                                      nlsDisplayName,
                                                      (const TCHAR *)SERVICE_SERVER );

        err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : psvc->QueryError();

        if( err == NERR_Success )
        {
            err = psvc->Start();
        }

        delete psvc;
    }

    return err;

}   // SM_ADMIN_APP :: StartServer


/*******************************************************************

    NAME:       SM_ADMIN_APP :: LoadMenuExtension

    SYNOPSIS:   Loads a menu extension by name.

    ENTRY:      pszExtensionDll         - Name of the DLL containing
                                          the menu extension.

                dwDelta                 - Menu ID delta for the extension.

    RETURNS:    AAPP_MENU_EXT *         - New extension object.

    HISTORY:
        KeithMo 19-Oct-1992     Created.

********************************************************************/
AAPP_MENU_EXT * SM_ADMIN_APP::LoadMenuExtension( const TCHAR * pszExtensionDll,
                                                 DWORD         dwDelta )
{
    //
    //  Create the extension object.
    //

    SM_MENU_EXT * pExt = new SM_MENU_EXT( this,
                                          pszExtensionDll,
                                          dwDelta,
                                          QueryHwnd() );

    APIERR err = ( pExt == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pExt->QueryError();

    if( err == NERR_Success )
    {
        //
        //  Update the menus.
        //

        err = AddExtensionMenuItem( pExt->QueryMenuName(),
                                    pExt->QueryMenuHandle(),
                                    dwDelta );
    }

    //
    //  Do the -5 to get past the last 4 items: ALL, SEPARATOR, ACCOUNTONLY,
    //  SEPARATOR, REFRESH.
    //
    //  Don't update the view menu if the extension specified a server type
    //  mask of zero.
    //

    if( ( err == NERR_Success ) && ( pExt->QueryServerType() != 0 ) )
    {
        err = _menuView.Insert( pExt->QueryMenuName(),
                                _menuView.QueryItemCount() - 5,
                                dwDelta + VMID_VIEW_EXT,
                                MF_BYPOSITION );
    }

    if( err != NERR_Success )
    {
        //
        //  Something failed, cleanup.
        //

        delete pExt;
        pExt = NULL;

        DBGEOL( "SM_ADMIN_APP::LoadMenuExtension - error " << err );

        if( err != ERROR_EXTENDED_ERROR )
        {
            //
            //  We'll assume that extended error processing
            //  was handled by the SM_MENU_EXT constructor.
            //

            ::DisplayGenericError( this,
                                   IDS_CANNOT_LOAD_EXTENSION,
                                   err,
                                   pszExtensionDll );
        }
    }

    return (AAPP_MENU_EXT *)pExt;

}   // SM_ADMIN_APP :: LoadMenuExtension


/*******************************************************************

    NAME:       SM_ADMIN_APP :: SetExtensionView

    SYNOPSIS:   Sets the view to one of the extensions.

    ENTRY:      mid                     - The menu ID for the extension
                                          entry in the "View" menu.

                dwServerTypeMask        - The server type mask for this
                                          extension.
    HISTORY:
        KeithMo 26-Oct-1992     Created.

********************************************************************/
VOID SM_ADMIN_APP::SetExtensionView( MID   mid,
                                     DWORD dwServerTypeMask )
{
    //
    //  Nuke the old view.
    //

    _fViewWkstas  = FALSE;
    _fViewServers = FALSE;

    if( _midView == mid )
    {
        //
        //  View already set, nothing to do.
        //

        return;
    }

    //
    //  Save the new view & type mask.
    //

    _midView = mid;
    _dwViewedServerTypeMask = dwServerTypeMask;

    //
    //  Refresh the main window.
    //

    SetAdminCaption();
    RefreshMainListbox( TRUE );

}   // SM_ADMIN_APP :: SetExtensionView


/*******************************************************************

    NAME:       SM_ADMIN_APP :: RefreshMainListbox

    SYNOPSIS:   Refreshes the main listbox.  Will not refresh the
                listbox if RAS Mode is enabled.

    ENTRY:      fForcedRefresh          - Will always force a refresh,
                                          even if RAS Mode enabled.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo 27-Oct-1992     Created.
        KeithMo 02-Feb-1992     Don't auto-refresh in RAS Mode unless
                                fForcedRefresh is TRUE.

********************************************************************/
APIERR SM_ADMIN_APP::RefreshMainListbox( BOOL fForcedRefresh )
{
    APIERR err = NERR_Success;

    if( !InRasMode() || fForcedRefresh )
    {
        //
        //  Refresh the main window.
        //

        err = OnRefreshNow( fForcedRefresh );

        //
        //  Refresh any loaded extensions.
        //

        RefreshExtensions( QueryHwnd() );
    }

    return err;

}   // SM_ADMIN_APP :: RefreshMainListbox


/*******************************************************************

    NAME:       SM_ADMIN_APP :: DetermineRasMode

    SYNOPSIS:   Determines if the app should be in RAS Mode for
                the current focus.  We must delay the IsSlowTransport
                check until this time if focus is set to a domain and
                the user did not explicitly decide.

    HISTORY:
        KeithMo 30-Apr-1993     Created.

********************************************************************/
VOID SM_ADMIN_APP::DetermineRasMode( const TCHAR * pchServer )
{
    if (_fDelaySlowModeDetection == TRUE)
    {
        SetRasMode( DetectSlowTransport( pchServer ) == FOCUS_CACHE_SLOW );
        _fDelaySlowModeDetection = FALSE;
    }

}   // SM_ADMIN_APP :: DetermineRasMode



SET_ROOT_OBJECT( SM_ADMIN_APP,
                 IDRSRC_APP_BASE, IDRSRC_APP_LAST,
                 IDS_UI_APP_BASE, IDS_UI_APP_LAST );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\srvbase.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvbase.hxx
        Class declaration for the SRV_BASE_DIALOG class.

    The SRV_BASE_DIALOG class is a wrapper that adds
    the SetCaption method to DIALOG_WINDOW.


    FILE HISTORY:
        ChuckC      27-Dec-1991 Created, stole from now defunct srvutil.hxx

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
    #include <srvmgr.h>
}

#include <srvbase.hxx>


/*******************************************************************

    NAME:       SRV_BASE_DIALOG :: SRV_BASE_DIALOG

    SYNOPSIS:   SRV_BASE_DIALOG class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
SRV_BASE_DIALOG::SRV_BASE_DIALOG( const IDRESOURCE & idrsrcDialog,
                                  const PWND2HWND & wndOwner ):
                    DIALOG_WINDOW(idrsrcDialog, wndOwner)
{
    ;
}


/*******************************************************************

    NAME:       SRV_BASE_DIALOG :: ~SRV_BASE_DIALOG

    SYNOPSIS:   SRV_BASE_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
SRV_BASE_DIALOG :: ~SRV_BASE_DIALOG()
{
    ;
}   // SRV_BASE_DIALOG :: ~SRV_BASE_DIALOG

/*******************************************************************

    NAME:       SRV_BASE_DIALOG :: SetCaption

    SYNOPSIS:   Sets the dialog caption to "Foo on Server".

    ENTRY:      powin                   - The dialog window.

                idCaption               - Resource ID for the caption
                                          string (for example,
                                          "Open Resources on %1").

                pszServerName           - The server name.

    EXIT:       The caption is set.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      This is a static method.

    HISTORY:
        KeithMo     22-Sep-1991 Created.

********************************************************************/
APIERR SRV_BASE_DIALOG :: SetCaption( OWNER_WINDOW * powin,
                                     UINT           idCaption,
                                     const TCHAR   * pszServerName )
{
    UIASSERT( powin != NULL );
    UIASSERT( pszServerName != NULL );

    //
    //  This will (eventually...) receive the caption string.
    //

    NLS_STR nlsCaption;

    if( !nlsCaption )
    {
        return nlsCaption.QueryError();
    }

    //
    //  Note that the server name still has the leading
    //  backslashes (\\).  They are not to be displayed.
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

#ifdef  DEBUG
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( nlsServerName );

        UIASSERT( nlsServerName.QueryChar( istrDbg ) == '\\' );
        ++istrDbg;
        UIASSERT( nlsServerName.QueryChar( istrDbg ) == '\\' );
    }
#endif  // DEBUG

    //
    //  Skip the backslashes.
    //
    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    //
    //  The insert strings for Load().
    //
    const NLS_STR * apnlsParams[2];

    apnlsParams[0] = &nlsWithoutPrefix;
    apnlsParams[1] = NULL;

    nlsCaption.Load( idCaption );
    nlsCaption.InsertParams( apnlsParams );

    if( !nlsCaption )
    {
        return nlsCaption.QueryError();
    }

    //
    //  Set the caption.
    //

    powin->SetText( nlsCaption.QueryPch() );

    //
    //  Success!
    //

    return NERR_Success;

}   // SRV_BASE_DIALOG :: SetCaption
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\srvsvc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    srvsvc.cxx

    This file contains the code for most of the service related
    UI in the server manager.

    FILE HISTORY:
        ChuckC      07-Sep-1991     Created
        ChuckC      23-Sep-1991     Code review changes.
                                    Attended by JimH, KeithMo, EricCh, O-SimoP
        KeithMo     06-Oct-1991     Win32 Conversion.
        KeithMo     19-Jan-1992     Added GENERIC_SERVICE.
        KeithMo     02-Jun-1992     Added an additional GENERIC_SERVICE ctor.
*/

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmsvc.hxx>
#include <lmosrv.hxx>
#include <srvsvc.hxx>
#include <svcman.hxx>           // service controller wrappers
#include <lmoenum.hxx>
#include <lmoesess.hxx>

#include <dbgstr.hxx>

extern "C" {
    #include <srvmgr.h>
    #include <winsvc.h>         // service controller
}


//
//  TIMER_FREQ is the frequency of our timer messages.
//  TIMER_MULT is a multiplier.  We'll actually poll the
//  service every (TIMER_FREQ * TIMER_MULT) seconds.
//  This allows us to advance the progress indicator more
//  fequently than we hit the net.  Should keep the user better
//  amused.
//

#define TIMER_FREQ 500
#define TIMER_MULT 6
#define POLL_TIMER_FREQ (TIMER_FREQ * TIMER_MULT)
#define POLL_DEFAULT_MAX_TRIES 1


/*******************************************************************

    NAME:       GENERIC_SERVICE :: GENERIC_SERVICE

    SYNOPSIS:   GENERIC_SERVICE class constructor.

    ENTRY:      wndOwner                - The window which "owns" this
                                          object.

                pszServerName           - The name of the target server.

                pszServiceName          - The name of the target service.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     19-Jan-1992     Created.

********************************************************************/
GENERIC_SERVICE :: GENERIC_SERVICE( const PWND2HWND & wndOwner,
                                    const TCHAR     * pszServerName,
                                    const TCHAR     * pszSrvDspName,
                                    const TCHAR     * pszServiceName,
                                    const TCHAR     * pszServiceDisplayName,
                                    BOOL              fIsDevice )
  : LM_SERVICE( pszServerName, pszServiceName ),
    _hwndParent( wndOwner.QueryHwnd() ),
    _pszSrvDspName( pszSrvDspName ),
    _fIsNT( FALSE ),
    _fIsDevice( fIsDevice ),
    _nlsDisplayName( pszServiceDisplayName )
{
    UIASSERT( pszSrvDspName != NULL );
    UIASSERT( pszServiceName != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDisplayName )
    {
        ReportError( _nlsDisplayName.QueryError() );
        return;
    }

    //
    //  Determine if this is an NT server.
    //

    SERVER_1 srv1( pszServerName );

    APIERR err = srv1.GetInfo();

    if( err == NERR_ServerNotStarted )
    {
        //
        //  If the server isn't started, it must be
        //  local, therefore it must be NT.
        //

        _fIsNT = TRUE;
        err = NERR_Success;
    }
    else
    if( err == NERR_Success )
    {
        _fIsNT = ( srv1.QueryServerType() & SV_TYPE_NT ) != 0;
    }

    //
    //  Retrieve the appropriate display name for this service.
    //

    if( ( err == NERR_Success ) && ( pszServiceDisplayName == NULL ) )
    {
        if( _fIsNT )
        {
            //
            //  NT machine, so get the display name from
            //  the service controller.
            //

            SC_MANAGER scm( pszServerName, GENERIC_READ );

            err = scm.QueryError();

            if( err == NERR_Success )
            {
                err = scm.QueryServiceDisplayName( pszServiceName,
                                                   &_nlsDisplayName );
            }
        }
        else
        {
            //
            //  Downlevel machine, display name = service name.
            //

            err = _nlsDisplayName.CopyFrom( pszServiceName );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // GENERIC_SERVICE :: GENERIC_SERVICE


/*******************************************************************

    NAME:       GENERIC_SERVICE :: ~GENERIC_SERVICE

    SYNOPSIS:   GENERIC_SERVICE class destructor.

    EXIT:       The object has been destroyed.

    HISTORY:
        KeithMo     19-Jan-1992     Created.

********************************************************************/
GENERIC_SERVICE :: ~GENERIC_SERVICE()
{
    _hwndParent    = NULL;
    _pszSrvDspName = NULL;

}   // GENERIC_SERVICE :: ~GENERIC_SERVICE


/*******************************************************************

    NAME:       GENERIC_SERVICE :: Start

    SYNOPSIS:   Start the service

    ENTRY:      object constructed successfully

    EXIT:       Service INSTALLed.

    RETURNS:    NERR_Success on success, API error otherwise.

    HISTORY:
                ChuckC      07-Sep-1991     Created
                KeithMo     28-Jan-1992     Now takes a const TCHAR *.

********************************************************************/
APIERR GENERIC_SERVICE :: Start( const TCHAR * pszArgs )
{
    /*
     * initiate the Start
     */
    APIERR err = LM_SERVICE::Start( pszArgs,
                                    POLL_TIMER_FREQ,
                                    POLL_DEFAULT_MAX_TRIES );
    if (err != NERR_Success)
        return(err) ;

    /*
     * wait till it reaches desired state
     */
    return Wait( LM_SVC_START );

}   // GENERIC_SERVICE :: Start


/*******************************************************************

    NAME:       GENERIC_SERVICE :: Pause

    SYNOPSIS:   Pause a service

    ENTRY:      object properly constructed

    EXIT:       service is paused

    NOTES:      it is OK to pause a paused service

    RETURNS:    NERR_Success if success, API error otherwise

    HISTORY:
                ChuckC      07-Sep-1991     Created

********************************************************************/
APIERR GENERIC_SERVICE :: Pause( VOID )
{
    /*
     * initiate the Pause
     */
    APIERR err = LM_SERVICE::Pause( POLL_TIMER_FREQ,
                                    POLL_DEFAULT_MAX_TRIES );
    if (err != NERR_Success)
        return(err) ;

    /*
     * wait till it reaches desired state
     */
    return Wait( LM_SVC_PAUSE );

}   // GENERIC_SERVICE :: Pause


/*******************************************************************

    NAME:       GENERIC_SERVICE :: Continue

    SYNOPSIS:   Continue a service

    ENTRY:      object properly constructed

    EXIT:       service is continue

    RETURNS:    NERR_Success if success, API error otherwise

    NOTES:      it is OK to continue a continued service

    HISTORY:
                ChuckC      07-Sep-1991     Created

********************************************************************/
APIERR GENERIC_SERVICE :: Continue( VOID )
{
    /*
     * initiate the continue
     */
    APIERR err = LM_SERVICE::Continue( POLL_TIMER_FREQ,
                                       POLL_DEFAULT_MAX_TRIES );
    if (err != NERR_Success)
        return(err) ;

    /*
     * wait till it reaches desired state
     */
    return Wait( LM_SVC_CONTINUE );

}   // GENERIC_SERVICE :: Continue


/*******************************************************************

    NAME:       GENERIC_SERVICE :: Stop

    SYNOPSIS:   stop the service

    ENTRY:      onject properly constructed

    EXIT:       service stopped

    RETURNS:    NERR_Success if success, API error otherwise

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/
APIERR GENERIC_SERVICE :: Stop( BOOL * pfStoppedServer )
{
    if( pfStoppedServer != NULL )
    {
        *pfStoppedServer = FALSE;       // until proven otherwise...
    }

    //
    //  We'll set this flag to TRUE if we'll be
    //  stopping the server service.
    //

    BOOL fStoppingServer =
            ( ::stricmpf( QueryName(), (TCHAR *)SERVICE_SERVER ) == 0 ) ||
            ( ::stricmpf( QueryName(), (TCHAR *)SERVICE_LM20_SERVER ) == 0 );

    /*
     * initiate the stop
     */
    APIERR err = LM_SERVICE::Stop( POLL_TIMER_FREQ,
                                   POLL_DEFAULT_MAX_TRIES );

    if( err != NERR_Success )
    {
        //
        //  If we're stopping the server service AND this is an
        //  acceptable status code during a server stop, then map
        //  the error to success.
        //

        if( fStoppingServer && IsAcceptableStopServerStatus( err ) )
        {
            err = NERR_Success;

            if( pfStoppedServer != NULL )
            {
                *pfStoppedServer = TRUE;
            }
        }

        return err;
    }

    //
    //  Wait for the service to reach the desired state.
    //

    err = Wait( LM_SVC_STOP );

    //
    //  If we're stopping the server service AND this is an
    //  acceptable status code during a server stop, then map
    //  the error to success.
    //

    if( fStoppingServer && IsAcceptableStopServerStatus( err ) )
    {
        err = NERR_Success;

        if( pfStoppedServer != NULL )
        {
            *pfStoppedServer = TRUE;
        }
    }

    return err;

}   // GENERIC_SERVICE :: Stop


/*******************************************************************

    NAME:       GENERIC_SERVICE :: Wait

    SYNOPSIS:   wait till the service reaches the desired state
                as a result of the requested operation.

    ENTRY:      A service control operation like start/stop/pause
                has just benn called.

    EXIT:       We get to the state we want or give up waiting.

    RETURNS:    NERR_Success if success, API error otherwise.

    HISTORY:
        ChuckC      07-Sep-1991     Created
        KeithMo     17-Jul-1992     Restructured to gracefully handle
                                    stopping the server service.

********************************************************************/
APIERR GENERIC_SERVICE :: Wait( LM_SERVICE_OPERATION lmsvcOp )
{
    //
    //  Invoke the wait dialog.
    //

    SERVICE_WAIT_DIALOG * pDlg = new SERVICE_WAIT_DIALOG( QueryParentHwnd(),
                                                          this,
                                                          lmsvcOp,
                                                          NULL,
                                                          _pszSrvDspName,
                                                          _fIsDevice );

    UINT   errTmp = NERR_Success;
    APIERR errDlg = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : pDlg->Process( &errTmp );

    delete pDlg;
    APIERR errOp = (APIERR)errTmp;

    if( errDlg != NERR_Success )
    {
        //
        //  The dialog failed.  Use its error code.
        //

        errOp = errDlg;
    }

    return errOp;

}   // GENERIC_SERVICE :: Wait


/*******************************************************************

    NAME:       GENERIC_SERVICE :: IsAcceptableStopServerStatus

    SYNOPSIS:   Check to see if the specified error code is an
                OK status to receive when stopping the server
                service.

    ENTRY:      err                     - The error code to check.

    RETURNS:    BOOL                    - TRUE  if this is an OK status
                                                to receive when stopping
                                                the server service.

                                          FALSE otherwise.

    HISTORY:
        KeithMo     17-Jul-1992     Created.

********************************************************************/
BOOL GENERIC_SERVICE :: IsAcceptableStopServerStatus( APIERR err ) const
{
    return ( err == NERR_Success                ) ||
           ( err == RPC_S_SERVER_UNAVAILABLE    ) ||
           ( err == RPC_S_CALL_FAILED           ) ||
           ( err == ERROR_BAD_NETPATH           );

}   // GENERIC_SERVICE :: IsAcceptableStopServerStatus


/*******************************************************************

    NAME:       GENERIC_SERVICE :: StopWarning

    SYNOPSIS:   Warn the user that they are about to stop a service.
                Give special warning for certain critical services,
                such as the SERVER and the WORKSTATION.

    EXIT:       The user has been warned.

    RETURNS:    BOOL                    - TRUE if user wants to abort.
                                          FALSE if user wants to continue.

    HISTORY:
        KeithMo     28-Jan-1992     Created.

********************************************************************/
BOOL GENERIC_SERVICE :: StopWarning( VOID ) const
{
    //
    //  CODEWORK: Need to special case a few critical services here!!
    //
    //


    // figure out what services are dependent on the one we
    // are about to stop
    APIERR err ;
    STRLIST slKeyNames;
    STRLIST slDisplayNames;
    err = ((GENERIC_SERVICE *) this)->EnumerateDependentServices(QueryName(), &slKeyNames, &slDisplayNames);
    if (err != NERR_Success)
    {
        MsgPopup( QueryParentHwnd(), err, MPSEV_ERROR, MP_OK ) ;
        return TRUE ;
    }

    // if there are none, its easy. just ask the guy if he's sure
    // he wants to stop the service.
    if (slKeyNames.QueryNumElem() == 0)  // if no dependent services
    {
        return (MsgPopup( QueryParentHwnd(),
                         _fIsDevice ? IDS_DEV_STOP_WARN
                                    : IDS_SVC_STOP_WARN,
                         MPSEV_WARNING,
                         MP_YESNO,
                         QueryServiceDisplayName(),
                         MP_NO ) != IDYES);
    }

    // if there are, we bring up dialog with list of services,
    // and he gets to stop them all.
    STOP_DEPENDENT_DIALOG *pStpDepDlg =
                new STOP_DEPENDENT_DIALOG(QueryParentHwnd(),
                                          (GENERIC_SERVICE *)this,
                                          &slKeyNames,
                                          &slDisplayNames);
    if (pStpDepDlg == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY ;
    else
        err = pStpDepDlg->QueryError() ;

    BOOL fOK = TRUE;

    // so far so good. lets bring the dialog up!
    if (err == NERR_Success)
        err = pStpDepDlg->Process( &fOK ) ;

    if (err != NERR_Success)
    {
        MsgPopup( QueryParentHwnd(), err, MPSEV_ERROR, MP_OK ) ;
        return TRUE ;
    }

    delete pStpDepDlg ;
    pStpDepDlg = NULL ;

    //
    //  This method should return TRUE if the user wants to
    //  abort the stop.
    //
    //  fOK will be TRUE if the user pressed OK in the stop
    //  dependent services dialog, FALSE if the user pressed
    //  CANCEL.
    //
    //  Therefore, we want to abort the stop if fOK is FALSE,
    //  so we'll return fOK's negation.
    //

    return !fOK;

}   // GENERIC_SERVICE :: StopWarning


/*******************************************************************

    NAME:       GENERIC_SERVICE :: PauseWarning

    SYNOPSIS:   Warn the user that they are about to pause a service.
                Give special warning for certain critical services,
                such as the SERVER and the WORKSTATION.

    EXIT:       The user has been warned.

    RETURNS:    BOOL                    - TRUE if user wants to abort.
                                          FALSE if user wants to continue.

    HISTORY:
        KeithMo     28-Jan-1992     Created.

********************************************************************/
BOOL GENERIC_SERVICE :: PauseWarning( VOID ) const
{
    //
    //  CODEWORK: Need to special case a few critical services here!!
    //

    return MsgPopup( QueryParentHwnd(),
                     IDS_SVC_PAUSE_WARN,
                     MPSEV_WARNING,
                     MP_YESNO,
                     QueryServiceDisplayName(),
                     MP_NO ) != IDYES;

}   // GENERIC_SERVICE :: PauseWarning

/*******************************************************************

    NAME:       GENERIC_SERVICE :: EnumerateDependentServices

    SYNOPSIS:   Call the service controller to figure out dependent
                services,

    EXIT:       The STRLIST has all depende services.

    RETURNS:    APIERR

    HISTORY:
        ChuckC      16-May-1992     Created.

********************************************************************/
APIERR GENERIC_SERVICE :: EnumerateDependentServices( const TCHAR * pszService,
                                                      STRLIST     * pslKeyNames,
                                                      STRLIST     * pslDisplayNames )
{
    UIASSERT(pszService!= NULL) ;
    UIASSERT(pslKeyNames!= NULL) ;
    UIASSERT(pslDisplayNames!= NULL) ;

    pslKeyNames->Clear();
    pslDisplayNames->Clear();

    if( !_fIsNT )
    {
        //
        //  CODEWORK: Should we do that NETCMD hard-coded
        //  dependency list thang??
        //

        return NERR_Success;
    }

    // open service controller
    SC_MANAGER scManager( QueryServerName(),
                          GENERIC_READ );

    APIERR err ;
    if ((err = scManager.QueryError()) == NERR_Success)
    {
        // open the service we are interested in
        SC_SERVICE scService( scManager,
                              pszService,
                              GENERIC_READ | SERVICE_ENUMERATE_DEPENDENTS );

        if ((err = scService.QueryError()) == NERR_Success)
        {
            LPENUM_SERVICE_STATUS pServices ;
            UINT uServices ;

            // enumerate the dependent services
            err = scService.EnumDependent(SERVICE_ACTIVE,
                                          &pServices,
                                          (DWORD *)&uServices )  ;

            // while OK and we aint thru with all yet
            while (err == NERR_Success && uServices--)
            {
                // add to strlist
                NLS_STR * pnlsKeyName =
                    new NLS_STR( pServices->lpServiceName );

                err = ( pnlsKeyName == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                              : pnlsKeyName->QueryError();

                if( err == NERR_Success )
                {
                    err = pslKeyNames->Append( pnlsKeyName );
                }

                if( err != NERR_Success )
                {
                    break;
                }

                NLS_STR * pnlsDisplayName =
                    new NLS_STR( pServices->lpDisplayName );

                err = ( pnlsDisplayName == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                                  : pnlsDisplayName->QueryError();

                if( err == NERR_Success )
                {
                    err = pslDisplayNames->Append( pnlsDisplayName );
                }

                if( err != NERR_Success )
                {
                    break;
                }

                pServices++ ;
            }
        }
    }

    return err;

}   // GENERIC_SERVICE :: EnumerateDependentServices


#if 0

/*******************************************************************

    NAME:       SERVER_SERVICE::SERVER_SERVICE

    SYNOPSIS:   constructor for SERVER_SERVICE. does very little

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

SERVER_SERVICE::SERVER_SERVICE (const OWNER_WINDOW *powin,
                                const TCHAR *       pszServer)
    : UI_SERVICE (powin, pszServer, NULL, (const TCHAR *)SERVICE_SERVER)
{
    if (QueryError() != NERR_Success)
        return ;
}

/*******************************************************************

    NAME:       SERVER_SERVICE::stop_warning

    SYNOPSIS:   put up the appropriate warnings if the user wishes to
                stop the server.

    ENTRY:      This is a static method that can be called without
                construvting the object first. Just pass it valid
                powin and servername.

    EXIT:       User has been warned.

    RETURNS:    IDYES if user chooses to carry on, IDNO otherwise.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

UINT SERVER_SERVICE::stop_warning (const OWNER_WINDOW *powin,
                                   const TCHAR *pszServer,
                                   BOOL fConfirm)
{
    /*
     * create the session dialog
     */
    CURRENT_SESS_DIALOG *pSessDialog = new
        CURRENT_SESS_DIALOG (powin->QueryHwnd() ) ;
    if (pSessDialog == NULL)
    {
        MsgPopup( powin, ERROR_NOT_ENOUGH_MEMORY );
        return(IDNO) ;
    }

    /*
     * query the number of sessions. Note: if error,
     * we will just get FALSE back. Also, GetSession may ReportError.
     */
    BOOL fSessions = pSessDialog->GetSessions(pszServer) ;

    /*
     * now check for error. could have occurred during construction or
     * GetSessions. If error, bag out now.
     */
    APIERR err = pSessDialog->QueryError() ;
    if (err != NERR_Success)
    {
        delete pSessDialog ;
        MsgPopup( powin, err );
        return(IDNO) ;
    }

    /*
     * only bring up the sessions dialog if have sessions
     */
    if (fSessions)
    {
        UINT uReturnVal ;
        err = pSessDialog->Process(&uReturnVal);
        delete pSessDialog ;

        if ( err != NERR_Success )
        {
            /*
             * if error, report it and behave as if user said NO.
             */
            MsgPopup( powin, err );
            uReturnVal = IDNO ;
        }

        /*
         * if user didn't say YES, quit right here and now
         */
        if (uReturnVal != IDYES)
            return(uReturnVal) ;
    }
    else
        delete pSessDialog ;

    /*
     * if confirmation is on, put up another warning
     */
    if (fConfirm)
        if (MsgPopup(powin,IDS_STOP_WARNING,
                     MPSEV_WARNING,MP_YESNO,pszServer,MP_NO) != IDYES)
        {
            return(IDNO) ;
        }

    /*
     * if get here, everything passed
     */
    return (IDYES) ;
}


/*******************************************************************

    NAME:       SERVER_SERVICE::Stop

    SYNOPSIS:   stop the server service. This has a couple
                of special cases compared with normalservice.

    ENTRY:      object properly constructed

    EXIT:       service stopped

    RETURNS:    NERR_Success if success, API error otherwise

    NOTES:      while waiting for service to stop, if we
                get ERROR_BAD_NETPATH or ERROR_UNEXP_NET_ERR
                we assume we have successfully stopped the server.

    HISTORY:
        ChuckC      07-Sep-1991     Created (btw, this is Jim's birthday,
                                             as he points out in code review).

********************************************************************/

APIERR SERVER_SERVICE::Stop( VOID )
{
    /*
     * initiate the stop
     */
    APIERR err = LM_SERVICE::Stop() ;
    if (err != NERR_Success)
        return(err) ;

    /*
     * wait till it reaches desired state
     */
    err = Wait(LM_SVC_STOP) ;

    /*
     * special the cases below. Our net call to stop succeeded, but
     * the polling failed. Which implies the server is either dead is real
     * close to it!
     */
    if (err == ERROR_UNEXP_NET_ERR || err == ERROR_BAD_NETPATH)
        err = NERR_Success ;

    return (err) ;
}

#endif  // 0



/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::SERVICE_WAIT_DIALOG

    SYNOPSIS:   constructor for SERVICE_WAIT

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/
SERVICE_WAIT_DIALOG::SERVICE_WAIT_DIALOG( HWND                   hWndOwner,
                                          GENERIC_SERVICE      * psvc,
                                          LM_SERVICE_OPERATION   lmsvcOp,
                                          const TCHAR          * pszArgs,
                                          const TCHAR          * pszSrvDspName,
                                          BOOL                   fIsDevice )
  : DIALOG_WINDOW( IDD_SERVICE_CTRL_DIALOG, hWndOwner ),
    _timer( this, TIMER_FREQ, FALSE ),
    _lmsvcOp( lmsvcOp ),
    _psvc( psvc ),
    _pszArgs( pszArgs ),
    _progress( this, IDSCD_PROGRESS, IDI_PROGRESS_ICON_0, IDI_PROGRESS_NUM_ICONS ),
    _sltMessage( this, IDSCD_MESSAGE ),
    _pszSrvDspName( pszSrvDspName ),
    _nTickCounter( TIMER_MULT )
{
    UIASSERT( psvc != NULL );
    UIASSERT( pszSrvDspName != NULL );

    if (QueryError() != NERR_Success)
        return ;

    /*
     * figure out the message.
     */

    MSGID idMessage;

    switch (lmsvcOp)
    {
        case LM_SVC_START:
            idMessage = fIsDevice ? IDS_STARTING_DEV : IDS_STARTING ;
            break ;
        case LM_SVC_STOP:
            idMessage = fIsDevice ? IDS_STOPPING_DEV : IDS_STOPPING ;
            break ;
        case LM_SVC_PAUSE:
            idMessage = IDS_PAUSING ;
            break ;
        case LM_SVC_CONTINUE:
            idMessage = IDS_CONTINUING ;
            break ;
        default:
            UIASSERT(FALSE) ;  // bogus operation
            ReportError(ERROR_INVALID_PARAMETER) ;
            return ;
    }

    /*
     * set the message.
     */

    ALIAS_STR nlsService( psvc->QueryServiceDisplayName() );
    UIASSERT( nlsService.QueryError() == NERR_Success );

    ALIAS_STR nlsServer( _pszSrvDspName );
    UIASSERT( nlsServer.QueryError() == NERR_Success );

    RESOURCE_STR nlsMessage( idMessage );

    APIERR err = nlsMessage.QueryError();

    if( err == NERR_Success )
    {
        ISTR istrServer( nlsServer );
        istrServer += 2;

        err = nlsMessage.InsertParams( nlsService, nlsServer[istrServer] );
    }

    if( err == NERR_Success )
    {
        _sltMessage.SetText( nlsMessage );

        //
        //  Set the caption.
        //

        RESOURCE_STR nls( fIsDevice ? IDS_CAPTION_DEV_CONTROL
                                    : IDS_CAPTION_SVC_CONTROL );

        err = nls.QueryError();

        if( err == NERR_Success )
        {
            SetText( nls );
        }
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    /*
     * set polling timer
     */

    _timer.Enable( TRUE );

}

/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::~SERVICE_WAIT_DIALOG

    SYNOPSIS:   destructor for SERVICE_WAIT_DIALOG. Stops
                the timer if it has not already been stopped.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/
SERVICE_WAIT_DIALOG::~SERVICE_WAIT_DIALOG( VOID )
{
    _timer.Enable( FALSE );
}

/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        KeithMo     06-Oct-1991     Created.

********************************************************************/
VOID SERVICE_WAIT_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
        return;
    }

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  No need to continue if we're just amusing the user.
    //

    if( --_nTickCounter > 0 )
    {
        return;
    }

    _nTickCounter = TIMER_MULT;

    //
    //  Poll the service to see if the operation is
    //  either complete or continuing as expected.
    //

    BOOL fDone;
    APIERR err = _psvc->Poll( &fDone );

    if (err != NERR_Success)
    {
        //
        //      Either an error occurred retrieving the
        //      service status OR the service is returning
        //      bogus state information.
        //

        Dismiss( err );
        return;
    }

    if( fDone )
    {
        //
        //      The operation is complete.
        //
        Dismiss( NERR_Success );
        return;
    }

    //
    //  If we made it this far, then the operation is
    //  continuing as expected.  We'll have to wait for
    //  the next WM_TIMER message to recheck the service.
    //

}   // SERVICE_WAIT_DIALOG :: OnTimerNotification

/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG :: OnCancel

    SYNOPSIS:   Called when the user presses the [Cancel] button
                (which we don't have) or the [Esc] key.

    HISTORY:
        KeithMo     14-Sep-1992     Created.

********************************************************************/
BOOL SERVICE_WAIT_DIALOG :: OnCancel( VOID )
{
    Dismiss( FALSE );
    return TRUE;

}   // SERVICE_WAIT_DIALOG :: OnCancel


#if 0

/*******************************************************************

    NAME:       CURRENT_SESS_DIALOG::CURRENT_SESS_DIALOG

    SYNOPSIS:   constructor for CURRENT_SESS_DIALOG

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

CURRENT_SESS_DIALOG::CURRENT_SESS_DIALOG( HWND hWndOwner ):
                                DIALOG_WINDOW(MAKEINTRESOURCE(
                                    IDD_CURRENT_SESS_DIALOG),
                                    hWndOwner),
                                _sltServer(this,IDCU_SERVERNAME),
                                _lbComputers(this,IDCU_SESSIONSLISTBOX)
{
    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:       CURRENT_SESS_DIALOG::OnOK

    SYNOPSIS:   virtual replacement for OnOK. Dismiss with IDYES
                as return value.

    RETURNS:    TRUE always

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

BOOL CURRENT_SESS_DIALOG::OnOK( VOID )
{
    Dismiss(IDYES) ;
    return(TRUE) ;
}

/*******************************************************************

    NAME:       CURRENT_SESS_DIALOG::OnCancel

    SYNOPSIS:   virtual replacement for OnCancel. Dismiss with IDNO
                as return value.

    RETURNS:    TRUE always

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

BOOL CURRENT_SESS_DIALOG::OnCancel( VOID )
{
    Dismiss(IDNO) ;
    return(TRUE) ;
}


/*******************************************************************

    NAME:       CURRENT_SESS_DIALOG::GetSessions

    SYNOPSIS:   figures out if there are sessions and hence if
                dialog is worth putting up.

    RETURNS:    TRUE if there are sessions, FALSE if not.
                also returns FALSE if error occurs.

    NOTES:      caller should call QueryError() after this.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

BOOL CURRENT_SESS_DIALOG::GetSessions(const TCHAR *pszServer)
{
    UIASSERT(pszServer != NULL) ;

    /*
     * if object in error, just return 0.
     */
    APIERR err = QueryError() ;
    if ( err != NERR_Success )
        return(FALSE) ;

    /*
     * synthesize the server name
     */
    ISTACK_NLS_STR (nlsServer, MAX_PATH, SZ("\\\\") ) ;
    nlsServer += pszServer ;
    UIASSERT(nlsServer.QueryError()==NERR_Success) ;  // should not fail!

    /*
     * enumerate all sessions
     */
    SESSION0_ENUM enumSession0( (TCHAR *)nlsServer.QueryPch() );
    err = enumSession0.GetInfo();
    if( err != NERR_Success )
    {
        ReportError (err) ;
        return(FALSE) ;
    }

    /*
     *  We've got our enumeration, now find all computers
     */
    SESSION0_ENUM_ITER iterSession0( enumSession0 );
    const SESSION0_ENUM_OBJ * psi0 = iterSession0();
    if (psi0 == NULL)
        return(FALSE) ;

    /*
     * Add all to listbox
     */
    while( psi0 != NULL )
    {
        INT iEntry = _lbComputers.AddItem(psi0->QueryComputerName()) ;
        if (iEntry < 0)
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
            return(FALSE) ;
        }
        psi0 = iterSession0() ;
    }

    /*
     * fill in the server text while we're here, since we have
     * synthesized the name.
     */
    _sltServer.SetText(nlsServer.QueryPch()) ;
    return(TRUE) ;
}

#endif  // 0



/*******************************************************************

    NAME:       STOP_DEPENDENT_DIALOG::STOP_DEPENDENT_DIALOG

    SYNOPSIS:   constructor for STOP_DEPENDENT_DIALOG

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

STOP_DEPENDENT_DIALOG::STOP_DEPENDENT_DIALOG( HWND              hWndOwner,
                                              GENERIC_SERVICE * psvc,
                                              STRLIST         * pslKeyNames,
                                              STRLIST         * pslDisplayNames )
  : DIALOG_WINDOW( IDD_SVC_DEP_DIALOG, hWndOwner ),
    _psvc( psvc ),
    _pslKeyNames( pslKeyNames ),
    _pslDisplayNames( pslDisplayNames ),
    _sltParentService( this, IDSDD_PARENT_SERVICE ),
    _lbDepServices( this, IDSDD_DEP_SERVICES )
{
    if (QueryError() != NERR_Success)
        return ;

    /*
     * set the caption
     */
    RESOURCE_STR nlsOperation(IDS_SERVICE_STOPPING) ;
    APIERR err = nlsOperation.QueryError() ;
    if (err != NERR_Success)
    {
        ReportError(err) ;
        return ;
    }
    SetText(nlsOperation.QueryPch()) ;

    /*
     * set the text describing the parent service
     */
    _sltParentService.SetText(_psvc->QueryServiceDisplayName()) ;

    /*
     * fill listbox with dependent services
     */
    ITER_STRLIST islDisplayNames(*_pslDisplayNames) ;
    NLS_STR * pnlsDisplayName;
    while( pnlsDisplayName = islDisplayNames.Next() )
        _lbDepServices.AddItem( pnlsDisplayName->QueryPch() );
}

/*******************************************************************

    NAME:       STOP_DEPENDENT_DIALOG::~STOP_DEPENDENT_DIALOG

    SYNOPSIS:   destructor for STOP_DEPENDENT_DIALOG.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

STOP_DEPENDENT_DIALOG::~STOP_DEPENDENT_DIALOG( VOID )
{
    ;   // nuthin more to do
}

/*******************************************************************

    NAME:       STOP_DEPENDENT_DIALOG::OnOK

    SYNOPSIS:   action on OK button being hit

    HISTORY:
        ChuckC      01-Apr-1992     Created

********************************************************************/
BOOL STOP_DEPENDENT_DIALOG::OnOK( VOID )
{
    APIERR err ;

    AUTO_CURSOR NiftyCursor;

    STOP_DEP_WAIT_DIALOG *pdlg =
        new STOP_DEP_WAIT_DIALOG(QueryHwnd(),
                                 _psvc->QueryServerName(),
                                 _psvc->QueryServerDisplayName(),
                                 _pslKeyNames,
                                 _pslDisplayNames);
    if (pdlg == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY ;
    else
        err = pdlg->QueryError() ;

    if (err != NERR_Success)
    {
        MsgPopup( this, err );
        delete pdlg ;
        pdlg = NULL ;
        Dismiss( FALSE ) ;
        return(TRUE) ;
    }

    UINT retval ;

    err = pdlg->Process(&retval) ;

    delete pdlg ;
    pdlg = NULL ;

    if (err != NERR_Success)
        MsgPopup( this, err );
    else if (retval != NERR_Success)
        MsgPopup( this, retval );

    Dismiss( ( err == NERR_Success ) && ( retval == NERR_Success ) );
    return(TRUE) ;
}

/*******************************************************************

    NAME:       STOP_DEPENDENT_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     22-Dec-1992 Created.

********************************************************************/
ULONG STOP_DEPENDENT_DIALOG :: QueryHelpContext( void )
{
    return HC_SVC_DEP_DIALOG;

}   // STOP_DEPENDENT_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       STOP_DEP_WAIT_DIALOG::STOP_DEP_WAIT_DIALOG

    SYNOPSIS:   constructor

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

STOP_DEP_WAIT_DIALOG::STOP_DEP_WAIT_DIALOG( HWND          hWndOwner,
                                            const TCHAR * pszServer,
                                            const TCHAR * pszSrvDspName,
                                            STRLIST     * pslKeyNames,
                                            STRLIST     * pslDisplayNames )
  : DIALOG_WINDOW( IDD_SERVICE_CTRL_DIALOG, hWndOwner ),
    _timer( this, TIMER_FREQ, FALSE ),
    _pslKeyNames( pslKeyNames ),
    _pslDisplayNames( pslDisplayNames ),
    _progress( this, IDSCD_PROGRESS, IDI_PROGRESS_ICON_0, IDI_PROGRESS_NUM_ICONS ),
    _sltMessage( this, IDSCD_MESSAGE ),
    _islKeyNames( *pslKeyNames ),
    _islDisplayNames( *pslDisplayNames ),
    _pszServer( pszServer ),
    _pszSrvDspName( pszSrvDspName ),
    _psvc( NULL ),
    _nTickCounter( TIMER_MULT )
{
    UIASSERT( pszSrvDspName != NULL );
    UIASSERT( pslKeyNames != NULL );
    UIASSERT( pslDisplayNames != NULL );

    AUTO_CURSOR NiftyCursor;

    if( QueryError() != NERR_Success )
    {
        return;
    }

    NLS_STR * pnlsKeyName     = _islKeyNames.Next();
    NLS_STR * pnlsDisplayName = _islDisplayNames.Next();

    if( pnlsKeyName == NULL )
    {
        UIASSERT( pnlsDisplayName == NULL );
        Dismiss( NERR_Success );
        return;
    }

    UIASSERT( pnlsDisplayName != NULL );

    APIERR err = StopNextInList( pnlsKeyName, pnlsDisplayName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

     // set polling timer
    _timer.Enable( TRUE );
}

/*******************************************************************

    NAME:       STOP_DEP_WAIT_DIALOG::~STOP_DEP_WAIT_DIALOG

    SYNOPSIS:   destructor for STOP_DEP_WAIT_DIALOG. Stops
                the timer if it has not already been stopped.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

STOP_DEP_WAIT_DIALOG::~STOP_DEP_WAIT_DIALOG( VOID )
{
    _timer.Enable( FALSE );
    delete _psvc ;
    _psvc = NULL ;
}

/*******************************************************************

    NAME:       STOP_DEP_WAIT_DIALOG::OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        KeithMo     06-Oct-1991     Created.

********************************************************************/
VOID STOP_DEP_WAIT_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
        return;
    }

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  No need to continue if we're just amusing the user.
    //

    if( --_nTickCounter > 0 )
    {
        return;
    }

    _nTickCounter = TIMER_MULT;

    //
    //  Poll the service to see if the operation is
    //  either complete or continuing as expected.
    //

    BOOL fDone;
    APIERR err = _psvc->Poll( &fDone );

    if (err != NERR_Success)
    {
        //
        //      Either an error occurred retrieving the
        //      service status OR the service is returning
        //      bogus state information.
        //

        Dismiss( err );
        return;
    }

    if( fDone )
    {
        //
        //      are there anymore?
        //

        NLS_STR * pnlsKeyName     = _islKeyNames.Next();
        NLS_STR * pnlsDisplayName = _islDisplayNames.Next();

        if( pnlsKeyName == NULL )
        {
            UIASSERT( pnlsDisplayName == NULL );
            Dismiss( NERR_Success );
            return;
        }

        UIASSERT( pnlsDisplayName != NULL );

        APIERR err = StopNextInList( pnlsKeyName, pnlsDisplayName );

        if( err != NERR_Success )
        {
            Dismiss( err );
            return;
        }
    }

    //
    //  If we made it this far, then the operation is
    //  continuing as expected.  We'll have to wait for
    //  the next WM_TIMER message to recheck the service.
    //

}   // STOP_DEP_WAIT_DIALOG :: OnTimerNotification


/*******************************************************************

    NAME:       STOP_DEP_WAIT_DIALOG :: OnCancel

    SYNOPSIS:   Called when the user presses the [Cancel] button
                (which we don't have) or the [Esc] key.

    HISTORY:
        KeithMo     14-Sep-1992     Created.

********************************************************************/
BOOL STOP_DEP_WAIT_DIALOG :: OnCancel( VOID )
{
    Dismiss( FALSE );
    return TRUE;

}   // STOP_DEP_WAIT_DIALOG :: OnCancel


/*******************************************************************

    NAME:       STOP_DEP_WAIT_DIALOG :: StopNextInList

    SYNOPSIS:   Stop the next service in the list.

    HISTORY:
        ChuckC      ??-???-????     Created.

********************************************************************/
APIERR STOP_DEP_WAIT_DIALOG::StopNextInList( NLS_STR * pnlsKeyName,
                                             NLS_STR * pnlsDisplayName )
{
    //
    //  Delete the current service (if any).
    //

    delete _psvc;
    _psvc = NULL;

    //
    //  Display the appropriate message.
    //

    ALIAS_STR nlsServer( _pszSrvDspName );
    UIASSERT( !!nlsServer );

    RESOURCE_STR nlsMessage( IDS_STOPPING );
    APIERR err = nlsMessage.QueryError();

    if( err == NERR_Success )
    {
        ISTR istrServer( nlsServer );
        istrServer += 2;

        err = nlsMessage.InsertParams( *pnlsDisplayName, nlsServer[istrServer] );
    }

    if( err == NERR_Success )
    {
        //
        //  Create a new service object.
        //

        _psvc = new LM_SERVICE( _pszServer, pnlsKeyName->QueryPch() );

        err = ( _psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : _psvc->QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Display the message, then initiate the stop action.
        //

        _sltMessage.SetText( nlsMessage );
        err = _psvc->Stop();
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\svclb.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    svclb.cxx
    Class definitions for the SVCCNTL_LISTBOX and SVCCNTL_LBI classes.


    FILE HISTORY:
        KeithMo     22-Dec-1992 Split off from svccntl.hxx.

*/

#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_WINDOWS
#define INCL_NETSERVER
#include <lmui.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <lmobj.hxx>
#include <lmoenum.hxx>
#include <lmoesvc.hxx>
#include <svclb.hxx>

extern "C"
{
    #include <srvmgr.h>

}   // extern "C"



//
//  SVC_LISTBOX methods
//

/*******************************************************************

    NAME:           SVC_LISTBOX :: SVC_LISTBOX

    SYNOPSIS:       SVC_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pszServerName       - The target server's API name.

                    nServerType         - The target server's type bitmask.

                    nServiceTypes       - The "type" of services to list.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVC_LISTBOX :: SVC_LISTBOX( OWNER_WINDOW * powner,
                            CID            cid,
                            const TCHAR  * pszServerName,
                            ULONG          nServerType,
                            UINT           nServiceTypes )
  : BLT_LISTBOX( powner, cid ),
    _nlsStarted( IDS_STARTED ),
    _nlsPaused( IDS_PAUSED ),
    _nlsBoot( IDS_BOOT ),
    _nlsSystem( IDS_SYSTEM ),
    _nlsAutomatic( IDS_AUTOMATIC ),
    _nlsManual( IDS_MANUAL ),
    _nlsDisabled( IDS_DISABLED ),
    _pszServerName( pszServerName ),
    _nServerType( nServerType ),
    _nServiceTypes( nServiceTypes )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsStarted.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsPaused.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsBoot.QueryError()      ) != NERR_Success ) ||
        ( ( err = _nlsSystem.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsAutomatic.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsManual.QueryError()    ) != NERR_Success ) ||
        ( ( err = _nlsDisabled.QueryError()  ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     NUM_SVC_LISTBOX_COLUMNS,
                                     powner,
                                     cid,
                                     FALSE );

}   // SVC_LISTBOX :: SVC_LISTBOX


/*******************************************************************

    NAME:           SVC_LISTBOX :: ~SVC_LISTBOX

    SYNOPSIS:       SVC_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVC_LISTBOX :: ~SVC_LISTBOX( VOID )
{
    _pszServerName = NULL;

}   // SVC_LISTBOX :: ~SVC_LISTBOX


/*******************************************************************

    NAME:           SVC_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
APIERR SVC_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Construct our service enumerator.
    //

    SERVICE_ENUM enumServices( _pszServerName,
                               ( _nServerType & SV_TYPE_NT ) > 0,
                               _nServiceTypes );

    APIERR err = enumServices.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  OK, now that we've got the enumeration, blow away
    //  the current listbox contents.
    //

    DeleteAllItems();

    //
    //  And add the current enumeration list to the listbox.
    //

    SERVICE_ENUM_ITER iterServices( enumServices );
    const SERVICE_ENUM_OBJ * psvc;

    while( ( psvc = iterServices() ) != NULL )
    {
        ULONG State = psvc->QueryCurrentState();
        ULONG StartType = psvc->QueryStartType();

        SVC_LBI * plbi = new SVC_LBI( psvc->QueryServiceName(),
                                      psvc->QueryDisplayName(),
                                      State,
                                      MapStateToName( State ),
                                      psvc->QueryControlsAccepted(),
                                      StartType,
                                      MapStartTypeToName( StartType ) );

        if( AddItem( plbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
    }

    //
    //  Success!
    //

    return err;

}   // SVC_LISTBOX :: Fill


/*******************************************************************

    NAME:           SVC_LISTBOX :: MapStateToName

    SYNOPSIS:       Maps a service state value (such as SERVICE_STOPPED)
                    to a human readable representation (such as "Stopped").

    ENTRY:          State               - The state to map.

    RETURNS:        const TCHAR *       - The name of the state.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
const TCHAR * SVC_LISTBOX :: MapStateToName( ULONG State ) const
{
    const TCHAR * pszStateName = NULL;

    switch( State )
    {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        //
        //  Note that, be design, we never display the service
        //  status as "Stopped".  Instead, we just don't display
        //  the status.  Hence, the empty string.
        //

        pszStateName = SZ("");
        break;

    case SERVICE_RUNNING:
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
        pszStateName = _nlsStarted.QueryPch();
        break;

    case SERVICE_PAUSED:
    case SERVICE_PAUSE_PENDING:
        pszStateName = _nlsPaused.QueryPch();
        break;

    default:
        UIASSERT( FALSE );
        pszStateName = SZ("??");
        break;
    }

    return pszStateName;

}   // SVC_LISTBOX :: MapStateToName


/*******************************************************************

    NAME:           SVC_LISTBOX :: MapStartTypeToName

    SYNOPSIS:       Maps a service start type (such as SERVICE_AUTO_START)
                    to a displayable form (such as "Automatic").

    ENTRY:          StartType           - The start type to map.

    RETURNS:        const TCHAR *       - The name of the start type.

    HISTORY:
        KeithMo     19-Jul-1992 Created.

********************************************************************/
const TCHAR * SVC_LISTBOX :: MapStartTypeToName( ULONG StartType ) const
{
    const TCHAR * pszStartTypeName = NULL;

    switch( StartType )
    {
    case SERVICE_BOOT_START :
        pszStartTypeName = _nlsBoot;
        break;

    case SERVICE_SYSTEM_START :
        pszStartTypeName = _nlsSystem;
        break;

    case SERVICE_AUTO_START :
        pszStartTypeName = _nlsAutomatic;
        break;

    case SERVICE_DEMAND_START :
        pszStartTypeName = _nlsManual;
        break;

    case SERVICE_DISABLED :
        pszStartTypeName = _nlsDisabled;
        break;

    default:
        UIASSERT( FALSE );
        pszStartTypeName = SZ("??");
        break;
    }

    return pszStartTypeName;

}   // SVC_LISTBOX :: MapStartTypeToName



//
//  SVC_LBI methods
//

/*******************************************************************

    NAME:           SVC_LBI :: SVC_LBI

    SYNOPSIS:       SVC_LBI class constructor.

    ENTRY:          pszServiceName      - The service name.

                    CurrentState        - The current state of the service.

                    pszStateName        - A human readable representation
                                          of the current state.

                    ControlsAccepted    - The controls accepted by this
                                          service.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVC_LBI :: SVC_LBI( const TCHAR * pszServiceName,
                    const TCHAR * pszDisplayName,
                    ULONG         CurrentState,
                    const TCHAR * pszStateName,
                    ULONG         ControlsAccepted,
                    ULONG         StartType,
                    const TCHAR * pszStartType )
  : _CurrentState( CurrentState ),
    _pszCurrentState( pszStateName ),
    _ControlsAccepted( ControlsAccepted ),
    _nlsServiceName( pszServiceName ),
    _nlsDisplayName( pszDisplayName ),
    _StartType( StartType ),
    _pszStartType( pszStartType )
{
    UIASSERT( pszServiceName != NULL );
    UIASSERT( pszStateName   != NULL );
    UIASSERT( pszStartType   != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsServiceName )
    {
        ReportError( _nlsServiceName.QueryError() );
        return;
    }

    if( !_nlsDisplayName )
    {
        ReportError( _nlsDisplayName.QueryError() );
        return;
    }

}   // SVC_LBI :: SVC_LBI


/*******************************************************************

    NAME:           SVC_LBI :: ~SVC_LBI

    SYNOPSIS:       SVC_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVC_LBI :: ~SVC_LBI()
{
    _pszCurrentState = NULL;
    _pszStartType    = NULL;

}   // SVC_LBI :: ~SVC_LBI


/*******************************************************************

    NAME:           SVC_LBI :: Paint

    SYNOPSIS:       Draw an entry in SVC_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     15-Jan-1992 Created.
        beng        22-Apr-1992 Changes to LBI::Paint

********************************************************************/
VOID SVC_LBI :: Paint( LISTBOX *      plb,
                       HDC            hdc,
                       const RECT   * prect,
                       GUILTT_INFO  * pGUILTT ) const
{
    STR_DTE dteDisplayName( _nlsDisplayName.QueryPch() );
    STR_DTE dteStateName( _pszCurrentState );
    STR_DTE dteStartTypeName( _pszStartType );

    DISPLAY_TABLE dtab( NUM_SVC_LISTBOX_COLUMNS,
                        ((SVC_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteDisplayName;
    dtab[1] = &dteStateName;
    dtab[2] = &dteStartTypeName;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // SVC_LBI :: Paint


/*******************************************************************

    NAME:       SVC_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
WCHAR SVC_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsDisplayName );

    return _nlsDisplayName.QueryChar( istr );

}   // SVC_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       SVC_LBI :: Compare

    SYNOPSIS:   Compare two SVC_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
INT SVC_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsDisplayName._stricmp( ((const SVC_LBI *)plbi)->_nlsDisplayName );

}   // SVC_LBI :: Compare


/*******************************************************************

    NAME:       SVC_LBI :: SetStartType

    SYNOPSIS:   Sets the start type for this service listbox item.

    ENTRY:      StartType               - The new start type.

                pszStartType            - Displayable form of the start type.

    HISTORY:
        KeithMo     19-Jul-1992 Created.

********************************************************************/
VOID SVC_LBI :: SetStartType( ULONG         StartType,
                              const TCHAR * pszStartType )
{
    _StartType    = StartType;
    _pszStartType = pszStartType;

}   // SVC_LBI :: SetStartType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\userlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    userlb.cxx
    Class definitions for the USERS_LISTBOX and USERS_LBI classes.

    The USERS_LISTBOX and USERS_LBI classes are used to show the
    users connected to a particular shared resource.


    FILE HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.
        KeithMo     26-Aug-1991 Changes from code review attended by
                                RustanL and EricCh.
        KeithMo     22-Sep-1991 Changed to the "New SrvMgr" look.
        KeithMo     06-Oct-1991 Win32 Conversion.
        KeithMo     01-Apr-1992 Added AreResourcesOpen().

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_NETERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmoenum.hxx>
#include <lmoeconn.hxx>
#include <lmosrv.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C"
{
    #include <stdlib.h>     // toupper

    #include <srvmgr.h>

}   // extern "C"

#include <userlb.hxx>
#include <lmsrvres.hxx>


//
//  min/max macros
//

#define min(x,y) (((x) < (y)) ? (x) : (y))
#define max(x,y) (((x) > (y)) ? (x) : (y))


//
//  USERS_LISTBOX methods.
//

/*******************************************************************

    NAME:       USERS_LISTBOX :: USERS_LISTBOX

    SYNOPSIS:   USERS_LISTBOX class constructor.

    ENTRY:      powner                  - The owning window.

                cid                     - The listbox CID.

                pserver                 - The server object.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.
        KeithMo     14-Oct-1991 Use INTL_PROFILE to get time separator.
        KeithMo     18-Feb-1992 Made the listbox read only.

********************************************************************/
USERS_LISTBOX :: USERS_LISTBOX( OWNER_WINDOW   * powner,
                                CID              cid,
                                const SERVER_2 * pserver )
  : BLT_LISTBOX( powner, cid ),
    _pserver( pserver ),
    _dteIcon( IDBM_LB_USER ),
    _nlsShare()
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_dteIcon )
    {
        ReportError( _dteIcon.QueryError() );
        return;
    }

    if( !_nlsShare )
    {
        ReportError( _nlsShare.QueryError() );
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;

    if( !nlsTimeSep )
    {
        ReportError( nlsTimeSep.QueryError() );
        return;
    }

    INTL_PROFILE intl;

    if( !intl )
    {
        ReportError( intl.QueryError() );
        return;
    }

    APIERR err = intl.QueryTimeSeparator( &nlsTimeSep );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build the column width table used for
    //  displaying the listbox items.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     4,
                                     powner,
                                     cid,
                                     TRUE) ;
}   // USERS_LISTBOX :: USERS_LISTBOX


/*******************************************************************

    NAME:       USERS_LISTBOX :: ~USERS_LISTBOX

    SYNOPSIS:   USERS_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
USERS_LISTBOX :: ~USERS_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // USERS_LISTBOX :: ~USERS_LISTBOX


/*******************************************************************

    NAME:       USERS_LISTBOX :: Fill

    SYNOPSIS:   Fills the listbox with the connected users.

    ENTRY:      pszShare                - The target sharename.  Note
                                          that this sharename is "sticky"
                                          in that it will be used in
                                          subsequent Refresh() calls.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.
        KeithMo     23-Sep-1992 Always clear listbox on error.

********************************************************************/
APIERR USERS_LISTBOX :: Fill( const TCHAR * pszShare )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Nuke the listbox.
    //

    DeleteAllItems();

    //
    //  Save our sharename away.
    //

    _nlsShare = pszShare;

    if( !_nlsShare )
    {
        return _nlsShare.QueryError();
    }

    //
    //  If our qualifier is NULL (a valid scenario) then
    //  there are no connections in the listbox.
    //

    if( pszShare == NULL )
    {
        return NERR_Success;
    }

    //
    //  Our connection enumerator.
    //

    CONN1_ENUM enumConn1( (TCHAR *)_pserver->QueryName(), (TCHAR *)pszShare );

    //
    //  See if the connections are available.
    //

    APIERR err = enumConn1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    SetRedraw( FALSE );

    //
    //  For iterating the available connections.
    //

    CONN1_ENUM_ITER iterConn1( enumConn1 );
    const CONN1_ENUM_OBJ * pconi1;

    //
    //  Iterate the connections adding them to the listbox.
    //

    while( ( err == NERR_Success ) && ( ( pconi1 = iterConn1() ) != NULL ) )
    {
        USERS_LBI * pclbi = new USERS_LBI( pconi1->QueryUserName(),
                                           pconi1->QueryNetName(),
                                           pconi1->QueryTime(),
                                           pconi1->QueryNumOpens(),
                                           _chTimeSep );

        if( AddItem( pclbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // USERS_LISTBOX :: Fill


/*******************************************************************

    NAME:       USERS_LISTBOX :: Refresh

    SYNOPSIS:   Refreshes the listbox, maintaining (as much as
                possible) the relative position of the current
                selection.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      This method is now obsolete.  It will be replaced
                as soon as KevinL's WFC refreshing listbox code is
                available.

    HISTORY:
        KeithMo     31-Jul-1991 Created.

********************************************************************/
APIERR USERS_LISTBOX :: Refresh( VOID )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    APIERR err = Fill( _nlsShare.QueryPch() );

    if( err != NERR_Success )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        iCurrent = min( max( iCurrent, 0 ), cItems - 1 );
        iTop     = min( max( iTop, 0 ), cItems - 1 );

        SelectItem( iCurrent );
        SetTopIndex( iTop );
    }

    return NERR_Success;

}   // USERS_LISTBOX :: Refresh


/*******************************************************************

    NAME:       USERS_LISTBOX :: AreResourcesOpen

    SYNOPSIS:   Returns TRUE if any user in the listbox has any
                resources open.

    RETURNS:    BOOL

    HISTORY:
        KeithMo     01-Apr-1992 Created.

********************************************************************/
BOOL USERS_LISTBOX :: AreResourcesOpen( VOID ) const
{
    INT cItems = QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        USERS_LBI * plbi = QueryItem( i );

        if( plbi && plbi->QueryNumOpens() > 0 ) // JonN 01/28/00: PREFIX bug 444941
        {
            return TRUE;
        }
    }

    return FALSE;

}   // USERS_LISTBOX :: AreResourcesOpen



//
//  USERS_LBI methods.
//

/*******************************************************************

    NAME:       USERS_LBI :: USERS_LBI

    SYNOPSIS:   USERS_LBI class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                pszComputerName         - The user's computer name.

                ulTime                  - Connection time.

                cOpens                  - Number of opens on this connection.

                chTimeSep               - Time format separator.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.

********************************************************************/
USERS_LBI :: USERS_LBI( const TCHAR * pszUserName,
                        const TCHAR * pszComputerName,
                        ULONG         ulTime,
                        UINT          cOpens,
                        TCHAR         chTimeSep )
  : _nlsUserName( pszUserName ),
    _nlsComputerName( pszComputerName ),
    _nlsInUse(),
    _nlsTime( ulTime, chTimeSep ),
    _cOpens( cOpens )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsUserName.QueryError()     ) != NERR_Success ) ||
        ( ( err = _nlsComputerName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsInUse.QueryError()        ) != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError()         ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

#ifdef DEBUG
    //
    //  Ensure that the server name doesn't already have backslashes.
    //

    ISTR istrDbg( _nlsComputerName );

    UIASSERT( _nlsComputerName.QueryChar( istrDbg ) != '\\' );
#endif

    //
    //  Build the more complex display strings.
    //

    err = _nlsInUse.Load( ( cOpens > 0 ) ? IDS_YES : IDS_NO );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // USERS_LBI :: USERS_LBI


/*******************************************************************

    NAME:       USERS_LBI :: ~USERS_LBI

    SYNOPSIS:   USERS_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.

********************************************************************/
USERS_LBI :: ~USERS_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // USERS_LBI :: ~USERS_LBI


/*******************************************************************

    NAME:       USERS_LBI :: Paint

    SYNOPSIS:   Draw an entry in USERS_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.
        KeithMo     06-Oct-1991 Now takes a const RECT *.
        beng        22-Apr-1992 Changes to LBI::Paint

********************************************************************/
VOID USERS_LBI :: Paint( LISTBOX *        plb,
                         HDC              hdc,
                         const RECT     * prect,
                         GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteDisplayName( QueryDisplayName() );
    STR_DTE dteTime( _nlsTime.QueryPch() );
    STR_DTE dteInUse( _nlsInUse.QueryPch() );

    DISPLAY_TABLE dtab( 4, ((USERS_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = (DMID_DTE *) ((USERS_LISTBOX *)plb)->QueryIcon();
    dtab[1] = &dteDisplayName;
    dtab[2] = &dteTime;
    dtab[3] = &dteInUse;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // USERS_LBI :: Paint


/*******************************************************************

    NAME:       USERS_LBI :: QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR                   - The leading character.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.

********************************************************************/
WCHAR USERS_LBI :: QueryLeadingChar( VOID ) const
{
    return (WCHAR)*QueryDisplayName();

}   // USERS_LBI :: QueryLeadingChar

/*******************************************************************

    NAME:       USERS_LBI :: Compare

    SYNOPSIS:   Compare two USERS_LBI items.

    ENTRY:      plbi                    - The "other" item.

    RETURNS:    INT                     -  0 if the items match.
                                          -1 if we're < the other item.
                                          +1 if we're > the other item.

    HISTORY:
        KeithMo     18-Jun-1991 Created for the Server Manager.

********************************************************************/
INT USERS_LBI :: Compare( const LBI * plbi ) const
{
    return ::stricmpf( QueryDisplayName(),
                       ((const USERS_LBI *)plbi)->QueryDisplayName() );

}   // USERS_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\server\svccntl.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    svccntl.hxx
    Class definitions for the SVCCNTL_DIALOG class.

    The SVCCNTL_DIALOG allows the user to directly manipulate the
    network services on a remote server.  The user can start, stop,
    pause, and continue the available services.


    FILE HISTORY:
        KeithMo     15-Jan-1992 Created for the Server Manager.
        KeithMo     27-Jan-1992 Added DisableControlButtons method.
        KeithMo     31-Jan-1992     Changes from code review on 29-Jan-1992
                                    attended by ChuckC, EricCh, TerryK.
        KeithMo     24-Jul-1992 Added alternate constructor & other special
                                casing for the Services Manager Applet.
        KeithMo     11-Nov-1992 DisplayName support.
        KeithMo     22-Apr-1993 Ensure logon accounts have service logon
                                privilege, special case Replicator's account.

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETDOMAIN
#define INCL_ICANON
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <srvsvc.hxx>
#include <dbgstr.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <usrbrows.hxx>
#include <strnumer.hxx>
#include <lsaaccnt.hxx>
#include <svcman.hxx>
#include <svclb.hxx>
#include <svccntl.hxx>
#include <hwprof.hxx> // for SVC_HWPROFILE_DIALOG
#include <lmowks.hxx>
#include <lmosrvmo.hxx>
#include <lmodom.hxx>
#include <lmouser.hxx> // UI_NULL_USERSETINFO_PASSWD

extern "C"
{
    #include <srvmgr.h>
    #include <mnet.h>

}   // extern "C"



//
//  This is the maximum number of characters allowed in the
//  startup parameters SLE.
//
//  CODEWORK:  The number 512 was chosen purely at random.
//

#define SM_MAX_PARAMETER_LENGTH 512


//
//  This manifest is used to control/validate the length
//  limits of passwords.
//

#define SM_MAX_PASSWORD_LENGTH  LM20_PWLEN


//
//  This is the prefix used for a qualified account name
//  specifying the local machine as the domain.
//

#define LOCAL_MACHINE_DOMAIN    SZ(".\\")


//
//  This is the name of the Local System Account.
//

const TCHAR * pszLocalSystemAccount = SZ("LocalSystem");



//
//  SVCCNTL_DIALOG methods
//

/*******************************************************************

    NAME:           SVCCNTL_DIALOG :: SVCCNTL_DIALOG

    SYNOPSIS:       SVCCNTL_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszServerName       - The target server's API name.

                    pszSrvDspName       - The target server's display name.

                    nServerType         - The target server's type bitmask.

    EXIT:           The object is constructed.

    NOTE:           Note that the service control buttons (Start, Stop,
                    Pause, and Continue) are disabled by default.  They
                    will be enabled by the SetupControlButtons method
                    if appropriate.

    HISTORY:
        KeithMo     24-Jul-1992 Created.

********************************************************************/
SVCCNTL_DIALOG :: SVCCNTL_DIALOG( HWND          hWndOwner,
                                  const TCHAR * pszServerName,
                                  const TCHAR * pszSrvDspName,
                                  ULONG         nServerType )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SVCCNTL_DIALOG ), hWndOwner ),
    _lbServices( this,
                 IDSC_SERVICES,
                 pszServerName,
                 nServerType,
                 SERVICE_WIN32 ),
    _pbStart( this, IDSC_START ),
    _pbStop( this, IDSC_STOP ),
    _pbPause( this, IDSC_PAUSE ),
    _pbContinue( this, IDSC_CONTINUE ),
    _pbConfigure( this, IDSC_CONFIGURE ),
    _pbHWProfile( this, IDSC_HWPROFILE ),
    _pbClose( this, IDOK ),
    _sleParameters( this, IDSC_PARAMETERS, SM_MAX_PARAMETER_LENGTH ),
    _pszServerName( pszServerName ),
    _nServerType( nServerType ),
    _nlsSrvDspName( pszSrvDspName ),
    _hCfgMgrHandle( NULL ),
    _nlsAccountTarget( pszServerName ),
    _fAccountTargetAvailable( FALSE ),
    _fServicesManipulated( FALSE ),
    _fTargetServerIsLocal( TRUE )
{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSrvDspName )
    {
        ReportError( _nlsSrvDspName.QueryError() );
        return;
    }

    //
    //  Set the caption.
    //

    APIERR err = SRV_BASE_DIALOG::SetCaption( this,
                                              IDS_CAPTION_SVCCNTL,
                                              _nlsSrvDspName );

    if( err == NERR_Success )
    {
        //
        //  Determine if this is focused on a BDC.  If it is,
        //  retrieve the name of the PDC of the primary domain.
        //

        _fAccountTargetAvailable = GetAccountTarget();
    }

    //
    // We must do this before Refresh, otherwise the HW Profiles button
    // is always initially disabled.
    //
    if ( (err == NERR_Success) && (( _nServerType & SV_TYPE_NT ) != 0) )
    {
        // an error here just means we should not enable the pushbutton
        err = HWPROFILE_DIALOG::GetHandle( pszServerName,
                                           &_hCfgMgrHandle );
        ASSERT( (err == NERR_Success) == (_hCfgMgrHandle != NULL) );
        err = NERR_Success;
    }

    if( err == NERR_Success )
    {
        //
        //  Fill the service Listbox.
        //

        err = Refresh();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SVCCNTL_DIALOG :: SVCCNTL_DIALOG

/*******************************************************************

    NAME:           SVCCNTL_DIALOG :: SVCCNTL_DIALOG

    SYNOPSIS:       SVCCNTL_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pserver             - a SERVER_2 object representing the
                                          target server.

    EXIT:           The object is constructed.

    NOTE:           Note that the service control buttons (Start, Stop,
                    Pause, and Continue) are disabled by default.  They
                    will be enabled by the SetupControlButtons method
                    if appropriate.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVCCNTL_DIALOG :: SVCCNTL_DIALOG( HWND       hWndOwner,
                                  SERVER_2 * pserver )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SVCCNTL_DIALOG ), hWndOwner ),
    _lbServices( this,
                 IDSC_SERVICES,
                 pserver->QueryName(),
                 pserver->QueryServerType(),
                 SERVICE_WIN32 ),
    _pbStart( this, IDSC_START ),
    _pbStop( this, IDSC_STOP ),
    _pbPause( this, IDSC_PAUSE ),
    _pbContinue( this, IDSC_CONTINUE ),
    _pbConfigure( this, IDSC_CONFIGURE ),
    _pbHWProfile( this, IDSC_HWPROFILE ),
    _pbClose( this, IDOK ),
    _sleParameters( this, IDSC_PARAMETERS, SM_MAX_PARAMETER_LENGTH ),
    _pszServerName( pserver->QueryName() ),
    _nServerType( pserver->QueryServerType() ),
    _nlsSrvDspName(),
    _hCfgMgrHandle( NULL ),
    _nlsAccountTarget( pserver->QueryName() ),
    _fAccountTargetAvailable( FALSE ),
    _fServicesManipulated( FALSE ),
    _fTargetServerIsLocal( FALSE )
{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsSrvDspName )
    {
        ReportError( _nlsSrvDspName.QueryError() );
        return;
    }

    //
    //  Set the caption.
    //

    APIERR err = pserver->QueryDisplayName( &_nlsSrvDspName );

    if( err == NERR_Success )
    {
        err = SRV_BASE_DIALOG::SetCaption( this,
                                           IDS_CAPTION_SVCCNTL,
                                           _nlsSrvDspName );
    }

    if( err == NERR_Success )
    {
        //
        //  Determine if this is focused on a BDC.  If it is,
        //  retrieve the name of the PDC of the primary domain.
        //

        _fAccountTargetAvailable = GetAccountTarget();
    }

    //
    // We must do this before Refresh, otherwise the HW Profiles button
    // is always initially disabled.
    //
    if ( (err == NERR_Success) && (( _nServerType & SV_TYPE_NT ) != 0) )
    {
        // an error here just means we should not enable the pushbutton
        err = HWPROFILE_DIALOG::GetHandle( _pszServerName,
                                           &_hCfgMgrHandle );
        ASSERT( (err == NERR_Success) == (_hCfgMgrHandle != NULL) );
        err = NERR_Success;
    }

    if( err == NERR_Success )
    {
        //
        //  Fill the service Listbox.
        //

        err = Refresh();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SVCCNTL_DIALOG :: SVCCNTL_DIALOG


/*******************************************************************

    NAME:           SVCCNTL_DIALOG :: ~SVCCNTL_DIALOG

    SYNOPSIS:       SVCCNTL_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
SVCCNTL_DIALOG :: ~SVCCNTL_DIALOG( VOID )
{
    _pszServerName = NULL;
    HWPROFILE_DIALOG::ReleaseHandle( &_hCfgMgrHandle );

}   // SVCCNTL_DIALOG :: ~SVCCNTL_DIALOG


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
APIERR SVCCNTL_DIALOG :: Refresh( VOID )
{
    //
    //  We'll need these to restore the appearance of
    //  the listbox.
    //

    UINT iTop;
    UINT iSel;

    if( _lbServices.QueryCount() == 0 )
    {
        //
        //  The listbox is currently empty.
        //  Therefore, its top index and selected
        //  item are both zero.
        //

        iTop = 0;
        iSel = 0;
    }
    else
    {
        //
        //  The listbox is not empty, so retrieve
        //  its top index and selected item index.
        //

        iTop = _lbServices.QueryTopIndex();
        iSel = _lbServices.QueryCurrentItem();
    }

    //
    //  Fill the listbox with that available services.
    //

    _lbServices.SetRedraw( FALSE );

    APIERR err = _lbServices.Fill();

    if( err == NERR_Success )
    {
        //
        //  If there are any services in the listbox, adjust
        //  its appearance to match the "pre-refresh" state.
        //  Also, setup the control buttons as appropriate for
        //  the current state & abilities of the selected service.
        //

        UINT cItems = _lbServices.QueryCount();

        if( cItems > 0 )
        {
            if( ( iTop >= cItems ) ||
                ( iSel >= cItems ) )
            {
                //
                //  The number of services in the listbox has changed,
                //  dropping below either the previous top index or
                //  the index of the previously selected item.  Just
                //  to be safe, we'll revert our selection to the first
                //  item in the listbox.
                //
                //  CODEWORK:  There's got to be a better strategy than
                //  just zapping back to the first listbox item.
                //  Perhaps we should display the *last* 'N' items in
                //  the listbox?  See ChuckC for details!
                //

                iTop = 0;
                iSel = 0;
            }

            _lbServices.SetTopIndex( iTop );
            _lbServices.SelectItem( iSel );

            SVC_LBI * plbi = _lbServices.QueryItem();
            UIASSERT( plbi != NULL );

            if (plbi != NULL) // PREFIX bug 444933
                SetupControlButtons( plbi->QueryCurrentState(),
                                     plbi->QueryControlsAccepted(),
                                     plbi->QueryStartType() );
        }
        else
        {
            //
            //  No services in the listbox.  Therfore, disable all of
            //  the control buttons.
            //

            DisableControlButtons();
        }
    }
    else
    {
        //
        //  An error occurred while filling the listbox, probably
        //  during the service enumeration.
        //

        DisableControlButtons();
    }

    //
    //  Allow listbox repaints, then force a repaint.
    //

    _lbServices.SetRedraw( TRUE );
    _lbServices.Invalidate( TRUE );

    return err;

}   // SVCCNTL_DIALOG :: Refresh


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
BOOL SVCCNTL_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    switch( event.QueryCid() )
    {
    case IDSC_START:
       {
        ServiceControl( SvcOpStart );
        return TRUE;
       }
    case IDSC_STOP:
       {
        BOOL fStoppedServer = FALSE;

        ServiceControl( SvcOpStop, &fStoppedServer );

        if( fStoppedServer && !_fTargetServerIsLocal )
        {
            Dismiss( TRUE );
        }

        return TRUE;
       }
    case IDSC_PAUSE:
       {
        ServiceControl( SvcOpPause );
        return TRUE;
       }
    case IDSC_CONTINUE:
       {
        ServiceControl( SvcOpContinue );
        return TRUE;
       }
    case IDSC_SERVICES:
       {
        //
        //  The SVC_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in SVC_LISTBOX.
            //

            SVC_LBI * plbi = _lbServices.QueryItem();
            UIASSERT( plbi != NULL );

            if (plbi != NULL) // PREFIX bug 444934
                SetupControlButtons( plbi->QueryCurrentState(),
                                     plbi->QueryControlsAccepted(),
                                     plbi->QueryStartType() );

            return TRUE;
        }
        else
        if( event.QueryCode() == LBN_DBLCLK )
        {
            //
            //  Fall through to configure (on double-click).
            //
        }
        else
        {
            return TRUE;
        }
       }
    case IDSC_CONFIGURE:
    case IDSC_HWPROFILE:
       {
        {
            BOOL fDoRefresh = FALSE;
            const TCHAR * pszTarget = _fAccountTargetAvailable
                                          ? _nlsAccountTarget.QueryPch()
                                          : NULL;

            SVC_LBI * plbi = _lbServices.QueryItem();
            UIASSERT( plbi != NULL );

            APIERR err = NERR_Success;
            if ( event.QueryCid() != IDSC_HWPROFILE ) // note fallthrough from
                                                      // previous case
            // must seperate these clauses since dlog dtor is not virtual
            {
                SVCCFG_DIALOG * pDlg =
                       new SVCCFG_DIALOG(        QueryHwnd(),
                                                 _pszServerName,
                                                 _nlsSrvDspName,
                                                 plbi->QueryServiceName(),
                                                 plbi->QueryDisplayName(),
                                                 pszTarget );
                err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : pDlg->Process( &fDoRefresh );

                delete pDlg;
            } else {
                HWPROFILE_DIALOG * pDlg =
                       new HWPROFILE_DIALOG(     QueryHwnd(),
                                                 _pszServerName,
                                                 _nlsSrvDspName,
                                                 plbi->QueryServiceName(),
                                                 plbi->QueryDisplayName(),
                                                 _hCfgMgrHandle );
                err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                       : pDlg->Process( &fDoRefresh );

                delete pDlg;
            }

            if( err == NERR_Success )
            {
                if( fDoRefresh )
                {
                    Refresh();
                }
            }
            else
            {
                MsgPopup( this, err );
            }
        }

        return TRUE;
       }
    default:
       {
        //
        //  If we made it this far, then we're not interested in the message.
        //

        return FALSE;
       }
    }

}   // SVCCNTL_DIALOG :: OnCommand


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: SetupControlButtons

    SYNOPSIS:   This method enables & disables the various
                control buttons as appropriate for the service's
                current state and control abilities.

    ENTRY:      CurrentState            - The service's state.

                ControlsAccepted        - A bit mask representing
                                          the types of controls the
                                          service will respond to.

                StartType               - The start type for the service.

    EXIT:       The start, stop, pause, continue, and configure buttons
                are set as appropriate.

    HISTORY:
        KeithMo     15-Jan-1992 Created.
        KeithMo     19-Jul-1992 Added start type controls.

********************************************************************/
VOID SVCCNTL_DIALOG :: SetupControlButtons( ULONG CurrentState,
                                            ULONG ControlsAccepted,
                                            ULONG StartType )
{
    //
    //  We'll assume that no operations are allowed
    //  unless proven otherwise.
    //

    BOOL fStop     = FALSE;
    BOOL fStart    = FALSE;
    BOOL fPause    = FALSE;
    BOOL fContinue = FALSE;

    switch( CurrentState )
    {
    case SERVICE_STOPPED:
    case SERVICE_STOP_PENDING:
        //
        //  If the service is stopped, the only thing
        //  we can do is start it.
        //

        fStart = TRUE;
        break;

    case SERVICE_RUNNING:
    case SERVICE_START_PENDING:
    case SERVICE_CONTINUE_PENDING:
        //
        //  If the service is started, we may be allowed
        //  to either stop or pause it.
        //

        fStop  = ( ( ControlsAccepted & SERVICE_ACCEPT_STOP ) != 0 );
        fPause = ( ( ControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE ) != 0 );
        break;

    case SERVICE_PAUSED:
    case SERVICE_PAUSE_PENDING:
        //
        //  If the service is currently paused, then it
        //  much better accept pause/continue operations.
        //  Also, we may be allowed to stop the service.
        //

        fContinue = ( ( ControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE ) != 0 );
        fStop     = ( ( ControlsAccepted & SERVICE_ACCEPT_STOP ) != 0 );
        break;

    default:
        //
        //  Bogus state.
        //

        UIASSERT( FALSE );
        break;
    }

    //
    //  Start is only allowed if the service is not disabled.
    //

    if( StartType == SERVICE_DISABLED )
    {
        fStart = FALSE;
    }

    _pbStop.Enable( fStop );
    _pbStart.Enable( fStart );
    _pbPause.Enable( fPause );
    _pbContinue.Enable( fContinue );

    _pbConfigure.Enable( ( _nServerType & SV_TYPE_NT ) != 0 );
    _pbHWProfile.Enable( _hCfgMgrHandle != NULL );

}   // SVCCNTL_DIALOG :: SetupControlButtons


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: DisableControlButtons

    SYNOPSIS:   This method disables the various service control
                buttons.

    EXIT:       The start, stop, pause, and continue buttons
                are disabled.

    HISTORY:
        KeithMo     27-Jan-1992 Created.

********************************************************************/
VOID SVCCNTL_DIALOG :: DisableControlButtons( VOID )
{
    _pbStop.Enable( FALSE );
    _pbStart.Enable( FALSE );
    _pbPause.Enable( FALSE );
    _pbContinue.Enable( FALSE );

    _pbConfigure.Enable( FALSE );
    _pbHWProfile.Enable( FALSE );

}   // SVCCNTL_DIALOG :: DisableControlButtons


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     15-Jan-1992 Created.

********************************************************************/
ULONG SVCCNTL_DIALOG :: QueryHelpContext( VOID )
{
    return HC_SVCCNTL_DIALOG;

}   // SVCCNTL_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: ServiceControl

    SYNOPSIS:   This method does most of the actual service control.

    ENTRY:      OpCode                  - Either SvcOpStart, SvcOpStop,
                                          SvcOpPause, or SvcOpContinue.

                pfStoppedServer         - Optional pointer to a BOOL.
                                          Will be set to TRUE if the
                                          user stopped the server service.

    EXIT:       Either the service has changed state or an error
                message has been presented to the user.

    HISTORY:
        KeithMo     19-Jan-1992 Created.
        KeithMo     17-Jul-1992 Added pfStoppedServer parameter.

********************************************************************/
VOID SVCCNTL_DIALOG :: ServiceControl( enum ServiceOperation   OpCode,
                                       BOOL                  * pfStoppedServer )
{
    AUTO_CURSOR Cursor;
    BOOL fStoppedServer = FALSE;        // until proven otherwise...

    //
    //  Determine exactly which service we'll be controlling.
    //

    SVC_LBI * plbi = _lbServices.QueryItem();
    UIASSERT( plbi != NULL );

    //
    //  Create our service control object, check for errors.
    //

    MSGID  idFailure = 0;
    APIERR err;
    GENERIC_SERVICE * pSvc = new GENERIC_SERVICE( this,
                                                  _pszServerName,
                                                  _nlsSrvDspName,
                                                  plbi->QueryServiceName(),
                                                  plbi->QueryDisplayName() );

    if( pSvc == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        err = pSvc->QueryError();
    }

    if( err != NERR_Success )
    {
        delete pSvc;
        MsgPopup( this, err );
        return;
    }

    //
    //  Interpret the opcode.
    //

    NLS_STR nlsParams;

    switch( OpCode )
    {

    case SvcOpStart:
        //
        //  No warning if we're starting a service, but we do
        //  have to get the parameter string from our SLE.
        //

        if( !nlsParams )
        {
            err = nlsParams.QueryError();
        }

        if( err == NERR_Success )
        {
            err = _sleParameters.QueryText( &nlsParams );
        }

        if( err == NERR_Success )
        {
            err = pSvc->Start( nlsParams.QueryPch() );
        }

        idFailure = IDS_CANNOT_START;
        break;

    case SvcOpStop:
        //
        //  Before we stop the service, warn the user.
        //

        if( pSvc->StopWarning() )
        {
            delete pSvc;
            return;
        }

        err = pSvc->Stop( &fStoppedServer );
        idFailure = IDS_CANNOT_STOP;
        break;

    case SvcOpPause:
        //
        //  Before we pause the service, warn the user.
        //

        if( pSvc->PauseWarning() )
        {
            delete pSvc;
            return;
        }

        err = pSvc->Pause();
        idFailure = IDS_CANNOT_PAUSE;
        break;

    case SvcOpContinue:
        //
        //  No warning if we're continuing a service.
        //

        err = pSvc->Continue();
        idFailure = IDS_CANNOT_CONTINUE;
        break;

    default:
        UIASSERT( FALSE );
        break;
    }

    UIASSERT( idFailure != 0 );

    //
    //  If the operation failed, give the user the bad news.
    //

    if( err == ERROR_SERVICE_SPECIFIC_ERROR )
    {
        DEC_STR nls( (ULONG)pSvc->QuerySpecificCode() );

        err = !nls ? nls.QueryError() : IDS_SERVICE_SPECIFIC_CODE;

        ::MsgPopup( this,
                    err,
                    MPSEV_ERROR,
                    MP_OK,
                    plbi->QueryDisplayName(),
                    nls.QueryPch() );
    }
    else
    if( err != NERR_Success )
    {
        ::DisplayGenericError( this,
                               idFailure,
                               err,
                               plbi->QueryDisplayName(),
                               _nlsSrvDspName,
                               MPSEV_ERROR );
    }

    //
    //  Now that we're done, delete the GENERIC_SERVICE
    //  object & refresh the dialog.
    //

    delete pSvc;

    if( pfStoppedServer != NULL )
    {
        *pfStoppedServer = fStoppedServer;
    }

    if( !fStoppedServer || _fTargetServerIsLocal )
    {
        Refresh();

        //
        //  If everything went well then we should set the input
        //  focus to the help button.  Also, if this was a start
        //  operation, kill the text in the SLE.
        //

        if( err == NERR_Success )
        {
            _fServicesManipulated = TRUE;

            if( OpCode == SvcOpStart )
            {
                _sleParameters.SetText( SZ("") );
            }

            SetDialogFocus( _pbClose );
        }
    }

    return;

}   // SVCCNTL_DIALOG :: ServiceControl


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: OnOK

    SYNOPSIS:   Dismiss the dialog when the user press OK.

    HISTORY:
        KeithMo     17-Jul-1992 Created.

********************************************************************/
BOOL SVCCNTL_DIALOG :: OnOK( VOID )
{
    Dismiss( _fServicesManipulated );
    return TRUE;

}   // SVCCNTL_DIALOG :: OnOK


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: OnCancel

    SYNOPSIS:   Dismiss the dialog when the user press Cancel.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
BOOL SVCCNTL_DIALOG :: OnCancel( VOID )
{
    Dismiss( _fServicesManipulated );
    return TRUE;

}   // SVCCNTL_DIALOG :: OnCancel


/*******************************************************************

    NAME:       SVCCNTL_DIALOG :: GetAccountTarget

    SYNOPSIS:   Determines if this dialog is focused on a BDC.  If
                so, find the PDC of the primary domain and store
                its name in _nlsAccountTarget.

    RETURNS:    BOOL                    - TRUE if account target is
                                          available, FALSE if it isn't.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
BOOL SVCCNTL_DIALOG :: GetAccountTarget( VOID )
{
    BOOL   fBDC = FALSE;
    APIERR err  = NERR_Success;

    {
        SERVER_MODALS modals( _pszServerName );

        err = modals.QueryError();

        if( err == NERR_Success )
        {
            UINT role;

            err = modals.QueryServerRole( &role );

            if( ( err == NERR_Success ) && ( role == UAS_ROLE_BACKUP ) )
            {
                //
                //  It's a BDC.
                //

                fBDC = TRUE;
            }
        }
    }

    if( !fBDC || ( err != NERR_Success ) )
    {
        //
        //  Either it's not a BDC, or we hit an error.
        //

        return ( err == NERR_Success );
    }

    //
    //  At this point, we know the machine of focus IS a BDC.  So
    //  we need to go through the joyous process of determining
    //  the PDC of the BDC's primary domain.  What a life.
    //

    //
    //  We'll start by determining the wksta (i.e. primary) domain
    //  of the target machine.
    //

    WKSTA_10 wksta( _pszServerName );
    BOOL     fAvail = FALSE;    // until proven otherwise...

    err = wksta.GetInfo();

    if( err == NERR_Success )
    {
        //
        //  Now that we have the name of the primary domain,
        //  determine the PDC of that domain.
        //

        DOMAIN domain( wksta.QueryWkstaDomain() );
        err = domain.GetInfo();

        if( err == NERR_Success )
        {
            //
            //  Just because NetGetDCName succeeded doesn't really
            //  prove anything.  Validate that this is indeed a
            //  valid DC in the domain.
            //

            const TCHAR * pszPrimary = domain.QueryPDC();
            UIASSERT( pszPrimary != NULL );

            if( DOMAIN::IsValidDC( pszPrimary, wksta.QueryWkstaDomain() ) )
            {
                //
                //  Yippee.
                //

                err = _nlsAccountTarget.CopyFrom( pszPrimary );

                if( err == NERR_Success )
                {
                    fAvail = TRUE;

                    DBGEOL( "account operations redirected to " << pszPrimary );
                }
            }
        }
    }

    return fAvail;

}   // SVCCNTL_DIALOG :: GetAccountTarget



//
//  SVCCFG_DIALOG methods
//

/*******************************************************************

    NAME:           SVCCFG_DIALOG :: SVCCFG_DIALOG

    SYNOPSIS:       SVCCFG_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszServerName       - The API name for the target server.

                    pszSrvDspName       - The target server's display name.

                    pszServiceName      - The name of the target service.

                    pszAccountTarget    - The name of the machine to use as
                                          a "target" for account operations.
                                          This will be NULL if no target is
                                          available.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     19-Jul-1992 Created.

********************************************************************/
SVCCFG_DIALOG :: SVCCFG_DIALOG( HWND          hWndOwner,
                                const TCHAR * pszServerName,
                                const TCHAR * pszSrvDspName,
                                const TCHAR * pszServiceName,
                                const TCHAR * pszDisplayName,
                                const TCHAR * pszAccountTarget )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SVCCFG_DIALOG ), hWndOwner ),
    _sltServiceName( this, IDSC_SERVICE_NAME ),
    _rgStartType( this, IDSC_START_AUTO, 3 ),
    _mgLogonAccount( this, IDSC_SYSTEM_ACCOUNT, 2, IDSC_SYSTEM_ACCOUNT ),
    _sleAccountName( this, IDSC_ACCOUNT_NAME ),
    _slePassword( this, IDSC_PASSWORD, SM_MAX_PASSWORD_LENGTH ),
    _sleConfirmPassword( this, IDSC_CONFIRM_PASSWORD, SM_MAX_PASSWORD_LENGTH ),
    _pbUserBrowser( this, IDSC_USER_BROWSER ),
    _sltPasswordLabel( this, IDSC_PASSWORD_LABEL ),
    _sltConfirmLabel( this, IDSC_CONFIRM_LABEL ),
    _cbInteractive( this, IDSC_SERVICE_INTERACTIVE ),
    _pscman( NULL ),
    _pscsvc( NULL ),
    _cLocks( 0 ),
    _pszServerName( pszServerName ),
    _pszSrvDspName( pszSrvDspName ),
    _pszServiceName( pszServiceName ),
    _pszDisplayName( pszDisplayName ),
    _pszAccountTarget( pszAccountTarget ),
    _nlsOldLogonAccount()
{
    UIASSERT( pszSrvDspName != NULL );
    UIASSERT( pszServiceName != NULL );

    //
    //  Let's make sure everything constructed OK.
    //

    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        err = _nlsOldLogonAccount.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Set the dialog caption.
        //

        err = SetCaption( _pszSrvDspName, pszDisplayName );
    }

    if( err == NERR_Success )
    {
        //
        //  Connect to the target service.
        //

        err = ConnectToTargetService( pszServiceName );
    }

    if( err == NERR_Success )
    {
        //
        //  Setup the dialog controls.
        //

        err = SetupControls();
    }

    if( err == NERR_Success )
    {
        //
        //  Setup the magic group associations.
        //

        err = SetupAssociations();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SVCCFG_DIALOG :: SVCCFG_DIALOG


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: ~SVCCFG_DIALOG

    SYNOPSIS:       SVCCFG_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     19-Jul-1992 Created.

********************************************************************/
SVCCFG_DIALOG :: ~SVCCFG_DIALOG( VOID )
{
    UIASSERT( _cLocks == 0 );

    //
    //  Note that _pscsvc *must* be deleted before _pscman!
    //

    delete _pscsvc;
    _pscsvc = NULL;

    delete _pscman;
    _pscman = NULL;

    _pszServerName  = NULL;
    _pszSrvDspName = NULL;

}   // SVCCFG_DIALOG :: ~SVCCFG_DIALOG


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: LockServiceDatabase

    SYNOPSIS:       Locks the service database.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: LockServiceDatabase( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    //
    //  We only need to actually perform the lock
    //  if the database is currently unlocked.
    //

    if( ++_cLocks == 1 )
    {
        err = _pscman->Lock();

        if( err != NERR_Success )
        {
            //
            //  We were unable to actually lock the database,
            //  do decrement the reference counter accordingly.
            //

            _cLocks--;
        }
    }

    return err;

}   // SVCCFG_DIALOG :: LockServiceDatabase


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: UnlockServiceDatabase

    SYNOPSIS:       Unlocks the service database.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: UnlockServiceDatabase( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );
    UIASSERT( _cLocks > 0 );

    APIERR err = NERR_Success;

    //
    //  We only need to actually perform the unlock
    //  if the database is currently locked.
    //

    if( --_cLocks == 0 )
    {
        err = _pscman->Unlock();

        if( err != NERR_Success )
        {
            //
            //  We were unable to actually unlock the database,
            //  so increment the reference counter accordingly.
            //

            _cLocks++;
        }
    }

    return err;

}   // SVCCFG_DIALOG :: UnlockServiceDatabase


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: SetCaption

    SYNOPSIS:       Worker method called during construction to
                    setup the dialog caption.

    ENTRY:          pszServerName       - The name of the target server.

                    pszServiceName      - The name of the target service.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: SetCaption( const TCHAR * pszServerName,
                                    const TCHAR * pszServiceName )
{
    UIASSERT( pszServerName  != NULL );
    UIASSERT( pszServiceName != NULL );

    //
    //  Kruft up some NLS_STRs for our input parameters.
    //
    //  Note that the server name (should) still have the
    //  leading backslashes (\\).  They are not to be displayed.
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

    ALIAS_STR nlsServiceName( pszServiceName );
    UIASSERT( nlsServiceName.QueryError() == NERR_Success );

#ifdef  DEBUG
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( nlsServerName );

        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
        ++istrDbg;
        UIASSERT( nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
    }
#endif  // DEBUG

    //
    //  Skip the backslashes.
    //
    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    //
    //  The insert strings for Load().
    //

    const NLS_STR * apnlsParams[3];

    apnlsParams[0] = &nlsWithoutPrefix;
    apnlsParams[1] = NULL;

    //
    //  Load the caption string.
    //

    NLS_STR nlsCaption;

    APIERR err = nlsCaption.QueryError();

    if( err == NERR_Success )
    {
        nlsCaption.Load( IDS_CAPTION_SVCCFG );
        nlsCaption.InsertParams( apnlsParams );

        err = nlsCaption.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Set the caption.
        //

        _sltServiceName.SetText( nlsServiceName );
        SetText( nlsCaption );
    }

    return err;

}   // SVCCFG_DIALOG :: SetCaption


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: SetupAssociations

    SYNOPSIS:       Worker method called during construction to
                    setup the necessary magic group associations.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: SetupAssociations( VOID )
{
    //
    //  Setup the magic group associations.
    //

    APIERR err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                                 &_sleAccountName );

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                              &_pbUserBrowser );
    }

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                              &_slePassword );
    }

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                              &_sleConfirmPassword );
    }

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                              &_sltPasswordLabel );
    }

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_THIS_ACCOUNT,
                                              &_sltConfirmLabel );
    }

    if( err == NERR_Success )
    {
        err = _mgLogonAccount.AddAssociation( IDSC_SYSTEM_ACCOUNT,
                                              &_cbInteractive );
    }

    return err;

}   // SVCCFG_DIALOG :: SetupAssociations


/*******************************************************************

    NAME:           SVCCFG_DIALOG :: ConnectToTargetService

    SYNOPSIS:       Worker method called during construction to
                    connect to the target service.

    ENTRY:          pszServiceName      - The name of the target service.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: ConnectToTargetService( const TCHAR * pszServiceName )
{
    //
    //  This may take a few seconds...
    //

    AUTO_CURSOR NiftyCursor;

    //
    //  Connect to the target server's service controller.
    //

    _pscman = new SC_MANAGER( _pszServerName,
                              STANDARD_RIGHTS_REQUIRED |
                                  SC_MANAGER_CONNECT   |
                                  SC_MANAGER_LOCK,
                              ACTIVE );

    APIERR err = ( _pscman == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pscman->QueryError();

    if( err == NERR_Success )
    {
        //
        //  Lock the service database.
        //

        err = LockServiceDatabase();
    }

    if( err == NERR_Success )
    {
        //
        //  Connect to the target service.
        //

        _pscsvc = new SC_SERVICE( *_pscman,
                                  pszServiceName,
                                  STANDARD_RIGHTS_REQUIRED  |
                                      SERVICE_QUERY_CONFIG  |
                                      SERVICE_CHANGE_CONFIG );

        err = ( _pscsvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : _pscsvc->QueryError();
    }

    return err;

}   // SVCCFG_DIALOG :: ConnectToTargetService


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: SetupControls

    SYNOPSIS:   Initializes the various dialog controls to reflect
                the values returned by the service controller.

    NOTES:      Cairo account names always begin with backslash.
                We do not validate or "crack" names beginning with
                backslash.

    HISTORY:
        KeithMo     19-Jul-1992 Created.
        JonN        27-Jul-1995 Cairo support

********************************************************************/
APIERR SVCCFG_DIALOG :: SetupControls( VOID )
{
    UIASSERT( _pscman != NULL );
    UIASSERT( _pscman->QueryError() == NERR_Success );
    UIASSERT( _pscsvc != NULL );
    UIASSERT( _pscsvc->QueryError() == NERR_Success );

    //
    //  Query the service configuration.
    //

    LPQUERY_SERVICE_CONFIG psvccfg;

    APIERR err = _pscsvc->QueryConfig( &psvccfg );

    if( err == NERR_Success )
    {
        UIASSERT( psvccfg != NULL );

        //
        //  Setup the start type radio group.
        //

        CID cidStartType = RG_NO_SEL;

        switch( psvccfg->dwStartType )
        {
        case SERVICE_AUTO_START:
            cidStartType = IDSC_START_AUTO;
            break;

        case SERVICE_DEMAND_START:
            cidStartType = IDSC_START_DEMAND;
            break;

        case SERVICE_DISABLED:
            cidStartType = IDSC_START_DISABLED;
            break;

        default:
            UIASSERT( FALSE );
            break;
        }

        _rgStartType.SetSelection( cidStartType );

        RADIO_BUTTON * prb = _rgStartType[cidStartType];
        UIASSERT( prb != NULL );

        if( prb != NULL )
        {
            prb->ClaimFocus();
        }

        //
        //  If this is a SERVICE_WIN32_SHARE_PROCESS type service,
        //  or if we were unable to determine the account target,
        //  then disable the logon info.  Shared process services
        //  *must* run under the LocalSystem account.
        //

        if( ( psvccfg->dwServiceType & SERVICE_WIN32_SHARE_PROCESS ) ||
            ( _pszAccountTarget == NULL ) )
        {
            _mgLogonAccount.Enable( FALSE );

            _sleAccountName.Enable( FALSE );
            _pbUserBrowser.Enable( FALSE );
            _slePassword.Enable( FALSE );
            _sleConfirmPassword.Enable( FALSE );

            _sltPasswordLabel.Enable( FALSE );
            _sltConfirmLabel.Enable( FALSE );
        }
        else
        {
            _slePassword.SetText( UI_NULL_USERSETINFO_PASSWD );
            _sleConfirmPassword.SetText( UI_NULL_USERSETINFO_PASSWD );
        }

        //
        //  Setup the logon info.
        //

        NLS_STR   nlsCrackedDomain;
        NLS_STR   nlsCrackedUser;
        ALIAS_STR nlsQualifiedAccount( (TCHAR *)psvccfg->lpServiceStartName );

        err = nlsCrackedDomain.QueryError();

        if( err == NERR_Success )
        {
            err = nlsCrackedUser.QueryError();
        }

        if( err == NERR_Success )
        {
            //
            //  Remember the "old" logon account.
            //

            err = _nlsOldLogonAccount.CopyFrom( nlsQualifiedAccount );
        }

        BOOL fCairoAccount = FALSE;
        TCHAR chFirst = *(nlsQualifiedAccount.QueryPch());
        if ( chFirst == TCH('\\') )
        {
            fCairoAccount = TRUE;
            TRACEEOL(   "SRVMGR: SVCCFG_DIALOG::SetupControls(): Cairo account name \""
                     << nlsQualifiedAccount << "\"" );
        }

        if( err == NERR_Success && !fCairoAccount )
        {
            //
            //  Crack the qualified account name into a
            //  "normal" account and an optional domain qualifier.
            //

            err = NT_ACCOUNTS_UTILITY :: CrackQualifiedAccountName(
                                                        nlsQualifiedAccount,
                                                        &nlsCrackedUser,
                                                        &nlsCrackedDomain );
        }

        if( err == NERR_Success )
        {
            CID cidAccountType = IDSC_THIS_ACCOUNT;   // until proven otherwise
            const TCHAR * pszEditText;

            if( (!fCairoAccount) && nlsCrackedDomain.QueryTextLength() == 0 )
            {
                //
                //  There was no domain specified.
                //

                pszEditText = nlsCrackedUser;

                if( ::stricmpf( pszEditText, pszLocalSystemAccount ) == 0 )
                {
                    //
                    //  The local system account is specified.
                    //

                    cidAccountType = IDSC_SYSTEM_ACCOUNT;
                }
            }
            else
            {
                //
                //  The domain\username syntax is specified, so just
                //  use the qualified account name.
                //

                pszEditText = nlsQualifiedAccount;
            }

            _sleAccountName.SetText( pszEditText );
            _mgLogonAccount.SetSelection( cidAccountType );
        }
    }

    if( err == NERR_Success )
    {
        _cbInteractive.SetCheck( psvccfg->dwServiceType & SERVICE_INTERACTIVE_PROCESS );
    }

    return err;

}   // SVCCFG_DIALOG :: SetupControls


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: InvokeUserBrowser

    SYNOPSIS:   Invokes the User Browser.  This method is responsible
                for updating the dialog with the selecte user (if any)
                and displaying any appropriate error messages.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
VOID SVCCFG_DIALOG :: InvokeUserBrowser( VOID )
{
    //
    //  Create the user browser dialog.
    //

    NT_USER_BROWSER_DIALOG * pDlg =
            new NT_USER_BROWSER_DIALOG( USRBROWS_SINGLE_DIALOG_NAME,
                                        QueryHwnd(),
                                        _pszServerName,
                                        HC_USERBROWSER_DIALOG,
                                        USRBROWS_SHOW_USERS |
                                        USRBROWS_SINGLE_SELECT,
                                        QueryHelpFile( HC_USERBROWSER_DIALOG ),
                                        HC_USERBROWSER_DIALOG_MEMBERSHIP,
                                        HC_USERBROWSER_DIALOG_SEARCH );

    BOOL fUserPressedOK = FALSE;

    APIERR err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pDlg->Process( &fUserPressedOK );

    if( fUserPressedOK && ( err == NERR_Success ) )
    {
        BROWSER_SUBJECT_ITER   iterBrowserSub( pDlg );
        BROWSER_SUBJECT      * pBrowserSub;
        NLS_STR                nlsQualifiedAccountName;

        err = iterBrowserSub.QueryError();

        if( err == NERR_Success )
        {
            err = nlsQualifiedAccountName.QueryError();
        }

        if( err == NERR_Success )
        {
            err = iterBrowserSub.Next( &pBrowserSub );
        }

        if( ( err == NERR_Success ) && ( pBrowserSub != NULL ) )
        {
            err = pBrowserSub->QueryQualifiedName( &nlsQualifiedAccountName,
                                                   NULL,
                                                   FALSE );

            if( err == NERR_Success )
            {
                _sleAccountName.SetText( nlsQualifiedAccountName );
                _sleAccountName.ClaimFocus();
            }
        }
    }

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

    //
    //  Nuke the user browser dialog.
    //

    delete pDlg;

}   // SVCCFG_DIALOG :: InvokeUserBrowser


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: TweakQualifiedAccount

    SYNOPSIS:   Makes minor "tweaks" to a qualified account name.  This
                is currently limited to prepending ".\" to the qualified
                account name if a domain component is not present.

    ENTRY:      pnlsQualifiedAccount    - The qualified account name to
                                          tweak.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     28-Jul-1992 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: TweakQualifiedAccount( NLS_STR * pnlsQualifiedAccount )
{
    UIASSERT( pnlsQualifiedAccount != NULL );

    NLS_STR nlsCrackedDomain;
    NLS_STR nlsCrackedUser;

    //
    //  Ensure that the passed string is not in an error state
    //  and that our local strings constructed properly.
    //

    APIERR err = pnlsQualifiedAccount->QueryError();

    if( err == NERR_Success )
    {
        err = nlsCrackedDomain.QueryError();
    }

    if( err == NERR_Success )
    {
        err = nlsCrackedUser.QueryError();
    }

    //
    //  Crack the qualified name into domain & user components.
    //

    if( err == NERR_Success )
    {
        err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                                        *pnlsQualifiedAccount,
                                                        &nlsCrackedUser,
                                                        &nlsCrackedDomain );
    }

    //
    //  If there is no domain component, prepend
    //  LOCAL_MACHINE_DOMAIN.
    //

    if( ( err == NERR_Success ) && ( nlsCrackedDomain.QueryTextLength() == 0 ) )
    {
        if( strnicmpf( pnlsQualifiedAccount->QueryPch(),
                       LOCAL_MACHINE_DOMAIN,
                       sizeof(LOCAL_MACHINE_DOMAIN)/sizeof(TCHAR) ) != 0 )
        {
            ISTR istr( *pnlsQualifiedAccount );
            ALIAS_STR nlsPrefix( LOCAL_MACHINE_DOMAIN );
            UIASSERT( !!nlsPrefix );

            pnlsQualifiedAccount->InsertStr( nlsPrefix, istr );

            err = pnlsQualifiedAccount->QueryError();
        }
    }

    return err;

}   // SVCCFG_DIALOG :: TweakQualifiedAccount


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
BOOL SVCCFG_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    BOOL fResult = TRUE;        // until proven otherwise...

    switch( event.QueryCid() )
    {
    case IDSC_USER_BROWSER:
        InvokeUserBrowser();
        break;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        fResult = FALSE;
        break;
    }

    return fResult;

}   // SVCCFG_DIALOG :: OnCommand


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: OnOK

    SYNOPSIS:   Dismiss the dialog when the user presses OK.

    NOTES:      Cairo account names always begin with backslash.
                We do not validate or "crack" names beginning with
                backslash.

    HISTORY:
        KeithMo     19-Jul-1992 Created.
        JonN        09-Jul-1995 Cairo support

********************************************************************/
BOOL SVCCFG_DIALOG :: OnOK( VOID )
{
    //
    //  Grab the dialog data.
    //

    NLS_STR nlsQualifiedAccount( pszLocalSystemAccount );
    NLS_STR nlsUnqualifiedAccount;
    NLS_STR nlsPassword;
    NLS_STR nlsConfirmPassword;

    ULONG   StartType              = SERVICE_DISABLED; //
    BOOL    fUseLocalSystemAccount = TRUE;             // until proven otherwise
    BOOL    fIsDialogValid         = TRUE;             //
    MSGID   msgid                  = IDS_CANNOT_CONFIGURE_SERVICE;

    //
    //  Verify that our strings constructed OK.
    //

    APIERR err = nlsQualifiedAccount.QueryError();
    err = err ? err : nlsUnqualifiedAccount.QueryError();
    err = err ? err : nlsPassword.QueryError();
    err = err ? err : nlsConfirmPassword.QueryError();

    BOOL fCairoAccount = FALSE;
    BOOL fNoPasswordChange = FALSE;

    if( _mgLogonAccount.QuerySelection() == IDSC_THIS_ACCOUNT )
    {
        //
        //  The account name & password fields are only
        //  necessary if we're *not* using the local
        //  system account.
        //

        err = err ? err : _sleAccountName.QueryText( &nlsQualifiedAccount );

        if( ( err == NERR_Success ) &&
            ::stricmpf( nlsQualifiedAccount, pszLocalSystemAccount ) )
        {
            fUseLocalSystemAccount = FALSE;

            err = err ? err : _slePassword.QueryText( &nlsPassword );
            err = err ? err : _sleConfirmPassword.QueryText( &nlsConfirmPassword );
        }

        TCHAR chFirst = *(nlsQualifiedAccount.QueryPch());
        if ( chFirst == TCH('\\') )
        {
            fCairoAccount = TRUE;
            TRACEEOL(   "SRVMGR: SVCCFG_DIALOG::OnOK(): Cairo account name \""
                     << nlsQualifiedAccount << "\"" );
        }
    }

    err = err ? err : nlsUnqualifiedAccount.CopyFrom( nlsQualifiedAccount );

    //
    //  Determine the new start type.
    //

    if( err == NERR_Success )
    {
        switch( _rgStartType.QuerySelection() )
        {
        case IDSC_START_AUTO:
            StartType = SERVICE_AUTO_START;
            break;

        case IDSC_START_DEMAND:
            StartType = SERVICE_DEMAND_START;
            break;

        case IDSC_START_DISABLED:
            StartType = SERVICE_DISABLED;
            break;

        default:
            UIASSERT( FALSE );  // bogus value from radio group!
            break;
        }
    }


    UINT ServiceType = SERVICE_NO_CHANGE;

    if ( err == NERR_Success )
    {

        LPQUERY_SERVICE_CONFIG psvccfg;
        err = _pscsvc->QueryConfig( &psvccfg );
        ServiceType = psvccfg->dwServiceType;

        if ( (!!_cbInteractive.QueryCheck()) != !!(ServiceType & SERVICE_INTERACTIVE_PROCESS) )
        {
            //
            // Only try to set it if it has changed.
            //
            ServiceType = _cbInteractive.QueryCheck() ? (ServiceType |= SERVICE_INTERACTIVE_PROCESS)
                                                    : (ServiceType &= ~SERVICE_INTERACTIVE_PROCESS);
        }
    }


    //
    //  Validate the dialog items.
    //
    //  If the dialog is *not* valid then we'll display
    //  an appropriate warning message, set the input focus
    //  to the offending control, and set fIsDialogValid
    //  to FALSE.
    //
    //  Note that the account name and password do *not*
    //  need to be validated if we're to use the local
    //  system account.
    //

    if( !fUseLocalSystemAccount )
    {
        if( err == NERR_Success && !fCairoAccount )
        {
            //
            //  Validate the account name.
            //

            APIERR err2 =
                NT_ACCOUNTS_UTILITY::ValidateQualifiedAccountName(
                                                        nlsQualifiedAccount );

            if( err2 == ERROR_INVALID_PARAMETER )
            {
                MsgPopup( this, IDS_ACCOUNT_NAME_INVALID );

                _sleAccountName.SelectString();
                _sleAccountName.ClaimFocus();

                fIsDialogValid = FALSE;
            }
            else
            if( err2 != NERR_Success )
            {
                err = err2;
            }
        }

        if( ( err == NERR_Success ) && fIsDialogValid )
        {
            //
            //  Validate the password.
            //

            if( nlsPassword.strcmp( nlsConfirmPassword ) != 0 )
            {
                MsgPopup( this, IDS_PASSWORD_MISMATCH );

                _slePassword.SetText( UI_NULL_USERSETINFO_PASSWD );
                _sleConfirmPassword.SetText( UI_NULL_USERSETINFO_PASSWD );
                _slePassword.ClaimFocus();

                fIsDialogValid = FALSE;
            }
            else
            if (!::stricmpf( nlsPassword.QueryPch(),
                             UI_NULL_USERSETINFO_PASSWD ) )
            {
                fNoPasswordChange = TRUE;
            }
            else
            if( ::I_MNetNameValidate( NULL,
                                      nlsPassword,
                                      NAMETYPE_PASSWORD,
                                      0 ) != NERR_Success )
            {
                MsgPopup( this, IDS_PASSWORD_INVALID );

                _slePassword.SetText( UI_NULL_USERSETINFO_PASSWD );
                _sleConfirmPassword.SetText( UI_NULL_USERSETINFO_PASSWD );
                _slePassword.ClaimFocus();

                fIsDialogValid = FALSE;
            }
        }
    }

    if( fIsDialogValid )
    {
        //
        //  This may take a few seconds...
        //

        AUTO_CURSOR NiftyCursor;

        if( err == NERR_Success && !fCairoAccount )
        {
            //
            //  "Tweak" the qualified account name.  This basically
            //  prepends a ".\" to the beginning of the qualified
            //  account if a domain name is not specified.
            //
            //  The leading ".\" is required by the Service Controller
            //  API for accounts on the local machine.
            //

            err = TweakQualifiedAccount( &nlsQualifiedAccount );
        }

        if( err == NERR_Success )
        {
            //
            //  Update the service.
            //

            const TCHAR * pszAccountName = nlsQualifiedAccount;
            const TCHAR * pszPassword    = nlsPassword;

            //
            //  JonN 6/20/95  Don't try to change the password
            //  if it is still UI_NULL_USERSETINFO_PASSWORD
            //
            //  We do this so the user won't be forced to re-enter the
            //  logon account password everytime the configure dialog
            //  is invoked.  Basically, if the user has changed the
            //  logon account, then a default password SLE means that
            //  there is no password for the account.  If the user has
            //  not changed the logon account, then an default password
            //  SLE means that the old password should be used.
            //

            if ( fNoPasswordChange )
            {
                pszPassword = NULL;
            }

            err = _pscsvc->ChangeConfig( ServiceType,     // service type
                                         StartType,             // start type
                                         SERVICE_NO_CHANGE,     // error ctrl
                                         NULL,                  // image path
                                         NULL,                  // load group
                                         NULL,                  // dependencies
                                         pszAccountName,        // logon account
                                         pszPassword );         // password
        }

        if( ( err == NERR_Success ) &&
            !fUseLocalSystemAccount &&
            ( _pszAccountTarget != NULL ) )
        {
            //
            //  Adjust the logon account privileges if necessary.
            //

            err = AdjustAccountPrivileges( nlsUnqualifiedAccount );

            if( err != NERR_Success )
            {
                msgid = IDS_CANNOT_ADJUST_PRIVILEGE;
            }
        }

        if( err == NERR_Success )
        {
            //
            //  Unlock the service database.
            //

            err = UnlockServiceDatabase();
        }

        if( err == NERR_Success )
        {
            //
            //  Dismiss the dialog.
            //

            Dismiss( TRUE );
        }
        else
        {
            //
            //  Some error occurred along the way.
            //

            DisplayGenericError( this,
                                 msgid,
                                 err,
                                 _pszDisplayName,
                                 nlsUnqualifiedAccount );
        }
    }

    return TRUE;

}   // SVCCFG_DIALOG :: OnOK


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: OnCancel

    SYNOPSIS:   Dismiss the dialog when the user presses Cancel.

    HISTORY:
        KeithMo     20-Jul-1992 Created.

********************************************************************/
BOOL SVCCFG_DIALOG :: OnCancel( VOID )
{
    //
    //  Unlock the service database.
    //

    APIERR err = UnlockServiceDatabase();

    if( err != NERR_Success )
    {
        //
        //  Whoops.
        //

        MsgPopup( this, err );
    }
    else
    {
        //
        //  Dismiss the dialog.
        //

        Dismiss( FALSE );
    }

    return TRUE;

}   // SVCCFG_DIALOG :: OnCancel


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: QueryHelpContext

    SYNOPSIS:   This method returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        KeithMo     19-Jul-1992 Created.

********************************************************************/
ULONG SVCCFG_DIALOG :: QueryHelpContext( VOID )
{
    return HC_SVCCFG_DIALOG;

}   // SVCCFG_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: AdjustAccountPrivileges

    SYNOPSIS:   Ensures the specified account has the Service Logon
                privilege.  Also does some special casing for the
                Replicator service (ensures the account is a member
                of the Replicators local group).

    ENTRY:      pszUnqualifiedAccount   - Contains the raw, unqualified
                                          account name from the dialog's
                                          edit field.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Apr-1993 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: AdjustAccountPrivileges(
                                        const TCHAR * pszUnqualifiedAccount )
{
    UIASSERT( _pszAccountTarget != NULL );
    UIASSERT( pszUnqualifiedAccount != NULL );

    BOOL fAddedServiceLogonPrivilege = FALSE;
    BOOL fAddedToReplicatorGroup     = FALSE;

    //
    //  Connect to the LSA Policy on the target server.
    //

    LSA_POLICY             lsapol( _pszAccountTarget, POLICY_ALL_ACCESS );
    LSA_TRANSLATED_SID_MEM lsatsm;
    LSA_REF_DOMAIN_MEM     lsardm;

    APIERR err = lsapol.QueryError();
    err = err ? err : lsatsm.QueryError();
    err = err ? err : lsardm.QueryError();

    //
    //  Lookup the proper Replicator & Backup Operator alias names.
    //

    NLS_STR nlsReplicator;
    NLS_STR nlsBackupOperators;

    err = err ? err : nlsReplicator.QueryError();
    err = err ? err : nlsBackupOperators.QueryError();

    err = err ? err : LookupSystemSidName( &lsapol,
                                           UI_SID_Replicator,
                                           &nlsReplicator );

    err = err ? err : LookupSystemSidName( &lsapol,
                                           UI_SID_BackupOperators,
                                           &nlsBackupOperators );

    if( err == NERR_Success )
    {
        //
        //  Translate the name to a PSID/RID pair.
        //

        err = lsapol.TranslateNamesToSids( &pszUnqualifiedAccount,
                                           1,
                                           &lsatsm,
                                           &lsardm );
    }

    if( err == NERR_Success )
    {
        //
        //  Build a "real" SID from the PSID/RID pair.
        //

        OS_SID ossid( lsardm.QueryPSID( lsatsm.QueryDomainIndex( 0 ) ),
                      lsatsm.QueryRID( 0 ) );

        err = ossid.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Add the Service Logon privilege.
            //

            err = AddSystemAccessMode( &lsapol,
                                       ossid.QueryPSID(),
                                       POLICY_MODE_SERVICE,
                                       &fAddedServiceLogonPrivilege );
        }

        if( ( err == NERR_Success ) &&
            ( ::stricmpf( _pszServiceName, (TCHAR *)SERVICE_REPL ) == 0 ) )
        {
            //
            //  Add the account to the Replicators local group.
            //

            err = AddToLocalGroup( ossid.QueryPSID(),
                                   nlsReplicator,
                                   &fAddedToReplicatorGroup );

            if( err == NERR_Success )
            {
                BOOL fDummy;

                //
                //  Add the account to the Backup Operators local group.
                //  Note that (at least for now) we don't present any
                //  special messages if we added the account to the
                //  Backup Operators local group.
                //

                err = AddToLocalGroup( ossid.QueryPSID(),
                                       nlsBackupOperators,
                                       &fDummy );
            }
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Success.  If we added the Service Logon privilege
        //  to the account and/or added the account to the
        //  Replicator local group, tell the user what we did.
        //

        MSGID msgid = 0;

        if( fAddedServiceLogonPrivilege )
        {
            msgid = fAddedToReplicatorGroup
                        ? IDS_ADDED_PRIVILEGE_AND_TO_LOCAL_GROUP
                        : IDS_ADDED_PRIVILEGE;
        }
        else
        {
            msgid = fAddedToReplicatorGroup
                        ? IDS_ADDED_TO_LOCAL_GROUP
                        : 0;
        }

        if( msgid != 0 )
        {
            ::MsgPopup( this,
                        msgid,
                        MPSEV_INFO,
                        MP_OK,
                        pszUnqualifiedAccount );
        }
    }

    return err;

}   // SVCCFG_DIALOG :: AdjustAccountPrivileges


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: AddSystemAccessMode

    SYNOPSIS:   Adds the specified system access mode to the specified
                account.

    ENTRY:      plsapol                 - Points to an LSA_POLICY object
                                          representing the LSA Policy
                                          on the target server.

                psid                    - The SID of the account to
                                          manipulate.

                accessAdd               - The access mode(s) to add.

                pfAddedMode             - Will receive TRUE if the
                                          mode(s) were updated.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Apr-1993 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: AddSystemAccessMode( LSA_POLICY * plsapol,
                                             PSID         psid,
                                             ULONG        accessAdd,
                                             BOOL       * pfAddedMode )
{
    UIASSERT( plsapol != NULL );
    UIASSERT( plsapol->QueryError() == NERR_Success );
    UIASSERT( psid != NULL );
    UIASSERT( pfAddedMode != NULL );

    *pfAddedMode = FALSE;

    //
    //  Create the LSA_ACCOUNT object representing this account.
    //

    LSA_ACCOUNT lsaaccount( plsapol, psid );
    APIERR err = lsaaccount.QueryError();
    err = err ? err : lsaaccount.GetInfo();

    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  No LSA account exists for this account.  Create one.
        //

        err = lsaaccount.CreateNew();
    }

    if( err == NERR_Success )
    {
        ULONG accessCurrent = lsaaccount.QuerySystemAccess();

        if( ( accessCurrent & accessAdd ) != accessAdd )
        {
            //
            //  The account needs updating.
            //

            lsaaccount.InsertSystemAccessMode( accessAdd );
            err = lsaaccount.Write();

            if( err == NERR_Success )
            {
                *pfAddedMode = TRUE;
            }
        }
    }

    return err;

}   // SVCCFG_DIALOG :: AddSystemAccessMode


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: AddToLocalGroup

    SYNOPSIS:   Adds the specified account to the specified local
                group on the target server.

    ENTRY:      psid                    - The SID of the account to
                                          add.

                pszLocalGroup           - The name of the local group.

                pfAddedToGroup          - Will receive TRUE if the
                                          account was actually added
                                          to the group.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Apr-1993 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: AddToLocalGroup( PSID          psid,
                                         const TCHAR * pszLocalGroup,
                                         BOOL        * pfAddedToGroup )
{
    UIASSERT( psid != NULL );
    UIASSERT( pszLocalGroup != NULL );
    UIASSERT( pfAddedToGroup != NULL );
    UIASSERT( _pszAccountTarget != NULL );

    *pfAddedToGroup = FALSE;

    //
    //  We need LMOBJ support for this API!
    //

    APIERR err = ::MNetLocalGroupAddMember( _pszAccountTarget,
                                            pszLocalGroup,
                                            psid );

    if( err == NERR_Success )
    {
        //
        //  Account added to local group.  Let the caller know it.
        //

        *pfAddedToGroup = TRUE;
    }
    else
    if( err == ERROR_MEMBER_IN_ALIAS )
    {
        //
        //  Account was already a member.  Pretend it succeeded,
        //  but don't tell the caller it was added.
        //

        err = NERR_Success;
    }

    return err;

}   // SVCCFG_DIALOG :: AddToLocalGroup


/*******************************************************************

    NAME:       SVCCFG_DIALOG :: LookupSystemSidName

    SYNOPSIS:   Lookup the name of a system SID.

    ENTRY:      plsapol - The LSA_POLICY target for the lookup.

                SystemSid - The SID to lookup.

                pnlsName - Will receive the name if successful.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     19-Jul-1993 Created.

********************************************************************/
APIERR SVCCFG_DIALOG :: LookupSystemSidName( LSA_POLICY        * plsapol,
                                             enum UI_SystemSid   SystemSid,
                                             NLS_STR           * pnlsName )

{
    APIERR                  err;
    OS_SID                  ossid;
    LSA_TRANSLATED_NAME_MEM lsatnm;
    LSA_REF_DOMAIN_MEM      lsardm;

    //
    //  Validate parameters.
    //

    UIASSERT( plsapol != NULL );
    UIASSERT( plsapol->QueryError() == NERR_Success );
    UIASSERT( pnlsName != NULL );
    UIASSERT( pnlsName->QueryError() == NERR_Success );

    //
    //  Validate construction.
    //

    err = ossid.QueryError();
    err = err ? err : lsatnm.QueryError();
    err = err ? err : lsardm.QueryError();

    //
    //  Build the SID.
    //

    err = err ? err : NT_ACCOUNTS_UTILITY::QuerySystemSid( SystemSid, &ossid );

    if( err == NERR_Success )
    {
        //
        //  Lookup the name.
        //

        PSID psid = ossid.QueryPSID();

        err = err ? err : plsapol->TranslateSidsToNames( &psid,
                                                         1,
                                                         &lsatnm,
                                                         &lsardm );

        //
        //  Copy it back to the caller.
        //

        err = err ? err : lsatnm.QueryName( 0, pnlsName );
    }

    return err;

}   // SVCCFG_DIALOG :: LookupSystemSidName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\smxdebug\smxdebug.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    smxdebug.c
    This is a simple test for the Server Manager Extension mechanism.


    FILE HISTORY:
        KeithMo     20-Oct-1992 Created.

*/


#include "smxdebug.h"


//
//  Globals.
//

HANDLE _hInstance;
HWND   _hwndMessage;
DWORD  _dwVersion;
DWORD  _dwDelta;



/*******************************************************************

    NAME:       SmxDebugDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance               - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
BOOL FAR PASCAL SmxDebugDllInitialize( HANDLE hInstance,
                                       DWORD  nReason,
                                       LPVOID pReserved )
{
    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // SmxDebugDllInitialize


/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance               - Program instance of the caller.

    EXIT:       The DLL has been initialized.

    RETURNS:    BOOL                    - TRUE  = Initialization OK.
                                          FALSE = Initialization failed.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
BOOL InitializeDll( HANDLE hInstance )
{
    //
    //  Save the instance handle.
    //

    _hInstance = hInstance;

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       SMELoadMenuW

    SYNOPSIS:   This DLL entrypoint notifies the extension that it
                is getting loaded by the application.

    ENTRY:      hwndMessage             - The "owning" window.

                psmsload                - Points to an SMS_LOADMENU
                                          structure containing load
                                          parameters.

    RETURNS:    DWORD                   - Actually an APIERR, should be
                                          0 if successful.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
DWORD PASCAL SMELoadMenuW( HWND          hwndMessage,
                           PSMS_LOADMENU psmsload )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMELoadMenuW\n") );

    if( psmsload == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    _hwndMessage = hwndMessage;
    _dwVersion   = EXT_VERSION;

    if( psmsload->dwVersion > _dwVersion )
    {
        psmsload->dwVersion = _dwVersion;
    }
    else
    if( psmsload->dwVersion < _dwVersion )
    {
        _dwVersion = psmsload->dwVersion;
    }

    _dwDelta = psmsload->dwMenuDelta;

    psmsload->dwServerType = SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL;

    LoadString( _hInstance, IDS_MENUNAME, psmsload->szMenuName, MENU_TEXT_LEN );
    LoadString( _hInstance, IDS_HELPFILE, psmsload->szHelpFileName, MAX_PATH );

    psmsload->hMenu = LoadMenu( _hInstance, MAKEINTRESOURCE( ID_MENU ) );

    return NO_ERROR;

}   // SMELoadW


/*******************************************************************

    NAME:       SMEGetExtendedErrorStringW

    SYNOPSIS:   If SMELoadW returns ERROR_EXTENDED_ERROR, then this
                entrypoint should be called to retrieve the error
                text associated with the failure condition.

    RETURNS:    LPTSTR                  - The extended error text.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
LPTSTR PASCAL SMEGetExtendedErrorStringW( VOID )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMEGetExtendedErrorStringW\n") );

    return TEXT("Empty Extended Error String");

}   // SMEGetExtendedErrorStringW


/*******************************************************************

    NAME:       SMEUnloadMenu

    SYNOPSIS:   Notifies the extension DLL that it is getting unloaded.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL SMEUnloadMenu( VOID )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMEUnloadMenu\n") );

    //
    //  This space intentionally left blank.
    //

}   // SMEUnload


/*******************************************************************

    NAME:       SMEInitializeMenu

    SYNOPSIS:   Notifies the extension DLL that the main menu is
                getting activated.  The extension should use this
                opportunity to perform any menu manipulations.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL SMEInitializeMenu( VOID )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMEInitializeMenu\n") );

    //
    //  This space intentionally left blank.
    //

}   // SMEInitializeMenu


/*******************************************************************

    NAME:       SMERefresh

    SYNOPSIS:   Notifies the extension DLL that the user has requested
                a refresh.  The extension should use this opportunity
                to update any cached data.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL SMERefresh( HWND hwndParent )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMERefresh\n") );

    //
    //  This space intentionally left blank.
    //

}   // SMERefresh


/*******************************************************************

    NAME:       SMEMenuAction

    SYNOPSIS:   Notifies the extension DLL that one of its menu
                items has been selected.

    ENTRY:      dwEventId               - The menu ID being activated
                                          (should be 1-99).

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL SMEMenuAction( HWND hwndParent, DWORD dwEventId )
{
    TCHAR szBuffer[512];
    const TCHAR * pszMsg = TEXT("ASSERT");
    SMS_GETSELCOUNT smsget;

    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMEMenuAction\n") );

    if( ( SendMessage( _hwndMessage, SM_GETSELCOUNT, 0, (LPARAM)&smsget ) == 0 ) ||
        ( smsget.dwItems == 0 ) )
    {
        pszMsg = TEXT("No servers selected");
    }
    else
    {
        switch( dwEventId )
        {
        case IDM_TEST1:
            {
                SMS_GETSERVERSEL smssel;

                if( !SendMessage( _hwndMessage, SM_GETSERVERSEL, 0, (LPARAM)&smssel ) )
                {
                    wsprintf( szBuffer,
                              TEXT("Can't get server selection") );
                }
                else
                {
                    wsprintf( szBuffer,
                              TEXT("Server = %s Type = %08lX"),
                              smssel.szServerName,
                              smssel.dwServerType );
                }

                pszMsg = szBuffer;
                break;
            }
        case IDM_TEST2:
            {
                SMS_GETSERVERSEL2 smssel;

                if( !SendMessage( _hwndMessage, SM_GETSERVERSEL2, 0, (LPARAM)&smssel ) )
                {
                    wsprintf( szBuffer,
                              TEXT("Can't get server selection") );
                }
                else
                {
                    wsprintf( szBuffer,
                              TEXT("Server = %s Type = %08lX"),
                              smssel.szServerName,
                              smssel.dwServerType );
                }

                pszMsg = szBuffer;
                break;
            }
        case IDM_TEST3:
            pszMsg = TEXT("test3");
            break;
        case IDM_TEST4:
            pszMsg = TEXT("test4");
            break;
        case IDM_TEST5:
            pszMsg = TEXT("test5");
            break;

        default :
            pszMsg = TEXT("Unknown event ID");
            break;
        }
    }

    MessageBox( hwndParent,
                pszMsg,
                TEXT("SMXDEBUG"),
                MB_OK );

}   // SMEMenuAction


/*******************************************************************

    NAME:       SMEValidateW

    SYNOPSIS:   Tries to recognize the given server.

    ENTRY:      psmsvalidate            - Points to an SMS_VALIDATE
                                          structure.

    RETURNS:    BOOL                    - TRUE if recognized,
                                          FALSE otherwise.

    HISTORY:
        KeithMo     07-Dec-1992 Created.

********************************************************************/
BOOL PASCAL SMEValidateW( PSMS_VALIDATE psmsvalidate )
{
    OutputDebugString( TEXT("SMXDEBUG.DLL : in SMEValidateW\n") );

    //
    //  This is a routine.  It will recognize
    //  any server that starts with "\\SMX".
    //

    if (   psmsvalidate->pszServer == NULL
        || psmsvalidate->pszServer[0] != L'S'
        || psmsvalidate->pszServer[1] != L'M'
        || psmsvalidate->pszServer[2] != L'X'
       )
    {
        return FALSE;
    }

    psmsvalidate->pszType    = TEXT("SMXDEBUG Server");
    psmsvalidate->pszComment = TEXT("This comment from SMXDEBUG.DLL!");

    return TRUE;

}   // SMEValidateW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\server\smxdebug\smxdebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    smxdebug.h
    Main header file for Test Server Manager Extension.


    FILE HISTORY:
        KeithMo     20-Oct-1992 Created.

*/


#ifndef _SMXDEBUG_H_
#define _SMXDEBUG_H_


#include <windows.h>
#include <lm.h>
#include <smx.h>
#include <wchar.h>


//
//  Constants
//

#define ID_MENU         1000
#define IDM_TEST1       1
#define IDM_TEST2       2
#define IDM_TEST3       3
#define IDM_TEST4       4
#define IDM_TEST5       5

#define IDS_MENUNAME    2000
#define IDS_HELPFILE    2001

#define EXT_VERSION     1


//
//  Prototypes.
//

BOOL FAR PASCAL SmxDebugDllInitialize( HANDLE hInstance,
                                       DWORD  nReason,
                                       LPVOID pReserved );

BOOL InitializeDll( HANDLE hInstance );

VOID TerminateDll( VOID );


#endif  // _SMXDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\h\usrmgr.h ===
//
//  For DLGEDIT.EXE's benifit.
//

#ifndef _USRMGR_H_
#define _USRMGR_H_

#ifndef IDHELPBLT
#error You must include bltrc.h if you include usrmgr.h!
// The following are bogus values which may or may not really
// be IDHELPBLT etc.  They just keep DLGEDIT.EXE happy.
#define IDHELPBLT                      80
#endif  // IDHELPBLT

#ifndef IDYES
#error You must include winuser.h if you include usrmgr.h!
// The following is a bogus value which may or may not really
// be IDYES.  It just keeps DLGEDIT.EXE happy.
#define IDYES                      6
#endif  // IDYES

#ifndef IDNO
#error You must include winuser.h if you include usrmgr.h!
// The following is a bogus value which may or may not really
// be IDNO.  It just keeps DLGEDIT.EXE happy.
#define IDNO                      7
#endif  // IDYES



//
//  Dialog Template IDs
//


//
//  Common User Properties items
//
#define IDUP_ST_USER                1001
#define IDUP_LB_USERS               1003
#define IDUP_ST_USERS_FIRST_COL     1004
#define IDUP_ST_USERS_SECOND_COL    1005
#define IDUP_ST_USER_LB             1006


/* User Properties dialog */
#define IDD_SINGLEUSER              1100
#define IDD_MULTIUSER               1200
#define IDD_NEWUSER                 1300
#define IDUP_ET_COMMENT                1101
#define IDUP_ST_COMMENT_LABEL          1102
#define IDUP_ET_FULL_NAME              1103
#define IDUP_ET_PASSWORD               1104
#define IDUP_ET_PASSWORD_CONFIRM       1105
#define IDUP_CB_ACCOUNTDISABLED        1106
#define IDUP_ET_LOGON_NAME             1107
#define IDUP_ST_LOGON_NAME             1108

#define IDUP_GB_1                      1110
#define IDUP_GB_2                      1111
#define IDUP_GB_3                      1112
#define IDUP_GB_4                      1113
#define IDUP_GB_5                      1114
#define IDUP_GB_6                      1115
#define IDUP_GB_7                      1116
//hydra
#define IDUP_GB_8                      1117

/* Details dialog */
#define IDD_DETAILS_DOWNLEVEL       1500
#define IDD_DETAILS_NT              1600
#define IDDT_RB_HOME                   1501
#define IDDT_RB_REMOTE                 1502
#define IDDT_RB_NEVER                  1503
#define IDDT_RB_END_OF                 1504
#define IDDT_SPINB_END_OF              1505
#define IDDT_SPINB_UP_ARROW            1506
#define IDDT_SPINB_DOWN_ARROW          1507
#define IDDT_SPING_MONTH               1508
#define IDDT_SPING_SEP1                1509
#define IDDT_SPING_DAY                 1510
#define IDDT_SPING_SEP2                1511
#define IDDT_SPING_YEAR                1512

#define IDDT_SPING_FRAME               1513
#define IDUP_CB_CONSTRAINT             1520
#define IDUP_CB_USERCANCHANGE          1521
#define IDUP_CB_FORCEPWCHANGE          1522
#define IDUP_CB_NOPASSWORDEXPIRE       1523
#define IDUP_CB_ACCOUNTLOCKOUT         1524
#define IDUP_CB_ISNETWAREUSER          1525

/* Valid logon workstation */
#define IDD_VLWDLG                 1700
#define IDVLW_RB_WORKS_ALL         1701
#define IDVLW_RB_WORKS_SELECTED    1702
#define IDVLW_ST_CAN_LOG_TEXT      1703
#define IDVLW_SLE_WORKS_1          1704
#define IDVLW_SLE_WORKS_2          1705
#define IDVLW_SLE_WORKS_3          1706
#define IDVLW_SLE_WORKS_4          1707
#define IDVLW_SLE_WORKS_5          1708
#define IDVLW_SLE_WORKS_6          1709
#define IDVLW_SLE_WORKS_7          1710
#define IDVLW_SLE_WORKS_8          1711
#define IDVLW_SLT_WORKS_1          1712
#define IDVLW_SLT_WORKS_2          1713
#define IDVLW_SLT_WORKS_3          1714
#define IDVLW_SLT_WORKS_4          1715
#define IDVLW_SLT_WORKS_5          1716
#define IDVLW_SLT_WORKS_6          1717
#define IDVLW_SLT_WORKS_7          1718
#define IDVLW_SLT_WORKS_8          1719
#define IDVLW_RB_WORKS_ALL_NW      1720
#define IDVLW_RB_WORKS_SELECTED_NW 1721
#define IDVLW_LB_ADDRESS           1722
#define IDVLW_SLT_NETWORKADDR      1723
#define IDVLW_SLT_NODEADDR         1724
#define IDVLW_ADD                  1725
#define IDVLW_REMOVE               1726

/* Valid logon workstation */
#define IDD_NO_NETWARE_VLWDLG      1730

/* Add NetWare allowed workstation's address dialog */
#define IDD_ADD_NW_DLG             1750
#define IDADD_SLE_NETWORK_ADDR     1751
#define IDADD_SLE_NODE_ADDR        1752
#define ID_ADD_HELP                1753

/* NetWare Password Dialog*/
#define IDD_NW_PASSWORD_DLG        1760
#define IDNWP_ST_USERNAME          1761
#define IDNWP_ET_PASSWORD          1762
#define IDNWP_ET_PASSWORD_CONFIRM  1763
#define ID_NW_PASSWORD_HELP        1764


/* Valid logon workstation ends */

/* Group Membership */
#define IDD_USERMEMB_DLG            1800
#define IDC_UMEMB_NAME_SLT_TITLE    1801
#define IDC_UMEMB_NAME_SLT          1802
#define IDC_UMEMB_IN_TITLE          1803
#define IDC_UMEMB_IN_LB             1804
#define IDC_UMEMB_ADD               1805
#define IDC_UMEMB_REMOVE            1806
#define IDC_UMEMB_NOT_IN_TITLE      1807
#define IDC_UMEMB_NOT_IN_LB         1808
#define IDC_UM_SET_PRIMARY_GROUP    1809
#define IDC_UM_PRIMARY_GROUP_LABEL  1810
#define IDC_UM_PRIMARY_GROUP        1811
/* Group Membership ends*/


/* Logon Hours */
#define IDD_USERLOGONHRS            1900
#define IDUP_LH_CUSTOM              1910
#define IDUP_LH_PERMIT              1920
#define IDUP_LH_BAN                 1921
#define IDUP_LH_PERMITALL           1922
#define IDUP_LH_BITMAP              1930
/* The following 5 must be consecutive */
#define IDUP_LH_LABEL1              1931
#define IDUP_LH_LABEL2              1932
#define IDUP_LH_LABEL3              1933
#define IDUP_LH_LABEL4              1934
#define IDUP_LH_LABEL5              1935
/* The following 3 must be consecutive */
#define IDUP_LH_ICON1               1936
#define IDUP_LH_ICON2               1937
#define IDUP_LH_ICON3               1938

/* Privilege Level */
#define IDD_PRIVLEVEL               2000
#define IDPL_RB_ADMIN               2001
#define IDPL_RB_USER                2002
#define IDPL_RB_GUEST               2003
#define IDPL_CB_ACCOUNTOP           2004
#define IDPL_CB_SERVEROP            2005
#define IDPL_CB_PRINTOP             2006
#define IDPL_CB_COMMOP              2007
/* Privilege Level ends */

/* Netware */
#define IDD_NCPDLG                                  2050
#define IDNCP_CB_PASSWORD_EXPIRED                   2051
#define IDNCP_RB_NO_GRACE_LOGIN_LIMIT               2052
#define IDNCP_RB_LIMIT_GRACE_LOGIN                  2053
#define IDNCP_ST_GRACE_LOGIN_ALLOW                  2054
#define IDNCP_ST_GRACE_LOGIN                        2055
#define IDNCP_ST_GRACE_LOGIN_REMAINING              2056
#define IDNCP_SLE_GRACE_LOGIN_ALLOWED               2057
#define IDNCP_SPINB_GROUP_GRACE_LOGIN               2058
#define IDNCP_SPINB_UP_ARROW_GRACE_LOGIN            2059
#define IDNCP_SPINB_DOWN_ARROW_GRACE_LOGIN          2060
#define IDNCP_ST_GRACE_LOGIN_NUM                    2061
#define IDNCP_RB_NO_LIMIT                           2062
#define IDNCP_RB_LIMIT                              2063
#define IDNCP_ST_CONCURRENT_CONNECTIONS             2064
#define IDNCP_SLE_MAX_CONNECTIONS                   2065
#define IDNCP_SPINB_GROUP_MAX_CONNECTIONS           2066
#define IDNCP_SPINB_UP_ARROW_MAX_CONNECTIONS        2067
#define IDNCP_SPINB_DOWN_ARROW_MAX_CONNECTIONS      2068
#define ID_NCP_HELP                                 2069
#define IDNCP_SLT_OBJECTID                          2070
#define IDNCP_SLT_OBJECTID_TEXT                     2071
#define IDNCP_PB_LOGIN_SCRIPT                       2072
#define IDNCP_FRAME_GRACE_LOGIN_ALLOWED             2073
#define IDNCP_FRAME_MAX_CONNECTIONS                 2074
/* Netware ends */

/* Netware Login Script */
#define IDD_NCP_LOGIN_SCRIPT_DIALOG                 2075
#define IDLS_MLE_LOGIN_SCRIPT                       2076
/* Netware Login Script ends */

/* Profile */
#define IDD_PROFILE_DOWNLEVEL       2100
#define IDPR_ET_LOGON_SCRIPT        2101
#define IDPR_ET_REMOTE_HOMEDIR      2102

#define IDD_PROFILE                 2103
#define IDPL_COMBO_DRIVELETTER      2104
#define IDPR_ET_PROFILE_PATH        2105
#define IDPR_RB_LOCAL_HOMEDIR       2106
#define IDPR_RB_REMOTE_HOMEDIR      2107
#define IDPR_ET_LOCAL_HOMEDIR       2108
#define IDPR_CB_REMOTE_DEVICE       2109
#define IDPR_ET_PROFILE_TEXT        2111
#define IDPR_ET_NW_HOMEDIR          2112
#define IDPR_ST_NW_HOMEDIR          2113
#define IDD_NO_NETWARE_PROFILE      2114

// hydra
#define IDPR_CB_HOMEDIR_MAPROOT     2115
#define IDPR_ET_WFPROFILE_TEXT      2116
#define IDPR_ET_WFPROFILE_PATH      2117

#define IDPR_ET_REMOTE_WFHOMEDIR    2118
#define IDPR_ET_LOCAL_WFHOMEDIR     2119
#define IDPR_CB_WFREMOTE_DEVICE     2120
#define IDPR_RB_LOCAL_WFHOMEDIR     2121
#define IDPR_RB_REMOTE_WFHOMEDIR    2122
// end hydra
/* Profile ends */

/* Dialin Properties */
#define IDD_DIALIN_PROPERTIES       2200
#define IDDIALIN_ALLOW_DIALIN       2210
#define IDDIALIN_NOCALLBACK         2220
#define IDDIALIN_CALLBACK_CALLER    2221
#define IDDIALIN_CALLBACK_PRESET    2222
#define IDDIALIN_CALLBACKNUMBER     2223
/* RAS Properties ends */

/* Group Properties */
#define IDD_GROUP                   2500
#define IDD_NEWGROUP                2600

#define IDGP_IN_LB                  2501
#define IDGP_IN_ST_FIRST_COL        2502        // these two are
#define IDGP_IN_ST_SECOND_COL       2503        // not visible
#define IDGP_NOT_IN_LB              2504
#define IDGP_NOT_IN_ST_FIRST_COL    2505        // these two are
#define IDGP_NOT_IN_ST_SECOND_COL   2506        // not visible
#define IDGP_ET_COMMENT             2507
#define IDGP_ET_GROUP_NAME          2508
#define IDGP_ICON                   2509
#define IDGP_ST_GROUP_NAME          2510
#define IDGP_ADD                    2511
#define IDGP_REMOVE                 2512
#define IDGP_ST_GROUP_NAME_LABEL    2513
/* Group Properties ends */



/* Alias Properties */
#define IDD_ALIAS                   2700
#define IDGP_ST_ALIAS_NAME_LABEL    2701
#define IDAL_ST_ALIAS_NAME_LABEL    2702
#define IDAL_ST_GROUP_NAME          2703
#define IDAL_ET_COMMENT             2704
#define IDAL_LB_FIRST_COL           2705
#define IDAL_LB_SECOND_COL          2706
#define IDAL_LB                     2707
#define IDAL_ADD                    2708
#define IDAL_REMOVE                 2709
#define IDAL_SHOWFULLNAMES          2710
#define IDAL_ST_ALIAS_NAME          2711
#define IDAL_ET_ALIAS_NAME          2712
#define IDAL_ICON                   2713
/* Alias Properties ends */

/* Rename User dialog */
#define IDD_RENAMEUSER              3000
#define IDUP_ET_RENAMEUSER          3001
#define IDUP_ST_RENAMEOLD           3002


/* Trusted Domain List */
#define IDD_TRUST_LIST              3100
#define IDTL_DOMAIN                 3101
#define IDTL_TRUSTED_LIST           3102
#define IDTL_PERMITTED_LIST         3103
#define IDTL_ADD_TRUSTED            3104
#define IDTL_REMOVE_TRUSTED         3105
#define IDTL_ADD_PERMITTED          3106
#define IDTL_REMOVE_PERMITTED       3107
/* Trusted Domain List ends */

/* Add Trusted Domain */
#define IDD_ADD_TRUSTED_DOMAIN      3200
#define IDAT_DOMAIN                 3201
#define IDAT_PASSWORD               3202
/* Add Trusted Domain ends */

/* Permit Domain to Trust */
#define IDD_PERMIT_DOMAIN           3300
#define IDPD_DOMAIN                 3301
#define IDPD_PASSWORD               3302
#define IDPD_CONFIRM_PASSWORD       3303
/* Permit Domain To Trust ends */


/* Auditing */
#define IDD_AUDITING                3400

#define BUTTON_NO_AUDIT                 3401
#define BUTTON_AUDIT                    3402

#define SLT_SUCCESS                     3403
#define SLT_FAILURE                     3404

// The following five ids must be consecutive
#define SLT_LOGON                       3405
#define SLT_OBJECT_ACCESS               3406
#define SLT_PRIVILEGE_USE               3407
#define SLT_ACCOUNT_MANAGEMENT          3408
#define SLT_POLICY_CHANGE               3409
#define SLT_SYSTEM                      3410
#define SLT_DETAILED_TRACKING           3411

// The following five ids must be consecutive
#define CHECKB_LOGON_SUCCESS               3412
#define CHECKB_OBJECT_ACCESS_SUCCESS       3413
#define CHECKB_PRIVILEGE_USE_SUCCESS       3414
#define CHECKB_ACCOUNT_MANAGEMENT_SUCCESS  3415
#define CHECKB_POLICY_CHANGE_SUCCESS       3416
#define CHECKB_SYSTEM_SUCCESS              3417
#define CHECKB_DETAILED_TRACKING_SUCCESS   3418

// The following five ids must be consecutive
#define CHECKB_LOGON_FAILURE                 3419
#define CHECKB_OBJECT_ACCESS_FAILURE         3420
#define CHECKB_PRIVILEGE_USE_FAILURE         3421
#define CHECKB_ACCOUNT_MANAGEMENT_FAILURE    3422
#define CHECKB_POLICY_CHANGE_FAILURE         3423
#define CHECKB_SYSTEM_FAILURE                3424
#define CHECKB_DETAILED_TRACKING_FAILURE     3425

#define CHECKB_HALT_SYSTEM              3426



/* racommn */

/* BUGBUG needed? */
#define IDUP_ST_SECURITYID              3502

#define SLT_FOCUS_TITLE                 3503
#define SLT_FOCUS                       3504


/* Rights */
#define IDD_USER_RIGHTS             3600

#define CB_RIGHTS                       3601

// The following two CID must be continuous
#define LB_ACCOUNT                      3602
#define LB_ACCOUNT_TITLE                3603

#define BUTTON_ADD                      3604
#define BUTTON_REMOVE                   3605

#define CHECKB_ADVANCED_RIGHTS		3606


/* Security Settings */

#define IDD_SECSET                      3700
#define SLT_DOMAIN_OR_SERVER            3702
#define SLTP_DOMAIN_OR_SERVER_NAME      3703


#define SLT_SECURITY_ID                 3704
#define SLT_SECURITY_ID_NUMBER          3705

#define RB_MAX_PASSW_AGE_NEVER_EXPIRES  3710
#define RB_MAX_PASSW_AGE_SET_DAYS       3711
#define SLE_MAX_PASSW_AGE_SET_DAYS      3712
#define SB_MAX_PASSW_AGE_SET_DAYS_GRP   3713
#define SB_MAX_PASSW_AGE_SET_DAYS_UP    3714
#define SB_MAX_PASSW_AGE_SET_DAYS_DOWN  3715
#define FRAME_MAX_PASSW_AGE_SET_DAYS    3716

#define RB_PASSW_LENGTH_PERMIT_BLANK    3720
#define RB_PASSW_LENGTH_SET_LEN         3721
#define SLE_PASSW_LENGTH_SET_LEN        3722
#define SB_PASSW_LENGTH_SET_LEN_GRP     3723
#define SB_PASSW_LENGTH_SET_LEN_UP      3724
#define SB_PASSW_LENGTH_SET_LEN_DOWN    3725
#define FRAME_PASSW_LENGTH_SET_LEN      3726

#define RB_MIN_PASSW_AGE_ALLOW_IMMEDIA  3740
#define RB_MIN_PASSW_AGE_SET_DAYS       3741
#define SLE_MIN_PASSW_AGE_SET_DAYS      3742
#define SB_MIN_PASSW_AGE_SET_DAYS_GRP   3743
#define SB_MIN_PASSW_AGE_SET_DAYS_UP    3744
#define SB_MIN_PASSW_AGE_SET_DAYS_DOWN  3745
#define FRAME_MIN_PASSW_AGE_SET_DAYS    3746

#define RB_PASSW_UNIQUE_NOT_HISTORY     3750
#define RB_PASSW_UNIQUE_SET_AMOUNT      3751
#define SLE_PASSW_UNIQUE_SET_AMOUNT     3752
#define SB_PASSW_UNIQUE_SET_AMOUNT_GRP  3753
#define SB_PASSW_UNIQUE_SET_AMOUNT_UP   3754
#define SB_PASSW_UNIQUE_SET_AMOUNT_DOWN 3755
#define FRAME_PASSW_UNIQUE_SET_AMOUNT     3756

#define SECSET_CB_DISCONNECT            3770
#define SECSET_CB_NOANONCHANGE          3771


/* Set Selection */
#define IDD_SETSEL_DLG                  3800

#define IDC_SETSEL_GROUP_TEXT           3801
#define IDC_SETSEL_GROUP_LB             3802
#define IDC_SETSEL_SELECT               3803
#define IDC_SETSEL_DESELECT             3804


/* Delete User dialog */
#define IDD_DELETE_USERS                3900
#define IDC_DelUsers_YesToAll           3910
#define IDC_DelUsers_Text               3915


/* RAS Selection dialog */
#define IDD_RAS_SELECT                  4000
#define IDC_RasSel_Text                 4001
#define IDC_RasSel_Edit                 4002


/* Security Settings with Lockout (also has IDD_SECSET controls) */
#define IDD_SECSET_LOCKOUT              4100

#define RB_LOCKOUT_DISABLED             4110
#define RB_LOCKOUT_ENABLED              4111

#define SLE_LOCKOUT_THRESHOLD           4122
#define SB_LOCKOUT_THRESHOLD_GRP        4123
#define SB_LOCKOUT_THRESHOLD_UP         4124
#define SB_LOCKOUT_THRESHOLD_DOWN       4125
#define FRAME_LOCKOUT_THRESHOLD         4126

#define SLE_LOCKOUT_OBSERV_WND          4132
#define SB_LOCKOUT_OBSERV_WND_GRP       4133
#define SB_LOCKOUT_OBSERV_WND_UP        4134
#define SB_LOCKOUT_OBSERV_WND_DOWN      4135
#define FRAME_LOCKOUT_OBSERV_WND        4136

#define RB_LOCKOUT_DURATION_FOREVER     4140
#define RB_LOCKOUT_DURATION_SECS        4141
#define SLE_LOCKOUT_DURATION_SECS       4142
#define SB_LOCKOUT_DURATION_SECS_GRP    4143
#define SB_LOCKOUT_DURATION_SECS_UP     4144
#define SB_LOCKOUT_DURATION_SECS_DOWN   4145
#define FRAME_LOCKOUT_DURATION_SECS     4146


#endif // _USRMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\h\umhelpc.h ===
/**********************************************************************/
/**                       Microsoft Window NT                        **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    umhelpc.h

    Header file for help context numbers for User Manager

    This file is used both by the LAN Manager NT User Manager
    (LANNT USER MANAGER or FUM) and the Windows  NT User Manager
    (MINI UM).

    Many dialogs in the User Manager may need different help based
    upon the "type" of the target machine, and upon whether this
    is the FUM or MINI UM.  There are four possibilities:

        FUM focused on LANMAN NT server

        FUM focused on Win NT workstation

        FUM focused on downlevel domain

        MINI UM (always focused on Win NT workstation)

    Where necessary, separate help contexts are used below.

    FILE HISTORY:
        Thomaspa        14-Feb-1992     Created
*/
#ifndef _UMHELPC_H_
#define _UMHELPC_H_

#include <uihelp.h>

#define HC_UM_BASE      HC_UI_USRMGR_BASE

/*
 * Offsets for each of the various forms of a dialog.  Note that not
 * all forms are applicable for all dialogs
 */
#define UM_OFF_LANNT    0
#define UM_OFF_WINNT    1
#define UM_OFF_DOWN     2
#define UM_OFF_MINI     3

#define UM_NUM_HELPTYPES 4

/*
 * Main User Properties dialog for a new user
 */
#define HC_UM_NEWUSERPROP_LANNT ( HC_UM_BASE )
#define HC_UM_NEWUSERPROP_WINNT ( HC_UM_NEWUSERPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_NEWUSERPROP_DOWN  ( HC_UM_NEWUSERPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_NEWUSERPROP_MINI  ( HC_UM_NEWUSERPROP_LANNT + UM_OFF_MINI )

#define HC_UM_COPYUSERPROP_LANNT ( HC_UM_BASE +4 )
#define HC_UM_COPYUSERPROP_WINNT ( HC_UM_COPYUSERPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_COPYUSERPROP_DOWN  ( HC_UM_COPYUSERPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_COPYUSERPROP_MINI  ( HC_UM_COPYUSERPROP_LANNT + UM_OFF_MINI )


/*
 * Main Global Group Properties dialog for a new group.
 */
#define HC_UM_GROUPPROP_LANNT   ( HC_UM_BASE + 8 )
#define HC_UM_GROUPPROP_WINNT   ( HC_UM_GROUPPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_GROUPPROP_DOWN    ( HC_UM_GROUPPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_GROUPPROP_MINI    ( HC_UM_GROUPPROP_LANNT + UM_OFF_MINI )

/*
 * Main Local Group Properties dialog for a new alias.
 */
#define HC_UM_ALIASPROP_LANNT   ( HC_UM_BASE + 12 )
#define HC_UM_ALIASPROP_WINNT   ( HC_UM_ALIASPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_ALIASPROP_DOWN    ( HC_UM_ALIASPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_ALIASPROP_MINI    ( HC_UM_ALIASPROP_LANNT + UM_OFF_MINI )

/*
 * Rename User dialog.
 */
#define HC_UM_RENAME_USER_LANNT ( HC_UM_BASE + 16 )
#define HC_UM_RENAME_USER_WINNT ( HC_UM_RENAME_USER_LANNT + UM_OFF_WINNT )
#define HC_UM_RENAME_USER_DOWN  ( HC_UM_RENAME_USER_LANNT + UM_OFF_DOWN )
#define HC_UM_RENAME_USER_MINI  ( HC_UM_RENAME_USER_LANNT + UM_OFF_MINI )

/*
 * Main User Properties dialog for existing, single user.
 */
#define HC_UM_SINGLEUSERPROP_LANNT  ( HC_UM_BASE + 20 )
#define HC_UM_SINGLEUSERPROP_WINNT ( HC_UM_SINGLEUSERPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_SINGLEUSERPROP_DOWN  ( HC_UM_SINGLEUSERPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_SINGLEUSERPROP_MINI  ( HC_UM_SINGLEUSERPROP_LANNT + UM_OFF_MINI )

/*
 * Main User Properties dialog for existing, multiple users.
 */
#define HC_UM_MULTIUSERPROP_LANNT  ( HC_UM_BASE + 24 )
#define HC_UM_MULTIUSERPROP_WINNT ( HC_UM_MULTIUSERPROP_LANNT + UM_OFF_WINNT )
#define HC_UM_MULTIUSERPROP_DOWN  ( HC_UM_MULTIUSERPROP_LANNT + UM_OFF_DOWN )
#define HC_UM_MULTIUSERPROP_MINI  ( HC_UM_MULTIUSERPROP_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for group memberships.
 */
#define HC_UM_GROUPMEMB_LANNT   ( HC_UM_BASE + 28 )
#define HC_UM_GROUPMEMB_WINNT   ( HC_UM_GROUPMEMB_LANNT + UM_OFF_WINNT )
#define HC_UM_GROUPMEMB_DOWN    ( HC_UM_GROUPMEMB_LANNT + UM_OFF_DOWN )
#define HC_UM_GROUPMEMB_MINI    ( HC_UM_GROUPMEMB_LANNT + UM_OFF_MINI )

#define HC_UM_MGROUPMEMB_LANNT  ( HC_UM_BASE + 32 )
#define HC_UM_MGROUPMEMB_WINNT  ( HC_UM_MGROUPMEMB_LANNT + UM_OFF_WINNT )
#define HC_UM_MGROUPMEMB_DOWN   ( HC_UM_MGROUPMEMB_LANNT + UM_OFF_DOWN )
#define HC_UM_MGROUPMEMB_MINI   ( HC_UM_MGROUPMEMB_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for Profiles
 */
#define HC_UM_USERPROFILE_LANNT ( HC_UM_BASE + 36 )
#define HC_UM_USERPROFILE_WINNT ( HC_UM_USERPROFILE_LANNT + UM_OFF_WINNT )
#define HC_UM_USERPROFILE_DOWN  ( HC_UM_USERPROFILE_LANNT + UM_OFF_DOWN )
#define HC_UM_USERPROFILE_MINI  ( HC_UM_USERPROFILE_LANNT + UM_OFF_MINI )

#define HC_UM_MUSERPROFILE_LANNT ( HC_UM_BASE + 40 )
#define HC_UM_MUSERPROFILE_WINNT ( HC_UM_MUSERPROFILE_LANNT + UM_OFF_WINNT )
#define HC_UM_MUSERPROFILE_DOWN  ( HC_UM_MUSERPROFILE_LANNT + UM_OFF_DOWN )
#define HC_UM_MUSERPROFILE_MINI  ( HC_UM_MUSERPROFILE_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for Logon hours
 */
#define HC_UM_LOGONHOURS_LANNT  ( HC_UM_BASE + 44 )
#define HC_UM_LOGONHOURS_WINNT  ( HC_UM_LOGONHOURS_LANNT + UM_OFF_WINNT )
#define HC_UM_LOGONHOURS_DOWN   ( HC_UM_LOGONHOURS_LANNT + UM_OFF_DOWN )
#define HC_UM_LOGONHOURS_MINI   ( HC_UM_LOGONHOURS_LANNT + UM_OFF_MINI )

#define HC_UM_MLOGONHOURS_LANNT ( HC_UM_BASE + 48 )
#define HC_UM_MLOGONHOURS_WINNT ( HC_UM_MLOGONHOURS_LANNT + UM_OFF_WINNT )
#define HC_UM_MLOGONHOURS_DOWN  ( HC_UM_MLOGONHOURS_LANNT + UM_OFF_DOWN )
#define HC_UM_MLOGONHOURS_MINI  ( HC_UM_MLOGONHOURS_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for valid logon workstations
 */
#define HC_UM_WORKSTATIONS_LANNT  ( HC_UM_BASE + 52 )
#define HC_UM_WORKSTATIONS_WINNT ( HC_UM_WORKSTATIONS_LANNT + WINT_OFFSET )
#define HC_UM_WORKSTATIONS_DOWN  ( HC_UM_WORKSTATIONS_LANNT + UM_OFF_DOWN )
#define HC_UM_WORKSTATIONS_MINI  ( HC_UM_WORKSTATIONS_LANNT + UM_OFF_MINI )

#define HC_UM_MWORKSTATIONS_LANNT  ( HC_UM_BASE + 56 )
#define HC_UM_MWORKSTATIONS_WINNT ( HC_UM_MWORKSTATIONS_LANNT + WINT_OFFSET )
#define HC_UM_MWORKSTATIONS_DOWN  ( HC_UM_MWORKSTATIONS_LANNT + UM_OFF_DOWN )
#define HC_UM_MWORKSTATIONS_MINI  ( HC_UM_MWORKSTATIONS_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for account details
 */
#define HC_UM_DETAIL_LANNT      ( HC_UM_BASE + 60 )
#define HC_UM_DETAIL_WINNT      ( HC_UM_DETAIL_LANNT + UM_OFF_WINNT )
#define HC_UM_DETAIL_DOWN       ( HC_UM_DETAIL_LANNT + UM_OFF_DOWN )
#define HC_UM_DETAIL_MINI       ( HC_UM_DETAIL_LANNT + UM_OFF_MINI )

#define HC_UM_MDETAIL_LANNT     ( HC_UM_BASE + 64 )
#define HC_UM_MDETAIL_WINNT     ( HC_UM_MDETAIL_LANNT + UM_OFF_WINNT )
#define HC_UM_MDETAIL_DOWN      ( HC_UM_MDETAIL_LANNT + UM_OFF_DOWN )
#define HC_UM_MDETAIL_MINI      ( HC_UM_MDETAIL_LANNT + UM_OFF_MINI )

/*
 * User Subproperty dialog for dialin properties
 */
#define HC_UM_DIALIN_PROP_LANNT  ( HC_UM_BASE + 68 )
#define HC_UM_DIALIN_PROP_WINNT  ( HC_UM_DIALIN_PROP_LANNT + UM_OFF_WINNT )
#define HC_UM_DIALIN_PROP_DOWN   ( HC_UM_DIALIN_PROP_LANNT + UM_OFF_DOWN )
#define HC_UM_DIALIN_PROP_MINI   ( HC_UM_DIALIN_PROP_LANNT + UM_OFF_MINI )

#define HC_UM_MDIALIN_PROP_LANNT ( HC_UM_BASE + 72 )
#define HC_UM_MDIALIN_PROP_WINNT ( HC_UM_MDIALIN_PROP_LANNT + UM_OFF_WINNT )
#define HC_UM_MDIALIN_PROP_DOWN  ( HC_UM_MDIALIN_PROP_LANNT + UM_OFF_DOWN )
#define HC_UM_MDIALIN_PROP_MINI  ( HC_UM_MDIALIN_PROP_LANNT + UM_OFF_MINI )

/*
 * Account policy dialog, no lockout (FUM, FUM to downlevel)
 *
 * also see HC_UM_POLICY_LOCKOUT
 */
#define HC_UM_POLICY_ACCOUNT_LANNT ( HC_UM_BASE + 76 )
#define HC_UM_POLICY_ACCOUNT_WINNT ( HC_UM_POLICY_ACCOUNT_LANNT + UM_OFF_WINNT )
#define HC_UM_POLICY_ACCOUNT_DOWN  ( HC_UM_POLICY_ACCOUNT_LANNT + UM_OFF_DOWN )
#define HC_UM_POLICY_ACCOUNT_MINI  ( HC_UM_POLICY_ACCOUNT_LANNT + UM_OFF_MINI )

/*
 * User rights policy dialog
 */
#define HC_UM_POLICY_RIGHTS_LANNT ( HC_UM_BASE + 80 )
#define HC_UM_POLICY_RIGHTS_WINNT ( HC_UM_POLICY_RIGHTS_LANNT + UM_OFF_WINNT )
#define HC_UM_POLICY_RIGHTS_DOWN  ( HC_UM_POLICY_RIGHTS_LANNT + UM_OFF_DOWN )
#define HC_UM_POLICY_RIGHTS_MINI  ( HC_UM_POLICY_RIGHTS_LANNT + UM_OFF_MINI )

/*
 * Auditing policy dialog
 */
#define HC_UM_POLICY_AUDIT_LANNT ( HC_UM_BASE + 84 )
#define HC_UM_POLICY_AUDIT_WINNT ( HC_UM_POLICY_AUDIT_LANNT + UM_OFF_WINNT )
#define HC_UM_POLICY_AUDIT_DOWN  ( HC_UM_POLICY_AUDIT_LANNT + UM_OFF_DOWN )
#define HC_UM_POLICY_AUDIT_MINI  ( HC_UM_POLICY_AUDIT_LANNT + UM_OFF_MINI )

/*
 * Trust relationships policy dialog
 */
#define HC_UM_POLICY_TRUST_LANNT ( HC_UM_BASE + 88 )
#define HC_UM_POLICY_TRUST_WINNT ( HC_UM_POLICY_TRUST_LANNT + UM_OFF_WINNT )
#define HC_UM_POLICY_TRUST_DOWN  ( HC_UM_POLICY_TRUST_LANNT + UM_OFF_DOWN )
#define HC_UM_POLICY_TRUST_MINI  ( HC_UM_POLICY_TRUST_LANNT + UM_OFF_MINI )

/*
 * Add Trusted domain dialog
 */
#define HC_UM_ADD_TRUSTED_LANNT ( HC_UM_BASE + 92 )
#define HC_UM_ADD_TRUSTED_WINNT ( HC_UM_ADD_TRUSTED_LANNT + UM_OFF_WINNT )
#define HC_UM_ADD_TRUSTED_DOWN  ( HC_UM_ADD_TRUSTED_LANNT + UM_OFF_DOWN )
#define HC_UM_ADD_TRUSTED_MINI  ( HC_UM_ADD_TRUSTED_LANNT + UM_OFF_MINI )

/*
 * Permit domain to trust this domain dialog
 */
#define HC_UM_PERMIT_TRUST_LANNT ( HC_UM_BASE + 96 )
#define HC_UM_PERMIT_TRUST_WINNT ( HC_UM_PERMIT_TRUST_LANNT + UM_OFF_WINNT )
#define HC_UM_PERMIT_TRUST_DOWN  ( HC_UM_PERMIT_TRUST_LANNT + UM_OFF_DOWN )
#define HC_UM_PERMIT_TRUST_MINI  ( HC_UM_PERMIT_TRUST_LANNT + UM_OFF_MINI )

/*
 * Select Users dialog
 */
#define HC_UM_SELECT_USERS_LANNT ( HC_UM_BASE + 100 )
#define HC_UM_SELECT_USERS_WINNT ( HC_UM_SELECT_USERS_LANNT + UM_OFF_WINNT )
#define HC_UM_SELECT_USERS_DOWN  ( HC_UM_SELECT_USERS_LANNT + UM_OFF_DOWN )
#define HC_UM_SELECT_USERS_MINI  ( HC_UM_SELECT_USERS_LANNT + UM_OFF_MINI )

/*
 * Delete multiple user dialog
 */
#define HC_UM_DELMULTIUSER_LANNT (HC_UM_BASE + 104)
#define HC_UM_DELMULTIUSER_WINNT (HC_UM_DELMULTIUSER_LANNT + UM_OFF_WINNT)
#define HC_UM_DELMULTIUSER_DOWN  (HC_UM_DELMULTIUSER_LANNT + UM_OFF_DOWN)
#define HC_UM_DELMULTIUSER_MINI  (HC_UM_DELMULTIUSER_LANNT + UM_OFF_MINI)

/*
 * Downlevel User Privileges dialog (BUGBUG this should disappear and
 * be merged into the User Details(Accounts) dialog
 */
#define HC_UM_USERPRIV_LANNT    ( HC_UM_BASE + 108)
#define HC_UM_USERPRIV_WINNT    (HC_UM_USERPRIV_LANNT + UM_OFF_WINNT)
#define HC_UM_USERPRIV_DOWN     (HC_UM_USERPRIV_LANNT + UM_OFF_DOWN)
#define HC_UM_USERPRIV_MINI     (HC_UM_USERPRIV_LANNT + UM_OFF_MINI)

#define HC_UM_MUSERPRIV_LANNT   ( HC_UM_BASE + 112)
#define HC_UM_MUSERPRIV_WINNT   (HC_UM_MUSERPRIV_LANNT + UM_OFF_WINNT)
#define HC_UM_MUSERPRIV_DOWN    (HC_UM_MUSERPRIV_LANNT + UM_OFF_DOWN)
#define HC_UM_MUSERPRIV_MINI    (HC_UM_MUSERPRIV_LANNT + UM_OFF_MINI)

/*
 * Account policy dialog, with lockout (FUM)
 */
#define HC_UM_POLICY_LOCKOUT_LANNT ( HC_UM_BASE + 116 )
#define HC_UM_POLICY_LOCKOUT_WINNT ( HC_UM_POLLICY_LOCKOUT_LANNT + UM_OFF_WINNT )
#define HC_UM_POLICY_LOCKOUT_DOWN  ( HC_UM_POLLICY_LOCKOUT_LANNT + UM_OFF_DOWN )
#define HC_UM_POLICY_LOCKOUT_MINI  ( HC_UM_POLLICY_LOCKOUT_LANNT + UM_OFF_MINI )


/*
 * Help contexts for common dialogs
 */

#define HC_UM_SELECT_DOMAIN                 ( HC_UM_BASE + 120 )

#define HC_UM_ADD_RIGHTS                    ( HC_UM_BASE + 121 )
#define HC_UM_ADD_RIGHTS_LOCALGROUP         ( HC_UM_BASE + 122 )
#define HC_UM_ADD_RIGHTS_GLOBALGROUP        ( HC_UM_BASE + 123 )
#define HC_UM_ADD_RIGHTS_FINDUSER           ( HC_UM_BASE + 124 )

#define HC_UM_PROMPT_ANY_DC                 ( HC_UM_BASE + 125 )

#define HC_UM_ADD_ALIASMEMBERS              ( HC_UM_BASE + 126 )
#define HC_UM_ADD_ALIASMEMBERS_LOCALGROUP   ( HC_UM_BASE + 127 )
#define HC_UM_ADD_ALIASMEMBERS_GLOBALGROUP  ( HC_UM_BASE + 128 )
#define HC_UM_ADD_ALIASMEMBERS_FINDUSER     ( HC_UM_BASE + 129 )

/*
 * Help Menu command contexts
 */

#define HC_UM_CONTENTS          ( HC_UM_BASE + 130 )
#define HC_UM_SEARCH            ( HC_UM_BASE + 131 )
#define HC_UM_HOWTOUSE          ( HC_UM_BASE + 132 )

/*
 * Help for menu items
 */
#define HC_USER_NEWUSER		( HC_UM_BASE + 150 )
#define HC_USER_NEWGLOBALGROUP	( HC_UM_BASE + 151 )
#define HC_USER_NEWLOCALGROUP	( HC_UM_BASE + 152 )
#define HC_USER_COPY		( HC_UM_BASE + 153 )
#define HC_USER_DELETE		( HC_UM_BASE + 154 )
#define HC_USER_RENAME		( HC_UM_BASE + 155 )
#define HC_USER_PROPERTIES	( HC_UM_BASE + 156 )
#define HC_USER_SELECTUSERS	( HC_UM_BASE + 157 )
#define HC_USER_SELECTDOMAIN	( HC_UM_BASE + 158 )
#define HC_USER_EXIT		( HC_UM_BASE + 159 )

#define HC_VIEW_SORTBYFULLNAME	( HC_UM_BASE + 160 )
#define HC_VIEW_SORTBYUSERNAME	( HC_UM_BASE + 161 )
#define HC_VIEW_REFRESH 	( HC_UM_BASE + 162 )

#define HC_POLICIES_ACCOUNT		( HC_UM_BASE + 163 )
#define HC_POLICIES_USERRIGHTS		( HC_UM_BASE + 164 )
#define HC_POLICIES_AUDIT		( HC_UM_BASE + 165 )
#define HC_POLICIES_TRUSTRELATIONSHIPS  ( HC_UM_BASE + 166 )

/* RAS comes later */
#define HC_OPTIONS_CONFIRMATION		( HC_UM_BASE + 167 )
#define HC_OPTIONS_SAVESETTINGSONEXIT	( HC_UM_BASE + 168 )

#define HC_HELP_CONTENTS	( HC_UM_BASE + 169 )
#define HC_HELP_SEARCH		( HC_UM_BASE + 170 )
#define HC_HELP_HOWTOUSE	( HC_UM_BASE + 171 )
#define HC_HELP_ABOUT		( HC_UM_BASE + 172 )

#define HC_OPTIONS_RAS_MODE ( HC_UM_BASE + 173 )
#define HC_COPY_RAS_MODE    ( HC_UM_BASE + 174 )
#define HC_DELETE_RAS_MODE  ( HC_UM_BASE + 175 )
#define HC_EDIT_RAS_MODE    ( HC_UM_BASE + 176 )
#define HC_RENAME_RAS_MODE  ( HC_UM_BASE + 177 )

/* Hydra */

#define HC_UM_USERCONFIG ( HC_UM_BASE + 178 )

/*
 *   Special help contexts
 */
#define HC_UM_TRUST_DOMAINS_SHARE_SIDS      ( HC_UM_BASE + 180 )
#define HC_UM_TRUST_SESS_CONFLICT           ( HC_UM_BASE + 181 )

/*
 *   NetWare help contexts
 */
#define HC_VIEW_ALLUSERS      ( HC_UM_BASE + 185 )
#define HC_VIEW_NETWAREUSERS  ( HC_UM_BASE + 186 )
#define HC_HELP_NETWARE       ( HC_UM_BASE + 187 )


/*
 * Resserved
 */
#define HC_UM_RESERVED1_BASE      ( HC_UM_BASE + 190 )
/*
 * User Subproperty dialog for NetWare properties.
 */
#define HC_UM_NETWARE             ( HC_UM_BASE + 190 )
#define HC_UM_NETWARE_PASSWORD    ( HC_UM_BASE + 191 )
#define HC_UM_NETWARE_ADD         ( HC_UM_BASE + 192 )
#define HC_UM_NETWARE_LOGIN_SCRIPT ( HC_UM_BASE + 193 )
#define HC_UM_RESERVED1_LAST      ( HC_UM_BASE + 200 )

#endif // _UMHELPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\h\setsel.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    setsel.h
    Set Selection dialog manifests


    FILE HISTORY:
        rustanl     16-Aug-1991 Created
        beng        01-Apr-1992 Inserted SZs.
        JonN        02-Apr-1992 Load by ordinal only
        beng        04-Aug-1992 Move into range
*/


#ifndef _SETSEL_H_
#define _SETSEL_H_

#define IDD_SETSEL_DLG              2000

#define IDC_SETSEL_GROUP_TEXT       7501
#define IDC_SETSEL_GROUP_LB         7502
#define IDC_SETSEL_SELECT           7503
#define IDC_SETSEL_DESELECT         7504


#endif  // _SETSEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\miniuser\musrmgr.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    musrmain.cxx
    Mini-User Manager: main application module

    FILE HISTORY:
        jonn        10-Apr-1992     created for Mini-User Manager

    The macro MINI_USER_MANAGER alters the root module USRMAIN.CXX
    to become the Mini-User Manager.  Exactly one of usrmain.obj
    and musrmain.obj should be linked into the executable, this
    makes the difference between the User Manager and the
    Mini-User Manager.

*/

#define MINI_USER_MANAGER

#include "usrmgr.cxx"

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\h\dllfunc.h ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/

/*
    dllfunc.h

    Stubs that call out to entries in NWSLIB.DLL and FPNWCLNT.DLL


    FILE HISTORY:
        ???         ??-???-1994 Created
        chuckc      24-Oct-1995 Added header, comments
*/

#include <fpnwapi.h>

APIERR LoadFpnwClntDll(void);

APIERR LoadNwsLibDll(void);

APIERR CallMapRidToObjectId( DWORD dwRid,
                             LPWSTR pszUserName,
                             BOOL fNTAS,
                             BOOL fBuiltin,
                             ULONG *pulObjectId);

APIERR CallSwapObjectId( ULONG ulObjectId,
                         ULONG *pulObjectId);

APIERR CallNwVolumeGetInfo(IN  LPWSTR pServerName OPTIONAL,
                           IN  LPWSTR pVolumeName,
                           IN  DWORD  dwLevel,
                           OUT PFPNWVOLUMEINFO *ppVolumeInfo );

APIERR CallNwApiBufferFree ( IN  LPVOID pBuffer );

APIERR CallQueryUserProperty(IN  LPWSTR          UserParms,
                             IN  LPWSTR          Property,
                             OUT PWCHAR          PropertyFlag,
                             OUT PUNICODE_STRING PropertyValue );

APIERR CallSetUserProperty(IN  LPWSTR          UserParms,
                           IN  LPWSTR          Property,
                           IN  UNICODE_STRING  PropertyValue,
                           IN  WCHAR           PropertyFlag,
                           OUT LPWSTR *        pNewUserParms,
                           OUT BOOL *          Update );

APIERR CallReturnNetwareForm(const char * pszSecretValue,
                             DWORD dwUserId,
                             const WCHAR * pchNWPassword,
                             UCHAR * pchEncryptedNWPassword);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\h\usrmgrrc.h ===
/**********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**              Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    usrmgrrc.h
    Header file for common User Tool resource manifests

    FILE HISTORY:
        jonn        02-Aug-1991 Created
        rustanl     22-Jul-1991 Added column header string manifests
        JonN        11-Sep-1991 USERPROP_DLG Code review changes part 1
                                (9/6/91) Attending: KevinL, RustanL,
                                JonN, o-SimoP
        o-SimoP     25-Sep-1991 Code review changes (9/24/91)
                                Attending: JimH, JonN, DavidHov and I
        jonn        27-Jan-1992 NTISSUES 564: empty fullname allowed
        JonN        27-Feb-1992 Multiple bitmaps in both panes
        beng        01-Apr-1992 Inserted SZs.
        JonN        02-Apr-1992 Load by ordinal only
        beng        04-Jun-1992 ConfirmGroupDelete, ConfirmUserDelete
        beng        07-Jun-1992 Cursors
*/


#include <adminapp.h>
#include <usrmgr.h>

#define ID_APPMENU   1
#define ID_APPACCEL  1
#define ID_MENU_MINI 2

#define ID_USERNAME  150
#define ID_FULLNAME  160
#define ID_GROUP     250

//
// Icon ID's
//

#define IDI_UM_FullUserManager 300
#define IDI_UM_MiniUserManager 301

#define IDI_UM_LH_Moon         310
#define IDI_UM_LH_Sun          311

//
// Cursor IDs
//

#define IDC_USERONE     400
#define IDC_USERMANY    401
#define IDC_GROUPONE    402
#define IDC_GROUPMANY   403

//
// String ID's
//

#define IDS_UMAPP_BASE                      (IDS_ADMINAPP_LAST+1)

#define IDS_UMAPPNAME                       (IDS_UMAPP_BASE+0)
#define IDS_UMAPPNAME_FULL                  (IDS_UMAPP_BASE+1)
#define IDS_UMOBJECTNAME                    (IDS_UMAPP_BASE+2)
#define IDS_UMINISECTIONNAME                (IDS_UMAPP_BASE+3)
#define IDS_UMHELPFILENAME                  (IDS_UMAPP_BASE+4)
#define IDS_UMHELPFILENAME_MINI             (IDS_UMAPP_BASE+5)
#define IDS_CAPTION_FOCUS                   (IDS_UMAPP_BASE+6)
#define IDS_CAPTION_FOCUS_MINI              (IDS_UMAPP_BASE+7)
#define IDS_UMX_LIST                        (IDS_UMAPP_BASE+8)
#define IDS_UMINISECTIONNAME_FULL           (IDS_UMAPP_BASE+9)
#define IDS_UMINISECTIONNAME_DBCS           (IDS_UMAPP_BASE+10)

#define IDS_UMPERFORMTEMPLATE_BASE          (IDS_UMAPP_BASE+20)
#define IDS_UMGetOneFailure                 (IDS_UMPERFORMTEMPLATE_BASE+0)
#define IDS_UMCreateNewFailure              (IDS_UMPERFORMTEMPLATE_BASE+1)
// These two IDs must remain contiguous
#define IDS_UMEditFailure                   (IDS_UMPERFORMTEMPLATE_BASE+2)
#define IDS_UMEditFailureContinue           (IDS_UMPERFORMTEMPLATE_BASE+3)
#define IDS_UMCreateFailure                 (IDS_UMPERFORMTEMPLATE_BASE+4)
#define IDS_UMGetOneGroupFailure            (IDS_UMPERFORMTEMPLATE_BASE+5)
#define IDS_UMCreateNewGroupFailure         (IDS_UMPERFORMTEMPLATE_BASE+6)
#define IDS_UMEditGroupFailure              (IDS_UMPERFORMTEMPLATE_BASE+7)
#define IDS_UMCreateGroupFailure            (IDS_UMPERFORMTEMPLATE_BASE+8)
#define IDS_UMGetOneAliasFailure            (IDS_UMPERFORMTEMPLATE_BASE+9)
#define IDS_UMCreateNewAliasFailure         (IDS_UMPERFORMTEMPLATE_BASE+10)
#define IDS_UMEditAliasFailure              (IDS_UMPERFORMTEMPLATE_BASE+11)
#define IDS_UMCreateAliasFailure            (IDS_UMPERFORMTEMPLATE_BASE+12)
#define IDS_UMNewUserAliasFailure           (IDS_UMPERFORMTEMPLATE_BASE+13)

#define IDS_UM_COL_HEADER_BASE              (IDS_UMAPP_BASE+40)
#define IDS_COL_HEADER_LOGON_NAME           (IDS_UM_COL_HEADER_BASE+0)
#define IDS_COL_HEADER_FULLNAME             (IDS_UM_COL_HEADER_BASE+1)
#define IDS_COL_HEADER_USER_COMMENT         (IDS_UM_COL_HEADER_BASE+2)
#define IDS_COL_HEADER_GROUP_NAME           (IDS_UM_COL_HEADER_BASE+3)
#define IDS_COL_HEADER_GROUP_COMMENT        (IDS_UM_COL_HEADER_BASE+4)

// Strings to match the bitmaps in the User Properties dialogs
#define IDS_UM_BTN_BASE                     (IDS_UMAPP_BASE+50)
#define IDS_UM_GROUPBTN                     (IDS_UM_BTN_BASE+0)
#define IDS_UM_PRIVSBTN                     (IDS_UM_BTN_BASE+1)
#define IDS_UM_PROFILE                      (IDS_UM_BTN_BASE+2)
#define IDS_UM_HOURSBTN                     (IDS_UM_BTN_BASE+3)
#define IDS_UM_LFROMBTN                     (IDS_UM_BTN_BASE+4)
#define IDS_UM_DETAILBTN                    (IDS_UM_BTN_BASE+5)
#define IDS_UM_RASBTN                       (IDS_UM_BTN_BASE+6)
#define IDS_UM_NCPBTN                       (IDS_UM_BTN_BASE+7)

#define IDS_UM_ERR_BASE                     (IDS_UMAPP_BASE+60)
// These two IDs must remain contiguous
#define IDS_CannotDeleteUser                (IDS_UM_ERR_BASE+0)
#define IDS_CannotDeleteUserContinue        (IDS_UM_ERR_BASE+1)
#define IDS_CannotDeleteGroup               (IDS_UM_ERR_BASE+2)
#define IDS_CannotForceLockout              (IDS_UM_ERR_BASE+3)

#define IERR_UM_BASE                        (IDS_UMAPP_BASE+70)
#define IERR_CannotDeleteSystemGrp          (IERR_UM_BASE+0)
#define IERR_UM_PasswordInvalid             (IERR_UM_BASE+1)
#define IERR_UM_PasswordMismatch            (IERR_UM_BASE+2)
#define IERR_UM_NWPasswordMismatch          (IERR_UM_BASE+3)
// #define IERR_UM_FullNameRequired         (IERR_UM_BASE+3)
#define IERR_UM_UsernameRequired            (IERR_UM_BASE+4)
#define IERR_UM_GroupnameRequired           (IERR_UM_BASE+5)
#define IERR_UM_UsernameAlreadyUser         (IERR_UM_BASE+6)
#define IERR_UM_UsernameAlreadyGroup        (IERR_UM_BASE+7)
#define IERR_UM_GroupnameAlreadyUser        (IERR_UM_BASE+8)
#define IERR_UM_GroupnameAlreadyGroup       (IERR_UM_BASE+9)
// #define IERR_BadLogonScript              (IERR_UM_BASE+10)
#define IERR_BadHomeDir                     (IERR_UM_BASE+11)
#define IERR_UM_AliasnameRequired           (IERR_UM_BASE+12)
#define IERR_UM_AliasnameAlreadyUser        (IERR_UM_BASE+13)
#define IERR_UM_AliasnameAlreadyGroup       (IERR_UM_BASE+14)
#define IERR_UM_RemoteDriveRequired         (IERR_UM_BASE+15)
#define IERR_UM_FullUsrMgrOnWinNt           (IERR_UM_BASE+16)
#define IERR_UM_DomainInvalid               (IERR_UM_BASE+17)
#define IERR_UM_FocusOnLanmanNt             (IERR_UM_BASE+18)
#define IERR_UM_InconsistentPWControl       (IERR_UM_BASE+19)
#define IERR_UM_CantTrustYourself           (IERR_UM_BASE+21)
#define IERR_UM_RemoteHomedirRequired       (IERR_UM_BASE+22)
#define IERR_UM_NotInPrimaryGroup           (IERR_UM_BASE+23)
#define IERR_UM_InvalidTrustPassword        (IERR_UM_BASE+24)
#define IERR_UM_AlreadyTrusted              (IERR_UM_BASE+25)
#define IERR_UM_AlreadyPermitted            (IERR_UM_BASE+26)
#define IERR_UM_InvalidHandle               (IERR_UM_BASE+27)
#define IERR_UM_FocusOnDownlevelDC          (IERR_UM_BASE+28)
#define IERR_UM_DomainsMightShareSids       (IERR_UM_BASE+29)

#define IDS_UM_MSG_BASE                     (IDS_UMAPP_BASE+100)
#define IDS_ConfirDelUsers1                 (IDS_UM_MSG_BASE+0)
#define IDS_ConfirDelUsers2                 (IDS_UM_MSG_BASE+1)
#define IDS_SETSEL_CLOSE_BUTTON             (IDS_UM_MSG_BASE+2)
#define IDS_BadDayInput                     (IDS_UM_MSG_BASE+3)
#define IDS_InvalidPath                     (IDS_UM_MSG_BASE+4)
#define IDS_UMEMB_MULT_IN_TITLE             (IDS_UM_MSG_BASE+5)
#define IDS_UMEMB_MULT_NOT_IN_TITLE         (IDS_UM_MSG_BASE+6)
#define IDS_OkToDelAdminInDomain            (IDS_UM_MSG_BASE+7)
#define IDS_LABEL_USERS                     (IDS_UM_MSG_BASE+8)
#define IDS_LABEL_USER                      (IDS_UM_MSG_BASE+9)
#define IDS_OkToDelAdminOnServer            (IDS_UM_MSG_BASE+10)
#define IDS_ConfirmGroupDelete              (IDS_UM_MSG_BASE+11)
#define IDS_ConfirmUserDelete               (IDS_UM_MSG_BASE+12)
#define IDS_ConfirDelGroup1                 (IDS_UM_MSG_BASE+13)
#define IDS_ConfirDelGroup2                 (IDS_UM_MSG_BASE+14)
#define IDS_CannotDelUserOfTool             (IDS_UM_MSG_BASE+15)
#define MSG_VLW_GIVE_NAMES                  (IDS_UM_MSG_BASE+16)
#define MSG_VLW_NO_GOOD_NAMES               (IDS_UM_MSG_BASE+17)
#define IDS_CannotRemoveAdminInteractive    (IDS_UM_MSG_BASE+18)
#define IDS_UM_AddButton                    (IDS_UM_MSG_BASE+19)
#define IDS_UM_CopyOfUserTitle              (IDS_UM_MSG_BASE+20)
#define IDS_UM_ForcePWChangeIgnore          (IDS_UM_MSG_BASE+21)
#define IDS_InvalidRelPath                  (IDS_UM_MSG_BASE+22)
#define IDS_BadUserLBI                      (IDS_UM_MSG_BASE+23)
// Ran out of room above in IERR_UM range
#define IERR_UM_FocusOnNT50Domain           (IDS_UM_MSG_BASE+24)
#define IERR_UM_FocusOnNT50Computer         (IDS_UM_MSG_BASE+25)

#define IDS_GRPPROP_GROUP_NAME_LABEL        (IDS_UM_MSG_BASE+26)
#define IDS_GRPPROP_NEW_GROUP_DLG_NAME      (IDS_UM_MSG_BASE+27)
#define IDS_VLW_USERS_ANYWHERE_TEXT         (IDS_UM_MSG_BASE+28)
#define IDS_VLW_USERS_SELECTED_TEXT         (IDS_UM_MSG_BASE+29)
#define IDS_LH_INDETERMINATE                (IDS_UM_MSG_BASE+30)
#define IDS_LH_DAYSPERWEEK                  (IDS_UM_MSG_BASE+33)
#define IDS_LH_DAYSPERWEEK_ONE              (IDS_UM_MSG_BASE+33)
#define IDS_LH_DAYSPERWEEK_MANY             (IDS_UM_MSG_BASE+34)
#define IDS_LH_BADUNITS                     (IDS_UM_MSG_BASE+35)
#define IDS_LH_BADUNITS_ONE                 (IDS_UM_MSG_BASE+35)
#define IDS_LH_BADUNITS_MANY                (IDS_UM_MSG_BASE+36)

#define IDS_UM_TrustComplete                (IDS_UM_MSG_BASE+37)
#define IDS_UM_TrustIncomplete              (IDS_UM_MSG_BASE+38)
#define IDS_UM_Trust_SessConflict           (IDS_UM_MSG_BASE+39)

#define IDS_VLW_USERS_ANYWHERE_NW_TEXT      (IDS_UM_MSG_BASE+40)
#define IDS_VLW_USERS_SELECTED_NW_TEXT      (IDS_UM_MSG_BASE+41)

#define IDS_NETWARE_PASSWORD_PROMPT         (IDS_UM_MSG_BASE+42)
#define IDS_RETYPE_NT_PASSWORD              (IDS_UM_MSG_BASE+43)

#define MSG_NO_NETWORK_ADDR                 (IDS_UM_MSG_BASE+44)
#define MSG_WRONG_NETWORK_ADDR              (IDS_UM_MSG_BASE+45)
#define MSG_WRONG_NODE_ADDR                 (IDS_UM_MSG_BASE+46)

#define IDS_NETWARE_LOGINSCRIPT_PROMPT      (IDS_UM_MSG_BASE+47)
#define IDS_NETWARE_LOGINSCRIPT_DIR_ERR     (IDS_UM_MSG_BASE+48)
#define IDS_ALL_NODES                       (IDS_UM_MSG_BASE+49)
#define IDS_INCLUDE_ALL_NODES               (IDS_UM_MSG_BASE+50)

#define IDS_PR_USERNAME_REPLACE             (IDS_UM_MSG_BASE+51)
#define IDS_PR_EXTENSION1_REPLACE           (IDS_UM_MSG_BASE+52)
#define IDS_PR_CannotCreateHomeDir          (IDS_UM_MSG_BASE+53)

#define IDS_REMAINING_OUT_OF_RANGE          (IDS_UM_MSG_BASE+54)

#define IDS_ALSPROP_ALIAS_NAME_LABEL        (IDS_UM_MSG_BASE+55)
#define IDS_ALSPROP_NEW_ALIAS_DLG_NAME      (IDS_UM_MSG_BASE+56)

#define IDS_PR_EXTENSION2_REPLACE           (IDS_UM_MSG_BASE+57)
#define IDS_PR_EXTENSION3_REPLACE           (IDS_UM_MSG_BASE+58)
#define IDS_PR_EXTENSION4_REPLACE           (IDS_UM_MSG_BASE+59)

#define IDS_AUDIT_LOGON                     (IDS_UM_MSG_BASE+61)
#define IDS_AUDIT_OBJECT_ACCESS             (IDS_UM_MSG_BASE+62)
#define IDS_AUDIT_PRIVILEGE_USE             (IDS_UM_MSG_BASE+63)
#define IDS_AUDIT_ACCOUNT_MANAGEMENT        (IDS_UM_MSG_BASE+64)
#define IDS_AUDIT_POLICY_CHANGE             (IDS_UM_MSG_BASE+65)
#define IDS_AUDIT_SYSTEM                    (IDS_UM_MSG_BASE+66)
#define IDS_AUDIT_DETAILED_TRACKING         (IDS_UM_MSG_BASE+67)

#define IDS_INTERACTIVE                     (IDS_UM_MSG_BASE+83)
#define IDS_NETWORK                         (IDS_UM_MSG_BASE+84)
#define IDS_SERVICE                         (IDS_UM_MSG_BASE+85)
#define IDS_BATCH                           (IDS_UM_MSG_BASE+86)

// these strings hide the main window listboxed in Slow Network mode
#define IDS_HIDE_USERS                      (IDS_UM_MSG_BASE+90)
#define IDS_HIDE_GROUPS                     (IDS_UM_MSG_BASE+91)

// these strings are the title and text of the dialog where you enter
// the name of the user or group you wish to work with in Slow Network mode
#define IDS_RAS_TITLE_COPY                  (IDS_UM_MSG_BASE+93)
#define IDS_RAS_TEXT_COPY                   (IDS_UM_MSG_BASE+94)
#define IDS_RAS_TITLE_DELETE                (IDS_UM_MSG_BASE+95)
#define IDS_RAS_TEXT_DELETE                 (IDS_UM_MSG_BASE+96)
#define IDS_RAS_TITLE_EDIT                  (IDS_UM_MSG_BASE+97)
#define IDS_RAS_TEXT_EDIT                   (IDS_UM_MSG_BASE+98)
#define IDS_RAS_TITLE_RENAME_USER           (IDS_UM_MSG_BASE+99)
#define IDS_RAS_TEXT_RENAME_USER            (IDS_UM_MSG_BASE+100)

// These are miscallaneous error messages associated with Slow Network mode
#define IDS_RAS_ACCOUNT_NOT_FOUND           (IDS_UM_MSG_BASE+102)
#define IDS_RAS_WRONG_ACCOUNT_TYPE          (IDS_UM_MSG_BASE+103)
#define IDS_RAS_CANT_RENAME_GROUP           (IDS_UM_MSG_BASE+104)
#define IDS_RAS_CANT_EDIT_GLOB_GRP          (IDS_UM_MSG_BASE+105)
#define IDS_RAS_CANT_MIX_TYPES              (IDS_UM_MSG_BASE+106)
#define IDS_RAS_CANT_RENAME_MULTIPLE        (IDS_UM_MSG_BASE+107)
#define IDS_RAS_CANT_COPY_MULTIPLE          (IDS_UM_MSG_BASE+108)

#define IDS_SERVER_TEXT                     (IDS_UM_MSG_BASE+110)
#define IDS_DOMAIN_TEXT                     (IDS_UM_MSG_BASE+111)
#define IDS_ACCKEY_S                        (IDS_UM_MSG_BASE+112)
#define IDS_ACCKEY_M                        (IDS_UM_MSG_BASE+113)
#define IERR_SECSET_MIN_MAX                 (IDS_UM_MSG_BASE+114)
#define IERR_SECSET_DURATION_LT_OBSRV       (IDS_UM_MSG_BASE+115)

#define IDS_FPNW_SVC_ACCOUNT_NAME           (IDS_UM_MSG_BASE+116)
#define IDS_REMOVE_NETWARE_USER             (IDS_UM_MSG_BASE+117)
#define IDS_REMOVE_NETWARE_USERS            (IDS_UM_MSG_BASE+118)

#define IDS_MENU_NAME_ALL_USERS             (IDS_UM_MSG_BASE+119)
#define IDS_MENU_NAME_NETWARE_USERS         (IDS_UM_MSG_BASE+120)
#define IDS_MENU_NAME_NETWARE_HELP          (IDS_UM_MSG_BASE+121)
#define IDS_FILTERED                        (IDS_UM_MSG_BASE+122)

#define IDS_DIALIN_PRESET_REQUIRED          (IDS_UM_MSG_BASE+123)
#define IDS_DIALIN_BAD_PHONE                (IDS_UM_MSG_BASE+124)

// hydra
#define IDS_ReminderForAnonymousReboot      (IDS_UM_MSG_BASE+125)


//
// Menu ID's
//

#define IDM_UMAPP_BASE          (IDM_ADMINAPP_LAST+1)

#define IDM_VIEW_LOGONNAME_SORT (IDM_UMAPP_BASE+0)
#define IDM_VIEW_FULLNAME_SORT  (IDM_UMAPP_BASE+1)

#define IDM_USER_NEWGROUP       (IDM_UMAPP_BASE+4)
#define IDM_USER_NEWALIAS       (IDM_UMAPP_BASE+5)
#define IDM_USER_SET_SELECTION  (IDM_UMAPP_BASE+2)
#define IDM_USER_RENAME         (IDM_UMAPP_BASE+3)

#define IDM_POLICY_ACCOUNT      (IDM_UMAPP_BASE+6)
#define IDM_POLICY_USER_RIGHTS  (IDM_UMAPP_BASE+7)
#define IDM_POLICY_AUDITING     (IDM_UMAPP_BASE+8)
#define IDM_POLICY_TRUST        (IDM_UMAPP_BASE+9)

#define IDM_HELP_NETWARE        (IDM_UMAPP_BASE+10)
#define IDM_VIEW_ALL_USERS      (IDM_UMAPP_BASE+11)
#define IDM_VIEW_NETWARE_USERS  (IDM_UMAPP_BASE+12)

//
// Main Window ListBox Control IDs
//

#define IDC_COLHEAD_USERS       100
#define IDC_LBUSERS             101
#define IDC_COLHEAD_GROUPS      102
#define IDC_LBGROUPS            103

// these SLTs hide the main window listboxed in RAS mode
#define IDC_HIDEUSERS           104
#define IDC_HIDEGROUPS          105

// this is the main window listbox splitter bar
#define IDC_UM_SPLITTER         110

// These bitmaps can be in the User Properties dialogs

#define BMID_USRPROP_BTN_BASE   210
#define BMID_USRPROP_GROUPBTN   210
#define BMID_USRPROP_PRIVSBTN   211
#define BMID_USRPROP_PROFILEBTN 212
#define BMID_USRPROP_HOURSBTN   213
#define BMID_USRPROP_LFROMBTN   214
#define BMID_USRPROP_DETAILBTN  215
#define BMID_USRPROP_RASBTN     216
#define BMID_USRPROP_NCPBTN     217

/********* KEITHMO BELOW *****************/


//
//  Message Pop-up string IDs.
//

#define IDS_TRUSTDIALOG_BASE            (IDS_UMAPP_BASE+310)
#define IDS_TRUST_WARN_DELETE_TRUSTED   (IDS_TRUSTDIALOG_BASE+0)
#define IDS_TRUST_WARN_DELETE_PERMITTED (IDS_TRUSTDIALOG_BASE+1)
#define IDS_TRUST_CLOSE                 (IDS_TRUSTDIALOG_BASE+2)
#define IDS_TRUST_PASSWORD_TOO_SMALL    (IDS_TRUSTDIALOG_BASE+3)


//
//  Help contexts for the messages above.
//

#define HC_VLW_BASE                             1000
#define HC_VLW_GIVE_NAMES       (HC_VLW_BASE +1)
#define HC_VLW_NO_GOOD_NAMES    (HC_VLW_BASE +2)

//
//  Help contexts for the various dialogs.
//


/********* KEITHMO ABOVE *****************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\umxdebug\umxdebug.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    umxdebug.h
    Main header file for Test User Manager Extension.


    FILE HISTORY:
        JonN        19-Nov-1992 Created (templated from smxdebug)

*/


#ifndef _UMXDEBUG_H_
#define _UMXDEBUG_H_


#include <windows.h>
#include <lm.h>
#include <umx.h>


//
//  Constants
//

#define ID_MENU         1000
#define IDM_TEST1       1
#define IDM_TEST2       2
#define IDM_TEST3       3
#define IDM_TEST4       4
#define IDM_TEST5       5
#define IDM_TEST6       6

#define IDS_MENUNAME    2000
#define IDS_HELPFILE    2001

#define EXT_VERSION     1


//
//  Prototypes.
//

BOOL FAR PASCAL UmxDebugDllInitialize( HANDLE hInstance,
                                       DWORD  nReason,
                                       LPVOID pReserved );

BOOL InitializeDll( HANDLE hInstance );

VOID TerminateDll( VOID );


#endif  // _UMXDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\umxdebug\umxdebug.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    umxdebug.c
    This is a simple test for the User Manager Extension mechanism.


    FILE HISTORY:
        JonN        10-Nov-1992 Created (templated from smxdebug)

*/


#include "umxdebug.h"


//
//  Globals.
//

HANDLE _hInstance;
HWND   _hwndMessage;
DWORD  _dwVersion;
DWORD  _dwDelta;


VOID DoPopup( HWND hwndParent,
              PUMS_GETSEL pumsSelection,
              const TCHAR * pchFnCalled,
              const TCHAR * pchNewName );
VOID DoShowAction( HWND hwndParent, DWORD dwEventId );
VOID DoShowSelection( HWND hwndParent, DWORD dwListbox );

VOID DoPopup( HWND hwndParent,
              PUMS_GETSEL pumsSelection,
              const TCHAR * pchFnCalled,
              const TCHAR * pchNewName )
{
    TCHAR szBuffer[512];
    TCHAR szBuffer2[128];
    const TCHAR * pszMsg = szBuffer;
    const TCHAR * pszCaption = szBuffer2;

    if (pchNewName == NULL) {
        wsprintf( szBuffer,
                  TEXT("RID = %08lx, Name = \"%s\", Type = %08lX, Fullname = \"%s\", Comment = \"%s\""),
                  pumsSelection->dwRID,
                  (pumsSelection->pchName) ? pumsSelection->pchName : TEXT("<NULL>"),
                  pumsSelection->dwSelType,
                  (pumsSelection->pchFullName) ? pumsSelection->pchFullName : TEXT("<NULL>"),
                  (pumsSelection->pchComment) ? pumsSelection->pchComment : TEXT("<NULL>") );
                  // CODEWORK buffer size may be too small
    }
    else
    {
        wsprintf( szBuffer,
                  TEXT("New name = \"%s\", RID = %08lx, Name = \"%s\", Type = %08lX, Fullname = \"%s\", Comment = \"%s\""),
                  pchNewName,
                  pumsSelection->dwRID,
                  (pumsSelection->pchName) ? pumsSelection->pchName : TEXT("<NULL>"),
                  pumsSelection->dwSelType,
                  (pumsSelection->pchFullName) ? pumsSelection->pchFullName : TEXT("<NULL>"),
                  (pumsSelection->pchComment) ? pumsSelection->pchComment : TEXT("<NULL>") );
                  // CODEWORK buffer size may be too small
    }

    wsprintf( szBuffer2,
              TEXT("UMXDEBUG - %s"),
              pchFnCalled );

    MessageBox( hwndParent,
                pszMsg,
                pszCaption,
                MB_OK );

}


VOID DoShowAction( HWND hwndParent, DWORD dwEventId )
{
    TCHAR szBuffer[512];
    const TCHAR * pszMsg = szBuffer;

    wsprintf( szBuffer,
              TEXT("Menu item %d activated"),
              dwEventId );

    MessageBox( hwndParent,
                pszMsg,
                TEXT("UMXDEBUG"),
                MB_OK );

}


VOID DoShowSelection( HWND hwndParent, DWORD dwListbox )
{
    TCHAR szBuffer[512];
    const TCHAR * pszMsg = szBuffer;
    UMS_GETSELCOUNT umsget;
    DWORD i;

    if (!SendMessage( _hwndMessage, UM_GETSELCOUNT, dwListbox, (LPARAM)&umsget ))
    {
        MessageBox( hwndParent,
                    (dwListbox == UMS_LISTBOX_USERS)
                      ? TEXT("Error loading user count")
                      : TEXT("Error loading group count"),
                    TEXT("UMXDEBUG"),
                    MB_OK );

    }
    else
    {
        wsprintf( szBuffer,
                  TEXT("%d %s selected"),
                  umsget.dwItems,
                  (dwListbox == UMS_LISTBOX_USERS)
                    ? TEXT("user(s)")
                    : TEXT("group(s)") );

        MessageBox( hwndParent,
                    pszMsg,
                    TEXT("UMXDEBUG"),
                    MB_OK );


        for (i = 0; i < umsget.dwItems ; i++ )
        {

            UMS_GETSEL umsel;

            if (!SendMessage( _hwndMessage,
                              (dwListbox == UMS_LISTBOX_USERS)
                                 ? UM_GETUSERSEL
                                 : UM_GETGROUPSEL,
                              (WPARAM)i,
                              (LPARAM)&umsel ) )
            {
                wsprintf( szBuffer,
                          TEXT("Error loading %s %d"),
                          (dwListbox == UMS_LISTBOX_USERS)
                            ? TEXT("user(s)")
                            : TEXT("group(s)"),
                          i );
            }
            else
            {
                wsprintf( szBuffer,
                          TEXT("%s %d: RID = %08lx, Name = \"%s\", Type = %08lX, Fullname = \"%s\", Comment = \"%s\""),
                          (dwListbox == UMS_LISTBOX_USERS)
                            ? TEXT("User")
                            : TEXT("Group"),
                          i,
                          umsel.dwRID,
                          (umsel.pchName) ? umsel.pchName : TEXT("<NULL>"),
                          umsel.dwSelType,
                          (umsel.pchFullName) ? umsel.pchFullName : TEXT("<NULL>"),
                          (umsel.pchComment) ? umsel.pchComment : TEXT("<NULL>") );
                          // CODEWORK buffer size may be too small
            }

            MessageBox( hwndParent,
                        pszMsg,
                        TEXT("UMXDEBUG"),
                        MB_OK );

        }
    }
}




/*******************************************************************

    NAME:       UmxDebugDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance               - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
BOOL FAR PASCAL UmxDebugDllInitialize( HANDLE hInstance,
                                       DWORD  nReason,
                                       LPVOID pReserved )
{
    BOOL fResult = TRUE;

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

        fResult = InitializeDll( hInstance );
        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

        TerminateDll();
        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;

}   // UmxDebugDllInitialize


/*******************************************************************

    NAME:       InitializeDll

    SYNOPSIS:   Perform DLL initialiazation functions on a
                once-per-process basis.

    ENTRY:      hInstance               - Program instance of the caller.

    EXIT:       The DLL has been initialized.

    RETURNS:    BOOL                    - TRUE  = Initialization OK.
                                          FALSE = Initialization failed.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
BOOL InitializeDll( HANDLE hInstance )
{
    //
    //  Save the instance handle.
    //

    _hInstance = hInstance;

    return TRUE;

}   // InitializeDll


/*******************************************************************

    NAME:       TerminateDll

    SYNOPSIS:   Perform DLL termination functions on a
                once-per-process basis.

    EXIT:       All necessary BLT terminators have been invoked.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID TerminateDll( VOID )
{
    //
    //  Just in case we try to do anything goofy.
    //

    _hInstance = NULL;

}   // TerminateDll


/*******************************************************************

    NAME:       UMELoadMenuW

    SYNOPSIS:   This DLL entrypoint notifies the extension that it
                is getting loaded by the application.

    ENTRY:      hWnd                    - The "owning" window.

                pumsload                - Points to an UMS_LOADMENU
                                          structure containing load
                                          parameters.

    RETURNS:    DWORD                   - Actually an APIERR, should be
                                          0 if successful.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
DWORD PASCAL UMELoadMenuW( HWND          hwndMessage,
                           PUMS_LOADMENU pumsload )
{
    TCHAR szBuffer[512];
    const TCHAR * pszMsg = szBuffer;

    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMELoadMenuW\n") );

    if( pumsload == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    wsprintf( szBuffer,
              TEXT("Incoming version %d, menu delta %d"),
              pumsload->dwVersion,
              pumsload->dwMenuDelta );

    MessageBox( hwndMessage,
                pszMsg,
                TEXT("UMXDEBUG"),
                MB_OK );

    _hwndMessage = hwndMessage;
    _dwVersion   = EXT_VERSION;

    if( pumsload->dwVersion > _dwVersion )
    {
        pumsload->dwVersion = _dwVersion;
    }
    else
    if( pumsload->dwVersion < _dwVersion )
    {
        _dwVersion = pumsload->dwVersion;
    }

    wsprintf( szBuffer,
              TEXT("Outgoing version %d"),
              _dwVersion );

    MessageBox( hwndMessage,
                pszMsg,
                TEXT("UMXDEBUG"),
                MB_OK );

    _dwDelta = pumsload->dwMenuDelta;

    LoadString( _hInstance, IDS_MENUNAME, pumsload->szMenuName, UME_MENU_TEXT_LEN );
    LoadString( _hInstance, IDS_HELPFILE, pumsload->szHelpFileName, MAX_PATH );

    pumsload->hMenu = LoadMenu( _hInstance, MAKEINTRESOURCE( ID_MENU ) );

    return NO_ERROR;

}   // UMELoadW


/*******************************************************************

    NAME:       UMEGetExtendedErrorStringW

    SYNOPSIS:   If UMELoadW returns ERROR_EXTENDED_ERROR, then this
                entrypoint should be called to retrieve the error
                text associated with the failure condition.

    RETURNS:    LPTSTR                  - The extended error text.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
LPTSTR PASCAL UMEGetExtendedErrorStringW( VOID )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMEGetExtendedErrorStringW\n") );

    return TEXT("Error String from UMEGetExtendedErrorStringW");

}   // UMEGetExtendedErrorStringW


/*******************************************************************

    NAME:       UMEUnloadMenu

    SYNOPSIS:   Notifies the extension DLL that it is getting unloaded.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL UMEUnloadMenu( VOID )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMEUnloadMenu\n") );

}   // UMEUnload


/*******************************************************************

    NAME:       UMEInitializeMenu

    SYNOPSIS:   Notifies the extension DLL that the main menu is
                getting activated.  The extension should use this
                opportunity to perform any menu manipulations.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL UMEInitializeMenu( VOID )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMEInitializeMenu\n") );

    //
    //  This space intentionally left blank.
    //

}   // UMEInitializeMenu


/*******************************************************************

    NAME:       UMERefresh

    SYNOPSIS:   Notifies the extension DLL that the user has requested
                a refresh.  The extension should use this opportunity
                to update any cached data.

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL UMERefresh( HWND hwndParent )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMERefresh\n") );

    MessageBox( hwndParent,
                TEXT("UMERefresh"),
                TEXT("UMXDEBUG"),
                MB_OK );

}   // UMERefresh


/*******************************************************************

    NAME:       UMEMenuAction

    SYNOPSIS:   Notifies the extension DLL that one of its menu
                items has been selected.

    ENTRY:      dwEventId               - The menu ID being activated
                                          (should be 1-99).

    HISTORY:
        KeithMo     20-Oct-1992 Created.

********************************************************************/
VOID PASCAL UMEMenuAction( HWND hwndParent, DWORD dwEventId )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMEMenuAction\n") );

    DoShowAction( hwndParent, dwEventId );

    switch (dwEventId) {

    case IDM_TEST1:
    case IDM_TEST2:
        {
            DoShowSelection( hwndParent, UMS_LISTBOX_USERS );
            DoShowSelection( hwndParent, UMS_LISTBOX_GROUPS );
        }
        break;

    case IDM_TEST3:
        {
            UMS_GETCURFOCUS umsfocus;

            if (!SendMessage( _hwndMessage, UM_GETCURFOCUS, 0, (LPARAM)&umsfocus ))
            {
                MessageBox( hwndParent,
                            TEXT("Could not get focus information"),
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
            else
            {
                TCHAR szBuffer[512];
                const TCHAR * pszMsg = szBuffer;

                wsprintf( szBuffer,
                          TEXT("Focus \"%s\", focus type %d, focus PDC \"%s\", focus SID \"%s\""),
                          umsfocus.szFocus,
                          umsfocus.dwFocusType,
                          umsfocus.szFocusPDC,
                          TEXT("<?>") ); // CODEWORK display SID properly

                MessageBox( hwndParent,
                            pszMsg,
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
        }
        break;

    case IDM_TEST6:
        {
            UMS_GETCURFOCUS2 umsfocus;

            if (!SendMessage( _hwndMessage, UM_GETCURFOCUS2, 0, (LPARAM)&umsfocus ))
            {
                MessageBox( hwndParent,
                            TEXT("Could not get focus information"),
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
            else
            {
                TCHAR szBuffer[512];
                const TCHAR * pszMsg = szBuffer;

                wsprintf( szBuffer,
                          TEXT("Focus \"%s\", focus type %d, focus PDC \"%s\", focus SID \"%s\""),
                          umsfocus.szFocus,
                          umsfocus.dwFocusType,
                          umsfocus.szFocusPDC,
                          TEXT("<?>") ); // CODEWORK display SID properly

                MessageBox( hwndParent,
                            pszMsg,
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
        }
        break;

    case IDM_TEST4:
        {
            UMS_GETOPTIONS umsoptions;

            if (!SendMessage( _hwndMessage, UM_GETOPTIONS, 0, (LPARAM)&umsoptions ))
            {
                MessageBox( hwndParent,
                            TEXT("Could not get options information"),
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
            else
            {
                TCHAR szBuffer[512];
                const TCHAR * pszMsg = szBuffer;

                wsprintf( szBuffer,
                          TEXT("Save Settings On Exit %s, Confirmation %s, Sort By Full Name %s"),
                          (umsoptions.fSaveSettingsOnExit) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fConfirmation) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fSortByFullName) ? TEXT("TRUE") : TEXT("FALSE") );

                MessageBox( hwndParent,
                            pszMsg,
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
        }
        break;

    case IDM_TEST5:
        {
            UMS_GETOPTIONS2 umsoptions;

            if (!SendMessage( _hwndMessage, UM_GETOPTIONS2, 0, (LPARAM)&umsoptions ))
            {
                MessageBox( hwndParent,
                            TEXT("Could not get options information"),
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
            else
            {
                TCHAR szBuffer[512];
                const TCHAR * pszMsg = szBuffer;

                wsprintf( szBuffer,
                          TEXT("Save Settings On Exit %s, Confirmation %s, Sort By Full Name %s, Mini-User Manager %s, Low Speed Connection %s"),
                          (umsoptions.fSaveSettingsOnExit) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fConfirmation) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fSortByFullName) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fMiniUserManager) ? TEXT("TRUE") : TEXT("FALSE"),
                          (umsoptions.fLowSpeedConnection) ? TEXT("TRUE") : TEXT("FALSE") );

                MessageBox( hwndParent,
                            pszMsg,
                            TEXT("UMXDEBUG"),
                            MB_OK );

            }
        }
        break;

    default:
        {
            MessageBox( hwndParent,
                        TEXT("Unexpected event ID"),
                        TEXT("UMXDEBUG"),
                        MB_OK );
        }
        break;

    }

}   // UMEMenuAction


/*******************************************************************

    NAME:       UMECreateW

    SYNOPSIS:   Notifies the extension DLL that the user has created
                a group or user.

    HISTORY:
        JonN        24-Nov-1992 Created.

********************************************************************/
VOID PASCAL UMECreateW( HWND hwndParent, PUMS_GETSELW pumsSelection )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMECreateW\n") );

    DoPopup( hwndParent,
             pumsSelection,
             TEXT("UMECreateW"),
             NULL );

}   // UMERefresh


/*******************************************************************

    NAME:       UMEDeleteW

    SYNOPSIS:   Notifies the extension DLL that the user has deleted
                a group or user.

    HISTORY:
        JonN        24-Nov-1992 Created.

********************************************************************/
VOID PASCAL UMEDeleteW( HWND hwndParent, PUMS_GETSELW pumsSelection )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMEDeleteW\n") );

    DoPopup( hwndParent,
             pumsSelection,
             TEXT("UMEDeleteW"),
             NULL );

}   // UMERefresh


/*******************************************************************

    NAME:       UMERenameW

    SYNOPSIS:   Notifies the extension DLL that the user has renamed
                a user (groups cannot be renamed).

    HISTORY:
        JonN        24-Nov-1992 Created.

********************************************************************/
VOID PASCAL UMERenameW( HWND hwndParent,
                        PUMS_GETSELW pumsSelection,
                        LPWSTR pchNewName )
{
    OutputDebugString( TEXT("UMXDEBUG.DLL : in UMECreateW\n") );

    DoPopup( hwndParent,
             pumsSelection,
             TEXT("UMERenameW"),
             pchNewName );

}   // UMERefresh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\ctxhlprs.cxx ===
/*************************************************************************
*
*   ctxhlprs.c
*
*   User Manager Citrix extension helper routines
*
*   copyright notice: Copyright 1997, Citrix Systems Inc.
*
*   $Author:   butchd  $ Butch Davis
*
*   $Log:   N:\NT\PRIVATE\NET\UI\ADMIN\USER\USER\CITRIX\VCS\CTXHLPRS.CXX  $
*  
*     Rev 1.1   25 Mar 1997 14:30:12   butchd
*  update
*  
*     Rev 1.0   14 Mar 1997 11:51:04   butchd
*  Initial revision.
*  
*************************************************************************/

/*
 *  Includes
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmremutl.h>
#include <lmapibuf.h>
#include <winsock.h>
#include <citrix\ctxhlprs.hxx>
#include <citrix\winsta.h>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

/*
 * Defines and typedefs
 */
typedef struct _userlist {
    struct _userlist *pNext;
    WCHAR UserName[USERNAME_LENGTH+1];
} USERLIST, *PUSERLIST;

#define MAX_DOMAINANDNAME     ((DOMAIN_LENGTH+1+USERNAME_LENGTH+1)*sizeof(WCHAR))
#define MAX_BUFFER            (10*MAX_DOMAINANDNAME)       

/*
 * Local variables
 */
WCHAR *s_pszCompareList = NULL;
WCHAR s_szServer[256];

/*
 * Local functions.
 */
WCHAR *_ctxCreateAnonymousUserCompareList();

/*******************************************************************************
 *
 *  ctxInitializeAnonymousUserCompareList - helper routine
 *
 *    Creates a list of all local users who currently belong to the local
 *    Anonymous group on the specified server, and saves the server name.
 *
 * ENTRY:
 *    pszServer (input)
 *       Name of server to query users for.
 *
 ******************************************************************************/

void WINAPI
ctxInitializeAnonymousUserCompareList( const WCHAR *pszServer )
{
    if ( s_pszCompareList )
        free( s_pszCompareList );

    wcscpy(s_szServer, pszServer);

    s_pszCompareList = _ctxCreateAnonymousUserCompareList();
}


/*******************************************************************************
 *
 *  ctxHaveAnonymousUsersChanged - helper routine
 *
 *    Using the saved server name, fetch current list of local users that 
 *    belong to the local Anonymous group and compare with saved list.
 *
 * ENTRY:
 * EXIT:
 *    On exit, the original compare list is freed and server name cleared.
 *
 ******************************************************************************/

BOOL WINAPI
ctxHaveAnonymousUsersChanged()
{
    BOOL bChanged = FALSE;
    WCHAR *pszNewCompareList, *pszOldName, *pszNewName;

    if ( s_pszCompareList && *s_szServer ) {

        if ( pszNewCompareList = _ctxCreateAnonymousUserCompareList() ) {

            bChanged = TRUE;

            for ( pszOldName = s_pszCompareList, pszNewName = pszNewCompareList;
                  (*pszOldName != L'\0') && (*pszNewName != L'\0'); ) {

                if ( wcscmp(pszOldName, pszNewName) )
                    break;
                pszOldName += (wcslen(pszOldName) + 1);
                pszNewName += (wcslen(pszNewName) + 1);
            }

            if ( (*pszOldName == L'\0') && (*pszNewName == L'\0') )
                bChanged = FALSE;

            free(pszNewCompareList);
        }
    }

    if ( s_pszCompareList )
        free( s_pszCompareList );

    s_pszCompareList = NULL;

    memset(s_szServer, 0, sizeof(s_szServer));

    return(bChanged);
}


/*******************************************************************************
 *
 *  _ctxCreateAnonymousUserCompareList - local routine
 *
 *    Routine to get local anonymous users and place in sorted string list.
 *
 * ENTRY:
 * EXIT:
 *      pszCompareList - Returns pointer to buffer containing sorted string 
 *                       list of local anonymous users, double null terminated.
 *                       NULL if error.
 *
 ******************************************************************************/

WCHAR *
_ctxCreateAnonymousUserCompareList()
{
    DWORD                        EntriesRead, EntriesLeft, ResumeHandle = 0;
    NET_API_STATUS               rc;
    WCHAR                        DomainAndUsername[256], *pszCompareList = NULL;
    DWORD                        i, TotalCharacters = 0;
    LPWSTR                       p;
    PLOCALGROUP_MEMBERS_INFO_3   plgrmi3 = NULL;
    PUSERLIST                    pUserListBase = NULL, pNewUser;

    /*
     * Loop till all local anonymous users have been retrieved.
     */
    do {

        /*
         *  Get first batch
         */
        if ( (rc = NetLocalGroupGetMembers( s_szServer,
                                            PSZ_ANONYMOUS,
                                            3,            
                                            (LPBYTE *)&plgrmi3,
                                            MAX_BUFFER,
                                            &EntriesRead,
                                            &EntriesLeft,
                                            &ResumeHandle )) &&
             (rc != ERROR_MORE_DATA ) ) {

            break;
        }

        /*
         *  Process first batch
         */
        for ( i = 0; i < EntriesRead; i++ ) {

            /*
             *  Get DOMAIN/USERNAME
             */
            wcscpy( DomainAndUsername, plgrmi3[i].lgrmi3_domainandname );

            /*
             *  Check that DOMAIN is actually LOCAL MACHINE NAME
             */
            if ( (p = wcsrchr( DomainAndUsername, L'\\' )) != NULL ) {

                /*
                 * Make sure that this user belongs to specified
                 * server.
                 */
                *p = L'\0';
                if ( _wcsicmp( DomainAndUsername, &s_szServer[2] ) ) {
                    continue;
                }
            }

            /*
             * Allocate list element and insert this username into list.
             */
            if ( (pNewUser = (PUSERLIST)malloc(sizeof(USERLIST))) == NULL ) {

                rc = ERROR_OUTOFMEMORY;
                break;
            }

            pNewUser->pNext = NULL;
            wcscpy(pNewUser->UserName, p+1);
            TotalCharacters += wcslen(p+1) + 1;

            if ( pUserListBase == NULL ) {

                /*
                 * First item in list.
                 */
                pUserListBase = pNewUser;

            } else {

                PUSERLIST pPrevUserList, pUserList;
                pPrevUserList = pUserList = pUserListBase;

                for ( ; ; )  {
                    
                    if ( wcscmp(pNewUser->UserName, pUserList->UserName) < 0 ) {
                        
                       if ( pPrevUserList == pUserListBase ) {

                            /*
                             * Insert at beginning of list.
                             */
                            pUserListBase = pNewUser;

                        } else {

                            /*
                             * Insert into middle or beginning of list.
                             */
                            pPrevUserList->pNext = pNewUser;
                        }

                        /*
                         * Link to next.
                         */
                        pNewUser->pNext = pUserList;
                        break;

                    } else if ( pUserList->pNext == NULL ) {

                        /*
                         * Add to end of list.
                         */
                        pUserList->pNext = pNewUser;
                        break;
                    }

                    pPrevUserList = pUserList;
                    pUserList = pUserList->pNext;
                }
            }
        }

        /*
         *  Free memory
         */
        if ( plgrmi3 != NULL ) {
            NetApiBufferFree( plgrmi3 );
        }

    } while ( rc == ERROR_MORE_DATA );

    /*
     * Allocate buffer for multi-string compare list if no error so far
     * and terminate in case of empty list.
     */
    if ( rc == ERROR_SUCCESS ) {

        pszCompareList = (WCHAR *)malloc( (++TotalCharacters) * 2 );
        *pszCompareList = L'\0';
    }

    /*
     * Traverse and free username list, creating the multi-string compare
     * list if buffer is available (no error so far).
     */
    if ( pUserListBase ) {

        PUSERLIST pUserList = pUserListBase,
                  pNext = NULL;
        WCHAR *pBuffer = pszCompareList;

        do {

            pNext = pUserList->pNext;

            if ( pBuffer ) {

                wcscpy(pBuffer, pUserList->UserName);
                pBuffer += (wcslen(pBuffer) + 1);
                *pBuffer = L'\0';   // auto double-null terminate
            }

            free(pUserList);
            pUserList = pNext;

        } while ( pUserList );
    }

    return(pszCompareList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\dialin.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT  		     **/
/**          Copyright(c) Microsoft Corp., 1991                      **/
/**********************************************************************/

/*
 *   dialin.cxx
 *   This module contains the Dialin Properties dialog.
 *
 *   FILE HISTORY:
 *	JonN	16-Jan-1996	Created
 */

#include <ntincl.hxx>
extern "C"
{
   #include <ntsam.h>  // for USER_LBI to compile
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETACCESS  // for UF_NORMAL_ACCOUNT etc in ntuser.hxx
#include <lmui.hxx>
#include <lmomod.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <mnet.h>
    #include <umhelpc.h>
    #include <rassapi.h>
    #include <raserror.h> // ERROR_BAD_PHONE_NUMBER
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <strnumer.hxx>
#include <usrmgrrc.h>
#include <lmsvc.hxx>
#include <dialin.hxx>
#include <security.hxx>
#include <dbgstr.hxx>

typedef DWORD (* PRASADMINGETPARMS)( WCHAR*      lpszParms,
                                     RAS_USER_0* pRasUser0 );
typedef DWORD (* PRASADMINSETPARMS)( WCHAR*      lpszParms,
                                     DWORD       cchNewParms,
                                     RAS_USER_0* pRasUser0 );
#define SZ_RASADMIN_DLL      SZ("RASSAPI.DLL")
// not SZ(""), there is no GetProcAddressW
#define SZ_RASADMIN_GETPARMS "RasAdminGetUserParms"
#define SZ_RASADMIN_SETPARMS "RasAdminSetUserParms"
#define DoRasAdminGet (PRASADMINGETPARMS)_pfnRasAdminGetParms
#define DoRasAdminSet (PRASADMINSETPARMS)_pfnRasAdminSetParms

/*******************************************************************

    NAME:	DIALIN_PROP_DLG::DIALIN_PROP_DLG

    SYNOPSIS:   Constructor for Dialin Properties subdialog

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

DIALIN_PROP_DLG::DIALIN_PROP_DLG(
	USERPROP_DLG * puserpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USER_SUBPROP_DLG(
		puserpropdlgParent,
		MAKEINTRESOURCE( IDD_DIALIN_PROPERTIES ),
		pulb
		),
            _fAllowDialin( FALSE ),
            _fIndeterminateAllowDialin( FALSE ),
            _fCallbackTypeFlags( 0x0 ),
            _fIndeterminateCallbackTypeFlags( FALSE ),
            _nlsPresetCallback(),
            _fIndeterminatePresetCallback( FALSE ),
            _fIndetNowPresetCallback( FALSE ),
            _cbAllowDialin( this, IDDIALIN_ALLOW_DIALIN ),
            _pmgrpCallbackType( NULL ),
            _slePresetCallback( this,
                                IDDIALIN_CALLBACKNUMBER,
                                RASSAPI_MAX_PHONENUMBER_SIZE/sizeof(TCHAR)  ),
            _hinstRasAdminDll( NULL ),
            _pfnRasAdminGetParms( NULL ),
            _pfnRasAdminSetParms( NULL )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    _pmgrpCallbackType = new MAGIC_GROUP( this, IDDIALIN_NOCALLBACK, 3 );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _pmgrpCallbackType == NULL
        || (err = _pmgrpCallbackType->QueryError()) != NERR_Success
        || (err = _pmgrpCallbackType->AddAssociation(
	        IDDIALIN_CALLBACK_PRESET,
	        &_slePresetCallback )) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    if (   (_hinstRasAdminDll = ::LoadLibrary( SZ_RASADMIN_DLL )) == NULL
        || (_pfnRasAdminGetParms = ::GetProcAddress(
                                        _hinstRasAdminDll,
                                        SZ_RASADMIN_GETPARMS)) == NULL
        || (_pfnRasAdminSetParms = ::GetProcAddress(
                                        _hinstRasAdminDll,
                                        SZ_RASADMIN_SETPARMS)) == NULL
       )
    {
        err = ::GetLastError();
        TRACEEOL( "USRMGR: DIALIN_PROP_DLG::ctor: load error " << err );
        ReportError( err );
        return;
    }

}// DIALIN_PROP_DLG::DIALIN_PROP_DLG



/*******************************************************************

    NAME:       DIALIN_PROP_DLG::~DIALIN_PROP_DLG

    SYNOPSIS:   Destructor for Dialin Properties subdialog

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

DIALIN_PROP_DLG::~DIALIN_PROP_DLG()
{
    delete _pmgrpCallbackType;
    if ( _hinstRasAdminDll != NULL )
    {
        REQUIRE( ::FreeLibrary( _hinstRasAdminDll ) );
        _hinstRasAdminDll = NULL;
    }

}// DIALIN_PROP_DLG::~DIALIN_PROP_DLG



/*******************************************************************

    NAME:       DIALIN_PROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

APIERR DIALIN_PROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    USER_2 * puser2Curr = QueryUser2Ptr( iObject );

    RAS_USER_0 rasuser0;
    ::memsetf( &rasuser0, 0, sizeof(rasuser0) );
    APIERR err = (DoRasAdminGet)( (WCHAR *)puser2Curr->QueryParms(),
                                  &rasuser0 );
    TRACEEOL( "DIALIN_PROP_DLG::W_LMOBJtoMembers: RasAdminGetUserParms returns "
        << err );
    TRACEEOL( "  rasuser0.bfPrivilege = 0x" << HEX_STR(rasuser0.bfPrivilege)
        << ", rasuser0.szPhoneNumber = \"" << rasuser0.szPhoneNumber << "\"" );
    if (err == ERROR_BAD_FORMAT)
        err = NERR_InternalError;
    if (err != NERR_Success)
        return err;

    if ( iObject == 0 ) // first object
    {
        _fAllowDialin = !!(rasuser0.bfPrivilege & RASPRIV_DialinPrivilege);
        _fCallbackTypeFlags = rasuser0.bfPrivilege & RASPRIV_CallbackType;
        if ( _fCallbackTypeFlags & RASPRIV_AdminSetCallback )
        {
           if ( (err = _nlsPresetCallback.CopyFrom(rasuser0.szPhoneNumber))
                   != NERR_Success )
           {
               return err;
           }
        }
    }
    else	// iObject > 0
    {
        if ( _fAllowDialin !=
                !!(rasuser0.bfPrivilege & RASPRIV_DialinPrivilege) )
        {
            _fIndeterminateAllowDialin = TRUE;
        }
	if ( _fCallbackTypeFlags !=
                (rasuser0.bfPrivilege & RASPRIV_CallbackType) )
	{
            _fIndeterminateCallbackTypeFlags = TRUE;
	    _fIndeterminatePresetCallback = TRUE;
	} else if ( _fCallbackTypeFlags & RASPRIV_AdminSetCallback )
        {
	    ALIAS_STR nlsNewPresetCallback( rasuser0.szPhoneNumber );
	    if ( _nlsPresetCallback.strcmp( nlsNewPresetCallback ) )
	    {
	        _fIndeterminatePresetCallback = TRUE;
		APIERR err = _nlsPresetCallback.CopyFrom( NULL );
		if ( err != NERR_Success )
		    return err;
	    }
        }
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );
	
} // DIALIN_PROP_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       DIALIN_PROP_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by DIALIN_PROP_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

APIERR DIALIN_PROP_DLG::InitControls()
{
    APIERR err = NERR_Success;

    if ( !_fIndeterminateAllowDialin )
    {
        _cbAllowDialin.SetCheck( _fAllowDialin );
        _cbAllowDialin.EnableThirdState( FALSE );
    } else {
        _cbAllowDialin.SetIndeterminate();
    }

    INT idresInitialSelection = RG_NO_SEL;
    if ( !_fIndeterminateCallbackTypeFlags )
    {
	if ( _fCallbackTypeFlags & RASPRIV_AdminSetCallback ) {
            ASSERT( RASPRIV_AdminSetCallback ==
                        (_fCallbackTypeFlags & RASPRIV_CallbackType) );
            idresInitialSelection = IDDIALIN_CALLBACK_PRESET;
	} else if ( _fCallbackTypeFlags & RASPRIV_CallerSetCallback ) {
            ASSERT( RASPRIV_CallerSetCallback ==
                        (_fCallbackTypeFlags & RASPRIV_CallbackType) );
            idresInitialSelection = IDDIALIN_CALLBACK_CALLER;
        } else {
            ASSERT( RASPRIV_NoCallback ==
                        (_fCallbackTypeFlags & RASPRIV_CallbackType) );
            idresInitialSelection = IDDIALIN_NOCALLBACK;
        }
    }
    _pmgrpCallbackType->SetSelection( idresInitialSelection );

    // must do this after SetSelection, reason unknown
    if (   idresInitialSelection == IDDIALIN_CALLBACK_PRESET
        && !_fIndeterminatePresetCallback )
    {
        if ( !_fIndeterminatePresetCallback )
        {
            _slePresetCallback.SetText( _nlsPresetCallback );
        }
    }

    return (err == NERR_Success) ? USER_SUBPROP_DLG::InitControls() : err;

} // DIALIN_PROP_DLG::InitControls


/*******************************************************************

    NAME:       DIALIN_PROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

APIERR DIALIN_PROP_DLG::W_DialogToMembers()
{
    _fIndeterminateAllowDialin = _cbAllowDialin.IsIndeterminate();
    if ( !_fIndeterminateAllowDialin )
    {
        _fAllowDialin = _cbAllowDialin.IsChecked();
    }

    _fIndeterminateCallbackTypeFlags = FALSE;
    _fIndetNowPresetCallback = TRUE;
    APIERR err = _nlsPresetCallback.CopyFrom( NULL );
    CID cid = _pmgrpCallbackType->QuerySelection();
    switch (cid)
    {
    case IDDIALIN_NOCALLBACK:
        _fCallbackTypeFlags = RASPRIV_NoCallback;
        break;
    case IDDIALIN_CALLBACK_CALLER:
        _fCallbackTypeFlags = RASPRIV_CallerSetCallback;
        break;
    case IDDIALIN_CALLBACK_PRESET:
        _fCallbackTypeFlags = RASPRIV_AdminSetCallback;
        err = _slePresetCallback.QueryText( &_nlsPresetCallback );
        ASSERT( _nlsPresetCallback.strlen() <= RASSAPI_MAX_PHONENUMBER_SIZE/sizeof(TCHAR) );
        _fIndetNowPresetCallback = ( _fIndeterminatePresetCallback &&
    	        (_nlsPresetCallback.strlen() == 0) );
        break;
    case RG_NO_SEL:
        _fIndeterminateCallbackTypeFlags = TRUE;
        break;
    default:
        ASSERT( FALSE );
        break;
    }

    return (err != NERR_Success) ? err : USER_SUBPROP_DLG::W_DialogToMembers();

} // DIALIN_PROP_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       DIALIN_PROP_DLG::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_2 is changed

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

BOOL DIALIN_PROP_DLG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       DIALIN_PROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

APIERR DIALIN_PROP_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    APIERR err = NERR_Success;

    if ( (!_fIndeterminateAllowDialin) || (!_fIndeterminateCallbackTypeFlags) )
    {
        RAS_USER_0 rasuser0;
        ::memsetf( &rasuser0, 0, sizeof(rasuser0) );

        // retain previous settings
        // CODEWORK it would be nice if we saved these from the
        //   initial query
        APIERR err = (DoRasAdminGet)( (WCHAR *)puser2->QueryParms(),
                                      &rasuser0 );
        TRACEEOL( "DIALIN_PROP_DLG::W_MembersToLMOBJ: RasAdminGetUserParms returns "
            << err );
        TRACEEOL( "  rasuser0.bfPrivilege = 0x" << HEX_STR(rasuser0.bfPrivilege)
            << ", rasuser0.szPhoneNumber = \"" << rasuser0.szPhoneNumber << "\"" );
        if (err == ERROR_BAD_FORMAT)
            err = NERR_InternalError;
        if (err != NERR_Success)
            return err;
        if (   (rasuser0.bfPrivilege & RASPRIV_AdminSetCallback)
            && (::strlenf(rasuser0.szPhoneNumber) == 0) )
        {
            TRACEEOL( "  WARNING: bad initial phone number" );
        }


        if ( !_fIndeterminateAllowDialin )
        {
            rasuser0.bfPrivilege &= ~RASPRIV_DialinPrivilege;
            if ( _fAllowDialin )
                rasuser0.bfPrivilege |= RASPRIV_DialinPrivilege;
        }

        if ( !_fIndeterminateCallbackTypeFlags )
        {
            rasuser0.bfPrivilege &= ~RASPRIV_CallbackType;
            rasuser0.bfPrivilege |= _fCallbackTypeFlags;
            if ( !_fIndetNowPresetCallback )
            {
                ::strncpyf( rasuser0.szPhoneNumber,
                            _nlsPresetCallback.QueryPch(),
                            RASSAPI_MAX_PHONENUMBER_SIZE/sizeof(TCHAR) );
            }
        }

        if (   (rasuser0.bfPrivilege & RASPRIV_AdminSetCallback)
            && (::strlenf(rasuser0.szPhoneNumber) == 0) )
        {
            _slePresetCallback.ClaimFocus();
            _slePresetCallback.SelectString();
            return IDS_DIALIN_PRESET_REQUIRED;
        }

        TRACEEOL( "DIALIN_PROP_DLG::W_MembersToLMOBJ: calling RasAdminSetUserParms" );
        TRACEEOL( "  rasuser0.bfPrivilege = 0x" << HEX_STR(rasuser0.bfPrivilege)
            << ", rasuser0.szPhoneNumber = \"" << rasuser0.szPhoneNumber << "\"" );
        BUFFER buf( ::strlenf(puser2->QueryParms())*sizeof(WCHAR)
                        + sizeof(RAS_USER_0) );
        if ( (err = buf.QueryError()) != NERR_Success )
            return err;
        WCHAR * pwchParms = (WCHAR *)buf.QueryPtr();
        ::strcpyf( pwchParms, puser2->QueryParms() );
        err = (DoRasAdminSet)( pwchParms,
                               buf.QuerySize() / sizeof(WCHAR),
                               &rasuser0 );
        TRACEEOL( "DIALIN_PROP_DLG::W_MembersToLMOBJ: RasAdminSetUserParms returns "
            << err );
        if (err == ERROR_BAD_FORMAT)
            err = NERR_InternalError;
        else if (err == ERROR_INVALID_CALLBACK_NUMBER)
        {
            _slePresetCallback.ClaimFocus();
            _slePresetCallback.SelectString();
            err = IDS_DIALIN_BAD_PHONE;
        }
        if (   err != NERR_Success
            || (err = puser2->SetParms(pwchParms)) != NERR_Success
           )
        {
            return err;
        }
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// DIALIN_PROP_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       DIALIN_PROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
	JonN	16-Jan-1996	Created

********************************************************************/

ULONG DIALIN_PROP_DLG::QueryHelpContext( void )
{

    return HC_UM_DIALIN_PROP_LANNT + QueryHelpOffset();

} // DIALIN_PROP_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\alsprop.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991, 1992          **/
/**********************************************************************/

/*
    alsprop.cxx

    FILE HISTORY:
    Thomaspa     17-Mar-1992    Created
    Thomaspa     14-May-1992    Show Full Names support and copy alias
    JonN         07-Jun-1992    Fixed _pfWorkWasDone
    JonN         17-Aug-1992    HAW-for-Hawaii in listbox

    CODEWORK should use VALIDATED_DIALOG for edit field validation
*/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <lmowks.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SETCONTROL
#include <blt.hxx>

// usrmgrrc.h must be included after blt.hxx (more exactly, after bltrc.h)
extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <ntseapi.h>
    #include <mnet.h>
    #include <usrmgrrc.h>
    #include <umhelpc.h>
}

#include <dbgstr.hxx>

#include <usrcolw.hxx>
#include <slist.hxx>
#include <strlst.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <heapones.hxx>
#include <lmogroup.hxx>
#include <security.hxx>
#include <ntacutil.hxx>
#include <usrbrows.hxx>
#include <bmpblock.hxx> // SUBJECT_BITMAP_BLOCK
#include <lmouser.hxx>
#include <alsprop.hxx>
#include <usrmain.hxx>


//
// BEGIN MEMBER FUNCTIONS
//

DEFINE_EXT_SLIST_OF( OS_SID );


/*******************************************************************

    NAME:       ACCOUNTS_LBI::ACCOUNTS_LBI

    SYNOPSIS:   Constructor

    ENTRY:      pszSubjectName - name of account
                psidSubject - PSID for account
                        or
                ulRIDSubject - RID of account   and
                psidDomain - PSID for domain of account
                SidType - SID_NAME_USE for account

    NOTES:

    HISTORY:
        Thomaspa    4-Apr-1992  Created
        beng        08-Jun-1992 Differentiate remote users

********************************************************************/

ACCOUNTS_LBI::ACCOUNTS_LBI( const TCHAR * pszSubjectName,
                            PSID psidSubject,
                            SID_NAME_USE  SidType,
                            BOOL fIsMemberAlready,
                            BOOL fRemoteUser )
        : LBI(),
          _nlsDisplayName( pszSubjectName ),
          _ossid( psidSubject, TRUE ),
          _SidType( SidType ),
          _fIsMemberAlready( fIsMemberAlready ),
          _fRemoteUser( fRemoteUser )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if (   ((err = _nlsDisplayName.QueryError()) != NERR_Success)
        || ((err = _ossid.QueryError()) != NERR_Success) )
    {
        ReportError( err );
        return;
    }

    // A little discipline... last flag makes sense only for users
    ASSERT(!fRemoteUser || SidType == SidTypeUser);
}


ACCOUNTS_LBI::ACCOUNTS_LBI( const TCHAR * pszSubjectName,
                            ULONG ulRIDSubject,
                            PSID psidDomain,
                            SID_NAME_USE  SidType,
                            BOOL fIsMemberAlready,
                            BOOL fRemoteUser )
        : LBI(),
          _nlsDisplayName( pszSubjectName ),
          _ossid( psidDomain, ulRIDSubject ),
          _SidType( SidType ),
          _fIsMemberAlready( fIsMemberAlready ),
          _fRemoteUser( fRemoteUser )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if (   ((err = _nlsDisplayName.QueryError()) != NERR_Success)
        || ((err = _ossid.QueryError()) != NERR_Success) )
    {
        ReportError( err );
        return;
    }

    // A little discipline... last flag makes sense only for users
    ASSERT(!fRemoteUser || SidType == SidTypeUser);
}


/*******************************************************************

    NAME:       ACCOUNTS_LBI::~ACCOUNTS_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    NOTES:

    HISTORY:
        Thomaspa        4-Apr-1992     Created

********************************************************************/

ACCOUNTS_LBI::~ACCOUNTS_LBI()
{
    // ...
}


/*******************************************************************

    NAME:       ACCOUNTS_LBI::Paint

    SYNOPSIS:   paints the LBI


    HISTORY:
        Thomaspa    4-Apr-1992     Created
        beng        24-Apr-1992    Change to LBI::Paint

********************************************************************/

VOID ACCOUNTS_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                          GUILTT_INFO * pGUILTT ) const
{
    // BUGBUG Fix this
    ((ACCOUNTS_LB*)plb)->QueryColWidthArray()[ 0 ] = COL_WIDTH_WIDE_DM;
    ((ACCOUNTS_LB*)plb)->QueryColWidthArray()[ 1 ] = COL_WIDTH_GROUP_NAME;

    STR_DTE strdteName( _nlsDisplayName ) ;
    DM_DTE  dmdteIcon( ((ACCOUNTS_LB*)plb)->QueryDisplayMap( this ) ) ;

    DISPLAY_TABLE dt( 2, ((ACCOUNTS_LB*)plb)->QueryColWidthArray()) ;
    dt[0] = &dmdteIcon ;
    dt[1] = &strdteName ;

    dt.Paint( plb, hdc, prect, pGUILTT ) ;
}


/*******************************************************************

    NAME:       ACCOUNTS_LBI::Compare

    SYNOPSIS:   Compare two ACCOUNTS_LBIs

    HISTORY:
        Thomaspa        4-Apr-1992     Created

********************************************************************/

INT ACCOUNTS_LBI::Compare( const LBI * plbi ) const
{
    ACCOUNTS_LBI * paccountsLBI = (ACCOUNTS_LBI*) plbi ;

    /* Non-User LBIs are always greater then User LBIs
     */
    INT i = _nlsDisplayName._stricmp( paccountsLBI->_nlsDisplayName );
    if ( i == 0 )
    {
        if ( (QueryType() != SidTypeUser) &&
             (paccountsLBI->QueryType() == SidTypeUser ))
        {
            i = -1 ;
        }

        if ( (QueryType() == SidTypeUser) &&
             (paccountsLBI->QueryType() != SidTypeUser ))
        {
            i = 1 ;
        }
    }

    return i;
}


/**********************************************************************

    NAME:       ACCOUNTS_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Determine whether this listbox item starts with the
                string provided

    HISTORY:
        jonn        17-Aug-1992 HAW-for-Hawaii code

**********************************************************************/

INT ACCOUNTS_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    ISTR istr( nls );
    UINT cchIn = nls.QueryTextLength();
    istr += cchIn;

//    TRACEEOL(   SZ("User Manager: ACCOUNT_LBI::Compare_HAWforHawaii(): \"")
//             << nls
//             << SZ("\", \"")
//             << _nlsDisplayName
//             << SZ("\", ")
//             << cchIn
//             );
    return nls._strnicmp( _nlsDisplayName, istr );

} // ACCOUNTS_LBI::Compare_HAWforHawaii


/*******************************************************************

    NAME:       ACCOUNTS_LBI::QueryLeadingChar()

    SYNOPSIS:   H-for-Hawaii support

    HISTORY:
        Thomaspa        4-Apr-1992     Created

********************************************************************/

WCHAR ACCOUNTS_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsDisplayName ) ;
    return _nlsDisplayName.QueryChar( istr ) ;
}


/*******************************************************************

    NAME:       ACCOUNTS_LB::ACCOUNTS_LB

    SYNOPSIS:   Constructor

    ENTRY:      powin - parent window
                cid - Control ID for LB

    HISTORY:
        Thomaspa        4-Apr-1992     Created
        JonN            17-Aug-1992    HAW-for-Hawaii in listbox

********************************************************************/

ACCOUNTS_LB::ACCOUNTS_LB( OWNER_WINDOW * powin,
                          CID cid,
                          const SUBJECT_BITMAP_BLOCK & bmpblock )
    : BLT_LISTBOX_HAW( powin, cid ),
      _bmpblock( bmpblock )
{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( QueryColWidthArray(),
                                                 2,
                                                 powin,
                                                 QueryCid(),
                                                 TRUE ))             )
    {
        ReportError( err ) ;
        return ;
    }
}


/*******************************************************************

    NAME:       ACCOUNTS_LB::~ACCOUNTS_LB

    SYNOPSIS:   destructor

    HISTORY:
        Thomaspa        4-Apr-1992     Created

********************************************************************/

ACCOUNTS_LB::~ACCOUNTS_LB()
{
    // ...
}


/*******************************************************************

    NAME:       ACCOUNTS_LB::QueryDisplayMap

    SYNOPSIS:   Returns the DISPLAY_MAP for the given LBI

    ENTRY:      plbi - pointer to LBI whose display map is desired

    NOTES:

    HISTORY:
        Thomaspa        4-Apr-1992  Created
        beng            08-Jun-1992 Differentiate remote users

********************************************************************/

DISPLAY_MAP * ACCOUNTS_LB::QueryDisplayMap( const ACCOUNTS_LBI * plbi )
{
    UIASSERT( plbi != NULL ) ;

    return ((SUBJECT_BITMAP_BLOCK &)_bmpblock).QueryDisplayMap(
                                      plbi->QueryType(),
                                      UI_SID_Invalid,
                                      plbi->IsRemoteUser() );
}


/*******************************************************************

    NAME:       SEARCH_LISTBOX_LOCK::SEARCH_LISTBOX_LOCK

    SYNOPSIS:   Make and lock the user listbox for searches

    ENTRY:      pdlg - Host dialog ("this" within ALIASPROP or child)

    EXIT:       Side effects _cLocks and _ulsoSave within dialog.

    NOTES:
        See ALIASPROP_DLG::IsRemoteUser.

        This class should be local to ALIASPROP_DLG.

        CODEWORK - Fix the dialog classes to keep a NON-const
        pointer to the user listbox.

        CODEWORK - See performance notes in IsRemoteUser

    HISTORY:
        beng        08-Jun-1992 Created

********************************************************************/

SEARCH_LISTBOX_LOCK::SEARCH_LISTBOX_LOCK( ALIASPROP_DLG * pdlgOwner )
    : _pdlgOwner(pdlgOwner)
{
    if ((pdlgOwner->_cLocks)++ > 0) // Lock(s) already outstanding
        return;

    USER_LISTBOX_SORTORDER ulsoTmp = pdlgOwner->_pulb->QuerySortOrder();
    LAZY_USER_LISTBOX * pulb = (LAZY_USER_LISTBOX*)pdlgOwner->_pulb; // lose the const

    // Put into sort-on-account-name sequence for searches.

    pulb->SetRedraw(FALSE);
    APIERR err = pulb->SetSortOrder( ULB_SO_LOGONNAME, TRUE );
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    // Remember original sort order for when we're finished

    pdlgOwner->_ulsoSave = ulsoTmp;
}


/*******************************************************************

    NAME:       SEARCH_LISTBOX_LOCK::~SEARCH_LISTBOX_LOCK

    SYNOPSIS:   Release the lock on the user listbox

    EXIT:       Side effects _cLocks within dialog.

    NOTES:
        See ALIASPROP_DLG::IsRemoteUser.

    HISTORY:
        beng        08-Jun-1992 Created

********************************************************************/

SEARCH_LISTBOX_LOCK::~SEARCH_LISTBOX_LOCK()
{
    if (--(_pdlgOwner->_cLocks) > 0) // Locks(s) still outstanding
        return;

    // Restore original sort order, resorting, and re-enable redraw
    // within the listbox.  Shouldn't need to invalidate the control,
    // since nothing should have changed in the round trip.

    LAZY_USER_LISTBOX * pulb = (LAZY_USER_LISTBOX*)_pdlgOwner->_pulb; // lose the const
    pulb->SetSortOrder( _pdlgOwner->_ulsoSave, TRUE );
    pulb->SetRedraw(TRUE);
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::ALIASPROP_DLG

    SYNOPSIS:   Constructor for Alias Properties main dialog, base class

    ENTRY:      powin   -   pointer to OWNER_WINDOW

                pulb    -   pointer to main window LAZY_USER_LISTBOX

                loc     -   reference to current LOCATION

                psel    -   pointer to ADMIN_SELECTION; currently only
                            one Alias can be selected.  "New alias"
                            variants pass NULL.

    NOTES:      psel is required to be NULL for NEW variants,
                non-NULL otherwise.

    HISTORY:
        Thomaspa        17-Mar-1992 Templated from grpprop.cxx
        beng            08-Jun-1992 Differentiate remote users

********************************************************************/

ALIASPROP_DLG::ALIASPROP_DLG( const OWNER_WINDOW    * powin,
	                      const UM_ADMIN_APP *    pumadminapp,
                              const LAZY_USER_LISTBOX    * pulb,
                              const LOCATION        & loc,
                              const ADMIN_SELECTION * psel )
    : PROP_DLG( loc, MAKEINTRESOURCE(IDD_ALIAS), powin, (psel == NULL) ),
    _apsamalias( NULL ),
    _nlsComment( ),
    _sleComment( this, IDAL_ET_COMMENT, MAXCOMMENTSZ ),
    _pulb( pulb ),
    _sleAliasName( this, IDAL_ET_ALIAS_NAME, GNLEN ),
    _sltAliasName( this, IDAL_ST_ALIAS_NAME ),
    _sltAliasNameLabel( this, IDAL_ST_ALIAS_NAME_LABEL ),
    _lbMembers( this, IDAL_LB, pumadminapp->QueryBitmapBlock() ),
    _pushbuttonFullNames( this, IDAL_SHOWFULLNAMES ),
    _pushbuttonRemove( this, IDAL_REMOVE ),
    _pushbuttonAdd( this, IDAL_ADD ),
    _pushbuttonOK( this, IDOK ),
    _slRemovedAccounts(),
    _fShowFullNames( FALSE ),
    _cLocks(0),
    _pumadminapp( pumadminapp )
{
    if ( QueryError() != NERR_Success )
        return;

    // We leave the array mechanism in place in case we ever decide
    // to support alias multiselection, and to remain consistent with
    // USERPROP_DLG.

    _apsamalias = new SAM_ALIAS *[ 1 ];
    if( _apsamalias == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }
    _apsamalias[ 0 ] = NULL;

    APIERR err;
    if ( (err = _nlsComment.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::~ALIASPROP_DLG

    SYNOPSIS:   Destructor for Alias Properties main dialog, base class

    HISTORY:
        Thomaspa        17-Mar-1992     Templated from grpprop.cxx

********************************************************************/

ALIASPROP_DLG::~ALIASPROP_DLG()
{
    if ( _apsamalias != NULL )
    {
        // CODEWORK: This does not support multi-select
        delete _apsamalias[0];
	delete _apsamalias;
        _apsamalias = NULL;
    }
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::InitControls


    SYNOPSIS:   Initializes the controls maintained by ALIASPROP_DLG,
                according to the values in the class data members.

    RETURNS:    error code.

    NOTES:      we don't use any intermediate list of users, we move
                users directly between the dialog and the LMOBJ.

    CODEWORK  Should this be called W_MembersToDialog?  This would fit
    in with the general naming scheme.

    HISTORY:
         Thomaspa  17-Mar-1992    Templated from grpprop.cxx
         JonN      02-Jun-1992    NEW initial focus on alias name

********************************************************************/

APIERR ALIASPROP_DLG::InitControls()
{
    ASSERT( _nlsComment.QueryError() == NERR_Success );
    _sleComment.SetText( _nlsComment );

    BOOL fNewVariant = IsNewVariant();
    if ( fNewVariant )
    {
        RESOURCE_STR res( IDS_ALSPROP_NEW_ALIAS_DLG_NAME );
        RESOURCE_STR res2( IDS_ALSPROP_ALIAS_NAME_LABEL );
        APIERR err = res.QueryError();
        if(     err != NERR_Success
            || (err = res2.QueryError()) != NERR_Success )
            return err;

        SetText( res );
        _sltAliasNameLabel.SetText( res2 );
    }

    _sltAliasName.Show( !fNewVariant );
    _sleAliasName.Show( fNewVariant );

    //  the listbox is already filled and now the first line is
    //  brought to 'visible'
    if( _lbMembers.QueryCount() > 0 )
        _lbMembers.SelectItem( 0, TRUE );
    _lbMembers.RemoveSelection();

    _pushbuttonRemove.Enable( FALSE );

    if ( fNewVariant )
    {
        SetDialogFocus( _sleAliasName );
    }
    else
    {
        SetDialogFocus( _pushbuttonAdd );
    }

    return PROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:   Loads class data members from initial data

    ENTRY:      Index of alias to examine.  W_LMOBJToMembers expects to be
                called once for each alias, starting from index 0.

    RETURNS:    error code

    NOTES:      This API takes a UINT rather than a SAM_ALIAS * because it
                must be able to recognize the first alias.

                We don't use any intermediate list of users, we move
                users directly between the dialog and the LMOBJ.

    HISTORY:
        JonN  09-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR ALIASPROP_DLG::W_LMOBJtoMembers( UINT iObject )
{
    UIASSERT( iObject == 0 );
    SAM_ALIAS * psamalias = QueryAliasPtr( iObject );

    APIERR err = NERR_Success;

    // If psamalias is NULL, this must be a new alias, so skip getting
    // the comment.
    if ( psamalias != NULL )
        err = psamalias->GetComment( &_nlsComment );

    return err;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::W_PerformOne

    SYNOPSIS:   Saves information on one alias

    ENTRY:      iObject is the index of the object to save

                perrMsg is set by subclasses

                pfWorkWasDone indicates whether any UAS changes were
                successfully written out.  This may return TRUE even if
                the PerformOne action as a whole failed (i.e. PerformOne
                returned other than NERR_Success).

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
        Thomaspa        30-Mar-1992     Created

********************************************************************/

APIERR ALIASPROP_DLG::W_PerformOne(
        UINT            iObject,
        APIERR *        perrMsg,
        BOOL *          pfWorkWasDone
        )
{
    UNREFERENCED( perrMsg ); //is set by subclasses
    UIASSERT( iObject < QueryObjectCount() );

    TRACEEOL("ALIASPROP_DLG::W_PerformOne : " << QueryObjectName(iObject) );

    // Set the comment
    APIERR err = QueryAliasPtr( iObject )->SetComment( &_nlsComment );

    if( err != NERR_Success )
        return err;

    //
    // We set *pfWorkWasDone to TRUE since the comment might have changed
    //

    *pfWorkWasDone = TRUE;

    //
    // first remove members
    //

    UINT cRemovedAccounts = _slRemovedAccounts.QueryNumElem();
    if ( !IsNewVariant() && cRemovedAccounts > 0 )
    {
        // create array of PSIDs to delete

        BUFFER bufRemovedAccounts( cRemovedAccounts * sizeof(PSID) );
        if ( (err = bufRemovedAccounts.QueryError()) != NERR_Success )
        {
            DBGEOL("ALIASPROP_DLG::W_PerformOne : buffer alloc error " << err );
            return err;
        }

        // Walk through the removed slist.

        ITER_SL_OF( OS_SID ) iterRemovedAccounts( _slRemovedAccounts );
        OS_SID * possid = NULL;
        UINT i = 0;
        PSID * apsidRemovedAccounts = (PSID *)bufRemovedAccounts.QueryPtr();
        UIASSERT( apsidRemovedAccounts != NULL );
        while ( ( possid = iterRemovedAccounts.Next() ) != NULL )
        {
            if ( i >= cRemovedAccounts )
            {
                UIASSERT( FALSE );
                return err;
            }
            apsidRemovedAccounts[i++] = possid->QueryPSID();
        }
        UIASSERT( i == cRemovedAccounts );

        err = QueryAliasPtr(iObject)->RemoveMembers( apsidRemovedAccounts,
                                                     cRemovedAccounts );
        if (err != NERR_Success)
        {
            DBGEOL("ALIASPROP_DLG::W_PerformOne : error removing accounts " << err );
            return err;
        }
    }

    _slRemovedAccounts.Clear();

    //
    // Now add members
    //

    INT nCount = _lbMembers.QueryCount();
    UINT cAddedAccounts = 0;
    for( INT i = 0; i < nCount; i++ )
    {
        ACCOUNTS_LBI * pacclbi = _lbMembers.QueryItem( i );
        UIASSERT( pacclbi != NULL );
        if ( ! pacclbi->IsMemberAlready() )
            cAddedAccounts++;
    }
    if ( cAddedAccounts > 0 )
    {
        BUFFER bufAddedAccounts( cAddedAccounts * sizeof(PSID) );
        if ( (err = bufAddedAccounts.QueryError()) != NERR_Success )
        {
            DBGEOL("ALIASPROP_DLG::W_PerformOne : buffer alloc error " << err );
            return err;
        }

        PSID * apsidAddedAccounts = (PSID *)bufAddedAccounts.QueryPtr();
        UIASSERT( apsidAddedAccounts != NULL );
        UINT iAddedAccount = 0;
        for( INT i = 0; i < nCount; i++ )
        {
            ACCOUNTS_LBI * pacclbi = _lbMembers.QueryItem( i );
            UIASSERT( pacclbi != NULL );
            if ( ! pacclbi->IsMemberAlready() )
            {
                if ( iAddedAccount >= cAddedAccounts )
                {
                    UIASSERT( FALSE );
                    return err;
                }
                apsidAddedAccounts[iAddedAccount++] = pacclbi->QueryPSID();
            }
        }
        UIASSERT( iAddedAccount == cAddedAccounts );

        err = QueryAliasPtr( iObject )->AddMembers( apsidAddedAccounts,
                                                    cAddedAccounts );
        if (err != NERR_Success)
        {
            DBGEOL("ALIASPROP_DLG::W_PerformOne : error adding accounts " << err );
            return err;
        }
    }

    TRACEEOL("ALIASPROP_DLG::W_PerformOne returns " << err );

    return err;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::W_DialogToMembers

    SYNOPSIS:   Loads data from dialog into class data members

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
        Thomaspa  30-Mar-1992    Created

********************************************************************/

APIERR ALIASPROP_DLG::W_DialogToMembers()
{
    APIERR err = NERR_Success;
    if (   ((err = _sleComment.QueryText( &_nlsComment )) != NERR_Success)
        || ((err = _nlsComment.QueryError()) != NERR_Success ) )
    {
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::IsRemoteUser

    SYNOPSIS:   Determine whether a user is remote or not

    ENTRY:      nlsAccount - account name to check

    RETURNS:    TRUE if named user is remote

    NOTES:
        This function diddles (may diddle) the main user listbox
        in order to make it searchable on the account name.  If it is to
        be called repeatedly, the caller should create a SEARCH_LISTBOX_LOCK
        object itself to avoid repeated redundant diddling.

    HISTORY:
        beng        08-Jun-1992 Created

********************************************************************/

BOOL ALIASPROP_DLG::IsRemoteUser( const NLS_STR & nlsAccount )
{
    // CODEWORK for performance:
    // If the nlsAccount contains a backslash, then we know it can't
    // be a "remote user" (proxy account), since proxy accounts always
    // appear as local.
    //
    // The listbox lock could sort the listbox by PSID instead of
    // by account name, in the interests of speedy sort and speedy
    // lookup.  (IsRemoteUser would have to take a PSID then, too.)
    // Would involve changes to LAZY_USER_LISTBOX to add the new sort
    // order.
    //

    if (!nlsAccount)
    {
        DBGEOL("USRMGR - IsRemoteUser given bad arg, err "
                << nlsAccount.QueryError());
        return FALSE;
    }

    SEARCH_LISTBOX_LOCK lock(this);
    if (!lock)
    {
        DBGEOL("USRMGR - failed to lock listbox, err " << lock.QueryError());
        return FALSE;
    }

    USER_LBI lbiFake(nlsAccount, NULL, NULL, _pulb, 0, MAINUSRLB_REMOTE);
    if (!lbiFake)
    {
        DBGEOL("USRMGR - failed to ct fake lbi, err "
               << lbiFake.QueryError());
        return FALSE;
    }

    //
    // In RAS mode, this listbox is empty, and we are unable to
    // distinguish remote users from local users.
    // This might in theiry allow us to add the same user twice, once
    // as global, once as local.  However, since the Add dialog never
    // adds local user accounts, the point is moot.
    //
    INT ilbi = _pulb->FindItem(lbiFake);
    if (ilbi < 0)
        return FALSE;

    USER_LBI * plbiReal = (USER_LBI*) (_pulb->QueryItem(ilbi));

    return (plbiReal->QueryIndex() == MAINUSRLB_REMOTE);
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::OnCommand

    SYNOPSIS:   Checks control notifications and dispatches to
                appropriate method

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    HISTORY:
        thomaspa        02-Apr-1992     Created

********************************************************************/

BOOL ALIASPROP_DLG::OnCommand( const CONTROL_EVENT & ce )
{
    switch ( ce.QueryCid() )
    {
    case IDAL_ADD:
        return OnAdd();
    case IDAL_REMOVE:
        return OnRemove();
    case IDAL_SHOWFULLNAMES:
        return OnShowFullnames();
    case IDAL_LB:
        if ( ce.QueryCode() == LBN_SELCHANGE )
	{
	    _pushbuttonRemove.Enable( _lbMembers.QuerySelCount() > 0 );
        }

    default:
        break;
    }

    return PROP_DLG::OnCommand( ce ) ;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::OnOK

    SYNOPSIS:   OK button handler.  This handler applies to all variants
                including EDIT_ and NEW_.

    EXIT:       Dismiss() return code indicates whether the dialog wrote
                any changes successfully to the API at any time.

    HISTORY:
        Thomaspa  30-Mar-1992    Templated from grpprop.cxx

********************************************************************/

BOOL ALIASPROP_DLG::OnOK()
{
TRACETIMESTART;
    APIERR err = W_DialogToMembers();
    if ( err != NERR_Success )
    {
        MsgPopup( this, err );
        return TRUE;
    }

    if ( PerformSeries() )
        Dismiss( QueryWorkWasDone() );

TRACETIMEEND( "ALIASPROP_DLG::OnOK(): total time " );
    return TRUE;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::OnAdd

    SYNOPSIS:   Add button handler.  This handler applies to all variants
                including EDIT_ and NEW_.

    EXIT:       Dismiss() return code indicates whether the dialog wrote
                any changes successfully to the API at any time.

    HISTORY:
        Thomaspa    30-Mar-1992 Created
        beng        08-Jun-1992 Differentiate remote users

********************************************************************/

BOOL ALIASPROP_DLG::OnAdd()
{
    NT_USER_BROWSER_DIALOG * pdlgUserBrows = new NT_USER_BROWSER_DIALOG(
                        USRBROWS_DIALOG_NAME,
                        QueryRobustHwnd(),
                        QueryLocation().QueryServer(),
                        HC_UM_ADD_ALIASMEMBERS,
                        USRBROWS_SHOW_USERS | USRBROWS_SHOW_GROUPS
                        | USRBROWS_EXPAND_USERS,
			BLT::CalcHelpFileHC( HC_UM_ADD_ALIASMEMBERS ),
			0,
			0,
			0,
			(QueryTargetServerType() == UM_LANMANNT) ?
			    QueryAdminAuthority() :
			    NULL );

    if ( pdlgUserBrows == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    APIERR err = NERR_Success;

    //
    // OnAdd will be calling OnRemoteUser repeatedly.  We only want to have
    // to resort the listbox once.
    //
    SEARCH_LISTBOX_LOCK * plock = NULL;

    do // error breakout loop
    {
	BOOL fUserPressedOk;
        if (   (err = pdlgUserBrows->QueryError()) != NERR_Success
            || (err = pdlgUserBrows->Process( &fUserPressedOk )) != NERR_Success
	    || !fUserPressedOk )
        {
            break;
        }

        // In order to display usernames properly, needs to know the
        // current domain of focus (so that it can elide the domain prefix
        // on "local" usernames).

        NLS_STR nlsDomainOfApp;
        if (QueryLocation().IsDomain())
        {
            nlsDomainOfApp = QueryLocation().QueryDomain();
        }
        else if (   QueryLocation().QueryServer() == NULL
                 || *(QueryLocation().QueryServer()) == TCH('\0') )
        {
            TRACEEOL( "ALIASPROP_DLG::OnAdd(): calling GetComputerName" );

            TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
            DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

            if (   (err = (::GetComputerName( szComputerName, &cchBuffer )
                            ? NERR_Success
                            : ::GetLastError()) ) != NERR_Success
                || (err = nlsDomainOfApp.CopyFrom( szComputerName )) != NERR_Success
               )
            {
                DBGEOL( "ALIASPROP_DLG::OnAdd(): GetComputerName failed " << err );
                break;
            }
        }
        else
        {

            nlsDomainOfApp = QueryLocation().QueryServer();

        }
        TRACEEOL("App focused on domain " << nlsDomainOfApp);


        BROWSER_SUBJECT_ITER iterUserSelection( pdlgUserBrows );
        BROWSER_SUBJECT * pBrowserSubject;

        if ((err = iterUserSelection.QueryError()) != NERR_Success)
            break;

        BOOL fChangedFocus = FALSE;

        while ( !(err = iterUserSelection.Next( &pBrowserSubject )) &&
            pBrowserSubject != NULL )
        {
            OS_SID ossid( pBrowserSubject->QuerySid()->QuerySid() );
            if ((err = ossid.QueryError()) != NERR_Success)
                break;

            BOOL fIsMemberAlready = FALSE;

            // First check to see if it is in the RemovedList;
            if ( _slRemovedAccounts.IsMember( ossid ) )
            {
                delete _slRemovedAccounts.Remove( ossid );
                fIsMemberAlready = TRUE;
            }

            NLS_STR nlsDisplayName;
            BOOL fRemoteUser = FALSE;

            // Build an appropriately decorated name for display
            // in the listbox

            err = pBrowserSubject->QueryQualifiedName(
                            &nlsDisplayName,
                            &nlsDomainOfApp,
                            (pBrowserSubject->QueryType() == SidTypeUser)
				? _fShowFullNames : FALSE );

                if (err != NERR_Success) // will pick up all errors
                    break;

            if (pBrowserSubject->QueryType() == SidTypeUser)
            {
                // Determine if it is a remote user

                NLS_STR nlsAccountName = pBrowserSubject->QueryAccountName();
                if ((err = nlsAccountName.QueryError()) != NERR_Success)
                    break;

                // create SEARCH_LISTBOX_LOCK if needed
                if ( plock == NULL )
                {
                    plock = new SEARCH_LISTBOX_LOCK(this);
                    err = ERROR_NOT_ENOUGH_MEMORY;
                    if (   plock == NULL
                        || (err = plock->QueryError()) != NERR_Success )
                    {
                        TRACEEOL( "ALIASPROP_DLG::OnAdd lock error " << err );
                        break;
                    }
                }
                fRemoteUser = IsRemoteUser(nlsAccountName);
            }

            // Assume it is not already in the listbox
            ACCOUNTS_LBI * pacclbi =
                new ACCOUNTS_LBI(nlsDisplayName,
                                 pBrowserSubject->QuerySid()->QuerySid(),
                                 pBrowserSubject->QueryType(),
                                 fIsMemberAlready,
                                 fRemoteUser );

            // no need for error checking, AddItem does it
            if ( _lbMembers.AddItemIdemp( pacclbi ) < 0 )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (!fChangedFocus)
            {
                SetDialogFocus( _pushbuttonOK );
                Invalidate( TRUE );
                fChangedFocus = TRUE;
            }
        }

    } while ( FALSE ) ; // error breakout loop

    if ( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

    delete plock;
    delete pdlgUserBrows;

    return TRUE;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::OnRemove

    SYNOPSIS:   Remove button handler.  This handler applies to all variants
                including EDIT_ and NEW_.

    EXIT:       Dismiss() return code indicates whether the dialog wrote
                any changes successfully to the API at any time.

    HISTORY:
        Thomaspa  30-Mar-1992    Created

********************************************************************/

BOOL ALIASPROP_DLG::OnRemove()
{
    APIERR err = NERR_Success;

    INT cSelections = _lbMembers.QuerySelCount();

    BUFFER buffLBSel( cSelections * sizeof( INT ) );

    if ( (err = buffLBSel.QueryError()) != NERR_Success )
    {
        MsgPopup( this, err );
        return FALSE;
    }

    INT * piSelections = (INT *) buffLBSel.QueryPtr();

    if ( (err = _lbMembers.QuerySelItems( piSelections, cSelections ))
                != NERR_Success )
    {
        MsgPopup( this, err );
        return TRUE;
    }


    for ( INT i = cSelections - 1; i >= 0; i-- )
    {
        ACCOUNTS_LBI * plbi = _lbMembers.QueryItem( piSelections[i] );

        if ( plbi != NULL )
        {
            OS_SID * possid = new OS_SID(plbi->QueryOSSID()->QuerySid(), TRUE);
            if ( possid == NULL || (err = possid->QueryError()) != NERR_Success)
            {
                MsgPopup( this, err );
                break;
            }
            if ( (err = _slRemovedAccounts.Add( possid )) != NERR_Success )
            {
                MsgPopup( this, err );
                break;
            }
            _lbMembers.DeleteItem( piSelections[i] );
        }
    }

    return TRUE;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::OnShowFullnames

    SYNOPSIS:   Show Fullnames button handler.  This handler applies to all
                variants including EDIT_ and NEW_.

    EXIT:       Dismiss() return code indicates whether the dialog wrote
                any changes successfully to the API at any time.

    HISTORY:
        Thomaspa  30-Mar-1992    Created

********************************************************************/

BOOL ALIASPROP_DLG::OnShowFullnames()
{
    INT i;

    AUTO_CURSOR autocur;

    PSID * apsid = new PSID[ _lbMembers.QueryCount() ];
    if ( apsid == NULL )
    {
        ::MsgPopup( this, ERROR_NOT_ENOUGH_MEMORY );
        return TRUE;
    }

    SID_NAME_USE * asidtype = new SID_NAME_USE[ _lbMembers.QueryCount() ];
    if ( asidtype == NULL )
    {
	delete apsid;
        ::MsgPopup( this, ERROR_NOT_ENOUGH_MEMORY );
	return TRUE;
    }

    _fShowFullNames = TRUE;

    //
    //  This action can only be done once, so disable the Show Fullnames
    //  button.  Before doing this, move focus to another control,
    //  otherwise focus is lost and cannot be restored without using
    //  the mouse.
    //
    //  This previously used Command(WM_NEXTDLGCTL, 0, FALSE), but this
    //  would move focus to the exact wrong control if you use the
    //  keyboard accelerator.  We now use the TRUE variant to force
    //  focus to the OK button.   JonN 1/25/95
    SetDialogFocus( _pushbuttonOK );
    _pushbuttonFullNames.Enable( FALSE );

    if ( _lbMembers.QueryCount() == 0 )
    {
	delete apsid;
	delete asidtype;
	return TRUE;
    }

    for ( i = 0; i < _lbMembers.QueryCount(); i++ )
    {
        apsid[i] = _lbMembers.QueryItem( i )->QueryPSID();
	asidtype[i] = _lbMembers.QueryItem( i )->QueryType();
    }

    STRLIST strlistQualifiedNames;

    //
    // CODEWORK:  We must provide the server name here so that we can look
    // up names on the focus domain (when focus is on a domain).  This
    // parameter really shouldn't be optional.
    //
    APIERR err;
    if ( (err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                *QueryAdminAuthority()->QueryLSAPolicy(),
                                *QueryAdminAuthority()->QueryAccountDomain(),
                                apsid,
                                _lbMembers.QueryCount(),
                                TRUE,
                                &strlistQualifiedNames,
			        NULL,
			        asidtype,
                                NULL,
                                QueryAdminAuthority()->QueryServer()
                                        )) != NERR_Success )
    {
        delete apsid;
        delete asidtype;
        ::MsgPopup( this, err );
        return TRUE;
    }

    ITER_STRLIST istr( strlistQualifiedNames );

    NLS_STR *pnls;
    i = 0;
    while( (pnls = istr.Next()) != NULL )
    {
        _lbMembers.QueryItem( i )->SetDisplayName( pnls->QueryPch() );
	_lbMembers.QueryItem( i )->SetType( asidtype[ i ] );
        _lbMembers.InvalidateItem( i );
        i++;
    }

    delete apsid;
    delete asidtype;
    return TRUE;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::QueryObjectCount

    SYNOPSIS:   Returns the number of selected aliases, always 1 at present

    HISTORY:
        Thomaspa  30-Mar-1992    Templated from grpprop.cxx

********************************************************************/

UINT ALIASPROP_DLG::QueryObjectCount() const
{
    return 1;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::QueryAliasPtr

    SYNOPSIS:   Accessor to the SAM_ALIAS arrays, for use by subdialogs

    HISTORY:
        Thomaspa        30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

SAM_ALIAS * ALIASPROP_DLG::QueryAliasPtr( UINT iObject ) const
{
    ASSERT( _apsamalias != NULL );
    ASSERT( iObject == 0 );
    return _apsamalias[ iObject ];
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::SetAliasPtr

    SYNOPSIS:   Accessor to the SAM_ALIAS arrays, for use by subdialogs

    HISTORY:
        Thomaspa        30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

VOID ALIASPROP_DLG::SetAliasPtr( UINT iObject, SAM_ALIAS * psamaliasNew )
{
    ASSERT( _apsamalias != NULL );
    ASSERT( iObject == 0 );
    ASSERT( (psamaliasNew == NULL) || (psamaliasNew != _apsamalias[iObject]) );
    delete _apsamalias[ iObject ];
    _apsamalias[ iObject ] = psamaliasNew;
}


/*******************************************************************

    NAME:       ALIASPROP_DLG::AddAccountsToMembersLb

    SYNOPSIS:   adds members of alias pointed to by the alias
                pointer to the members listbox

    ENTRY:      fIsNewAlias - if TRUE, this is a new alias whose
                        membership is being copied from an existing alias
                              if FALSE, we are editing an existing alias

    RETURNS:    error code

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx
        beng        08-Jun-1992     Differentiate remote users

********************************************************************/

APIERR ALIASPROP_DLG::AddAccountsToMembersLb( BOOL fIsNewAlias )
{
    SAM_ALIAS * psamAlias = QueryAliasPtr( 0 );
    SAM_SID_MEM samsm;

    APIERR err = psamAlias->GetMembers( &samsm );
    if ( err != NERR_Success )
        return err;

    if ( samsm.QueryCount() > 0 )
    {
        // Lock the listbox of users for efficient multiple lookups
        // when differentiating remote user accounts.

        SEARCH_LISTBOX_LOCK Lock(this);

        // Translate Sids to names
        LSA_POLICY * plsapol = QueryAdminAuthority()->QueryLSAPolicy();

        LSA_TRANSLATED_NAME_MEM lsatnm;
        LSA_REF_DOMAIN_MEM lsardm;

        err = plsapol->TranslateSidsToNames( samsm.QueryPtr(),
                                             samsm.QueryCount(),
                                             &lsatnm,
                                             &lsardm );
        if ( err != NERR_Success )
            return err;

        PSID psidAccountDomain
                = QueryAdminAuthority()->QueryAccountDomain()->QueryPSID();

        /*
         * Must filter the "(None)" group for Mini User manager
         */
        OS_SID ossidNoneGroup( psidAccountDomain,
                               (ULONG) DOMAIN_GROUP_RID_USERS );
        if ( (err = ossidNoneGroup.QueryError()) != NERR_Success )
        {
            return err;
        }

        for( INT i = 0; i < (INT)lsatnm.QueryCount(); i++ )
        {
            NLS_STR nlsAccountName;
            NLS_STR nlsDomainName; // starts out init'd to empty
            NLS_STR nlsQualifiedName;

            if ( (err = nlsAccountName.QueryError()) != NERR_Success ||
                (err = nlsDomainName.QueryError()) != NERR_Success ||
                (err = nlsQualifiedName.QueryError()) != NERR_Success ||
                (err = lsatnm.QueryName( i, &nlsAccountName )) != NERR_Success)
            {
                return err;
            }

            LONG nDomIndex;
            if ((nDomIndex = lsatnm.QueryDomainIndex(i)) != LSA_UNKNOWN_INDEX)
            {
                /*
                 * On Mini User Manager, filter the "(None)" group
                 */
                if ( fMiniUserManager )
                {
                    OS_SID ossid( samsm.QueryPSID(i) );
                    if ( (err = ossid.QueryError()) != NERR_Success )
                    {
                        return err;
                    }

                    if ( ossid == ossidNoneGroup )
                    {
                        // Filter None Group
                        continue;
                    }
                }

                if ( (err = lsardm.QueryName(nDomIndex,
                                             &nlsDomainName)) != NERR_Success )
                {
                    return err;
                }
            }

            // Silently remove Deleted accounts
            if ( lsatnm.QueryUse(i) == SidTypeDeletedAccount )
	    {
		psamAlias->RemoveMember( samsm.QueryPSID(i) );
		continue;
	    }


            if ( (err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                &nlsQualifiedName,
                                nlsAccountName,
                                psidAccountDomain,
                                nlsDomainName,
                                NULL,
                                nDomIndex == LSA_UNKNOWN_INDEX
                                    ? NULL
                                    : lsardm.QueryPSID(nDomIndex),
				lsatnm.QueryUse(i)))
                        != NERR_Success )
            {
                return err;
            }

            BOOL fRemoteUser = (lsatnm.QueryUse(i) == SidTypeUser)
                                && IsRemoteUser(nlsAccountName);

            ACCOUNTS_LBI * pacclbi
                = new ACCOUNTS_LBI( nlsQualifiedName,
                                    samsm.QueryPSID(i),
                                    lsatnm.QueryUse(i),
                                    !fIsNewAlias,
                                    fRemoteUser );

            //  no need for error checking, AddItem does it
            if ( _lbMembers.AddItem( pacclbi ) < 0 )
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }
    return NERR_Success;
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::EDIT_ALIASPROP_DLG

    SYNOPSIS:   constructor for Alias Properties main dialog, edit
                alias variant

    ENTRY:      powin   -   pointer to OWNER_WINDOW

                pulb    -   pointer to main window LAZY_USER_LISTBOX

                loc     -   reference to current LOCATION

                psel    -   pointer to ADMIN_SELECTION, currently only
                            one alias can be selected

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

EDIT_ALIASPROP_DLG::EDIT_ALIASPROP_DLG(
        const OWNER_WINDOW * powin,
	const UM_ADMIN_APP * pumadminapp,
        const LAZY_USER_LISTBOX * pulb,
        const LOCATION & loc,
        const ADMIN_SELECTION * psel
        ) : ALIASPROP_DLG(
                powin,
                pumadminapp,
                pulb,
                loc,
                psel
                ),
            _psel( psel )
{
    ASSERT( QueryObjectCount() == 1 );

    if ( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::~EDIT_ALIASPROP_DLG

    SYNOPSIS:   destructor for Alias Properties main dialog, edit
                alias variant

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

EDIT_ALIASPROP_DLG::~EDIT_ALIASPROP_DLG()
{
    // ...
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::GetOne

    SYNOPSIS:   Loads information on one alias

    ENTRY:      iObject is the index of the object to load

                perrMsg returns the error message to be displayed if an
                error occurs, see PERFORMER::PerformSeries for details

    RETURNS:    error code

    NOTES:      This version of GetOne assumes that the alias already
                exists.  Classes which work with new alias will want
                to define their own GetOne.

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR EDIT_ALIASPROP_DLG::GetOne(
        UINT            iObject,
        APIERR *        perrMsg
        )
{
    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( perrMsg != NULL );

    *perrMsg = IDS_UMGetOneAliasFailure;


    SAM_ALIAS * psamaliasNew = new SAM_ALIAS(
                                IsBuiltinAlias( iObject ) ?
                                *(QueryAdminAuthority()->QueryBuiltinDomain()) :
                                *(QueryAdminAuthority()->QueryAccountDomain()),
                                QueryObjectRID( iObject ));

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if ( psamaliasNew == NULL ||
        (err = psamaliasNew->QueryError()) != NERR_Success )
    {
        delete psamaliasNew;
        return err;
    }


    SetAliasPtr( iObject, psamaliasNew ); // change and delete previous

    return W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::PerformOne

    SYNOPSIS:   Saves information on one alias

    ENTRY:      iObject is the index of the object to save

                perrMsg is the error message to be displayed if an
                error occurs, see PERFORMER::PerformSeries for details

                pfWorkWasDone indicates whether any SAM changes were
                successfully written out.  This may return TRUE even if
                the PerformOne action as a whole failed (i.e. PerformOne
                returned other than NERR_Success).

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR EDIT_ALIASPROP_DLG::PerformOne(
        UINT            iObject,
        APIERR *        perrMsg,
        BOOL *          pfWorkWasDone
        )
{
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    *perrMsg = IDS_UMEditAliasFailure;

    *pfWorkWasDone = FALSE;

    return W_PerformOne( iObject, perrMsg, pfWorkWasDone );
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::InitControls

    SYNOPSIS:   See ALIASPROP_DLG::InitControls().

    RETURNS:    error code

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR EDIT_ALIASPROP_DLG::InitControls()
{
    APIERR err;

    err = AddAccountsToMembersLb();

    if ( err != NERR_Success )
    {
        return err;
    }
    _sltAliasName.SetText( QueryObjectName( 0 ) );

    return ALIASPROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::QueryObjectName

    SYNOPSIS:   Returns the name of the selected alias.  This is meant for
                use with "edit alias" variants and should be redefined
                for "new alias" variants.

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

const TCHAR * EDIT_ALIASPROP_DLG::QueryObjectName( UINT iObject ) const
{
    UIASSERT( _psel != NULL );
    return _psel->QueryItemName( iObject );
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::QueryObjectRID

    SYNOPSIS:   Returns the RID of the selected alias.  This is meant for
                use with "edit alias" variants and should be redefined
                for "new alias" variants.

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

ULONG EDIT_ALIASPROP_DLG::QueryObjectRID( UINT iObject ) const
{
    UIASSERT( _psel != NULL );
    return ((ALIAS_LBI *)(_psel->QueryItem( iObject )))->QueryRID();
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::IsBuiltinAlias

    SYNOPSIS:   Returns TRUE if the selected alias is in the
                Builtin domain.

    HISTORY:
        Thomaspa    23-Apr-1992     created

********************************************************************/

BOOL EDIT_ALIASPROP_DLG::IsBuiltinAlias( UINT iObject ) const
{
    UIASSERT( _psel != NULL );
    return ((ALIAS_LBI *)(_psel->QueryItem( iObject )))->IsBuiltinAlias();
}


/*******************************************************************

    NAME:       EDIT_ALIASPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

ULONG EDIT_ALIASPROP_DLG::QueryHelpContext()
{
    return HC_UM_ALIASPROP_LANNT + QueryHelpOffset();
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::NEW_ALIASPROP_DLG

    SYNOPSIS:   Constructor for Alias Properties main dialog, new alias variant

    ENTRY:      powin   -   pointer to OWNER_WINDOW

                pulb    -   pointer to main window LAZY_USER_LISTBOX

                loc     -   reference to current LOCATION

                psel    -   pointer to ADMIN_SELECTION, currently only
                            one alias can be selected

                pridCopyFrom - The name of the alias to be copied.  Pass
                              the name for "Copy..." actions, or NULL for
                              "New..." actions

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

NEW_ALIASPROP_DLG::NEW_ALIASPROP_DLG( const OWNER_WINDOW * powin,
	                              const UM_ADMIN_APP * pumadminapp,
                                      const LAZY_USER_LISTBOX * pulb,
                                      const LOCATION & loc,
                                      const ULONG * pridCopyFrom,
                                      BOOL fCopyBuiltin )
    : ALIASPROP_DLG( powin, pumadminapp, pulb, loc, NULL ),
      _nlsAliasName(),
      _pridCopyFrom( pridCopyFrom ),
      _fCopyBuiltin( fCopyBuiltin )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsAliasName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::~NEW_ALIASPROP_DLG

    SYNOPSIS:   Destructor for Alias Properties main dialog, new alias variant

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

NEW_ALIASPROP_DLG::~NEW_ALIASPROP_DLG()
{
    // ...
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::GetOne

    SYNOPSIS:   if _pridCopyFrom is NULL, then this is New Alias,
                otherwise this is Copy Alias

    ENTRY:      iObject is the index of the object to load

                perrMsg returns the error message to be displayed if an
                error occurs, see PERFORMER::PerformSeries for details

    RETURNS:    error code

    HISTORY:
    Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR NEW_ALIASPROP_DLG::GetOne(
        UINT            iObject,
        APIERR *        perrMsg
        )
{
    *perrMsg = IDS_UMCreateNewAliasFailure;
    UIASSERT( iObject == 0 );

    APIERR err = NERR_Success;
    if ( _pridCopyFrom == NULL )
    {
        err = PingFocus( QueryLocation() );
    }

    if( err != NERR_Success )
    {
        return err;
    }

    return W_LMOBJtoMembers( iObject );
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::FillMembersListbox

    SYNOPSIS:   Puts selected users, if any, from main window's listbox
                to Members listbox.

    ENTRY:      aiSel   -   pointer to array of INTs, these are
                            indexes to selected items in main window's
                            user listbox. Default NULL

                iSize   -   size of array. Default 0.

                        These are only used in New Alias case

    NOTES:      Assumes aiSel is in order

    RETURNS:    error code

    HISTORY:
        Thomaspa    27-Mar-1992 Created
        beng        08-Jun-1992 Differentiate remote users

********************************************************************/

APIERR NEW_ALIASPROP_DLG::FillMembersListbox( const INT * aiSel, INT iSize )
{
    if ( aiSel == NULL || iSize == 0 )
    {
        return NERR_Success;
    }


    PSID psidDomain = QueryAdminAuthority()->QueryAccountDomain()->QueryPSID();

    for( INT i = 0; i < iSize; i++ )
    {
        USER_LBI * pulbi = _pulb->QueryItem( aiSel[ i ] );
        UIASSERT( pulbi != NULL );

        // Get remote-user status directly from the lbi.  Don't need
        // to bother with locks, FindItem calls, etc., etc....

        BOOL fRemoteUser = (pulbi->QueryIndex() == MAINUSRLB_REMOTE);

        // Assume the user is not already a member of the alias.  This
        // may cause us to try an extra add, but it will just tell us
        // that the account is already a member, which we will ignore.

        ACCOUNTS_LBI * pacclbi = new ACCOUNTS_LBI( pulbi->QueryAccount(),
                                                   pulbi->QueryRID(),
                                                   psidDomain,
                                                   SidTypeUser,
                                                   FALSE,
                                                   fRemoteUser );

        //  no need for error checking, AddItem does it
        if ( _lbMembers.AddItem( pacclbi ) < 0 )
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return NERR_Success;
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::InitControls

    SYNOPSIS:   See ALIASPROP_DLG::InitControls()

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR NEW_ALIASPROP_DLG::InitControls()
{
    APIERR err = NERR_Success;
    if( _pridCopyFrom == NULL ) // we like to put selected users to
    {                           // members listbox
        INT cSelCount = _pulb->QuerySelCount();
        UIASSERT( cSelCount >= 0 );
        if( cSelCount != 0 && !_pumadminapp->InRasMode() )
        {
            BUFFER buf( sizeof(INT) * cSelCount );
            if( (err = buf.QueryError()) != NERR_Success )
            {
                return err;
            }
            INT * aiSel = (INT *) buf.QueryPtr();
            err = _pulb->QuerySelItems( aiSel, cSelCount );
            if( err != NERR_Success )
                return err;
            // all nonselected to Not Members listbox and selected to
            // Members lb
            err = FillMembersListbox( aiSel, cSelCount );
            if( err != NERR_Success )
                return err;

        }
    }
    else
    {
        // Temporarily set the samalias pointer to the alias to copy.
        SAM_ALIAS * psamaliasCopy = new SAM_ALIAS(
                      _fCopyBuiltin
                        ? *(QueryAdminAuthority()->QueryBuiltinDomain())
                        : *(QueryAdminAuthority()->QueryAccountDomain()),
                      *_pridCopyFrom );

        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if ( psamaliasCopy == NULL ||
            (err = psamaliasCopy->QueryError()) != NERR_Success )
        {
            delete psamaliasCopy;
            return err;
        }


        SetAliasPtr( 0, psamaliasCopy ); // change and delete previous

        err = AddAccountsToMembersLb( TRUE );

        // Also get the comment while we can.
        err = psamaliasCopy->GetComment( &_nlsComment );

        // Reset the samalias pointer to NULL (implicitly deletes psamaliasCopy).
        SetAliasPtr( 0, NULL );
    }
    if( err != NERR_Success )
        return err;
    // leave _sleAliasName blank

    return ALIASPROP_DLG::InitControls();
}


/*******************************************************************

    NAME:       NEW_ALIASPPROP_DLG::PerformOne

    SYNOPSIS:   This is the "new alias" variant of ALIASPPROP_DLG::PerformOne()

    ENTRY:      iObject is the index of the object to save

                perrMsg is the error message to be displayed if an
                error occurs, see PERFORMER::PerformSeries for details

                pfWorkWasDone indicates whether any SAM changes were
                successfully written out.  This may return TRUE even if
                the PerformOne action as a whole failed (i.e. PerformOne
                returned other than NERR_Success).

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

APIERR NEW_ALIASPROP_DLG::PerformOne(
        UINT            iObject,
        APIERR *        perrMsg,
        BOOL *          pfWorkWasDone
        )
{
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );
    *perrMsg = IDS_UMCreateAliasFailure;

    *pfWorkWasDone = FALSE;

    // First make sure a user, group, or alias with the same name doesn't
    // already exist in the Builtin domain.
    APIERR err = ((UM_ADMIN_APP *)_pumadminapp)->ConfirmNewObjectName( _nlsAliasName.QueryPch() );
    if ( err != NERR_Success )
    {
	return W_MapPerformOneError( err );
    }


    // We always add aliases to the accounts domain
    SAM_ALIAS * psamalias = new SAM_ALIAS(
                                *(QueryAdminAuthority()->QueryAccountDomain()),
                                _nlsAliasName.QueryPch() );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if ( psamalias == NULL || (err = psamalias->QueryError()) != NERR_Success )
    {
        delete psamalias;
	return W_MapPerformOneError( err );
    }

    *pfWorkWasDone = TRUE;

    SetAliasPtr( iObject, psamalias );

    err = W_PerformOne( iObject, perrMsg, pfWorkWasDone );

    if ( IsNewVariant() && *pfWorkWasDone )
    {
        ((UM_ADMIN_APP *)_pumadminapp)->NotifyCreateExtensions( QueryHwnd(),
                                              _nlsAliasName,
                                              _nlsComment );
    }

    return W_MapPerformOneError( err );
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::W_MapPerformOneError

    SYNOPSIS:   Checks whether the error maps to a specific control
                and/or a more specific message.  Each level checks for
                errors specific to edit fields it maintains.  This
                level checks for errors associated with the AliasName
                edit field.

    ENTRY:      Error returned from PerformOne()

    RETURNS:    Error to be displayed to user

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

MSGID NEW_ALIASPROP_DLG::W_MapPerformOneError( APIERR err )
{
    APIERR errNew = NERR_Success;
    switch ( err )
    {
    case NERR_BadUsername:
        errNew = IERR_UM_AliasnameRequired;
        break;
    case NERR_GroupExists:
    case NERR_SpeGroupOp:
        errNew = IERR_UM_AliasnameAlreadyGroup;
        break;
    case NERR_UserExists:
        errNew = IERR_UM_AliasnameAlreadyUser;
        break;
             // BUGBUG handle case where ALIAS exists
    default: // other error
        return err;
    }

    _sleAliasName.SelectString();
    _sleAliasName.ClaimFocus();
    return errNew;
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::QueryObjectName

    SYNOPSIS:   This is the "new alias" variant of QueryObjectName.  The
                best name we can come up with is the last name read from
                the dialog.

    HISTORY:
        Thomaspa    30-Mar-1992     Templated from grpprop.cxx

********************************************************************/

const TCHAR * NEW_ALIASPROP_DLG::QueryObjectName(
        UINT            iObject
        ) const
{
    UIASSERT( iObject == 0 );
    return _nlsAliasName.QueryPch();
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::W_DialogToMembers

    SYNOPSIS:   Loads data from dialog into class data members

    RETURNS:    error message (not necessarily an error code)

    NOTES:      This method takes care of validating the data in the
                dialog.  This means ensuring that the logon name is
                valid.  If this validation fails, W_DialogToMembers will
                change focus et al. in the dialog, and return the error
                message to be displayed.

    HISTORY:
        JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_ALIASPROP_DLG::W_DialogToMembers()
{
    // _sleAliasName is an SLE_STRIP and will strip whitespace
    APIERR err = NERR_Success;
    if (   ((err = _sleAliasName.QueryText( &_nlsAliasName )) != NERR_Success )
        || ((err = _nlsAliasName.QueryError()) != NERR_Success ) )
    {
        return err;
    }

    ISTR istr( _nlsAliasName );
#if defined(UNICODE) && defined(FE_SB)
    if (   (_nlsAliasName.strlen() == 0)              // no empty names
        || (_nlsAliasName.strchr( &istr, TCH('\\') )) // may not have backslash
        || (_nlsAliasName.QueryAnsiTextLength() > GNLEN) // check max ansi byte length
       )
#else
    if (   (_nlsAliasName.strlen() == 0)              // no empty names
        || (_nlsAliasName.strchr( &istr, TCH('\\') )) // may not have backslash
       )
#endif
    {
        _sleAliasName.SelectString();
        _sleAliasName.ClaimFocus();
        return IERR_UM_AliasnameRequired;
    }

    return ALIASPROP_DLG::W_DialogToMembers();
}


/*******************************************************************

    NAME:       NEW_ALIASPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
        JonN  24-Jul-1991    created

********************************************************************/

ULONG NEW_ALIASPROP_DLG::QueryHelpContext()
{
    return HC_UM_ALIASPROP_LANNT + QueryHelpOffset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\auditdlg.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT 			     **/
/**		Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
    auditdlg.cxx

    Auditing dialog.

    FILE HISTORY:
	Yi-HsinS	 30-Mar-1992	Created
        Yi-HsinS         18-Mar-1992    Support new auditing categories.Got 
				        rid of MayRun and _nlsInconsistentInfo
        YiHsinS          28-Mar-1992    #ifdef out support for Halt System
                                        when security log is full.
*/

#include <ntincl.hxx>
extern "C" {
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#define INCL_BLT_APP
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <uintlsa.hxx>

extern "C" {
#include <usrmgr.h>
#include <usrmgrrc.h>
#include <umhelpc.h>
}

#include <lmoloc.hxx>
#include <usrmain.hxx>
#include <auditdlg.hxx>

// The bit position associated with the each of the different audit types
// exposed to the user.
#define BITPOS_AUDIT_NONE      	        -1
#define BITPOS_AUDIT_LOGON               0
#define BITPOS_AUDIT_OBJECT_ACCESS       1
#define BITPOS_AUDIT_PRIVILEGE_USE       2
#define BITPOS_AUDIT_ACCOUNT_MANAGEMENT  3
#define BITPOS_AUDIT_POLICY_CHANGE	 4
#define BITPOS_AUDIT_SYSTEM	   	 5
#define BITPOS_AUDIT_DETAILED_TRACKING   6

#define BITPOS_AUDIT_COUNT      7 

//
// The table containing the type strings exposed to the user
// indexed by bit position. 
//

MSGID AuditTypeDlgStringTable[ BITPOS_AUDIT_COUNT ] =
{ IDS_AUDIT_LOGON,               // BITPOS_AUDIT_LOGON
  IDS_AUDIT_OBJECT_ACCESS,       // BITPOS_AUDIT_OBJECT_ACCESS
  IDS_AUDIT_PRIVILEGE_USE,       // BITPOS_AUDIT_PRIVILEGE_USE
  IDS_AUDIT_ACCOUNT_MANAGEMENT,  // BITPOS_AUDIT_ACCOUNT_MANAGEMENT
  IDS_AUDIT_POLICY_CHANGE,       // BITPOS_AUDIT_POLICY_CHANGE
  IDS_AUDIT_SYSTEM,              // BITPOS_AUDIT_SYSTEM
  IDS_AUDIT_DETAILED_TRACKING    // BITPOS_AUDIT_DETAILED_TRACKING
};

#define COMMA_CHAR       TCH(',')
#define BACKSLASH_CHAR   TCH('\\')

/*************************************************************************

    NAME:	AUDITING_GROUP::AUDITING_GROUP

    SYPNOSIS:   Constructor

    ENTRY:      powin      - pointer to the owner window
                bitSuccess - bitmask containing the audit types to be audited
                             for success
                bitFailure - bitmask containing the audit type to be audited
                             for failure.
    EXIT:

    RETURNS:

    NOTES:	

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

AUDITING_GROUP::AUDITING_GROUP( OWNER_WINDOW *powin,
                                const BITFIELD &bitSuccess,
                                const BITFIELD &bitFailure )
    :  CONTROL_GROUP(),
       _sltSuccess      ( powin, SLT_SUCCESS ),
       _sltFailure      ( powin, SLT_FAILURE ),
       _pSetOfAudits    ( NULL )
{

     if ( QueryError() != NERR_Success )
         return;

     APIERR err;

     // Set up the MASK_MAP for use in SET_OF_AUDIT_CATEGORIES
     MASK_MAP AuditMap;
     if ( (err = AuditMap.QueryError() ) != NERR_Success )
     {
         ReportError( err );
         return;
     }

     for ( INT i = 0; i < BITPOS_AUDIT_COUNT; i++ )
     {
          BITFIELD bitTemp( (ULONG) 1 << i );
          RESOURCE_STR  nlsTemp( AuditTypeDlgStringTable[i] );

          if (  (( err = bitTemp.QueryError()) != NERR_Success )
             || (( err = nlsTemp.QueryError()) != NERR_Success )
             || (( err = AuditMap.Add( bitTemp, nlsTemp )) != NERR_Success )
             )
          {
              break;
          }
     }

     if ( err != NERR_Success )
     {
         ReportError( err );
         return;
     }

     // Construct the SET_OF_AUDIT_CATEGORIES 
     _pSetOfAudits  =  new SET_OF_AUDIT_CATEGORIES(powin, 
                                                   SLT_LOGON, 
                                                   CHECKB_LOGON_SUCCESS,
                                                   CHECKB_LOGON_FAILURE,
                                                   &AuditMap, 
                                                   (BITFIELD *) &bitSuccess, 
                                                   (BITFIELD *) &bitFailure );

     err = _pSetOfAudits == NULL? ERROR_NOT_ENOUGH_MEMORY
                                 : _pSetOfAudits->QueryError();

     if ( err != NERR_Success )
     {
         ReportError( err );
         return;
     }
}

/*************************************************************************

    NAME:	AUDITING_GROUP::~AUDITING_GROUP

    SYPNOSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:	

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

AUDITING_GROUP::~AUDITING_GROUP()
{
    delete _pSetOfAudits;
    _pSetOfAudits = NULL;
}

/*************************************************************************

    NAME:	AUDITING_GROUP::SaveValue

    SYPNOSIS:   This is called by the magic group when the user tries to
                change the selection from "Audit" to "Not Audit".

    ENTRY:      fInvisible - ignored

    EXIT:

    RETURNS:

    NOTES: 	Redefine the behaviour of SaveValue - we don't want
                the checks to disappear from the checkboxes if the
                user changes the selection from "Audit" to "Not Audit".
                Instead, we disabled the checkboxes.

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

VOID AUDITING_GROUP::SaveValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );

    _sltSuccess.Enable( FALSE );
    _sltFailure.Enable( FALSE );

    _pSetOfAudits->Enable( FALSE );

}

/*************************************************************************

    NAME:	AUDITING_GROUP::RestoreValue

    SYPNOSIS:   This is called by the magic group when the user tries to
                change the selection from "Audit" to "Not Audit".

    ENTRY:      fInvisible - ignored

    EXIT:

    RETURNS:

    NOTES: 	Since we redefined the behaviour of SaveValue, we have to
                redefine RestoreValue. We enable the group of audit checkboxes
                when the user changes the selection from "Not Audit" to "Audit".

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

VOID AUDITING_GROUP::RestoreValue( BOOL fInvisible )
{
    UNREFERENCED( fInvisible );

    _sltSuccess.Enable( TRUE );
    _sltFailure.Enable( TRUE );

    _pSetOfAudits->Enable( TRUE );
}

/*************************************************************************

    NAME:	AUDITING_GROUP::QueryAuditMask

    SYPNOSIS:   Query the bitmask for Success and Failure from the
                Audit checkboxes

    ENTRY:

    EXIT:       pbitSuccess - contains the bitmask for Success
                pbitFailure - contains the bitmask for Failure

    RETURNS:

    NOTES:	

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

APIERR AUDITING_GROUP::QueryAuditMask( BITFIELD *pbitSuccess,
                                       BITFIELD *pbitFailure )
{

     UIASSERT( pbitSuccess != NULL );
     UIASSERT( pbitFailure != NULL );

     return  _pSetOfAudits->QueryUserSelectedBits( pbitSuccess, pbitFailure);
}

/*************************************************************************

    NAME:	AUDITING_DIALOG::AUDITING_DIALOG

    SYPNOSIS:   Constructor

    ENTRY:      pumadminapp - pointer to the UM_ADMIN_APP
                plsaPolicy  - pointer to the LSA_POLICY object
                locFocus    - location the user manager is focusing on
    EXIT:

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

AUDITING_DIALOG::AUDITING_DIALOG( UM_ADMIN_APP * pumadminapp,
                                  LSA_POLICY  *plsaPolicy,
                                  const LOCATION &locFocus )
    : DIALOG_WINDOW ( IDD_AUDITING, ((OWNER_WINDOW *)pumadminapp)->QueryHwnd()),
      _pumadminapp  ( pumadminapp ),
      _plsaPolicy   ( plsaPolicy ),
      _sltFocusTitle( this, SLT_FOCUS_TITLE ),
      _sltFocus     ( this, SLT_FOCUS ),
      _mgrpAudit    ( this, BUTTON_NO_AUDIT, 2 ),
      _pAuditGrp    ( NULL ),
      _lsaAuditEventInfoMem()
#if 0
      _checkbHaltSystem( this, CHECKB_HALT_SYSTEM ),
      _fShutDownOnFull( FALSE )
#endif
{

    UIASSERT( plsaPolicy != NULL );

    AUTO_CURSOR autocur;

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    NLS_STR nlsFocus;
    RESOURCE_STR nlsTitle( locFocus.IsDomain()? IDS_DOMAIN_TEXT
                                              : IDS_SERVER_TEXT );

    if (  ((err = nlsFocus.QueryError()) != NERR_Success )
       || ((err = locFocus.QueryDisplayName( &nlsFocus )) != NERR_Success )
       || ((err = nlsTitle.QueryError() ) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    //
    // Set the text for the location of focus
    // ( Get rid of the backslashes when focused on a server )
    //

    _sltFocusTitle.SetText( nlsTitle );
    ISTR istr( nlsFocus );
    if ( nlsFocus.QueryChar( istr ) == BACKSLASH_CHAR )
        istr += 2;  // skip past "\\"
    _sltFocus.SetText( nlsFocus.QueryPch( istr));


    //
    // Get the information about which events to audit from the LSA
    //

    BITFIELD bitSuccess( (ULONG) 0 );
    BITFIELD bitFailure( (ULONG) 0 );

    if (  ((err = _mgrpAudit.QueryError()) != NERR_Success )
       || ((err = _lsaAuditEventInfoMem.QueryError()) != NERR_Success )
       || ((err = _plsaPolicy->GetAuditEventInfo( &_lsaAuditEventInfoMem ))
           != NERR_Success )
       || ((err = bitSuccess.QueryError()) != NERR_Success )
       || ((err = bitFailure.QueryError()) != NERR_Success )
       || ((err = ConvertAuditEventInfoToMask( &bitSuccess, &bitFailure ))
           != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }


    //
    // Construct the the audit checkboxes
    //

    _pAuditGrp = new AUDITING_GROUP( this, bitSuccess, bitFailure );

    err = _pAuditGrp == NULL? ERROR_NOT_ENOUGH_MEMORY
                            : _pAuditGrp->QueryError();

    if (  (err != NERR_Success )
       || ((err = _mgrpAudit.AddAssociation( BUTTON_AUDIT, _pAuditGrp ))
                != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    //
    // Set the magic group selection to "Audit" or "Not Audit"
    //

    if ( _lsaAuditEventInfoMem.IsAuditingOn() )
        _mgrpAudit.SetSelection( BUTTON_AUDIT );
    else
        _mgrpAudit.SetSelection( BUTTON_NO_AUDIT );

    _mgrpAudit.SetControlValueFocus();


#if 0
    //
    // Check the ShutDownOnFull checkbox if it's set in the LSA
    //

    if ( (err = _plsaPolicy->CheckIfShutDownOnFull( &_fShutDownOnFull ))
         != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _checkbHaltSystem.SetCheck( _fShutDownOnFull );
#endif

}

/*************************************************************************

    NAME:       AUDITING_DIALOG::~AUDITING_DIALOG

    SYPNOSIS:   Destructor

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

AUDITING_DIALOG::~AUDITING_DIALOG()
{
    _pumadminapp = NULL;
    _plsaPolicy  = NULL;

    delete _pAuditGrp;
    _pAuditGrp = NULL;
}

/*************************************************************************

    NAME:       AUDITING_DIALOG::QueryBitPos

    SYPNOSIS:   Query the bit position in the bitmask the Audit event type
                should map into.

    ENTRY:      nAuditEventType - audit event type

    EXIT:

    RETURN:     Return the bitpos the audit event type should map to

    NOTES:      This methods maps the Audit Event types to the
                types exposed to the user.

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

INT AUDITING_DIALOG::QueryBitPos( INT nAuditEventType )
{
    INT nBitPos = BITPOS_AUDIT_NONE;

    switch ( nAuditEventType )
    {
        case AuditCategorySystem:
            nBitPos = BITPOS_AUDIT_SYSTEM;
            break;

        case AuditCategoryLogon:
            nBitPos = BITPOS_AUDIT_LOGON;
            break;

        case AuditCategoryObjectAccess:
            nBitPos = BITPOS_AUDIT_OBJECT_ACCESS;         
            break;

        case AuditCategoryPrivilegeUse:
            nBitPos = BITPOS_AUDIT_PRIVILEGE_USE;         
            break;

        case AuditCategoryDetailedTracking:
            nBitPos = BITPOS_AUDIT_DETAILED_TRACKING;         
            break;
 
        case AuditCategoryPolicyChange:
            nBitPos = BITPOS_AUDIT_POLICY_CHANGE;         
            break;

        case AuditCategoryAccountManagement:
            nBitPos = BITPOS_AUDIT_ACCOUNT_MANAGEMENT;         
            break;

        default:
            nBitPos = BITPOS_AUDIT_NONE;
            break;
    };

    return nBitPos;
};

/*************************************************************************

    NAME:       AUDITING_DIALOG::ConvertAuditMaskToEventInfo

    SYPNOSIS:   Convert the bitmask got back from the dialog to
                information contained in LSA_AUDIT_EVENT_INFO_MEM so
                that we can pass the info back to the API.

    ENTRY:      bitSuccess - contains the bitmask for types to audit for success
                bitFailure - contains the bitmask for types to audit for failure

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	18-May-1992	Created

**************************************************************************/


VOID AUDITING_DIALOG::ConvertAuditMaskToEventInfo( const BITFIELD &bitSuccess,
                                                   const BITFIELD &bitFailure )
{

    POLICY_AUDIT_EVENT_OPTIONS *pPolicyAuditEventOptions =
           _lsaAuditEventInfoMem.QueryAuditingOptions();

    for ( UINT i = 0; i < _lsaAuditEventInfoMem.QueryAuditEventCount(); i++ )
    {

        INT nPos = QueryBitPos( i );

        if ( nPos == BITPOS_AUDIT_NONE )
            continue;

        pPolicyAuditEventOptions[ i ] = POLICY_AUDIT_EVENT_NONE;

        if ( bitSuccess.IsBitSet( nPos )  )
        {
            pPolicyAuditEventOptions[ i ] |=  POLICY_AUDIT_EVENT_SUCCESS;
        }

        if ( bitFailure.IsBitSet( nPos )  )
        {
            pPolicyAuditEventOptions[ i ] |=  POLICY_AUDIT_EVENT_FAILURE;
        }

    }

}

/*************************************************************************

    NAME:       AUDITING_DIALOG::ConvertAuditEventInfoToMask

    SYPNOSIS:   Convert the information contained in LSA_AUDIT_EVENT_INFO_MEM
                to bitmask so that we can display them in the audit checkboxes

    ENTRY:

    EXIT:       pbitSuccess - points to the bitmask Success
                pbitFailure - points to the bitmask Failure

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	18-May-1992	Created

**************************************************************************/

APIERR AUDITING_DIALOG::ConvertAuditEventInfoToMask( BITFIELD *pbitSuccess,
                                                     BITFIELD *pbitFailure )
{

    POLICY_AUDIT_EVENT_OPTIONS *pPolicyAuditEventOptions =
           _lsaAuditEventInfoMem.QueryAuditingOptions();

    APIERR err;
    NLS_STR nls;
    if ( (err = nls.QueryError()) != NERR_Success )
        return err; 

    //
    // Iterate through all audit event types and set the corresponding bit
    //
    for ( UINT i = 0; i < _lsaAuditEventInfoMem.QueryAuditEventCount(); i++)
    {
         INT nPos = QueryBitPos( i );

        if ( nPos == BITPOS_AUDIT_NONE )
            continue;

         ULONG ulAuditMask = pPolicyAuditEventOptions[ i ];

         if ( ulAuditMask & POLICY_AUDIT_EVENT_SUCCESS )
         {
             pbitSuccess->SetBit( nPos );
         }
         if ( ulAuditMask & POLICY_AUDIT_EVENT_FAILURE )
         {
             pbitFailure->SetBit( nPos );
         }
    }

    return NERR_Success;
}

/*************************************************************************

    NAME:	AUDITING_DIALOG::OnOK

    SYPNOSIS:   Set the audit information back to the LSA when the OK
                button is pressed.

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/

BOOL AUDITING_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    APIERR err = NERR_Success;

    BITFIELD bitSuccess( (ULONG) 0 );
    BITFIELD bitFailure( (ULONG) 0 );

    do {      // Not a loop

        // Get the bitmask for Success and Failure
        if (  ((err = bitSuccess.QueryError()) != NERR_Success )
           || ((err = bitFailure.QueryError()) != NERR_Success )
           || ((err = _pAuditGrp->QueryAuditMask( &bitSuccess, &bitFailure ))
                != NERR_Success )
           )
        {
            break;
        }

        // Convert the bitmask to LSA_AUDIT_EVENT_INFO_MEM
        ConvertAuditMaskToEventInfo( bitSuccess, bitFailure );

        // Set the auditing mode: "ON" or "OFF"
        _lsaAuditEventInfoMem.SetAuditingMode(
             _mgrpAudit.QuerySelection() == BUTTON_NO_AUDIT ? FALSE : TRUE );

        // Set the auditing information back to the LSA
        err = _plsaPolicy->SetAuditEventInfo( &_lsaAuditEventInfoMem );
        if ( err != NERR_Success )
            break;

#if 0
        // Set the shut down on full flag in the LSA if the checkbox
        // state has changed. 
        BOOL fShutDown = _checkbHaltSystem.QueryCheck();
        if (  ( _fShutDownOnFull && !fShutDown )
           || ( !_fShutDownOnFull && fShutDown )
           )
        {
            err = _plsaPolicy->SetShutDownOnFull( fShutDown );
        }
#endif

    } while (FALSE);

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );
    }
    else
    {
        Dismiss( TRUE );
    }

    return TRUE;
}

/*************************************************************************

    NAME:	AUDITING_DIALOG::QueryHelpContext

    SYPNOSIS:   Return the help context associated with the auditing dialog

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
	Yi-HsinS	30-Mar-1992	Created

**************************************************************************/
ULONG AUDITING_DIALOG::QueryHelpContext( VOID )
{
    return HC_UM_POLICY_AUDIT_LANNT + _pumadminapp->QueryHelpOffset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\grplb.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    grplb.cxx
    GROUP_LISTBOX, GROUP_LBI, GROUP_COLUMN_HEADER, and USRMGR_LISTBOX module

    FILE HISTORY:
        rustanl     18-Jul-1991     Created
        rustanl     12-Sep-1991     Added USRMGR_LISTBOX code
        jonn        10-Oct-1991     LMOENUM update
        o-SimoP     11-Dec-1991     Added support for multiple bitmaps
        o-SimoP     31-Dec-1991     CR changes, attended by BenG, JonN and I
        JonN        27-Feb-1992     Multiple bitmaps in both panes
        JonN        31-Mar-1992     Add aliases to listbox
*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
    #include <ntseapi.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <lmoenum.hxx>
#include <lmoent.hxx>   // NT_GROUP_ENUM
#include <lmoeusr.hxx>

#include <uintsam.hxx>
#include <lmoeali.hxx>

#include <usrcolw.hxx>
#include <usrmgrrc.h>
#include <grplb.hxx>
#include <usrmain.hxx>
#include <bmpblock.hxx> // SUBJECT_BITMAP_BLOCK


// The administrator can set up this value in the User Manager for Domains
// registry key.  This should be a DWORD and is in milliseconds.
// If it takes more time than this to read the user list (API time only),
// we skip reading the group comments.
// 0 means read group comments regardless.  This affects:
// -- reading local group comments except from Mini-User Manager;
// -- reading global group comments from an NT 3.1 server only.
// Default is 0.  (NT 3.1 value was fixed, 7500 milliseconds.)
#define AA_INIKEY_COMMENTS_CUTOFF SZ("GroupCommentsCutoffMsec")


// Copied from applib\applib\usrlb.cxx

class USRMGR_NT_GROUP_ENUM : public NT_GROUP_ENUM
{
protected:

    virtual APIERR QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall );      // how many milliseconds last call took

public:

    USRMGR_NT_GROUP_ENUM( const SAM_DOMAIN * psamdomain )
        : NT_GROUP_ENUM( psamdomain )
        {}

    ~USRMGR_NT_GROUP_ENUM()
        {}

};  // class NT_GROUP_ENUM


APIERR USRMGR_NT_GROUP_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    return QueryCountPreferences2( pcEntriesRequested,
                                   pcbBytesRequested,
                                   nNthCall,
                                   cLastEntriesRequested,
                                   cbLastBytesRequested,
                                   msTimeLastCall );
}



/*******************************************************************

    NAME:       GROUP_LBI::GROUP_LBI

    SYNOPSIS:   GROUP_LBI constructor

    ENTRY:      pszGroup -      Pointer to group name
                pszComment -    Pointer to group comment (may be NULL
                                for no comment)

    NOTES:      Group name is assumed to come straight from LMOENUM
                this method does not validate or canonicalize
                the group name.

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

GROUP_LBI::GROUP_LBI( const TCHAR * pszGroup,
                     const TCHAR * pszComment,
                     ULONG ulRID,
                     enum MAINGRPLB_GRP_INDEX  nIndex )
    :   _nlsGroup( pszGroup ),
        _nlsComment( pszComment ),
        _ulRID( ulRID ),
        _nIndex( nIndex )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ( err = _nlsGroup.QueryError()) != NERR_Success ||
         ( err = _nlsComment.QueryError()) != NERR_Success      )
    {
        DBGEOL( "GROUP_LBI ct:  Ct of data members failed" );
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       GROUP_LBI::Paint

    SYNOPSIS:   Paints the GROUP_LBI

    ENTRY:      plb -       Pointer to listbox which provides the context
                            for this LBI.
                hdc -       The device context handle to be used
                prect -     Pointer to clipping rectangle
                pGUILTT -   Pointer to GUILTT structure

    HISTORY:
        rustanl     18-Jul-1991 Created
        beng        08-Nov-1991 Unsigned widths
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/

VOID GROUP_LBI::Paint( LISTBOX * plb,
                       HDC hdc,
                       const RECT * prect,
                       GUILTT_INFO * pGUILTT ) const
{
    STR_DTE dteGroup( _nlsGroup.QueryPch());
    STR_DTE dteComment( _nlsComment.QueryPch());

    DISPLAY_TABLE dtab( 3, (((GROUP_LISTBOX *)plb)->QuerypadColGroup())->QueryColumnWidth());
    dtab[ 0 ] = ((GROUP_LISTBOX *)plb)->QueryDmDte( _nIndex );
    dtab[ 1 ] = &dteGroup;
    dtab[ 2 ] = &dteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       GROUP_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

WCHAR GROUP_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsGroup );
    return _nlsGroup.QueryChar( istr );
}


/*******************************************************************

    NAME:       GROUP_LBI::Compare

    SYNOPSIS:   Compares two GROUP_LBI's

    ENTRY:      plbi -      Pointer to other GROUP_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    HISTORY:
        rustanl     18-Jul-1991 Created
        beng        08-Jun-1992 Aliases sorted with groups

********************************************************************/

INT GROUP_LBI::Compare( const LBI * plbi ) const
{
    INT i = _nlsGroup._stricmp( ((const GROUP_LBI *)plbi)->_nlsGroup );

    if (i == 0)
        i = ((const GROUP_LBI *)plbi)->_nIndex - _nIndex ;

    return i;
}


/*******************************************************************

    NAME:       GROUP_LBI::QueryName

    SYNOPSIS:   Returns the name of the LBI

    RETURNS:    Pointer to name of LBI

    NOTES:      This is a virtual replacement from the ADMIN_LBI class

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

const TCHAR * GROUP_LBI::QueryName() const
{
    return QueryGroup();
}


/*******************************************************************

    NAME:       GROUP_LBI::CompareAll

    SYNOPSIS:   Compares the entire LBI item, in order to optimize
                painting of refreshed items

    ENTRY:      plbi -      Pointer to item to compare with

    RETURNS:    TRUE if both items are identical; FALSE otherwise

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

BOOL GROUP_LBI::CompareAll( const ADMIN_LBI * plbi )
{
    const GROUP_LBI * pulbi = (const GROUP_LBI *)plbi;

    return ( _nlsGroup.strcmp( pulbi->_nlsGroup ) == 0 &&
             _nlsComment.strcmp( pulbi->_nlsComment ) == 0 &&
             _nIndex == pulbi->_nIndex );
}


/**********************************************************************

    NAME:       GROUP_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Determine whether this listbox item starts with the
                string provided

    HISTORY:
        jonn        15-Aug-1992 HAW-for-Hawaii code

**********************************************************************/

INT GROUP_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    ISTR istr( nls );
    UINT cchIn = nls.QueryTextLength();
    istr += cchIn;

//    TRACEEOL(   SZ("User Manager: GROUP_LBI::Compare_HAWforHawaii(): \"")
//             << nls
//             << SZ("\", \"")
//             << _nlsGroup
//             << SZ("\", ")
//             << cchIn
//             );
    return nls._strnicmp( _nlsGroup, istr );

} // GROUP_LBI::Compare_HAWforHawaii


/*******************************************************************

    NAME:       GROUP_LISTBOX::GROUP_LISTBOX

    SYNOPSIS:   GROUP_LISTBOX constructor

    HISTORY:
        rustanl     18-Jul-1991     Created
        beng        31-Jul-1991     Control error handling changed

********************************************************************/

GROUP_LISTBOX::GROUP_LISTBOX( UM_ADMIN_APP * puappwin, CID cid,
                              XYPOINT xy, XYDIMENSION dxy )
    :   USRMGR_LISTBOX( puappwin, cid, xy, dxy ),
        _padColGroup( NULL ),
        _fGroupRidsKnown( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

     _padColGroup = new ADMIN_COL_WIDTHS (QueryHwnd(),
                                          puappwin->QueryInstance(),
                                          ID_GROUP,
                                          3);

     APIERR err = ERROR_NOT_ENOUGH_MEMORY;
     if (   _padColGroup == NULL
         || (err = _padColGroup->QueryError()) != NERR_Success
        )
     {
         DBGEOL( "GROUP_LISTBOX::ctor(); ADMIN_COL_WIDTHS error " << err );
         ReportError (err);
         return;
     }
}


/*******************************************************************

    NAME:       GROUP_LISTBOX::~GROUP_LISTBOX

    SYNOPSIS:   GROUP_LISTBOX destructor

    HISTORY:
        rustanl     01-Jul-1991     Created

********************************************************************/

GROUP_LISTBOX::~GROUP_LISTBOX()
{
    delete _padColGroup;
    _padColGroup = NULL;
}


/*******************************************************************

    NAME:       GROUP_LISTBOX::QueryDmDte

    SYNOPSIS:   Return a pointer to the display map DTE to be
                used by LBI's in this listbox

    RETURNS:    Pointer to said display map DTE

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

DM_DTE * GROUP_LISTBOX::QueryDmDte( enum MAINGRPLB_GRP_INDEX nIndex )
{
    SID_NAME_USE sidtype = SidTypeUnknown;

    switch (nIndex)
    {
        case MAINGRPLB_GROUP:
            sidtype = SidTypeGroup;
            break;

        case MAINGRPLB_ALIAS:
            sidtype = SidTypeAlias;
            break;

        default:
            DBGEOL( "GROUP_LISTBOX::QueryDmDte: bad nIndex " << (INT)nIndex );
            break;
    }

    return QueryBitmapBlock().QueryDmDte( sidtype );

}   // GROUP_LISTBOX::QueryDmDte


/*******************************************************************

    NAME:       GROUP_LISTBOX::CreateNewRefreshInstance

    SYNOPSIS:   Prepares the listbox to begin a new refresh cycle

    EXIT:       On success, RefreshNext is ready to be called

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

APIERR GROUP_LISTBOX::CreateNewRefreshInstance()
{
    //  All work is done at one time in RefreshNext.  Hence, there
    //  is nothing to be initialized here.

    return NERR_Success;
}


/*******************************************************************

    NAME:       GROUP_LISTBOX::DeleteRefreshInstance

    SYNOPSIS:   Deletes refresh enumerators

    HISTORY:
        jonn       27-Sep-1991     Created

********************************************************************/

VOID GROUP_LISTBOX::DeleteRefreshInstance()
{
    // nothing to do
}


//
// Make this STATIC to reduce code change
//

static INT _static_nCommentCutoffMsec = 0;


/*******************************************************************

    NAME:       GROUP_LISTBOX::RefreshNext

    SYNOPSIS:   This method performs the next refresh phase

    RETURNS:    An API error, which may be one of the following:
                    NERR_Success -      success

    NOTES:      Group info level 1 requires admin or account operator
                privilege.  If getting data at this level fails, level
                0 is used, which can be called by anyone.  The difference
                between these two levels is that level 0 doesn't return
                the comment.

                Issue #755, NAMES OF GROUPS, estanblishes that the
                special groups (such as ADMINS, USERS, and GROUPS)
                retain their original names in this listbox, rather than
                being renamed to "Domain Users" etc.  JonN 1/23/92

    HISTORY:
        rustanl     04-Sep-1991     Created

********************************************************************/

APIERR GROUP_LISTBOX::RefreshNext()
{

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

    if ( QueryUAppWindow()->InRasMode() ) // slow mode
        return NERR_Success;

    //
    // Check whether registry specified alternate comment cutoff
    //
    if ( fMiniUserManager )
    {
        _static_nCommentCutoffMsec = 0;
    }
    else if ( NERR_Success != QueryUAppWindow()->Read( AA_INIKEY_COMMENTS_CUTOFF,
                                                       &_static_nCommentCutoffMsec,
                                                       0 ) )
    {
        _static_nCommentCutoffMsec = 0;
        DBGEOL( "GROUP_LISTBOX::RefreshNext(): error reading AA_INIKEY_CUTOFF" );
    }
    TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): comment cutoff "
             << _static_nCommentCutoffMsec );

#ifdef WIN32

    {

        if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL )
        {
            APIERR err = NtRefreshAliases();
            if (err != NERR_Success)
                return err;
        }
    }

#endif // WIN32

    if (!(QueryUAppWindow()->DoShowGroups())) // skip groups for Windows NT
    {
#if defined(DEBUG) && defined(TRACE)
        TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): total time "
                 << (::GetTickCount())-start << " msec" );
#endif
        return NERR_Success;
    }


    /* Try to use SamQDI(DOMAIN_DISPLAY_GROUP).  This will work
     * only if the target is Daytona or better.  Code copied from
     * applib\applib\usrlb.cxx.
     */
    if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL ) {

        const ADMIN_AUTHORITY * padminauth =
                QueryUAppWindow()->QueryAdminAuthority();
        SAM_DOMAIN * psamdomAccount = padminauth->QueryAccountDomain();
        USRMGR_NT_GROUP_ENUM ntgenum( psamdomAccount );
        APIERR err = NERR_Success;
        if (   (err = ntgenum.QueryError()) == NERR_Success
            && (err = ntgenum.GetInfo()) == NERR_Success
           )
        {
            // do not create iter until after GetInfo
            NT_GROUP_ENUM_ITER ntgeiter( ntgenum );
            NLS_STR nlsAccountName;
            NLS_STR nlsComment;
            if (   (err = ntgeiter.QueryError()) != NERR_Success
                || (err = nlsAccountName.QueryError()) != NERR_Success
                || (err = nlsComment.QueryError()) != NERR_Success
               )
            {
                DBGEOL("GROUP_LISTBOX::RefreshNext: NT_GROUP_ENUM_ITER error " << err);
                return err;
            }

            const NT_GROUP_ENUM_OBJ * pntgeobj = NULL;
            while( ( pntgeobj = ntgeiter(&err, FALSE)) != NULL )
            {
                ASSERT( err != ERROR_MORE_DATA );

                if (   (err = pntgeobj->QueryGroup( &nlsAccountName ))
                                    != NERR_Success
                    || (err = pntgeobj->QueryComment( &nlsComment ))
                                    != NERR_Success
                   )
                {
                    DBGEOL( "GROUP_LISTBOX::RefreshNext: QueryGroup error " << err );
                    return err;
                }

                //  Note, no error checking in done at this level for the
                //  'new' and for the construction of the GROUP_LBI (which
                //  is an LBI item).  This is because AddItem is documented
                //  to check for these.
                GROUP_LBI * plbi = new GROUP_LBI( nlsAccountName,
                                                  nlsComment,
                                                  pntgeobj->QueryRID(),
                                                  MAINGRPLB_GROUP );
                err = AddRefreshItem( plbi );
                if ( err != NERR_Success )
                {
                    DBGEOL("GROUP_LISTBOX::RefreshNext: AddRefreshItem error " << err );
                    return err;
                }

            }

            if ( err != NERR_Success )
            {
                DBGEOL( "GROUP_LISTBOX::RefreshNext: error in SamQDI enum " << err );
            }

#if defined(DEBUG) && defined(TRACE)
            TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): total time "
                     << (::GetTickCount())-start << " msec" );
#endif
            return err; // we don't want to mix SamQDI and EnumerateGroups results
        }

        if (err == ERROR_NOT_SUPPORTED || err == ERROR_INVALID_PARAMETER)
        {
            TRACEEOL("GROUP_LISTBOX::RefreshNext: SamQDI not supported" );
            err = NERR_Success; // it must be a Product 1 server
        }
        else
        {
            DBGEOL( "GROUP_LISTBOX::RefreshNext: Error " << err << "in SamQDI" ) ;
            _fGroupRidsKnown = TRUE;
            return err;
        }

    }

    _fGroupRidsKnown = FALSE;

    //
    // Only read group comments if the time needed to read the user list
    // is less than _static_nCommentCutoffMsec
    //
    TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): time to enumerate users was "
             << QueryUAppWindow()->QueryTimeForUserlistRead() << " msec" );
    if (   _static_nCommentCutoffMsec == 0
        || QueryUAppWindow()->QueryTimeForUserlistRead() < (DWORD)_static_nCommentCutoffMsec )
    {
        TRACEEOL( "GROUP_LISTBOX::RefreshNext(): GROUP1_ENUM starts" );

        GROUP1_ENUM ge1( QueryAppWindow()->QueryLocation());
        APIERR err = ge1.QueryError();
        if( err != NERR_Success )
            return err;
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif
        err = ge1.GetInfo();
#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): GROUP1_ENUM took "
                 << finish-start << " msec" );
#endif
        switch ( err )
        {
        case NERR_Success:
            {
                GROUP1_ENUM_ITER gei1( ge1 );
                const GROUP1_ENUM_OBJ * pgi1;

                while( ( pgi1 = gei1() ) != NULL )
                {
                    //  Note, no error checking in done at this level for the
                    //  'new' and for the construction of the GROUP_LBI (which
                    //  is an LBI item).  This is because AddItem is documented
                    //  to check for these.
                    GROUP_LBI * plbi = new GROUP_LBI( pgi1->QueryName(),
                                                      pgi1->QueryComment(),
                                                      0, // RID not known
                                                      MAINGRPLB_GROUP );
                    err = AddRefreshItem( plbi );
                    if ( err != NERR_Success )
                    {
                        DBGEOL("GROUP_LISTBOX::RefreshNext: AddRefreshItem failed");
                        return err;
                    }
                }
            }
#if defined(DEBUG) && defined(TRACE)
            TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): total time "
                     << (::GetTickCount())-start << " msec" );
#endif
            return NERR_Success;

        case ERROR_ACCESS_DENIED:
            break;
        default:
            DBGEOL("GROUP_LISTBOX::RefreshNext: GROUP1_ENUM::GetInfo failed");
            return err;

        }
    }


    {
        TRACEEOL( "GROUP_LISTBOX::RefreshNext(): GROUP0_ENUM starts" );

        GROUP0_ENUM ge0( QueryAppWindow()->QueryLocation());
        APIERR err = ge0.QueryError();
        if( err != NERR_Success )
            return err;
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif
        err = ge0.GetInfo();
#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): GROUP0_ENUM took "
                 << finish-start << " msec" );
#endif
        if ( err != NERR_Success )
        {
            DBGEOL("GROUP_LISTBOX::RefreshNext: GROUP0_ENUM::GetInfo failed");
            return err;
        }

        GROUP0_ENUM_ITER gei0( ge0 );
        const GROUP0_ENUM_OBJ * pgi0;

        while( ( pgi0 = gei0() ) != NULL )
        {
            //  Note, no error checking in done at this level for the
            //  'new' and for the construction of the GROUP_LBI (which
            //  is an LBI item).  This is because AddItem is documented
            //  to check for these.
            GROUP_LBI * plbi = new GROUP_LBI( pgi0->QueryName(),
                                              NULL ); // RID not known
            err = AddRefreshItem( plbi );
            if ( err != NERR_Success )
            {
                DBGEOL("GROUP_LISTBOX::RefreshNext: AddRefreshItem failed");
                return err;
            }
        }
    }

#if defined(DEBUG) && defined(TRACE)
    TRACEEOL(   "GROUP_LISTBOX::RefreshNext(): total time "
             << (::GetTickCount())-start << " msec" );
#endif
    return NERR_Success;
}


#ifdef WIN32

/*******************************************************************

    NAME:       GROUP_LISTBOX::NtRefreshAliases

    SYNOPSIS:   This method refreshed the Alias LBIs for NT focus

    RETURNS:    An API error, which may be one of the following:
                    NERR_Success -      success

    NOTES:      This method assumes that RefreshNext, and therefore
                NtRefreshAliases, is only called once.

    HISTORY:
        jonn        31-Mar-1992     Created

********************************************************************/

APIERR GROUP_LISTBOX::NtRefreshAliases()
{

    const ADMIN_AUTHORITY * padminauth =
                ((UM_ADMIN_APP *)QueryAppWindow())->QueryAdminAuthority();
    SAM_DOMAIN * psamdomAccount = padminauth->QueryAccountDomain();

    ALIAS_ENUM aeAccount( *psamdomAccount );
    APIERR err = aeAccount.QueryError();
    if( err != NERR_Success )
            return err;
    err = aeAccount.GetInfo();

#if defined(DEBUG) && defined(TRACE)
    DWORD total_msec = 0;
    DWORD total_numaliases = 0;
#endif

    switch ( err )
    {
    case NERR_Success:
        {
            ALIAS_ENUM_ITER aeiAccount( aeAccount );
            const ALIAS_ENUM_OBJ * paeoAccount;

            while( ( paeoAccount = aeiAccount.Next( &err ) ) != NULL
                        && err == NERR_Success )
            {
                    NLS_STR nlsName;
                    err = ((ALIAS_ENUM_OBJ *)paeoAccount)->GetName( &nlsName );
                    if (err != NERR_Success)
                    {
                        return err;
                    }

                    NLS_STR nlsComment;
                    //
                    // Only read group comments if the time needed to read the user list
                    // is less than _static_nCommentCutoffMsec
                    //
                    if (   _static_nCommentCutoffMsec == 0
                        || QueryUAppWindow()->QueryTimeForUserlistRead() < (DWORD)_static_nCommentCutoffMsec )
                    {
#if defined(DEBUG) && defined(TRACE)
                        DWORD start = ::GetTickCount();
#endif
                        err = ((ALIAS_ENUM_OBJ *)paeoAccount)->GetComment(*psamdomAccount, &nlsComment);
#if defined(DEBUG) && defined(TRACE)
                        DWORD finish = ::GetTickCount();
                        total_msec += finish - start;
                        total_numaliases++;
#endif
                        if (err != NERR_Success)
                        {
                            return err;
                        }
                    }

                    //  Note, no error checking in done at this level for the
                    //  'new' and for the construction of the ALIAS_LBI (which
                    //  is an LBI item).  This is because AddItem is documented
                    //  to check for these.
                    ALIAS_LBI * plbi = new ALIAS_LBI(
                                        nlsName.QueryPch(),
                                        nlsComment.QueryPch(),
                                        paeoAccount->QueryRid()
                                        );
                    err = AddRefreshItem( plbi );
                    if ( err != NERR_Success )
                    {
                        return err;
                    }
            }
        }
        break;

    case ERROR_ACCESS_DENIED:
        break;
    default:
        return err;

    }


    SAM_DOMAIN * psamdomBuiltin = padminauth->QueryBuiltinDomain();

    ALIAS_ENUM aeBuiltin( *psamdomBuiltin );
    err = aeBuiltin.QueryError();
    if( err != NERR_Success )
            return err;
    err = aeBuiltin.GetInfo();

    switch ( err )
    {
    case NERR_Success:
        {
            ALIAS_ENUM_ITER aeiBuiltin( aeBuiltin );
            const ALIAS_ENUM_OBJ * paeoBuiltin;

            while( ( paeoBuiltin = aeiBuiltin.Next( &err ) ) != NULL
                        && err == NERR_Success )
            {
                    NLS_STR nlsName;
                    err = ((ALIAS_ENUM_OBJ *)paeoBuiltin)->GetName( &nlsName );
                    if ( err != NERR_Success )
                    {
                        return err;
                    }

                    NLS_STR nlsComment;
                    //
                    // Only read group comments if the time needed to read the user list
                    // is less than _static_nCommentCutoffMsec
                    //
                    if (   _static_nCommentCutoffMsec == 0
                        || QueryUAppWindow()->QueryTimeForUserlistRead() < (DWORD)_static_nCommentCutoffMsec )
                    {
#if defined(DEBUG) && defined(TRACE)
                        DWORD start = ::GetTickCount();
#endif
                        err = ((ALIAS_ENUM_OBJ *)paeoBuiltin)->GetComment(*psamdomBuiltin, &nlsComment);
#if defined(DEBUG) && defined(TRACE)
                        DWORD finish = ::GetTickCount();
                        total_msec += finish - start;
                        total_numaliases++;
#endif
                        if (err != NERR_Success)
                        {
                            return err;
                        }
                    }
                    if ( err != NERR_Success )
                    {
                        return err;
                    }

                    //  Note, no error checking in done at this level for the
                    //  'new' and for the construction of the ALIAS_LBI (which
                    //  is an LBI item).  This is because AddItem is documented
                    //  to check for these.
                    ALIAS_LBI * plbi = new ALIAS_LBI(
                                        nlsName.QueryPch(),
                                        nlsComment.QueryPch(),
                                        paeoBuiltin->QueryRid(),
                                        TRUE
                                        );
                    err = AddRefreshItem( plbi );
                    if ( err != NERR_Success )
                    {
                        return err;
                    }
            }
        }
        break;

    case ERROR_ACCESS_DENIED:
        break;
    default:
        return err;
    }

#if defined(DEBUG) && defined(TRACE)
    TRACEEOL(   "GROUP_LISTBOX::NtRefreshAliases(): " << total_numaliases
             << " alias comments took "
             << total_msec << " msec" );
#endif

    return NERR_Success; // BUGBUG
}

#endif // WIN32


/*******************************************************************

    NAME:       GROUP_LISTBOX::ChangeFont

    SYNOPSIS:   Makes all changes associated with a font change

    HISTORY:
        jonn        23-Sep-1993     Created

********************************************************************/

APIERR GROUP_LISTBOX::ChangeFont( HINSTANCE hmod, FONT & font )
{
    ASSERT(   font.QueryError() == NERR_Success
           && _padColGroup != NULL
           && _padColGroup->QueryError() == NERR_Success
           );

    SetFont( font, TRUE );

    APIERR err = _padColGroup->ReloadColumnWidths( QueryHwnd(),
                                                   hmod,
                                                   ID_GROUP );
    if (   err != NERR_Success
        || (err = CalcSingleLineHeight()) != NERR_Success
       )
    {
        DBGEOL( "GROUP_LISTBOX::ChangeFont: reload/calc error " << err );
    }
    else
    {
        (void) Command( LB_SETITEMHEIGHT,
                        (WPARAM)0,
                        (LPARAM)QuerySingleLineHeight() );
    }

    return err;
}


/*******************************************************************

    NAME:       GROUP_LISTBOX::QueryBitmapBlock

    SYNOPSIS:

    HISTORY:
        jonn        04-Oct-1993     Created

********************************************************************/

SUBJECT_BITMAP_BLOCK & GROUP_LISTBOX::QueryBitmapBlock() const
{
    return (SUBJECT_BITMAP_BLOCK &)(QueryUAppWindow()->QueryBitmapBlock());
}


/*******************************************************************

    NAME:       GROUP_COLUMN_HEADER::GROUP_COLUMN_HEADER

    SYNOPSIS:   GROUP_COLUMN_HEADER constructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

GROUP_COLUMN_HEADER::GROUP_COLUMN_HEADER( OWNER_WINDOW * powin, CID cid,
                                          XYPOINT xy, XYDIMENSION dxy,
                                          const GROUP_LISTBOX * pulb)
    :   ADMIN_COLUMN_HEADER( powin, cid, xy, dxy ),
        _pulb (pulb),
        _nlsGroupName(),
        _nlsComment()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ( err = _nlsGroupName.QueryError()) != NERR_Success ||
         ( err = _nlsComment.QueryError()) != NERR_Success )
    {
        DBGEOL("GROUP_COLUMN_HEADER ct: String ct failed");
        ReportError( err );
        return;
    }

    RESOURCE_STR res1( IDS_COL_HEADER_GROUP_NAME );
    RESOURCE_STR res2( IDS_COL_HEADER_GROUP_COMMENT );
    if ( ( err = res1.QueryError() ) != NERR_Success ||
         ( err = ( _nlsGroupName = res1, _nlsGroupName.QueryError())) != NERR_Success ||
         ( err = res2.QueryError() ) != NERR_Success ||
         ( err = ( _nlsComment = res2, _nlsComment.QueryError())) != NERR_Success )
    {
        DBGEOL("GROUP_COLUMN_HEADER ct: Loading resource strings failed");
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       GROUP_COLUMN_HEADER::~GROUP_COLUMN_HEADER

    SYNOPSIS:   GROUP_COLUMN_HEADER destructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

GROUP_COLUMN_HEADER::~GROUP_COLUMN_HEADER()
{
    // do nothing else
}


/*******************************************************************

    NAME:       GROUP_COLUMN_HEADER::OnPaintReq

    SYNOPSIS:   Paints the column header control

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
        rustanl     22-Jul-1991 Created
        jonn        07-Oct-1991 Uses PAINT_DISPLAY_CONTEXT
        beng        08-Nov-1991 Unsigned widths

********************************************************************/

BOOL GROUP_COLUMN_HEADER::OnPaintReq()
{
    PAINT_DISPLAY_CONTEXT dc( this );

    XYRECT xyrect(this); // get client rectangle

    METALLIC_STR_DTE strdteGroupName( _nlsGroupName.QueryPch());
    METALLIC_STR_DTE strdteComment( _nlsComment.QueryPch());

    DISPLAY_TABLE cdt( 2, ((_pulb)->QuerypadColGroup())->QueryColHeaderWidth());
    cdt[ 0 ] = &strdteGroupName;
    cdt[ 1 ] = &strdteComment;
    cdt.Paint( NULL, dc.QueryHdc(), xyrect );

    return TRUE;
}


/*******************************************************************

    NAME:       USRMGR_LISTBOX::USRMGR_LISTBOX

    SYNOPSIS:   USRMGR_LISTBOX constructor

    ENTRY:      puappwin -      Pointer to parent window
                cid -           Control ID
                xy -            Position
                dxy -           Dimension
                fMultSel -      Specifies whether or not listbox is mutli
                                select

    HISTORY:
        rustanl     12-Sep-1991     Created

********************************************************************/

USRMGR_LISTBOX::USRMGR_LISTBOX( UM_ADMIN_APP * puappwin, CID cid,
                                XYPOINT xy, XYDIMENSION dxy,
                                BOOL fMultSel )
    :   ADMIN_LISTBOX( (ADMIN_APP *)puappwin, cid, xy, dxy, fMultSel ),
        _puappwin( puappwin ),
        _hawinfo()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       USRMGR_LISTBOX::CD_VKey

    SYNOPSIS:   Switches the focus when receiving the F6 key

    ENTRY:      nVKey -         Virtual key that was pressed
                nLastPos -      Previous listbox cursor position

    RETURNS:    Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action

    HISTORY:
        rustanl     12-Sep-1991 Created
        beng        16-Oct-1991 Win32 conversion

********************************************************************/

INT USRMGR_LISTBOX::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    //  BUGBUG.  This now works on any combination of Shift/Ctrl/Alt
    //  keys with the F6 and Tab keys (except Alt-F6).  Tab, Shift-Tab,
    //  and F6 should be the only ones that should cause the focus to
    //  change.  It would be nice if this could be changed here.
    if ( nVKey == VK_F6 || nVKey == VK_TAB )
    {
        _puappwin->OnFocusChange( this );
        return -2;      // take no futher action
    }

    return ADMIN_LISTBOX::CD_VKey( nVKey, nLastPos );
}


/*******************************************************************

    NAME:       USRMGR_LISTBOX::CD_Char

    SYNOPSIS:   Views characters as they pass by

    ENTRY:      wch      -     Key pressed
                nLastPos -  Previous listbox cursor position

    RETURNS:    See Win SDK

    HISTORY:
        jonn        26-Aug-1992 HAW-for-Hawaii code

********************************************************************/

INT USRMGR_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{

    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo );

}  // USRMGR_LISTBOX::CD_Char
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\dllfunc.c ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"

#include "windef.h"
#include "winerror.h"
#include "winbase.h"

#include "lmcons.h"
#include "netlibnt.h"
#include "ntlsa.h"
#include "crypt.h"

#include "lmuitype.h" // APIERR
#include "lmerr.h"    // NERR_Success

#include "dllfunc.h"
#include <usrprop.h>

#define SZ_NWSLIB_DLL         L"NWSLIB.DLL"
#define SZ_FPNWCLNT_DLL       L"FPNWCLNT.DLL"
#define SZ_MAPRIDTOOBJECTID   "MapRidToObjectId"
#define SZ_SWAPOBJECTID       "SwapObjectId"
#define SZ_FPNWVOLUMEGETINFO  "FpnwVolumeGetInfo"
#define SZ_FPNWAPIBUFFERFREE  "FpnwApiBufferFree"
#define SZ_QUERYUSERPROPERTY  "QueryUserProperty"
#define SZ_SETUSERPROPERTY    "SetUserProperty"
#define SZ_RETURNNETWAREFORM  "ReturnNetwareForm"

// Global handles for functinos in nwslib.dll and fpnwclnt.dll
HINSTANCE _hNwslibDll = NULL;
HINSTANCE _hfpnwclntDll = NULL;

//
// CODEWORK  The repetitive code to load function pointers should be
// folded together.  JonN 11/6/95
//

typedef APIERR (* PMAPRIDTOOBJECTID)(DWORD dwRid,
                                     LPWSTR pszUserName,
                                     BOOL fNTAS,
                                     BOOL fBuiltin );

typedef APIERR (* PSWAPOBJECTID)( ULONG ulObjectId );

typedef APIERR (* PFPNWVOLUMEGETINFO)( IN  LPWSTR pServerName OPTIONAL,
                                       IN  LPWSTR pVolumeName,
                                       IN  DWORD  dwLevel,
                                       OUT PFPNWVOLUMEINFO *ppVolumeInfo );

typedef APIERR (* PFPNWAPIBUFFERFREE)( IN  LPVOID pBuffer );

typedef APIERR (* PQUERYUSERPROPERTY)(   IN  LPWSTR          UserParms,
                                         IN  LPWSTR          Property,
                                         OUT PWCHAR          PropertyFlag,
                                         OUT PUNICODE_STRING PropertyValue );

typedef APIERR (* PSETUSERPROPERTY)(   IN LPWSTR             UserParms,
                                       IN LPWSTR             Property,
                                       IN UNICODE_STRING     PropertyValue,
                                       IN WCHAR              PropertyFlag,
                                       OUT LPWSTR *          pNewUserParms,
                                       OUT BOOL *            Update );

typedef APIERR (* PRETURNNETWAREFORM)(   const char * pszSecretValue,
                                         DWORD dwUserId,
                                         const WCHAR * pchNWPassword,
                                         UCHAR * pchEncryptedNWPassword);


APIERR CallMapRidToObjectId( DWORD dwRid,
                            LPWSTR pszUserName,
                            BOOL fNTAS,
                            BOOL fBuiltin,
                            ULONG *pulObjectId)
{
    APIERR err = NERR_Success;
    static PMAPRIDTOOBJECTID  _pfnMapRidToObjectId  = NULL;

    if (_pfnMapRidToObjectId == NULL)
    {
        if (err = LoadNwsLibDll())
        {
            return(err);
        }

        _pfnMapRidToObjectId = (PMAPRIDTOOBJECTID) GetProcAddress(
                                                       _hNwslibDll,
                                                       SZ_MAPRIDTOOBJECTID);

        if (_pfnMapRidToObjectId == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }

    *pulObjectId = _pfnMapRidToObjectId(dwRid, pszUserName, fNTAS, fBuiltin);

    return(err);
}

APIERR CallSwapObjectId( ULONG ulObjectId,
                         ULONG *pulObjectId)
{
    APIERR err = NERR_Success;
    static PSWAPOBJECTID      _pfnSwapObjectId      = NULL;

    if (_pfnSwapObjectId == NULL)
    {
        if (err = LoadNwsLibDll())
        {
            return(err);
        }

        _pfnSwapObjectId = (PSWAPOBJECTID) GetProcAddress(
                                               _hNwslibDll,
                                               SZ_SWAPOBJECTID);

        if (_pfnSwapObjectId == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }

    *pulObjectId = _pfnSwapObjectId(ulObjectId);

    return(err);
}

APIERR CallNwVolumeGetInfo(IN  LPWSTR pServerName OPTIONAL,
                           IN  LPWSTR pVolumeName,
                           IN  DWORD  dwLevel,
                           OUT PFPNWVOLUMEINFO *ppVolumeInfo )

{
    APIERR err = NERR_Success;
    static PFPNWVOLUMEGETINFO   _pfnNwVolumeGetInfo   = NULL;

    if (_pfnNwVolumeGetInfo == NULL)
    {
        if (err = LoadFpnwClntDll())
        {
            return(err);
        }

        _pfnNwVolumeGetInfo = (PFPNWVOLUMEGETINFO) GetProcAddress(
                                                     _hfpnwclntDll,
                                                     SZ_FPNWVOLUMEGETINFO);

        if (_pfnNwVolumeGetInfo == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }

    err = _pfnNwVolumeGetInfo(pServerName, pVolumeName, dwLevel, ppVolumeInfo);

    return(err);
}

APIERR CallNwApiBufferFree ( IN  LPVOID pBuffer )
{
    APIERR err = NERR_Success;
    static PFPNWAPIBUFFERFREE   _pfnNwApiBufferFree   = NULL;

    if (_pfnNwApiBufferFree == NULL)
    {
        if (err = LoadFpnwClntDll())
        {
            return(err);
        }

        _pfnNwApiBufferFree = (PFPNWAPIBUFFERFREE) GetProcAddress(
                                                      _hfpnwclntDll,
                                                      SZ_FPNWAPIBUFFERFREE);

        if (_pfnNwApiBufferFree == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }

    err = _pfnNwApiBufferFree ( pBuffer );

    return(err);
}


APIERR CallQueryUserProperty(IN  LPWSTR          UserParms,
                             IN  LPWSTR          Property,
                             OUT PWCHAR          PropertyFlag,
                             OUT PUNICODE_STRING PropertyValue )
{
    APIERR err = NERR_Success;
    NTSTATUS status;

#if 0
    static PQUERYUSERPROPERTY _pfnQueryUserProperty = NULL;
    if (_pfnQueryUserProperty == NULL)
    {
        if (err = LoadNwsLibDll())
        {
            return(err);
        }

        _pfnQueryUserProperty = (PQUERYUSERPROPERTY) GetProcAddress(
                                                          _hNwslibDll,
                                                          SZ_QUERYUSERPROPERTY);

        if (_pfnQueryUserProperty == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }
#endif
    status = NetpParmsQueryUserProperty (UserParms,
                                         Property,
                                         PropertyFlag,
                                         PropertyValue);

    if (!NT_SUCCESS( status))
        err = NetpNtStatusToApiStatus(status);

    return(err);
}

APIERR CallSetUserProperty(IN  LPWSTR          UserParms,
                           IN  LPWSTR          Property,
                           IN  UNICODE_STRING  PropertyValue,
                           IN  WCHAR           PropertyFlag,
                           OUT LPWSTR *        pNewUserParms,
                           OUT BOOL *          Update )
{
    APIERR err = NERR_Success;
    NTSTATUS status;

#if 0
    static PSETUSERPROPERTY   _pfnSetUserProperty   = NULL;
    if (_pfnSetUserProperty == NULL)
    {
        if (err = LoadNwsLibDll())
        {
            return(err);
        }

        _pfnSetUserProperty = (PSETUSERPROPERTY) GetProcAddress(
                                                      _hNwslibDll,
                                                      SZ_SETUSERPROPERTY);

        if (_pfnSetUserProperty == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }
#endif
    status = NetpParmsSetUserProperty (UserParms,
                                       Property,
                                       PropertyValue,
                                       PropertyFlag,
                                       pNewUserParms,
                                       Update);

    if (!NT_SUCCESS( status))
        err = NetpNtStatusToApiStatus(status);

    return(err);
}

APIERR CallReturnNetwareForm(const char * pszSecretValue,
                             DWORD dwUserId,
                             const WCHAR * pchNWPassword,
                             UCHAR * pchEncryptedNWPassword)


{
    APIERR err = NERR_Success;
    static PRETURNNETWAREFORM _pfnReturnNetwareForm = NULL;
    NTSTATUS status;

    if (_pfnReturnNetwareForm == NULL)
    {
        if (err = LoadNwsLibDll())
        {
            return(err);
        }

        _pfnReturnNetwareForm = (PRETURNNETWAREFORM) GetProcAddress(
                                                        _hNwslibDll,
                                                        SZ_RETURNNETWAREFORM);

        if (_pfnReturnNetwareForm == NULL)
        {
            err = GetLastError();
            return(err);
        }
    }

    status = _pfnReturnNetwareForm (pszSecretValue,
                                    dwUserId,
                                    pchNWPassword,
                                    pchEncryptedNWPassword);

    if (!NT_SUCCESS( status))
        err = NetpNtStatusToApiStatus(status);

    return(err);
}

APIERR LoadFpnwClntDll(void)
{

    static BOOL fAttemptedLoad = FALSE ;

    if (fAttemptedLoad)
    {
        return(  _hfpnwclntDll ? NERR_Success : ERROR_FILE_NOT_FOUND) ;
    }

    fAttemptedLoad = TRUE ;

    if (!_hfpnwclntDll)
    {
        _hfpnwclntDll = LoadLibrary( SZ_FPNWCLNT_DLL );
        if (!_hfpnwclntDll)
        {
            return( GetLastError() ) ;
        }
    }

    return NERR_Success ;
}

APIERR LoadNwsLibDll(void)
{

    static BOOL fAttemptedLoad = FALSE ;

    if (fAttemptedLoad)
    {
        return( _hNwslibDll ? NERR_Success : ERROR_FILE_NOT_FOUND) ;
    }

    fAttemptedLoad = TRUE ;

    if (!_hNwslibDll)
    {
        //
        //  most functions from NWSLIB.DLL were moved to FPNWCLNT.DLL for
        //  SUR merge
        //

//      _hNwslibDll = LoadLibrary( SZ_NWSLIB_DLL );
        _hNwslibDll = LoadLibrary( SZ_FPNWCLNT_DLL );
        if (!_hNwslibDll)
        {
            return( GetLastError() ) ;
        }
    }

    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\logonhrs.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    logonhrs.cxx


    FILE HISTORY:
    JonN        10-Dec-1991     Created
    JonN        18-Dec-1991     Logon Hours code review changes part 1
    JonN        18-Dec-1991     Logon Hours code review changes part 2
        CR attended by JimH, o-SimoP, ThomasPa, BenG, JonN
    JonN        06-Mar-1992     Moved GetOne from subprop subclasses
    jonn        18-May-1992     Uses new logon hours control, viva BenG!
    JonN        13-Aug-1992     Uses BIT_MAP_CONTROL
    JonN        17-Aug-1992     Does not use BIT_MAP_CONTROL; settles
                                for icon controls
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>


extern "C"
{
    #include <usrmgrrc.h>
    #include <umhelpc.h>
}

#include <lhourset.hxx>

#include <usrmain.hxx>
#include <lmouser.hxx>
#include <logonhrs.hxx>




//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::USERLOGONHRS_DLG

    SYNOPSIS:   Constructor for User Properties Logon Hours subdialog

    ENTRY:      puserpropdlgParent - pointer to parent properties
                                     dialog

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

USERLOGONHRS_DLG::USERLOGONHRS_DLG(
        USERPROP_DLG * puserpropdlgParent,
        const LAZY_USER_LISTBOX * pulb
        ) : USER_SUBPROP_DLG(
                puserpropdlgParent,
                MAKEINTRESOURCE(IDD_USERLOGONHRS),
                pulb
                ),
            _logonhrsctrl( this, IDUP_LH_CUSTOM ),
            _pushbuttonPermit( this, IDUP_LH_PERMIT ),
            _pushbuttonBan( this, IDUP_LH_BAN ),
            _icon1( this, IDUP_LH_ICON1 ),
            _icon2( this, IDUP_LH_ICON2 ),
            _icon3( this, IDUP_LH_ICON3 ),
            _fontHelv( FONT_DEFAULT ),
            _logonhrssetting(),
            _fIndeterminateLogonHrs ( FALSE ),
            _fEncounteredDaysPerWeek ( FALSE ),
            _fEncounteredBadUnits ( FALSE )
{

    INT i;
    for ( i = 0; i < UM_LH_NUMLABELS; i++ )
    {
        _sltLabels[i] = (SLT *)NULL;
    }

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    XYRECT xyrectLogonHrsCtrl;

    if (   (err = _logonhrssetting.QueryError()) != NERR_Success
        || (err = _fontHelv.QueryError()) != NERR_Success
        || (err = xyrectLogonHrsCtrl.QueryError()) != NERR_Success
        || (_logonhrsctrl.QueryWindowRect( &xyrectLogonHrsCtrl ), FALSE )
        || (xyrectLogonHrsCtrl.ConvertScreenToClient( QueryHwnd() ), FALSE )
               // xyrectLogonHrsCtrl is now in client coordinates
        || (err = CenterOverHour( &_icon1, xyrectLogonHrsCtrl, 1  )) != NERR_Success
        || (err = CenterOverHour( &_icon2, xyrectLogonHrsCtrl, 13 )) != NERR_Success
        || (err = CenterOverHour( &_icon3, xyrectLogonHrsCtrl, 25 )) != NERR_Success
        || (err = _icon1.SetIcon(IDI_UM_LH_Moon)) != NERR_Success
        || (err = _icon2.SetIcon(IDI_UM_LH_Sun)) != NERR_Success
        || (err = _icon3.SetIcon(IDI_UM_LH_Moon)) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    for ( i = 0; i < UM_LH_NUMLABELS; i++ )
    {
        _sltLabels[i] = new SLT( this, IDUP_LH_LABEL1 + i );
        err = _sltLabels[i]->QueryError();
        if (   (err != NERR_Success)
            || (err = CenterOverHour( _sltLabels[i],
                                      xyrectLogonHrsCtrl,
                                      (i * 6) + 1 )) != NERR_Success
           )
        {
            ReportError( err );
            return;
        }
        _sltLabels[i]->SetFont( _fontHelv );
    }

    //
    //  WARNING
    //
    //  The LOGON_HOURS control is bascially a subclassed STATIC
    //  text field.  Unfortunately, because of the way we do
    //  subclassing, the STATIC control doesn't receive the initial
    //  focus indication.  To hack around this, we arrange the dialog
    //  template so that the logon hours control is *not* the first
    //  control with the WS_TABSTOP style.  Then, we set the focus
    //  to the logon hours control here in the dialog constructor.
    //

    _logonhrsctrl.ClaimFocus();

}// USERLOGONHRS_DLG::USERLOGONHRS_DLG



/*******************************************************************

    NAME:       USERLOGONHRS_DLG::~USERLOGONHRS_DLG

    SYNOPSIS:   Destructor for User Properties Logon Hours subdialog

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

USERLOGONHRS_DLG::~USERLOGONHRS_DLG( void )
{
    INT i;
    for ( i = 0; i < UM_LH_NUMLABELS; i++ )
    {
        delete _sltLabels[i]; // CODEWORK should be _apsltLabels;
    }
}


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::CenterOverHour

    SYNOPSIS:   Centers a control over an hour gridmark in the
                Logon Hours custom control

    ENTRY:      pwin -- window to center

                xyrectLogonHrsCtrl -- location of logon hours control
                                      in client coordinates

                nHour - Index of gridmark, 1 for left midnight, 13 for noon,
                        25 for right midnight

    HISTORY:
    JonN        29-Jan-1993     Created

********************************************************************/

APIERR USERLOGONHRS_DLG::CenterOverHour( WINDOW * pwin,
                                         XYRECT & xyrectLogonHrsCtrl,
                                         INT nHour )
{
    ASSERT( pwin != NULL );

    XYRECT xyWindowPos;
    pwin->QueryWindowRect( &xyWindowPos );
    xyWindowPos.ConvertScreenToClient( QueryHwnd() );
    // xyOldPos is now in client coordinates

    INT xDesiredCenter = _logonhrsctrl.QueryXForRow( nHour );
    INT xCurrentWidth = xyWindowPos.CalcWidth();
    INT xDesiredPos = xyrectLogonHrsCtrl.QueryLeft() + xDesiredCenter - (xCurrentWidth / 2);
    xyWindowPos.Offset( xDesiredPos - xyWindowPos.QueryLeft(), 0 );

    XYPOINT xy( xyWindowPos.QueryLeft(), xyWindowPos.QueryTop() );

    pwin->SetPos( xy );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::W_LMOBJtoMembers

    SYNOPSIS:   Loads class data members from initial data

    ENTRY:      Index of user to examine.  W_LMOBJToMembers expects to be
                called once for each user, starting from index 0.

    RETURNS:    error code

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

APIERR USERLOGONHRS_DLG::W_LMOBJtoMembers(
        UINT            iObject)
{

    USER_2 * puser2Curr = QueryUser2Ptr( iObject );
    UINT uNewUsersPerWeek = puser2Curr->QueryLogonHours().QueryUnitsPerWeek();
    APIERR err = NERR_Success;
    if ( iObject == 0 ) // first object
    {
        _fIndeterminateLogonHrs = FALSE;
        _fEncounteredDaysPerWeek = FALSE;
        _fEncounteredBadUnits = FALSE;
        if ( LOGON_HOURS_SETTING::IsEditableUnitsPerWeek( uNewUsersPerWeek ) )
        {
            err = _logonhrssetting.Set( puser2Curr->QueryLogonHours() );
        }
        else if ( LOGON_HOURS_SETTING::IsConvertibleUnitsPerWeek( uNewUsersPerWeek ) )
        {
            _fEncounteredDaysPerWeek = TRUE;

            if ( !ConfirmPairedMessage( IDS_LH_DAYSPERWEEK ))
                return IERR_CANCEL_NO_ERROR;

            err = _logonhrssetting.Set( puser2Curr->QueryLogonHours() );
            if ( err == NERR_Success )
                err = _logonhrssetting.ConvertToHoursPerWeek();
        }
        else
        {
            _fEncounteredBadUnits = TRUE;
            if ( !ConfirmPairedMessage( IDS_LH_BADUNITS ))
                return IERR_CANCEL_NO_ERROR;

            err = _logonhrssetting.MakeDefault();
        }
        _logonhrssetting.ConvertFromGMT();
    }
    else        // iObject > 0
    {
        if ( !_fIndeterminateLogonHrs && !_fEncounteredBadUnits )
        {
            if ( LOGON_HOURS_SETTING::IsEditableUnitsPerWeek( uNewUsersPerWeek ) )
            {
                LOGON_HOURS_SETTING tempsetting( puser2Curr->QueryLogonHours() );
                err = tempsetting.QueryError();
                if ( err == NERR_Success )
                    tempsetting.ConvertFromGMT();
                if ( err == NERR_Success && !(_logonhrssetting.IsIdentical( tempsetting )) )
                {
                    _fIndeterminateLogonHrs = TRUE;

                    if ( !ConfirmMessage( IDS_LH_INDETERMINATE ))
                        return IERR_CANCEL_NO_ERROR;

                    err = _logonhrssetting.MakeDefault();
                }
            }
            else if ( LOGON_HOURS_SETTING::IsConvertibleUnitsPerWeek( uNewUsersPerWeek ) )
            {
                if (   !_fEncounteredDaysPerWeek
                    && !ConfirmPairedMessage( IDS_LH_DAYSPERWEEK )
                   )
                {
                    return IERR_CANCEL_NO_ERROR;
                }

                _fEncounteredDaysPerWeek = TRUE;
                LOGON_HOURS_SETTING tempsetting( puser2Curr->QueryLogonHours() );
                err = tempsetting.QueryError();
                if ( err == NERR_Success )
                    err = tempsetting.ConvertToHoursPerWeek();
                if ( err == NERR_Success )
                {
                    tempsetting.ConvertFromGMT();
                    if ( !(_logonhrssetting.IsIdentical( tempsetting )) )
                    {
                        _fIndeterminateLogonHrs = TRUE;

                        if ( !ConfirmMessage( IDS_LH_INDETERMINATE ))
                            return IERR_CANCEL_NO_ERROR;

                        err = _logonhrssetting.MakeDefault();
                    }
                }
            }
            else
            {
                _fEncounteredBadUnits = TRUE;
                if ( !ConfirmPairedMessage( IDS_LH_BADUNITS ))
                    return IERR_CANCEL_NO_ERROR;

                err = _logonhrssetting.MakeDefault();
            }
        }
    }

    if ( err != NERR_Success )
        return err;

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );

} // USERLOGONHRS_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERLOGONHRS_DLG,
                according to the values in the class data members.

    RETURNS:    An error code which is NERR_Success on success.

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

APIERR USERLOGONHRS_DLG::InitControls()
{
    APIERR err = _logonhrsctrl.SetHours( &_logonhrssetting );

    return (err == NERR_Success) ? USER_SUBPROP_DLG::InitControls() : err;

} // USERLOGONHRS_DLG::InitControls


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

BOOL USERLOGONHRS_DLG::OnOK( void )
{
    APIERR err = W_DialogToMembers();

    switch( err )
    {
    case NERR_Success:
        break;

    default:
        ::MsgPopup( this, err );
        return TRUE;
        break;
    }

    if ( PerformSeries() )
    {
        Dismiss(); // Dismiss code not used
    }

    return TRUE;

}   // USERLOGONHRS_DLG::OnOK


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::DisplayMessage

    SYNOPSIS:   Displays message as specified.

    RETURNS:    As MsgPopup().

    HISTORY:
    JonN        19-Dec-1991     Created

********************************************************************/

INT USERLOGONHRS_DLG::DisplayMessage( MSGID msgid,
                                      MSG_SEVERITY msgsev,
                                      UINT usButtons )
{

    return MsgPopup( this,
                     msgid,
                     msgsev,
                     usButtons,
                     QueryObjectName( 0 ) );

}   // USERLOGONHRS_DLG::OnOK


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::W_DialogToMembers

    SYNOPSIS:   Loads data from dialog into class data members

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

APIERR USERLOGONHRS_DLG::W_DialogToMembers()
{
    APIERR err = _logonhrsctrl.QueryHours( &_logonhrssetting );
    if ( err != NERR_Success )
        return err;

    return USER_SUBPROP_DLG::W_DialogToMembers();

} // USERLOGONHRS_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::ChangesUser2Ptr

    SYNOPSIS:   Checks whether W_MembersToLMOBJ changes the USER_2
                for this object.

    ENTRY:      index to object

    RETURNS:    TRUE iff USER_2 is changed

    HISTORY:
        JonN    18-Dec-1991   created

********************************************************************/

BOOL USERLOGONHRS_DLG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::W_MembersToLMOBJ

    SYNOPSIS:   Loads class data members into the USER_2 object

    ENTRY:      puser2          - pointer to a USER_2 to be modified

                pusermemb       - pointer to a USER_MEMB to be modified

    RETURNS:    error code

    NOTES:      If some fields were different for multiply-selected
                objects, the initial contents of the edit fields
                contained only a default value.  In this case, we only
                want to change the LMOBJ if the value of the edit field
                has changed.  This is also important for "new" variants,
                where PerformOne will not always copy the object and
                work with the copy.

                Note that the LMOBJ is not changed if the current
                contents of the edit field are the same as the
                initial contents.

                In User Property subproperty dialogs, this method may
                only change the LMOBJs indicated by ChangesUser2Ptr and
                ChangesUserMembPtr.

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

APIERR USERLOGONHRS_DLG::W_MembersToLMOBJ(
        USER_2 *        puser2,
        USER_MEMB *     pusermemb )
{
    LOGON_HOURS_SETTING  tempsetting( _logonhrssetting );
    tempsetting.ConvertToGMT();
    APIERR err = puser2->SetLogonHours( tempsetting );
    if( err != NERR_Success )
        return err;

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERLOGONHRS_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       USER_LOGONHRS_DLG::OnCommand

    SYNOPSIS:   button handler

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    NOTES:      This handles the Permit All button.

    HISTORY:
               JonN  12-Dec-1991    created

********************************************************************/

BOOL USERLOGONHRS_DLG::OnCommand( const CONTROL_EVENT & ce )
{
    switch ( ce.QueryCid() )
    {
    case IDUP_LH_PERMIT:
        _logonhrsctrl.DoPermitButton();
        return TRUE;

    case IDUP_LH_BAN:
        _logonhrsctrl.DoBanButton();
        return TRUE;

    // else fall through

    }

    return USER_SUBPROP_DLG::OnCommand( ce ) ;

}// USERLOGONHRS_DLG::OnCommand


/*******************************************************************

    NAME:       USERLOGONHRS_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
    JonN        10-Dec-1991     Created

********************************************************************/

ULONG USERLOGONHRS_DLG::QueryHelpContext( void )
{

    return HC_UM_LOGONHOURS_LANNT + QueryHelpOffset();

} // USERLOGONHRS_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\lusrlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lusrlb.cxx
    LAZY_USER_LISTBOX module


    FILE HISTORY:
        jonn        17-Dec-1992     Templated from adminlb.cxx

    CODEWORK  This listbox (and others) should make a better effort to
              retain caret position when items are added or removed.
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
    #include <ntseapi.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <lmoenum.hxx>
#include <lmoeusr.hxx>  // Downlevel user enumerator
#ifdef WIN32
#include <lmoent.hxx>   // NT user enumerator
#endif // WIN32

#include <usrcolw.hxx>
#include <usrmgrrc.h>
#include <usrmain.hxx>
#include <usrlb.hxx>    // USER_LBI
#include <lusrlb.hxx>   // LAZY_USER_LISTBOX
#include <memblb.hxx>
#include <bmpblock.hxx> // SUBJECT_BITMAP_BLOCK


//
// Define this macro to test _pulbiError.  This macro should be the inverse
// frequency of failure of the QueryItem function (e.g. 32 is 1/32 frequency).
// Every Xth item will register as unreadable.
//
// #define USRMGR_TEST_QUERY_FAILURE 32


/*
 *  This class is local to this file
 */
class LUSRLB_SAVE_SELECTION : public SAVE_SELECTION
{
protected:

    virtual const TCHAR * QueryItemIdent( INT i );
    virtual INT FindItemIdent( const TCHAR * pchIdent );

public:
    LUSRLB_SAVE_SELECTION( LAZY_USER_LISTBOX * plb )
        : SAVE_SELECTION( plb )
        {}
    ~LUSRLB_SAVE_SELECTION()
        {}

    LAZY_USER_LISTBOX * QueryListbox()
        { return (LAZY_USER_LISTBOX *)SAVE_SELECTION::QueryListbox(); }

};



//
//  USRMGR_LBI_CACHE methods.
//

/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: USRMGR_LBI_CACHE

    SYNOPSIS:   USRMGR_LBI_CACHE class constructor.

    EXIT:       The object has been constructed.

    HISTORY:
        JonN        18-Dec-1992     Created

********************************************************************/
USRMGR_LBI_CACHE :: USRMGR_LBI_CACHE( VOID )
  : USER_LBI_CACHE( sizeof(BOOL) ),
    _plazylb( NULL )
{

    TRACEEOL( "USRMGR_LBI_CACHE::USRMGR_LBI_CACHE" );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // USRMGR_LBI_CACHE :: USRMGR_LBI_CACHE

/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: ~USRMGR_LBI_CACHE

    SYNOPSIS:   USRMGR_LBI_CACHE class destructor.

    EXIT:       The object has been destroyed.

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        18-Dec-1992     Created

********************************************************************/
USRMGR_LBI_CACHE :: ~USRMGR_LBI_CACHE( VOID )
{

    TRACEEOL( "USRMGR_LBI_CACHE::~USRMGR_LBI_CACHE" );

    // nothing

}   // USRMGR_LBI_CACHE :: ~USRMGR_LBI_CACHE


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: CreateLBI

    SYNOPSIS:   This virtual callback returns the appropriate LBI
                for the provided DOMAIN_DISPLAY_USER.


    RETURNS:    lbi

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        18-Dec-1992     Created

********************************************************************/
LBI * USRMGR_LBI_CACHE::CreateLBI( const DOMAIN_DISPLAY_USER * pddu )
{

    // TRACEEOL( "User Manager:CreateLBI(): Creating LBI index " << pddu->Index );
    ASSERT( pddu != NULL );

    LBI * plbi = new USER_LBI( pddu, _plazylb, FALSE );

#ifdef DEBUG
    if ( plbi == NULL || plbi->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: CreateLBICache: error creating LBI" );
    }
#endif // DEBUG

    return plbi;
}


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: Compare

    SYNOPSIS:   These virtual callbacks returns the ordering for two
                LBIs, or for one LBI and one DOMAIN_DISPLAY_USER.

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        21-Dec-1992     Created.

********************************************************************/
INT USRMGR_LBI_CACHE::Compare( const LBI                 * plbi,
                               const DOMAIN_DISPLAY_USER * pddu ) const
{
    // USRMGR_ULC_ENTRY not needed for compare methods

    ULC_ENTRY ulc0; // local names in initializer not supported by Glock
    ulc0.pddu = NULL;
    ulc0.plbi = (LBI *)plbi;

    ULC_ENTRY ulc1;
    ulc1.pddu = (DOMAIN_DISPLAY_USER *)pddu;
    ulc1.plbi = NULL;

    return (QueryCompareMethod())( &ulc0, &ulc1 );
}

INT USRMGR_LBI_CACHE::Compare( const LBI * plbi0,
                               const LBI * plbi1 ) const
{
    ULC_ENTRY ulc0; // local names in initializer not supported by Glock
    ulc0.pddu = NULL;
    ulc0.plbi = (LBI *)plbi0;

    ULC_ENTRY ulc1;
    ulc1.pddu = NULL;
    ulc1.plbi = (LBI *)plbi1;

    return (QueryCompareMethod())( &ulc0, &ulc1 );
}

/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: QueryCompareMethod

    SYNOPSIS:   This virtual callback returns the appropriate compare
                method to be used by qsort() while sorting the cache
                entries.  The default compare method is
                USRMGR_LBI_CACHE::CompareLogonNames().


    RETURNS:    PQSORT_COMPARE          - sort method

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        18-Dec-1992     Created.

********************************************************************/
PQSORT_COMPARE USRMGR_LBI_CACHE::QueryCompareMethod( VOID ) const
{
    return (   ( _plazylb != NULL )
            && ( _plazylb->QuerySortOrder() == ULB_SO_FULLNAME ) )
                    ? (PQSORT_COMPARE)&USRMGR_LBI_CACHE::CompareFullNames
                    : (PQSORT_COMPARE)&USRMGR_LBI_CACHE::CompareLogonNames;
}


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: CompareLogonNames

    SYNOPSIS:   Compares the LogonName fields of two ULC_ENTRY structures.

    ENTRY:      p0                      - Points to the "left" structure.

                p1                      - Points to the "right" structure.

    RETURNS:    int                     -  0 if *p0 == *p1
                                          >0 if *p0  > *p1
                                          <0 if *p0  < *p1

    NOTES:      This is a static method.

    HISTORY:
        JonN        22-Dec-1992     Created.

********************************************************************/
int __cdecl USRMGR_LBI_CACHE :: CompareLogonNames( const void * p0,
                                                    const void * p1 )
{
    const ULC_ENTRY * pLeft  = (const ULC_ENTRY *)p0;
    const ULC_ENTRY * pRight = (const ULC_ENTRY *)p1;

    const DOMAIN_DISPLAY_USER * pdduLeft = (pLeft->plbi != NULL)
                                              ? ((USER_LBI *)(pLeft->plbi))->QueryDDU()
                                              : pLeft->pddu;
    const DOMAIN_DISPLAY_USER * pdduRight = (pRight->plbi != NULL)
                                              ? ((USER_LBI *)(pRight->plbi))->QueryDDU()
                                              : pRight->pddu;

    return ::ICompareUnicodeString( &pdduLeft->LogonName,
                                    &pdduRight->LogonName );

}   // USER_LBI_CACHE :: CompareLogonNames


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: CompareFullNames

    SYNOPSIS:   Compares the FullName fields of two ULC_ENTRY structures,
                or the LogonName fields if neither has a FullName or
                both have the same FullName..

    ENTRY:      p0                      - Points to the "left" structure.

                p1                      - Points to the "right" structure.

    RETURNS:    int                     -  0 if *p0 == *p1
                                          >0 if *p0  > *p1
                                          <0 if *p0  < *p1

    NOTES:      This is a static method.

    HISTORY:
        JonN        22-Dec-1992     Created.

********************************************************************/
int __cdecl USRMGR_LBI_CACHE :: CompareFullNames( const void * p0,
                                                   const void * p1 )
{
    const ULC_ENTRY * pLeft  = (const ULC_ENTRY *)p0;
    const ULC_ENTRY * pRight = (const ULC_ENTRY *)p1;

    const DOMAIN_DISPLAY_USER * pdduLeft = (pLeft->plbi != NULL)
                                              ? ((USER_LBI *)(pLeft->plbi))->QueryDDU()
                                              : pLeft->pddu;
    const DOMAIN_DISPLAY_USER * pdduRight = (pRight->plbi != NULL)
                                              ? ((USER_LBI *)(pRight->plbi))->QueryDDU()
                                              : pRight->pddu;

    int cbLeftFullname  = pdduLeft->FullName.Length;
    int cbRightFullname = pdduRight->FullName.Length;

    if ( cbLeftFullname > 0 &&
         cbRightFullname > 0 )
    {
        int nResult = ::ICompareUnicodeString( &pdduLeft->FullName,
                                               &pdduRight->FullName );

        if ( nResult != 0 )
            return nResult;
    }
    else
    {
        //  At least one of the fullnames is empty

        if ( cbLeftFullname > 0 || cbRightFullname > 0 )
        {
            //  Exactly one of the two fullnames is empty
            if ( cbLeftFullname > 0 )
            {
                // This fullname is non-empty; sort it first
                return -1;
            }

            // That fullname is non-empty; sort it first
            return 1;
        }
    }

    //  Use secondary sort key
    return ::ICompareUnicodeString( &pdduLeft->LogonName,
                                    &pdduRight->LogonName );

}   // USER_LBI_CACHE :: CompareFullNames


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: AddItem

    SYNOPSIS:   Add a new LBI to the cache.  A binary search of the
                cache will be performed to determine the appropriate
                location for the new LBI.  AddItem will also take care
                of the listbox selection if a listbox is attached.

    ENTRY:      plbi                    - The new LBI to add to the
                                          cache.

    EXIT:       If successful, then the new LBI has been added to
                the cache in sorted order.

    RETURNS:    INT                     - ULC_ERR if an error occurred
                                          while adding the item.
                                          Otherwise, returns the index
                                          for the new item.

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        18-Dec-1992     Created

********************************************************************/
INT USRMGR_LBI_CACHE :: AddItem( LBI * plbi )
{
    TRACEEOL( "USRMGR_LBI_CACHE::AddItem" );

    //
    //  Add the new item to the cache.
    //

    INT i = USER_LBI_CACHE::AddItem( plbi );

    if( i >= 0 && _plazylb != NULL )
    {
        //
        //  Item successfully added to cache, now insert
        //  a new item into the lazy listbox.
        //

        if( _plazylb->InsertItem( i ) < 0 )
        {

        TRACEEOL( "USRMGR_LBI_CACHE::AddItem failed" );

        //
        //  Failure while inserting new item into
        //  lazy listbox.  Remove the newly added
        //  item from the cache.
        //
        //  The following REQUIRE will ensure that
        //  the item removed from the cache was
        //  the same item we just added.
        //

        REQUIRE( plbi == USER_LBI_CACHE::RemoveItem( i ) );

        //
        //  Delete the LBI, since we failed the addition.
        //

        delete plbi;

        //
        //  Return an appropriate error code.
        //

        i = ULC_ERR;
        }
    }

    ASSERT( _plazylb->QueryCount() == QueryCount() );

    return i;

}   // USRMGR_LBI_CACHE :: AddItem

/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: RemoveItem

    SYNOPSIS:   Removes an item from the cache, but does not delete
                the corresponding LBI.  RemoveItem will also take care of
                the listbox selection if one is attacahed.

    ENTRY:      i                       - Zero-based index of the
                                          item to remove.

    EXIT:       If successful, then the LBI has been removed from
                the cache.

    RETURNS:    LBI *                   - Points to the LBI removed
                                          from the cache.  Will be
                                          NULL if an error occurred.

    NOTES:      This is a virtual method.

    HISTORY:
        JonN        18-Dec-1992     Created

********************************************************************/
LBI * USRMGR_LBI_CACHE :: RemoveItem( INT i )
{
    TRACEEOL( "USRMGR_LBI_CACHE::RemoveItem( " << i << " )" );

    //
    //  Remove the item from the cache.
    //

    LBI * plbi = USER_LBI_CACHE::RemoveItem( i );

    if( plbi != NULL && _plazylb != NULL )
    {
        //
        //  Item successfully removed from cache.  Now
        //  remove it from the lazy listbox.
        //

        if( _plazylb->DeleteItem( i ) < 0 )
        {

        TRACEEOL( "USRMGR_LBI_CACHE:RemoteItem: LB::DeleteItem failed" );

        //
        //  Failure while deleting the item from the
        //  lazy listbox.  Re-add the item back into
        //  the cache.
        //

        //
        //  The following REQUIRE will ensure that the
        //  item is added back in its original cache
        //  location.
        //

        REQUIRE( USER_LBI_CACHE::AddItem( plbi ) == i );

        //
        //  Return a failure indication.
        //

        plbi = NULL;

        }
    }

    ASSERT( _plazylb->QueryCount() == QueryCount() );

    return plbi;

}   // USRMGR_LBI_CACHE :: RemoveItem


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: FindItem

    SYNOPSIS:   Finds an LBI in the cache.  Note that this does not guarantee
                that the items exactly match.

    HISTORY:
        JonN        22-Dec-1992     Created.

********************************************************************/
INT USRMGR_LBI_CACHE :: FindItem( const USER_LBI & ulbi )
{
    return FindItem( ulbi.QueryDDU() );

}   // USRMGR_LBI_CACHE :: FindItem


INT USRMGR_LBI_CACHE :: FindItem( DOMAIN_DISPLAY_USER * pddu )
{
    INT nReturn = BinarySearch( pddu );

    if ( (nReturn < 0) || (nReturn >= QueryCount()) )
    {
        TRACEEOL( "User Manager: USRMGR_LBI_CACHE::FindItem binary search miss" );
        nReturn = ULC_ERR;
    }
    else
    {
        USRMGR_ULC_ENTRY * pumulc = QueryEntryPtr( nReturn );
        ASSERT( pumulc != NULL );

        ULC_ENTRY ulcTemp;
        ulcTemp.plbi = NULL;
        ulcTemp.pddu = pddu;

        BOOL fMatch = (0 == (QueryCompareMethod())( (void *)(&ulcTemp),
                                                    (void *)pumulc     ) );

        if ( !fMatch )
        {
            TRACEEOL( "User Manager: USRMGR_LBI_CACHE::FindItem found non-match " << nReturn );
            nReturn = ULC_ERR;
        }
    }

    return nReturn;

}   // USRMGR_LBI_CACHE :: FindItem


INT USRMGR_LBI_CACHE :: FindItem( const TCHAR * pchUserName )
{

    INT nReturn = ULC_ERR;

    if ( _plazylb != NULL && _plazylb->QuerySortOrder() == ULB_SO_FULLNAME )
    {
#if defined(DEBUG) && defined(TRACE)
        DWORD start = ::GetTickCount();
#endif
        //
        // We must perform a linear search
        //


        UNICODE_STRING unistr;
        unistr.Length = ::strlenf(pchUserName) * sizeof(WCHAR);
        unistr.MaximumLength = unistr.Length + sizeof(WCHAR);
#ifndef UNICODE
#error
#else
        unistr.Buffer = (WCHAR *)pchUserName;
#endif

        INT cItems = QueryCount();
        for ( INT i = 0; i < cItems; i++ )
        {
            DOMAIN_DISPLAY_USER * pddu = QueryDDU( i );
            ASSERT( pddu != NULL );

            if (0 == ::ICompareUnicodeString( &unistr, &(pddu->LogonName) ) )
            {
                nReturn = i;
                break;
            }
        }
#if defined(DEBUG) && defined(TRACE)
        DWORD finish = ::GetTickCount();
        TRACEEOL( "User Manager: linear search FindItem() took " << finish-start << " ms" );
#endif
    }
    else
    {
        //
        // Create a dummy DOMAIN_DISPLAY_USER to find in cache
        // We only need the LogonName field
        //
        DOMAIN_DISPLAY_USER ddu;
        ddu.LogonName.Length = ::strlenf(pchUserName) * sizeof(WCHAR);
        ddu.LogonName.MaximumLength = ddu.LogonName.Length + sizeof(WCHAR);
        ddu.LogonName.Buffer = (WCHAR *)pchUserName;

        nReturn = FindItem( &ddu );
    }

#if defined(DEBUG)
    if (nReturn < 0)
    {
        //      This is not (necessarily) an error.
        //  Report using DBGEOL, though.
        DBGEOL(   "LAZY_USER_LISTBOX::FindItem:  Could not find user "
               << pchUserName );
    }
#endif // DEBUG

    return nReturn;

}   // USRMGR_LBI_CACHE :: FindItem


/*******************************************************************

    NAME:       USRMGR_LBI_CACHE :: AttachListbox

    SYNOPSIS:   Attaches a lazy listbox to the cache.  The listbox's
                selection will automatically be updated when items are
                added or removed.

    HISTORY:
        JonN        18-Dec-1992     Created.

********************************************************************/
VOID USRMGR_LBI_CACHE :: AttachListbox( LAZY_USER_LISTBOX * plazylb )
{
    _plazylb = plazylb;

}   // USRMGR_LBI_CACHE :: AttachListbox




/*************************************************************************

    NAME:       FAST_USER_LBI

    SYNOPSIS:   Special version of USER_LBI

    INTERFACE:  FAST_USER_LBI() -       constructor

    PARENT:     USER_LBI

    HISTORY:
        rustanl     12-Sep-1991     Created

**************************************************************************/

class FAST_USER_LBI : public USER_LBI
{
private:
    const TCHAR * Convert( TCHAR * psz );

public:
    FAST_USER_LBI( TCHAR * pszAccount,
                   TCHAR * pszFullname,
                   TCHAR * pszComment,
                   const LAZY_USER_LISTBOX * pulb );

};  // class FAST_USER_LBI


/*******************************************************************

    NAME:       FAST_USER_LBI::FAST_USER_LBI

    SYNOPSIS:   FAST_USER_LBI constructor

    ENTRY:      pszAccount -    Pointer to account name
                pszFullname -   Pointer to fullname
                pszComment -    Pointer to comment
                pulb -          Pointer to listbox which will provide
                                context for this LBI

    HISTORY:
        rustanl     13-Sep-1991     Created

********************************************************************/

FAST_USER_LBI::FAST_USER_LBI( TCHAR * pszAccount,
                              TCHAR * pszFullname,
                              TCHAR * pszComment,
                              const LAZY_USER_LISTBOX * pulb )
    :   USER_LBI( Convert( pszAccount ),
                  Convert( pszFullname ),
                  Convert( pszComment ),
                  pulb )
{
    if ( QueryError() != NERR_Success )
        return;

}  // FAST_USER_LBI::FAST_USER_LBI


/*******************************************************************

    NAME:       FAST_USER_LBI::Convert

    SYNOPSIS:   Converts a character pointer

    ENTRY:      psz -       Pointer to be converted

    RETURNS:    Converted pointer

    HISTORY:
        rustanl     13-Sep-1991     Created

********************************************************************/

const TCHAR * FAST_USER_LBI::Convert( TCHAR * psz )
{
    if ( *psz++ == TCH('I') )
    {
        *(psz-1) = TCH('i');
        TCHAR * pszT = psz;
        TCHAR * pszH = psz;
        while ( *pszH != TCH('\0') )
        {
            *pszT = *pszH;
            pszT++;
            pszH += 2;
        }
        *pszT = TCH('\0');
    }

    return (const TCHAR *)psz;

}  // FAST_USER_LBI::Convert



class UM_NT_USER_ENUM : public NT_USER_ENUM
{
protected:

    virtual APIERR QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall );      // how many milliseconds last call took

public:

    UM_NT_USER_ENUM( const SAM_DOMAIN * psamdomain )
        : NT_USER_ENUM( psamdomain )
        {}

    ~UM_NT_USER_ENUM()
        {}

};  // class NT_USER_ENUM


APIERR UM_NT_USER_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    return QueryCountPreferences2( pcEntriesRequested,
                                   pcbBytesRequested,
                                   nNthCall,
                                   cLastEntriesRequested,
                                   cbLastBytesRequested,
                                   msTimeLastCall );
}




DEFINE_MI2_NEWBASE( LAZY_USER_LISTBOX, LAZY_LISTBOX, TIMER_CALLOUT );

/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::LAZY_USER_LISTBOX

    SYNOPSIS:   LAZY_USER_LISTBOX constructor

    NOTES:      LAZY_USER_LISTBOX is always extended-select.

                Most of the methods of LAZY_USER_LISTBOX are templated from
                ADMIN_LISTBOX, USER_LISTBOX or BLT_LISTBOX.

    HISTORY:
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

LAZY_USER_LISTBOX::LAZY_USER_LISTBOX( UM_ADMIN_APP * paappwin, CID cid,
                             XYPOINT xy, XYDIMENSION dxy )
    :  LAZY_LISTBOX( paappwin, cid, xy, dxy,
                    WS_CHILD | WS_VSCROLL | WS_HSCROLL | WS_BORDER |
                    LBS_OWNERDRAWFIXED | LBS_NOTIFY | LBS_NODATA |
                    LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT |
                    LBS_EXTENDEDSEL ),
        TIMER_CALLOUT(),
        _timerFastRefresh( this, 1000 ),
        _paappwin( paappwin ),
        _fRefreshInProgress ( FALSE ),
        _fInvalidatePending ( FALSE ),
        _hawinfo(),
        _ulbso( ULB_SO_LOGONNAME ),
#ifdef WIN32 // NT user enumerator
        _pntuenum( NULL ),
        _pntueiter( NULL ),
#endif // WIN32
        _pue10( NULL ),
        _puei10( NULL ),
        _plbicache( NULL ),
        _pulbiError( NULL ),
        _padColUsername( NULL ),
        _padColFullname( NULL ),
        _msTimeForUserlistRead( 0L )
{
    if ( QueryError() != NERR_Success )
        return;

    RESOURCE_STR nlsErrorLBI( IDS_BadUserLBI );

    APIERR err = NERR_Success;

    if(   (err = _hawinfo.QueryError()) != NERR_Success
       || (err = nlsErrorLBI.QueryError()) != NERR_Success )
    {
       ReportError( err );
       return;
    }

    _pulbiError = new USER_LBI( nlsErrorLBI.QueryPch(),
                                NULL,
                                NULL,
                                this );

    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _pulbiError == NULL
        || (err = _pulbiError->QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _padColUsername = new ADMIN_COL_WIDTHS (QueryHwnd(),
                                            paappwin->QueryInstance(),
                                            ID_USERNAME,
                                            4);    //cColumns = 4.

    _padColFullname = new ADMIN_COL_WIDTHS (QueryHwnd(),
                                            paappwin->QueryInstance(),
                                            ID_FULLNAME,
                                            4);

    if ((_padColUsername == NULL) ||
        (_padColFullname == NULL))
    {
        ReportError (ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    if ( ((err = _padColUsername->QueryError()) != NERR_Success) ||
         ((err = _padColFullname->QueryError()) != NERR_Success) )
    {
        ReportError (err);
        return;
    }
}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::~LAZY_USER_LISTBOX

    SYNOPSIS:  LAZY_USER_LISTBOX destructor

    HISTORY:
       rustanl     01-Jul-1991     Created
       kevinl      12-Aug-1991     Added Refresh shutdown
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

LAZY_USER_LISTBOX::~LAZY_USER_LISTBOX()
{
    DeleteRefreshInstance();
    TurnOffRefresh();           // Turn off refresh if running.

    if ( _plbicache != NULL )
    {
        _plbicache->AttachListbox( NULL );
        delete _plbicache;
        _plbicache = NULL;
    }

    delete _pulbiError;
    _pulbiError = NULL;

    delete _padColUsername;
    delete _padColFullname;

    _padColUsername = NULL;
    _padColFullname = NULL;
}


//
// The following methods originated in ADMIN_LISTBOX
//


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::OnTimerNotification

    SYNOPSIS:   Called every time

    ENTRY:      tid -       ID of timer that matured

    HISTORY:
        kevinl    17-Sep-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::OnTimerNotification( TIMER_ID tid )
{
    if ( _timerFastRefresh.QueryID() == tid )
    {
       if ( _fRefreshInProgress )       // Do we have a timer refresh
            OnFastTimer();              // running?
        return;
    }

    // call parent class
    TIMER_CALLOUT::OnTimerNotification( tid );
}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::TurnOffRefresh

    SYNOPSIS:  This method stops a timer driven refresh.  This is
                the method that ADMIN_APP::StopRefresh should call.
                If a refresh is currently running then the method
                turns off the refresh timer and then calls the virtual
                method DeleteRefreshInstance which informs the user
                that they should remove the refresh specific data.
                Once this method is called, no further RefreshNext
                calls will be made without a call to
                CreateNewRefreshInstance.  Otherwise, it simply returns.

    HISTORY:
       kevinl     19-Aug-1991     Created
       kevinl     25-Sep-1991     Added call to DeleteRefreshInstance
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::TurnOffRefresh()
{
     if (!_fRefreshInProgress)                  // Refresh running?
         return;                                // No, Return

     _timerFastRefresh.Enable( FALSE );
     _fRefreshInProgress = FALSE;               // No refresh in progress

     DeleteRefreshInstance();                   // Delete Refresh Data
}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::OnFastTimer

    SYNOPSIS:  Called by the fast refresh timer.  It will then
                call RefreshNext so that the next portion of the
                listbox can be updated.  It will stop the refresh
                if either all of the data has been processed or
                an error is reported by RefreshNext.

    HISTORY:
       kevinl     19-Aug-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::OnFastTimer()
{
    APIERR err = RefreshNext(); // Process the next piece

    if ( _fInvalidatePending )
    {
        SetRedraw( TRUE );                      // Allow redraws
         Invalidate();
         _fInvalidatePending = FALSE;
    }

    switch ( err )
    {
    case NERR_Success:                  // All data processed
        TurnOffRefresh();               // Stop the refresh timer
        PurgeStaleItems();                      // Delete old items

        break;

    case ERROR_MORE_DATA:               // Wait for the next timer
        return;

    default:                            // Error, or unknown case
        StopRefresh();                  // Stop the refresh
        break;
    }

    //
    // Refresh the extensions.  Note that the caller of RefreshNow is
    // responsible for doing this himself, only periodic refresh
    // completion is handled here.
    //

    _paappwin->CompletePeriodicRefresh();

}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::MarkAllAsStale

    SYNOPSIS:  Simple loops through the listbox items and resets
                the refreshed flags to UnRefreshed.  So that we
                always maintain valid data in the listbox.

    HISTORY:
       kevinl     19-Aug-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::MarkAllAsStale()
{
    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::MarkAllAsStale(): bad or no cache" );
        return;
    }

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

    USRMGR_ULC_ENTRY * pumulc;

    INT clbe = _plbicache->QueryCount();

    for (INT i = 0; i < clbe; i++)
    {
        pumulc = _plbicache->QueryEntryPtr(i);
        UIASSERT( pumulc != NULL );
        pumulc->fNotStale = FALSE;
    }

#if defined(DEBUG) && defined(TRACE)
    DWORD finish = ::GetTickCount();
    TRACEEOL( "User Manager: LAZY_USER_LISTBOX::MarkAllAsStale() took " << finish-start << " ms" );
#endif

}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::PurgeStaleItems

    SYNOPSIS:   Loops through the listbox and depending on the
                refreshed flag will either:
                    Flag value                  Action
                -------------------------------------------
                   Refreshed            MarkAsUnrefreshed
                                        So subsequent refreshes
                                        will update it properly
                   UnRefreshed          Remove the item from
                                        the listbox.

    NOTES:      The basic algorithm is outlined below:

                for all items in the listbox,
                    if the item is current,
                        mark the item as stale
                    else
                        delete the item
                    endif
                endfor

                In addition, QueryItem( i ) might return _pulbiError
                if no LBI could be created for a position.  These
                should never be deleted.


    HISTORY:
       kevinl     19-Aug-1991     Created
       kevinl     04-Sep-1991     Code review changes
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::PurgeStaleItems()
{

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::PurgeStaleItems(): bad or no cache" );
        return;
    }

#if defined(DEBUG) && defined(TRACE)
    DWORD start = ::GetTickCount();
#endif

    BOOL fItemDeleted = FALSE;

    SetRedraw( FALSE );                 // No flicker

    USRMGR_ULC_ENTRY * pumulc;

    INT clbe = _plbicache->QueryCount();

    for (INT i = 0; i < clbe; i++)
    {
        pumulc = _plbicache->QueryEntryPtr(i);
        UIASSERT( pumulc != NULL );

        if ( pumulc->fNotStale )
        {
            pumulc->fNotStale = FALSE;               // Yes, Mark it.
        }
        else
        {
            TRACEEOL( "LAZY_USER_LISTBOX::PurgeStaleItems: deleting item " << i );
            //
            // CODEWORK RemoveItem is potentially an O(n) operation, making
            // PurgeStaleItems O(n^^2).  This could be recoded to be more
            // efficient.  JonN 11/6/95
            //
            // CODEWORK We also should not use RemoveItem since this creates
            // an LBI even if none currently exists.  JonN 11/6/95
            //
            LBI * plbi =_plbicache->RemoveItem(i);
            if (plbi == NULL)
            {
                TRACEEOL( "LAZY_USER_LISTBOX::PurgeStaleItems: RemoveItem failed" );
            }
            else
            {
               delete plbi;
            }
            i--;                           // Adjust the count and
            clbe--;                        // index.  Because delete
                                           // item will adjust the
                                           // listbox immediately.
            fItemDeleted = TRUE;           // Go ahead and invalidate
                                           // the listbox
        }
    }

#if defined(DEBUG) && defined(TRACE)
    DWORD finish = ::GetTickCount();
    TRACEEOL( "LAZY_USER_LISTBOX::PurgeStaleItems() took " << finish-start << " ms" );
#endif

    ASSERT( QueryCount() == _plbicache->QueryCount() );

    SetRedraw( TRUE );                          // Allow painting

    if ( fItemDeleted || _fInvalidatePending )
        Invalidate( TRUE );                           // Force the updates.
}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::RefreshNow

    SYNOPSIS:  Will force a refresh to occur, and will not yield
                until all of the data has been processed.

    RETURNS:   An API error, which is NERR_Success on success

    HISTORY:
       kevinl     19-Aug-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::RefreshNow()
{
    APIERR err = NERR_Success;

    if ( QueryUAppWindow()->InRasMode() )
    {
        // Leave the listbox blank if we are in RAS mode.  Note that
        // the cache is left alone, in case the user leaves RAS mode.

        // clear the cache
        delete _plbicache;
        _plbicache = new USRMGR_LBI_CACHE(); // initially empty
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _plbicache == NULL
            || (err = _plbicache->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "\tFailed with error " << err );
            delete _plbicache;
            _plbicache = NULL;
        }
        else
        {
            _plbicache->AttachListbox( this );
        }

        SetCount( 0 );
        Invalidate();

        return err;
    }

    AUTO_CURSOR autocur;                // Hourglass.

    //
    // Stop the timer refresh if one is running.  NOTE:
    // that StopRefresh will do nothing if a timer is not running.
    //
    StopRefresh();                      // Stop the refresh

    //
    // If there is no cache, we still have not loaded initial information.
    // Use the optimized loading procedure in USRMGR_LBI_CACHE.
    //
    // If the cache exists but is empty, we assume we were is RAS mode
    // and use optimized loading anyway.
    //
    if ( _plbicache == NULL || _plbicache->QueryCount() == 0 )
    {
        delete _plbicache;
        _plbicache = new USRMGR_LBI_CACHE(); // initially empty
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _plbicache == NULL
            || (err = _plbicache->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "\tFailed with error " << err );
            delete _plbicache;
            _plbicache = NULL;
            return err;
        }

        if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL )
        {
            DBGEOL( "\tThis is the first refresh.  Let USRMGR_LBI_CACHE do the work." );

            DWORD start = ::GetTickCount();

            err = _plbicache->ReadUsers(
                        (ADMIN_AUTHORITY *)QueryUAppWindow()->QueryAdminAuthority(),
                        ULC_INITIAL_GROWTH_DEFAULT,
                        ULC_REQUEST_COUNT_DEFAULT,
                        TRUE );
            if ( err != NERR_Success )
                return err;

            DWORD finish = ::GetTickCount();
            _msTimeForUserlistRead = finish - start;

            TRACEEOL(   "LAZY_USER_LISTBOX::RefreshNow(): initial read took "
                     << _msTimeForUserlistRead << " msec" );

            if ( ((UM_ADMIN_APP *)_paappwin)->QueryViewAcctType() & UM_VIEW_NETWARE_USERS )
            {
                TRACEEOL( "LAZY_USER_LISTBOX::RefreshNow(): NetWare user filter" );

                _plbicache->AttachListbox( this ); // required by Purge
                SetCount( _plbicache->QueryCount() );

                //
                // Mark as stale all users who are not NetWare-enabled
                //
                DWORD start = ::GetTickCount();
                INT clbe = _plbicache->QueryCount();
                USRMGR_ULC_ENTRY * pumulc = NULL;
                DOMAIN_DISPLAY_USER * pddu = NULL;
                INT i = 0;
                for (i = 0; i < clbe; i++)
                {
                    pumulc = _plbicache->QueryEntryPtr(i);
                    UIASSERT( pumulc != NULL );
                    pddu = pumulc->pddu;
                    UIASSERT( pddu != NULL );
                    pumulc->fNotStale = !!(pddu->AccountControl & USER_MNS_LOGON_ACCOUNT);
                }
                DWORD finish = ::GetTickCount();
                TRACEEOL(   "LAZY_USER_LISTBOX::RefreshNow(): NetWare user filter took "
                         << finish-start << " msec" );

                //
                // Purge all users who are not NetWare-enabled
                //
                start = ::GetTickCount();
                PurgeStaleItems();
                MarkAllAsStale();
                finish = ::GetTickCount();
                TRACEEOL(   "LAZY_USER_LISTBOX::RefreshNow(): NetWare user purge took "
                         << finish-start << " msec" );
            }
        }
        else
        {
            DBGEOL( "\tThis is the first refresh.  Create empty USRMGR_LBI_CACHE for downlevel focus." );
        }

        _plbicache->AttachListbox( this );
        SetCount( _plbicache->QueryCount() );
        Invalidate();

        if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL )
        {
            DWORD start = ::GetTickCount();
            _plbicache->Sort();
            DWORD finish = ::GetTickCount();
            TRACEEOL(   "LAZY_USER_LISTBOX::RefreshNow(): final sort took "
                     << finish-start << " msec" );
            return NERR_Success;
        }
    }

    LUSRLB_SAVE_SELECTION savesel( this );
    APIERR errSaveSel = savesel.QueryError();
    if (errSaveSel == NERR_Success)
    {
        errSaveSel = savesel.Remember();
    }

    // Let the listbox know we are going to refresh

    if ((err = CreateNewRefreshInstance()) != NERR_Success)
    {
        DeleteRefreshInstance();        // Delete Refresh Instance
        return err;
    }

    SetRedraw( FALSE );         // No Flicker

    _fInvalidatePending = FALSE;

    do
    {
        err = RefreshNext();            // Process the next piece
    }
    while ( err == ERROR_MORE_DATA );

    DeleteRefreshInstance();            // Delete Refresh Instance

    switch ( err )
    {
    case NERR_Success:          // All data has been successfully
                                // processed.
        PurgeStaleItems();      // Remove old items.
                                // Will SetRedraw( TRUE );

        if (errSaveSel == NERR_Success)
        {
            (void) savesel.Restore();
        }

        return NERR_Success;

    default:
        MarkAllAsStale();       // Start over.
        SetRedraw( TRUE );
        return err;

    }
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::KickOffRefresh

    SYNOPSIS:   This method starts a timer driven refresh.

        This is the method that periodic refreshes should call.
        If a refresh is currently running then the method
        simply returns.  Otherwise, it tries to start the refresh.

    HISTORY:
       kevinl     19-Aug-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::KickOffRefresh()
{

    if ( QueryUAppWindow()->InRasMode() )
    {
        return NERR_Success; // leave blank if in RAS mode
    }

    if (_fRefreshInProgress)            // Is a timer refresh running?
        return NERR_Success;            // if so, just exit

    // Let the listbox know we plan to refresh.
    // If this call succeeds then try to start the timer.
    //
    // We can reuse err for both calls since we only get to the second
    // assignment if the call to CreateNewRefreshInstance succeeds.

    APIERR err;

    if ((err = CreateNewRefreshInstance()) == NERR_Success)
    {
        _timerFastRefresh.Enable( TRUE );
        _fRefreshInProgress = TRUE;     // Set refresh in progress
    }
    else
    {
        DeleteRefreshInstance();        // Delete refresh instance
        _fRefreshInProgress = FALSE;    // Set NO refresh in progress
    }

    _fInvalidatePending = FALSE;

    return err;
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::StopRefresh

    SYNOPSIS:   This method stops a timer driven refresh.

        This is the method that ADMIN_APP::StopRefresh should call.
        If a refresh is currently running then the method
        turns off the refresh timer and then calls MarkAllAsStale
        to reset the listbox entries.  Once this method is
        called, no further RefreshNext calls will be made
        without a call to CreateNewRefreshInstance.  Otherwise,
        it simply returns.

    HISTORY:
       kevinl     25-Sep-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::StopRefresh()
{
    if (!_fRefreshInProgress)
        return;

    TurnOffRefresh();                   // Turn off refresh if running

    MarkAllAsStale();                   // Reset listbox items
}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::AddRefreshItem

    SYNOPSIS:

    HISTORY:
       kevinl     19-Aug-1991     Created
       jonn       29-Mar-1992     Fixed AddRefreshItem(NULL)
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::AddRefreshItem ( USER_LBI * plbi )
{
    INT iRet;
    APIERR err = NERR_Success;

    if ( plbi == NULL || (plbi->QueryError() != NERR_Success) )
    {
        DBGEOL( "User Manager: bad LBI in LAZY_USER_LISTBOX::AddRefreshItem" );
        return AddItem( plbi );
    }

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::AddRefreshItem(): bad or no cache" );
        return AddItem( plbi );
    }

    if ( (iRet = FindItem( *plbi )) < 0 )
    {                                   // Not Found
        SetRedraw( FALSE );
         _fInvalidatePending = TRUE;

        if ( (iRet = AddItem( plbi )) < 0 )
        {
            //  Assume out of memory
            DBGEOL("ADMIN LISTBOX: AddItem failed in AddRefreshItem");
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            USRMGR_ULC_ENTRY * pumulc = _plbicache->QueryEntryPtr( iRet );
            UIASSERT( pumulc != NULL );

            pumulc->fNotStale = TRUE;
        }
    }
    else                                // Found - Now check information
    {
        BOOL fMatch = USER_LBI::CompareAll( plbi->QueryDDU(),
                                            QueryDDU( iRet ) );

        if ( !fMatch )
        {
            TRACEEOL( "AddRefreshItem: incomplete match, replacing " << iRet );

            if ( (err = ReplaceItem( iRet, plbi )) == NERR_Success)
            {
                if ( !_fInvalidatePending )
                    InvalidateItem( iRet );
            }
        }
        else
        {
            USRMGR_ULC_ENTRY * pumulc = _plbicache->QueryEntryPtr( iRet );
            UIASSERT( pumulc != NULL );

            pumulc->fNotStale = TRUE;

            delete plbi;
        }
    }

    return err;

}


/*******************************************************************

    NAME:      LAZY_USER_LISTBOX::AddRefreshItem

    SYNOPSIS:

    HISTORY:
       jonn       30-Dec-1992   Created

********************************************************************/

APIERR LAZY_USER_LISTBOX::AddRefreshItem ( DOMAIN_DISPLAY_USER * pddu )
{
    INT iRet;
    APIERR err = NERR_Success;

    if ( pddu == NULL )
    {
        DBGEOL( "User Manager: bad DDU in LAZY_USER_LISTBOX::AddRefreshItem" );
        return ULC_ERR;
    }

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::AddRefreshItem(): bad or no cache" );
        return ULC_ERR;
    }

    if ( (iRet = FindItem( pddu )) < 0 )
    {                                   // Not Found
        SetRedraw( FALSE );
         _fInvalidatePending = TRUE;

        USER_LBI * plbi = new USER_LBI( pddu, this, TRUE );
        if ( (iRet = AddItem( plbi )) < 0 )
        {
            //  Assume out of memory
            DBGEOL("ADMIN LISTBOX: AddItem failed in AddRefreshItem");
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            USRMGR_ULC_ENTRY * pumulc = _plbicache->QueryEntryPtr( iRet );
            UIASSERT( pumulc != NULL );

            pumulc->fNotStale = TRUE;
        }
    }
    else                                // Found - Now check information
    {
        BOOL fMatch = USER_LBI::CompareAll( pddu,
                                            QueryDDU( iRet ) );

        if ( !fMatch )
        {
            TRACEEOL( "AddRefreshItem: incomplete match, replacing " << iRet );

            USER_LBI * plbi = new USER_LBI( pddu, this, TRUE );
            if ( (err = ReplaceItem( iRet, plbi )) == NERR_Success)
            {
                if ( !_fInvalidatePending )
                    InvalidateItem( iRet );
            }
        }
        else
        {
            USRMGR_ULC_ENTRY * pumulc = _plbicache->QueryEntryPtr( iRet );
            UIASSERT( pumulc != NULL );

            pumulc->fNotStale = TRUE;
        }
    }

    return err;

}



//
// The following methods originated in USER_LISTBOX
//


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::QueryDmDte

    SYNOPSIS:   Return a pointer to the display map DTE to be
                used by LBI's in this listbox

    RETURNS:    Pointer to said display map DTE

    HISTORY:
        jonn     26-Feb-1992     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

DM_DTE * LAZY_USER_LISTBOX::QueryDmDte( enum MAINUSRLB_USR_INDEX nIndex )
{
    SID_NAME_USE sidtype = SidTypeUser;
    BOOL fRemote = FALSE;

    switch (nIndex)
    {
        case MAINUSRLB_REMOTE:
            fRemote = TRUE;
            // fall through
        case MAINUSRLB_NORMAL:
            break;

        default:
            DBGEOL( "LAZY_USER_LISTBOX::QueryDmDte: bad nIndex " << (INT)nIndex );
            sidtype = SidTypeUnknown;
            break;
    }

    return ((SUBJECT_BITMAP_BLOCK &)QueryBitmapBlock()).QueryDmDte(
                                          sidtype,
                                          BMPBLOCK_DEFAULT_UISID,
                                          fRemote );

}  // LAZY_USER_LISTBOX::QueryDmDte


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::CreateNewRefreshInstance

    SYNOPSIS:   Prepares the listbox to begin a new refresh cycle

    EXIT:       On success, RefreshNext is ready to be called

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     04-Sep-1991     Created
        JonN        15-Mar-1992     Enabled NT_USER_ENUM
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::CreateNewRefreshInstance( void )
{

#ifdef WIN32

    if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL )
        return NtCreateNewRefreshInstance();


#endif // WIN32

    DBGEOL( "LAZY_USER_LISTBOX::CreateNewRefreshInstance" );

    UIASSERT( _pue10 == NULL );
    UIASSERT( _puei10 == NULL );

    _pue10 = new USER10_ENUM( QueryAppWindow()->QueryLocation() );

    if ( _pue10 == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    APIERR err = _pue10->GetInfo();
    if ( err != NERR_Success )
    {
        DeleteRefreshInstance();
        return err;
    }

    _puei10 = new USER10_ENUM_ITER( *_pue10 );
    if ( _puei10 == NULL )
    {
        DeleteRefreshInstance();
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NERR_Success;

}  // LAZY_USER_LISTBOX::CreateNewRefreshInstance


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::DeleteRefreshInstance

    SYNOPSIS:   Deletes refresh enumerators

    HISTORY:
        jonn       27-Sep-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

VOID LAZY_USER_LISTBOX::DeleteRefreshInstance()
{
DBGEOL( "LAZY_USER_LISTBOX::DeleteRefreshInstance" );

#ifdef WIN32 // NT user enumerator
    delete _pntueiter;
    _pntueiter = NULL;

    delete _pntuenum;
    _pntuenum = NULL;

#endif WIN32

    delete _puei10;
    _puei10 = NULL;

    delete _pue10;
    _pue10 = NULL;

}  // LAZY_USER_LISTBOX::DeleteRefreshInstance


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::RefreshNext

    SYNOPSIS:   This method performs the next refresh phase

    RETURNS:    An API error, which may be one of the following:
                    NERR_Success -      success
                    ERROR_MORE_DATA -   There is at least one more
                                        refresh cycle to be done

    HISTORY:
        rustanl     04-Sep-1991     Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::RefreshNext( void )
{

    if ( QueryUAppWindow()->InRasMode() )
    {
        return NERR_Success; // leave blank if in RAS mode
    }

    APIERR err = NERR_Success;

#ifdef WIN32

    if ( QueryUAppWindow()->QueryTargetServerType() != UM_DOWNLEVEL )
        return NtRefreshNext();


#endif // WIN32

    UIDEBUG( "LAZY_USER_LISTBOX::RefreshNext\n\r" );

    const USER10_ENUM_OBJ * pui10;
    while( ( pui10 = (*_puei10)( &err )) != NULL )
    {
        if ( err != NERR_Success )
            break;

        //  Note, no error checking in done at this level for the
        //  'new' and for the construction of the USER_LBI.
        //  This is because AddRefreshItem is documented to check for these.
        // CODEWORK don't create LBI if not needed
        USER_LBI * plbi = new USER_LBI( pui10->QueryName(),
                                        pui10->QueryFullName(),
                                        pui10->QueryComment(),
                                        this );
        err = AddRefreshItem( plbi );
        if ( err != NERR_Success )
        {
            UIDEBUG( "LAZY_USER_LISTBOX::RefreshNext:  AddRefreshItem failed\r\n" );
            break;
        }
    }

    DeleteRefreshInstance();

    return err;

}  // LAZY_USER_LISTBOX::RefreshNext


#ifdef WIN32

/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::NtCreateNewRefreshInstance

    SYNOPSIS:   Prepares the listbox to begin a new refresh cycle

    EXIT:       On success, RefreshNext is ready to be called

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        JonN        15-Mar-1992     Enabled NT_USER_ENUM
        JonN        21-Dec-1992     Extended for LBI cache

********************************************************************/

APIERR LAZY_USER_LISTBOX::NtCreateNewRefreshInstance( void )
{
UIDEBUG( "LAZY_USER_LISTBOX::NtCreateNewRefreshInstance\n\r" );

    UIASSERT( _pntuenum == NULL );
    UIASSERT( _pntueiter == NULL );

    APIERR err = NERR_Success;

    _pntuenum = new UM_NT_USER_ENUM(
        QueryUAppWindow()->QueryAdminAuthority()->QueryAccountDomain() );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (_pntuenum == NULL)
        || (err = _pntuenum->QueryError()) != NERR_Success
        || (err = _pntuenum->GetInfo()) != NERR_Success
       )
    {
        DeleteRefreshInstance();
        return err;
    }

    _pntueiter = new NT_USER_ENUM_ITER( *_pntuenum );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   (_pntueiter == NULL)
        || (err = _pntueiter->QueryError()) != NERR_Success
       )
    {
        DeleteRefreshInstance();
        return err;
    }

    return NERR_Success;

}  // LAZY_USER_LISTBOX::NtCreateNewRefreshInstance


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::NtRefreshNext

    SYNOPSIS:   This method performs the next refresh phase

    RETURNS:    An API error, which may be one of the following:
                    NERR_Success -      success
                    ERROR_MORE_DATA -   There is at least one more
                                        refresh cycle to be done

    HISTORY:
        JonN        15-Mar-1992     Enabled NT_USER_ENUM
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::NtRefreshNext( void )
{

    APIERR err = NERR_Success;

UIDEBUG( "LAZY_USER_LISTBOX::NtRefreshNext\n\r" );

    const NT_USER_ENUM_OBJ * pntueobj;
    BOOL fFilterNetWareUsers = ((UM_ADMIN_APP *)_paappwin)->QueryViewAcctType() & UM_VIEW_NETWARE_USERS;

    while( ( pntueobj = (*_pntueiter)(&err, TRUE)) != NULL )
    {
        if (  ( !fFilterNetWareUsers )
           || (((DOMAIN_DISPLAY_USER *) pntueobj->QueryBufferPtr())->AccountControl & USER_MNS_LOGON_ACCOUNT )
           )
        {
            err = AddRefreshItem( (DOMAIN_DISPLAY_USER *) pntueobj->QueryBufferPtr() );
            if ( err != NERR_Success )
            {
                ASSERT( err != ERROR_MORE_DATA ); // ensures that AddRefreshItem error
                                                  // does not confuse enumerator
                UIDEBUG( "LAZY_USER_LISTBOX::NtRefreshNext:  AddRefreshItem failed\r\n" );
                break;
            }
        }
    }

    if ( err != ERROR_MORE_DATA )
    {
        DeleteRefreshInstance();
    }

    return err;

}  // LAZY_USER_LISTBOX::NtRefreshNext

#endif // WIN32


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::SetSortOrder

    SYNOPSIS:   Sets the sort order in the listbox, and then resorts
                the listbox.  If a failure occurs, state of listbox
                snaps back to that prior to this call.

    ENTRY:      ulbso -     Specifies the new sort order
                fResort -   Specifies whether or not the listbox
                            should be resorted after the sort order
                            has been changed.  If FALSE, this method
                            is guaranteed to succeed.

    EXIT:       On success, sort order is set to ulbso, and, if fResort
                was TRUE, the listbox items are sorted in that order.
                On failure, the listbox, its items, and its sort order
                are left unchanged.

    RETURNS:    An API error code, which is NERR_Success on success.

    HISTORY:
        rustanl     03-Jul-1991     Created
        rustanl     16-Aug-1991     Added fResort parameter
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

APIERR LAZY_USER_LISTBOX::SetSortOrder( enum USER_LISTBOX_SORTORDER ulbso,
                                   BOOL fResort )
{
    if ( ulbso == _ulbso )
        return NERR_Success;        // sort order is the same as before

    enum USER_LISTBOX_SORTORDER ulbsoOld = _ulbso;
    _ulbso = ulbso;

    if ( ! fResort )
        return NERR_Success;

    TRACEEOL( "LAZY_USER_LISTBOX::SetSortOrder(): re-sorting" );

    APIERR err = Resort();
    if ( err != NERR_Success )
    {
        //  Listbox items remain in the previous order, sorted by ulbsoOld.
        //  Reset _ulbso to its previous value so that listbox goes back
        //  to state before this method was invoked.
        _ulbso = ulbsoOld;
    }

    return err;

}  // LAZY_USER_LISTBOX::SetSortOrder



/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::CD_VKey

    SYNOPSIS:   Switches the focus when receiving the F6 key

    ENTRY:      nVKey -         Virtual key that was pressed
                nLastPos -      Previous listbox cursor position

    RETURNS:    Return value appropriate to WM_VKEYTOITEM message:
                -2      ==> listbox should take no further action
                -1      ==> listbox should take default action
                other   ==> index of an item to perform default action

    HISTORY:
        jonn        22-Dec-1992 Copied from USRMGR_LISTBOX

********************************************************************/

INT LAZY_USER_LISTBOX::CD_VKey( USHORT nVKey, USHORT nLastPos )
{
    //  BUGBUG.  This now works on any combination of Shift/Ctrl/Alt
    //  keys with the F6 and Tab keys (except Alt-F6).  Tab, Shift-Tab,
    //  and F6 should be the only ones that should cause the focus to
    //  change.  It would be nice if this could be changed here.
    if ( nVKey == VK_F6 || nVKey == VK_TAB )
    {
        ((UM_ADMIN_APP *) QueryUAppWindow())->OnFocusChange(this );
        return -2;      // take no futher action
    }
    else
    if( nVKey == VK_F1 )
    {
        // F1 pressed, invoke app help.
        _paappwin->Command( WM_COMMAND, IDM_HELP_CONTENTS, 0 );
        return -2;      // take no futher action
    }
    else
    if (nVKey == VK_BACK)
    {
        TRACEEOL( "LAZY_USER_LISTBOX:CD_VKey: hit BACKSPACE" );
        _hawinfo._time = 0L; // reset timer
        _hawinfo._nls = SZ("");
        UIASSERT( _hawinfo._nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }


    return LAZY_LISTBOX::CD_VKey( nVKey, nLastPos );
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::CD_Char

    SYNOPSIS:   Views characters as they pass by

    ENTRY:      wch      -     Key pressed
                nLastPos -  Previous listbox cursor position

    RETURNS:    See Win SDK

    HISTORY:
        rustanl     12-Sep-1991 Created
        beng        16-Oct-1991 Win32 conversion
        jonn        28-Jul-1992 HAW-for-Hawaii code
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

INT LAZY_USER_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{

#if 0

    static const TCHAR * const psz = SZ("NT\tLAN");
    static const TCHAR * pszC = psz;
    static TCHAR * apsz[] = { SZ("IRXU4SFTFAANELF"), SZ("IRFuwsftgafnf FLxezifneos"),
                             SZ("IFqihrnsntz 9Pxrfofjredcgtk 6lhewaldh faynUd7 YpbreodgyrIafmnm4eTrs"),
                             SZ("IJKObN7NW"), SZ("IJ5ohng nN evwhmuagn!"),
                             SZ("IPfrdodgurtaimbmgehrt"), SZ("ISTIYMSOKPA"),
                             SZ("ISpiomloi sPeeNl tyotntegnd"),
                             SZ("IPrrro4gbr%afmJm eZr2"),
                             SZ("ITrHGOSM3AFSzP8Ab"),
                             SZ("ITdhgoxmbaws4 bPsavy2neee"),
                             SZ("ISsejc5oxn%dv kPerxogjlemcvte ;lee2acdg oawnqdz vphrro8gdrsacmomweer4"),
                             SZ("IYDIFHGSWISNJSX"),
                             SZ("IYhil-5Hsscinns wSruyn gz"),
                             SZ("IAsuhd4i%t# ba nidd npgoel6ikcvyx"),
                             SZ("IKAEUIITEHAMDO6"),
                             SZ("IKaehictahr eMso ogrheu"),
                             SZ("IAm aneadmkee iycouus ocsasng cter uwsytu")
                             };


    UIASSERT( *pszC != TCH('\0') );
    if ( wch == (WCHAR)*pszC )
    {
        pszC++;
        if ( *pszC == TCH('\0') )
        {
            // DeleteAllItems(); also must clear cache
            for ( INT i = 0; i < 18; i += 3 )
            {
                AddItem( new FAST_USER_LBI( apsz[ i ], apsz[ i+1 ],
                                            apsz[ i+2 ], this ));
            }
            pszC = psz;
            return -2;
        }
    }
    else
    {
        pszC = psz;
    }

#endif // 0

    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo );

}  // LAZY_USER_LISTBOX::CD_Char


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    HISTORY:
        JonN        30-Dec-1992 Templated from bltlb.cxx

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/**********************************************************************

    NAME:       LAZY_USER_LISTBOX::CD_Char_HAWforHawaii

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

        CODEWORK:  Should be moved to LAZY_LISTBOX class, where this can be
                   implemented more efficiently

    HISTORY:
        JonN        30-Dec-1992 Templated from BLT_LISTBOX
        JonN        22-Mar-1992 Move focus to first after string if miss

**********************************************************************/

INT LAZY_USER_LISTBOX::CD_Char_HAWforHawaii( WCHAR wch,
                                             USHORT nLastPos,
                                             HAW_FOR_HAWAII_INFO * phawinfo )
{
    UIASSERT( phawinfo != NULL && phawinfo->QueryError() == NERR_Success );

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::CD_Char(): bad or no cache" );
        return -2;
    }
    if (wch == VK_BACK)
    {
        TRACEEOL( "LAZY_USER_LISTBOX:HAWforHawaii: hit BACKSPACE" );
        phawinfo->_time = 0L; // reset timer
        phawinfo->_nls = SZ("");
        UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items; 
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    // CODEWORK ignoring time wraparound effects for now
    if ( (lTime - phawinfo->_time) > ThresholdTime )
    {
        TRACEEOL( "LAZY_USER_LISTBOX:HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    APIERR err = phawinfo->_nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "LAZY_USER_LISTBOX:HAWforHawaii: could not extend phawinfo->_nls" );
        nLastPos = 0;
        phawinfo->_nls = SZ("");
    }

    UIASSERT( phawinfo->_nls.QueryError() == NERR_Success );

    TRACEEOL(   "LAZY_USER_LISTBOX:HAWforHawaii: phawinfo->_nls is \""
             << phawinfo->_nls.QueryPch()
             << "\"" );

    phawinfo->_time = lTime;

    USER_LISTBOX_SORTORDER ulbso = QuerySortOrder();

    INT nReturn = -2; // take no other action

    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {

        INT nCompare = USER_LBI::W_Compare_HAWforHawaii( phawinfo->_nls,
                                                         QueryDDU( iLoop ),
                                                         ulbso );
        if ( nCompare == 0 )
        {
            TRACEEOL( "LAZY_USER_LISTBOX:HAWforHawaii: match at " << iLoop );

            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            return ( iLoop );
        }
        else if ( nCompare < 0 )
        {
            if ( nReturn < 0 )
                nReturn = iLoop;
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    if (nReturn == -2)
    {
        nReturn = clbi-1;
        TRACEEOL(
            "LAZY_USER_LISTBOX:HAWforHawaii: no exact or subsequent match, returning last item "
            << nReturn );
    }
    else
    {
        TRACEEOL(
            "LAZY_USER_LISTBOX:HAWforHawaii: no exact match, returning subsequent match "
            << nReturn );
    }

    return nReturn;
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::SelectUser

    SYNOPSIS:   Add/remove this user to/from the current selection

    ENTRY:      pchUser - username
                fSelectUser - TRUE to select, FALSE to deselect

    RETURNS:    TRUE if successful, FALSE otherwise

    HISTORY:
        jonn        24-Aug-1992 Created
        jonn        17-Dec-1992     Templated from adminlb.cxx

********************************************************************/

BOOL LAZY_USER_LISTBOX::SelectUser( const TCHAR * pchUser, BOOL fSelectUser )
{
    ASSERT( _plbicache != NULL );

    BOOL fRet = TRUE;

    INT iulbi = FindItem( pchUser );

    if ( iulbi < 0 )
    {
        //      Note, this is not (necessarily) an error; this user could
        //      have been added to the security database since last user
        //      listbox refresh.  Report using DBGEOL, though.
        DBGEOL(   "LAZY_USER_LISTBOX::SelectUser:  Could not find user "
               << pchUser );
        fRet = FALSE;
    }
    else
    {
        SelectItem( iulbi, fSelectUser );
    }

    return fRet;

}  // LAZY_USER_LISTBOX::SelectUser


//
// New cache-dependent stuff
//

/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::OnNewItem

    SYNOPSIS:   Creates a new LBI for LAZY_LISTBOX

    ENTRY:      i        -  Index of new item in listbox

    RETURNS:    LBI *

    NOTES:      This has been coded to ensure that a valid LBI is always
                returned regardless of errors.  The error LBI _pulbiError
                will mess up the sort order &c, but should prevent access
                violations.

    HISTORY:
        jonn        21-Dec-1992 Created

********************************************************************/

LBI * LAZY_USER_LISTBOX::OnNewItem( UINT i )
{
    return QueryItem(i);

}  // LAZY_USER_LISTBOX::OnNewItem


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::OnDeleteItem

    SYNOPSIS:   Releases a painted LBI for LAZY_LISTBOX

    HISTORY:
        jonn        22-Dec-1992 Created

********************************************************************/

VOID LAZY_USER_LISTBOX::OnDeleteItem( LBI *plbi )
{
   // nothing to do

}  // LAZY_USER_LISTBOX::OnDeleteItem


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::QueryItem

    SYNOPSIS:   Returns an LBI from a LAZY_USER_LISTBOX, creating it if
                necessary.  If there is an error, this will return a
                pointer to the default error LBI.

    ENTRY:      i        -  Index of item in listbox

    RETURNS:    USER_LBI *

    HISTORY:
        jonn        21-Dec-1992 Created

********************************************************************/

USER_LBI * LAZY_USER_LISTBOX::QueryItem( INT i ) const
{
    USER_LBI * plbi = _pulbiError;

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::QueryItem(): bad or no cache" );
    }
    else
    {
        USER_LBI * plbiQuery = (USER_LBI *) _plbicache->QueryItem( i );

        if ( plbiQuery == NULL || plbiQuery->QueryError() != NERR_Success )
        {
            DBGEOL( "User Manager: LAZY_USER_LISTBOX::QueryItem(): bad or no LBI" );
        }
        else
        {
            plbi = plbiQuery;

#ifdef USRMGR_TEST_QUERY_FAILURE

            if ( (i % USRMGR_TEST_QUERY_FAILURE) == 0 )
            {
                plbi = _pulbiError;
            }

#endif

        }
    }

    return plbi;


}  // LAZY_USER_LISTBOX::QueryItem


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::AddItem

    SYNOPSIS:   Adds an LBI to a LAZY_USER_LISTBOX.

    ENTRY:      pulbi   - item to add to listbox

    RETURNS:    i       - index of item in listbox, -1 on error

    HISTORY:
        jonn        21-Dec-1992 Created

********************************************************************/

INT LAZY_USER_LISTBOX::AddItem( USER_LBI * pulbi )
{
    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::AddItem(): no cache" );
        delete pulbi;
        return -1;
    }

    return _plbicache->AddItem( pulbi );

}  // LAZY_USER_LISTBOX::AddItem


INT LAZY_USER_LISTBOX::FindItem( DOMAIN_DISPLAY_USER * pddu ) const
{
    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::FindItem(): no cache" );
        return ULC_ERR;
    }

    return _plbicache->FindItem( pddu );

}  // LAZY_USER_LISTBOX::FindItem


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::ReplaceItem

    SYNOPSIS:   Replaces an LBI in a LAZY_USER_LISTBOX.  ReplaceItem
                may be relied upon to take care of pulbiNew, either by
                inserting it into the array, or by deleting it.

    ENTRY:      i       - index of item to replace
                pulbiNew - item to replace it with
                ppulbiOld - optional -- item which was replaced, if NULL
                            it is deleted

    RETURNS:    APIERR

    HISTORY:
        jonn        21-Dec-1992 Created

********************************************************************/

APIERR LAZY_USER_LISTBOX::ReplaceItem(  INT i,
                                        USER_LBI * pulbiNew,
                                        USER_LBI * * ppulbiOld )
{
    TRACEEOL( "LAZY_USER_LISTBOX::ReplaceItem( " << i << ")" );

    APIERR err = NERR_Success;

    if ( ppulbiOld != NULL )
        *ppulbiOld = NULL;

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::ReplaceItem(): no cache" );
        delete pulbiNew;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    USER_LBI * pulbiOld = (USER_LBI *)_plbicache->RemoveItem(i);
    if ( pulbiOld == NULL )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::ReplaceItem(): remove failed" );
        delete pulbiNew;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INT iRet;
    if ( (iRet = AddItem(pulbiNew)) < 0 )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::ReplaceItem(): add failed" );
        // try to reinsert
        if ( AddItem( pulbiOld ) >= 0 )
            pulbiOld = NULL;
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        USRMGR_ULC_ENTRY * pumulc = _plbicache->QueryEntryPtr( iRet );
        UIASSERT( pumulc != NULL );

        pumulc->fNotStale = TRUE;
    }

    if (ppulbiOld == NULL)
    {
        // no one wants it, delete it
        delete pulbiOld;
    }
    else
    {
        *ppulbiOld = pulbiOld;
    }

    ASSERT( QueryCount() == _plbicache->QueryCount() );

    return err;

}  // LAZY_USER_LISTBOX::ReplaceItem


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::Resort

    SYNOPSIS:   Resorts the listbox

    EXIT:       On success, the items in the listbox resorted according
                to the current sort order.
                On failure, the order of the listbox items are left
                unchanged.

    RETURNS:    An API error, which is NERR_Success on success.

    HISTORY:
        jonn        21-Dec-1992 Templated from BLT_LISTBOX

********************************************************************/

APIERR LAZY_USER_LISTBOX::Resort()
{

    if ( _plbicache == NULL || _plbicache->QueryError() != NERR_Success )
    {
        DBGEOL( "User Manager: LAZY_USER_LISTBOX::Resort(): no cache" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    AUTO_CURSOR autocur;        // this may take a while

    SetRedraw( FALSE );

    _plbicache->Sort();

    SetRedraw( TRUE );

    Invalidate();

    return NERR_Success;
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::ZapListbox

    SYNOPSIS:   Clears the cache, to optimize the next read

    HISTORY:
        jonn        21-Dec-1992 Templated from BLT_LISTBOX

********************************************************************/

APIERR LAZY_USER_LISTBOX::ZapListbox( void )
{
    // create an empty cache
    USRMGR_LBI_CACHE * plbicacheNew = new USRMGR_LBI_CACHE(); // initially empty
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   plbicacheNew == NULL
        || (err = plbicacheNew->QueryError()) != NERR_Success
       )
    {
        DBGEOL( "LAZY_USER_LISTBOX::ZapListbox failed with error " << err );
        delete plbicacheNew;
    }
    else
    {
        delete _plbicache;
        _plbicache = plbicacheNew;
        _plbicache->AttachListbox( this );
        SetCount( 0 );
        Invalidate();
    }

    return err;
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::ChangeFont

    SYNOPSIS:   Makes all changes associated with a font change

    HISTORY:
        jonn        23-Sep-1993     Created

********************************************************************/

APIERR LAZY_USER_LISTBOX::ChangeFont( HINSTANCE hmod, FONT & font )
{
    ASSERT(   font.QueryError() == NERR_Success
           && _padColUsername != NULL
           && _padColUsername->QueryError() == NERR_Success
           && _padColFullname != NULL
           && _padColFullname->QueryError() == NERR_Success
           );

    SetFont( font, TRUE );

    APIERR err = _padColUsername->ReloadColumnWidths( QueryHwnd(),
                                                      hmod,
                                                      ID_USERNAME );
    if (err == NERR_Success)
    {
        err = _padColFullname->ReloadColumnWidths( QueryHwnd(),
                                                   hmod,
                                                   ID_FULLNAME );
    }

    UINT nHeight;
    if (   err != NERR_Success
        || (err = (CalcFixedHeight( QueryHwnd(), &nHeight ))
                        ? NERR_Success
                        : ERROR_GEN_FAILURE) != NERR_Success
       )
    {
        DBGEOL( "LAZY_USER_LISTBOX::ChangeFont: reload/calc error " << err );
    }

    if (err == NERR_Success)
    {
        (void) Command( LB_SETITEMHEIGHT, (WPARAM)0, (LPARAM)nHeight );
    }

    return err;
}


/*******************************************************************

    NAME:       LAZY_USER_LISTBOX::QueryBitmapBlock

    SYNOPSIS:

    HISTORY:
        jonn        04-Oct-1993     Created

********************************************************************/

const SUBJECT_BITMAP_BLOCK & LAZY_USER_LISTBOX::QueryBitmapBlock() const
{
    return QueryUAppWindow()->QueryBitmapBlock();
}





/*******************************************************************

    NAME:       LAZY_USER_SELECTION::LAZY_USER_SELECTION

    SYNOPSIS:   LAZY_USER_SELECTION constructor

    ENTRY:      alb -       Listbox which contains the items of
                            interest
                fAll -      Indicates whether or not all listbox items
                            in the given listbox are to be used in
                            the LAZY_USER_SELECTION, or if only those
                            items selected should.

                            TRUE means use all items.
                            FALSE means use only selected items.

                            Default value is FALSE.

    HISTORY:
        jonn        20-Dec-1992     Templated from ADMIN_SELECTION

********************************************************************/

LAZY_USER_SELECTION::LAZY_USER_SELECTION( LAZY_USER_LISTBOX & alb,
                                          BOOL fAll )
    :   _alb( alb ),
        _clbiSelection( 0 ),
        _piSelection( NULL ),
        _fAll( fAll )
{
    // This _must_ be done before any return statement, since the dtor
    // will always UnlockRefresh().
    _alb.LockRefresh();

    if ( QueryError() != NERR_Success )
        return;

    if ( _fAll )
    {
        _clbiSelection = (UINT)alb.QueryCount();
    }
    else
    {
        _clbiSelection = (UINT)alb.QuerySelCount();

        if ( _clbiSelection > 0 )
        {
            _piSelection = new UINT[ _clbiSelection ];
            if ( _piSelection == NULL )
            {
                DBGEOL("LAZY_USER_SELECTION ct:  Out of memory");
                ReportError( ERROR_NOT_ENOUGH_MEMORY );
                return;
            }

            APIERR err = _alb.QuerySelItems(
                (INT *)_piSelection,
                (INT)_clbiSelection
                );
            if ( err != NERR_Success )
            {
                ReportError( err );
                return;
            }
        }
    }
}


/*******************************************************************

    NAME:       LAZY_USER_SELECTION::~LAZY_USER_SELECTION

    SYNOPSIS:   LAZY_USER_SELECTION destructor

    HISTORY:
        rustanl     07-Aug-1991     Created
        jonn        20-Dec-1992     Templated from ADMIN_SELECTION

********************************************************************/

LAZY_USER_SELECTION::~LAZY_USER_SELECTION()
{
    // This _must_ be done before any return statement, since the ctor
    // will always LockRefresh().
    _alb.UnlockRefresh();

    delete _piSelection;
    _piSelection = NULL;
}


/*******************************************************************

    NAME:       LAZY_USER_SELECTION::QueryIndex

    SYNOPSIS:   Returns the index of a selected item

    ENTRY:      i -     A valid index into the pool of items in the selection

    RETURNS:    The index of the specified item

    HISTORY:
        jonn        13-Sep-1994     Created

********************************************************************/

UINT LAZY_USER_SELECTION::QueryIndex( UINT i ) const
{
    UIASSERT( i < QueryCount() );

    if ( ! _fAll )
        i = _piSelection[ i ];

    return i;
}


/*******************************************************************

    NAME:       LAZY_USER_SELECTION::QueryItem

    SYNOPSIS:   Returns a selected item

    ENTRY:      i -     A valid index into the pool of items in the selection

    RETURNS:    A pointer to the name of the specified item

    HISTORY:
        jonn        09-Mar-1992     Created
        jonn        20-Dec-1992     Templated from ADMIN_SELECTION

********************************************************************/

const USER_LBI * LAZY_USER_SELECTION::QueryItem( UINT i ) const
{
    return (USER_LBI *)_alb.QueryItem( QueryIndex(i) );
}


/*******************************************************************

    NAME:       LAZY_USER_SELECTION::QueryItemName

    SYNOPSIS:   Returns the name of a selected item

    ENTRY:      i -     A valid index into the pool of items in the selection

    RETURNS:    A pointer to the name of the specified item

    HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support
        rustanl     16-Aug-1991     Added support for _fAll parameter
        jonn        09-Mar-1992     Uses QueryItem
        jonn        20-Dec-1992     Templated from ADMIN_SELECTION

********************************************************************/

const TCHAR * LAZY_USER_SELECTION::QueryItemName( UINT i ) const
{
    const USER_LBI * pulbi = QueryItem( i );
    return (pulbi != NULL) ? pulbi->QueryName() : SZ("");
}


/*******************************************************************

    NAME:       LAZY_USER_SELECTION::QueryCount

    SYNOPSIS:   Returns the number of items in the selection

    RETURNS:    The number of items in the selection

    HISTORY:
        rustanl     17-Jul-1991     Created
        rustanl     07-Aug-1991     Added initial mult sel support
        jonn        20-Dec-1992     Templated from ADMIN_SELECTION

********************************************************************/

UINT LAZY_USER_SELECTION::QueryCount() const
{
    return _clbiSelection;
}


/*******************************************************************

    NAME:       LUSRLB_SAVE_SELECTION::QueryItemIdent

    SYNOPSIS:   returns username for item

    HISTORY:
        jonn        13-Oct-1993     Created

********************************************************************/

const TCHAR * LUSRLB_SAVE_SELECTION::QueryItemIdent( INT i )
{
    const TCHAR * pchReturn = NULL;

    USER_LBI * pulbi = QueryListbox()->QueryItem( i );
    if ( pulbi != NULL && pulbi->QueryError() == NERR_Success )
    {
        pchReturn = pulbi->QueryAccount();
    }

    return pchReturn;
}


/*******************************************************************

    NAME:       LUSRLB_SAVE_SELECTION::FindItemIdent

    SYNOPSIS:   finds item with username

    HISTORY:
        jonn        13-Oct-1993     Created

********************************************************************/

INT LUSRLB_SAVE_SELECTION::FindItemIdent( const TCHAR * pchIdent )
{
    return QueryListbox()->FindItem( pchIdent );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\ncp.cxx ===
/**********************************************************************/
/**           Microsoft Windows NT               **/
/**          Copyright(c) Microsoft Corp., 1991                      **/
/**********************************************************************/

/*
 *   ncp.cxx
 *   This module contains the Netware Properties dialog.
 *
 *   FILE HISTORY:
 *           CongpaY 01-Oct-1993  Created
 */

#include <ntincl.hxx>
extern "C"
{
   #include <ntsam.h>  // for USER_LBI to compile
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETLIB
#define INCL_NETACCESS  // for UF_NORMAL_ACCOUNT etc in ntuser.hxx
#include <lmui.hxx>
#include <lmomod.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

extern "C"
{
    #include <mnet.h>
    #include <umhelpc.h>
    #include <fpnwcomm.h>
    #include <dllfunc.h>
    #include <fpnwname.h>
}

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <strnumer.hxx>
#include <usrmgrrc.h>
#include <lmsvc.hxx>
#include <ncp.hxx>
#include <security.hxx>
#include <nwuser.hxx>
#include <dbgstr.hxx>

#define DEFAULT_MAX_CONNECTIONS           1
#define DEFAULT_MAX_CONNECTIONS_LOW_RANGE 1
#define DEFAULT_MAX_CONNECTIONS_UP_RANGE  1000

#define DEFAULT_GRACE_LOGIN_LOW_RANGE 1
#define DEFAULT_GRACE_LOGIN_UP_RANGE  200

#define SZ_MAIL_DIR         SZ("MAIL\\")
#define SZ_LOGIN_FILE       SZ("\\LOGIN")

#define NO_GRACE_LOGIN_LIMIT 0xFF

/*******************************************************************

    NAME:   NCP_DIALOG::NCP_DIALOG

    SYNOPSIS:   Constructor for NetWare Properties dialog

    ENTRY:  puserpropdlgParent - pointer to parent properties dialog

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

NCP_DIALOG::NCP_DIALOG(
    USERPROP_DLG * puserpropdlgParent,
    const LAZY_USER_LISTBOX * pulb
    ) : USER_SUBPROP_DLG(
        puserpropdlgParent,
        MAKEINTRESOURCE( IDD_NCPDLG ),
        pulb,
        TRUE    // Use Ansi form of dialog to canonicalize the computernames
        ),
    _fSingleUserSelect              ( FALSE ),
    _fIndeterminateGraceLoginAllowed( FALSE ),
    _fIndetNowGraceLogin            ( FALSE ),
    _fIndeterminateGraceLoginRemaining ( FALSE ),
    _fIndeterminateMaxConnections   ( FALSE ),
    _fIndetNowMaxConnections        ( FALSE ),
    _fIndeterminateNWPasswordExpired( FALSE ),
    _fIndetNowNWPasswordExpired     ( FALSE ),
    _fNWPasswordExpired             ( FALSE ),
    _fNWPasswordExpiredChanged      ( FALSE ),
    _ushGraceLoginAllowed           ( DEFAULT_GRACELOGINALLOWED ),
    _ushGraceLoginRemaining         ( DEFAULT_GRACELOGINALLOWED ),
    _ushMaxConnections              ( DEFAULT_MAXCONNECTIONS),

    _cbNWPasswordExpired            ( this, IDNCP_CB_PASSWORD_EXPIRED),
    _mgrpMasterGraceLogin           ( this, IDNCP_RB_NO_GRACE_LOGIN_LIMIT, 2,
                                      IDNCP_RB_NO_GRACE_LOGIN_LIMIT),
        _spsleGraceLoginAllowed     ( this,
                                      IDNCP_SLE_GRACE_LOGIN_ALLOWED,
                                      DEFAULT_GRACELOGINALLOWED,
                                      DEFAULT_GRACE_LOGIN_LOW_RANGE,
                                      DEFAULT_GRACE_LOGIN_UP_RANGE,
                                      TRUE,
                                      IDNCP_FRAME_GRACE_LOGIN_ALLOWED ),
        _spgrpGraceLoginAllowed     ( this, IDNCP_SPINB_GROUP_GRACE_LOGIN,
                                      IDNCP_SPINB_UP_ARROW_GRACE_LOGIN,
                                      IDNCP_SPINB_DOWN_ARROW_GRACE_LOGIN),
        _sltGraceLoginAllow         ( this, IDNCP_ST_GRACE_LOGIN_ALLOW),
        _sltGraceLogin              ( this, IDNCP_ST_GRACE_LOGIN),
        _sltGraceLoginRemaining     ( this, IDNCP_ST_GRACE_LOGIN_REMAINING),
        _sleGraceLoginRemaining     ( this, IDNCP_ST_GRACE_LOGIN_NUM),
    _mgrpMaster                     ( this, IDNCP_RB_NO_LIMIT, 2,
                                      IDNCP_RB_NO_LIMIT ),
        _spsleMaxConnections        ( this,
                                      IDNCP_SLE_MAX_CONNECTIONS,
                                      DEFAULT_MAX_CONNECTIONS,
                                      DEFAULT_MAX_CONNECTIONS_LOW_RANGE,
                                      DEFAULT_MAX_CONNECTIONS_UP_RANGE,
                                      TRUE,
                                      IDNCP_FRAME_MAX_CONNECTIONS ),
        _spgrpMaxConnections        ( this, IDNCP_SPINB_GROUP_MAX_CONNECTIONS,
                                      IDNCP_SPINB_UP_ARROW_MAX_CONNECTIONS,
                                      IDNCP_SPINB_DOWN_ARROW_MAX_CONNECTIONS),

    _sltObjectID                    ( this, IDNCP_SLT_OBJECTID),
    _sltObjectIDText                ( this, IDNCP_SLT_OBJECTID_TEXT),
    _pbLoginScript                  ( this, IDNCP_PB_LOGIN_SCRIPT)
{
    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    //
    // Set the default grace login remaining in the SLE first, so that
    // the magic group will have the initial value.
    //
    DEC_STR nlsGraceLoginRemaining (_ushGraceLoginRemaining);
    if ((err = nlsGraceLoginRemaining.QueryError()) != NERR_Success)
    {
        ReportError( err );
    }
    _sleGraceLoginRemaining.SetText (nlsGraceLoginRemaining);

    //
    // Set the associations of controls with the magic groups
    //

    if ((( err = _mgrpMaster.QueryError() ) != NERR_Success) ||
        (( err = _spgrpMaxConnections.AddAssociation (&_spsleMaxConnections)) != NERR_Success) ||
        (( err = _mgrpMaster.AddAssociation (IDNCP_RB_LIMIT, &_spgrpMaxConnections)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.QueryError() ) != NERR_Success) ||
        (( err = _spgrpGraceLoginAllowed.AddAssociation (&_spsleGraceLoginAllowed)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.AddAssociation (IDNCP_RB_LIMIT_GRACE_LOGIN, &_sltGraceLoginAllow)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.AddAssociation (IDNCP_RB_LIMIT_GRACE_LOGIN, &_sltGraceLogin)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.AddAssociation (IDNCP_RB_LIMIT_GRACE_LOGIN, &_sltGraceLoginRemaining)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.AddAssociation (IDNCP_RB_LIMIT_GRACE_LOGIN, &_sleGraceLoginRemaining)) != NERR_Success) ||
        (( err = _mgrpMasterGraceLogin.AddAssociation (IDNCP_RB_LIMIT_GRACE_LOGIN, &_spgrpGraceLoginAllowed)) != NERR_Success))
    {
        ReportError (err);
    }


}// NCP_DIALOG::NCP_DIALOG


/*******************************************************************

    NAME:   NCP_DIALOG::~NCP_DIALOG

    SYNOPSIS:   Destructor for NetWare Properties dialog

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/
NCP_DIALOG::~NCP_DIALOG()
{
}// NCP_DIALOG::~NCP_DIALOG


/*******************************************************************

    NAME:       NCP_DIALOG::W_LMOBJtoMembers

    SYNOPSIS:   Loads class data members from initial data

    ENTRY:  Index of user to examine.  W_LMOBJToMembers expects to be
        called once for each user, starting from index 0.

    RETURNS:    error code

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

APIERR NCP_DIALOG::W_LMOBJtoMembers ( UINT iObject )
{
    USER_NW * puserNW = QueryUserNWPtr( iObject );
    UIASSERT( (puserNW != NULL) && (puserNW->QueryError() == NERR_Success));

    APIERR err;
    ULONG  ulNWPasswordAge;

    USER_MODALS umInfo (QueryLocation().QueryServer());
    if ((err = umInfo.GetInfo()) != NERR_Success)
        return err;

    ULONG ulPasswordAgeAllowed = umInfo.QueryMaxPasswdAge();

    if ( iObject == 0 ) // first object
    {
        _fSingleUserSelect = TRUE;

        if (((err = puserNW->QueryMaxConnections(&_ushMaxConnections)) != NERR_Success) ||
            ((err = puserNW->QueryGraceLoginAllowed(&_ushGraceLoginAllowed)) != NERR_Success) ||
            ((err = puserNW->QueryGraceLoginRemainingTimes(&_ushGraceLoginRemaining)) != NERR_Success) ||
            ((err = puserNW->QueryNWPasswordAge(&ulNWPasswordAge))!= NERR_Success))
        {
            return err;
        }

        _fNWPasswordExpired =  (ulNWPasswordAge >= ulPasswordAgeAllowed);

        //
        // figure out the object ID to display.
        //
        if ((err = CallMapRidToObjectId (
                          puserNW->QueryUserId(),
                          (LPWSTR) puserNW->QueryName(),
                          QueryTargetServerType() == UM_LANMANNT,
                          FALSE,
                          &_ulObjectId)) != NERR_Success)
        {
            return err;
        }

        if (_ulObjectId != SUPERVISOR_USERID)
        {
            if ((err = CallSwapObjectId(_ulObjectId, &_ulObjectId)) != NERR_Success)
            {
                return err;
            }
        }
    }
    else    // iObject > 0
    {
        _fSingleUserSelect = FALSE;

        if ( !_fIndeterminateGraceLoginAllowed )
        {
            USHORT ushGraceLoginAllowed;
            if ((err = puserNW->QueryGraceLoginAllowed(&ushGraceLoginAllowed)) != NERR_Success)
            {
                return err;
            }

            if ( _ushGraceLoginAllowed != ushGraceLoginAllowed )
            {
                _ushGraceLoginAllowed = DEFAULT_GRACELOGINALLOWED;
                _fIndeterminateGraceLoginAllowed = TRUE;
            }
        }

        if ( !_fIndeterminateGraceLoginRemaining)
        {
            USHORT ushGraceLoginRemaining;
            if ((err = puserNW->QueryGraceLoginRemainingTimes(&ushGraceLoginRemaining)) != NERR_Success)
            {
                return err;
            }

            if ( _ushGraceLoginRemaining != ushGraceLoginRemaining )
            {
                _fIndeterminateGraceLoginRemaining = TRUE;
            }
        }

        if ( !_fIndeterminateMaxConnections )
        {
            USHORT ushMaxConnections;
            if ((err = puserNW->QueryMaxConnections(&ushMaxConnections)) != NERR_Success)
            {
                return err;
            }

            if ( _ushMaxConnections != ushMaxConnections )
            {
                _fIndeterminateMaxConnections = TRUE;
            }
        }

        if ( !_fIndeterminateNWPasswordExpired )
        {
            if ((err = puserNW->QueryNWPasswordAge(&ulNWPasswordAge)) != NERR_Success)
            {
                return err;
            }

            if ( _fNWPasswordExpired != (ulNWPasswordAge >= ulPasswordAgeAllowed))
            {
                _fIndeterminateNWPasswordExpired = TRUE;
            }
        }
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );

} // NCP_DIALOG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       NCP_DIALOG::InitControls

    SYNOPSIS:   Initializes the controls maintained by NCP_DIALOG,
        according to the values in the class data members.

    RETURNS:    An error code which is NERR_Success on success.

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

APIERR NCP_DIALOG::InitControls()
{
    APIERR err;

    if (  !_fIndeterminateGraceLoginAllowed
       && !_fIndeterminateGraceLoginRemaining )
    {
        if ((err = _spsleGraceLoginAllowed.SetSaveValue (_ushGraceLoginAllowed)) != NERR_Success)
        {
            return err;
        }
        _spsleGraceLoginAllowed.Update();

        if (_ushGraceLoginRemaining == 0xFF)
        {
            _mgrpMasterGraceLogin.SetSelection (IDNCP_RB_NO_GRACE_LOGIN_LIMIT);
        }
        else
        {
            DEC_STR nlsGraceLoginRemaining (_ushGraceLoginRemaining);
            if ((err = nlsGraceLoginRemaining.QueryError()) != NERR_Success)
            {
                return err;
            }
            _sleGraceLoginRemaining.SetText (nlsGraceLoginRemaining);

            _mgrpMasterGraceLogin.SetSelection (IDNCP_RB_LIMIT_GRACE_LOGIN);
        }
    }
    else
    {
        _mgrpMasterGraceLogin.SetSelection (RG_NO_SEL);
    }

    if ( !_fIndeterminateMaxConnections )
    {
        if( _ushMaxConnections == NO_LIMIT)  // There is no limit on max connections.
        {
            _mgrpMaster.SetSelection( IDNCP_RB_NO_LIMIT);
        }
        else
        {
            if (( err = _spsleMaxConnections.SetSaveValue (_ushMaxConnections)) != NERR_Success)
            {
                return err;
            }
            _spsleMaxConnections.Update();

            _mgrpMaster.SetSelection( IDNCP_RB_LIMIT );

        }
    }
    else
    {
        _mgrpMaster.SetSelection (RG_NO_SEL);
    }

    RESOURCE_STR nlsFPNWName( IDS_FPNW_SVC_ACCOUNT_NAME );
    if ( (err = nlsFPNWName.QueryError()) != NERR_Success )
        return err;

    if ( !_fIndeterminateNWPasswordExpired )
    {
        _cbNWPasswordExpired.SetCheck (_fNWPasswordExpired);
        _cbNWPasswordExpired.EnableThirdState (FALSE);
    }
    else
    {
        _cbNWPasswordExpired.SetIndeterminate ();
    }

    //
    // if we have multi selection or user not yet created, dont show.
    // else simply convert to hex string. in the case user has not been
    // created, rid is zero, so all we have is the bias or zero.
    //
    if (_fSingleUserSelect)
    {

        //
        // we only allow the edit login script button if FPNW is installed
        // and we have the client side dll to talk to FPNW.
        // CODEWORK: it is questionable whether the button should be
        // hidden in this case or merely disabled.  JonN 1/3/96
        //
        if ( LoadFpnwClntDll() != NERR_Success )
        {
            TRACEEOL( "NCP_DIALOG::InitControls: hiding _pbLoginScript" );
            _pbLoginScript.Show(FALSE);
        }

        DWORD ulRemoteDomainBiasObjectId;
        if ((err = CallSwapObjectId(BINDLIB_REMOTE_DOMAIN_BIAS, &ulRemoteDomainBiasObjectId)) != NERR_Success)
            return err;

        if ((_ulObjectId != ulRemoteDomainBiasObjectId) &&
            (_ulObjectId != 0x00000000))
        {
            HEX_STR nlsObjectId (_ulObjectId, 8);
            _sltObjectID.SetText(nlsObjectId);
        }
        else
        {
            _pbLoginScript.Enable(FALSE);
            _sltObjectIDText.Enable(FALSE);
            _sltObjectID.SetText(SZ(""));
        }

        // Disable the edit login script button if fpnw service is not running.
        LM_SERVICE svc( QueryLocation().QueryServer(), NW_SERVER_SERVICE);
        if ((svc.QueryError() != NERR_Success) || !svc.IsStarted())
            _pbLoginScript.Enable(FALSE);
    }
    else
    {
        _sltObjectID.Show(FALSE);
        _sltObjectIDText.Show(FALSE);
        _pbLoginScript.Show(FALSE);
    }


    if ((err = USER_SUBPROP_DLG::InitControls()) != NERR_Success)
    {
        return err;
    }
    else if (_fIndeterminateGraceLoginAllowed)
    {
        ASSERT( QueryObjectCount() > 1 );
        ASSERT( _plbLogonName != NULL );
        SetDialogFocus( *_plbLogonName );
    }
    else
    {
        CID nSelection = _mgrpMasterGraceLogin.QuerySelection();
        if ( nSelection != RG_NO_SEL )
        {
            SetDialogFocus( *(_mgrpMasterGraceLogin[nSelection]) );
        }
        else // Should be multi-select since there is no selection
        {
            ASSERT( QueryObjectCount() > 1 );
            ASSERT( _plbLogonName != NULL );
            SetDialogFocus( *_plbLogonName );
        }

    }

    return NERR_Success;

} // NCP_DIALOG::InitControls


/*******************************************************************

    NAME:       NCP_DIALOG::W_DialogToMembers

    SYNOPSIS:   Loads data from dialog into class data members

    RETURNS:    error message (not necessarily an error code)

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

APIERR NCP_DIALOG::W_DialogToMembers()
{

    switch( _mgrpMasterGraceLogin.QuerySelection() )
    {
    case IDNCP_RB_NO_GRACE_LOGIN_LIMIT:
        _fIndetNowGraceLogin = FALSE;
        _ushGraceLoginRemaining = NO_GRACE_LOGIN_LIMIT;
        _ushGraceLoginAllowed = DEFAULT_GRACELOGINALLOWED;
        break;
    case IDNCP_RB_LIMIT_GRACE_LOGIN:
    {
        _fIndetNowGraceLogin = FALSE;

        ULONG ulGraceLoginAllowed;
        _spsleGraceLoginAllowed.QueryContent(&ulGraceLoginAllowed);
        _ushGraceLoginAllowed = (USHORT) ulGraceLoginAllowed;

        APIERR err;
        NLS_STR nlsGraceLoginRemaining;
        if (((err = nlsGraceLoginRemaining.QueryError()) != NERR_Success) ||
            ((err = _sleGraceLoginRemaining.QueryText(&nlsGraceLoginRemaining)) != NERR_Success))
            return err;

        _ushGraceLoginRemaining = (USHORT)nlsGraceLoginRemaining.atoul();
        if (  _ushGraceLoginRemaining == 0
           || (_ushGraceLoginRemaining > _ushGraceLoginAllowed)
           )
        {
            _sleGraceLoginRemaining.SelectString();
            _sleGraceLoginRemaining.ClaimFocus();
            return IDS_REMAINING_OUT_OF_RANGE;
        }

        break;
    }
    case RG_NO_SEL:
        _fIndetNowGraceLogin = TRUE;
        break;
    }

    switch( _mgrpMaster.QuerySelection() )
    {
    case IDNCP_RB_NO_LIMIT:
        _fIndetNowMaxConnections = FALSE;
        _ushMaxConnections = NO_LIMIT;
        break;
    case IDNCP_RB_LIMIT:
        ULONG ulTmp;
        _fIndetNowMaxConnections = FALSE;
        _spsleMaxConnections.QueryContent(&ulTmp);
        _ushMaxConnections = (USHORT) ulTmp;
        break;
    case RG_NO_SEL:
        _fIndetNowMaxConnections = TRUE;
        break;
    }

    _fIndetNowNWPasswordExpired =  _cbNWPasswordExpired.IsIndeterminate();
    if ( !_fIndetNowNWPasswordExpired )
    {
        if (_fNWPasswordExpired != _cbNWPasswordExpired.IsChecked())
        {
            _fNWPasswordExpiredChanged = TRUE;
            _fNWPasswordExpired = !_fNWPasswordExpired;
        }
        else if (_fIndetNowNWPasswordExpired!= _fIndeterminateNWPasswordExpired)
        {
            _fNWPasswordExpiredChanged = TRUE;
        }
    }

    return USER_SUBPROP_DLG::W_DialogToMembers();

} // NCP_DIALOG::W_DialogToMembers


/*******************************************************************

    NAME:       NCP_DIALOG::ChangesUser2Ptr

    SYNOPSIS:   Checks whether W_MembersToLMOBJ changes the USER_2
                for this object.

    ENTRY:  index to object

    RETURNS:    TRUE iff USER_2 is changed

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

BOOL NCP_DIALOG::ChangesUser2Ptr (UINT iObject)
{
    UNREFERENCED (iObject);
    return TRUE;
}

/*******************************************************************

    NAME:       NCP_DIALOG::W_MembersToLMOBJ

    SYNOPSIS:   Loads class data members into the USER_2 object
                Only UserParms field is changed.

    ENTRY:  puser2      - pointer to a USER_2 to be modified

        pusermemb   - pointer to a USER_MEMB to be modified

    RETURNS:    error code

    NOTES:  If some fields were different for multiply-selected
            objects, the initial contents of the edit fields
        contained only a default value.  In this case, we only
        want to change the LMOBJ if the value of the edit field
        has changed.  This is also important for "new" variants,
        where PerformOne will not always copy the object and
        work with the copy.

    HISTORY:
            CongpaY 01-Oct-1993 Created

********************************************************************/

APIERR NCP_DIALOG::W_MembersToLMOBJ(
    USER_2 *    puser2,
    USER_MEMB * pusermemb )
{
    APIERR err;

    if ( !_fIndetNowMaxConnections )
    {
        if ( (err = ((USER_NW *)puser2)->SetMaxConnections(_ushMaxConnections, TRUE)) != NERR_Success )
        return err;
    }

    if ( !_fIndetNowGraceLogin)
    {
        if ((err = ((USER_NW *)puser2)->SetGraceLoginAllowed(_ushGraceLoginAllowed, TRUE)) != NERR_Success )
            return err;

        if ((err = ((USER_NW *)puser2)->SetGraceLoginRemainingTimes(_ushGraceLoginRemaining, TRUE)) != NERR_Success )
        {
            return err;
        }
    }

    if ( (!_fIndetNowNWPasswordExpired) && _fNWPasswordExpiredChanged)
    {
        if ((err = ((USER_NW *)puser2)->SetNWPasswordAge(_fNWPasswordExpired)) != NERR_Success )
        return err;
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// NCP_DIALOG::W_MembersToLMOBJ

/*******************************************************************

    NAME:       NCP_DIALOG::OnCommand

    SYNOPSIS:   Handles LOGIN_SCRIPT pushbutton.

    RETURNS:    TRUE is action is taken
                FALSE otherwise

    NOTE:

    HISTORY:
                   CongpaY  4-Oct-1993    created

********************************************************************/
BOOL NCP_DIALOG::OnCommand (const CONTROL_EVENT & ce)
{
    switch (ce.QueryCid())
    {
    case IDNCP_PB_LOGIN_SCRIPT:
        OnLoginScript();
        break;

    case IDNCP_SLE_GRACE_LOGIN_ALLOWED:
    {
        ULONG ulGraceLoginAllowed;
        _spsleGraceLoginAllowed.QueryContent(&ulGraceLoginAllowed);

        BOOL fSetGraceLoginRemaining = (_ushGraceLoginAllowed
                                     != (SHORT)ulGraceLoginAllowed);

        if (fSetGraceLoginRemaining)
        {
            _ushGraceLoginAllowed = (SHORT) ulGraceLoginAllowed;
            DEC_STR nlsGraceLoginRemaining (ulGraceLoginAllowed);

            APIERR err;
            if ((err = nlsGraceLoginRemaining.QueryError()) != NERR_Success)
            {
                ::MsgPopup (this, err);
                return TRUE;
            }
            else
                _sleGraceLoginRemaining.SetText (nlsGraceLoginRemaining);
        }

        break;
    }

    default:
        break;
    }

    return USER_SUBPROP_DLG::OnCommand (ce);
}

/*******************************************************************

    NAME:       NCP_DIALOG::OnLoginScript

    SYNOPSIS:   Handles LOGIN_SCRIPT pushbutton.

    NOTE:

    HISTORY:
                   CongpaY  4-Oct-1993    created

********************************************************************/
VOID NCP_DIALOG::OnLoginScript (VOID)
{
    APIERR err = NERR_Success;
    do
    {
        LPCTSTR lpServer = QueryLocation().QueryServer();

        NLS_STR nlsLoginScriptFile(SZ(""));
        HEX_STR nlsObjectID (_ulObjectId);

        if (((err = nlsLoginScriptFile.QueryError())!= NERR_Success) ||
            ((err = nlsObjectID.QueryError())!= NERR_Success))
            break;

        if (lpServer != NULL)
        {
            if (((err = nlsLoginScriptFile.CopyFrom (lpServer))!= NERR_Success) ||
                ((err = nlsLoginScriptFile.AppendChar(TCH('\\')))!= NERR_Success))
                break;
        }

        PFPNWVOLUMEINFO lpnwVolInfo ;

        if (((err = ::CallNwVolumeGetInfo((LPTSTR) lpServer,
                                      SYSVOL_NAME_STRING,
                                      1,
                                      &lpnwVolInfo)) != NERR_Success) ||
            ((err = nlsLoginScriptFile.Append(lpnwVolInfo->lpPath)) != NERR_Success))
            break;

        // If the last character of the path is not '\\', append it.
        if (*(nlsLoginScriptFile.QueryPch()+nlsLoginScriptFile.QueryTextLength()-1) != TCH('\\'))
        {
            if ((err = nlsLoginScriptFile.AppendChar(TCH('\\'))) != NERR_Success)
                break;
        }

        if (((err = nlsLoginScriptFile.Append(SZ_MAIL_DIR)) != NERR_Success) ||
            ((err = nlsLoginScriptFile.Append(nlsObjectID)) != NERR_Success) ||
            ((err = nlsLoginScriptFile.Append(SZ_LOGIN_FILE)) != NERR_Success))
            break;

        if (lpServer != NULL)
        {
            LPTSTR  pszColon ;
            if (!(pszColon = strchrf(nlsLoginScriptFile.QueryPch(), TCH(':'))))
            {
                err = ERROR_INVALID_PARAMETER ;
                break;
            }

            *pszColon = TCH('$') ;
        }

        LOGIN_SCRIPT_DLG * pdlg = new LOGIN_SCRIPT_DLG (this->QueryHwnd(),
                                                        nlsLoginScriptFile.QueryPch());

        err = (pdlg == NULL)? ERROR_NOT_ENOUGH_MEMORY :
                              pdlg->Process();

        if (err != NERR_Success)
            ::MsgPopup (this, err);

        delete pdlg;
        break;
    }while (FALSE);

    if (err)
        MsgPopup (this, err);
}

ULONG NCP_DIALOG::QueryHelpContext()
{
    return HC_UM_NETWARE;
}


/*******************************************************************

    NAME:   LOGIN_SCRIPT_DLG::LOGIN_SCRIPT_DLG

    SYNOPSIS:   Constructor for login script dialog

    ENTRY:

    HISTORY:
            CongpaY 9-Dec-1994 Created

********************************************************************/

LOGIN_SCRIPT_DLG::LOGIN_SCRIPT_DLG(HWND  hWndOwner,
                               const TCHAR * lpLoginScriptFile)
  : DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_NCP_LOGIN_SCRIPT_DIALOG), hWndOwner),
    _mleLoginScript (this, IDLS_MLE_LOGIN_SCRIPT),
    _lpLoginScriptFile (lpLoginScriptFile)
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if ((( err = _mleLoginScript.QueryError() ) != NERR_Success ) ||
        (( err = ShowLoginScript ()) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    UIASSERT(_lpLoginScriptFile != NULL) ;

    _mleLoginScript.SetFmtLines();
}

APIERR LOGIN_SCRIPT_DLG::ShowLoginScript()
{
    APIERR err = NERR_Success;

    HANDLE hFile;
    hFile = CreateFile (_lpLoginScriptFile,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        err = GetLastError();

        if ((err == ERROR_PATH_NOT_FOUND) || (err == ERROR_FILE_NOT_FOUND))
        {
            //
            // this is OK. will create later
            //
            return (NERR_Success);
        }

        return (err);
    }

    CHAR *lpFile = NULL;
    TCHAR *lpLoginScript = NULL;

    do  // FALSE loop.
    {
        DWORD dwFileSize = GetFileSize (hFile, NULL);
        if (dwFileSize == -1)
        {
            err = GetLastError();
            break;
        }

        if (dwFileSize == 0)
            break;

        lpFile = (CHAR *)LocalAlloc (LPTR, dwFileSize);
        if (lpFile == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        DWORD dwBytesRead;
        if (!ReadFile (hFile,
                       lpFile,
                       dwFileSize,
                       &dwBytesRead,
                       NULL))
        {
            err = GetLastError();
            break;
        }

        UIASSERT (dwBytesRead == dwFileSize);

        DWORD dwLoginScript = (dwBytesRead+1)*sizeof (TCHAR);
        lpLoginScript = (TCHAR *)LocalAlloc (LPTR, dwLoginScript);
        if (lpLoginScript == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Remove special end of file character added by editor.
        if (*(lpFile+dwBytesRead-2) == 13)
            *(lpFile+dwBytesRead-2) = 0;

        if (!MultiByteToWideChar (CP_ACP,
                                  0,
                                  lpFile,
                                  dwBytesRead,
                                  lpLoginScript,
                                  dwLoginScript))
        {
            err = GetLastError();
            break;
        }

        _mleLoginScript.SetText (lpLoginScript);
    }while (FALSE);

    CloseHandle (hFile);
    if (lpFile)
        LocalFree (lpFile);
    if (lpLoginScript)
        LocalFree (lpLoginScript);
    return err;
}

LOGIN_SCRIPT_DLG::~LOGIN_SCRIPT_DLG()
{
}

BOOL  LOGIN_SCRIPT_DLG::OnOK()
{
    AUTO_CURSOR         AutoCursor;

    APIERR err = NERR_Success;

    char *lpFile = NULL;

    do // FALSE loop
    {
        UINT cb = _mleLoginScript.QueryTextSize();

        NLS_STR nlsLoginScript( cb );

        if (((err = nlsLoginScript.QueryError()) != NERR_Success) ||
            ((err = _mleLoginScript.QueryText( &nlsLoginScript)) != NERR_Success))
            break;

        cb = cb / sizeof (TCHAR);
        lpFile = (CHAR *)LocalAlloc (LPTR, cb);
        if (lpFile == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if (!WideCharToMultiByte (CP_ACP,
                                  0,
                                  nlsLoginScript.QueryPch(),
                                  -1,
                                  lpFile,
                                  cb,
                                  NULL,
                                  NULL))
        {
            err = GetLastError();
            break;
        }

        HANDLE hFile;
        hFile = CreateFile (_lpLoginScriptFile,
                            GENERIC_WRITE,
                            FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            0);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            err = GetLastError();

            if (err != ERROR_PATH_NOT_FOUND)
            {
                break;
            }

            //
            // path not found. create now dir - strip off last component first.
            //

            TCHAR *pszTmp ;

            if (pszTmp = ::strrchrf(_lpLoginScriptFile, TCH('\\')))
            {
                *pszTmp = 0 ;

                if (! ::CreateDirectory(_lpLoginScriptFile, NULL) )
                {
                    *pszTmp = TCH('\\') ;   // restore the '\'

                    err = GetLastError() ;
                }
                else
                {
                    *pszTmp = TCH('\\') ;   // restore the '\'

                    //
                    // try again to create the file
                    //
                    hFile = CreateFile (_lpLoginScriptFile,
                                        GENERIC_WRITE,
                                        FILE_SHARE_WRITE,
                                        NULL,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        0);

                    if (hFile == INVALID_HANDLE_VALUE)
                    {
                        err = GetLastError();
                    }
                    else
                    {
                        err = NERR_Success ;
                    }
                }

                if (err != NERR_Success)
                    break ;

            }
        }

        DWORD dwBytesWrite;
        if (!WriteFile (hFile,
                        lpFile,
                        cb-1,  //don't write the last null character.
                        &dwBytesWrite,
                        NULL))
            err = GetLastError();

        UIASSERT (dwBytesWrite == cb-1);
        CloseHandle(hFile);
    }while (FALSE);

    if (lpFile)
        LocalFree (lpFile);

    if (err)
    {
        ::MsgPopup( this, err );
        return(TRUE);
    }
    else
        return (DIALOG_WINDOW::OnOK());
}

ULONG LOGIN_SCRIPT_DLG::QueryHelpContext()
{
    return HC_UM_NETWARE_LOGIN_SCRIPT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\nwlb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
 *   nwlb.cxx
 *   Class declarations for the ADD_DIALOG, NW_ADDR_LISTBOX, and
 *   NW_ADDR_LBI classes. ADD_DIALOG let users type in the workstation address and
 *   node address of the allowed login worksation. NW_ADDR_LISTBOX is the listbox
 *   that holds the addresses of the allowed login workstations, NW_ADDR_LBI is
 *   for each item in the listbox.
 *
 *   FILE HISTORY:
 *       CongpaY         1-Oct-1993     Created.
 */

#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <bltmsgp.hxx>
#include <nwlb.hxx>

extern "C"
{
    #include <mnet.h>
    #include <usrmgrrc.h>
}

#include <strnumer.hxx>

#define SZ12FS          SZ("ffffffffffff")

/*******************************************************************

    NAME:       NW_ADDR_LISTBOX :: NW_ADDR_LISTBOX

    SYNOPSIS:   NW_ADDR_LISTBOX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_ADDR_LISTBOX :: NW_ADDR_LISTBOX( OWNER_WINDOW   * powOwner,
                                    CID              cid)
  : BLT_LISTBOX( powOwner, cid)
{
    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if ((err = DISPLAY_TABLE::CalcColumnWidths (_adx,
                                     NUM_NW_ADDR_LISTBOX_COLUMNS,
                                     powOwner,
                                     cid,
                                     FALSE)) != NERR_Success)
    {
        ReportError(err);
    }

}   // NW_ADDR_LISTBOX :: NW_ADDR_LISTBOX


/*******************************************************************

    NAME:       NW_ADDR_LISTBOX :: ~NW_ADDR_LISTBOX

    SYNOPSIS:   NW_ADDR_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_ADDR_LISTBOX :: ~NW_ADDR_LISTBOX()
{
}

/*******************************************************************

    NAME:       NW_ADDR_LISTBOX :: AddNWAddr

    SYNOPSIS:   Get all the NetWare workstations in the listbox.

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
APIERR NW_ADDR_LISTBOX :: AddNWAddr( NLS_STR & nlsNetworkAddr, NLS_STR & nlsNodeAddr)
{
    // Add the address to the listbox.
    NW_ADDR_LBI * plbi = new NW_ADDR_LBI (nlsNetworkAddr, nlsNodeAddr);
    INT i = AddItemIdemp(plbi);
    if (i < 0)
    {
       return ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        SelectItem (i);
        return NERR_Success;
    }
}

/*******************************************************************

    NAME:       NW_ADDR_LISTBOX :: QueryWkstaNamesNW

    SYNOPSIS:   Get all the NetWare workstations in the listbox.

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
APIERR NW_ADDR_LISTBOX :: QueryWkstaNamesNW( NLS_STR * pnlsWkstaNameNW)
{
    NW_ADDR_LBI * plbi;
    APIERR err;
    INT i;
    for ( i = 0; i < QueryCount(); i++)
    {
        plbi = (NW_ADDR_LBI *) QueryItem(i);

        if (plbi != NULL)
        {
            if((err = pnlsWkstaNameNW->Append (plbi->QueryNetworkAddr())) != NERR_Success)
            {
                return err;
            }

            if ((plbi->QueryNodeAddr()).QueryTextLength() == NODESIZE)
            {
                if ((err = pnlsWkstaNameNW->Append (plbi->QueryNodeAddr())) != NERR_Success)
                {
                    return err;
                }
            }
            else    // No Node Address specified, add 12 "f".
            {
                if ((err = pnlsWkstaNameNW->Append(SZ12FS)) != NERR_Success)
                {
                    return err;
                }
            }
        }
    }
    return NERR_Success;
}

/*******************************************************************

    NAME:       NW_ADDR_LBI :: NW_ADDR_LBI

    SYNOPSIS:   NW_ADDR_LBI class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_ADDR_LBI :: NW_ADDR_LBI(const NLS_STR & nlsNetworkAddr, const NLS_STR & nlsNodeAddr)
   :_nlsNetworkAddr (nlsNetworkAddr),
    _nlsNodeAddr (nlsNodeAddr)
{
    if (!_nlsNetworkAddr)
    {
         ReportError (_nlsNetworkAddr.QueryError());
         return;
    }

    if (!_nlsNodeAddr)
    {
         ReportError (_nlsNodeAddr.QueryError());
         return;
    }

    APIERR err;

    if (strcmpf ( nlsNodeAddr.QueryPch(), SZ12FS ) == 0 )
    {
        if ((err = _nlsNodeAddr.Load (IDS_ALL_NODES)) != NERR_Success)
            ReportError (err);
    }
}

/*******************************************************************

    NAME:       NW_ADDR_LBI :: ~NW_ADDR_LBI

    SYNOPSIS:   NW_ADDR_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_ADDR_LBI :: ~NW_ADDR_LBI()
{
}

/*******************************************************************

    NAME:       NW_ADDR_LBI :: Paint

    SYNOPSIS:   Paint LBI in the listbox

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
VOID NW_ADDR_LBI :: Paint( LISTBOX *        plb,
                      HDC              hdc,
                      const RECT     * prect,
                      GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE dteNetworkAddr ( _nlsNetworkAddr);
    STR_DTE dteNodeAddr ( _nlsNodeAddr );

    DISPLAY_TABLE dtab( NUM_NW_ADDR_LISTBOX_COLUMNS,
                        ((NW_ADDR_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteNetworkAddr;
    dtab[1] = &dteNodeAddr;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // NW_ADDR_LBI :: Paint

/*******************************************************************

    NAME:       NW_ADDR_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    HISTORY:
            rustanl     18-Jul-1991     Created

********************************************************************/

WCHAR NW_ADDR_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsNetworkAddr );
    return _nlsNetworkAddr.QueryChar( istr );
}


/*******************************************************************

    NAME:       NW_ADDR_LBI::Compare

    SYNOPSIS:   Compares two NW_ADDR_LBI's

    ENTRY:      plbi -      Pointer to other NW_ADDR_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    HISTORY:
            rustanl     18-Jul-1991 Created
            beng        08-Jun-1992 Aliases sorted with groups

********************************************************************/

INT NW_ADDR_LBI::Compare( const LBI * plbi ) const
{
    INT i = _nlsNetworkAddr._stricmp( ((const NW_ADDR_LBI *)plbi)->_nlsNetworkAddr );

    if (i == 0)
        i = _nlsNodeAddr._stricmp( ((const NW_ADDR_LBI *)plbi)->_nlsNodeAddr );

    return i;
}

/*******************************************************************

    NAME:       SLE_HEX :: SLE_HEX

    SYNOPSIS:   SLE_HEX class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
SLE_HEX :: SLE_HEX( OWNER_WINDOW *     powner,
                    CID cid, UINT cchMaxLen)
  : SLE (powner, cid, cchMaxLen),
    CUSTOM_CONTROL (this)
{
}

SLE_HEX :: ~SLE_HEX ()
{
}

BOOL SLE_HEX :: OnChar (const CHAR_EVENT & event)
{
    TCHAR chKey = event.QueryChar();
    if ((!iswxdigit(chKey)) &&
        (chKey != VK_BACK) &&
        (chKey != VK_DELETE) &&
        (chKey != VK_END) &&
        (chKey != VK_HOME) )
    {
        ::MessageBeep (0);
        return TRUE;
    }

    return FALSE;
}

/*******************************************************************

    NAME:       ADD_DIALOG ::ADD_DIALOG

    SYNOPSIS:   ADD_DIALOG class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
ADD_DIALOG :: ADD_DIALOG( OWNER_WINDOW *     powner,
                          NW_ADDR_LISTBOX   *     plbNW)
  :DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_ADD_NW_DLG), powner->QueryHwnd()),
   _sleNetworkAddr( this, IDADD_SLE_NETWORK_ADDR, NETWORKSIZE),
   _sleNodeAddr (this, IDADD_SLE_NODE_ADDR, NODESIZE),
   _plbNW (plbNW)
{
}

/*******************************************************************

    NAME:       ADD_DIALOG :: ~ADD_DIALOG

    SYNOPSIS:   ADD_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
ADD_DIALOG:: ~ADD_DIALOG()
{
}

/*******************************************************************

    NAME:       ADD_DIALOG :: QueryHelpContext

    SYNOPSIS:   Handle Help

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
ULONG ADD_DIALOG :: QueryHelpContext()
{
    return HC_UM_NETWARE_ADD;
}

/*******************************************************************

    NAME:       ADD_DIALOG :: OnOK

    SYNOPSIS:   OK handler. Get the Network Address and add it to the listbox.

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
BOOL ADD_DIALOG:: OnOK()
{
    NLS_STR nlsNetworkAddr;
    NLS_STR nlsNodeAddr;

    APIERR err;
    do
    {
        // Get dialog value.
        if (((err = nlsNetworkAddr.QueryError())!= NERR_Success) ||
            ((err = nlsNodeAddr.QueryError())!= NERR_Success) ||
            ((err = _sleNetworkAddr.QueryText (&nlsNetworkAddr)) != NERR_Success) ||
            ((err = _sleNodeAddr.QueryText (&nlsNodeAddr)) != NERR_Success) )
            break;

        // Convert network address to 8 hex numbers.
        INT nNetworkAddrLen = nlsNetworkAddr.QueryTextLength();
        if (nNetworkAddrLen == 0)
        {
            _sleNetworkAddr.ClaimFocus();
            err = MSG_NO_NETWORK_ADDR;
            break;
        }
        else if (nNetworkAddrLen < NETWORKSIZE)
        {
            HEX_STR nlsZero (0, NETWORKSIZE-nNetworkAddrLen);
            if ((err = nlsZero.QueryError())!= NERR_Success)
                break;

            ISTR istr (nlsNetworkAddr);

            if (!nlsNetworkAddr.InsertStr (nlsZero, istr))
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        // Convert node address to 12 hex numbers.
        INT nNodeAddrLen = nlsNodeAddr.QueryTextLength();
        if (nNodeAddrLen == 0)
        {
            if (::MsgPopup (this,
                            IDS_INCLUDE_ALL_NODES,
                            MPSEV_WARNING,
                            MP_YESNO,
                            MP_NO) != IDYES )
                return TRUE;

            if ((err = nlsNodeAddr.Load (IDS_ALL_NODES)) != NERR_Success)
                break;
        }
        else if (nNodeAddrLen < NODESIZE)
        {
            HEX_STR nlsZero (0, NODESIZE-nNodeAddrLen);
            if ((err = nlsZero.QueryError())!= NERR_Success)
                break;

            ISTR istr (nlsNodeAddr);

            if (!nlsNodeAddr.InsertStr (nlsZero, istr))
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if (( err = _plbNW->AddNWAddr (nlsNetworkAddr, nlsNodeAddr)) != NERR_Success)
            break;

    }while (FALSE);

    if (err)
    {
        ::MsgPopup (this, err);
        return TRUE;
    }

    return (DIALOG_WINDOW::OnOK());
}

/*******************************************************************

    NAME:        NW_PASSWORD_DLG::NW_PASSWORD_DLG

    SYNOPSIS:    class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_PASSWORD_DLG::NW_PASSWORD_DLG ( OWNER_WINDOW *     powner,
                                   const TCHAR *      pchUserName,
                                   NLS_STR *          pnlsNWPassword)
  :DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_NW_PASSWORD_DLG), powner->QueryHwnd()),
  _pnlsNWPassword (pnlsNWPassword),
  _sltUserName (this, IDNWP_ST_USERNAME),
  _sleNWPassword (this, IDNWP_ET_PASSWORD, MAXNWPASSWORDLENGTH),
  _sleNWPasswordConfirm (this, IDNWP_ET_PASSWORD_CONFIRM, MAXNWPASSWORDLENGTH)
{
    if (QueryError() != NERR_Success)
    {
        return;
    }
    _sltUserName.SetText (pchUserName);
}

/*******************************************************************

    NAME:        NW_PASSWORD_DLG:: ~NW_PASSWORD_DLG

    SYNOPSIS:    class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
NW_PASSWORD_DLG :: ~NW_PASSWORD_DLG()
{
}

/*******************************************************************

    NAME:       NW_PASSWORD_DLG :: QueryHelpContext

    SYNOPSIS:   Handle Help

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
ULONG NW_PASSWORD_DLG :: QueryHelpContext()
{
    return HC_UM_NETWARE_PASSWORD;
}

/*******************************************************************

    NAME:       NW_PASSWORD_DLG :: OnOK

    SYNOPSIS:   OK handler. Validate the Network Address and add it to the listbox.

    EXIT:

    HISTORY:
        CongpaY         1-Oct-1993     Created.

********************************************************************/
BOOL NW_PASSWORD_DLG:: OnOK()
{
    APIERR err;
    NLS_STR nlsNWPassword;
    NLS_STR nlsNWPasswordConfirm;
    if (((err = nlsNWPassword.QueryError()) != NERR_Success) ||
        ((err = nlsNWPasswordConfirm.QueryError()) != NERR_Success) ||
        ((err = _sleNWPassword.QueryText (&nlsNWPassword)) != NERR_Success) ||
        ((err = nlsNWPassword.QueryError()) != NERR_Success) ||
        ((err = _sleNWPasswordConfirm.QueryText (&nlsNWPasswordConfirm)) != NERR_Success) ||
        ((err = nlsNWPasswordConfirm.QueryError()) != NERR_Success) )
    {
        MsgPopup (this, err);
        return TRUE;
    }

    // Don't validate password because NetWare only not allow control characters in
    // password and sle does not accept control characters.

    if ( nlsNWPassword.strcmp( nlsNWPasswordConfirm ) )
    {
	err = IERR_UM_NWPasswordMismatch;
    }
    else
    {
        err = _pnlsNWPassword->CopyFrom (nlsNWPassword);
    }

    // clear password from pagefile
    ::memsetf( (void *)(nlsNWPassword.QueryPch()),
               0x20,
               nlsNWPassword.strlen() );

    ::memsetf( (void *)(nlsNWPasswordConfirm.QueryPch()),
               0x20,
               nlsNWPasswordConfirm.strlen() );

    if ( err != NERR_Success )
    {
	_sleNWPassword.SetText(NULL);
	_sleNWPasswordConfirm.SetText(NULL);
	_sleNWPassword.ClaimFocus();
        MsgPopup (this, err);
        return TRUE;
    }

    return (DIALOG_WINDOW::OnOK());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\nwlogdlg.cxx ===
/******************************************************************************
*
*   nwlogdlg.cxx
*   NWLOGON_DLG class implementation
*
*  Copyright Citrix Systems Inc. 1995
*
*  Author: Bill Madden
*
*  $Log:   N:\NT\PRIVATE\NET\UI\ADMIN\USER\USER\CITRIX\VCS\NWLOGDLG.CXX  $
*  
*     Rev 1.3   25 Jun 1996 11:30:22   miked
*  4.0 merge
*  
*     Rev 1.2   18 Jun 1996 14:11:06   bradp
*  4.0 Merge
*  
*     Rev 1.1   28 Jan 1996 15:10:38   billm
*  CPR 2583: Check for domain admin user
*  
*     Rev 1.0   21 Nov 1995 15:43:34   billm
*  Initial revision.
*  
******************************************************************************/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>
extern "C"
{
    #include <mnet.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>


extern "C"
{
    #include <usrmgrrc.h>
    #include <umhelpc.h>
    #include <citrix\citrix.h>
}

#include <usrmain.hxx>
#include <citrix\nwlogdlg.hxx>
#include <lmowks.hxx>
#include <strnumer.hxx>
#include <citrix\uconfig.hxx>
#include <domenum.hxx>

/*******************************************************************

    NAME:	UCNWLOGON_DLG::UCNWLOGON_DLG

    SYNOPSIS:   Constructor for Citrix User Configuration Netware logon
                subdialog, base class

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

********************************************************************/

UCNWLOGON_DLG::UCNWLOGON_DLG(
	USER_SUBPROP_DLG * pusersubpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USER_SUB2PROP_DLG(
                pusersubpropdlgParent,
                MAKEINTRESOURCE(IDD_USER_NWLOGON_EDIT),
		pulb
		),
            _sleNWLogonServerName( this, IDC_NW_SERVERNAME, NASIFILESERVER_LENGTH ),
            _nlsNWLogonServerName(),
            _fIndeterminateServerName( FALSE ),

            _sleAdminUsername( this, IDC_NW_ADMIN_USERNAME, USERNAME_LENGTH ),
            _nlsAdminUsername(),

            _pwcAdminPassword( this, IDC_NW_ADMIN_PASSWORD, PASSWORD_LENGTH ), 
            _nlsAdminPassword(),                              

            _pwcAdminConfirmPassword( this, IDC_NW_ADMIN_CONFIRM_PW, 
                                      PASSWORD_LENGTH ), 

            _nlsAdminDomain(),                              
            _pNWLogonAdmin()

{
    APIERR err = NERR_Success;

    if( QueryError() != NERR_Success )
        return;

    if (  ((err = _nlsNWLogonServerName.QueryError() ) != NERR_Success )
       || ((err = _nlsAdminUsername.QueryError() ) != NERR_Success )
       || ((err = _nlsAdminPassword.QueryError() ) != NERR_Success )
       || ((err = _nlsAdminDomain.QueryError() ) != NERR_Success )
       )
        ReportError( err );

    _pNWLogonAdmin = new NWLOGON_ADMIN();
    if ( _pNWLogonAdmin == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
    }

    return;

} // UCNWLOGON_DLG::UCNWLOGON_DLG



/*******************************************************************

    NAME:       UCNWLOGON_DLG::~UCNWLOGON_DLG

    SYNOPSIS:   Destructor for User Configuration Netware Logon subdialog,
                base class

********************************************************************/

UCNWLOGON_DLG::~UCNWLOGON_DLG( void )
{
    delete _pNWLogonAdmin;

} // UCNWLOGON_DLG::~UCNWLOGON_DLG


/*******************************************************************

    NAME:       UCNWLOGON_DLG::GetOne

    SYNOPSIS:   Loads information on one user

    ENTRY:	iObject   -	the index of the object to load

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success

    RETURNS:	An error code which is NERR_Success on success.		

********************************************************************/

APIERR UCNWLOGON_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
    APIERR err = NERR_Success;
    USER_CONFIG * pUserConfig = QueryBaseParent()->QueryUserConfigPtr( iObject );
    PNWLOGON_ADMIN pNWLogonAdmin = QueryNWLogonPtr();

    ASSERT( pUserConfig != NULL );
    ASSERT( pNWLogonAdmin != NULL );

    *perrMsg = IDS_UMGetOneFailure;

    if ( iObject == 0 ) // first object
    {
        if ( (err = pNWLogonAdmin->SetServerName(pUserConfig->QueryServerName())) 
            == NERR_Success ) {
    
            err = pNWLogonAdmin->GetInfo();
            if (err == NERR_Success) {
                if ( (err = _nlsNWLogonServerName.
                                CopyFrom( pUserConfig->QueryNWLogonServer() )) 
                                    != NERR_Success )
                    return err;
                if ( (err = _nlsAdminUsername.
                                CopyFrom( pNWLogonAdmin->QueryAdminUsername() )) 
                                    != NERR_Success )
                    return err;
                if ( (err = _nlsAdminDomain.
                                CopyFrom( pNWLogonAdmin->QueryAdminDomain() )) 
                                    != NERR_Success )
                    return err;
                if ( (err = _nlsAdminPassword.
                                CopyFrom( pNWLogonAdmin->QueryAdminPassword() )) 
                                    != NERR_Success )
                    return err;

            }
        }
    }
    else	// iObject > 0
    {
        if ( !_fIndeterminateServerName &&
       	     (_nlsNWLogonServerName._stricmp( pUserConfig->QueryNWLogonServer() ) != 0) ) {

	        _fIndeterminateServerName = TRUE;
        }
    }
	
    return err;

} // UCNWLOGON_DLG::GetOne


/*******************************************************************

    NAME:       UCNWLOGON_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by UCNWLOGON_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

********************************************************************/

APIERR UCNWLOGON_DLG::InitControls()
{
    NLS_STR nlsTemp( UI_NULL_USERSETINFO_PASSWD );

    if ( !_fIndeterminateServerName )
        _sleNWLogonServerName.SetText( _nlsNWLogonServerName );

    _sleAdminUsername.SetText( _nlsAdminUsername );

    // If the username is empty, make password box empty
    if (_nlsAdminUsername.strlen() == 0) {
        nlsTemp.CopyFrom( TEXT("") );
    }

    _pwcAdminPassword.SetText( nlsTemp );
    _pwcAdminConfirmPassword.SetText( nlsTemp );

    return USER_SUB2PROP_DLG::InitControls();

} // UCNWLOGON_DLG::InitControls


/*******************************************************************

    NAME:       UCNWLOGON_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members and
                validates.

    RETURNS:	NERR_Success if all dialog data was OK; error code
                to cause message display otherwise.

********************************************************************/

APIERR UCNWLOGON_DLG::W_DialogToMembers()
{
    APIERR err = NERR_Success;
    NLS_STR nls, nlsConfirmPW;
    HANDLE LogonToken;
    USER_2 *puser2;

    // See if they updated the servername
    if ( ((err = _sleNWLogonServerName.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;
    if ( !_fIndeterminateServerName ||
         (_nlsNWLogonServerName._stricmp( nls ) != 0) ) {

        if ( (err = _nlsNWLogonServerName.CopyFrom( nls )) != NERR_Success )
            return err;
        _fIndeterminateServerName = FALSE;
    }

    // See if they updated the Admin username
    if ( ((err = _sleAdminUsername.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;
    if (_nlsAdminUsername._stricmp( nls ) != 0) {

        if ( (err = _nlsAdminUsername.CopyFrom( nls )) != NERR_Success )
            return err;
    }

    // Get the password
    if ( ((err = _pwcAdminPassword.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;

    // Get the confirmation password
    if ( ((err = _pwcAdminConfirmPassword.QueryText( &nlsConfirmPW )) != NERR_Success) ||
         ((err = nlsConfirmPW.QueryError()) != NERR_Success) )
        return err;

    // Are they the same?
    if (nls.strcmp( nlsConfirmPW ) != 0) {

	_pwcAdminPassword.ClaimFocus();
        return IERR_UM_PasswordMismatch;
    }

    // clear out confirmation password
    ::memsetf( (void *)(nlsConfirmPW.QueryPch()),
               0x20,
               nlsConfirmPW.strlen() );

    // If they actually updated the password, get the new value
    if (nls.strcmp( UI_NULL_USERSETINFO_PASSWD ) != 0) {

        if ( (err = _nlsAdminPassword.CopyFrom( nls )) != NERR_Success )
            return err;
    }

    // clear out the new password
    ::memsetf( (void *)(nls.QueryPch()),
               0x20,
               nls.strlen() );

    // If there's a server name, make sure this is an Admin user
    if (_nlsNWLogonServerName.strlen() && (!_nlsAdminUsername.strlen())) {

   	    _sleAdminUsername.ClaimFocus();
            err = ERROR_BAD_USERNAME;

    // Only verify the admin user if it's not null
    } else if (_nlsAdminUsername.strlen()) {

        // Verify that this is an administrator ID
        puser2 = new USER_2(_nlsAdminUsername.QueryPch(), QueryLocation());
        if (puser2 == NULL) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    
        // Get the account info for this user
        err = puser2->QueryError();
        if ( err == NERR_Success ) {
            err = puser2->GetInfo();
        }

        // User isn't in the current domain, but it might be a domain
        // admin, so walk through the domains looking for this user
        if ((err != NERR_Success) || 
            ((err == NERR_Success) && 
             (puser2->QueryPriv() != USER_PRIV_ADMIN))) {

            ULONG ultemp;
            BOOL  fFound = FALSE;
            const BROWSE_DOMAIN_INFO *pbdi;
            BROWSE_DOMAIN_ENUM *pEnumDomains = 
                new BROWSE_DOMAIN_ENUM(BROWSE_LM2X_DOMAINS, &ultemp);
        
            if (pEnumDomains == NULL) {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }

            err = pEnumDomains->QueryError();
        
            while ((err == NERR_Success) && 
                   !fFound &&
                   (pbdi = pEnumDomains->Next())) {

                // Only check if this is different from our current location
                if (::stricmpf(pbdi->QueryDomainName(), 
                               QueryLocation().QueryDomain()) != 0) {

                    // Remove previous user2 instance
                    delete puser2;
    
                    // See if the user exists in this domain
                    puser2 = new USER_2(_nlsAdminUsername.QueryPch(), 
                                        pbdi->QueryDomainName());
    
                    // Did the user2 structure get created OK?
                    if (puser2 == NULL) {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                    }
    
                    // See if there were any errors
                    err = puser2->QueryError();
    
                    // Get the info for this user on the domain
                    if ( err == NERR_Success ) {
                        err = puser2->GetInfo();
                    }
    
                    // Is this an administrator?
                    if ((err == NERR_Success) && 
                        (puser2->QueryPriv() == USER_PRIV_ADMIN)) {
                        fFound = TRUE;
                        err = _nlsAdminDomain.CopyFrom(pbdi->QueryDomainName());
                    } else if ((err == NERR_UserNotFound) || 
                               (err == NERR_DCNotFound)) {
                        err = NERR_Success;
                    }
                }
            }
            if (pEnumDomains) {
                delete pEnumDomains;
            }

            // Did we find an administrator with this ID?
            if ((err == NERR_Success) && !fFound) {
                err = IERR_NW_UserID_Not_Admin;
            }
        } else if (err == NERR_Success) {
            err = _nlsAdminDomain.CopyFrom(QueryLocation().QueryName());
        }
    
        if (puser2) {
            delete puser2;
        }
    }

    if ( err != NERR_Success )
    {
	return err;
    }

    return NERR_Success;

} // UCNWLOGON_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       UCNWLOGON_DLG::PerformOne
	
    SYNOPSIS:	PERFORMER::PerformSeries calls this

    ENTRY:	iObject  -	index of the object to save

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success
					
		pfWorkWasDone - always set to TRUE (thus performing a similar
                                function to the "ChangesUser2Ptr()" method
                                for other UM subdialogs).  Actual writing
                                of the USER_CONFIG object will only take
                                place if changes were made or the object
                                was 'dirty' to begin with.
					
    RETURNS:	An error code which is NERR_Success on success.

    NOTES:	This PerformOne() is intended to work only with the User
                Configuration subdialog and is a complete replacement of
                the USER_SUBPROP_DLG::PerformOne().

********************************************************************/

APIERR UCNWLOGON_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    APIERR err = NERR_Success;
    USER_CONFIG * pUserConfig = QueryBaseParent()->QueryUserConfigPtr( iObject );
    PNWLOGON_ADMIN pNWLogonAdmin = QueryNWLogonPtr();

    ASSERT( pUserConfig != NULL );
    ASSERT( pNWLogonAdmin != NULL );

    *perrMsg = IDS_UMEditFailure;
    *pfWorkWasDone = TRUE;

    if ( !_fIndeterminateServerName &&
         (_nlsNWLogonServerName._stricmp( pUserConfig->QueryNWLogonServer() ) != 0) ) {

        if ( (err = pUserConfig->
                        SetNWLogonServer( _nlsNWLogonServerName.QueryPch() ))
                            != NERR_Success )
            return err;
        pUserConfig->SetDirty();
    }

    // New admin username?
    if ( (_nlsAdminUsername._stricmp( pNWLogonAdmin->QueryAdminUsername() ) != 0) ) {

        // Set the administrator name in the NWLogogAdmin structure
        if ( (err = pNWLogonAdmin->
                        SetAdminUsername( _nlsAdminUsername.QueryPch() ))
                            != NERR_Success )
            return err;

        // Set the administrator domain
        if ( (err = pNWLogonAdmin->
                        SetAdminDomain( _nlsAdminDomain.QueryPch() ))
                            != NERR_Success )
            return err;

        pNWLogonAdmin->SetDirty();
    }

    // New password?
    if ( (_nlsAdminPassword.strcmp( pNWLogonAdmin->QueryAdminPassword() ) != 0) ) {
        if (err == ERROR_SUCCESS) {
            if ( (err = pNWLogonAdmin->
                            SetAdminPassword( _nlsAdminPassword.QueryPch() ))
                                != NERR_Success )
                return err;
            pNWLogonAdmin->SetDirty();
        }
    }

    err = pNWLogonAdmin->SetInfo();

    return err;

} // UCNWLOGON_DLG::PerformOne


/*******************************************************************

    NAME:       UCNWLOGON_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

********************************************************************/

ULONG UCNWLOGON_DLG::QueryHelpContext( void )
{
    return HC_UM_USERCONFIG;

} // UCNWLOGON_DLG::QueryHelpContext


/*******************************************************************

    NAME:       UCNWLOGON_DLG::QueryBaseParent

    SYNOPSIS:   Return the parent of our parent!

    RETURNS:    

********************************************************************/

USERPROP_DLG * UCNWLOGON_DLG::QueryBaseParent()
{                                  
    USER_SUBPROP_DLG *pusersubprop = (USER_SUBPROP_DLG *)QueryParent();

    return pusersubprop->QueryParent();

} // UCNWLOGON_DLG::QueryBaseParent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\grpprop.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    grpprop.cxx


    FILE HISTORY:
    JonN	08-Oct-1991	Templated from userprop.cxx
    JonN	17-Oct-1991	Uses SLE_STRIP
    o-SimoP	18-Nov-1991	Added code for getting/putting users to group
				now uses only one dialog template(resource)
    JonN	01-Jan-1992	Changed W_MapPerformOneAPIError to
				W_MapPerformOneError
    o-SimoP     01-Jan-1992	CR changes, attended by BenG, JonN and I
    JonN        15-May-1993     Disabled _fDescriptionOnly, but left structure
                                in case we need it later

    CODEWORK should use VALIDATED_DIALOG for edit field validation
*/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SETCONTROL
#include <blt.hxx>

// usrmgrrc.h must be included after blt.hxx (more exactly, after bltrc.h)
extern "C"
{
    #include <mnet.h>
    #include <usrmgrrc.h>
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <umhelpc.h>
}


#include <uitrace.hxx>
#include <uiassert.hxx>
#include <heapones.hxx>
#include <lmogroup.hxx>
#include <grpprop.hxx>
#include <usrmain.hxx>
#include <uintsam.hxx>

// CODEWORK These values are taken from net\access\userp.c.  It would be nice
// if we could share these values with that code in case they change.
#define GROUP_DESIRED_ACCESS_READ ( GROUP_READ_INFORMATION | GROUP_LIST_MEMBERS )
#define GROUP_DESIRED_ACCESS_WRITE ( GROUP_ADD_MEMBER | GROUP_REMOVE_MEMBER | GROUP_WRITE_ACCOUNT )
#define GROUP_DESIRED_ACCESS_ALL ( GROUP_DESIRED_ACCESS_READ | GROUP_DESIRED_ACCESS_WRITE )

//
// BEGIN MEMBER FUNCTIONS
//

DEFINE_ONE_SHOT_OF( USER_SC_LBI )

/*******************************************************************

    NAME:	GROUPPROP_DLG::GROUPPROP_DLG

    SYNOPSIS:	Constructor for Group Properties main dialog, base class

    ENTRY:	powin	-   pointer to OWNER_WINDOW
	
		pulb	-   pointer to main window LAZY_USER_LISTBOX
			
		loc	-   reference to current LOCATION
			
		psel	-   pointer to ADMIN_SELECTION, currently only
			    one group can be selected
				
    NOTES:	psel is required to be NULL for NEW variants,
		non-NULL otherwise.

    HISTORY:
    JonN        09-Oct-1991     Templated from userprop.cxx

********************************************************************/

GROUPPROP_DLG::GROUPPROP_DLG( const OWNER_WINDOW    * powin,
			      const UM_ADMIN_APP *	pumadminapp,
			            LAZY_USER_LISTBOX    * pulb,
			      const LOCATION        & loc,
			      const ADMIN_SELECTION * psel,
					// "new group" variants pass NULL
                                     ULONG            ulGroupRID
		) : PROP_DLG( loc, MAKEINTRESOURCE(IDD_GROUP),
			powin, (psel == NULL) ),
		    _pumadminapp( pumadminapp ),
		    _apgroup1( NULL ),
		    _apgroupmemb( NULL ),
		    _nlsComment(),
		    _sleComment( this,
                                 IDGP_ET_COMMENT,
                                 (pumadminapp->IsDownlevelVariant())
                                     ? LM20_MAXCOMMENTSZ
                                     : MAXCOMMENTSZ ),
                    // CODEWORK should not depend on ctor order here
                    _ulbicache( pulb ),
		    _lbIn(    this, IDGP_IN_LB,     _ulbicache, pulb, TRUE  ),
		    _lbNotIn( this, IDGP_NOT_IN_LB, _ulbicache, pulb, FALSE ),
		    _pulb( pulb ),
		    _sleGroupName( this, IDGP_ET_GROUP_NAME, LM20_GNLEN ),
		    _sltGroupName( this, IDGP_ST_GROUP_NAME ),
		    _sltGroupNameLabel( this, IDGP_ST_GROUP_NAME_LABEL ),
		    _psc( NULL ),
		    _posh( NULL ),
                    _poshSave( NULL ),
                    _strlistNamesNotFound(),
                    _pbfindStartedSelected( NULL ),
                    _fDescriptionOnly( FALSE ),
                    _ulGroupRID( ulGroupRID ),
                    _psamgroup( NULL )
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _lbIn.QueryError();
    if(    err  != NERR_Success
	|| (err = _lbNotIn.QueryError()) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    _lbIn.SetCount( 0 );
    _lbNotIn.SetCount( _ulbicache.QueryCount() );

    // We leave the array mechanism in place in case we ever decide
    // to support group multiselection, and to remain consistent with
    // USERPROP_DLG.

    _apgroup1 = new PGROUP_1[ 1 ];
    _apgroupmemb = new PGROUP_MEMB[ 1 ];
    if(    _apgroup1 == NULL
	|| _apgroupmemb == NULL )
    {
	delete _apgroupmemb;
	delete _apgroup1;
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }
    _apgroup1[ 0 ] = NULL;
    _apgroupmemb[ 0 ] = NULL;

    _psc = new USER_SC_SET_CONTROL( this, IDGP_ADD, IDGP_REMOVE,
                                    CURSOR::Load(IDC_USERONE),
                                    CURSOR::Load(IDC_USERMANY),
	                            &_lbNotIn, &_lbIn,
                                    COL_WIDTH_WIDE_DM );
    if( _psc == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }

    if (    (err = _nlsComment.QueryError()) != NERR_Success
    	 || (err = _psc->QueryError()) != NERR_Success )
    {
	delete _psc;
	_psc = NULL;
	ReportError( err );
	return;
    }

    _lbIn.Set_SET_CONTROL( _psc );
    _lbNotIn.Set_SET_CONTROL( _psc );

    INT cSelCount = _pulb->QueryCount();
    _posh = new ONE_SHOT_HEAP( cSelCount * sizeof( USER_SC_LBI ) );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if(    _posh == NULL
    	|| (err = _posh->QueryError()) != NERR_Success )
    {
	ReportError( err );
	return;
    }
    _poshSave = ONE_SHOT_OF( USER_SC_LBI )::QueryHeap();
    ONE_SHOT_OF( USER_SC_LBI )::SetHeap( _posh );
} // GROUPPROP_DLG::GROUPPROP_DLG


/*******************************************************************

    NAME:       GROUPPROP_DLG::~GROUPPROP_DLG

    SYNOPSIS:   Destructor for Group Properties main dialog, base class

    HISTORY:
    JonN        09-Oct-1991     Templated from userprop.cxx

********************************************************************/

GROUPPROP_DLG::~GROUPPROP_DLG( void )
{
    if ( _apgroup1 != NULL )
    {
	delete _apgroup1[0];
	delete _apgroup1;
	_apgroup1 = NULL;
    }

    if ( _apgroupmemb != NULL )
    {
	delete _apgroupmemb[0];
	delete _apgroupmemb;
	_apgroupmemb = NULL;
    }

    _lbIn.Set_SET_CONTROL( NULL );
    _lbNotIn.Set_SET_CONTROL( NULL );

    delete _psc;
    _psc = NULL;

    _lbIn.DeleteAllItems();	// these because of the deletion of the
    _lbNotIn.DeleteAllItems();	// one shot heap

    if( _posh != NULL )
    {
	ONE_SHOT_OF( USER_SC_LBI )::SetHeap( _poshSave );
	delete _posh;
	_posh = NULL;
    }

    delete _pbfindStartedSelected;
    delete _psamgroup;
	
} // GROUPPROP_DLG::~GROUPPROP_DLG



/*******************************************************************

    NAME:       GROUPPROP_DLG::InitControls

	
    SYNOPSIS:   Initializes the controls maintained by GROUPPROP_DLG,
		according to the values in the class data members.

    RETURNS:	error code.

    NOTES:	we don't use any intermediate list of users, we move
		users directly between the dialog and the LMOBJ.
	
    CODEWORK  Should this be called W_MembersToDialog?  This would fit
    in with the general naming scheme.

    HISTORY:
               JonN  09-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR GROUPPROP_DLG::InitControls()
{
    ASSERT( _nlsComment.QueryError() == NERR_Success );
    _sleComment.SetText( _nlsComment );

    BOOL fNewVariant = IsNewVariant();
    if ( fNewVariant )
    {
	RESOURCE_STR res( IDS_GRPPROP_NEW_GROUP_DLG_NAME );
	RESOURCE_STR res2( IDS_GRPPROP_GROUP_NAME_LABEL );
	APIERR err = res.QueryError();
	if(     err != NERR_Success
	    || (err = res2.QueryError()) != NERR_Success )
	    return err;

	SetText( res );
	_sltGroupNameLabel.SetText( res2 );
    }

    _sltGroupName.Show( !fNewVariant );
    _sleGroupName.Show( fNewVariant );
    if ( fNewVariant )
        _sleGroupName.ClaimFocus();

    //	these listboxes are already filled and now their first lines are
    //	brought to 'visible'
    _lbNotIn.RemoveSelection();
    _lbIn.RemoveSelection();
    if( _lbIn.QueryCount() > 0 )
    {
	_lbIn.SelectItem( 0, TRUE );
	if ( !fNewVariant )
	    _lbIn.ClaimFocus();
    }
    if( _lbNotIn.QueryCount() > 0 )
    {
	_lbNotIn.SelectItem( 0, TRUE );
        _lbIn.RemoveSelection();
	if ( !fNewVariant )
            _lbNotIn.ClaimFocus();
    }

    _psc->EnableMoves(FALSE);
    if ( !_fDescriptionOnly )
    {
        _psc->EnableMoves(TRUE);
    }

    if ( IsNewVariant() )
        _pbfindStartedSelected = new BITFINDER( _ulbicache.QueryCount() );
    else
        _pbfindStartedSelected = new BITFINDER( _ulbicache );
    APIERR err = (_pbfindStartedSelected == NULL)
                        ? ERROR_NOT_ENOUGH_MEMORY
                        : _pbfindStartedSelected->QueryError();
    if ( err != NERR_Success )
    {
        DBGEOL( "User Manager: error cloning BITFINDER " << err );
        return err;
    }

    return PROP_DLG::InitControls();

} // GROUPPROP_DLG::InitControls


/*******************************************************************

    NAME:       GROUPPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of group to examine.  W_LMOBJToMembers expects to be
		called once for each group, starting from index 0.

    RETURNS:	error code

    NOTES:	This API takes a UINT rather than a GROUP_1 * because it
		must be able to recognize the first group.
			
		We don't use any intermediate list of users, we move
		users directly between the dialog and the LMOBJ.
			
    HISTORY:
               JonN  09-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR GROUPPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    UIASSERT( iObject == 0 );
    GROUP_1 * pgroup1 = QueryGroup1Ptr( iObject );
    UIASSERT( pgroup1 != NULL );

    return _nlsComment.CopyFrom( pgroup1->QueryComment() );

} // GROUPPROP_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       GROUPPROP_DLG::W_PerformOne

    SYNOPSIS:	Saves information on one group

    ENTRY:	iObject is the index of the object to save

		perrMsg is set by subclasses

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
               JonN  11-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR GROUPPROP_DLG::W_PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
TRACETIMESTART;

    UNREFERENCED( perrMsg ); //is set by subclasses
    UIASSERT( iObject < QueryObjectCount() );

    TRACEEOL( "GROUPPROP_DLG::W_PerformOne : " << QueryObjectName( iObject ) );

    *pfWorkWasDone = FALSE;

    GROUP_1 * pgroup1Old = QueryGroup1Ptr( iObject );
    GROUP_MEMB * pgroupmembOld = QueryGroupMembPtr( iObject );
    UIASSERT( pgroup1Old != NULL && pgroupmembOld != NULL );

    GROUP_1 * pgroup1New = new GROUP_1( pgroup1Old->QueryName() );
    // CODEWORK GROUP_MEMB should have a QueryName method
    GROUP_MEMB * pgroupmembNew = new GROUP_MEMB( QueryLocation(), pgroup1Old->QueryName() );
    if ( pgroup1New == NULL || pgroupmembNew == NULL )
    {
	delete pgroup1New;
	delete pgroupmembNew;
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    APIERR err = pgroup1New->CloneFrom( *pgroup1Old );

    if ( err == NERR_Success && IsDownlevelVariant() )
    {
TRACETIMESTART2( clone );
	err = pgroupmembNew->CloneFrom( *pgroupmembOld );
TRACETIMEEND2( clone, "GROUPPROP_DLG::W_PerformOne; GroupMemb clone time " );
    }

    if ( err == NERR_Success )
    {
TRACETIMESTART2( ntl );
	err = W_MembersToLMOBJ( pgroup1New, pgroupmembNew );
TRACETIMEEND2( ntl, "GROUPPROP_DLG::W_PerformOne; clone time " );
    }

    if ( (err == NERR_Success) && IsNewVariant() )
    {
        err = W_MapPerformOneError(
                ((UM_ADMIN_APP *)_pumadminapp)->ConfirmNewObjectName( pgroup1New->QueryName() ));
    }

    TRACEEOL( "GROUPPROP_DLG::W_PerformOne object ready for WriteInfo" );

    if ( err == NERR_Success )
    {
TRACETIMESTART2( _write );
	err = pgroup1New->Write();
TRACETIMEEND2( _write, "GROUPPROP_DLG::W_PerformOne; write time " );
	if ( err == NERR_Success )
        {
	    *pfWorkWasDone = TRUE;

            if ( IsNewVariant() && *pfWorkWasDone )
                ((UM_ADMIN_APP *)_pumadminapp)->NotifyCreateExtensions( QueryHwnd(), pgroup1New );
        }
	else
	{
	    DBGEOL( "GROUPPROP_DLG::W_PerformOne: pgroup1New->WriteInfo raw error " << err );
	    err = W_MapPerformOneError( err );
	}
    }

/*
 * CODEWORK JonN & ThomasPa 3/27/92:  Suppose pgroup1New->Write() succeeds
 * but pgroupmembNew->Write() fails.  The group now exists but its
 * membership is not set.  If the user now changes the group name and
 * hits OK, pgroup1New->Write() will fail, since *pgroup1New thinks the
 * group already exists after the successful WriteNew(), but the name has
 * changed.  The best we can do here is to disable/gray the groupname
 * edit field.  An analogous situation exists in Alias Properties.
 */

    if ( err == NERR_Success )
    {
	SetGroup1Ptr( iObject, pgroup1New ); // change and delete previous
        pgroup1New = NULL;
    }

    do {  // false loop

        if ( _fDescriptionOnly )
            break;

        if ( err != NERR_Success )
        {
            break;
        }

        if ( !IsDownlevelVariant() )
        {
            //
            // We skipped setting the contents of pgroupmembNew
            //

            TRACEEOL( "GROUPPROP_DLG::W_PerformOne; use SAM API" );

            //
            // Build a buffer big enough to hold all the user RIDs,
            // both those users to be added (which will be added to the
            // front of the buffer) and those to be removed (at the
            // back of the buffer).
            //
            ASSERT( _pbfindStartedSelected != NULL );
            UINT cUsersInListbox = _ulbicache.QueryCount();
            BUFFER bufUserRIDs( cUsersInListbox * sizeof(ULONG) );
            if ( (err = bufUserRIDs.QueryError()) != NERR_Success )
            {
                TRACEEOL( "GROUPPROP_DLG::W_PerformOne; RID buffer error " << err );
                break;
            }
            ULONG * pulAddRid = (ULONG *)bufUserRIDs.QueryPtr();
            UINT cAddRids = 0;
            ULONG * pulRemoveRid = pulAddRid + cUsersInListbox;
            UINT cRemoveRids = 0;
            for ( UINT i = 0; i < cUsersInListbox; i++ )
            {
                BOOL fWasIn = _pbfindStartedSelected->IsBitSet( i );
                BOOL fWantedIn = _ulbicache.IsBitSet( i );
                if (fWasIn)
                {
                    if (!fWantedIn)
                    {
                        cRemoveRids++;
                        pulRemoveRid--;
                        *pulRemoveRid = _pulb->QueryDDU(i)->Rid;
                    }
                } else if (fWantedIn)
                {
                    *pulAddRid = _pulb->QueryDDU(i)->Rid;
                    pulAddRid++;
                    cAddRids++;
                }
            }

            if ( cAddRids == 0 && cRemoveRids == 0 )
            {
                TRACEEOL( "GROUPPROP_DLG::W_PerformOne; no users to add or remove" );
                break;
            }

            //
            // Now we have the arrays of user RIDs, get a SAM_GROUP object
            //
            if ( (err = GetSamGroup( QueryGroup1Ptr()->QueryName() )) != NERR_Success )
            {
                DBGEOL( "User Manager: GetSamGroup err " << err );
                break;
            }
            ASSERT( _psamgroup != NULL && _psamgroup->QueryError() == NERR_Success );

            //
            // Now use the SAM API to change the data if necessary
            //
            if ( cAddRids > 0 )
            {
                err = _psamgroup->AddMembers( (ULONG *)bufUserRIDs.QueryPtr(),
                                              cAddRids );
                if ( err != NERR_Success )
                {
                    DBGEOL( "User Manager: AddMembers err " << err );
                    break;
                }
            }
            if ( cRemoveRids > 0 )
            {
                err = _psamgroup->RemoveMembers( pulRemoveRid,
                                                 cRemoveRids );
                if ( err != NERR_Success )
                {
                    DBGEOL( "User Manager: RemoveMembers err " << err );
                    break;
                }
            }

            TRACEEOL( "GROUPPROP_DLG::W_PerformOne; success using SAM API" );
            break;
        }

        TRACEEOL( "GROUPPROP_DLG::W_PerformOne; falling back to GroupMemb" );

TRACETIMESTART2( 1 );
    	err = pgroupmembNew->Write();
TRACETIMEEND2( 1, "GROUPPROP_DLG::W_PerformOne; membership time " );
    	if ( err == NERR_Success )
    	    *pfWorkWasDone = TRUE;
    	else
    	{
    	    DBGEOL( "GROUPPROP_DLG::W_PerformOne: pgroupmembNew->WriteInfo raw error " << err );
    	    err = W_MapPerformOneError( err );
    	}

        if ( err == NERR_Success )
        {
	    SetGroupMembPtr( iObject, pgroupmembNew ); // change and delete previous
            pgroupmembNew = NULL;
        }
    } while (FALSE);

    // these pointers are NULL if all is well
    delete pgroup1New;
    delete pgroupmembNew;


    TRACEEOL( "GROUPPROP_DLG::W_PerformOne returns " << err );

TRACETIMEEND( "GROUPPROP_DLG::W_PerformOne; total time " );

    return err;

} // GROUPPROP_DLG::W_PerformOne


/*******************************************************************

    NAME:       GROUPPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the GROUP_1 object

    ENTRY:	pgroup1	    -   pointer to a GROUP_1 to be modified
	
		pgroupmemb  -   pointer to a GROUP_MEMB to be modified

    RETURNS:	error code
	
    NOTES:	we assume that *pgroupmemb is 'empty', and we add
		all from Members listbox. BUGBUG this is inefficient
		we should use IsIn stuff

    HISTORY:
	       JonN  10-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR GROUPPROP_DLG::W_MembersToLMOBJ(
	GROUP_1 *	pgroup1,
	GROUP_MEMB *	pgroupmemb
	)
{

TRACETIMESTART;

    APIERR err = pgroup1->SetComment( _nlsComment );
    if( err != NERR_Success )
	return err;

    //
    // If the target is NT, we skip the time-consuming GROUP_MEMB
    // maintenance and use an alternate means to add/remove users
    //

    if ( !IsDownlevelVariant() )
    {
        TRACEEOL( "GROUPPROP_DLG::W_MembersToLMOBJ: skip GROUP_MEMB work" );
        return NERR_Success;
    }

TRACETIMESTART2( delete );
    // first the deleting
    for( INT uCount = pgroupmemb->QueryCount() - 1; uCount >= 0; uCount-- )
    {
	err = pgroupmemb->DeleteAssocName( uCount );  // BUGBUG inefficient
	if( err != NERR_Success )	// and will not work well with
	    return err;			// multiselect
	
    }	
TRACETIMEEND2( delete, "GROUPPROP_DLG::W_MembersToLMOBJ: DeleteAssocName calls took " );

TRACETIMESTART2( build );
    INT nCount = _lbIn.QueryCount();
    for( INT i = 0; i < nCount; i++ )
    {
	USER_SC_LBI * pulbi = _lbIn.QueryItem( i );
	UIASSERT( pulbi != NULL );
        DOMAIN_DISPLAY_USER * pddu = pulbi->QueryDDU();
        NLS_STR * pnlsAccount;
        if ( (pddu == NULL) || (pddu->LogonName.Buffer == NULL) )
        {
            pnlsAccount = new NLS_STR();
        }
        else
        {
            pnlsAccount = new NLS_STR( pulbi->QueryDDU()->LogonName.Buffer,
                                       pulbi->QueryDDU()->LogonName.Length / sizeof(TCHAR) );
        }
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   pnlsAccount == NULL
            || (err = pnlsAccount->QueryError()) != NERR_Success
            || (err = pgroupmemb->AddAssocName( *pnlsAccount )) != NERR_Success
           )
        {
            delete pnlsAccount;
	    break;
        }
        delete pnlsAccount;
    }
TRACETIMEEND2( build, "GROUPPROP_DLG::W_MembersToLMOBJ: building list took " );

TRACETIMESTART2( add );
    if ( (err == NERR_Success) && (!IsNewVariant()) )
    {
        ITER_STRLIST itersl( _strlistNamesNotFound );
        NLS_STR * pnlsIter;
        while ( (pnlsIter = itersl.Next()) != NULL )
        {
            if ( (err = pgroupmemb->AddAssocName( *pnlsIter )) != NERR_Success )
            {
                break;
            }
        }
    }
TRACETIMEEND2( add, "GROUPPROP_DLG::W_MembersToLMOBJ: adding unfound users took " );

TRACETIMEEND( "GROUPPROP_DLG::W_MembersToLMOBJ: total time " );

    return err;

} // GROUPPROP_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       GROUPPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	       JonN  10-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR GROUPPROP_DLG::W_DialogToMembers(
	)
{
    APIERR err = NERR_Success;
    if (   ((err = _sleComment.QueryText( &_nlsComment )) != NERR_Success)
	|| ((err = _nlsComment.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    return NERR_Success;

} // GROUPPROP_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       GROUPPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  There
		are no errors associated with an invalid comment, so
		this level does nothing.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
	       JonN  10-Oct-1991    Templated from userprop.cxx
	       JonN  01-Jan-1992    Changed to W_MapPerformOneAPIError
					to W_MapPerformOneError

********************************************************************/

MSGID GROUPPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    return err;

} // GROUPPROP_DLG::W_MapPerformOneError


/*******************************************************************

    NAME:	GROUPPROP_DLG::W_GetOne

    SYNOPSIS:	creates GROUP_1 and GROUP_MEMB objs for GetOne

    ENTRY:	ppgrp1	  -    p to p to GROUP_1
	
		ppgrpmemb -    p to p to GROUP_MEMB
			
		pszName   -    pointer to name for objects to create

    EXIT:	if returns NERR_Success then objects are created and
		checked ( QueryError ), otherwise no memory allocations
		are made

    RETURNS:	error code

    HISTORY:
	    o-SimoP	15-Nov-1991	Created
********************************************************************/
APIERR GROUPPROP_DLG::W_GetOne(
	GROUP_1	   **	pgrp1,
	GROUP_MEMB **	pgrpmemb,
	const TCHAR *	pszName )
{
    *pgrp1 = new GROUP_1( pszName, QueryLocation() );
    *pgrpmemb = new GROUP_MEMB( QueryLocation(), pszName);
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if(   *pgrp1 == NULL
       || *pgrpmemb == NULL
       || ((err = (*pgrp1)->QueryError()) != NERR_Success)
       || ((err = (*pgrpmemb)->QueryError()) != NERR_Success) )
    {
	delete *pgrp1;
	delete *pgrpmemb;
	*pgrp1 = NULL;
	*pgrpmemb = NULL;
	return err;
    }

    return NERR_Success;	

} // GROUPPROP_DLG::W_GetOne


/*******************************************************************

    NAME:	GROUPPROP_DLG::MoveUsersToMembersLb

    SYNOPSIS:	Move users (that are in current GROUP_MEMB) from
		Not Members to Members listbox

    RETURNS:	error code

    NOTES:	uses SET_CONTROL Select... DoAdd

    HISTORY:
	    o-SimoP	15-Nov-1991	Created
********************************************************************/
APIERR GROUPPROP_DLG::MoveUsersToMembersLb()
{
TRACETIMESTART;
    GROUP_MEMB * pgmemb = QueryGroupMembPtr();
    UIASSERT( pgmemb != NULL );

    // we move some items to In box
    APIERR err = _lbIn.SetMembItems( *pgmemb,
                                     &_lbNotIn,
                                     &_strlistNamesNotFound );
TRACETIMEEND( "GROUPPROP_DLG::MoveUsersToMembersLb(): total time " );
    return err;

} // GROUPPROP_DLG::MoveUsersToMembersLb()


/*******************************************************************

    NAME:       GROUPPROP_DLG::OnOK

    SYNOPSIS:   OK button handler.  This handler applies to all variants
		including EDIT_ and NEW_.

    EXIT:	Dismiss() return code indicates whether the dialog wrote
		any changes successfully to the API at any time.

    HISTORY:
               JonN  10-Oct-1991    Templated from userprop.cxx

********************************************************************/

BOOL GROUPPROP_DLG::OnOK( void )
{
TRACETIMESTART;
    APIERR err = W_DialogToMembers();
    if ( err != NERR_Success )
    {
	MsgPopup( this, err );
	return TRUE;
    }

    if ( PerformSeries() )
    	Dismiss( QueryWorkWasDone() );
TRACETIMEEND( "GROUPPROP_DLG::OnOK(): total time " );
    return TRUE;

}   // GROUPPROP_DLG::OnOK


/*******************************************************************

    NAME:       GROUPPROP_DLG::QueryObjectCount

    SYNOPSIS:   Returns the number of selected groups, always 1 at present

    HISTORY:
               JonN  10-Oct-1991    Templated from userprop.cxx

********************************************************************/

UINT GROUPPROP_DLG::QueryObjectCount( void ) const
{
    return 1;

} // GROUPPROP_DLG::QueryObjectCount


/*******************************************************************

    NAME:	GROUPPROP_DLG::QueryGroup1Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

GROUP_1 * GROUPPROP_DLG::QueryGroup1Ptr( UINT iObject ) const
{
    ASSERT( _apgroup1 != NULL );
    ASSERT( iObject == 0 );
    return _apgroup1[ iObject ];

} // GROUPPROP_DLG::QueryGroup1Ptr


/*******************************************************************

    NAME:	GROUPPROP_DLG::SetGroup1Ptr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

VOID GROUPPROP_DLG::SetGroup1Ptr( UINT iObject, GROUP_1 * pgroup1New )
{
    ASSERT( _apgroup1 != NULL );
    ASSERT( iObject == 0 );
    ASSERT( (pgroup1New == NULL) || (pgroup1New != _apgroup1[iObject]) );
    delete _apgroup1[ iObject ];
    _apgroup1[ iObject ] = pgroup1New;

} // GROUPPROP_DLG::SetGroup1Ptr


/*******************************************************************

    NAME:	GROUPPROP_DLG::QueryGroupMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

GROUP_MEMB * GROUPPROP_DLG::QueryGroupMembPtr( UINT iObject ) const
{
    ASSERT( _apgroupmemb != NULL );
    ASSERT( iObject == 0 );
    return _apgroupmemb[ iObject ];

} // GROUPPROP_DLG::QueryGroupMembPtr


/*******************************************************************

    NAME:	GROUPPROP_DLG::SetGroupMembPtr

    SYNOPSIS:   Accessor to the NEW_LM_OBJ arrays, for use by subdialogs

    HISTORY:
    JonN        11-Sep-1991     De-inlined

********************************************************************/

VOID GROUPPROP_DLG::SetGroupMembPtr( UINT iObject, GROUP_MEMB * pgroupmembNew )
{
    ASSERT( _apgroupmemb != NULL );
    ASSERT( iObject == 0 );
    ASSERT( (pgroupmembNew == NULL) || (pgroupmembNew != _apgroupmemb[iObject]));
    delete _apgroupmemb[ iObject ];
    _apgroupmemb[ iObject ] = pgroupmembNew;

} // GROUPPROP_DLG::SetGroupMembPtr


/*******************************************************************

    NAME:	GROUPPROP_DLG::GetSamGroup

    SYNOPSIS:   Creates a SAM_GROUP object and stores it in _psamgroup

    HISTORY:
    JonN        12-Oct-1994     Created

********************************************************************/

APIERR GROUPPROP_DLG::GetSamGroup( const TCHAR * pszGroupName )
{

TRACETIMESTART;

    if (_psamgroup != NULL)
    {
        TRACEEOL( "User Manager: already have SAM_GROUP" );
        return NERR_Success;
    }

    ASSERT( !IsDownlevelVariant() );

    APIERR err = NERR_Success;
    SAM_DOMAIN * psamdomain =
         _pumadminapp->QueryAdminAuthority()->QueryAccountDomain();

    if ( _ulGroupRID == 0 )
    {
        // we must jump through some hoops to get the group RID
        // should only occur for Product 1 target server
        SAM_RID_MEM samrm;
        SAM_SID_NAME_USE_MEM samsnum;
        if (   (err = samrm.QueryError()) != NERR_Success
            || (err = samsnum.QueryError()) != NERR_Success
            || (err = psamdomain->TranslateNamesToRids(
                                     &pszGroupName,
                                     1,
                                     &samrm,
                                     &samsnum )) != NERR_Success
           )
        {
            DBGEOL( "User Manager: Could not obtain group RID" );
            return err;
        }
        REQUIRE( (_ulGroupRID = samrm.QueryRID( 0 )) != 0 );
    }

    // global groups are always in the Accounts domain
    _psamgroup = new SAM_GROUP( *psamdomain,
                                _ulGroupRID,
                                GROUP_DESIRED_ACCESS_ALL );
    err = (_psamgroup == NULL) ? ERROR_NOT_ENOUGH_MEMORY
                               : _psamgroup->QueryError();
    if (err != NERR_Success)
    {
        DBGEOL( "User Manager: unable to edit group; err " << err );
        delete _psamgroup;
        _psamgroup = NULL;
        return err;
    }
TRACETIMEEND( "GROUPPROP_DLG::GetSamGroup time " );

    return err;

} // GROUPPROP_DLG::GetSamGroup



/*******************************************************************

    NAME:	EDIT_GROUPPROP_DLG::EDIT_GROUPPROP_DLG

    SYNOPSIS:   constructor for Group Properties main dialog, edit
		group variant
			
    ENTRY:	powin	-   pointer to OWNER_WINDOW
	
		pulb	-   pointer to main window LAZY_USER_LISTBOX
			
		loc	-   reference to current LOCATION
			
		psel	-   pointer to ADMIN_SELECTION, currently only
			    one group can be selected

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

EDIT_GROUPPROP_DLG::EDIT_GROUPPROP_DLG(
	const OWNER_WINDOW * powin,
	const UM_ADMIN_APP * pumadminapp,
	      LAZY_USER_LISTBOX * pulb,
	const LOCATION & loc,
	const ADMIN_SELECTION * psel,
              ULONG  ulGroupRID
	) : GROUPPROP_DLG(
		powin,
		pumadminapp,
		pulb,
		loc,
		psel,
                ulGroupRID
		),
	    _psel( psel )
{
    ASSERT( QueryObjectCount() == 1 );

    if ( QueryError() != NERR_Success )
	return;

} // EDIT_GROUPPROP_DLG::EDIT_GROUPPROP_DLG


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::~EDIT_GROUPPROP_DLG

    SYNOPSIS:   destructor for Group Properties main dialog, edit
		group variant

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

EDIT_GROUPPROP_DLG::~EDIT_GROUPPROP_DLG( void )
{
} // EDIT_GROUPPROP_DLG::~EDIT_GROUPPROP_DLG


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::GetOne

    SYNOPSIS:   Loads information on one group

    ENTRY:	iObject is the index of the object to load

		perrMsg returns the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

    RETURNS:	error code

    NOTES:      This version of GetOne assumes that the group already
		exists.  Classes which work with new group will want
		to define their own GetOne.

                It is unusual for a GetOne routine to bring up its own
                MsgPopup.  This defeats the AUTO_CURSOR in BASEPROP.
                We must replace the AUTO_CURSOR, here and then later
                in InitControls, to keep the wait-cursor displayed
                when the user edits Domain Users.

    HISTORY:
               JonN  11-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR EDIT_GROUPPROP_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
TRACETIMESTART;
    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( perrMsg != NULL );

    APIERR err = NERR_Success;

    *perrMsg = IDS_UMGetOneGroupFailure;

// Check whether we have write permission.  If not, do not allow
// editing.
// CODEWORK:  We might want a better error message for the case where
// we can read but not edit.
// CODEWORK:  It would be nice if this dialog had a "read-only mode".
    AUTO_CURSOR autocur; // in case popup appeared
    if ( !IsDownlevelVariant() )
    {
        err = GetSamGroup( QueryObjectName( 0 ) );
        if (err != NERR_Success)
        {
            DBGEOL( "User Manager: no permission to edit group; err " << err );
            return err;
        }
    }

    GROUP_1 * pgroup1New = NULL;
    GROUP_MEMB * pgroupmembNew = NULL;
    err = W_GetOne( &pgroup1New, &pgroupmembNew, QueryObjectName( iObject ) );
    if( err != NERR_Success )
	return err;

    err = pgroup1New->GetInfo();

    if ( err == NERR_Success )
    {
TRACETIMESTART2( getinfo );
    	err = pgroupmembNew->GetInfo();
TRACETIMEEND2( getinfo, "EDIT_GROUPPROP_DLG::GetOne(): GetInfo() " );
    }

    if ( err != NERR_Success )
    {
	delete pgroupmembNew;
	delete pgroup1New;
	return err;
    }

    SetGroup1Ptr( iObject, pgroup1New ); // change and delete previous
    SetGroupMembPtr( iObject, pgroupmembNew ); // change and delete previous

    err = W_LMOBJtoMembers( iObject );
TRACETIMEEND( "EDIT_GROUPPROP_DLG::GetOne(): total time " );
    return err;

} // EDIT_GROUPPROP_DLG::GetOne


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::PerformOne

    SYNOPSIS:	Saves information on one group

    ENTRY:	iObject is the index of the object to save

		perrMsg is the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
               JonN  11-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR EDIT_GROUPPROP_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );
    *perrMsg = IDS_UMEditGroupFailure;
    return W_PerformOne( iObject, perrMsg, pfWorkWasDone );

} // EDIT_GROUPPROP_DLG::PerformOne


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::InitControls

    SYNOPSIS:   See GROUPPROP_DLG::InitControls().

    RETURNS:	error code

    HISTORY:
               JonN  11-Oct-1991    Templated from userprop.cxx

********************************************************************/

APIERR EDIT_GROUPPROP_DLG::InitControls()
{
    AUTO_CURSOR autocur2; // in case popup in GetOne() appeared

    APIERR err = MoveUsersToMembersLb();
    if ( err != NERR_Success )
    {
        return err;
    }
    _sltGroupName.SetText( QueryGroup1Ptr()->QueryName() );
    return GROUPPROP_DLG::InitControls();

} // EDIT_GROUPPROP_DLG::InitControls


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::QueryObjectName

    SYNOPSIS:   Returns the name of the selected group.  This is meant for
		use with "edit group" variants and should be redefined
		for "new group" variants.

    HISTORY:
               JonN  11-Oct-1991    Templated from userprop.cxx

********************************************************************/

const TCHAR * EDIT_GROUPPROP_DLG::QueryObjectName(
	UINT		iObject
	) const
{
    UIASSERT( _psel != NULL );
    return _psel->QueryItemName( iObject );

} // EDIT_GROUPPROP_DLG::QueryObjectName


/*******************************************************************

    NAME:       EDIT_GROUPPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to promote a backup
		domain controller to primary domain controller.

    HISTORY:
       o-SimoP	13-Nov-1991	Created
********************************************************************/

ULONG EDIT_GROUPPROP_DLG::QueryHelpContext( void )
{

    return HC_UM_GROUPPROP_LANNT + QueryHelpOffset();

} // EDIT_GROUPPROP_DLG :: QueryHelpContext



/*******************************************************************

    NAME:	NEW_GROUPPROP_DLG::NEW_GROUPPROP_DLG

    SYNOPSIS:   Constructor for Group Properties main dialog, new user variant
	
    ENTRY:	powin	-   pointer to OWNER_WINDOW
	
		pulb	-   pointer to main window LAZY_USER_LISTBOX
			
		loc	-   reference to current LOCATION
			
		psel	-   pointer to ADMIN_SELECTION, currently only
			    one group can be selected
				
		pszCopyFrom - The name of the group to be copied.  Pass
			      the name for "Copy..." actions, or NULL for
			      "New..." actions

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

NEW_GROUPPROP_DLG::NEW_GROUPPROP_DLG(
	const OWNER_WINDOW * powin,
	const UM_ADMIN_APP * pumadminapp,
	      LAZY_USER_LISTBOX * pulb,
	const LOCATION & loc,
	const TCHAR * pszCopyFrom
	) : GROUPPROP_DLG(
		powin,
		pumadminapp,
		pulb,
		loc,
		NULL
		),
	    _nlsGroupName(),
	    _pszCopyFrom( pszCopyFrom )
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

} // NEW_GROUPPROP_DLG::NEW_GROUPPROP_DLG



/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::~NEW_GROUPPROP_DLG

    SYNOPSIS:   Destructor for Group Properties main dialog, new user variant

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

NEW_GROUPPROP_DLG::~NEW_GROUPPROP_DLG( void )
{
} // NEW_GROUPPROP_DLG::~NEW_GROUPPROP_DLG


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::GetOne

    SYNOPSIS:   if _pszCopyFrom is NULL, then this is New Group,
		otherwise this is Copy Group

    ENTRY:	iObject is the index of the object to load

		perrMsg returns the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

    RETURNS:	error code

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx
    JonN        02-Dec-1991     Added PingFocus()

********************************************************************/

APIERR NEW_GROUPPROP_DLG::GetOne(
	UINT		iObject,
	APIERR *	perrMsg
	)
{
TRACETIMESTART;
    *perrMsg = IDS_UMCreateNewGroupFailure;
    UIASSERT( iObject == 0 );

    GROUP_1 * pgroup1New = NULL;
    GROUP_MEMB * pgroupmembNew = NULL;

    APIERR err = W_GetOne( &pgroup1New, &pgroupmembNew, _pszCopyFrom );
    if( err != NERR_Success )
	return err;

    if ( _pszCopyFrom == NULL )
    {
        err = PingFocus( QueryLocation() );
	if ( err == NERR_Success )
            err = pgroup1New->CreateNew();
	if ( err == NERR_Success )
            err = pgroupmembNew->CreateNew();
    }
    else
    {
/*	If you try copy one of groups ADMINS, USERS or GUESTS under
	LM2.X pgroup1New->GetInfo will fail (should work under NT).
	When LM2.x we call pgroup1New->CreateNew
*/
	BOOL fNT = (QueryTargetServerType() != UM_DOWNLEVEL);

	if( !fNT && IS_USERPRIV_GROUP( _pszCopyFrom ) )
	{
	    DBGEOL( "Cannot copy " << _pszCopyFrom << ", start new instead" );
	    err = pgroup1New->CreateNew();
	}
	else
	{
	    err = pgroup1New->GetInfo();
	    if( err == NERR_Success )
		err = pgroup1New->ChangeToNew();
	    if( err == NERR_Success )
		err = pgroup1New->SetName( NULL );
        }
	
TRACETIMESTART2( getinfo );
	if( err == NERR_Success )
	    err = pgroupmembNew->GetInfo();
TRACETIMEEND2( getinfo, "NEW_GROUPPROP_DLG::GetOne(): memb getinfo time " );
	if( err == NERR_Success )
	    err = pgroupmembNew->ChangeToNew();
    }

    if( err != NERR_Success )
    {
	delete pgroup1New;
	delete pgroupmembNew;
	return err;
    }
	
    SetGroup1Ptr( iObject, pgroup1New ); // change and delete previous
    SetGroupMembPtr( iObject, pgroupmembNew ); // change and delete previous

    err = W_LMOBJtoMembers( iObject );
TRACETIMEEND( "NEW_GROUPPROP_DLG::GetOne(): total time " );
    return err;

} // NEW_GROUPPROP_DLG::GetOne


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::InitControls

    SYNOPSIS:	See GROUPPROP_DLG::InitControls()

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_GROUPPROP_DLG::InitControls()
{
TRACETIMESTART;
    APIERR err = NERR_Success;
    if( _pszCopyFrom == NULL ) // we like to put selected users to
    {				// members listbox
	INT cSelCount = _pulb->QuerySelCount();
	UIASSERT( cSelCount >= 0 );
        do // false loop
        {
            if (cSelCount == 0)
                break;

            /*
             *  move selected items in main user lb to Members listbox
             */
	    BUFFER buf( sizeof(INT) * cSelCount );
	    if ( (err = buf.QueryError()) != NERR_Success )
		break;

	    INT * aiSel = (INT *) buf.QueryPtr();
	    err = _pulb->QuerySelItems( aiSel, cSelCount );
	    if ( err != NERR_Success )
		break;

            // we assume that all items are in the Not In listbox
            // and skip the ReverseFind
            _lbNotIn.RemoveSelection();
            _lbNotIn.SelectItems( aiSel, cSelCount );
            _lbNotIn.FlipSelectedItems( &_lbIn );

	} while (FALSE); // false loop
    }
    else
    {
	err = MoveUsersToMembersLb();
    }

    if( err != NERR_Success )
    {
        DBGEOL( "NEW_GROUPPROP_DLG::InitControls error " << err );
	return err;	
    }
    // leave _sleGroupName blank
	
    err = GROUPPROP_DLG::InitControls();
TRACETIMEEND( "NEW_GROUPPROP_DLG::InitControls(): total time " );
    return err;

} // NEW_GROUPPROP_DLG::InitControls


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::PerformOne

    SYNOPSIS:	This is the "new group" variant of GROUPPROP_DLG::PerformOne()
	
    ENTRY:	iObject is the index of the object to save

		perrMsg is the error message to be displayed if an
		error occurs, see PERFORMER::PerformSeries for details

		pfWorkWasDone indicates whether any UAS changes were
		successfully written out.  This may return TRUE even if
		the PerformOne action as a whole failed (i.e. PerformOne
		returned other than NERR_Success).

    RETURNS:	error message (not necessarily an error code)

    NOTE:	NTISSUES bug 759 confirms that we do not take any
    		special action to prevent the creation of groups with
		names such as "Domain Account Operators" on LM2x
		domains.

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_GROUPPROP_DLG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );
    *perrMsg = IDS_UMCreateGroupFailure;
    return W_PerformOne( iObject, perrMsg, pfWorkWasDone );

} // NEW_GROUPPROP_DLG::PerformOne


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::W_MapPerformOneError

    SYNOPSIS:	Checks whether the error maps to a specific control
		and/or a more specific message.  Each level checks for
		errors specific to edit fields it maintains.  This
		level checks for errors associated with the GroupName
		edit field.

    ENTRY:      Error returned from PerformOne()

    RETURNS:	Error to be displayed to user

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx
    JonN	01-Jan-1992	Changed to W_MapPerformOneAPIError
				to W_MapPerformOneError

********************************************************************/

MSGID NEW_GROUPPROP_DLG::W_MapPerformOneError(
	APIERR err
	)
{
    APIERR errNew = NERR_Success;
    switch ( err )
    {
    case NERR_BadUsername:
	errNew = IERR_UM_GroupnameRequired;
	break;
    case NERR_GroupExists:
    case NERR_SpeGroupOp:
	errNew = IERR_UM_GroupnameAlreadyGroup;
	break;
    case NERR_UserExists:
	errNew = IERR_UM_GroupnameAlreadyUser;
	break;
    default: // other error
        return GROUPPROP_DLG::W_MapPerformOneError( err );
    }

    _sleGroupName.SelectString();
    _sleGroupName.ClaimFocus();
    return errNew;

} // NEW_GROUPPROP_DLG::W_MapPerformOneError


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::QueryObjectName

    SYNOPSIS:	This is the "new group" variant of QueryObjectName.  The
		best name we can come up with is the last name read from
		the dialog.

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

const TCHAR * NEW_GROUPPROP_DLG::QueryObjectName(
	UINT		iObject
	) const
{
    UIASSERT( iObject == 0 );
    return _nlsGroupName.QueryPch();

} // NEW_GROUPPROP_DLG::QueryObjectName


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_GROUPPROP_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    ASSERT( iObject == 0 );

    APIERR err = _nlsGroupName.CopyFrom(QueryGroup1Ptr(iObject)->QueryName());
    if ( err != NERR_Success )
        return err;
    return GROUPPROP_DLG::W_LMOBJtoMembers( iObject );

} // NEW_GROUPPROP_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the GROUP_1 object

    ENTRY:	pgroup1	    -   pointer to a GROUP_1 to be modified
	
		pgroupmemb  -   pointer to a GROUP_MEMB to be modified
			
    RETURNS:	error code

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_GROUPPROP_DLG::W_MembersToLMOBJ(
	GROUP_1 *	pgroup1,
	GROUP_MEMB *	pgroupmemb
	)
{
    APIERR err = pgroup1->SetName( _nlsGroupName.QueryPch() );
    if ( err != NERR_Success )
	return err;

    err = pgroupmemb->SetName( _nlsGroupName.QueryPch() );
    if ( err != NERR_Success )
	return err;

    return GROUPPROP_DLG::W_MembersToLMOBJ( pgroup1, pgroupmemb );

} // NEW_GROUPPROP_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    NOTES:	This method takes care of validating the data in the
    		dialog.  This means ensuring that the logon name is
		valid.  If this validation fails, W_DialogToMembers will
		change focus et al. in the dialog, and return the error
		message to be displayed.

    HISTORY:
    JonN        11-Oct-1991     Templated from userprop.cxx

********************************************************************/

APIERR NEW_GROUPPROP_DLG::W_DialogToMembers(
	)
{
    // _sleGroupName is an SLE_STRIP and will strip whitespace
    APIERR err = NERR_Success;
    if (   ((err = _sleGroupName.QueryText( &_nlsGroupName )) != NERR_Success )
        || ((err = _nlsGroupName.QueryError()) != NERR_Success ) )
    {
	return err;
    }

    // CODEWORK should use VALIDATED_DIALOG
    if (   ( _nlsGroupName.strlen() == 0 )
	|| ( NERR_Success != ::I_MNetNameValidate( NULL,
						_nlsGroupName,
						NAMETYPE_GROUP,
						0L ) ) )
    {
	_sleGroupName.SelectString();
	_sleGroupName.ClaimFocus();
	return IERR_UM_GroupnameRequired;
    }

    return GROUPPROP_DLG::W_DialogToMembers();

} // NEW_GROUPPROP_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       NEW_GROUPPROP_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to promote a backup
		domain controller to primary domain controller.

    HISTORY:
               JonN  24-Jul-1991    created

********************************************************************/

ULONG NEW_GROUPPROP_DLG::QueryHelpContext( void )
{

    // For Final product this should be a different help context
    // than for the edit variant
    return HC_UM_GROUPPROP_LANNT + QueryHelpOffset();

} // NEW_GROUPPROP_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\memblb.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    memblb.cxx
    MEMB_SC_LISTBOX class implementation


    FILE HISTORY:
        jonn        07-Oct-1991     Split from umembdlg.cxx
        o-SimoP     23-Oct-1991     Added headers
        o-SimoP     25-Oct-1991     Modified for multiple DM_DTEs
        o-SimoP     31-Oct-1991     Code Review changes, attended by JimH,
                                    ChuckC, JonN and I
        o-SimoP     12-Nov-1991     Added USER_SC_LBI/LISTBOX
        o-Simop     27-Nov-1991     Code Review changes, attended by JimH,
                                    JonN, BenG and I
        o-SimoP     11-Dec-1991     USER_SC_LISTBOX inherits now form
                                    USER_LISTBOX_BASE and MEMB_SC_LISTBOX
        o-SimoP     31-Dec-1991 CR changes, attended by BenG, JonN and I
        JonN        27-Feb-1992     Multiple bitmaps in both panes
        JonN        17-Apr-1992     Fixed _apdmdte ctor/dtor
        thomaspa    28-Apr-1992     Added SelectItems2(), FindItemByRid()
        jonn        10-Sep-1993     USER_SC_LISTBOX becomes lazy
*/

#include <ntincl.hxx>


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_SETCONTROL
#define INCL_BLT_TIMER
#define INCL_BLT_APP
#include <blt.hxx>

extern "C"
{
    #include <usrmgrrc.h>
    #include <ntlsa.h>
    #include <ntsam.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <usrlb.hxx>
#include <memblb.hxx>
#include <usrcolw.hxx>
#include <uintsam.hxx>
#include <bmpblock.hxx>

LAZY_USER_LISTBOX * USER_SC_LISTBOX :: _pulbst = NULL ;


/*******************************************************************

    NAME:       MEMB_SC_LISTBOX::MEMB_SC_LISTBOX

    SYNOPSIS:   constructor

    ENTRY:      powin   -       pointer to OWNER_WINDOW
                cid     -       id for this

    HISTORY:
        o-SimoP     23-Oct-1991 Added header
        o-SimoP     25-Oct-1991 Modified for multiple DM_DTEs
        beng        07-Jun-1992 Support for direct manipulation

********************************************************************/

MEMB_SC_LISTBOX::MEMB_SC_LISTBOX( OWNER_WINDOW * powin, CID cid )
    :   BLT_LISTBOX( powin, cid ),
        CUSTOM_CONTROL( this ),
        _psetcontrol( NULL ),
        _hawinfo()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _hawinfo.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       MEMB_SC_LISTBOX::~MEMB_SC_LISTBOX()

    SYNOPSIS:   destructor

    HISTORY:
        o-SimoP     23-Oct-1991     Added header
        o-SimoP     25-Oct-1991     Added delete for array & item in it

********************************************************************/

MEMB_SC_LISTBOX::~MEMB_SC_LISTBOX()
{
    // nothing happening
}


/*******************************************************************

    NAME:       MEMB_SC_LISTBOX::SelectMembItems

    SYNOPSIS:   selects/deselects items according to given MEMBERSHIP_LM_OBJ

    ENTRY:      memb    -       reference to MEMBERSHIP_LM_OBJ
                fSelect -       if TRUE select, otherwise deselect

    RETURNS:    error code, which is NERR_Success on success

    HISTORY:
        o-SimoP     23-Oct-1991     Added header

********************************************************************/

APIERR MEMB_SC_LISTBOX::SelectMembItems( const MEMBERSHIP_LM_OBJ & memb,
                                         BOOL fSelect,
                                         STRLIST * pstrlistNotFound )
{
    APIERR err = NERR_Success;
    INT c = memb.QueryCount();
    for ( INT i = 0; i < c; i++ )
    {
        INT ilbi;
        err = W_FindItem( memb.QueryAssocName( i ), &ilbi );
        if( err != NERR_Success )
        {
            TRACEEOL( "MEMB_SC_LISTBOX::SelectMembItems: W_FindItem error " << err );
            break;
        }
        if ( ilbi < 0 )
        {
            //  This is certainly allowed to happen.
            //  Remember this item if STRLIST provided
            if (pstrlistNotFound != NULL)
            {
                NLS_STR * pnlsNew = new NLS_STR( memb.QueryAssocName( i ) );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   pnlsNew == NULL
                    || (err = pnlsNew->QueryError()) != NERR_Success
                   )
                {
                    TRACEEOL( "MEMB_SC_LISTBOX::SelectMembItems: alloc error " << err );
                    delete pnlsNew;
                    break;
                }

                if ( (err = pstrlistNotFound->Append( pnlsNew )) != NERR_Success
                   )
                {
                    TRACEEOL( "MEMB_SC_LISTBOX::SelectMembItems: could not append " << err );
                    break;
                }
            }
        }
        else
        {
            SelectItem( ilbi, fSelect );
        }
    }

    return err;
}


/*******************************************************************

    NAME:       MEMB_SC_LISTBOX::SelectAllItems

    SYNOPSIS:   selects all items

    HISTORY:
        o-SimoP     23-Oct-1991     Added header

********************************************************************/

VOID MEMB_SC_LISTBOX::SelectAllItems()
{
    INT c = QueryCount();

    for ( INT i = 0; i < c; i++ )
    {
        SelectItem( i );
    }
}


/*******************************************************************

    NAME:       MEMB_SC_LISTBOX::CD_Char

    SYNOPSIS:   Handle keypresses according to HAW-for-Hawaii

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

********************************************************************/

INT MEMB_SC_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    return CD_Char_HAWforHawaii( wch, nLastPos, &_hawinfo );
}


/*********************************************************************

    NAME:       MEMB_SC_LISTBOX::OnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

BOOL MEMB_SC_LISTBOX::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnLMouseButtonDown( (LISTBOX *)this,
                                                          (CUSTOM_CONTROL *)this,
                                                          e )
                : CUSTOM_CONTROL::OnLMouseButtonDown( e );
}


/*********************************************************************

    NAME:       MEMB_SC_LISTBOX::OnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

BOOL MEMB_SC_LISTBOX::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnLMouseButtonUp( (LISTBOX *)this,
                                                        (CUSTOM_CONTROL *)this,
                                                        e )
                : CUSTOM_CONTROL::OnLMouseButtonUp( e );
}


/*********************************************************************

    NAME:       MEMB_SC_LISTBOX::OnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

BOOL MEMB_SC_LISTBOX::OnMouseMove( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnMouseMove( (LISTBOX *)this,
                                                   e )
                : CUSTOM_CONTROL::OnMouseMove( e );
}


/*********************************************************************

    NAME:       MEMB_SC_LISTBOX::Set_SET_CONTROL

    SYNOPSIS:   List listbox to specified SET_CONTROL

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

VOID MEMB_SC_LISTBOX::Set_SET_CONTROL( SET_CONTROL * psetcontrol )
{
    ASSERT( psetcontrol == NULL || psetcontrol->QueryError() == NERR_Success );

    _psetcontrol = psetcontrol;
}



/*******************************************************************

    NAME:       GROUP_SC_LBI::GROUP_SC_LBI

    SYNOPSIS:   constructor

    ENTRY:      pszName -       pointer to group name for item

                uIndex  -       index for display map

    HISTORY:
        o-SimoP     23-Oct-1991     Added header

********************************************************************/

GROUP_SC_LBI::GROUP_SC_LBI( const TCHAR * pszName,
                            enum GROUPLB_GRP_INDEX uIndex,
                            ULONG rid,
                            BOOL fBuiltin )
    :   LBI(),
        _nlsName( pszName ),
        _uIndex( uIndex ),
        _rid( rid ),
        _fBuiltin( fBuiltin ),
        _fIsIn( FALSE )
{
    UIASSERT( ::strlenf( pszName ) <= GROUPLB_MAX_ITEM_LEN  );
    ASSERT( uIndex < GROUPLB_LB_OF_DMID_SIZE );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       GROUP_SC_LBI::~GROUP_SC_LBI

    SYNOPSIS:   destructor

    HISTORY:
        o-SimoP     23-Oct-1991     Added header

********************************************************************/

GROUP_SC_LBI::~GROUP_SC_LBI()
{
    // nothing
}


/*******************************************************************

    NAME:       GROUP_SC_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

WCHAR GROUP_SC_LBI::QueryLeadingChar() const
{
    ISTR istr( _nlsName );
    return _nlsName.QueryChar( istr );
}


/*******************************************************************

    NAME:       GROUP_SC_LBI::Compare

    SYNOPSIS:   Compares two GROUP_SC_LBI's

    ENTRY:      plbi -      Pointer to other GROUP_SC_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    HISTORY:
        rustanl     18-Jul-1991     Created

********************************************************************/

INT GROUP_SC_LBI::Compare( const LBI * plbi ) const
{
    INT i = _nlsName._stricmp( ((const GROUP_SC_LBI *)plbi)->_nlsName );
    if( i == 0 )
    {
        i = ((const GROUP_SC_LBI *)plbi)->_uIndex - _uIndex;
    }
    return i;
}


/*******************************************************************

    NAME:       GROUP_SC_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Compares a GROUP_LBI with a leading string

    RETURNS:    As Compare()

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

********************************************************************/

INT GROUP_SC_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    ISTR istr( nls );
    UINT cchIn = nls.QueryTextLength();
    istr += cchIn;

    // TRACEOUT(   "User Manager: GROUP_SC_LBI::Compare_HAWforHawaii(): \""
    //          << nls
    //          << "\", \""
    //          << _nlsName
    //          << "\", "
    //          << cchIn
    //          );
    return nls._strnicmp( _nlsName, istr );
}


/*******************************************************************

    NAME:       GROUP_SC_LBI::Paint

    SYNOPSIS:   Draw an entry in GROUP_SC_LISTBOX.

    ENTRY:      plb             - Pointer to a BLT_LISTBOX.

                hdc             - The DC to draw upon.

                prect           - Clipping rectangle.

                pGUILTT         - GUILTT info.

    HISTORY:
        o-SimoP     23-Oct-1991 Added header
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/

VOID GROUP_SC_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                          GUILTT_INFO * pGUILTT ) const
{

    STR_DTE strdte( _nlsName.QueryPch() );

    DISPLAY_TABLE dtab( ((GROUP_SC_LISTBOX *)plb)->QueryColumnsCount(),
        ((GROUP_SC_LISTBOX *)plb)->QueryColWidths() );
    dtab[ 0 ] = (DM_DTE *)((GROUP_SC_LISTBOX *)plb)->QueryDmDte( _uIndex );
    dtab[ 1 ] = &strdte;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::GROUP_SC_LISTBOX

    SYNOPSIS:   constructor

    ENTRY:      powin   -       pointer to OWNER_WINDOW
                cid     -       id for this

    HISTORY:
        o-SimoP     23-Oct-1991 Added header
        o-SimoP     25-Oct-1991 Modified for multiple DM_DTEs
        beng        07-Jun-1992 Support for direct manipulation

********************************************************************/

GROUP_SC_LISTBOX::GROUP_SC_LISTBOX( OWNER_WINDOW * powin,
                                    CID cid,
                                    const SUBJECT_BITMAP_BLOCK & bmpblock )
    : MEMB_SC_LISTBOX( powin, cid ),
      _bmpblock( bmpblock )
      // cannot yet initialize _adxColWidths
{
    if ( QueryError() != NERR_Success )
        return;

    _adxColWidths[ 0 ] = COL_WIDTH_WIDE_DM;
    _adxColWidths[ 1 ] = COL_WIDTH_AWAP;
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::~GROUP_SC_LISTBOX()

    SYNOPSIS:   destructor

    HISTORY:
        o-SimoP     23-Oct-1991     Added header
        o-SimoP     25-Oct-1991     Added delete for array & item in it

********************************************************************/

GROUP_SC_LISTBOX::~GROUP_SC_LISTBOX()
{
}



/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::QueryDmDte

    SYNOPSIS:   returns display map

    ENTRY:      uIndex  -       index for display map

    RETURNS:    pointer to display map

    HISTORY:
        o-SimoP     23-Oct-1991     Added header
        o-SimoP     25-Oct-1991     Modified for multiple DM_DTEs

********************************************************************/

const DM_DTE * GROUP_SC_LISTBOX::QueryDmDte(
                        enum GROUPLB_GRP_INDEX uIndex )
{
    SID_NAME_USE sidtype = SidTypeUnknown;

    switch (uIndex)
    {
        case GROUPLB_GROUP:
            sidtype = SidTypeGroup;
            break;

        case GROUPLB_ALIAS:
            sidtype = SidTypeAlias;
            break;

        default:
            DBGEOL( "GROUP_LISTBOX::QueryDmDte: bad nIndex " << (INT)uIndex );
            ASSERT( FALSE );
            break;
    }

    return ((SUBJECT_BITMAP_BLOCK &)_bmpblock).QueryDmDte( sidtype );
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::W_FindItem

    SYNOPSIS:   Finds item

    ENTRY:      pszName    -    pointer to group name to be found

                pIndex     -    pointer to index

    RETURNS:    error code, which is NERR_Success on success

    NOTES:      This doesn't find SPECIAL GROUPS, for now this is OK
                because when this is used there isn't any special groups

    HISTORY:
        o-SimoP     7-Nov-1991      Created

********************************************************************/

APIERR GROUP_SC_LISTBOX::W_FindItem( const TCHAR * pszName, INT * pIndex )
{
    GROUP_SC_LBI grlbi( pszName, GROUPLB_GROUP );
    APIERR err = grlbi.QueryError();
    if( err != NERR_Success )
        return err;
    *pIndex = FindItem( grlbi );
    return NERR_Success;
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::QueryColumnsCount

    SYNOPSIS:   returns the count of columns

    HISTORY:
        o-SimoP     25-Nov-1991     Deinlined

********************************************************************/

UINT GROUP_SC_LISTBOX::QueryColumnsCount() const
{
    return GROUPLB_COLUMNS_COUNT;
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::QueryColWidths

    SYNOPSIS:   returns pointer to array of column widths

    HISTORY:
        o-SimoP     25-Nov-1991     Deinlined

********************************************************************/

const UINT * GROUP_SC_LISTBOX::QueryColWidths() const
{
    return _adxColWidths;
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::SelectItems2

    SYNOPSIS:   selects/deselects items according to given SAM_RID_MEM

    ENTRY:      samrm    -       reference to SAM_RID_MEM

                fBuiltin -      if TRUE look for items from Builtin Domain
                                if FALSE look for items in Accounts Domain

                fSelect -       if TRUE select, otherwise deselect

    RETURNS:    error code, which is NERR_Success on success

    HISTORY:
        Thomaspa     28-Apr-1992     Templated from MEMB_SC_LISTBOX

********************************************************************/

APIERR GROUP_SC_LISTBOX::SelectItems2( const SAM_RID_MEM & samrm,
                                       BOOL fBuiltin,
                                       BOOL fSelect )
{
    INT c = (INT)samrm.QueryCount();
    for ( INT i = 0; i < c; i++ )
    {
        INT ilbi;
        APIERR err = FindItemByRid( samrm.QueryRID( i ), fBuiltin, &ilbi );
        if( err != NERR_Success )
            return err;
        if ( ilbi < 0 )
        {
            //  This is certainly allowed to happen.
        }
        else
        {
            SelectItem( ilbi, fSelect );
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       GROUP_SC_LISTBOX::FindItemByRid

    SYNOPSIS:   Finds an item in the list box given the rid

    ENTRY:      rid    -       rid to find

                fBuiltin -      if TRUE look for items from Builtin Domain
                                if FALSE look for items in Accounts Domain

                pIndex -       index of item if found

    RETURNS:    error code, which is NERR_Success on success

    HISTORY:
        Thomaspa     28-Apr-1992     created

********************************************************************/

APIERR GROUP_SC_LISTBOX::FindItemByRid( ULONG rid, BOOL fBuiltin, INT * pIndex )
{
    INT cItems = QueryCount();

    // BUGBUG Do we need to go through all of them?
    for ( INT i = 0; i < cItems; i++ )
    {
        GROUP_SC_LBI * pgrlbi = QueryItem( i );
        if ( pgrlbi->IsBuiltin() == fBuiltin && pgrlbi->QueryRID() == rid )
        {
            *pIndex = i;
            return NERR_Success;
        }
    }

    *pIndex = -1;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_SC_LBI::Compare

    SYNOPSIS:   Compares two USER_SC_LBI's

    ENTRY:      plbi -      Pointer to other USER_SC_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    HISTORY:
        o-SimoP     26-Dec-1991 Created

********************************************************************/

INT USER_SC_LBI::Compare( const LBI * plbi ) const
{
    return _iMainLbIndex - ((USER_SC_LBI *)plbi)->_iMainLbIndex;
}


/*******************************************************************

    NAME:       USER_SC_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    HISTORY:
        o-SimoP     26-Dec-1991 Created

********************************************************************/

WCHAR USER_SC_LBI::QueryLeadingChar( void ) const
{
    TCHAR * pchLogonName = QueryDDU()->LogonName.Buffer;
    return (pchLogonName == NULL) ? TCH('\0') : *pchLogonName;
}


/*******************************************************************

    NAME:       USER_SC_LBI::Compare_HAWforHawaii

    SYNOPSIS:   Compares a USER_LBI with a leading string

    RETURNS:    As Compare()

    HISTORY:
        jonn        11-Aug-1992 HAW-for-Hawaii for other LBs

********************************************************************/

INT USER_SC_LBI::Compare_HAWforHawaii( const NLS_STR & nls ) const
{
    //
    // Yeesh -- how to deal with this without having a pointer in every
    // LBI??  I wish I had passed an appropriate pointer in C_HAW()...
    // For now I'll make it a static...
    //

    ASSERT( USER_SC_LISTBOX::_pulbst != NULL );

    return USER_LBI::W_Compare_HAWforHawaii( nls, QueryDDU(),
                            USER_SC_LISTBOX::_pulbst->QuerySortOrder() );
}


/*******************************************************************

    NAME:       USER_SC_LBI::Paint

    SYNOPSIS:   Paints the USER_SC_LBI

    ENTRY:      plb -       Pointer to listbox which provides the context
                            for this LBI.

                hdc -       The device context handle to be used

                prect -     Pointer to clipping rectangle

                pGUILTT -   Pointer to GUILTT structure

    HISTORY:
        o-SimoP     26-Dec-1991 Created
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/

VOID USER_SC_LBI::Paint( LISTBOX * plb,
                         HDC hdc,
                         const RECT * prect,
                         GUILTT_INFO * pGUILTT ) const
{
    DISPLAY_TABLE * pdtab = ((USER_SC_LISTBOX * )plb)->QueryDisplayTable();
    UIASSERT( pdtab != NULL );

    UNICODE_STR_DTE dteAccount(  &(QueryDDU()->LogonName)  );
    UNICODE_STR_DTE dteFullname( &(QueryDDU()->FullName )  );

    (*pdtab)[ 0 ] = (DM_DTE *)((USER_SC_LISTBOX * )plb)->QueryDmDte( QueryIndex() );
    (*pdtab)[ ((USER_SC_LISTBOX * )plb)->QueryAccountIndex() ] = &dteAccount;
    (*pdtab)[ ((USER_SC_LISTBOX * )plb)->QueryFullnameIndex() ] = &dteFullname;
    pdtab->Paint( plb, hdc, prect, pGUILTT );

}


#define BF_BLOCKSIZE 128
/*******************************************************************

    NAME:       BITFINDER::BITFINDER

    SYNOPSIS:   constructor

    ENTRY:      cItems  -       number of on/off items

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

BITFINDER::BITFINDER( UINT cItems )
    :   BASE(),
        _bitfield( cItems, OFF ),
        _piItemsSetInBlock( NULL )
{
    if (QueryError() != NERR_Success)
        return;

    INT cBlocks = (cItems+BF_BLOCKSIZE-1) / BF_BLOCKSIZE;

    TRACEEOL(   "BITFINDER::ctor: " << cItems << " items, "
             << cBlocks << " blocks" );

    _piItemsSetInBlock = new INT[ cBlocks ];
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _piItemsSetInBlock == NULL
        || (err = _bitfield.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    ::memsetf( _piItemsSetInBlock,
               0,
               cBlocks * sizeof(INT) );
}

BITFINDER::BITFINDER( const BITFINDER & bfindCloneThis )
    :   BASE(),
        _bitfield( bfindCloneThis._bitfield ),
        _piItemsSetInBlock( NULL )
{
    if (QueryError() != NERR_Success)
        return;

    INT cBlocks = (QueryCount()+BF_BLOCKSIZE-1) / BF_BLOCKSIZE;

    TRACEEOL(   "BITFINDER::ctor: " << QueryCount() << " items, "
             << cBlocks << " blocks" );

    _piItemsSetInBlock = new INT[ cBlocks ];
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _piItemsSetInBlock == NULL
        || (err = _bitfield.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    ::memcpyf( _piItemsSetInBlock,
               bfindCloneThis._piItemsSetInBlock,
               cBlocks * sizeof(INT) );
}


/*******************************************************************

    NAME:       BITFINDER::~BITFINDER()

    SYNOPSIS:   destructor

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

BITFINDER::~BITFINDER()
{
    delete _piItemsSetInBlock;
    _piItemsSetInBlock = NULL;
}


/*******************************************************************

    NAME:       BITFINDER::FindItem

    SYNOPSIS:   Find the ordinal position of the Nth bit in the array which
                is on/off.  Note that ordinal N starts at 0.

                For example, the 5900th bit which is set FALSE might be the
                6000th bit, thus FindItem(5900) == 6000.

    INTERFACE:  nItem:          find nItem'th bit which is on/off
                fSet:           whether to find Nth ON bit or Nth OFF bit

    RETURNS:    -1 on error (also asserts, not normal return)

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

INT BITFINDER::FindItem( INT nFind, BOOL fSet )
{
    // TRACEEOL( "BITFINDER::FindItem; finding " << nFind << ", " << (INT)fSet );

    nFind++; // convert from 0-based ordinal to 1-based ordinal

    ASSERT( nFind > 0 );

    INT nItemsPassed = 0;
    INT nBlocksPassed = 0;
    INT cItemsInBlock = 0;
    INT cItems = QueryCount();
    INT cBlocks = (cItems+BF_BLOCKSIZE-1) / BF_BLOCKSIZE;

    do
    {
        if ( nBlocksPassed >= cBlocks )
        {
            DBGEOL( "BITFINDER::FindItem(): passed all blocks" );
            ASSERT( FALSE );
            return -1;
        }
        cItemsInBlock = _piItemsSetInBlock[nBlocksPassed];
        if ( !fSet )
        {
            if (nBlocksPassed < cBlocks-1)
                cItemsInBlock = BF_BLOCKSIZE - cItemsInBlock;
            else
                cItemsInBlock = (cItems - (nBlocksPassed*BF_BLOCKSIZE))
                                    - cItemsInBlock;
        }

        if ( nItemsPassed + cItemsInBlock >= nFind )
        {
            // TRACEEOL( "BITFINDER::FindItem; in block " << nBlocksPassed );
            break;
        }
        nItemsPassed += cItemsInBlock;
        nBlocksPassed++;

    } while (TRUE);

    INT nPosition = nBlocksPassed * BF_BLOCKSIZE;
    while ( nItemsPassed < nFind )
    {
        if ( nPosition >= cItems )
        {
            DBGEOL( "BITFINDER::FindItem(): passed all items" );
            ASSERT( FALSE );
            return -1;
        }
        if ( (!!fSet) == (!!IsBitSet(nPosition)) )
        {
            nItemsPassed++;
        }
        nPosition++; // will step one past correct position
    }

    // TRACEEOL( "BITFINDER::FindItem; returning " << nPosition-1 );

    return nPosition-1;
}


/*******************************************************************

    NAME:       BITFINDER::FindItems

    SYNOPSIS:   Find the ordinal position of the provided set of bits in
                the array.

    INTERFACE:  piFind:         find nItem'th bits which are on/off
                piFound:        Store positions of found bits
                ciItems:        Number of bit positions on both arrays
                fSet:           whether to find ON bits or OFF bits

    CODEWORK:   This could probably be implemented more efficiently to
                take advantage if the provided array is in order.

    NOTES:      It is permitted for piFind and piFound to be the same.

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

VOID BITFINDER::FindItems( const INT *piFind,
                           INT * piFound,
                           INT ciItems,
                           BOOL fSet )
{
    ASSERT( ciItems == 0 || (piFind != NULL && piFound != NULL) );

    INT i;
    for (i = 0; i < ciItems; i++)
    {
        piFound[i] = FindItem( piFind[i], fSet );
    }
}


/*******************************************************************

    NAME:       BITFINDER::SetBit

    SYNOPSIS:   Turn the Nth bit on/off.

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

VOID BITFINDER::SetBit( INT nItem, BOOL fSet )
{
    if ( (!!fSet) != (!!IsBitSet(nItem)) )
    {
        INT iBlock = nItem / BF_BLOCKSIZE;
        _bitfield.SetBit( nItem, (BITVALUES)fSet );
        if (fSet)
        {
            ASSERT( _piItemsSetInBlock[iBlock] < BF_BLOCKSIZE);
            (_piItemsSetInBlock[iBlock])++;
        }
        else
        {
            ASSERT( _piItemsSetInBlock[iBlock] > 0);
            (_piItemsSetInBlock[iBlock])--;
        }
    }
}


/*******************************************************************

    NAME:       BITFINDER::SetBits

    SYNOPSIS:   Turn multiple bits on/off.

    HISTORY:
        JonN        10-Sep-1993     created

********************************************************************/

VOID BITFINDER::SetBits( INT * piItems, INT ciItems, BOOL fSet )
{
    ASSERT( ciItems == 0 || piItems != NULL );

    INT i;
    for ( i = 0; i < ciItems; i++ )
    {
        SetBit( piItems[i], fSet );
    }
}


/*******************************************************************

    NAME:       BITFINDER::InverseFindItem

    SYNOPSIS:   Find the ordinal position of the Nth bit(s) in the list of
                bits which are on / off.

                For example, bit #6000 might be the 5900th bit which
                is set FALSE, thus InverseFindItem(6000) == 5900.

    NOTES:      iFind is permitted to be <0; if so, return value == iFind

                In InverseFindItems, the input and output arrays
                may be the same.

    HISTORY:
        JonN        15-Sep-1993     created

********************************************************************/

INT BITFINDER::InverseFindItem( INT iFind )
{
    ASSERT( iFind < (INT)QueryCount() );

    if ( iFind < 0 )
        return iFind;

    BOOL fSet = IsBitSet( iFind );

    INT nItemsPassed = 0;
    INT cItemsInBlock = 0;

    INT iBlock;
    INT iItemInBlock = iFind / BF_BLOCKSIZE;
    for (iBlock = 0; iBlock < iItemInBlock; iBlock++)
    {
        cItemsInBlock = _piItemsSetInBlock[iBlock];
        if ( !fSet )
        {
            cItemsInBlock = BF_BLOCKSIZE - cItemsInBlock;
        }

        nItemsPassed += cItemsInBlock;
    }

    INT iPosition;
    for ( iPosition = iItemInBlock * BF_BLOCKSIZE;
          iPosition < iFind;
          iPosition++ )
    {
        if ( (!!fSet) == (!!IsBitSet(iPosition)) )
        {
            nItemsPassed++;
        }
    }

    return nItemsPassed;
}


VOID BITFINDER::InverseFindItems( const INT * piFind,
                                  INT * piFound,
                                  INT ciItems )
{
    ASSERT( ciItems == 0 || (piFind != NULL && piFound != NULL) );

    INT i;
    for ( i = 0; i < ciItems; i++ )
    {
        piFound[i] = InverseFindItem( piFind[i] );
    }
}


/*******************************************************************

    NAME:       BITFINDER::QueryCount

    SYNOPSIS:   Count how many bits are on/off.

    HISTORY:
        JonN        04-Oct-1994     created

********************************************************************/

UINT BITFINDER::QueryCount( BOOL fSet )
{
    UINT cSet = 0;
    INT cBlocks = (QueryCount()+BF_BLOCKSIZE-1) / BF_BLOCKSIZE;
    for (INT iBlock = 0; iBlock < cBlocks; iBlock++)
    {
        cSet += _piItemsSetInBlock[iBlock];
    }

    if (!fSet)
    {
        cSet = QueryCount() - cSet;
    }

    return cSet;
}



/*******************************************************************

    NAME:       USER_SC_LBI_CACHE::USER_SC_LBI_CACHE

    SYNOPSIS:   constructor

    ENTRY:      plulb - pointer to main user listbox

    HISTORY:
        JonN        13-Sep-1993     created

********************************************************************/

USER_SC_LBI_CACHE::USER_SC_LBI_CACHE( LAZY_USER_LISTBOX * plulb )
    :   BITFINDER( plulb->QueryCount() ),
        _aplbi( NULL ),
        _plulb( plulb )
{
    ASSERT( plulb != NULL && plulb->QueryError() == NERR_Success );

    if (QueryError() != NERR_Success)
        return;

    INT cItems = QueryCount();
    _aplbi = (USER_SC_LBI **) new PVOID[ cItems ];
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if ( _aplbi == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    ::memsetf( _aplbi, 0x0, cItems * sizeof(PVOID) );
}


/*******************************************************************

    NAME:       USER_SC_LBI_CACHE::~USER_SC_LBI_CACHE()

    SYNOPSIS:   destructor

    HISTORY:
        JonN        13-Sep-1993     created

********************************************************************/

USER_SC_LBI_CACHE::~USER_SC_LBI_CACHE()
{
    // don't bother deleting the LBIs

    delete _aplbi;
    _aplbi = NULL;
}


/*******************************************************************

    NAME:       USER_SC_LBI_CACHE::QueryLBI

    SYNOPSIS:

    HISTORY:
        JonN        13-Sep-1993     created

********************************************************************/

USER_SC_LBI * USER_SC_LBI_CACHE::QueryLBI( INT i )
{
    ASSERT( _aplbi != NULL && i < (INT)QueryCount() && i >= 0 );

    USER_SC_LBI * plbiReturn = _aplbi[ i ];

    if (plbiReturn == NULL)
    {
        plbiReturn = new USER_SC_LBI( i );
        _aplbi[i] = plbiReturn;
        ASSERT( plbiReturn != NULL && plbiReturn->QueryError() == NERR_Success );
    }

    return plbiReturn;
}


USER_SC_LBI * USER_SC_LBI_CACHE::QueryLBI( INT i, BOOL fSet )
{
    ASSERT( _aplbi != NULL && i < (INT)QueryCount() && i >= 0 );

    INT iMainLBIndex = FindItem( i, fSet );
    if ( iMainLBIndex < 0 )
    {
        ASSERT( FALSE );
        return NULL;
    }
    else
    {
        return QueryLBI( iMainLBIndex );
    }
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::USER_SC_LISTBOX

    SYNOPSIS:   constructor

    ENTRY:      powin   -       pointer to OWNER_WINDOW
                cid     -       id for this
                pulb    -       pointer to main user listbox

    HISTORY:
        o-SimoP     7-Nov-1991  Created
        beng        07-Jun-1992 Support for direct manipulation
        JonN        10-Sep-1993     Made into a lazy listbox

********************************************************************/

USER_SC_LISTBOX::USER_SC_LISTBOX( OWNER_WINDOW * powin, CID cid,
                                  USER_SC_LBI_CACHE & ulbicache,
                                  LAZY_USER_LISTBOX * pulb,
                                  BOOL fIn )
    :   LAZY_LISTBOX( powin, cid ),
        CUSTOM_CONTROL( this ),
        USER_LISTBOX_BASE( powin, cid, pulb ),
        _ulbicache( ulbicache ),
        _psetcontrol( NULL ),
        _fIn( fIn ),
        _hawinfo()
{
    _pulbst = pulb;
    // _psetcontrol will be prepared in Set_SET_CONTROL

    APIERR err;
    if (   (err = _ulbicache.QueryError()) != NERR_Success
        || (err = _hawinfo.QueryError()) != NERR_Success
       )

    {
        DBGEOL( "USER_SC_LISTBOX::ctor error " << err );
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::~USER_SC_LISTBOX()

    SYNOPSIS:   destructor

    HISTORY:
        o-SimoP     7-Nov-1991      Created
        JonN        10-Sep-1993     Made into a lazy listbox

********************************************************************/

USER_SC_LISTBOX::~USER_SC_LISTBOX()
{
    // nothing else
}


/**********************************************************************

    NAME:       IsCharPrintableOrSpace

    SYNOPSIS:   Determine whether a character is printable or not

    NOTES:
        This of this as a Unicode/DBCS-safe "isprint"

    CODEWORK    Should be in a library somewhere

    HISTORY:
        JonN        30-Dec-1992 Templated from bltlb.cxx

**********************************************************************/

static WCHAR IsCharPrintableOrSpace( WCHAR wch )
{
#if !defined(UNICODE)
    if (HIBYTE(wch) != 0)               // All double-byte chars are printable
        return TRUE;
    return (LOBYTE(wch) >= (BYTE)' ');  // Otherwise, in Latin 1.
#else
    WORD nType;

    BOOL fOK = ::GetStringTypeW(CT_CTYPE1, &wch, 1, &nType);
    ASSERT(fOK);

    return (fOK && !(nType & (C1_CNTRL|C1_BLANK)));
#endif
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::CD_Char

    SYNOPSIS:   Custom-draw code to respond to a typed character
                for listboxes with HAW-for-Hawaii support

    ENTRY:      wch      - Character typed
                nLastPos - Current caret position
                phawinfo - Pointer to info buffer used internally
                           to keep track of HAW-for-Hawaii state.
                           This must have constructed successfully,
                           but the caller need not keep closer track.

    RETURNS:    As per WM_CHARTOITEM message (q.v.)

    NOTES:
        Does not assume that items are sorted.

    CODEWORK:  Should be moved to LAZY_LISTBOX class, where this can be
               implemented more efficiently

    HISTORY:
        JonN        15-Sep-1993 Templated from LAZY_USER_LISTBOX

**********************************************************************/

INT USER_SC_LISTBOX::CD_Char( WCHAR wch, USHORT nLastPos )
{
    ASSERT( _pulbst != NULL && _pulbst->QueryError() == NERR_Success );
    ASSERT( _hawinfo.QueryError() == NERR_Success );

    if (wch == VK_BACK)
    {
        TRACEEOL( "USER_SC_LISTBOX:HAWforHawaii: hit BACKSPACE" );
        _hawinfo._time = 0L; // reset timer
        _hawinfo._nls = SZ("");
        UIASSERT( _hawinfo._nls.QueryError() == NERR_Success );
        return 0; // go to first LBI
    }

    // Filter characters which won't appear in keys

    if ( ! IsCharPrintableOrSpace( wch ))
        return -2;  // take no other action

    INT clbi = QueryCount();
    if ( clbi == 0 )
    {
        // Should never get this message if no items;
        // 
        //
        return -2;  // take no other action
    }

    LONG lTime = ::GetMessageTime();

#define ThresholdTime 2000

    // CODEWORK ignoring time wraparound effects for now
    if ( (lTime - _hawinfo._time) > ThresholdTime )
    {
        TRACEEOL( "USER_SC_LISTBOX:HAWforHawaii: threshold timeout" );
        nLastPos = 0;
        _hawinfo._nls = SZ("");
    }

    APIERR err = _hawinfo._nls.AppendChar( wch );
    if (err != NERR_Success)
    {
        DBGEOL( "USER_SC_LISTBOX:HAWforHawaii: could not extend _hawinfo._nls" );
        nLastPos = 0;
        _hawinfo._nls = SZ("");
    }

    UIASSERT( _hawinfo._nls.QueryError() == NERR_Success );

    TRACEEOL(   "USER_SC_LISTBOX:HAWforHawaii: _hawinfo._nls is \""
             << _hawinfo._nls.QueryPch()
             << "\"" );

    _hawinfo._time = lTime;

    USER_LISTBOX_SORTORDER ulbso = _pulbst->QuerySortOrder();

    INT nReturn = -2; // take no other action

    // loop over all items in main user listbox
    for ( INT iLoop = nLastPos; iLoop < clbi; iLoop++ )
    {
        // don't find items not in this USER_SC_LISTBOX
        if ( (!!_ulbicache.IsBitSet(iLoop)) != (!!_fIn) )
        {
            continue;
        }

        INT nCompare = USER_LBI::W_Compare_HAWforHawaii(
                                        _hawinfo._nls,
                                        _pulbst->QueryDDU( iLoop ),
                                        ulbso );
        if ( nCompare == 0 )
        {
            iLoop = _ulbicache.InverseFindItem( iLoop );
            TRACEEOL(   "USER_SC_LISTBOX::HAWforHawaii: prefix match at "
                     << iLoop );
            ASSERT( iLoop >= 0 && iLoop < QueryCount() );

            //  Return index of item, on which the system listbox should
            //  perform the default action.
            //
            return ( iLoop );
        }
        else if ( nCompare < 0 )
        {
            if ( nReturn < 0 )
            {
                iLoop = _ulbicache.InverseFindItem( iLoop );
                TRACEEOL( "USER_SC_LISTBOX::HAWforHawaii: subsequent match at "
                         << iLoop );
                ASSERT( iLoop >= 0 && iLoop < QueryCount() );
                nReturn = iLoop;
            }
        }
    }

    //  The character was not found as a leading prefix of any listbox item

    if (nReturn == -2)
    {
        nReturn = clbi-1;
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact or subsequent match, returning last item "
            << nReturn );
    }
    else
    {
        TRACEEOL(
            "NETUI:HAWforHawaii: no exact match, returning subsequent match "
            << nReturn );
    }

    return nReturn;
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::W_FindItem

    SYNOPSIS:   Finds item

    ENTRY:      pszAccount -    pointer to user name to be found

                pIndex     -    pointer to index.  Index -1 indicates
                                item not found.

    RETURNS:    error code, which is NERR_Success on success

    NOTES:      Saves us from creating LBI, and allows us (at a
                high performance cost) to search by logonname when
                the list is sorted by fullname (and we don't need
                to know fullname).

   CODEWORK Should we keep some list for main listbox that has always
   users sorted by Logonname

    HISTORY:
        o-SimoP     13-Nov-1991     Templated from BLT_LISTBOX
        JonN        10-Sep-1993     Made into a lazy listbox

********************************************************************/

APIERR USER_SC_LISTBOX::W_FindItem( const TCHAR * pszAccount, INT * pIndex )
{
    ASSERT( FALSE ); //  no one calls this

    return ERROR_GEN_FAILURE;
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::OnNewItem

    SYNOPSIS:   Returns LBI pointer for listbox item

    ENTRY:      i -     Position of item in listbox

    HISTORY:
        JonN        13-Sep-1993     Created

********************************************************************/

LBI * USER_SC_LISTBOX::OnNewItem( UINT i )
{
    return _ulbicache.QueryLBI( i, _fIn );
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::OnDeleteItem

    SYNOPSIS:   Releases LBI pointer for listbox item

    ENTRY:      plbi -  item in listbox

    HISTORY:
        JonN        14-Sep-1993     Created

********************************************************************/

VOID USER_SC_LISTBOX::OnDeleteItem( LBI *plbi )
{
    // don't do anything, leave it in the cache
}


/*********************************************************************

    NAME:       USER_SC_LISTBOX::OnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

BOOL USER_SC_LISTBOX::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnLMouseButtonDown( (LISTBOX *)this,
                                                          (CUSTOM_CONTROL *)this,
                                                          e )
                : CUSTOM_CONTROL::OnLMouseButtonDown( e );
}


/*********************************************************************

    NAME:       USER_SC_LISTBOX::OnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

BOOL USER_SC_LISTBOX::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnLMouseButtonUp( (LISTBOX *)this,
                                                        (CUSTOM_CONTROL *)this,
                                                        e )
                : CUSTOM_CONTROL::OnLMouseButtonUp( e );
}


/*********************************************************************

    NAME:       USER_SC_LISTBOX::OnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

BOOL USER_SC_LISTBOX::OnMouseMove( const MOUSE_EVENT & e )
{
    return (_psetcontrol != NULL)
                ? _psetcontrol->HandleOnMouseMove( (LISTBOX *)this,
                                                   e )
                : CUSTOM_CONTROL::OnMouseMove( e );
}


/*********************************************************************

    NAME:       USER_SC_LISTBOX::FlipSelectedItems

    SYNOPSIS:   Changes the state of the selected listbox items in the
                BITFINDER.  Also forces refresh as appropriate.

    NOTES:      We assume there are no duplicates on the list

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

APIERR USER_SC_LISTBOX::FlipSelectedItems( USER_SC_LISTBOX * plbTo )
{
TRACETIMESTART;
    ASSERT( plbTo != NULL && plbTo->QueryError() == NERR_Success );

    SetRedraw( FALSE );
    plbTo->SetRedraw( FALSE );

    INT cSelItems = QuerySelCount();
    BUFFER bufItems( cSelItems*sizeof(INT) );
    INT * piItems = NULL;
    APIERR err = bufItems.QueryError();
    // JonN 7/17/00 PREFIX 144522
    if ( err != NERR_Success ||
        (NULL == (piItems = (INT *)bufItems.QueryPtr())) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    err = QuerySelItems( piItems, cSelItems );
    if (err == NERR_Success)
    {
TRACETIMESTART2( FindItems );
        _ulbicache.FindItems( piItems, piItems, cSelItems, _fIn );
TRACETIMEEND2( FindItems, "USER_SC_LISTBOX::FlipSelectedItems FindItems took " );
TRACETIMESTART2( SetBits );
        _ulbicache.SetBits( piItems, cSelItems, !_fIn );
TRACETIMEEND2( SetBits, "USER_SC_LISTBOX::FlipSelectedItems FindItems took " );
    }

    //
    // Fix the item counts
    //
    UINT clbiIn = _ulbicache.QueryCount(_fIn);
    SetCount( clbiIn );
    plbTo->SetCount( _ulbicache.QueryCount() - clbiIn );

    /*
     * same items still selected in the other listbox
     */
    RemoveSelection();
    plbTo->RemoveSelection();
    _ulbicache.InverseFindItems( piItems, piItems, cSelItems );
    INT i;
    for ( i = 0; i < cSelItems; i++ )
    {
        plbTo->SelectItem( piItems[i] );
    }
    if ( cSelItems > 0 )
    {
        SetCaretIndex( piItems[0] );
    }
    plbTo->ClaimFocus();

    SetRedraw( TRUE );
    plbTo->SetRedraw( TRUE );

    Invalidate( TRUE );
    plbTo->Invalidate( TRUE );

TRACETIMEEND( "USER_SC_LISTBOX::FlipSelectedItems took " );
    return err;
}


/*********************************************************************

    NAME:       USER_SC_LISTBOX::Set_SET_CONTROL

    SYNOPSIS:   List listbox to specified SET_CONTROL

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

VOID USER_SC_LISTBOX::Set_SET_CONTROL( USER_SC_SET_CONTROL * psetcontrol )
{
    ASSERT( psetcontrol == NULL || psetcontrol->QueryError() == NERR_Success );

    _psetcontrol = psetcontrol;
}


/*********************************************************************

    NAME:       USER_SC_SET_CONTROL::MoveItems

    SYNOPSIS:   Shifts items between the listboxes

    HISTORY:
        jonn        13-Sep-1993 Created

*********************************************************************/

APIERR USER_SC_SET_CONTROL::MoveItems( LISTBOX *plbFrom,
                                       LISTBOX *plbTo )
{
    ASSERT( plbFrom != plbTo );

    APIERR err = ((USER_SC_LISTBOX *)plbFrom)->FlipSelectedItems(
                                                (USER_SC_LISTBOX *)plbTo );
    EnableButtons();

    return err;
}


/*******************************************************************

    NAME:       USER_SC_LISTBOX::SetMembItems

    SYNOPSIS:   Moves items into this listbox according to
                provided MEMBERSHIP_LM_OBJ

    ENTRY:      memb -             reference to MEMBERSHIP_LM_OBJ
                plbOther -         pointer to other USER_SC_LISTBOX
                pstrlistNotFound - (optional) remember items not found

    RETURNS:    error code, which is NERR_Success on success

    HISTORY:
        JonN        13-Sep-1993     Copied from MEMB_SC_LISTBOX
        JonN        04-Oct-1994     changed from SelectMembItems for performance

********************************************************************/

APIERR USER_SC_LISTBOX::SetMembItems( const MEMBERSHIP_LM_OBJ & memb,
                                      USER_SC_LISTBOX * plbOther,
                                      STRLIST * pstrlistNotFound )
{

TRACETIMESTART;

    APIERR err = NERR_Success;
    //
    // Move account names to this listbox, or add them to the STRLIST
    // if they are missing
    //
    INT cMembItems = memb.QueryCount();
    for ( INT iMembItem = 0; iMembItem < cMembItems; iMembItem++ )
    {
        const TCHAR * cpszAccountName = memb.QueryAssocName( iMembItem );
        INT ilbiMainLb = ((LAZY_USER_LISTBOX *)_pulb)->FindItem( cpszAccountName );
        if ( ilbiMainLb < 0 )
        {
            //  This is certainly allowed to happen.
            //  Remember this item if STRLIST provided
            if (pstrlistNotFound != NULL)
            {
                NLS_STR * pnlsNew = new NLS_STR( cpszAccountName );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   pnlsNew == NULL
                    || (err = pnlsNew->QueryError()) != NERR_Success
                   )
                {
                    TRACEEOL( "USER_SC_LISTBOX::SetMembItems: alloc error " << err );
                    delete pnlsNew;
                    break;
                }

                if ( (err = pstrlistNotFound->Append( pnlsNew )) != NERR_Success
                   )
                {
                    TRACEEOL( "USER_SC_LISTBOX::SetMembItems: could not append " << err );
                    break;
                }
            }
        }
        else
        {
            //
            // This will leave the item counts temporarily incorrect
            //
            _ulbicache.SetBit( ilbiMainLb, _fIn );
        }
    }

    //
    // Fix the item counts
    //
    UINT clbiIn = _ulbicache.QueryCount(_fIn);
    SetCount( clbiIn );
    plbOther->SetCount( _ulbicache.QueryCount() - clbiIn );

TRACETIMEEND( "USER_SC_LISTBOX::SetMembItems: total " );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\nwlogon.cxx ===
/*******************************************************************************
*
*   nwlogon.cxx
*   NWLOGON_ADMIN class implementation
*
*   Implementation file for the Citrix NWLogon  Configuration data object class
*
*  Copyright Citrix Systems Inc. 1995
*
*  Author: Bill Madden
*
*  $Log:   N:\NT\PRIVATE\NET\UI\ADMIN\USER\USER\CITRIX\VCS\NWLOGON.CXX  $
*  
*     Rev 1.4   26 Mar 1997 15:58:58   JohnR
*  update
*  
*     Rev 1.3   25 Mar 1997 18:12:14   JohnR
*  update
*  
*     Rev 1.2   18 Jun 1996 14:11:20   bradp
*  4.0 Merge
*  
*     Rev 1.1   28 Jan 1996 15:10:42   billm
*  CPR 2583: Check for domain admin user
*  
*     Rev 1.0   21 Nov 1995 15:43:20   billm
*  Initial revision.
*  
*******************************************************************************/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SETCONTROL
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_TIME_DATE
#include <blt.hxx>

// usrmgrrc.h must be included after blt.hxx (more exactly, after bltrc.h)
extern "C"
{
    #include <usrmgrrc.h>
    #include <mnet.h>
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <ntseapi.h>
    #include <umhelpc.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>

#include <citrix\uconfig.hxx>  // will include <citrix\winsta.h>

extern "C"
BOOLEAN WINAPI
_NWLogonQueryAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    );

extern "C"
BOOLEAN WINAPI
_NWLogonSetAdmin(
    HANDLE hServer,
    PWCHAR pServerName,
    PNWLOGONADMIN pNWLogon
    );


/*******************************************************************

    NAME:       NWLOGON_ADMIN::NWLOGON_ADMIN

    SYNOPSIS:   Constructor for NWLOGON_ADMIN class

    ENTRY:      pszUserName -   name of user for USERCONFIG data
                pszServerName - name of server for USERCONFIG data

********************************************************************/


NWLOGON_ADMIN::NWLOGON_ADMIN()
        :   
            _nlsServerName(),
            _nlsAdminUsername(),
            _nlsAdminDomain(),
            _nlsAdminPassword()

{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _nlsServerName.QueryError()) != NERR_Success)
        || ((err = _nlsAdminUsername.QueryError()) != NERR_Success)
        || ((err = _nlsAdminPassword.QueryError()) != NERR_Success)
        || ((err = _nlsAdminDomain.QueryError()) != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       NWLOGON_ADMIN::GetInfo

    SYNOPSIS:   Gets specified server's userconfig data

    ENTRY:

********************************************************************/

APIERR NWLOGON_ADMIN::GetInfo()
{
    APIERR err;
    NWLOGONADMIN NWLogon;

    // This returns FALSE on error, like other WIN32 API's
    err = _NWLogonQueryAdmin(NULL,(WCHAR *)_nlsServerName.QueryPch(), 
                                     &NWLogon);

    if ( err == 0 ) {
        // If an error, we must return blank fields or the UI gets hosed.
        NWLogon.Username[0] = L'\0';   
        NWLogon.Domain[0]   = L'\0';   
        NWLogon.Password[0] = L'\0';   
    }

    err = NWLStructToMembers( &NWLogon );

    _fDirty = FALSE;
    return err ;
}


/*******************************************************************

    NAME:       NWLOGON_ADMIN::SetInfo

    SYNOPSIS:   Sets specified user's userconfig data if the object is 'dirty'.

    ENTRY:

    NOTES:      This method will reset the 'dirty' flag.

********************************************************************/

APIERR NWLOGON_ADMIN::SetInfo()
{
    APIERR err;
    NWLOGONADMIN NWLogon;

    /* If the object is not 'dirty', no need to save info.
     */
    if ( !_fDirty )
        return NERR_Success;

    /* Zero-initialize USERCONFIG structure and copy member variable
     * contents there.
     */
    ::memsetf( &NWLogon, 0x0, sizeof(NWLOGONADMIN) );
    MembersToNWLStruct( &NWLogon );

    /*
     * Save user's configuration.
     */

    // This returns FALSE on error, like other WIN32 API's
    err = _NWLogonSetAdmin(NULL,(WCHAR *)_nlsServerName.QueryPch(),  
                             &NWLogon);

    _fDirty = FALSE;

    if ( err ) {
        err = NERR_Success;        
    }
    else {
	err = NERR_ItemNotFound;
    }

    return err;
}


/*******************************************************************

    NAME:       NWLOGON_ADMIN::NWLStructToMembers

    SYNOPSIS:   Copies a given NWLOGONADMIN structure into
                corresponding member variables.

    ENTRY:      pNWLogon - pointer to NWLOGONADMIN structure.

********************************************************************/

APIERR NWLOGON_ADMIN::NWLStructToMembers( PNWLOGONADMIN pNWLogon )
{
    APIERR err;

    err = _nlsAdminUsername.CopyFrom( pNWLogon->Username );
    if ( err == NERR_Success )
        err = _nlsAdminPassword.CopyFrom( pNWLogon->Password );
    if ( err == NERR_Success )
        err = _nlsAdminDomain.CopyFrom( pNWLogon->Domain );

    return err;
}


/*******************************************************************

    NAME:       NWLOGON_ADMIN::MembersToNWLStruct

    SYNOPSIS:   Copies member variables into a given NWLOGONADMIN
                structure.

    ENTRY:      pNWLogon - pointer to NWLOGONADMIN structure.

********************************************************************/

VOID NWLOGON_ADMIN::MembersToNWLStruct( PNWLOGONADMIN pNWLogon )
{
    strcpy( pNWLogon->Username, _nlsAdminUsername.QueryPch() );
    strcpy( pNWLogon->Password, _nlsAdminPassword.QueryPch() );
    strcpy( pNWLogon->Domain, _nlsAdminDomain.QueryPch() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\nwuser.cxx ===
/**********************************************************************/
/**           Microsoft LAN Manager              **/
/**        Copyright(c) Microsoft Corp., 1990            **/
/**********************************************************************/

/*
 * This module contains the wrappers to the NetWare USER object.
 * All NetWare additional properties are stored in the UserParms field
 * in the SAM database. These properties include NetWare account password,
 * Maximum Concurrent Connections, Is NetWare Password Expired, Number of Grace
 * Login Remaining Times, and the station restrictions. Reading and Writing
 * these properties are through QueryUserProperty() and SetUserProperty().
 *
 * HISTORY:
 *  CongpaY 01-Oct-93   Created.
 *
 */

#include <ntincl.hxx>
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <errmap.hxx>
#include <strnumer.hxx>

extern "C"
{
    #include <fpnwcomm.h>
    #include <lmaccess.h>
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <crypt.h>
    #include <fpnwname.h>  // for LSA secret key name.
    #include <dllfunc.h>
    #include <usrprop.h>
}

#include <uintsam.hxx>
#include <uintlsax.hxx>
#include <ntacutil.hxx>
#include <nwuser.hxx>

#define NT_TIME_RESOLUTION_IN_SECOND 10000000

#define SZ_MAIL_DIR         SZ("MAIL\\")
#define SZ_LOGIN_FILE       SZ("\\LOGIN")
#define SZ_LOGIN_FILE_OS2   SZ("\\LOGIN.OS2")


/*******************************************************************

    NAME:   USER_NW::USER_NW

    SYNOPSIS:   Constructor for USER_NW class

    ENTRY:  pszAccount -    account name
        pszLocation -   server or domain name to execute on;
                default (NULL) means the logon domain

    EXIT:   Object is constructed

    NOTES:  Validation is not done until GetInfo() time.

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/


USER_NW::USER_NW( const TCHAR *pszAccount, const TCHAR *pszLocation )
    : USER_3( pszAccount, pszLocation )

{
}

USER_NW::USER_NW( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
    : USER_3( pszAccount, loctype )
{
}

USER_NW::USER_NW( const TCHAR *pszAccount, const LOCATION & loc )
    : USER_3( pszAccount, loc )
{
}

/*******************************************************************

    NAME:   USER_NW::~USER_NW

    SYNOPSIS:   Destructor for USER_NW class

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

USER_NW::~USER_NW()
{
}

/*******************************************************************

    NAME:   USER_NW::QueryUserProperty

    SYNOPSIS:   Get the value of a specific UserParms field
                If the field does not exist in UserParms, pfFound pointS to FLASE.
                Otherwise , it points to TRUE.


    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryUserProperty (const TCHAR * pchProperty,
                                   NLS_STR *     pnlsPropertyValue,
                                   BOOL *        pfFound)
{
    UIASSERT (pchProperty != NULL);

    WCHAR PropertyFlag;
    UNICODE_STRING PropertyValue;

    PropertyValue.Buffer = NULL;
    PropertyValue.Length = 0;
    PropertyValue.MaximumLength = 0;

    APIERR err = ::CallQueryUserProperty(    (LPWSTR)QueryParms(),
                                             (LPWSTR) pchProperty,
                                             &PropertyFlag,
                                             &PropertyValue );

    *pfFound = FALSE;

    //
    // The routine will return success even if the property cannot
    // be found. So, we need to check the property value length to
    // determine whether the property is there. ( This is fine since
    // property value cannot be of length 0. )
    //

    if ( ( err == NERR_Success ) && ( PropertyValue.Length != 0 ))
    {
        *pfFound = TRUE;
        err = pnlsPropertyValue->CopyFrom( PropertyValue.Buffer,
                                           PropertyValue.Length );

        LocalFree( PropertyValue.Buffer );
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetUserProperty

    SYNOPSIS:   Store a property and its value in the UserParms field.
                If the property value is 0, the field is deleted from the
                UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetUserProperty( const TCHAR * pchProperty,
                                 UNICODE_STRING uniPropertyValue,
                                 BOOL fForce )
{
   UIASSERT (pchProperty != NULL);
   BOOL fFound;
   APIERR err;

   if (!fForce)
   {
        NLS_STR nlsPropertyValue;

        if (((err = nlsPropertyValue.QueryError()) != NERR_Success) ||
            ((err = QueryUserProperty (pchProperty,
                                       &nlsPropertyValue,
                                       &fFound)) != NERR_Success))
        {
            return err;
        }
   }

   if (fForce || !fFound)
   {
       LPWSTR  lpNewUserParms = NULL;
       BOOL    fUpdate = FALSE;

       err = ::CallSetUserProperty(      (LPWSTR) QueryParms(),
                                         (LPWSTR) pchProperty,
                                         uniPropertyValue,
                                         USER_PROPERTY_TYPE_ITEM,
                                         &lpNewUserParms,
                                         &fUpdate );

       if ( ( err == NERR_Success) && fUpdate)
       {
           err = SetParms (lpNewUserParms);
       }

       if ( lpNewUserParms != NULL )
       {
           NetpParmsUserPropertyFree( lpNewUserParms );
       }
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::RemoveUserProperty

    SYNOPSIS:   Remove a property and its value from the UserParms field.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::RemoveUserProperty (const TCHAR * pchProperty)
{
    UNICODE_STRING uniPropertyValue;

    uniPropertyValue.Buffer = NULL;
    uniPropertyValue.Length = 0;
    uniPropertyValue.MaximumLength = 0;

    return (SetUserProperty(pchProperty, uniPropertyValue, TRUE));
}

/*******************************************************************

    NAME:   USER_NW::SetNWPassword

    SYNOPSIS:   Set "NWPassword" field is fIsNetWareUser is TRUE,
                Otherwise, delete the field from UserParms.

    NOTES:      Do not call this if dwUserID is 0 (i.e. for new users)

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetNWPassword(const ADMIN_AUTHORITY * pAdminAuthority, DWORD dwUserId, const TCHAR * pchNWPassword)
{
    APIERR err;
    TCHAR pchEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH];
    BOOL fIsSupervisor = _wcsicmp( QueryName(), SUPERVISOR_NAME_STRING ) == 0;

    do
    {
        LSA_SECRET LSASecret (NCP_LSA_SECRET_KEY);
        if ((err = LSASecret.QueryError()) != NERR_Success)
            break;

        if ((err = LSASecret.Open (*pAdminAuthority->QueryLSAPolicy())) != NERR_Success)
            break;

        NLS_STR nlsCurrentValue;
        if ((err = nlsCurrentValue.QueryError()) != NERR_Success)
            break;

        if ((err = LSASecret.QueryInfo (&nlsCurrentValue,
                                        NULL,
                                        NULL,
                                        NULL)) != NERR_Success)
            break;

        if (nlsCurrentValue.QueryTextLength() * sizeof (TCHAR) < NCP_LSA_SECRET_LENGTH)
        {
            // The secret does not have correct length, something is wrong.
            err = ERROR_NO_TRUST_LSA_SECRET;
            break;
        }

        char pszNWSecretValue[NCP_LSA_SECRET_LENGTH];

        memcpy(pszNWSecretValue,
               nlsCurrentValue.QueryPch(),
               NCP_LSA_SECRET_LENGTH);
        //
        // We need to special case the user supervisor. The userId of
        // supervisor is always 1.
        //
        err = ::CallReturnNetwareForm( pszNWSecretValue,
                                       fIsSupervisor? SUPERVISOR_USERID : dwUserId,
                                       pchNWPassword,
                                       (UCHAR *) pchEncryptedNWPassword );

        if ( err != NERR_Success )
            break;

        UNICODE_STRING uniPassword;
        uniPassword.Buffer = pchEncryptedNWPassword;
        uniPassword.Length = NWENCRYPTEDPASSWORDLENGTH * sizeof (WCHAR);
        uniPassword.MaximumLength = NWENCRYPTEDPASSWORDLENGTH * sizeof (WCHAR);

        if (((err = SetUserProperty (NWPASSWORD, uniPassword, TRUE)) != NERR_Success ) ||
            ((err = SetNWPasswordAge (FALSE)) != NERR_Success ) ||
            ((err = SetPassword (pchNWPassword)) != NERR_Success ))
            break;

    }while (FALSE);

    return err;
}

/*******************************************************************

    NAME:   USER_NW::QueryIsNetWareUser

    SYNOPSIS:   Return TRUE is "NWPassword" field exist in UserParms.
                Otherwise return FALSE.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryIsNetWareUser(BOOL * pfIsNetWareUser)
{
    NLS_STR nlsNWPassword;
    if (!nlsNWPassword)
    {
        return nlsNWPassword.QueryError();
    }

    return (QueryUserProperty (NWPASSWORD, &nlsNWPassword, pfIsNetWareUser));
}

/*******************************************************************

    NAME:   USER_NW::CreateNetWareUser

    SYNOPSIS:   Create a NetWare user by writing NetWare
                related properties in UserParms.
                If a property is not there yet, write the default value.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::CreateNetWareUser(const ADMIN_AUTHORITY * pAdminAuthority, DWORD dwUserId, const TCHAR * pchNWPassword)
{
    APIERR err;
    if ( ((err = SetNWPassword (pAdminAuthority, dwUserId, pchNWPassword)) != NERR_Success) ||
         ((err = SetUserFlag( TRUE, UF_MNS_LOGON_ACCOUNT)) != NERR_Success) ||
         ((err = SetMaxConnections (DEFAULT_MAXCONNECTIONS, FALSE)) != NERR_Success) ||
         ((err = SetGraceLoginAllowed (DEFAULT_GRACELOGINALLOWED, FALSE)) != NERR_Success) ||
         ((err = SetGraceLoginRemainingTimes (DEFAULT_GRACELOGINREMAINING, FALSE)) != NERR_Success) ||
         ((err = SetNWWorkstations (DEFAULT_NWLOGONFROM, FALSE)) != NERR_Success) ||
         ((err = SetNWHomeDir (DEFAULT_NWHOMEDIR, FALSE)) != NERR_Success) )
    {
        return err;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:   USER_NW::RemoveNetWareUser

    SYNOPSIS:   Remove a NetWare user by delete all NetWare
                related properties from UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::RemoveNetWareUser()
{
    APIERR err;
    if ( ((err = RemoveUserProperty (NWPASSWORD)) != NERR_Success) ||
         ((err = SetUserFlag( FALSE, UF_MNS_LOGON_ACCOUNT)) != NERR_Success) ||
         ((err = RemoveUserProperty (MAXCONNECTIONS)) != NERR_Success) ||
         ((err = RemoveUserProperty (NWTIMEPASSWORDSET)) != NERR_Success) ||
         ((err = RemoveUserProperty (GRACELOGINALLOWED)) != NERR_Success) ||
         ((err = RemoveUserProperty (GRACELOGINREMAINING)) != NERR_Success) ||
         ((err = RemoveUserProperty (NWLOGONFROM)) != NERR_Success) ||
         ((err = RemoveUserProperty (NWHOMEDIR)) != NERR_Success) )
    {
        return err;
    }

    return NERR_Success;
}

/*******************************************************************

    NAME:   USER_NW::QueryMaxConnections

    SYNOPSIS:   Get the Maximum Concurrent Connections from UserParms
                If "MaxConnections" field does not exist in UserParms,
                return 0xffff, otherwise return the value stored there.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryMaxConnections(USHORT * pushMaxConnections)
{
    BOOL fFound;
    NLS_STR nlsMaxConnections;
    if (!nlsMaxConnections)
    {
        return nlsMaxConnections.QueryError();
    }

    APIERR err = QueryUserProperty(MAXCONNECTIONS, &nlsMaxConnections, &fFound);
    if (err == NERR_Success)
    {
        *pushMaxConnections = fFound? ((USHORT) *(nlsMaxConnections.QueryPch()))
                                    : NO_LIMIT;
    }

    return (err);
}

/*******************************************************************

    NAME:   USER_NW::SetMaxConnections

    SYNOPSIS:   Store Maximum Concurret Connections in UserParms.
                If ushMaxConnections is 0xffff or 0, "MaxConnections"
                field will be deleted from UserParms, otherwise the
                value is stored.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetMaxConnections (USHORT ushMaxConnections, BOOL fForce)
{
    USHORT ushTemp = ushMaxConnections;
    UNICODE_STRING uniMaxConnections;
    uniMaxConnections.Buffer = &ushMaxConnections;
    uniMaxConnections.Length = sizeof(ushMaxConnections);
    uniMaxConnections.MaximumLength = sizeof(ushMaxConnections);

    return (SetUserProperty (MAXCONNECTIONS, uniMaxConnections, fForce));
}

/*******************************************************************

    NAME:   USER_NW::QueryNWPasswordAge

    SYNOPSIS:   Get the age of NWPassword.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryNWPasswordAge(ULONG * pulNWPasswordAge)
{
    BOOL fFound;
    *pulNWPasswordAge = 0;

    NLS_STR nlsPasswordOldTime;
    if (!nlsPasswordOldTime)
    {
        return nlsPasswordOldTime.QueryError();
    }

    APIERR err = QueryUserProperty( NWTIMEPASSWORDSET,
                                    &nlsPasswordOldTime,
                                    &fFound);

    if ((err == NERR_Success) && fFound)
    {
        LARGE_INTEGER oldTime = *((LARGE_INTEGER*)nlsPasswordOldTime.QueryPch());

        if (oldTime.LowPart != 0xffffffff ||
            oldTime.HighPart != 0xffffffff )
        {
            LARGE_INTEGER currentTime;
            NtQuerySystemTime (&currentTime);
            LARGE_INTEGER deltaTime ;

            deltaTime.QuadPart = currentTime.QuadPart - oldTime.QuadPart ;
            deltaTime.QuadPart /= NT_TIME_RESOLUTION_IN_SECOND ;

            *pulNWPasswordAge = deltaTime.LowPart;
        }
        else
            *pulNWPasswordAge = 0xffffffff;
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetNWPasswordAge

    SYNOPSIS:   If fExpired is TURE, set the NWPasswordSet field to be
                all fs. otherwise set it to be the current time.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetNWPasswordAge(BOOL fExpired)
{
    LARGE_INTEGER currentTime;
    if (fExpired)
    {
        currentTime.HighPart = 0xffffffff;
        currentTime.LowPart = 0xffffffff;
    }
    else
    {
        NtQuerySystemTime (&currentTime);
    }

    UNICODE_STRING uniPasswordAge;
    uniPasswordAge.Buffer = (PWCHAR) &currentTime;
    uniPasswordAge.Length = sizeof(currentTime);
    uniPasswordAge.MaximumLength = sizeof(currentTime);

    return (SetUserProperty (NWTIMEPASSWORDSET,
                             uniPasswordAge, TRUE));
}

/*******************************************************************

    NAME:   USER_NW::QueryGraceLoginAllowed

    SYNOPSIS:   Get Grace Login Allowed from UserParms.
                If "GraceLoginAllowed" field does not exist in UserParms,
                returns default value 6.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryGraceLoginAllowed(USHORT * pushGraceLoginAllowed)
{
    BOOL fFound;
    NLS_STR nlsGraceLogin;
    if (!nlsGraceLogin)
    {
        return nlsGraceLogin.QueryError();
    }

    APIERR err = QueryUserProperty (GRACELOGINALLOWED, &nlsGraceLogin, &fFound);
    if (err == NERR_Success)
    {
        *pushGraceLoginAllowed = fFound? ((USHORT) *(nlsGraceLogin.QueryPch())) : DEFAULT_GRACELOGINALLOWED;
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetGraceLoginAllowed

    SYNOPSIS:   Store Grace Login Allowed in UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetGraceLoginAllowed(USHORT ushGraceLoginAllowed, BOOL fForce)
{
    USHORT ushTemp = ushGraceLoginAllowed;
    UNICODE_STRING uniGraceLoginAllowed;
    uniGraceLoginAllowed.Buffer = &ushTemp;
    uniGraceLoginAllowed.Length = sizeof(ushTemp);
    uniGraceLoginAllowed.MaximumLength = sizeof(ushTemp);

    return (SetUserProperty (GRACELOGINALLOWED, uniGraceLoginAllowed, fForce));
}

/*******************************************************************

    NAME:   USER_NW::QueryGraceLoginRemainingTimes

    SYNOPSIS:   Get Grace Login Remaining Times from UserParms.
                If "GraceLogin" field does not exist in UserParms,
                returns default value 6.
    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryGraceLoginRemainingTimes(USHORT * pushGraceLoginRemaining)
{
    BOOL fFound;
    NLS_STR nlsGraceLogin;
    if (!nlsGraceLogin)
    {
        return nlsGraceLogin.QueryError();
    }

    APIERR err = QueryUserProperty (GRACELOGINREMAINING, &nlsGraceLogin, &fFound);
    if (err == NERR_Success)
        *pushGraceLoginRemaining = fFound? ((USHORT) *(nlsGraceLogin.QueryPch())) : DEFAULT_GRACELOGINREMAINING;

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetGraceLoginRemainingTimes

    SYNOPSIS:   Store Grace Login Remaining Times in UserParms.
                if ushGraceLogin is 0, "GraceLogin" field will be
                deleted from UserParms.
                The only case this functions gets called is ushGraceLogin = 6
                to set the default value and ushGraceLogin = 0 to delete
                "GraceLogin" field. No other value is going to be set.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetGraceLoginRemainingTimes(USHORT ushGraceLoginRemainingTimes, BOOL fForce)
{
    USHORT ushTemp = ushGraceLoginRemainingTimes;
    UNICODE_STRING uniGraceLoginRemainingTimes;
    uniGraceLoginRemainingTimes.Buffer = &ushTemp;
    uniGraceLoginRemainingTimes.Length = sizeof(ushTemp);
    uniGraceLoginRemainingTimes.MaximumLength = sizeof(ushTemp);

    return (SetUserProperty (GRACELOGINREMAINING, uniGraceLoginRemainingTimes, fForce));
}

/*******************************************************************

    NAME:   USER_NW::QueryNWWorkstations

    SYNOPSIS:   Get the NetWare allowed workstation addreesses from UserParms.
                If "NWLogonFrom" does not exist in UserParms, nlsNWWorkstaions
                will be NULL.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryNWWorkstations(NLS_STR * pnlsNWWorkstations)
{
    WCHAR PropertyFlag;
    UNICODE_STRING PropertyValue;

    PropertyValue.Buffer = NULL;
    PropertyValue.Length = 0;
    PropertyValue.MaximumLength = 0;

    APIERR err = ::CallQueryUserProperty(    (LPWSTR) QueryParms(),
                                             NWLOGONFROM,
                                             &PropertyFlag,
                                             &PropertyValue );

    if ( err != NERR_Success )
    {
        return err;
    }

    if (PropertyValue.Length == 0)
    {
        pnlsNWWorkstations = NULL;
    }
    else
    {
        INT cbRequiredSize = (PropertyValue.Length + 1) * sizeof (WCHAR);
        LPTSTR pchTemp = (LPTSTR) LocalAlloc (LPTR, cbRequiredSize);

        if ( pchTemp == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {

            INT i = MultiByteToWideChar (CP_ACP,
                                         0,
                                         (const CHAR *) PropertyValue.Buffer,
                                         PropertyValue.Length,
                                         pchTemp,
                                         cbRequiredSize);

            if ( i > 0 )
            {
                *(pchTemp + PropertyValue.Length) = 0;
                err = pnlsNWWorkstations->CopyFrom(pchTemp);
            }
            else
            {
                err = ::GetLastError();
            }

            LocalFree( pchTemp );
        }

        LocalFree (PropertyValue.Buffer);

    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetNWWorkstations

    SYNOPSIS:   Store NetWare allowed workstation addresses to UserParms
                If pchNWWorkstations is NULL, this function will delete
                "NWLgonFrom" field from UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetNWWorkstations( const TCHAR * pchNWWorkstations, BOOL fForce)
{
    APIERR err = NERR_Success;
    UNICODE_STRING uniNWWorkstations;
    CHAR * pchTemp = NULL;

    if (pchNWWorkstations == NULL)
    {
        uniNWWorkstations.Buffer = NULL;
        uniNWWorkstations.Length =  0;
        uniNWWorkstations.MaximumLength = 0;
    }
    else
    {
        BOOL fDummy;
        USHORT  nStringLength = (USHORT) lstrlen(pchNWWorkstations) + 1;
        pchTemp = (CHAR *) LocalAlloc (LPTR, nStringLength);

        if ( pchTemp == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;

        if ( err == NERR_Success &&
             !WideCharToMultiByte (CP_ACP,
                                   0,
                                   pchNWWorkstations,
                                   nStringLength,
                                   pchTemp,
                                   nStringLength,
                                   NULL,
                                   &fDummy))
        {
            err = ::GetLastError();
        }

        if ( err == NERR_Success )
        {
            uniNWWorkstations.Buffer = (WCHAR *) pchTemp;
            uniNWWorkstations.Length =  nStringLength;
            uniNWWorkstations.MaximumLength = nStringLength;
        }
    }

    err = err? err: SetUserProperty (NWLOGONFROM, uniNWWorkstations, fForce);

    if (pchTemp != NULL)
    {
        LocalFree (pchTemp);
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::QueryNWHomeDir

    SYNOPSIS:   Get the NetWare Home Directory from UserParms.
                If "NWHomeDir" does not exist in UserParms, nlsNWHomeDir
                will be NULL.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::QueryNWHomeDir(NLS_STR * pnlsNWHomeDir)
{
    WCHAR PropertyFlag;
    UNICODE_STRING PropertyValue;

    PropertyValue.Buffer = NULL;
    PropertyValue.Length = 0;
    PropertyValue.MaximumLength = 0;

    APIERR err = ::CallQueryUserProperty(    (LPWSTR) QueryParms(),
                                             NWHOMEDIR,
                                             &PropertyFlag,
                                             &PropertyValue );

    if ( err != NERR_Success )
    {
        return err;
    }

    //
    //  CODEWORK: Should use MapCopyFrom primitives.  JonN 11/7/95
    //

    if (PropertyValue.Length == 0)
    {
        pnlsNWHomeDir = NULL;
    }
    else
    {
        INT cbRequiredSize = (PropertyValue.Length + 1) * sizeof (WCHAR);
        LPTSTR pchTemp = (LPTSTR) LocalAlloc (LPTR, cbRequiredSize);

        if ( pchTemp == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            INT i = MultiByteToWideChar (CP_ACP,
                                         0,
                                         (const CHAR *) PropertyValue.Buffer,
                                         PropertyValue.Length,
                                         pchTemp,
                                         cbRequiredSize);

            if (i > 0)
            {
                *(pchTemp + PropertyValue.Length) = 0;
                err = pnlsNWHomeDir->CopyFrom (pchTemp);
            }
            else
            {
                err = GetLastError();
            }

            LocalFree( pchTemp );
        }

        LocalFree (PropertyValue.Buffer);
    }

    return err;
}

/*******************************************************************

    NAME:   USER_NW::SetNWHomeDir

    SYNOPSIS:   Store NetWare Home Directory to UserParms
                If pchNWWorkstations is NULL, this function will delete
                "NWLgonFrom" field from UserParms.

    EXIT:

    HISTORY:
        CongpaY 01-Oct-93   Created.

********************************************************************/

APIERR USER_NW::SetNWHomeDir( const TCHAR * pchNWHomeDir, BOOL fForce)
{
    APIERR err = NERR_Success;
    UNICODE_STRING uniNWHomeDir;
    CHAR * pchTemp = NULL;

    if (pchNWHomeDir == NULL)
    {
        uniNWHomeDir.Buffer = NULL;
        uniNWHomeDir.Length =  0;
        uniNWHomeDir.MaximumLength = 0;
    }
    else
    {
        BOOL fDummy;
        USHORT  nStringLength = (USHORT) lstrlen(pchNWHomeDir) + 1;
        pchTemp = (CHAR *) LocalAlloc (LPTR, nStringLength);

        if ( pchTemp == NULL )
            err = ERROR_NOT_ENOUGH_MEMORY;

        if ( err == NERR_Success &&
             !WideCharToMultiByte (CP_ACP,
                                   0,
                                   pchNWHomeDir,
                                   nStringLength,
                                   pchTemp,
                                   nStringLength,
                                   NULL,
                                   &fDummy))
        {
            err = ::GetLastError();
        }

        if ( err == NERR_Success )
        {
            uniNWHomeDir.Buffer = (WCHAR *) pchTemp;
            uniNWHomeDir.Length =  nStringLength;
            uniNWHomeDir.MaximumLength = nStringLength;
        }
    }

    err = err? err : SetUserProperty (NWHOMEDIR, uniNWHomeDir, fForce);

    if (pchTemp != NULL)
    {
        LocalFree (pchTemp);
    }

    return err;
}

/*******************************************************************

    NAME:       CreateNWLoginSCriptDirAcl

    SYNOPSIS:   Create a default ACL for the LOGIN Script Dir.
                Admin & the user in question has full rights.

    ENTRY:

    EXIT:

    RETURNS:    NERR_Success if OK, api error otherwise.

    NOTES:

    HISTORY:
                ChuckC    10-Nov-1994        Created

********************************************************************/

APIERR USER_NW::CreateNWLoginScriptDirAcl(
     const ADMIN_AUTHORITY   * pAdminAuthority,
     OS_SECURITY_DESCRIPTOR ** ppOsSecDesc,
     const ULONG               ulRid )
{
    UIASSERT(ppOsSecDesc) ;

    APIERR                   err ;
    OS_ACL                   aclDacl ;
    OS_ACE                   osace ;
    OS_SECURITY_DESCRIPTOR * pOsSecDesc ;

    *ppOsSecDesc = NULL ;   // empty it.

    do        // error breakout
    {

        //
        // make sure we constructed OK
        //
        if ( (err = aclDacl.QueryError())  ||
             (err = osace.QueryError()) )
        {
            break ;
        }

        //
        // create it! use NULL to mean we build it ourselves.
        //
        pOsSecDesc = new OS_SECURITY_DESCRIPTOR(NULL) ;
        if (pOsSecDesc == NULL)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        if (err = pOsSecDesc->QueryError())
        {
            break ;
        }

        //
        // This sets up an ACE with Generic all access
        //
        osace.SetAccessMask( GENERIC_ALL ) ;
        osace.SetInheritFlags( OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE ) ;
        osace.SetType( ACCESS_ALLOWED_ACE_TYPE ) ;

        //
        // create an Admins world SID, and add this to the full access ACE.
        // then put the ACE in the ACL, and the ACL in the Security
        // descriptor.
        //
        OS_SID ossidAdmins ;
        if ( (err = ossidAdmins.QueryError()) ||
             (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                   UI_SID_Admins,
                                                   &ossidAdmins )) ||
             (err = osace.SetSID( ossidAdmins )) ||
             (err = aclDacl.AddACE( 0, osace )))
        {
            break ;
        }

        //
        // create an Admins world SID, and add this to the full access ACE.
        // then put the ACE in the ACL, and the ACL in the Security
        // descriptor.
        //
        SAM_DOMAIN * psamdomAccount =
                pAdminAuthority->QueryAccountDomain();
        OS_SID ossidUser( psamdomAccount->QueryPSID(),
                          ulRid) ;
        if ( (err = ossidUser.QueryError()) ||
             (err = osace.SetSID( ossidUser )) ||
             (err = aclDacl.AddACE( 0, osace )))
        {
            break ;
        }

        if (err = pOsSecDesc->SetDACL( TRUE, &aclDacl ))
        {
            break ;
        }

        //
        // all set, set the security descriptor
        //
        *ppOsSecDesc = pOsSecDesc ;

    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:       USER_NW::SetupNWLoginScript

    SYNOPSIS:   Create or delete the directories for the user.

    RETURNS:

    HISTORY:
                ChuckC   06-Nov-1994     Created

********************************************************************/
APIERR USER_NW::SetupNWLoginScript(const ADMIN_AUTHORITY * pAdminAuthority,
                                   const ULONG             ulObjectId,
                                   const TCHAR *           pszSysVolPath)
{
    APIERR err = NERR_Success;
    PFPNWVOLUMEINFO lpnwVolInfo ;
    NLS_STR nlsPath, nlsTemp ;
    LPTSTR  pszColon ;
    ULONG ulSwappedObjectId ;
    BOOL fSupervisor = (ulObjectId == SUPERVISOR_USERID) ;

    //
    // user manger calls this more than once because of the way the convert
    // to LMOBJ and then PERFORM ONE. so if we get called with an object id
    // that is essentially 0, do nothing since we know the user has not been
    // created yet.
    //
    if (!(ulObjectId & ~BINDLIB_REMOTE_DOMAIN_BIAS))
        return NERR_Success ;

    //
    // display format and hence the directory name format
    // is swapped for all except supervisor
    //
    if (!fSupervisor)
    {
        if ((err = ::CallSwapObjectId(ulObjectId, &ulSwappedObjectId)) != NERR_Success)
            return err;
    }
    else
        ulSwappedObjectId = ulObjectId;

    HEX_STR nlsObjectId(ulSwappedObjectId) ;

    if (!pszSysVolPath)
    {
        //
        // if path not supplied, we go ahead and read it
        //

        err = ::CallNwVolumeGetInfo(
                   (LPTSTR) pAdminAuthority->QueryServer(),
                   SYSVOL_NAME_STRING,
                   1,
                   &lpnwVolInfo) ;

        if (err == NERR_Success)
        {
            err = nlsTemp.CopyFrom(lpnwVolInfo->lpPath) ;
            (void) ::CallNwApiBufferFree(lpnwVolInfo) ;
        }

        if (err != NERR_Success)
        {
            //
            // if for any reason we cant get to this, eg. if the target
            // PDC doesnt have FPNW, we just dont create the login dirs.
            //
            return NERR_Success ;
        }

        if (!(pszColon = strchrf(nlsTemp.QueryPch(), TCH(':'))))
        {
            return ERROR_INVALID_PARAMETER ;
        }
        *pszColon = TCH('$') ;

        if (err = nlsPath.CopyFrom(pAdminAuthority->QueryServer()))
        {
            return err ;
        }

        //
        // if zero length, get local computer name
        //
        if (nlsPath.QueryTextLength() == 0)
        {
            TCHAR szComputerName[CNLEN+1] ;
            ULONG ulSize = sizeof(szComputerName)/sizeof(szComputerName[0]) ;

            if (!GetComputerName(szComputerName, &ulSize))
                return (GetLastError()) ;

            if ((err = nlsPath.CopyFrom(SZ("\\\\"))) ||
                (err = nlsPath.Append(szComputerName)))
            {
                return err ;
            }
        }

        if ((err = nlsPath.AppendChar(TCH('\\'))) ||
            (err = nlsPath.Append(nlsTemp)))
        {
            return err ;
        }

    }
    else
    {
        //
        // path is supplied, just use it.
        //

        if (err = nlsPath.CopyFrom(pszSysVolPath))
        {
            return err ;
        }
    }

    // If nlsPath does not end with '\\', append '\\'.
    if (*(nlsPath.QueryPch()+nlsPath.QueryTextLength()-1) != TCH('\\'))
    {
        if ((err = nlsPath.AppendChar(TCH('\\'))) != NERR_Success)
            return err ;
    }

    if ((err = nlsPath.Append(SZ_MAIL_DIR)) ||
        (err = nlsPath.Append(nlsObjectId)))
    {
        return err ;
    }

    //
    // now create default ACL for the directory
    //

    OS_SECURITY_DESCRIPTOR *pOsSecDesc = NULL ;

    if (err = CreateNWLoginScriptDirAcl( pAdminAuthority,
                                         &pOsSecDesc,
                                         QueryUserId() ))
    {
        return err ;
    }

    SECURITY_ATTRIBUTES secAttrib ;
    secAttrib.nLength = sizeof(secAttrib) ;
    secAttrib.lpSecurityDescriptor = pOsSecDesc->QueryDescriptor() ;
    secAttrib.bInheritHandle = FALSE ;

    //
    // create the directory. OK if already exists
    //

    if (!CreateDirectory(nlsPath.QueryPch(), &secAttrib))
    {
        delete pOsSecDesc ;
        return (NERR_Success) ;
    }

    delete pOsSecDesc ;
    pOsSecDesc = NULL ;

    //
    // create the LOGIN file (empty)
    //

    if ((err = nlsTemp.CopyFrom(nlsPath)) ||
        (err = nlsTemp.Append(SZ_LOGIN_FILE)))
    {
        return err ;
    }

    HANDLE hFile ;
    hFile = CreateFile(nlsTemp.QueryPch(),
                       GENERIC_WRITE,
                       FILE_SHARE_WRITE,
                       NULL,
                       CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL,
                       0) ;
    if (hFile != INVALID_HANDLE_VALUE)
    {
        //
        // if we could create,  just close handle.
        // if we couldnt create (file exists, etc). just do nothing.
        //
        (void) CloseHandle(hFile) ;
    }

    //
    // create the LOGIN.OS2 file (empty)
    //

    if ((err = nlsTemp.CopyFrom(nlsPath)) ||
        (err = nlsTemp.Append(SZ_LOGIN_FILE_OS2)))
    {
        return err ;
    }

    hFile = CreateFile(nlsTemp.QueryPch(),
                       GENERIC_WRITE,
                       FILE_SHARE_WRITE,
                       NULL,
                       CREATE_NEW,
                       FILE_ATTRIBUTE_NORMAL,
                       0) ;
    if (hFile != INVALID_HANDLE_VALUE)
    {
        //
        // if we could create,  just close handle.
        // if we couldnt create (file exists, etc). just do nothing.
        //
        (void) CloseHandle(hFile) ;
    }

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\rights.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    rights.cxx

    User rights policy dialog.

    FILE HISTORY:
        Yi-HsinS         15-Mar-1992    Created
        Yi-HsinS	 08-Dec-1992    Added advanced user rights checkbox
        Yi-HsinS	 30-Mar-1993    Added support for POLICY_MODE_BATCH

*/

#include <ntincl.hxx>
#include <ntsam.h>
#include <ntlsa.h>

#define INCL_WINDOWS
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#define INCL_BLT_APP
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <string.hxx>
#include <uintlsa.hxx>
#include <lsaenum.hxx>

#include <security.hxx>
#include <ntacutil.hxx>

extern "C" {
#include <usrmgr.h>
#include <usrmgrrc.h>
#include <umhelpc.h>
}

#include <usrbrows.hxx>
#include <usrmain.hxx>
#include <rights.hxx>

//
// The table of privileges that are not advanced rights
//
TCHAR *CommonUserRightsTable[] =
    {
        (TCHAR *) SE_TAKE_OWNERSHIP_NAME,
        (TCHAR *) SE_SYSTEMTIME_NAME,
        (TCHAR *) SE_BACKUP_NAME,
        (TCHAR *) SE_RESTORE_NAME,
        (TCHAR *) SE_SHUTDOWN_NAME,
        (TCHAR *) SE_SECURITY_NAME,
        (TCHAR *) SE_REMOTE_SHUTDOWN_NAME,
        (TCHAR *) SE_LOAD_DRIVER_NAME,
        (TCHAR *) SE_MACHINE_ACCOUNT_NAME
    };

// The size of the above table
#define COMMON_USER_RIGHTS_TABLE_SIZE \
        (sizeof( CommonUserRightsTable) / sizeof( const TCHAR *))
// The last entry in the above table is for server focus only
#define COMMON_USER_RIGHTS_SERVER_ONLY 1

//
// The table containing the mapping between system access mode and the
// msgid of the strings associated with them, it also contains whether
// the system access mode is an advance right or not.
//

struct SYSACC_MAPPING {
ULONG ulSysAcc;
MSGID msgidSysAcc;
BOOL  fAdvanced;
} SysAccMapTable[] =
    {   { POLICY_MODE_INTERACTIVE, IDS_INTERACTIVE, FALSE },
        { POLICY_MODE_NETWORK,     IDS_NETWORK,     FALSE },
        { POLICY_MODE_SERVICE,     IDS_SERVICE,     TRUE },
        { POLICY_MODE_BATCH,       IDS_BATCH,       TRUE }
    };

// The size of the above table
#define SYSACC_MAP_TABLE_SIZE  \
        (sizeof( SysAccMapTable) / sizeof( struct SYSACC_MAPPING))

#define BACKSLASH_CHAR   TCH('\\')

/*************************************************************************

    NAME:       ACCOUNT_ITEM::ACCOUNT_ITEM

    SYNOPSIS:   Constructor

    ENTRY:      plsaAccount - pointer to a LSA_ACCOUNT object

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_ITEM::ACCOUNT_ITEM( LSA_ACCOUNT *plsaAccount )
    : _plsaAccount( plsaAccount )
{
    UIASSERT( plsaAccount != NULL );

    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       ACCOUNT_ITEM::~ACCOUNT_ITEM

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      _plsaAccount will be deleted by whoever that creats it.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_ITEM::~ACCOUNT_ITEM()
{
    _plsaAccount = NULL;
}

DEFINE_EXT_SLIST_OF( ACCOUNT_ITEM );

/*************************************************************************

    NAME:       RIGHTS_ITEM::RIGHTS_ITEM

    SYNOPSIS:   Constructor

    ENTRY:      pszName   - Name of the right
                luid      - the LUID of the privilege
                fAdvanced - TRUE if this is an advanced right, FALSE otherwise

    EXIT:

    RETURNS:

    NOTES:      This is used for constructing a RIGHTS_ITEM from a privilege

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

RIGHTS_ITEM::RIGHTS_ITEM( const TCHAR *pszName, LUID luid, BOOL fAdvanced )
    : _nlsName( pszName ),
      _fAdvanced( fAdvanced ),
      _fPrivilege( TRUE ),
      _osluid( luid ),
      _slAccounts()
{
     if ( QueryError() != NERR_Success )
        return;

     if ( _nlsName.QueryError() != NERR_Success )
     {
         ReportError( _nlsName.QueryError() );
         return;
     }

}

/*************************************************************************

    NAME:       RIGHTS_ITEM::RIGHTS_ITEM

    SYNOPSIS:   Constructor

    ENTRY:      pszName   - Name of the right
                ulSystemAccess - the system access mode
                fAdvanced - TRUE if this is an advanced right, FALSE otherwise

    EXIT:

    RETURNS:

    NOTES:      This is used for constructing a RIGHTS_ITEM from a system access

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

RIGHTS_ITEM::RIGHTS_ITEM( const TCHAR *pszName,
                          ULONG ulSystemAccess,
  			  BOOL  fAdvanced )
    : _nlsName( pszName ),
      _fAdvanced( fAdvanced ),
      _fPrivilege( FALSE ),
      _ulSystemAccess( ulSystemAccess ),
      _slAccounts()
{
     if ( QueryError() != NERR_Success )
        return;

     if ( _nlsName.QueryError() != NERR_Success )
     {
         ReportError( _nlsName.QueryError() );
         return;
     }
}

/*************************************************************************

    NAME:       RIGHTS_ITEM::HasAccount

    SYNOPSIS:   Check to see if the right is already granted to the
                account or not

    ENTRY:      plsaAccount -  pointer to the LSA_ACCOUNT to search for


    EXIT:

    RETURNS:    TRUE if the right is already granted to the account,
                FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

BOOL RIGHTS_ITEM::HasAccount( LSA_ACCOUNT *plsaAccount )
{
    ITER_SL_OF(ACCOUNT_ITEM) iterAccntItem( _slAccounts );
    ACCOUNT_ITEM *pAccntItem;

    while ( (pAccntItem = iterAccntItem.Next() ) != NULL )
    {
        if ( pAccntItem->QueryAccount() == plsaAccount )
            return TRUE;
    }

    return FALSE;

}


DEFINE_EXT_SLIST_OF( RIGHTS_ITEM );

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_GROUP::USER_RIGHTS_POLICY_GROUP

    SYPNOSIS:   Constructor

    ENTRY:      pdlg - pointer to the USER_RIGHTS_POLICY_DIALOG
                pcbRights - pointer to the rights combobox.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3-Mar-1992      Created

**************************************************************************/

USER_RIGHTS_POLICY_GROUP::USER_RIGHTS_POLICY_GROUP(
                             USER_RIGHTS_POLICY_DIALOG *pdlg,
                             COMBOBOX *pcbRights )
    :  _pdlg( pdlg ),
       _pcbRights( pcbRights )
{
     UIASSERT( pdlg != NULL );
     UIASSERT( pcbRights != NULL );

     if ( QueryError() != NERR_Success )
         return;

     _pcbRights->SetGroup( this );
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_GROUP::~USER_RIGHTS_POLICY_GROUP

    SYPNOSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3-Mar-1992      Created

**************************************************************************/

USER_RIGHTS_POLICY_GROUP::~USER_RIGHTS_POLICY_GROUP()
{
    _pdlg = NULL;
    _pcbRights = NULL;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_GROUP::OnUserAction

    SYPNOSIS:   When the user change the selection in the rights combobox,
                update the account listbox to reflect the right information.

    ENTRY:      pcw - control window
                e   - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        3-Mar-1992      Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_GROUP::OnUserAction( CONTROL_WINDOW *pcw,
                                               const CONTROL_EVENT &e )
{
    // If the selection in the combobox has changed, update the account
    // listbox.

    if ( pcw = QueryCBRights() )
    {
        // C7 CODEWORK: Remove Glock-pacifier cast
        if ( e.QueryCode() == CBN_SELCHANGE )
        {
             APIERR err;
             if ( (err = _pdlg->UpdateAccountsListbox()) != NERR_Success )
                 ::MsgPopup( QueryRightsDialog(), err );

        }
    }

    return GROUP_NO_CHANGE;
}

/*************************************************************************

    NAME:       ACCOUNT_LBI::ACCOUNT_LBI

    SYPNOSIS:   Constructor

    ENTRY:      plsaAccount - pointer to the LSA_ACCOUNT object to be
                              stored in the LBI

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_LBI::ACCOUNT_LBI( LSA_ACCOUNT *plsaAccount )
    : _plsaAccount( plsaAccount )
{
    UIASSERT( plsaAccount != NULL );

    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       ACCOUNT_LBI::~ACCOUNT_LBI

    SYPNOSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      _plsaAccount will be deleted by whoever that creates it.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_LBI::~ACCOUNT_LBI()
{
    _plsaAccount = NULL;
}

/*************************************************************************

    NAME:       ACCOUNT_LBI::Paint

    SYPNOSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created
        beng            24-Apr-1992     Change to LBI::Paint

**************************************************************************/

VOID ACCOUNT_LBI::Paint( LISTBOX     *plb,
                         HDC          hdc,
                         const RECT  *prect,
                         GUILTT_INFO *pGUILTT ) const
{
    STR_DTE strdteAccount( _plsaAccount->QueryName() );

    DISPLAY_TABLE dt( ACCOUNT_LB_NUM_COL,
                      ((ACCOUNT_LISTBOX *) plb)->QueryColumnWidths() );
    dt[0] = &strdteAccount;

    dt.Paint( plb, hdc, prect, pGUILTT );
}


/*************************************************************************

    NAME:       ACCOUNT_LBI::Compare

    SYPNOSIS:   Redefine Compare() method of LBI class

    ENTRY:      plbi - pointer to the LBI to compare with

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

INT ACCOUNT_LBI::Compare( const LBI *plbi ) const
{
    return (::stricmpf( _plsaAccount->QueryName(),
                       (( ACCOUNT_LBI *) plbi)->QueryAccount()->QueryName()));

}

/*************************************************************************

    NAME:       ACCOUNT_LBI::QueryLeadingChar

    SYPNOSIS:   Redefine QueryLeadingChar() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Nov-1992     Created

**************************************************************************/

WCHAR ACCOUNT_LBI::QueryLeadingChar( VOID ) const
{
    ALIAS_STR nls( _plsaAccount->QueryName());
    ISTR istr( nls );
    return nls.QueryChar( istr );
}

/*************************************************************************

    NAME:       ACCOUNT_LISTBOX::ACCOUNT_LISTBOX

    SYPNOSIS:   Constructor

    ENTRY:      powin - owner window
                cid   - the control id of the listbox

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_LISTBOX::ACCOUNT_LISTBOX( OWNER_WINDOW *powin, CID cid )
    : BLT_LISTBOX( powin, cid )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( (err = DISPLAY_TABLE::CalcColumnWidths( _adx,
                ACCOUNT_LB_NUM_COL, powin, cid, FALSE)) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::USER_RIGHTS_POLICY_DIALOG

    SYPNOSIS:   Constructor

    ENTRY:      pumadminapp - pointer to the parent admin_app
                plsaPolicy  - pointer to the LSA_POLICY object
                locFocus    - location of focus
    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

USER_RIGHTS_POLICY_DIALOG::USER_RIGHTS_POLICY_DIALOG( UM_ADMIN_APP *pumadminapp,
                                                      LSA_POLICY   *plsaPolicy,
                                                      const LOCATION &locFocus )
    : DIALOG_WINDOW ( IDD_USER_RIGHTS,
                      ((OWNER_WINDOW *)pumadminapp)->QueryHwnd() ),
      _pumadminapp  ( pumadminapp ),
      _sltFocusTitle( this, SLT_FOCUS_TITLE ),
      _sltFocus     ( this, SLT_FOCUS ),
      _cbRights     ( this, CB_RIGHTS ),
      _checkbAdvancedRights( this, CHECKB_ADVANCED_RIGHTS ),
      _lbAccounts   ( this, LB_ACCOUNT ),
      _buttonRemove ( this, BUTTON_REMOVE ),
      _rightsGrp    ( this, &_cbRights ),
      _plsaPolicy   ( plsaPolicy ),
      _locFocus     ( locFocus ),
      _pCurrentRightsItem( NULL ),
      _possidFocus    ( NULL )
{

    AUTO_CURSOR autocur;

    UIASSERT( plsaPolicy != NULL );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _rightsGrp.QueryError() ) != NERR_Success )
       || ((err = _locFocus.QueryError() ) != NERR_Success )
       )
    {
       ReportError( err );
       return;
    }

    // Set psidFocus to the sid of the Accounts domain.
    LSA_ACCT_DOM_INFO_MEM ladim;

    if ( (err = ladim.QueryError()) != NERR_Success
        || (err = plsaPolicy->GetAccountDomain( &ladim )) != NERR_Success )
    {
       ReportError( err );
       return;
    }

    _possidFocus = new OS_SID( ladim.QueryPSID(), TRUE );
    if ( _possidFocus == NULL )
    {
       ReportError( ERROR_NOT_ENOUGH_MEMORY );
       return;
    }

    if ( (err = _possidFocus->QueryError()) != NERR_Success )
    {
       ReportError( err );
       return;
    }


    //
    // Set the title text ( domain or computer ) and location of focus
    // in the dialog. ( Get rid of the backslashes if we are focused on
    // a computer ).
    //

    RESOURCE_STR nlsTitle( _locFocus.IsDomain()? IDS_DOMAIN_TEXT
                                               : IDS_SERVER_TEXT );
    NLS_STR nlsFocus;

    if (  ((err = nlsTitle.QueryError()) != NERR_Success )
       || ((err = nlsFocus.QueryError()) != NERR_Success )
       || ((err = locFocus.QueryDisplayName( &nlsFocus )) != NERR_Success )
       )
    {
       ReportError( err );
       return;
    }
    _sltFocusTitle.SetText( nlsTitle );
    ISTR istr( nlsFocus );
    if ( nlsFocus.QueryChar( istr ) == BACKSLASH_CHAR )
        istr += 2;  // skip past "\\"
    _sltFocus.SetText( nlsFocus.QueryPch( istr));

    //
    // Initialize the account linked list and the rights linked list
    //

    if (  ((err = InitRightsList() ) != NERR_Success )
       || ((err = InitAccountList() ) != NERR_Success )
       || ((err = UpdateAccountsListbox() ) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::~USER_RIGHTS_POLICY_DIALOG

    SYPNOSIS:   Destructor

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

USER_RIGHTS_POLICY_DIALOG::~USER_RIGHTS_POLICY_DIALOG()
{
    _pumadminapp = NULL;
    _plsaPolicy  = NULL;
    _pCurrentRightsItem = NULL;

    //
    // Iterate through the account linked list and
    // delete all the accounts contained in the account linked list
    //

    ITER_SL_OF(ACCOUNT_ITEM) iterAccntItem( _slAccounts );
    ACCOUNT_ITEM *pAccntItem;

    while ( (pAccntItem = iterAccntItem.Next() ) != NULL )
    {
        delete pAccntItem->QueryAccount();
    }

    delete _possidFocus;

}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::InitRightsList

    SYPNOSIS:   Build the rights linked list

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::InitRightsList( VOID )
{
    APIERR err = NERR_Success;

    do  // Not a loop
    {

        //
        //  Get all the privileges information from the LSA
        //

        LSA_PRIVILEGES_ENUM lsaPrivEnum( _plsaPolicy );
        NLS_STR nlsPriv;

        if (  ((err = nlsPriv.QueryError() ) != NERR_Success )
           || ((err = lsaPrivEnum.QueryError() ) != NERR_Success )
           || ((err = lsaPrivEnum.GetInfo() ) != NERR_Success )
           )
        {
            break;
        }

        //
        //  Enumerate through all the privileges and add them to the linked list
        //

        LSA_PRIVILEGES_ENUM_ITER lsaPrivEnumIter( lsaPrivEnum );
        const LSA_PRIVILEGES_ENUM_OBJ *plsaPrivObj;
        BOOL fAdvanced;

        while (  ( err == NERR_Success )
              && ((plsaPrivObj = lsaPrivEnumIter( &err ) ) != NULL )
              )
        {

            if (  (err != NERR_Success )
               || ((err = plsaPrivObj->QueryDisplayName( &nlsPriv,
                          _plsaPolicy )) != NERR_Success )
               || ((err = CheckIfAdvancedUserRight( plsaPrivObj, &fAdvanced ))
                          != NERR_Success )
               )
            {
                break;
            }

            RIGHTS_ITEM *pRightsItem = new RIGHTS_ITEM( nlsPriv,
                                       		plsaPrivObj->QueryLuid(),
				                fAdvanced );

            err = pRightsItem == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : pRightsItem->QueryError();

            if ( err != NERR_Success )
            {
                delete pRightsItem;
                pRightsItem = NULL;
            }
            else
            {
                err = _slRights.Add( pRightsItem );
            }
        }

        if ( err != NERR_Success )
            break;

        //
        //  Get all the system access mode and add them to the linked list
        //

        for ( UINT i = 0; err == NERR_Success && i < SYSACC_MAP_TABLE_SIZE; i++)
        {
            RESOURCE_STR nlsSys( SysAccMapTable[i].msgidSysAcc );

            if ( (err = nlsSys.QueryError()) != NERR_Success )
                break;

            RIGHTS_ITEM *pRightsItem = new RIGHTS_ITEM( nlsSys,
                                           SysAccMapTable[i].ulSysAcc,
					   SysAccMapTable[i].fAdvanced );

            err = pRightsItem == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : pRightsItem->QueryError();

            if ( err != NERR_Success )
            {
                delete pRightsItem;
                pRightsItem = NULL;
            }
            else
            {
                err = _slRights.Add( pRightsItem );
            }
        }

        if ( err != NERR_Success )
            break;

        //
        // Iterate through all the rights item in the linked list
        // and add them to the rights combo box.
        //
        err = RefreshRightsCombo( FALSE );  // don't want advanced rights

    } while ( FALSE );

    return err;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::CheckIfAdvancedUserRight

    SYPNOSIS:   Check to see if the given privilege is an advanced user
                right.

    ENTRY:      plsaPrivObj - The privilege

    EXIT:       *pfAdvanced - TRUE if the privilege is an advanced privilege,
                              FALSE otherwise.

    RETURN:

    NOTES:      This compares the internal name of the privilege
                with the privileges in the CommonUserRightsTable.

    HISTORY:
        Yi-HsinS        9-Dec-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::CheckIfAdvancedUserRight(
                                  const LSA_PRIVILEGES_ENUM_OBJ *plsaPrivObj,
				  BOOL *pfAdvanced )
{
    *pfAdvanced = TRUE;
    NLS_STR nlsName;
    APIERR err = nlsName.QueryError();

    if (  ( err == NERR_Success )
       && ( (err = plsaPrivObj->QueryName( &nlsName )) == NERR_Success )
       )
    {
        for ( INT i = 0;
              i < (INT)( (_pumadminapp->QueryTargetServerType() != UM_LANMANNT)
                        ? COMMON_USER_RIGHTS_TABLE_SIZE
                                        - COMMON_USER_RIGHTS_SERVER_ONLY
                        : COMMON_USER_RIGHTS_TABLE_SIZE );
              i++ )
        {
            ALIAS_STR nls( CommonUserRightsTable[i] );
            if ( nlsName.strcmp( nls ) == 0 )
            {
                *pfAdvanced = FALSE;
                break;
            }
        }
    }

    return err;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::RefreshRightsCombo

    SYPNOSIS:   Refresh the items in the rights combobox depending
                on whether advanced rights is needed or not.

    ENTRY:      fAdvanced - TRUE if we want advanced rights also, FALSE
                            otherwise

    EXIT:

    RETURN:

    NOTES:      If fAdvanced is TRUE, all rights will be shown. Else
                on rights that are common will be shown.

    HISTORY:
        Yi-HsinS        9-Dec-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::RefreshRightsCombo( BOOL fAdvanced )
{

    NLS_STR nlsSelected;
    APIERR err = nlsSelected.QueryError();
    if ( err != NERR_Success )
        return err;

    //
    // Store the original selection and delete all items in the combobox
    // if it is not empty
    //
    if ( _cbRights.QueryCount() > 0 )
    {
        if ((err = _cbRights.QueryItemText( &nlsSelected )) != NERR_Success)
            return err;

        _cbRights.DeleteAllItems();
    }

    //
    // Iterate through all the rights and add the rights to the combo
    // depending on the fAdvanced flag.
    //
    ITER_SL_OF(RIGHTS_ITEM) iterRightsItem( _slRights );
    RIGHTS_ITEM *pRightsItem;

    while ( (pRightsItem = iterRightsItem.Next() ) != NULL )
    {
        if (  ( fAdvanced )
           || ( !pRightsItem->IsAdvanced() )
           )
        {
            _cbRights.AddItem( *(pRightsItem->QueryName()) );
        }
    }

    //
    // Restore the original selection if possible.
    //
    INT i = 0;
    if ( nlsSelected.QueryTextLength() > 0 )
    {
        i = _cbRights.FindItemExact( nlsSelected );
        if ( i < 0 )
            i = 0;   // Select the first item if the item is not found
    }

    _cbRights.SelectItem( i );
    return NERR_Success;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::InitAccountList

    SYPNOSIS:   Build the account linked list

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::InitAccountList( VOID )
{
    APIERR err = NERR_Success;

    do  // Not a loop
    {

        //
        // Get information aboutn all accounts in the LSA
        //
        LSA_ACCOUNTS_ENUM lsaAccntEnum( _plsaPolicy );

        if (  ((err = lsaAccntEnum.QueryError()) != NERR_Success )
           || ((err = lsaAccntEnum.GetInfo()) != NERR_Success )
           )
        {
           break;
        }

        //
        // Iterate through all accounts
        //
        LSA_ACCOUNTS_ENUM_ITER lsaAccntEnumIter( lsaAccntEnum );
        const LSA_ACCOUNTS_ENUM_OBJ *plsaAccntObj;

        while (  ( err == NERR_Success )
              && (( plsaAccntObj = lsaAccntEnumIter( &err ) ) != NULL )
              )
        {

            if ( err != NERR_Success )
                break;

            //
            // Create a LSA_ACCOUNT for the account
            //
            LSA_ACCOUNT *plsaAccount = new LSA_ACCOUNT(
                                                _plsaPolicy,
                                                plsaAccntObj->QuerySid(),
                                                LSA_ACCOUNT_DEFAULT_MASK,
                                                _locFocus.QueryServer(),
                                                _possidFocus == NULL ? NULL
                                                       : _possidFocus->QueryPSID() );

            err = plsaAccount == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : plsaAccount->QueryError();

            if ( err != NERR_Success )
            {
                delete plsaAccount;
                plsaAccount = NULL;
                break;
            }

            //
            //  Get information about the account
            //
            err = plsaAccount->GetInfo();

            if ( err != NERR_Success )
                break;

            //
            //  Get all privileges granted to the account
            //
            LSA_ACCOUNT_PRIVILEGE_ENUM_ITER *plsaAccntPrivEnumIter;
            err = plsaAccount->QueryPrivilegeEnumIter( &plsaAccntPrivEnumIter );

            if ( err != NERR_Success )
            {
                delete plsaAccntPrivEnumIter;
                break;
            }

            //
            //  Iterate through all privileges granted to the account
            //
            const OS_LUID_AND_ATTRIBUTES *pOsLuidAttrib;
            ACCOUNT_ITEM *pAccntItem = NULL;

            while (  ( err == NERR_Success )
                  && (( pOsLuidAttrib = (*plsaAccntPrivEnumIter)() ) != NULL )
                  )
            {

                // Find the rights item that contained the privilege
                // and add the account to the list of accounts that have
                // the right.
                RIGHTS_ITEM *pRightsItem = FindRightsItem(
                                           pOsLuidAttrib->QueryOsLuid() );

                if ( pRightsItem == NULL )
                    continue;

                err = CreateAccntItem( &pAccntItem, plsaAccount );
                err = err? err : pRightsItem->AddAccount( pAccntItem );
            }

            delete plsaAccntPrivEnumIter;

            if ( err != NERR_Success )
                break;

            //
            //  Find the system accesses granted to the account
            //
            ULONG ulSysAcc = plsaAccount->QuerySystemAccess();

            //
            //  Iterate through the system access modes
            //
            for ( UINT i = 0; i < SYSACC_MAP_TABLE_SIZE; i++ )
            {
                if ( ulSysAcc & SysAccMapTable[i].ulSysAcc )
                {
                    // Find the rights item that contained the system access
                    // and add the account to the list of accounts that have
                    // the right.
                    RIGHTS_ITEM *pRightsItem = FindRightsItem(
                                               SysAccMapTable[i].ulSysAcc );
                    UIASSERT( pRightsItem != NULL );
                    err = CreateAccntItem( &pAccntItem, plsaAccount );
                    err = err? err : pRightsItem->AddAccount( pAccntItem );
                }
            }

            if ( err != NERR_Success )
                break;

            //
            //  Add the account to the account linked list
            //
            err = CreateAccntItem( &pAccntItem, plsaAccount );
            err = err? err : _slAccounts.Add( pAccntItem );
        }

        if ( err != NERR_Success )
            break;

    } while ( FALSE );

    return err;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::CreateAccntItem

    SYPNOSIS:   Create a new ACCOUNT_ITEM containing the LSA_ACCOUNT object

    ENTRY:      plsaAccount - pointer to the LSA_ACCOUNT object

    EXIT:       *ppAccntItem  - pointer to the newly created ACCOUNT_ITEM

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::CreateAccntItem( ACCOUNT_ITEM **ppAccntItem,
                                                   LSA_ACCOUNT   *plsaAccount )
{
    *ppAccntItem = new ACCOUNT_ITEM( plsaAccount );

    APIERR err = *ppAccntItem == NULL? ERROR_NOT_ENOUGH_MEMORY
                                     : (*ppAccntItem)->QueryError();

    if ( err != NERR_Success )
    {
        delete *ppAccntItem;
        *ppAccntItem = NULL;
    }

    return err;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::FindRightsItem

    SYPNOSIS:   Find the rights item containing the same OS_LUID

    ENTRY:      OsLuid - the OS_LUID to search for in the rights linked list

    EXIT:

    RETURN:     Return a pointer to the RIGHTS_ITEM containing the OS_LUID
                Will return NULL if it's not found.

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

RIGHTS_ITEM *USER_RIGHTS_POLICY_DIALOG::FindRightsItem( const OS_LUID &OsLuid )
{
    ITER_SL_OF(RIGHTS_ITEM) iterRightsItem( _slRights );

    RIGHTS_ITEM *pRightsItem;

    while ( (pRightsItem = iterRightsItem.Next() ) != NULL )
    {
        if ( pRightsItem->IsPrivilege() && OsLuid == pRightsItem->QueryOsLuid())
            return pRightsItem;
    }

    return NULL;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::FindRightsItem

    SYPNOSIS:   Find the rights item containing the same system access

    ENTRY:      ulSystemAccess - the system access mode to search for
                                 in the rights linked list

    EXIT:

    RETURN:     Returns a pointer to the RIGHTS_ITEM containing the system
                access. Will return NULL if it's not found.

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

RIGHTS_ITEM *USER_RIGHTS_POLICY_DIALOG::FindRightsItem( ULONG ulSystemAccess )
{
    ITER_SL_OF(RIGHTS_ITEM) iterRightsItem( _slRights );

    RIGHTS_ITEM *pRightsItem;

    while ( (pRightsItem = iterRightsItem.Next() ) != NULL )
    {
        if (  pRightsItem->IsSystemAccess()
           && (ulSystemAccess == pRightsItem->QuerySystemAccess() )
           )
        {
            return pRightsItem;
        }
    }

    return NULL;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::FindRightsItem

    SYPNOSIS:   Find the rights item containing the same name

    ENTRY:      nlsName - the name to search for in the rights linked list

    EXIT:

    RETURN:     Return a pointer to the RIGHTS_ITEM containing the same name
                Will return NULL if it's not found.

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

RIGHTS_ITEM *USER_RIGHTS_POLICY_DIALOG::FindRightsItem( const NLS_STR &nlsName )
{
    ITER_SL_OF(RIGHTS_ITEM) iterRightsItem( _slRights );

    RIGHTS_ITEM *pRightsItem;

    while ( (pRightsItem = iterRightsItem.Next() ) != NULL )
    {
        if ( nlsName._stricmp( *(pRightsItem->QueryName()) ) == 0 )
            return pRightsItem;
    }

    return NULL;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::FindAccntItem

    SYPNOSIS:   Find the account item that contains the same sid in the
                account linked list.

    ENTRY:      OsSid - the sid to search for in the linked list

    EXIT:

    RETURN:     Returns a pointer to the ACCOUNT_ITEM if found and
                NULL if not found.

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

ACCOUNT_ITEM *USER_RIGHTS_POLICY_DIALOG::FindAccntItem( const OS_SID &OsSid )
{
    ITER_SL_OF(ACCOUNT_ITEM) iterAccntItem( _slAccounts );

    ACCOUNT_ITEM *pAccntItem;

    while ( (pAccntItem = iterAccntItem.Next() ) != NULL )
    {
        if ( (pAccntItem->QueryAccount())->QueryOsSid() == OsSid )
        {
            return pAccntItem;
        }
    }

    return NULL;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::UpdateAccountsListbox

    SYPNOSIS:   Update the account listbox when the user change the
                rights selection in the rights combobox.

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::UpdateAccountsListbox( VOID )
{
    APIERR err;
    NLS_STR nls;

    //
    //  Query the name of the selected right.
    //

    if (  ((err = nls.QueryError()) != NERR_Success )
       || ((err = _cbRights.QueryItemText( &nls )) != NERR_Success )
       )
    {
        return err;
    }

    //
    //  Find the RIGHTS_ITEM object  associated with the name
    //

    _pCurrentRightsItem = FindRightsItem( nls );
    UIASSERT( _pCurrentRightsItem != NULL );

    //
    //  Update the listbox
    //  (1) Delete all items in the list box
    //  (2) Add the account that have the current selected right
    //      into the listbox
    //

    _lbAccounts.SetRedraw( FALSE );
    _lbAccounts.DeleteAllItems();

    ITER_SL_OF(ACCOUNT_ITEM) iterAccntItem(
                             _pCurrentRightsItem->QueryAccountList() );
    ACCOUNT_ITEM *pAccntItem;
    BOOL fAccountExist = FALSE;

    while ( (pAccntItem = iterAccntItem.Next() ) != NULL )
    {
        fAccountExist = TRUE;

        ACCOUNT_LBI *pAccntlbi = new ACCOUNT_LBI( pAccntItem->QueryAccount());

        if (  ( pAccntlbi == NULL )
           || ( _lbAccounts.AddItem( pAccntlbi ) < 0 )
           )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            delete pAccntlbi;
            pAccntlbi = NULL;
            break;
        }
    }

    _lbAccounts.SetRedraw( TRUE );

    //
    //  Enable/Disable the Remove button depending on
    //  whether there are accounts granted this right.
    //

    if ( err == NERR_Success )
    {
        if ( fAccountExist )
            _lbAccounts.SelectItem( 0 );

        _buttonRemove.Enable( fAccountExist );

    }

    return err;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::OnCommand

    SYPNOSIS:   Process the Add and Remove button

    ENTRY:      event - CONTROL_EVENT

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

BOOL USER_RIGHTS_POLICY_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    switch ( event.QueryCid() )
    {
        case BUTTON_ADD:
        {
            err = OnAdd();
            break;
        }

        case BUTTON_REMOVE:
        {
            LSA_ACCOUNT *plsaCurrentAccount =
                         (_lbAccounts.QueryItem())->QueryAccount();

            //
            // Delete the privilege or system access contained in the account
            //
            if ( _pCurrentRightsItem->IsPrivilege() )
            {
                err = plsaCurrentAccount->DeletePrivilege(
                            (_pCurrentRightsItem->QueryOsLuid()).QueryLuid() );
            }
            else
            {
                plsaCurrentAccount->DeleteSystemAccessMode(
                                    _pCurrentRightsItem->QuerySystemAccess() );
            }

            if ( err == NERR_Success )
            {
                //
                // Remove the account from the account linked list contained
                // in the rights item and update the account listbox
                //
                ACCOUNT_ITEM accntitem( plsaCurrentAccount );
                _pCurrentRightsItem->RemoveAccount( accntitem );
                err = err ? err : UpdateAccountsListbox();
            }
            break;
        }

        case CHECKB_ADVANCED_RIGHTS:
            err = RefreshRightsCombo( _checkbAdvancedRights.QueryCheck() );
            if ( err == NERR_Success )
                err = UpdateAccountsListbox();
            break;

        default:
            return DIALOG_WINDOW::OnCommand( event );

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    return TRUE;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::OnAdd

    SYPNOSIS:   Popup the USER_BROWSER dialog and add the accounts the
                user selected into the account listbox

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR USER_RIGHTS_POLICY_DIALOG::OnAdd( VOID )
{
    AUTO_CURSOR autocur;

    APIERR err = NERR_Success;

    //
    // Display the user browser dialog
    //


    NT_USER_BROWSER_DIALOG *pdlg = new NT_USER_BROWSER_DIALOG(
                                       USRBROWS_DIALOG_NAME,
                                       this->QueryHwnd(),
                                       _locFocus.QueryServer(),
                                       HC_UM_ADD_RIGHTS,
                                       USRBROWS_SHOW_ALL
                                       | USRBROWS_INCL_REMOTE_USERS
                                       | USRBROWS_INCL_INTERACTIVE
                                       | USRBROWS_INCL_EVERYONE,
				       BLT::CalcHelpFileHC(HC_UM_ADD_RIGHTS),
	                  	       0,
	                  	       0,
	                  	       0,
	                  	       (_pumadminapp->QueryTargetServerType() == UM_LANMANNT)
                                          ? _pumadminapp->QueryAdminAuthority()
	                  	          : NULL );


    do  // Not a loop
    {
        err = pdlg == NULL? ERROR_NOT_ENOUGH_MEMORY
                          : pdlg->QueryError();

        BOOL fOK;
        err = err? err : pdlg->Process( &fOK );

        if (  ( err != NERR_Success )
           || ( !fOK )
           )
        {
            break;
        }

        //
        // Iterate through all items selected by the user in the
        // USER_BROWSER listbox.
        //

        BROWSER_SUBJECT_ITER browSubIter( pdlg );

        if ( (err = browSubIter.QueryError() ) != NERR_Success )
            break;

        BROWSER_SUBJECT *pBrowSub;
        while (  ((err = browSubIter.Next( &pBrowSub )) == NERR_Success )
              && ( pBrowSub != NULL )
              )
        {
            OS_SID *pOsSid = (OS_SID *) pBrowSub->QuerySid();
            ACCOUNT_ITEM *pAccntItem = FindAccntItem( *pOsSid );
            LSA_ACCOUNT *plsaAccount = NULL;

            //
            // The account for the SID already exists
            //
            if ( pAccntItem != NULL )
            {
                plsaAccount = pAccntItem->QueryAccount();
            }

            //
            // The account for the SID does not exist, so create a new
            // LSA_ACCOUNT for it.
            //
            else
            {
                plsaAccount = new LSA_ACCOUNT( _plsaPolicy,
                                               pOsSid->QuerySid(),
                                               LSA_ACCOUNT_DEFAULT_MASK,
                                               _locFocus.QueryServer(),
                                               _possidFocus == NULL ? NULL
                                                      : _possidFocus->QueryPSID() );

                err = plsaAccount == NULL? ERROR_NOT_ENOUGH_MEMORY
                                         : plsaAccount->QueryError();

                if ( err != NERR_Success )
                {
                    delete plsaAccount;
                    plsaAccount = NULL;
                    break;
                }

                err = plsaAccount->CreateNew();

                // Create a new ACCOUNT_ITEM and add it to the account
                // linked list.
                err = err? err : CreateAccntItem( &pAccntItem, plsaAccount );
                err = err? err : _slAccounts.Add( pAccntItem );
            }

            //
            // If the current RIGHTS_ITEM does not already have the account,
            // add it and then update the account listbox.
            //
            if ( !_pCurrentRightsItem->HasAccount( plsaAccount ) )
            {
                err =  err ? err : CreateAccntItem( &pAccntItem, plsaAccount );
                err =  err ? err : _pCurrentRightsItem->AddAccount( pAccntItem);

                if ( err == NERR_Success )
                {
                    if ( _pCurrentRightsItem->IsPrivilege() )
                    {
                        err = plsaAccount->InsertPrivilege(
                            (_pCurrentRightsItem->QueryOsLuid()).QueryLuid() );
                    }
                    else
                    {
                       plsaAccount->InsertSystemAccessMode(
                             _pCurrentRightsItem->QuerySystemAccess() );
                    }

                    err =  err ? err : UpdateAccountsListbox();

                }
            }

        }

        if ( err != NERR_Success )
            break;

    } while ( FALSE );

    delete pdlg;
    pdlg = NULL;

    return err;

}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::OnOK

    SYPNOSIS:   Write all the information back to the LSA.

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created
	thomaspa	11-Jun-1992	Don't allow removal of administrators
					local group from local logon right.

**************************************************************************/

BOOL USER_RIGHTS_POLICY_DIALOG::OnOK( VOID )
{
    AUTO_CURSOR autocur;

    //
    //  Make sure that we don't remove interactive logon right from
    //  the Administrators Local Group.
    //

    //  Get the sid of the Administrators Local Group
    OS_SID ossidAdminAlias;
    APIERR err = ossidAdminAlias.QueryError();
    if (  ( err != NERR_Success )
       || (( err =  NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_Admins,
		   &ossidAdminAlias) ) != NERR_Success )
       )
    {
        ::MsgPopup( this, err );
        return TRUE;
    }

    RIGHTS_ITEM *pRightsItem = FindRightsItem( POLICY_MODE_INTERACTIVE );

    ITER_SL_OF(ACCOUNT_ITEM) iter(pRightsItem->QueryAccountList() );
    ACCOUNT_ITEM *pItem;
    BOOL fAccountExist = FALSE;

    while ( (pItem = iter.Next() ) != NULL )
    {
	if ( pItem->QueryAccount()->QueryOsSid() == ossidAdminAlias )
	{
	    fAccountExist = TRUE;
	    break;
	}
    }

    //  Popup an error the the administrator group is removed from the
    //  interactive logon right.
    if ( !fAccountExist )
    {
        ::MsgPopup( this, IDS_CannotRemoveAdminInteractive, MPSEV_ERROR, MP_OK);
	return TRUE;
    }

    //
    //  Iterate through all accounts
    //  (1) If the account has default settings
    //      ( no rights and no system access ), delete it.
    //  (2) Else write them back to LSA.
    //

    ITER_SL_OF(ACCOUNT_ITEM) iterAccntItem( _slAccounts );

    ACCOUNT_ITEM *pAccntItem;
    while ( (pAccntItem = iterAccntItem.Next() ) != NULL )
    {

        LSA_ACCOUNT *plsaAccount = pAccntItem->QueryAccount();

        if ( plsaAccount->IsDefaultSettings() )
            err = plsaAccount->Delete();
        else
            err = plsaAccount->Write();

        if ( err != NERR_Success )
            break;

    }

    if ( err != NERR_Success )
        ::MsgPopup( this, err );

    Dismiss( TRUE );

    return TRUE;
}

/*************************************************************************

    NAME:       USER_RIGHTS_POLICY_DIALOG::QueryHelpContext

    SYPNOSIS:   Query the help context associated with the dialog.

    ENTRY:

    EXIT:

    RETURN:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/
ULONG USER_RIGHTS_POLICY_DIALOG::QueryHelpContext( VOID )
{
    return HC_UM_POLICY_RIGHTS_LANNT + _pumadminapp->QueryHelpOffset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\secset.cxx ===
/**********************************************************************/
/**                Microsoft LAN Manager                             **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    secset.cxx


    FILE HISTORY:
    o-SimoP 06-Jun-1991     Created
    o-SimoP 11-Jul-1991     Code Review changes.
                            Attend: AnnMc, JohnL, Rustanl
    o-SimoP 03-Dec-1991     Security ID removed
    JonN    11-May-1992     Logoff delay reduced to checkbox
    JonN    10-Jun-1992     ForceLogoff only for UM_LANMANNT
    Yi-HsinS 8-Dev-1992	    Removed \\ when display computer name
    JonN    22-Dec-1993     Added AllowNoAnonChange
    JonN     5-Jan-1994     Added account lockout
*/


#include <ntincl.hxx>
extern "C"
{
    #include <ntlsa.h> // req'd for uintsam.hxx
    #include <ntsam.h>
}


#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#define   INCL_NETSERVER
#define   INCL_NETUSER   // NetUserSetInfo

#include <lmui.hxx>
#include <lmomod.hxx>


#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#include <blt.hxx>
#include <bltspobj.hxx>

extern "C"
{
    #include <usrmgr.h>
    #include <usrmgrrc.h>
    #include <umhelpc.h>
}

#include <usrmain.hxx> // for fMiniUserManager
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <secset.hxx>
#include <uintsam.hxx> // SAM_PSWD_DOM_INFO_MEM


#define SEC_PER_DAY  86400L //(60L * 60L * 24L)
#define SEC_PER_MIN  60

#define MAX_PASS_AGE_DEFAULT    90
#define MAX_PASS_AGE_MIN        1
#define MAX_PASS_AGE_MAX        999

#define MIN_PASS_LEN_DEFAULT    DEF_MIN_PWLEN // also in usrmain.cxx
#define MIN_PASS_LEN_MIN        1
#define MIN_PASS_LEN_MAX        14

#define MIN_PASS_AGE_DEFAULT    1
#define MIN_PASS_AGE_MIN        1
#define MIN_PASS_AGE_MAX        999

#define HISTORY_LEN_DEFAULT     5
#define HISTORY_LEN_MIN         1
#define HISTORY_LEN_MAX         24 // by request from JimK

//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:   SECSET_DIALOG::SECSET_DIALOG

    SYNOPSIS:   Constructor for Security Settings dialog

    ENTRY:  wndParent       - handle to parent window
	    locFocusName    - LOCATION reference, holds
                              domain/server name
            pszSecurityId   - pointer to SID

    HISTORY:
    simo        06-Jun-1991     Created
    o-SimoP     11-Jul-1991     Code Review changes.
    JonN	14-Aug-1991	Made some members pointers to get around
				C6's "out of heap space" problem
    JonN        11-May-1992     Logoff delay reduced to checkbox
********************************************************************/

SECSET_DIALOG::SECSET_DIALOG( UM_ADMIN_APP * pumadminapp,
    const LOCATION  & locFocusName,
    UINT idResource )
    :   DIALOG_WINDOW( MAKEINTRESOURCE( idResource ),
                       pumadminapp->QueryHwnd() ),
    _umInfo( locFocusName.QueryServer() ),
    _sltDomainOrServer( this, SLT_DOMAIN_OR_SERVER ),
    _sltpDomainOrServerName( this, SLTP_DOMAIN_OR_SERVER_NAME ),

//    _pmgrpMaxPassAge( NULL ),
        _spsleSetMaxAge( this, SLE_MAX_PASSW_AGE_SET_DAYS,
            MAX_PASS_AGE_DEFAULT, MAX_PASS_AGE_MIN, MAX_PASS_AGE_MAX, TRUE,
            FRAME_MAX_PASSW_AGE_SET_DAYS ),
        _spgrpSetMaxAge( this, SB_MAX_PASSW_AGE_SET_DAYS_GRP,
            SB_MAX_PASSW_AGE_SET_DAYS_UP, SB_MAX_PASSW_AGE_SET_DAYS_DOWN ),

//    _pmgrpMinPassLength( NULL ),
        _spsleSetLength( this, SLE_PASSW_LENGTH_SET_LEN,
            MIN_PASS_LEN_DEFAULT, MIN_PASS_LEN_MIN, MIN_PASS_LEN_MAX, TRUE,
            FRAME_PASSW_LENGTH_SET_LEN ),
        _spgrpSetLength( this, SB_PASSW_LENGTH_SET_LEN_GRP,
            SB_PASSW_LENGTH_SET_LEN_UP, SB_PASSW_LENGTH_SET_LEN_DOWN ),

//    _pmgrpMinPassAge( NULL ),
        _spsleSetMinAge( this, SLE_MIN_PASSW_AGE_SET_DAYS,
            MIN_PASS_AGE_DEFAULT, MIN_PASS_AGE_MIN, MIN_PASS_AGE_MAX, TRUE,
            FRAME_MIN_PASSW_AGE_SET_DAYS ),
        _spgrpSetMinAge( this, SB_MIN_PASSW_AGE_SET_DAYS_GRP,
            SB_MIN_PASSW_AGE_SET_DAYS_UP, SB_MIN_PASSW_AGE_SET_DAYS_DOWN ),

//    _pmgrpPassUniqueness( NULL ),
        _spsleSetAmount( this, SLE_PASSW_UNIQUE_SET_AMOUNT,
            HISTORY_LEN_DEFAULT, HISTORY_LEN_MIN, HISTORY_LEN_MAX, TRUE,
            FRAME_PASSW_UNIQUE_SET_AMOUNT ),
        _spgrpSetAmount( this, SB_PASSW_UNIQUE_SET_AMOUNT_GRP,
            SB_PASSW_UNIQUE_SET_AMOUNT_UP, SB_PASSW_UNIQUE_SET_AMOUNT_DOWN ),

     _pcbForceLogoff( NULL ),
     _phiddenForceLogoff( NULL ),
     _pcbAllowNoAnonChange( NULL ),
     _fAllowNoAnonChange( TRUE ),
     _pumadminapp( pumadminapp )
{
    _pmgrpMaxPassAge = NULL;
    _pmgrpMinPassLength = NULL;
    _pmgrpMinPassAge = NULL;
    _pmgrpPassUniqueness = NULL;

    APIERR err = QueryError();
    if( NERR_Success != err )
    {
        return;
    }

    _pmgrpMaxPassAge = new MAGIC_GROUP(
		    this, RB_MAX_PASSW_AGE_NEVER_EXPIRES,
                    2, RB_MAX_PASSW_AGE_NEVER_EXPIRES );
    _pmgrpMinPassLength = new MAGIC_GROUP(
		    this, RB_PASSW_LENGTH_PERMIT_BLANK,
                    2, RB_PASSW_LENGTH_PERMIT_BLANK );
    _pmgrpMinPassAge = new MAGIC_GROUP(
		    this, RB_MIN_PASSW_AGE_ALLOW_IMMEDIA,
                    2, RB_MIN_PASSW_AGE_ALLOW_IMMEDIA );
    _pmgrpPassUniqueness = new MAGIC_GROUP(
		    this, RB_PASSW_UNIQUE_NOT_HISTORY,
                    2, RB_PASSW_UNIQUE_NOT_HISTORY );
    if( (_pmgrpMaxPassAge == NULL)		||
        (_pmgrpMinPassLength == NULL)		||
        (_pmgrpMinPassAge == NULL)		||
        (_pmgrpPassUniqueness == NULL) )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if( (err = _pmgrpMaxPassAge->QueryError())    ||
        (err = _pmgrpMinPassLength->QueryError()) ||
        (err = _pmgrpMinPassAge->QueryError())    ||
        (err = _pmgrpPassUniqueness->QueryError()) )
    {
        ReportError( err );
        return;
    }

    // MUM:            we hide    the ForceLogoff control
    // FUM->Downlevel: we disable the ForceLogoff control
    // FUM->WinNt:     we disable the ForceLogoff control
    // FUM->LanManNt:  we enable  the ForceLogoff control
    ASSERT(   (!fMiniUserManager)
           || (_pumadminapp->QueryTargetServerType() != UM_LANMANNT) );
    if ( fMiniUserManager )
    {
        _phiddenForceLogoff = new HIDDEN_CONTROL( this, SECSET_CB_DISCONNECT );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (_phiddenForceLogoff == NULL)
            || (err = _phiddenForceLogoff->QueryError()) )
        {
            ReportError( err );
            return;
        }
    }
    else
    {
        _pcbForceLogoff = new CHECKBOX( this, SECSET_CB_DISCONNECT );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (_pcbForceLogoff == NULL)
            || (err = _pcbForceLogoff->QueryError()) )
        {
            ReportError( err );
            return;
        }

        if (_pumadminapp->QueryTargetServerType() != UM_LANMANNT)
        {
            _pcbForceLogoff->Enable( FALSE );
        }
    }

    // MUM:            we enable  the AllowNoAnonChange control
    // FUM->Downlevel: we disable the AllowNoAnonChange control
    // FUM->WinNt:     we enable  the AllowNoAnonChange control
    // FUM->LanManNt:  we enable  the AllowNoAnonChange control
    {
        _pcbAllowNoAnonChange = new CHECKBOX( this, SECSET_CB_NOANONCHANGE );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (_pcbAllowNoAnonChange == NULL)
            || (err = _pcbAllowNoAnonChange->QueryError()) )
        {
            ReportError( err );
            return;
        }

        if (_pumadminapp->QueryTargetServerType() == UM_DOWNLEVEL)
        {
            _pcbAllowNoAnonChange->Enable( FALSE );
        }
    }


    AUTO_CURSOR autocur;

    err = _umInfo.GetInfo();
    if( NERR_Success != err )
    {
        DBGEOL( "SECSET_DIALOG::ctor _umInfo.GetInfo error " << err );
        ReportError( err );
        return;
    }

    //
    // read _fAllowNoAnonChange
    //
    if (_pumadminapp->QueryTargetServerType() != UM_DOWNLEVEL)
    {
        SAM_PSWD_DOM_INFO_MEM sampswdinfo;
        if (  (err = sampswdinfo.QueryError()) != NERR_Success
            || (err = _pumadminapp->QueryAdminAuthority()
                         ->QueryAccountDomain()->GetPasswordInfo(
                                 &sampswdinfo )) != NERR_Success
           )
       {
           DBGEOL( "SECSET_DLG::ctor: error reading NoAnonChange " << err );
           ReportError( err );
           return;
       }
       _fAllowNoAnonChange = sampswdinfo.QueryNoAnonChange();
    }

    _spsleSetLength.SetBigIncValue( 1 );
    _spsleSetAmount.SetBigIncValue( 1 );

    if( (err = _spgrpSetMaxAge.AddAssociation( &_spsleSetMaxAge )) ||
        (err = _spgrpSetLength.AddAssociation( &_spsleSetLength )) ||
        (err = _spgrpSetMinAge.AddAssociation( &_spsleSetMinAge )) ||
        (err = _spgrpSetAmount.AddAssociation( &_spsleSetAmount )) )
    {
        ReportError( err );
        return;
    }

    STACK_NLS_STR( nlsTemp, MAX_RES_STR_LEN );

    err = nlsTemp.Load( locFocusName.IsDomain() ?
        IDS_DOMAIN_TEXT : IDS_SERVER_TEXT );
    if( NERR_Success != err )
    {
	DBGEOL( "SECSET_DIALOG::ctor Error in resouces (Load) " << err );
        ReportError( err );
        return;
    }
    _sltDomainOrServer.SetText( nlsTemp );

    STACK_NLS_STR( nlsTemp2, MAX_RES_STR_LEN ); // CODEWORK only needs to
						// be as long as computername
    if ( (err = locFocusName.QueryDisplayName( &nlsTemp2 )) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    ISTR istr( nlsTemp2 );
    if ( nlsTemp2.QueryChar( istr ) == TCH('\\') )
        istr += 2;  // skip past "\\"
    _sltpDomainOrServerName.SetText( nlsTemp2.QueryPch(istr));

    if ((err = _pmgrpMaxPassAge->AddAssociation(
             RB_MAX_PASSW_AGE_SET_DAYS, &_spgrpSetMaxAge ))  ||
         (err = _pmgrpMinPassLength->AddAssociation(
             RB_PASSW_LENGTH_SET_LEN, &_spgrpSetLength ))    ||
         (err = _pmgrpMinPassAge->AddAssociation(
             RB_MIN_PASSW_AGE_SET_DAYS, &_spgrpSetMinAge ))  ||
         (err = _pmgrpPassUniqueness->AddAssociation(
             RB_PASSW_UNIQUE_SET_AMOUNT, &_spgrpSetAmount )) )
    {
        ReportError( err );
        return ;
    }

    SetDataFields();

    _pmgrpMaxPassAge->SetControlValueFocus() ;

}// SECSET_DIALOG::SECSET_DIALOG



/*******************************************************************

    NAME:       SECSET_DIALOG::~SECSET_DIALOG

    SYNOPSIS:   Destructor for Security Settings dialog

    HISTORY:
    o-SimoP     11-Jul-1991     Created

********************************************************************/

SECSET_DIALOG::~SECSET_DIALOG( void )
{
    delete _pmgrpMaxPassAge;
    delete _pmgrpMinPassLength;
    delete _pmgrpMinPassAge;
    delete _pmgrpPassUniqueness;
    delete _pcbForceLogoff;
    delete _phiddenForceLogoff;
    delete _pcbAllowNoAnonChange;
}


/*******************************************************************

    NAME:       SECSET_DIALOG::OnOK

    SYNOPSIS:   OK button handler

    EXIT:       calls USER_MODALS::WriteInfo and exits dialog
                if information from dialog is ok

    HISTORY:
               simo  16-May-1991    created

********************************************************************/

BOOL SECSET_DIALOG::OnOK( void )
{

    APIERR err = GetAndCheckDataFields();
    if ( err != NERR_Success )
    {
        DBGEOL( "SECSET_DIALOG::OnOK GetAndCheckDataFields() error " << err ) ;
        ::MsgPopup( this, err );
        _spsleSetMinAge.ClaimFocus();
        _spsleSetMinAge.SelectString();
    }
    else
    {
        err = WriteDataFields();
        if ( err != NERR_Success )
        {
            DBGEOL( "SECSET_DIALOG::OnOK WriteDataFields error " << err ) ;
            ::MsgPopup( this, err );
        }
        else
        {
            Dismiss(TRUE);
        }
    }

    return TRUE;

}   // SECSET_DIALOG::OnOK



/*******************************************************************

    NAME:       SECSET_DIALOG::WriteDataFields

    SYNOPSIS:   Writes information in data fields, part of OK button handler

    EXIT:       calls USER_MODALS::WriteInfo

    HISTORY:
               jonn  28-Dec-1993    created

********************************************************************/

APIERR SECSET_DIALOG::WriteDataFields( void )
{

   APIERR err = _umInfo.WriteInfo();
   if( err != NERR_Success )
   {
       DBGEOL( "SECSET_DIALOG::WriteDataFields WriteInfo error " << err ) ;
   }
   else
   {
       //
       // write _fAllowNoAnonChange only if it has changed
       //
       if (_pumadminapp->QueryTargetServerType() != UM_DOWNLEVEL)
       {
          SAM_PSWD_DOM_INFO_MEM sampswdinfo;
          if (  (err = sampswdinfo.QueryError()) != NERR_Success
              || (err = _pumadminapp->QueryAdminAuthority()
                           ->QueryAccountDomain()->GetPasswordInfo(
                                   &sampswdinfo )) != NERR_Success
              || (sampswdinfo.QueryNoAnonChange() == _fAllowNoAnonChange)
              || (sampswdinfo.SetNoAnonChange( _fAllowNoAnonChange ), FALSE)
              || (err = _pumadminapp->QueryAdminAuthority()
                           ->QueryAccountDomain()->SetPasswordInfo(
                                   &sampswdinfo )) != NERR_Success
             )
          {
              if (err != NERR_Success)
                  DBGEOL( "SECSET_DLG::OnOK: error writing NoAnonChange " << err );
          }
       }
   }

    return err;

}   // SECSET_DIALOG::WriteDataFields


/*******************************************************************

    NAME:       SECSET_DIALOG::SetDataFields

    SYNOPSIS:   Fills SPIN fields, the default values are given
                in the constructor of SECSET_DIALOG

    ENTRY:      It is assumed that magic groups have
                not been AddAssociate'd

    HISTORY:
               Simo  20-June-1991    created

********************************************************************/

void SECSET_DIALOG::SetDataFields( void )
{
    ULONG ulMaxAge = _umInfo.QueryMaxPasswdAge();
    ASSERT( ulMaxAge >= SEC_PER_DAY ); // API requires this to be at least ONE_DAY
    if( TIMEQ_FOREVER != ulMaxAge )
    {
        // ul divided by 86400L results 16-bit value
        _spsleSetMaxAge.SetValue( (USHORT) (ulMaxAge / SEC_PER_DAY) );
        _spsleSetMaxAge.Update();

        _spsleSetMaxAge.SetValue( (USHORT) (ulMaxAge / SEC_PER_DAY) );
        _spsleSetMaxAge.Update();
    }
    _pmgrpMaxPassAge->SetSelection( (TIMEQ_FOREVER == ulMaxAge)
                                        ? RB_MAX_PASSW_AGE_NEVER_EXPIRES
                                        : RB_MAX_PASSW_AGE_SET_DAYS );


    UINT uMinLen = _umInfo.QueryMinPasswdLen();
    UIASSERT( ((INT)uMinLen) >= 0 );
    if( 0 != uMinLen )
    {
        _spsleSetLength.SetValue( (LONG)uMinLen );
        _spsleSetLength.Update();

        _spsleSetLength.SetValue( (LONG)uMinLen );
        _spsleSetLength.Update();
    }
    _pmgrpMinPassLength->SetSelection( (0 == uMinLen)
                                        ? RB_PASSW_LENGTH_PERMIT_BLANK
                                        : RB_PASSW_LENGTH_SET_LEN );

    if (_pumadminapp->QueryTargetServerType() == UM_LANMANNT)
    {
        ULONG ulDelay = _umInfo.QueryForceLogoff();
        _pcbForceLogoff->SetCheck( ulDelay != TIMEQ_FOREVER );
    }

    if (_pumadminapp->QueryTargetServerType() == UM_DOWNLEVEL)
    {
        _pcbAllowNoAnonChange->SetCheck( FALSE );
    }
    else
    {
        _pcbAllowNoAnonChange->SetCheck( _fAllowNoAnonChange );
    }

    {
        ULONG ulMinAge = _umInfo.QueryMinPasswdAge();
        if( 0L != ulMinAge )
        {
            _spsleSetMinAge.SetValue( (ulMinAge / SEC_PER_DAY) );
            _spsleSetMinAge.Update();

            _spsleSetMinAge.SetValue( (ulMinAge / SEC_PER_DAY) );
            _spsleSetMinAge.Update();
        }
        _pmgrpMinPassAge->SetSelection( (0L == ulMinAge)
                                                ? RB_MIN_PASSW_AGE_ALLOW_IMMEDIA
                                                : RB_MIN_PASSW_AGE_SET_DAYS );
    }

    {
        UINT uHistLen = _umInfo.QueryPasswdHistLen();
	UIASSERT( ((INT)uHistLen) >= 0 );
        if( 0 != uHistLen )
        {
            _spsleSetAmount.SetValue( uHistLen );
            _spsleSetAmount.Update();

            _spsleSetAmount.SetValue( uHistLen );
            _spsleSetAmount.Update();
        }
        _pmgrpPassUniqueness->SetSelection( (0 == uHistLen)
                                                ? RB_PASSW_UNIQUE_NOT_HISTORY
                                                : RB_PASSW_UNIQUE_SET_AMOUNT );
    }

} //SECSET_DIALOG::SetDataFields()


/*******************************************************************

    NAME:       SECSET_DIALOG::GetAndCheckDataFields

    SYNOPSIS:   Gets data from dialog and sets _umInfo

    RETURNS:    NERR_Success on success
                IERR_SECSET_MIN_MAX if MinPasswdAge > MaxPasswdAge

    HISTORY:
               Simo  24-June-1991    created

********************************************************************/

APIERR SECSET_DIALOG::GetAndCheckDataFields( void )
{
    ULONG ulMaxAge;

    // get max passwd age
    switch( _pmgrpMaxPassAge->QuerySelection() )
    {
    case RB_MAX_PASSW_AGE_SET_DAYS:
        ulMaxAge =_spsleSetMaxAge.QueryValue() * SEC_PER_DAY;
        break;
    default:
        DBGEOL( "MaxPassAge, default: should never happen" );
        ASSERT( FALSE );
        // just fall through
    case RB_MAX_PASSW_AGE_NEVER_EXPIRES:
        ulMaxAge = TIMEQ_FOREVER;
        break;
    }

    // get min passwd age
    {
        ULONG ulMinAge;
        switch( _pmgrpMinPassAge->QuerySelection() )
        {
        case RB_MIN_PASSW_AGE_SET_DAYS:
            ulMinAge = _spsleSetMinAge.QueryValue() * SEC_PER_DAY;
            break;
        default:
            DBGEOL( "MinPassAge, default: should never happen" );
            ASSERT( FALSE );
            // just fall through
        case RB_MIN_PASSW_AGE_ALLOW_IMMEDIA:
            ulMinAge = 0L;
            break;
        }


        if( ulMaxAge != TIMEQ_FOREVER &&
            ulMaxAge <= ulMinAge )
        {
            TRACEEOL( "SECSET_DIALOG::GetAndCheckDataFields MinAge > MaxAge" );
            return IERR_SECSET_MIN_MAX;
        }

        // set em
        REQUIRE( _umInfo.SetMaxPasswdAge( ulMaxAge ) == NERR_Success );
        REQUIRE( _umInfo.SetMinPasswdAge( ulMinAge ) == NERR_Success );
    }

    // get and set logoff delay
    if (_pumadminapp->QueryTargetServerType() == UM_LANMANNT)
    {
        // CODEWORK -- If the delay is currently neither 0 nor TIMEQ_FOREVER,
        // do we wish to force it to 0 if the user does not edit this field?
        ULONG ulDelay = (_pcbForceLogoff->QueryCheck()) ? 0
                                                     : TIMEQ_FOREVER;
        REQUIRE( _umInfo.SetForceLogoff( ulDelay ) == NERR_Success );
    }

    // get and set anon change
    if (_pumadminapp->QueryTargetServerType() != UM_DOWNLEVEL)
    {
        _fAllowNoAnonChange = _pcbAllowNoAnonChange->QueryCheck();
    }

    // get and set minimum passwd length
    {
        LONG lMinLen;

        switch( _pmgrpMinPassLength->QuerySelection() )
        {
        case RB_PASSW_LENGTH_SET_LEN:
            lMinLen = _spsleSetLength.QueryValue();
            break;
        default:
            DBGEOL( "MinLen, default: should never happen" );
            ASSERT( FALSE );
            // just fall through
        case RB_PASSW_LENGTH_PERMIT_BLANK:
            lMinLen = 0;
            break;
        }
        REQUIRE( _umInfo.SetMinPasswdLen( lMinLen ) == NERR_Success );
    }

    // get and set passwd history length
    {
        LONG lUniqueness;
        switch( _pmgrpPassUniqueness->QuerySelection() )
        {
        case RB_PASSW_UNIQUE_SET_AMOUNT:
            lUniqueness = _spsleSetAmount.QueryValue();
            break;
        default:
            DBGEOL( "Uniqueness, default: should never happen" );
            ASSERT( FALSE );
            // just fall through
        case RB_PASSW_UNIQUE_NOT_HISTORY:
            lUniqueness = 0;
            break;
        }
        REQUIRE( _umInfo.SetPasswdHistLen( lUniqueness ) == NERR_Success );
    }

    return NERR_Success;
} // SECSET_DIALOG::GetAndCheckDataFields()


/*******************************************************************

    NAME:       SECSET_DIALOG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
                o-simop 11-Jul-1991 Created.

********************************************************************/
ULONG SECSET_DIALOG::QueryHelpContext( void )
{
    return HC_UM_POLICY_ACCOUNT_LANNT
	+ _pumadminapp->QueryHelpOffset();

} // SECSET_DIALOG :: QueryHelpContext




#define THRESHOLD_DEFAULT    5
#define THRESHOLD_MIN        1
#define THRESHOLD_MAX        999

#define OBSERV_WIN_DEFAULT   5
#define OBSERV_WIN_MIN       1
#define OBSERV_WIN_MAX       99999

#define DURATION_DEFAULT     60
#define DURATION_MIN         1
#define DURATION_MAX         99999
#define DURATION_FOREVER     0xFFFFFFFF

#define SECS_PER_MIN         60


/*******************************************************************

    NAME:   SECSET_DIALOG_LOCKOUT::SECSET_DIALOG_LOCKOUT

    SYNOPSIS:   Constructor for Security Settings dialog with lockout

    ENTRY:  wndParent       - handle to parent window
	    locFocusName    - LOCATION reference, holds
                              domain/server name
            pszSecurityId   - pointer to SID

    HISTORY:
    JonN        23-Dec-1993     Created

********************************************************************/

SECSET_DIALOG_LOCKOUT::SECSET_DIALOG_LOCKOUT( UM_ADMIN_APP * pumadminapp,
    const LOCATION  & locFocusName,
    USER_MODALS_3 & uminfo3 )
    :   SECSET_DIALOG( pumadminapp,
                       locFocusName,
                       IDD_SECSET_LOCKOUT ),
    _uminfo3( uminfo3 ),

    _pmgrpLockoutEnabled( NULL ),

        _spsleThreshold( this, SLE_LOCKOUT_THRESHOLD,
            THRESHOLD_DEFAULT, THRESHOLD_MIN, THRESHOLD_MAX, TRUE,
            FRAME_LOCKOUT_THRESHOLD ),
        _spgrpThreshold( this, SB_LOCKOUT_THRESHOLD_GRP,
            SB_LOCKOUT_THRESHOLD_UP, SB_LOCKOUT_THRESHOLD_DOWN ),

        _spsleObservWnd( this, SLE_LOCKOUT_OBSERV_WND,
            OBSERV_WIN_DEFAULT, OBSERV_WIN_MIN, OBSERV_WIN_MAX, TRUE,
            FRAME_LOCKOUT_OBSERV_WND ),
        _spgrpObservWnd( this, SB_LOCKOUT_OBSERV_WND_GRP,
            SB_LOCKOUT_OBSERV_WND_UP, SB_LOCKOUT_OBSERV_WND_DOWN ),

        _pmgrpDuration( NULL ),
            _spsleDuration( this, SLE_LOCKOUT_DURATION_SECS,
                DURATION_DEFAULT, DURATION_MIN, DURATION_MAX, TRUE,
                FRAME_LOCKOUT_DURATION_SECS ),
            _spgrpDuration( this, SB_LOCKOUT_DURATION_SECS_GRP,
                SB_LOCKOUT_DURATION_SECS_UP, SB_LOCKOUT_DURATION_SECS_DOWN )

{
    APIERR err = QueryError();
    if( NERR_Success != err )
    {
        return;
    }

    _pmgrpLockoutEnabled = new MAGIC_GROUP(
		    this, RB_LOCKOUT_DISABLED,
                    2, RB_LOCKOUT_DISABLED );
    _pmgrpDuration = new MAGIC_GROUP(
		    this, RB_LOCKOUT_DURATION_FOREVER,
                    2, RB_LOCKOUT_DURATION_FOREVER ); // FOREVER is default
    if( (_pmgrpLockoutEnabled == NULL)		||
        (_pmgrpDuration == NULL) )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if( (err = _pmgrpLockoutEnabled->QueryError())    ||
        (err = _pmgrpDuration->QueryError()) )
    {
        ReportError( err );
        return;
    }


    AUTO_CURSOR autocur;

    // no need to call _uminfo3.GetInfo, that has already been done
    // CODEWORK is 1 the correct value here?

    _spsleThreshold.SetBigIncValue( 1 );
    _spsleObservWnd.SetBigIncValue( 10 );
    _spsleDuration.SetBigIncValue(  10 );

    if( (err = _spgrpThreshold.AddAssociation( &_spsleThreshold )) ||
        (err = _spgrpObservWnd.AddAssociation( &_spsleObservWnd )) ||
        (err = _spgrpDuration.AddAssociation( &_spsleDuration )) )
    {
        ReportError( err );
        return;
    }

    if ( (err = _pmgrpLockoutEnabled->AddAssociation(
             RB_LOCKOUT_ENABLED, &_spgrpThreshold ))  ||
         (err = _pmgrpLockoutEnabled->AddAssociation(
             RB_LOCKOUT_ENABLED, &_spgrpObservWnd ))  ||
         (err = _pmgrpLockoutEnabled->AddAssociation(
             RB_LOCKOUT_ENABLED, _pmgrpDuration ))  ||
         (err = _pmgrpDuration->AddAssociation(
             RB_LOCKOUT_DURATION_SECS, &_spgrpDuration )) )
    {
        ReportError( err );
        return ;
    }

    // We must repeat this call here, otherwise the lockout fields
    // will not be set from call in the the parent ctor
    SetDataFields();

}// SECSET_DIALOG_LOCKOUT::SECSET_DIALOG_LOCKOUT


/*******************************************************************

    NAME:       SECSET_DIALOG_LOCKOUT::~SECSET_DIALOG_LOCKOUT

    SYNOPSIS:   Destructor for Security Settings dialog with lockout

    HISTORY:
    JonN        23-Dec-1993     Created

********************************************************************/

SECSET_DIALOG_LOCKOUT::~SECSET_DIALOG_LOCKOUT( void )
{
    delete _pmgrpLockoutEnabled;
    delete _pmgrpDuration;
}


/*******************************************************************

    NAME:       SECSET_DIALOG_LOCKOUT::WriteDataFields

    SYNOPSIS:   Writes information in data fields, part of OK button handler

    EXIT:       calls USER_MODALS_3::WriteInfo

    HISTORY:
               jonn  28-Dec-1993    created

********************************************************************/

APIERR SECSET_DIALOG_LOCKOUT::WriteDataFields( void )
{

    APIERR err = _uminfo3.WriteInfo();
    if (err != NERR_Success)
    {
        DBGEOL( "SECSET_DIALOG_LOCKOUT::WriteDataFields WriteInfo error "
             << err ) ;
        return err;
    }

    return SECSET_DIALOG::WriteDataFields();

}   // SECSET_DIALOG_LOCKOUT::WriteDataFields


/*******************************************************************

    NAME:       SECSET_DIALOG_LOCKOUT::SetDataFields

    SYNOPSIS:   Fills SPIN fields, the default values are given
                in the constructor of SECSET_DIALOG_LOCKOUT

    ENTRY:      It is assumed that magic groups have
                not been AddAssociate'd

    HISTORY:
    JonN        23-Dec-1993     Created

********************************************************************/

void SECSET_DIALOG_LOCKOUT::SetDataFields( void )
{
    DWORD dwThreshold = _uminfo3.QueryThreshold();
    DWORD dwObservWnd = _uminfo3.QueryObservation();
    DWORD dwDuration  = _uminfo3.QueryDuration();
    BOOL fLockoutEnabled = TRUE;

    TRACEEOL( "SetDataFields: Threshold = " << dwThreshold );
    TRACEEOL( "SetDataFields: ObservWnd = " << dwObservWnd );
    TRACEEOL( "SetDataFields: Duration  = " << dwDuration );
    if (   0L == dwThreshold
        || 0L == dwObservWnd
        || 0L == dwDuration
       )
    {
        fLockoutEnabled = FALSE;
        dwThreshold = THRESHOLD_DEFAULT;
        if (0L == dwObservWnd)
            dwObservWnd = OBSERV_WIN_DEFAULT * SECS_PER_MIN;
        if (0L == dwDuration)
            dwDuration = DURATION_DEFAULT * SECS_PER_MIN;
    }

    if (dwThreshold > THRESHOLD_MAX)
        dwThreshold = THRESHOLD_MAX;

    // convert to minutes

    if (dwObservWnd > OBSERV_WIN_MAX * SECS_PER_MIN)
        dwObservWnd = OBSERV_WIN_MAX;
    else if (dwObservWnd > 0)
        dwObservWnd = (dwObservWnd + SECS_PER_MIN - 1) / SECS_PER_MIN;

    if (dwDuration > DURATION_MAX * SECS_PER_MIN)
        dwDuration = DURATION_FOREVER;
    else if (dwDuration > 0)
        dwDuration = (dwDuration + SECS_PER_MIN - 1) / SECS_PER_MIN;

// reversing order moves effect to new first item
// repeating action as test works around bug, don't know why

    _spsleThreshold.SetValue( dwThreshold );
    _spsleThreshold.Update();

    _spsleThreshold.SetValue( dwThreshold );
    _spsleThreshold.Update();

    _spsleObservWnd.SetValue( dwObservWnd );
    _spsleObservWnd.Update();

// must do _pmgrpDuration->SetSelection() after _spsleDuration.SetValue()

    BOOL fForever = ( dwDuration == DURATION_FOREVER );

    if ( fForever )
    {
        dwDuration = DURATION_DEFAULT;
    }

// repeating action as test works around bug, don't know why

    _spsleDuration.SetValue( dwDuration );
    _spsleDuration.Update();

    _spsleDuration.SetValue( dwDuration );
    _spsleDuration.Update();

    _pmgrpDuration->SetSelection( (fForever) ? RB_LOCKOUT_DURATION_FOREVER
                                             : RB_LOCKOUT_DURATION_SECS );

    _pmgrpLockoutEnabled->SetSelection( (fLockoutEnabled) ? RB_LOCKOUT_ENABLED
                                                          : RB_LOCKOUT_DISABLED );

    SECSET_DIALOG::SetDataFields();

} //SECSET_DIALOG_LOCKOUT::SetDataFields()


/*******************************************************************

    NAME:       SECSET_DIALOG_LOCKOUT::GetAndCheckDataFields

    SYNOPSIS:   Gets data from dialog and sets _umInfo

    RETURNS:    NERR_Success on success
                IERR_SECSET_MIN_MAX if MinPasswdAge > MaxPasswdAge

    HISTORY:
    JonN        23-Dec-1993     Created

********************************************************************/

APIERR SECSET_DIALOG_LOCKOUT::GetAndCheckDataFields( void )
{
    DWORD dwDuration = 0L;
    DWORD dwObservWnd = 0L;
    DWORD dwThreshold = 0L;

    // get values and convert to seconds
    switch( _pmgrpLockoutEnabled->QuerySelection() )
    {

    case RB_LOCKOUT_ENABLED:
        dwThreshold = _spsleThreshold.QueryValue();
        dwObservWnd = _spsleObservWnd.QueryValue() * SECS_PER_MIN;
        switch ( _pmgrpDuration->QuerySelection() )
        {
        case RB_LOCKOUT_DURATION_SECS:
            dwDuration = _spsleDuration.QueryValue() * SECS_PER_MIN;
            if (dwDuration < dwObservWnd) {
                TRACEEOL( "SECSET_DIALOG_LOCKOUT::GetAndCheckDataFields Duration < Observ" );
                return IERR_SECSET_DURATION_LT_OBSRV;
            }
            break;
        default:
            DBGEOL( "Duration, default: should never happen" );
            ASSERT( FALSE );
            // just fall through
        case RB_LOCKOUT_DURATION_FOREVER:
            dwDuration = DURATION_FOREVER;
            break;
        }

        // set em
        REQUIRE( _uminfo3.SetDuration(    dwDuration  ) == NERR_Success );
        REQUIRE( _uminfo3.SetObservation( dwObservWnd ) == NERR_Success );

        break;

    default:
        DBGEOL( "LockoutEnabled, default: should never happen" );
        ASSERT( FALSE );
        // just fall through

    case RB_LOCKOUT_DISABLED:
        break;

    }

    // set em
    REQUIRE( _uminfo3.SetThreshold(   dwThreshold ) == NERR_Success );

    return SECSET_DIALOG::GetAndCheckDataFields();

} // SECSET_DIALOG_LOCKOUT::GetAndCheckDataFields()


/*******************************************************************

    NAME:       SECSET_DIALOG_LOCKOUT::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
    JonN        23-Dec-1993     Created

********************************************************************/
ULONG SECSET_DIALOG_LOCKOUT::QueryHelpContext( void )
{
    return HC_UM_POLICY_LOCKOUT_LANNT
	+ _pumadminapp->QueryHelpOffset();

} // SECSET_DIALOG_LOCKOUT :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\slenum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
 *   slenum.cxx
 *   implements the SLE_NUM class
 *   FILE HISTORY:
 *       CongpaY         6-March-1995    Created.
*/

#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#include <slenum.hxx>

/*******************************************************************

    NAME:       SLE_NUM :: SLE_NUM

    SYNOPSIS:   SLE_NUM class constructor.

    ENTRY:

    EXIT:       The object is constructed.

    HISTORY:
            CongpaY         6-March-1995    Created.

********************************************************************/
SLE_NUM :: SLE_NUM( OWNER_WINDOW *     powner,
                    CID cid, UINT cchMaxLen)
  : SLE (powner, cid, cchMaxLen),
    CUSTOM_CONTROL (this)
{
}

SLE_NUM :: ~SLE_NUM ()
{
}

BOOL SLE_NUM :: OnChar (const CHAR_EVENT & event)
{
    TCHAR chKey = event.QueryChar();
    if ((!isdigit(chKey)) &&
        (chKey != VK_BACK) &&
        (chKey != VK_DELETE) &&
        (chKey != VK_END) &&
        (chKey != VK_HOME) )
    {
        ::MessageBeep (0);
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\rename.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT  		     **/
/**          Copyright(c) Microsoft Corp., 1992                      **/
/**********************************************************************/

/*
    rename.cxx


    FILE HISTORY:
    Thomaspa	20-Jan-1992	Created
*/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_ICANON
#define INCL_NETUSER
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif


#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#define INCL_BLT_APP
#include <blt.hxx>

extern "C"
{
    #include <usrmgrrc.h>
    #include <mnet.h>
    #include <ntlsa.h>
    #include <ntsam.h>
    #include <umhelpc.h>
}

#include <string.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <usrmain.hxx>
#include <rename.hxx>



//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:	RENAME_DIALOG::RENAME_DIALOG

    SYNOPSIS:   Constructor for base rename dialog

    ENTRY:	wndParent
		pszCurrentName - current name of account
		cchMaxName - maximum length of account
		nNameType - NAMETYPE of account

    HISTORY:
	thomaspa	20-Jan-1992	Created
********************************************************************/

RENAME_DIALOG::RENAME_DIALOG(
	UM_ADMIN_APP * pumadminapp,
	const TCHAR * pszCurrentName,
	UINT cchMaxName,
	INT nNameType
	)
    :	DIALOG_WINDOW( IDD_RENAMEUSER, ((OWNER_WINDOW *)pumadminapp)->QueryHwnd()),
    _pszCurrentName(pszCurrentName),
    // CODEWORK Rename User constants hard-coded into RENAME_DIALOG
    _pumadminapp(  pumadminapp ),
    _sleNewName( this, IDUP_ET_RENAMEUSER, cchMaxName, nNameType ),
    _sltOldName( this, IDUP_ST_RENAMEOLD )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    _sltOldName.SetText( _pszCurrentName );

}// RENAME_DIALOG::RENAME_DIALOG


/*******************************************************************

    NAME:	RENAME_DIALOG::~RENAME_DIALOG

    SYNOPSIS:   Destructor for base rename dialog

    HISTORY:
	thomaspa	20-Jan-1992	Created
********************************************************************/
RENAME_DIALOG::~RENAME_DIALOG()
{
	// nothing to do

}// RENAME_DIALOG::~RENAME_DIALOG



/*******************************************************************

    NAME:	RENAME_USER_DIALOG::RENAME_USER_DIALOG

    SYNOPSIS:   Constructor for rename user dialog

    ENTRY:	wndParent
                psamdomainAccount
		pszCurrentName - current name of user account
                ulRid


    HISTORY:
	thomaspa	22-Jan-1992	Created
********************************************************************/

RENAME_USER_DIALOG::RENAME_USER_DIALOG(
	UM_ADMIN_APP * pumadminapp,
        const SAM_DOMAIN * psamdomainAccount,
	const TCHAR * pszCurrentName,
        ULONG ulRID,
        NLS_STR * pnlsNewName
	)
	: RENAME_DIALOG( pumadminapp, pszCurrentName, LM20_UNLEN, NAMETYPE_USER ),
        _psamuser( NULL ),
        _pnlsNewName( pnlsNewName )
{
    UIASSERT( psamdomainAccount != NULL );
    UIASSERT( psamdomainAccount->QueryError() == NERR_Success );
    UIASSERT( _pnlsNewName != NULL );
    // _pnlsNewName may have an error but this causes immediate return

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

// Check whether the user has rename permission.  If not, do not allow
// editing.
    err = ERROR_NOT_ENOUGH_MEMORY;
    _psamuser = new SAM_USER(
                      *psamdomainAccount,
                      ulRID,
                      USER_WRITE_ACCOUNT );
    if (   _psamuser == NULL
        || (err = _psamuser->QueryError()) != NERR_Success
        || (err = _pnlsNewName->QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

}// RENAME_USER_DIALOG::RENAME_USER_DIALOG




/*******************************************************************

    NAME:	RENAME_USER_DIALOG::~RENAME_USER_DIALOG

    SYNOPSIS:   Destructor for rename user dialog

    HISTORY:
	thomaspa	22-Jan-1992	Created
********************************************************************/
RENAME_USER_DIALOG::~RENAME_USER_DIALOG()
{
    delete _psamuser;

}// RENAME_USER_DIALOG::~RENAME_USER_DIALOG




/*******************************************************************

    NAME:	RENAME_USER_DIALOG::OnOK()

    SYNOPSIS:
	Renames the user account

    RETURNS:
	TRUE always

    HISTORY:
	thomaspa	22-Jan-1992	Created
********************************************************************/
BOOL RENAME_USER_DIALOG::OnOK()
{
    APIERR err = NERR_Success;

    if (   (err = _sleNewName.QueryText( _pnlsNewName ))
	    || (err = _pnlsNewName->QueryError()) )
    {
        MsgPopup( this, err );
        return TRUE;
    }

#ifdef NOT_ALLOW_DBCS_USERNAME
    // #3255 6-Nov-93 v-katsuy
    // check contains DBCS for User name
    if ( NETUI_IsDBCS() )
    {
        CHAR  ansiNewName[LM20_UNLEN * 2 + 1];
        _pnlsNewName->MapCopyTo( (CHAR *)ansiNewName, LM20_UNLEN * 2 + 1);
        if ( ::lstrlenA( ansiNewName ) != _pnlsNewName->QueryTextLength() )
        {
    	    MsgPopup( this, NERR_BadUsername );
            _sleNewName.ClaimFocus();
            return TRUE;
        }
    }
#endif

    if ( (err = _psamuser->SetUsername( _pnlsNewName )) )
    {
        MsgPopup( this, err );
        return TRUE;
    }

    Dismiss( TRUE );
    return TRUE;
}


/*******************************************************************

    NAME:	RENAME_USER_DIALOG::QueryHelpContext()

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to rename a User.

    HISTORY:
	thomaspa	22-Jan-1992	Created
********************************************************************/
ULONG RENAME_USER_DIALOG::QueryHelpContext()
{
    return HC_UM_RENAME_USER_LANNT + _pumadminapp->QueryHelpOffset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\setsel.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    setsel.cxx
    SET_SELECTION_DIALOG class implementation


    FILE HISTORY:
        rustanl     16-Aug-1991     Created
        jonn        10-Oct-1991     LMOENUM update
        jonn        02-Apr-1992     Load by ordinal only

*/

#include <ntincl.hxx>

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SPIN
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

extern "C"
{
    #include <lmaccess.h>
    #include <ntlsa.h>
    #include <ntsam.h>
    #include <umhelpc.h>
}
#include <lmoeusr.hxx>

#include <usrmgrrc.h>

#include <usrlb.hxx>
#include <grplb.hxx>
#include <usrcolw.hxx>
#include <usrmain.hxx>

#include <setsel.hxx>
#include <uintlsa.hxx>
#include <uintsam.hxx>
#include <bmpblock.hxx>


/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LBI::SETSEL_PIGGYBACK_LBI

    SYNOPSIS:   SETSEL_PIGGYBACK_LBI constructor

    ENTRY:      asel -          ADMIN_SELECTION
                i -             indes into ADMIN_SELECTION

    HISTORY:
        thomaspa     30-May-1992     Created

********************************************************************/
SETSEL_PIGGYBACK_LBI::SETSEL_PIGGYBACK_LBI( const ADMIN_SELECTION & asel,
                                            INT i )
   : PIGGYBACK_LBI( asel, i )
{
    if ( QueryError( ) )
        return;
}

/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LBI::~SETSEL_PIGGYBACK_LBI

    SYNOPSIS:   SETSEL_PIGGYBACK_LBI destructor

    ENTRY:

    HISTORY:
        thomaspa     30-May-1992     Created

********************************************************************/
SETSEL_PIGGYBACK_LBI::~SETSEL_PIGGYBACK_LBI( )
{
}


/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LBI::Paint

    SYNOPSIS:   Paints the LBI

    ENTRY:      plb -           Pointer to listbox where LBI is
                hdc -           Handle to device context to be used
                                for drawing
                prect -         Pointer to rectangle in which to draw
                pGUILTT -       Pointer to GUILTT information

    HISTORY:
        thomaspa    02-May-1992 Created

********************************************************************/

VOID SETSEL_PIGGYBACK_LBI::Paint( LISTBOX * plb, HDC hdc, const RECT * prect,
                           GUILTT_INFO * pGUILTT ) const
{

    enum MAINGRPLB_GRP_INDEX nIndex
                = ((GROUP_LBI *)QueryRealLBI())->QueryIndex();
    DM_DTE * pdmdte = ((SETSEL_PIGGYBACK_LISTBOX *)plb)->QueryDmDte( nIndex );

    UINT adxColWidths[ 2 ];
    adxColWidths[ 0 ] = COL_WIDTH_WIDE_DM;      // this is in bltcons.h
    adxColWidths[ 1 ] = COL_WIDTH_GROUP_NAME;   // this is in usrcolw.hxx

    STR_DTE strdte( QueryName() );

    DISPLAY_TABLE dtab( 2, adxColWidths );
    dtab[ 0 ] = pdmdte;
    dtab[ 1 ] = &strdte;

    dtab.Paint( plb, hdc, prect, pGUILTT );
}


/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LISTBOX::SETSEL_PIGGYBACK_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin
                cit
                asel

    HISTORY:
        thomaspa    02-May-1992 Created

********************************************************************/

SETSEL_PIGGYBACK_LISTBOX::SETSEL_PIGGYBACK_LISTBOX(
                                OWNER_WINDOW * powin,
                                const SUBJECT_BITMAP_BLOCK & bmpblock,
                                CID cid,
                                const ADMIN_SELECTION & asel )
    : PIGGYBACK_LISTBOX( powin, cid, asel ),
      _bmpblock( bmpblock )
{
    ASSERT( bmpblock.QueryError() == NERR_Success );

    if( QueryError() )
        return;
}

/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LISTBOX::~SETSEL_PIGGYBACK_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    HISTORY:
        thomaspa    02-May-1992 Created

********************************************************************/

SETSEL_PIGGYBACK_LISTBOX::~SETSEL_PIGGYBACK_LISTBOX()
{
    // nothing to do here
}

/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LISTBOX::QueryDmDte

    SYNOPSIS:   Return a pointer to the display map DTE to be
                used by LBI's in this listbox

    RETURNS:    Pointer to said display map DTE

    HISTORY:
        thomaspa     5-May-1992     Created

********************************************************************/

DM_DTE * SETSEL_PIGGYBACK_LISTBOX::QueryDmDte( enum MAINGRPLB_GRP_INDEX nIndex )
{
    SID_NAME_USE sidtype = SidTypeUnknown;

    switch (nIndex)
    {
        case MAINGRPLB_GROUP:
            sidtype = SidTypeGroup;
            break;

        case MAINGRPLB_ALIAS:
            sidtype = SidTypeAlias;
            break;

        default:
            DBGEOL( "GROUP_LISTBOX::QueryDmDte: bad nIndex " << (INT)nIndex );
            break;
    }

    return ((SUBJECT_BITMAP_BLOCK &)_bmpblock).QueryDmDte( sidtype );

}  // SETSEL_PIGGYBACK_LISTBOX::QueryDmDte


/*******************************************************************

    NAME:       SETSEL_PIGGYBACK_LISTBOX::GetPiggyLBI

    SYNOPSIS:   Creates and returns a SETSEL_PIGGYBACK_LBI

    ENTRY:

    HISTORY:
        thomaspa    02-May-1992 Created

********************************************************************/
PIGGYBACK_LBI * SETSEL_PIGGYBACK_LISTBOX::GetPiggyLBI(
                                        const ADMIN_SELECTION & asel,
                                        INT i )
{
    return new SETSEL_PIGGYBACK_LBI( asel, i );
}




/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::SET_SELECTION_DIALOG

    SYNOPSIS:   SET_SELECTION_DIALOG constructor

    ENTRY:      powin -         Pointer to owner window
                loc -           Location from which to get network info
                pulb -          Pointer to LAZY_USER_LISTBOX in which to
                                select items
                pglb -          Pointer to GROUP_LISTBOX which contains
                                groups to select among

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

SET_SELECTION_DIALOG::SET_SELECTION_DIALOG( UM_ADMIN_APP * pumadminapp,
                                            const LOCATION & loc,
                                            const ADMIN_AUTHORITY * padminauth,
                                            LAZY_USER_LISTBOX * pulb,
                                            GROUP_LISTBOX * pglb )
    :   DIALOG_WINDOW( MAKEINTRESOURCE(IDD_SETSEL_DLG), ((OWNER_WINDOW *)pumadminapp)->QueryHwnd()),
        _ploc( &loc ),
        _padminauth( padminauth ),
        _pumadminapp( pumadminapp ),
        _pulb( pulb ),
        _pglb( pglb ),
        _aselGroup( *_pglb, TRUE ),
        //  Note, on the following line, _aselGroup is passed as a parameter
        //  even though it may not have constructed properly.  The
        //  PIGGYBACK_LISTBOX must check for aselGroup's proper construction,
        //  but should not assert it.
        _piggybacklb( this,
                      pumadminapp->QueryBitmapBlock(),
                      IDC_SETSEL_GROUP_LB,
                      _aselGroup ),
        _butCancel( this, IDCANCEL ),
        _fChangedSelection( FALSE )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pulb != NULL );
    UIASSERT( _pglb != NULL );
    UIASSERT( _ploc->QueryError() == NERR_Success );

    APIERR err;
    if ( ( err = _aselGroup.QueryError()) != NERR_Success ||
         ( err = _nlsClose.QueryError()) != NERR_Success  ||
         ( err = _nlsClose.Load( IDS_SETSEL_CLOSE_BUTTON ))
                                         != NERR_Success  ||
         ( err = _piggybacklb.Fill( _aselGroup ) ) != NERR_Success )
    {
        ReportError( err );
        return;
    }


    //  The _aselGroup ADMIN_SELECTION should have been non-empty, so
    //  the listbox should have items in it.  (The caller may have
    //  to restrict this.)
    UIASSERT( _aselGroup.QueryCount() > 0 );
    UIASSERT( _piggybacklb.QueryCount() > 0 );

    //  Select the first listbox item.  This way, there will always
    //  be some selected item in this listbox.
    _piggybacklb.SelectItem( 0 );

}  // SET_SELECTION_DIALOG::SET_SELECTION_DIALOG


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::~SET_SELECTION_DIALOG

    SYNOPSIS:   SET_SELECTION_DIALOG destructor

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

SET_SELECTION_DIALOG::~SET_SELECTION_DIALOG()
{
    // do no more

}  // SET_SELECTION_DIALOG::~SET_SELECTION_DIALOG


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::OnCancel

    SYNOPSIS:   Handles action takes when the Cancel button is pressed.
                This action is to dismiss the dialog with the appropriate
                return code.

    EXIT:       Dialog is dismissed

    RETURNS:    TRUE to indicate that message was handled

    NOTES:      Note, this dialog does not have an OK button

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

BOOL SET_SELECTION_DIALOG::OnCancel()
{
    Dismiss( _fChangedSelection );
    return TRUE;

}  // SET_SELECTION_DIALOG::OnCancel


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::QueryHelpContext

    SYNOPSIS:   Returns the dialog help context

    RETURNS:    The said help context

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

ULONG SET_SELECTION_DIALOG::QueryHelpContext()
{
    return HC_UM_SELECT_USERS_LANNT + _pumadminapp->QueryHelpOffset();

}  // SET_SELECTION_DIALOG::QueryHelpContext


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::OnCommand

    SYNOPSIS:   Checks control notifications and dispatches to
                appropriate method

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

BOOL SET_SELECTION_DIALOG::OnCommand( const CONTROL_EVENT & ce )
{
    switch ( ce.QueryCid() )
    {
    case IDC_SETSEL_SELECT:
    case IDC_SETSEL_DESELECT:
        OnSelectButton( ce.QueryCid() == IDC_SETSEL_SELECT );
        return TRUE;

    default:
        break;
    }

    return DIALOG_WINDOW::OnCommand( ce ) ;

}  // SET_SELECTION_DIALOG::OnCommand


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::OnSelectButton

    SYNOPSIS:   Called when the Select and Deselect button is
                pressed.  Calls SelectItems to select the
                requested items.

    ENTRY:      fSelect -   Specifies whether to select or deselect
                            items, a parameter computed based on
                            which button was pressed.

                            TRUE indicates select items
                            FALSE indicates deselect items

    HISTORY:
        rustanl     16-Aug-1991     Created
        thomaspa    30-Apr-1992     Added support for aliases

********************************************************************/

VOID SET_SELECTION_DIALOG::OnSelectButton( BOOL fSelect )
{
    SETSEL_PIGGYBACK_LBI * ppiggybacklbi = _piggybacklb.QueryItem();

    //  Constructor made sure that some item will always be selected
    //  in this listbox.
    UIASSERT( ppiggybacklbi != NULL );

    APIERR err;
    if ( ((GROUP_LBI*)ppiggybacklbi->QueryRealLBI())->IsAliasLBI())
    {
        err = SelectItemsAlias(
                ((ALIAS_LBI*)ppiggybacklbi->QueryRealLBI())->QueryRID(),
                ((ALIAS_LBI*)ppiggybacklbi->QueryRealLBI())->IsBuiltinAlias(),
                                fSelect );
    }
    else
    {
        err = SelectItems( ppiggybacklbi->QueryName(), fSelect );
    }
    if ( err != NERR_Success )
    {
        MsgPopup( this, err );
        return;
    }

}  // SET_SELECTION_DIALOG::OnSelectButton


/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::SelectItems

    SYNOPSIS:   Selects all user accounts that are members of
                group pszGroup

    ENTRY:      pszGroup -      Group name, whose members are to be
                                selected or deselected
                fSelect -       Indicates whether to select or deselect
                                the specified users.
                                TRUE indicates to select the users
                                FALSE indicates to deselect the users

    EXIT:       The requested items are selected.  If an error occurs,
                some subset of the specified items may have been
                selected.

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     16-Aug-1991     Created

********************************************************************/

APIERR SET_SELECTION_DIALOG::SelectItems( const TCHAR * pszGroup,
                                          BOOL fSelect )
{
    UIASSERT( pszGroup != NULL );

    AUTO_CURSOR autocur;

    USER0_ENUM ue0( *_ploc, pszGroup );
    APIERR err = ue0.GetInfo();
    if ( err != NERR_Success )
        return err;

    USER0_ENUM_ITER uei0( ue0 );
    const USER0_ENUM_OBJ * pui0;
    INT culbiSelected = 0;

    _pulb->SetRedraw( FALSE );

    while ( ( pui0 = uei0( &err )) != NULL )
    {
        if ( err != NERR_Success )
            return err;

        if ( _pulb->SelectUser( pui0->QueryName(), fSelect ) )
        {
            if ( culbiSelected++ == 0 )
                _pglb->RemoveSelection();
        }
        else
        {
            TRACEEOL(   SZ("SET_SELECTION_DIALOG::SelectItems: Could not find user ")
                     << pui0->QueryName() );
        }
    }

    _pulb->SetRedraw( TRUE );

    if ( culbiSelected > 0 )
    {
        if ( _pulb->QueryCount() > 0 )
        {
            //  Scroll the first selected item into view
            INT iFirstSelected = _pulb->QueryCurrentItem();
            _pulb->SetTopIndex( ( iFirstSelected < 0 ? 0 : iFirstSelected ));
        }

        //  Invalidate the user listbox
        _pulb->Invalidate();


        if ( !_fChangedSelection )
        {
            _fChangedSelection = TRUE;

            // rename Cancel button "&Close"
            _butCancel.SetText( _nlsClose );
        }
    }

    return err;

}  // SET_SELECTION_DIALOG::SelectItems





/*******************************************************************

    NAME:       SET_SELECTION_DIALOG::SelectItemsAlias

    SYNOPSIS:   Selects all user accounts that are members of
                an alias

    ENTRY:      ridAlias -      Alias rid, whose members are to be
                                selected or deselected
                fBuiltin -      TRUE if the alias is from the Builtin
                                SAM domain, FALSE if from the Accounts
                                SAM domain.
                fSelect -       Indicates whether to select or deselect
                                the specified users.
                                TRUE indicates to select the users
                                FALSE indicates to deselect the users

    EXIT:       The requested items are selected.  If an error occurs,
                some subset of the specified items may have been
                selected.

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        thomaspa     30-Apr-1992     Created

********************************************************************/

APIERR SET_SELECTION_DIALOG::SelectItemsAlias( ULONG  ridAlias,
                                               BOOL fBuiltin,
                                               BOOL fSelect )
{
    ASSERT( QueryAdminAuthority() != NULL );

    AUTO_CURSOR autocur;


    SAM_DOMAIN * psamdom = fBuiltin ?
                          QueryAdminAuthority()->QueryBuiltinDomain()
                        : QueryAdminAuthority()->QueryAccountDomain();

    SAM_ALIAS samalias( *psamdom, ridAlias );

    APIERR err;
    if ( (err = samalias.QueryError()) != NERR_Success )
    {
        return err;
    }

    SAM_SID_MEM samsm;

    err = samalias.GetMembers( &samsm );

    LSA_POLICY * plsapol = QueryAdminAuthority()->QueryLSAPolicy();

    LSA_TRANSLATED_NAME_MEM lsatnm;
    LSA_REF_DOMAIN_MEM lsardm;

    if ( samsm.QueryCount() > 0 )
    {
        // Translate Sids to names
        err = plsapol->TranslateSidsToNames( samsm.QueryPtr(),
                                             samsm.QueryCount(),
                                             &lsatnm,
                                             &lsardm );

        if ( err != NERR_Success )
            return err;
    }


    OS_SID ossidAccountDomain(
                QueryAdminAuthority()->QueryAccountDomain()->QueryPSID() );


    enum USER_LISTBOX_SORTORDER ulbso = _pulb->QuerySortOrder();

    INT culbiSelected = 0;

    _pulb->SetRedraw( FALSE );

    for( UINT i = 0; i < samsm.QueryCount(); i++ )
    {
        // Skip entries where the domain is unknown

        INT iDomainIndex = lsatnm.QueryDomainIndex( i );
        if (iDomainIndex < 0)
            continue;
        ASSERT( iDomainIndex < (INT)lsardm.QueryCount() );


        // Only check Users in this domain

        OS_SID ossidMembersDomain( lsardm.QueryPSID( iDomainIndex ) );

        if ( (err = ossidMembersDomain.QueryError()) != NERR_Success
            || lsatnm.QueryUse( i ) != SidTypeUser
            || !( ossidMembersDomain == ossidAccountDomain ) )
        {
            continue;
        }




        NLS_STR nlsName;

        err = lsatnm.QueryName( i, &nlsName );
        if ( err != NERR_Success )
            break;

        if ( _pulb->SelectUser( nlsName.QueryPch(), fSelect ) )
        {
            if ( culbiSelected++ == 0 )
                _pglb->RemoveSelection();
        }
        else
        {
            TRACEEOL(   SZ("SET_SELECTION_DIALOG::SelectItemsAlias: Could not find user ")
                     << nlsName.QueryPch() );
        }
    }


    _pulb->SetRedraw( TRUE );

    if ( culbiSelected > 0 )
    {
        if ( _pulb->QueryCount() > 0 )
        {
            //  Scroll the first selected item into view
            INT iFirstSelected = _pulb->QueryCurrentItem();
            _pulb->SetTopIndex( ( iFirstSelected < 0 ? 0 : iFirstSelected ));
        }

        //  Invalidate the user listbox
        _pulb->Invalidate();


        if ( !_fChangedSelection )
        {
            _fChangedSelection = TRUE;

            // rename Cancel button "&Close"
            // CODEWORK should be combined with BASE_PROP_DLG method
            _butCancel.SetText( _nlsClose );
        }
    }

    return err;

}  // SET_SELECTION_DIALOG::SelectItems
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\ucedit.cxx ===
/*******************************************************************************
*
*   ucedit.cxx
*   UCEDIT_DLG class implementation
*
*  Copyright Citrix Systems Inc. 1994
*
*  Author: Butch Davis
*
*  $Log:   N:\nt\private\net\ui\admin\user\user\citrix\VCS\ucedit.cxx  $
*  
*     Rev 1.12   13 Jan 1998 09:25:26   donm
*  removed encryption settings
*  
*     Rev 1.11   24 Feb 1997 11:27:38   butchd
*  CPR 4660: properly saves User Configuration when either OK or Close pressed
*  
*     Rev 1.10   24 Jul 1996 12:59:54   miked
*  update
*  
*     Rev 1.9   16 Jul 1996 16:44:00   TOMA
*  force client lpt to def
*  
*     Rev 1.7   16 Jul 1996 15:07:52   TOMA
*  force client lpt to def
*  
*     Rev 1.7   15 Jul 1996 18:06:24   TOMA
*  force client lpt to def
*
*     Rev 1.6   21 Nov 1995 15:39:22   billm
*  CPR 404, Added NWLogon configuration dialog
*
*     Rev 1.5   31 Jul 1995 17:26:46   butchd
*  added CITRIX User Configuration help context
*
*     Rev 1.4   19 May 1995 09:42:46   butchd
*  update
*
*     Rev 1.3   09 Dec 1994 16:50:00   butchd
*  update
*
*******************************************************************************/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>
extern "C"
{
    #include <mnet.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>


extern "C"
{
    #include <usrmgrrc.h>
    #include <umhelpc.h>
    #include "citrix.h"
}

#include <usrmain.hxx>
#include "ucedit.hxx"
#include <lmowks.hxx>
#include <strnumer.hxx>
#include "uconfig.hxx"
// #include "nwlogdlg.hxx"



//
// Static data
//
CID BrokenStringList[] = {
    IDS_UCE_BROKEN_DISCONNECT,
    IDS_UCE_BROKEN_RESET,
    INFINITE };

CID ReconnectStringList[] = {
    IDS_UCE_RECONNECT_ANY,
    IDS_UCE_RECONNECT_PREVIOUS,
    INFINITE };

CID CallbackStringList[] = {
    IDS_UCE_CALLBACK_DISABLE,
    IDS_UCE_CALLBACK_ROVING,
    IDS_UCE_CALLBACK_FIXED,
    INFINITE };

CID ShadowStringList[] = {
    IDS_UCE_SHADOW_DISABLE,
    IDS_UCE_SHADOW_INPUT_NOTIFY,
    IDS_UCE_SHADOW_INPUT_NONOTIFY,
    IDS_UCE_SHADOW_NOINPUT_NOTIFY,
    IDS_UCE_SHADOW_NOINPUT_NONOTIFY,
    INFINITE };

//
// Helper functions / classes
//

/**********************************************************************

    NAME:       VALUE_GROUP::VALUE_GROUP

    SYNOPSIS:   Constructor for value control group

    ENTRY:

    EXIT:

**********************************************************************/

VALUE_GROUP::VALUE_GROUP( OWNER_WINDOW * powin,
                          CID cidLabel,
                          CID cidEdit,
                          CID cidCheck,
                          ULONG ulMaxDigits,
                          ULONG ulDefault,
                          ULONG ulMin,
                          ULONG ulMax,
                          APIERR errMsg,
                          CONTROL_GROUP * pgroupOwner )
    : CONTROL_GROUP( pgroupOwner ),
        _powParent( powin ),
        _sltLabel( powin, cidLabel ),
        _sleEdit( powin, cidEdit, ulMaxDigits ),
        _cbCheck( powin, cidCheck ),
        _ulDefault( ulDefault ),
        _ulMin( ulMin ),
        _ulMax( ulMax ),
        _errMsg( errMsg )
{

    APIERR err = NERR_Success;

    if ( QueryError() )
        return;

    _cbCheck.SetGroup( this );

    return;

} // VALUE_GROUP::VALUE_GROUP


/**********************************************************************

    NAME:       VALUE_GROUP::OnUserAction

    SYNOPSIS:   Handle checkbox state change notification.

    ENTRY:

    EXIT:

**********************************************************************/

APIERR VALUE_GROUP::OnUserAction( CONTROL_WINDOW * pcwinControl,
                                  const CONTROL_EVENT & e )
{
    UNREFERENCED( e );

    /* We're only looking for action to checkbox control.
     */
    if ( pcwinControl->QueryCid() == _cbCheck.QueryCid() ) {

        if ( _cbCheck.IsChecked() ) {

            /* User action caused checkbox to now be checked.
             * Set value to 0, indicating 'none'.
             */
            SetValue( 0 );

        } else if ( _cbCheck.IsIndeterminate() ) {

            /* User action caused checkbox to now be indeterminate;
             * assure value group is now set as such.
             */
            SetIndeterminate();

        } else {

            /* User action caused checkbox to now be unchecked.  Set value
             * to the default and focus to the control.
             */
            SetValue( _ulDefault );
            _powParent->SetDialogFocus( _sleEdit );

        }
        return NERR_Success;
    }

    return GROUP_NO_CHANGE;

} // VALUE_GROUP::OnUserAction


/**********************************************************************

    NAME:       VALUE_GROUP::SetValue

    SYNOPSIS:   Initialize the value group.

    ENTRY:      ulValue - value to initialize to

    EXIT:

**********************************************************************/

VOID VALUE_GROUP::SetValue( ULONG ulValue )
{
    if ( ulValue == 0 ) {

        _cbCheck.SetCheck( TRUE );
        _sltLabel.Enable( FALSE );
        _sleEdit.Enable( FALSE );
        _sleEdit.SetText( TEXT("") );

    } else {

        DEC_STR nlsValue( ulValue );
        ASSERT(!!nlsValue);

        _cbCheck.SetCheck( FALSE );
        _sltLabel.Enable( TRUE );
        _sleEdit.Enable( TRUE );
        _sleEdit.SetText( nlsValue );
    }

} // VALUE_GROUP::SetValue


/**********************************************************************

    NAME:       VALUE_GROUP::QueryValue

    SYNOPSIS:   Query current value.

    ENTRY:      pulValue - pointer to variable to store valid value

    EXIT:       NERR_Success on success (value in *pulValue)
                IERR_CANCEL_NO_ERROR for bad value (message has been output)
                otherwise error code

    NOTE:       This method should not be called if the value group is
                in the 'indeterminate' state (call to IsIndeterminate()
                first to check).

**********************************************************************/

APIERR VALUE_GROUP::QueryValue( ULONG * pulValue )
{
    APIERR err = NERR_Success;

    if ( _cbCheck.IsChecked() ) {

        /* The 'none' checkbox is checked
         *
         */
        *pulValue = (ULONG)0;

    } else {

        WCHAR *endptr;
        ULONG ul;
        NLS_STR nls;

        err = _sleEdit.QueryText( &nls );
        if ( (err == NERR_Success) &&
             ((err = nls.QueryError()) == NERR_Success) ) {

            ul = wcstoul( nls.QueryPch(), &endptr, 10 );

            if ( (*endptr != WCHAR('\0')) ||
                 (ul < _ulMin) || (ul > _ulMax) ) {

                DEC_STR nlsMin( _ulMin );
                ASSERT(!!nlsMin);
                DEC_STR nlsMax( _ulMax );
                ASSERT(!!nlsMin);

                ::MsgPopup( _powParent,
                            _errMsg,
                            MPSEV_ERROR,
                            MP_OK,
                            nlsMin.QueryPch(),
                            nlsMax.QueryPch() );
                _powParent->SetDialogFocus( _sleEdit );
                err = IERR_CANCEL_NO_ERROR;

            } else {

                *pulValue = ul;
            }
        }
    }

    return err;

} // VALUE_GROUP::QueryValue


/**********************************************************************

    NAME:       VALUE_GROUP::DisableIndeterminate

    SYNOPSIS:   Prevents the 'none' checkbox from entering
                'indeterminate' state.

    ENTRY:

    EXIT:

**********************************************************************/

VOID VALUE_GROUP::DisableIndeterminate( )
{
    _cbCheck.EnableThirdState(FALSE);

} // VALUE_GROUP::DisableIndeterminate


/**********************************************************************

    NAME:       VALUE_GROUP::SetIndeterminate

    SYNOPSIS:   Initialize the value group to 'indeterminate' state.

    ENTRY:

    EXIT:

**********************************************************************/

VOID VALUE_GROUP::SetIndeterminate( )
{
    _cbCheck.SetIndeterminate( );
    _sltLabel.Enable( FALSE );
    _sleEdit.Enable( FALSE );
    _sleEdit.SetText( TEXT("") );

} // VALUE_GROUP::SetIndeterminate


/**********************************************************************

    NAME:       VALUE_GROUP::IsIndeterminate

    SYNOPSIS:   See if the value group is in the 'indeterminate' state.

    ENTRY:

    EXIT:       TRUE - in 'indeterminate' state; FALSE otherwise.

**********************************************************************/

BOOL VALUE_GROUP::IsIndeterminate( )
{
    return _cbCheck.IsIndeterminate( );

} // VALUE_GROUP::IsIndeterminate


/**********************************************************************

    NAME:       SMART_COMBOBOX::SMART_COMBOBOX

    SYNOPSIS:   Constructor for smart combo box control

    ENTRY:

    EXIT:

**********************************************************************/

SMART_COMBOBOX::SMART_COMBOBOX( OWNER_WINDOW * powin,
                                CID cid,
                                CID * pStrIds )
    : COMBOBOX( powin, cid )
{
    APIERR err = NERR_Success;

    if ( QueryError() )
        return;

    /* Initialize contents with strings if present.
     */
    while ( pStrIds && *pStrIds != INFINITE ) {

        RESOURCE_STR nlsChoice( *pStrIds );

        if ( (err = nlsChoice.QueryError()) != NERR_Success )
            break;

        if ( AddItem( nlsChoice ) < 0 ) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        pStrIds++;
    }

    if ( err != NERR_Success )
        ReportError( err );

    return;

} // SMART_COMBOBOX::SMART_COMBOBOX


//
// Member functions / classes
//

/*******************************************************************

    NAME:       UCEDIT_DLG::UCEDIT_DLG

    SYNOPSIS:   Constructor for Citrix User Configuration subdialog,
                base class

    ENTRY:      puserpropdlgParent - pointer to parent properties
                                     dialog

********************************************************************/

UCEDIT_DLG::UCEDIT_DLG(
        USERPROP_DLG * puserpropdlgParent,
        const LAZY_USER_LISTBOX * pulb
        ) : USER_SUBPROP_DLG(
                puserpropdlgParent,
                MAKEINTRESOURCE(IDD_USER_CONFIG_EDIT),
                pulb
                ),
            _cbAllowLogon( this, IDC_UCE_ALLOWLOGON ),
            _fAllowLogon(),
            // _pushbuttonNWLogon( this, IDC_UCE_NWLOGON ),
            _fIndeterminateAllowLogon( FALSE ),

            _vgConnection( this, IDL_UCE_CONNECTION,
                           IDC_UCE_CONNECTION,
                           IDC_UCE_CONNECTION_NONE,
                           CONNECTION_TIME_DIGIT_MAX,
                           CONNECTION_TIME_DEFAULT,
                           CONNECTION_TIME_MIN,
                           CONNECTION_TIME_MAX,
                           IERR_UCE_InvalidConnectionTimeout ),
            _ulConnection(),
            _fIndeterminateConnection( FALSE ),

            _vgDisconnection( this, IDL_UCE_DISCONNECTION,
                              IDC_UCE_DISCONNECTION,
                              IDC_UCE_DISCONNECTION_NONE,
                              DISCONNECTION_TIME_DIGIT_MAX,
                              DISCONNECTION_TIME_DEFAULT,
                              DISCONNECTION_TIME_MIN,
                              DISCONNECTION_TIME_MAX,
                              IERR_UCE_InvalidDisconnectionTimeout ),

            _ulDisconnection(),
            _fIndeterminateDisconnection( FALSE ),

            _vgIdle( this, IDL_UCE_IDLE, IDC_UCE_IDLE,
                     IDC_UCE_IDLE_NONE,
                     IDLE_TIME_DIGIT_MAX,
                     IDLE_TIME_DEFAULT,
                     IDLE_TIME_MIN,
                     IDLE_TIME_MAX,
                     IERR_UCE_InvalidIdleTimeout ),
            _ulIdle(),
            _fIndeterminateIdle( FALSE ),

            _sltCommandLine1( this, IDL_UCE_INITIALPROGRAM_COMMANDLINE1 ),
            _sleCommandLine( this, IDC_UCE_INITIALPROGRAM_COMMANDLINE,
                             INITIALPROGRAM_LENGTH ),
            _nlsCommandLine(),
            _fIndeterminateCommandLine( FALSE ),

            _sltWorkingDirectory1( this, IDL_UCE_INITIALPROGRAM_WORKINGDIRECTORY1 ),
            _sleWorkingDirectory( this, IDC_UCE_INITIALPROGRAM_WORKINGDIRECTORY,
                                  DIRECTORY_LENGTH ),
            _nlsWorkingDirectory(),
            _fIndeterminateWorkingDirectory( FALSE ),

            _cbClientSpecified( this, IDC_UCE_INITIALPROGRAM_INHERIT ),
            _fClientSpecified(),
            _fIndeterminateClientSpecified( FALSE ),

            _cbAutoClientDrives( this, IDC_UCE_CLIENTDEVICES_DRIVES ),
            _fAutoClientDrives(),
            _fIndeterminateAutoClientDrives( FALSE ),

            _cbAutoClientLpts( this, IDC_UCE_CLIENTDEVICES_PRINTERS ),
            _fAutoClientLpts(),
            _fIndeterminateAutoClientLpts( FALSE ),

            _cbForceClientLptDef( this, IDC_UCE_CLIENTDEVICES_FORCEPRTDEF ),
            _fForceClientLptDef(),
            _fIndeterminateForceClientLptDef( FALSE ),

            _scbBroken( this, IDC_UCE_BROKEN, BrokenStringList ),
            _iBroken(),
            _fIndeterminateBroken( FALSE ),

            _scbReconnect( this, IDC_UCE_RECONNECT, ReconnectStringList ),
            _iReconnect(),
            _fIndeterminateReconnect( FALSE ),

            _scbCallback( this, IDC_UCE_CALLBACK, CallbackStringList ),
            _iCallback(),
            _fIndeterminateCallback( FALSE ),

            _sltPhoneNumber( this, IDL_UCE_PHONENUMBER ),
            _slePhoneNumber( this, IDC_UCE_PHONENUMBER,
                             CALLBACK_LENGTH ),
            _nlsPhoneNumber(),
            _fIndeterminatePhoneNumber( FALSE ),

            _scbShadow( this, IDC_UCE_SHADOW, ShadowStringList ),
            _iShadow(),
            _fIndeterminateShadow( FALSE )
{
    APIERR err = NERR_Success;

    if( QueryError() != NERR_Success )
        return;

    if (  ((err = _vgConnection.QueryError() ) != NERR_Success )
       || ((err = _vgDisconnection.QueryError() ) != NERR_Success )
       || ((err = _vgIdle.QueryError() ) != NERR_Success )
       || ((err = _nlsCommandLine.QueryError() ) != NERR_Success )
       || ((err = _nlsWorkingDirectory.QueryError() ) != NERR_Success )
       || ((err = _scbBroken.QueryError() ) != NERR_Success )
       || ((err = _scbReconnect.QueryError() ) != NERR_Success )
       || ((err = _scbCallback.QueryError() ) != NERR_Success )
       || ((err = _nlsPhoneNumber.QueryError() ) != NERR_Success )
       || ((err = _scbShadow.QueryError() ) != NERR_Success )
       )
        ReportError( err );

    return;

} // UCEDIT_DLG::UCEDIT_DLG



/*******************************************************************

    NAME:       UCEDIT_DLG::~UCEDIT_DLG

    SYNOPSIS:   Destructor for User Properties Accounts subdialog,
                base class

********************************************************************/

UCEDIT_DLG::~UCEDIT_DLG( void )
{
    // Nothing to do

} // UCEDIT_DLG::~UCEDIT_DLG


/*******************************************************************

    NAME:       UCEDIT_DLG::GetOne

    SYNOPSIS:   Loads information on one user

    ENTRY:      iObject   -     the index of the object to load

                perrMsg  -      pointer to error message, that
                                is only used when this function
                                return value is not NERR_Success

    RETURNS:    An error code which is NERR_Success on success.         

********************************************************************/

APIERR UCEDIT_DLG::GetOne(
        UINT            iObject,
        APIERR *        perrMsg
        )
{
    APIERR err = NERR_Success;
    USER_CONFIG * pUserConfig = QueryParent()->QueryUserConfigPtr( iObject );
    ASSERT( pUserConfig != NULL );

    *perrMsg = IDS_UMGetOneFailure;

    if ( iObject == 0 ) // first object
    {
        _fAllowLogon = pUserConfig->QueryAllowLogon();
        _ulConnection = pUserConfig->QueryConnection();
        _ulDisconnection = pUserConfig->QueryDisconnection();
        _ulIdle = pUserConfig->QueryIdle();
        if ( (err = _nlsCommandLine.
                        CopyFrom( pUserConfig->QueryInitialProgram() ))
                            != NERR_Success )
            return err;
        if ( (err = _nlsWorkingDirectory.
                        CopyFrom( pUserConfig->QueryWorkingDirectory() ))
                            != NERR_Success )
            return err;
        _fClientSpecified = pUserConfig->QueryClientSpecified();
        _fAutoClientDrives = pUserConfig->QueryAutoClientDrives();
        _fAutoClientLpts = pUserConfig->QueryAutoClientLpts();
        _fForceClientLptDef = pUserConfig->QueryForceClientLptDef();
        _iBroken = pUserConfig->QueryBroken();
        _iReconnect = pUserConfig->QueryReconnect();
        _iCallback = pUserConfig->QueryCallback();
        if ( (err = _nlsPhoneNumber.
                        CopyFrom( pUserConfig->QueryPhoneNumber() ))
                            != NERR_Success )
            return err;
        _iShadow = pUserConfig->QueryShadow();
    }
    else        // iObject > 0
    {
        if ( !_fIndeterminateAllowLogon &&
             (_fAllowLogon != pUserConfig->QueryAllowLogon()) ) {

                _fIndeterminateAllowLogon = TRUE;
                _fAllowLogon = TRUE;
        }

        if ( !_fIndeterminateConnection &&
             (_ulConnection != pUserConfig->QueryConnection()) ) {

                _fIndeterminateConnection = TRUE;
                _ulConnection = 0;
        }

        if ( !_fIndeterminateDisconnection &&
             (_ulDisconnection != pUserConfig->QueryDisconnection()) ) {

                _fIndeterminateDisconnection = TRUE;
                _ulDisconnection = 0;
        }

        if ( !_fIndeterminateIdle &&
             (_ulIdle != pUserConfig->QueryIdle()) ) {

                _fIndeterminateIdle = TRUE;
                _ulIdle = 0;
        }

        if ( !_fIndeterminateCommandLine &&
             (_nlsCommandLine._stricmp( pUserConfig->QueryInitialProgram() ) != 0) ) {

                _fIndeterminateCommandLine = TRUE;
        }

        if ( !_fIndeterminateWorkingDirectory &&
             (_nlsWorkingDirectory._stricmp( pUserConfig->QueryWorkingDirectory() ) != 0) ) {

                _fIndeterminateWorkingDirectory = TRUE;
        }

        if ( !_fIndeterminateClientSpecified &&
             (_fClientSpecified != pUserConfig->QueryClientSpecified()) ) {

                _fIndeterminateClientSpecified = TRUE;
                _fClientSpecified = TRUE;
        }

        if ( !_fIndeterminateAutoClientDrives &&
             (_fAutoClientDrives != pUserConfig->QueryAutoClientDrives()) ) {

                _fIndeterminateAutoClientDrives = TRUE;
                _fAutoClientDrives = TRUE;
        }

        if ( !_fIndeterminateAutoClientLpts &&
             (_fAutoClientLpts != pUserConfig->QueryAutoClientLpts()) ) {

                _fIndeterminateAutoClientLpts = TRUE;
                _fAutoClientLpts = TRUE;
        }

        if ( !_fIndeterminateForceClientLptDef &&
             (_fForceClientLptDef != pUserConfig->QueryForceClientLptDef()) ) {

                _fIndeterminateForceClientLptDef = TRUE;
                _fForceClientLptDef = TRUE;
        }

        if ( !_fIndeterminateBroken &&
             (_iBroken != pUserConfig->QueryBroken()) ) {

                _fIndeterminateBroken = TRUE;
                _iBroken = -1;
        }

        if ( !_fIndeterminateReconnect &&
             (_iReconnect != pUserConfig->QueryReconnect()) ) {

                _fIndeterminateReconnect = TRUE;
                _iReconnect = -1;
        }

        if ( !_fIndeterminateCallback &&
             (_iCallback != pUserConfig->QueryCallback()) ) {

                _fIndeterminateCallback = TRUE;
                _iCallback = -1;
        }

        if ( !_fIndeterminatePhoneNumber &&
             (_nlsPhoneNumber._stricmp( pUserConfig->QueryPhoneNumber() ) != 0) ) {

                _fIndeterminatePhoneNumber = TRUE;
        }

        if ( !_fIndeterminateShadow &&
             (_iShadow != pUserConfig->QueryShadow()) ) {

                _fIndeterminateShadow = TRUE;
                _iShadow = -1;
        }
    }
        
    return err;

} // UCEDIT_DLG::GetOne


/*******************************************************************

    NAME:       UCEDIT_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by UCEDIT_DLG,
                according to the values in the class data members.
                        
    RETURNS:    An error code which is NERR_Success on success.

********************************************************************/

APIERR UCEDIT_DLG::InitControls()
{

    if( !_fIndeterminateAllowLogon )
    {
        _cbAllowLogon.SetCheck( _fAllowLogon );
        _cbAllowLogon.EnableThirdState(FALSE);
    }
    else
    {
        _cbAllowLogon.SetIndeterminate();
    }

    if( !_fIndeterminateConnection ) {

        _vgConnection.SetValue( _ulConnection / TIME_RESOLUTION );
        _vgConnection.DisableIndeterminate( );

    } else
        _vgConnection.SetIndeterminate();

    if( !_fIndeterminateDisconnection ) {

        _vgDisconnection.SetValue( _ulDisconnection / TIME_RESOLUTION );
        _vgDisconnection.DisableIndeterminate( );

    } else
        _vgDisconnection.SetIndeterminate();

    if( !_fIndeterminateIdle ) {

        _vgIdle.SetValue( _ulIdle / TIME_RESOLUTION );
        _vgIdle.DisableIndeterminate( );

    } else
        _vgIdle.SetIndeterminate();

    if ( !_fIndeterminateCommandLine )
        _sleCommandLine.SetText( _nlsCommandLine );

    if ( !_fIndeterminateWorkingDirectory )
        _sleWorkingDirectory.SetText( _nlsWorkingDirectory );

    if( !_fIndeterminateClientSpecified )
    {
        _cbClientSpecified.SetCheck( _fClientSpecified );
        OnClickedClientSpecified();
        _cbClientSpecified.EnableThirdState(FALSE);
    }
    else
    {
        _cbClientSpecified.SetIndeterminate();
        OnClickedClientSpecified();
    }

    if( !_fIndeterminateAutoClientDrives )
    {
        _cbAutoClientDrives.SetCheck( _fAutoClientDrives );
        _cbAutoClientDrives.EnableThirdState(FALSE);
    }
    else
    {
        _cbAutoClientDrives.SetIndeterminate();
    }

    if( !_fIndeterminateAutoClientLpts )
    {
        _cbAutoClientLpts.SetCheck( _fAutoClientLpts );
        _cbAutoClientLpts.EnableThirdState(FALSE);
    }
    else
    {
        _cbAutoClientLpts.SetIndeterminate();
    }

    if( !_fIndeterminateForceClientLptDef )
    {
        _cbForceClientLptDef.SetCheck( _fForceClientLptDef );
        _cbForceClientLptDef.EnableThirdState(FALSE);
    }
    else
    {
        _cbForceClientLptDef.SetIndeterminate();
    }

    _scbBroken.SelectItem( _iBroken, TRUE );

    _scbReconnect.SelectItem( _iReconnect, TRUE );

    _scbCallback.SelectItem( _iCallback, TRUE );
    if ( !_fIndeterminatePhoneNumber )
        _slePhoneNumber.SetText( _nlsPhoneNumber );
    OnSelchangeCallback();

    _scbShadow.SelectItem( _iShadow, TRUE );

    return USER_SUBPROP_DLG::InitControls();

} // UCEDIT_DLG::InitControls


/*******************************************************************

    NAME:       UCEDIT_DLG::W_DialogToMembers

    SYNOPSIS:   Loads data from dialog into class data members and
                validates.

    RETURNS:    NERR_Success if all dialog data was OK; error code
                to cause message display otherwise.

********************************************************************/

APIERR UCEDIT_DLG::W_DialogToMembers()
{
    APIERR err = NERR_Success;
    ULONG ul;
    INT selection;
    NLS_STR nls;

    if ( !_cbAllowLogon.IsIndeterminate() ) {

        _fAllowLogon = _cbAllowLogon.IsChecked();
        _fIndeterminateAllowLogon = FALSE;
    }

    if ( !_vgConnection.IsIndeterminate() ) {

        if ( (err = _vgConnection.QueryValue( &ul )) != NERR_Success )
            return err;
        else
            _ulConnection = ul * TIME_RESOLUTION;
        _fIndeterminateConnection = FALSE;
    }

    if ( !_vgDisconnection.IsIndeterminate() ) {

        if ( (err = _vgDisconnection.QueryValue( &ul )) != NERR_Success )
            return err;
        else
            _ulDisconnection = ul * TIME_RESOLUTION;
        _fIndeterminateDisconnection = FALSE;
    }

    if ( !_vgIdle.IsIndeterminate() ) {

        if ( (err = _vgIdle.QueryValue( &ul )) != NERR_Success )
            return err;
        else
            _ulIdle = ul * TIME_RESOLUTION;
        _fIndeterminateIdle = FALSE;
    }

    if ( ((err = _sleCommandLine.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;
    if ( !_fIndeterminateCommandLine ||
         (_nlsCommandLine._stricmp( nls ) != 0) ) {

        if ( (err = _nlsCommandLine.CopyFrom( nls )) != NERR_Success )
            return err;
        _fIndeterminateCommandLine = FALSE;
    }

    if ( ((err = _sleWorkingDirectory.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;
    if ( !_fIndeterminateWorkingDirectory ||
         (_nlsWorkingDirectory._stricmp( nls ) != 0) ) {

        if ( (err = _nlsWorkingDirectory.CopyFrom( nls )) != NERR_Success )
            return err;
        _fIndeterminateWorkingDirectory = FALSE;
    }

    if ( !_cbClientSpecified.IsIndeterminate() ) {

        _fClientSpecified = _cbClientSpecified.IsChecked();
        _fIndeterminateClientSpecified = FALSE;
    }

    if ( !_cbAutoClientDrives.IsIndeterminate() ) {

        _fAutoClientDrives = _cbAutoClientDrives.IsChecked();
        _fIndeterminateAutoClientDrives = FALSE;
    }

    if ( !_cbAutoClientLpts.IsIndeterminate() ) {

        _fAutoClientLpts = _cbAutoClientLpts.IsChecked();
        _fIndeterminateAutoClientLpts = FALSE;
    }

    if ( !_cbForceClientLptDef.IsIndeterminate() ) {

        _fForceClientLptDef = _cbForceClientLptDef.IsChecked();
        _fIndeterminateForceClientLptDef = FALSE;
    }

    if ( (selection = _scbBroken.QueryCurrentItem()) >= 0 ) {

        _iBroken = selection;
        _fIndeterminateBroken = FALSE;
    }

    if ( (selection = _scbReconnect.QueryCurrentItem()) >= 0 ) {

        _iReconnect = selection;
        _fIndeterminateReconnect = FALSE;
    }

    if ( (selection = _scbCallback.QueryCurrentItem()) >= 0 ) {

        _iCallback = selection;
        _fIndeterminateCallback = FALSE;
    }

    if ( ((err = _slePhoneNumber.QueryText( &nls )) != NERR_Success) ||
         ((err = nls.QueryError()) != NERR_Success) )
        return err;
    if ( !_fIndeterminatePhoneNumber ||
         (_nlsPhoneNumber._stricmp( nls ) != 0) ) {

        if ( (err = _nlsPhoneNumber.CopyFrom( nls )) != NERR_Success )
            return err;
        _fIndeterminatePhoneNumber = FALSE;
    }

    if ( (selection = _scbShadow.QueryCurrentItem()) >= 0 ) {

        _iShadow = selection;
        _fIndeterminateShadow = FALSE;
    }

    return USER_SUBPROP_DLG::W_DialogToMembers();

} // UCEDIT_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       UCEDIT_DLG::PerformOne
        
    SYNOPSIS:   PERFORMER::PerformSeries calls this

    ENTRY:      iObject  -      index of the object to save

                perrMsg  -      pointer to error message, that
                                is only used when this function
                                return value is not NERR_Success
                                        
                pfWorkWasDone - set to TRUE unless this is a new variant,
                                (thus performing a similar
                                function to the "ChangesUser2Ptr()" method
                                for other UM subdialogs).  Actual writing
                                of the USER_CONFIG object will only take
                                place if changes were made or the object
                                was 'dirty' to begin with.
                                        
    RETURNS:    An error code which is NERR_Success on success.

    NOTES:      This PerformOne() is intended to work only with the User
                Configuration subdialog and is a complete replacement of
                the USER_SUBPROP_DLG::PerformOne().

********************************************************************/

APIERR UCEDIT_DLG::PerformOne(
        UINT            iObject,
        APIERR *        perrMsg,
        BOOL *          pfWorkWasDone
        )
{
    APIERR err = NERR_Success;
    USER_CONFIG * pUserConfig = QueryParent()->QueryUserConfigPtr( iObject );
    ASSERT( pUserConfig != NULL );

    *perrMsg = IDS_UMEditFailure;

    if ( !IsNewVariant() )
        *pfWorkWasDone = TRUE;

    if ( !_fIndeterminateAllowLogon &&
         (_fAllowLogon != pUserConfig->QueryAllowLogon()) ) {

        pUserConfig->SetAllowLogon( _fAllowLogon );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateConnection &&
         (_ulConnection != pUserConfig->QueryConnection()) ) {

        pUserConfig->SetConnection( _ulConnection );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateDisconnection &&
         (_ulDisconnection != pUserConfig->QueryDisconnection()) ) {

        pUserConfig->SetDisconnection( _ulDisconnection );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateIdle &&
         (_ulIdle != pUserConfig->QueryIdle()) ) {

        pUserConfig->SetIdle( _ulIdle );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateCommandLine &&
         (_nlsCommandLine._stricmp( pUserConfig->QueryInitialProgram() ) != 0) ) {

        if ( (err = pUserConfig->
                        SetInitialProgram( _nlsCommandLine.QueryPch() ))
                            != NERR_Success )
            return err;
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateWorkingDirectory &&
         (_nlsWorkingDirectory._stricmp( pUserConfig->QueryWorkingDirectory() ) != 0) ) {

        if ( (err = pUserConfig->
                        SetWorkingDirectory( _nlsWorkingDirectory.QueryPch() ))
                            != NERR_Success )
            return err;
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateClientSpecified &&
         (_fClientSpecified != pUserConfig->QueryClientSpecified()) ) {

        pUserConfig->SetClientSpecified( _fClientSpecified );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateAutoClientDrives &&
         (_fAutoClientDrives != pUserConfig->QueryAutoClientDrives()) ) {

        pUserConfig->SetAutoClientDrives( _fAutoClientDrives );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateAutoClientLpts &&
         (_fAutoClientLpts != pUserConfig->QueryAutoClientLpts()) ) {

        pUserConfig->SetAutoClientLpts( _fAutoClientLpts );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateForceClientLptDef &&
         (_fForceClientLptDef != pUserConfig->QueryForceClientLptDef()) ) {

        pUserConfig->SetForceClientLptDef( _fForceClientLptDef );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateBroken &&
         (_iBroken != pUserConfig->QueryBroken()) ) {

        pUserConfig->SetBroken( _iBroken );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateReconnect &&
         (_iReconnect != pUserConfig->QueryReconnect()) ) {

        pUserConfig->SetReconnect( _iReconnect );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateCallback &&
         (_iCallback != pUserConfig->QueryCallback()) ) {

        pUserConfig->SetCallback( _iCallback );
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminatePhoneNumber &&
         (_nlsPhoneNumber._stricmp( pUserConfig->QueryPhoneNumber() ) != 0) ) {

        if ( (err = pUserConfig->
                        SetPhoneNumber( _nlsPhoneNumber.QueryPch() ))
                            != NERR_Success )
            return err;
        pUserConfig->SetDirty();
    }

    if ( !_fIndeterminateShadow &&
         (_iShadow != pUserConfig->QueryShadow()) ) {

        pUserConfig->SetShadow( _iShadow );
        pUserConfig->SetDirty();
    }

    /* Output if not a 'new' user.
     */
    if ( !IsNewVariant() )
        err = pUserConfig->SetInfo();

    return err;

} // UCEDIT_DLG::PerformOne


/*******************************************************************

    NAME:       UCEDIT_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

********************************************************************/

ULONG UCEDIT_DLG::QueryHelpContext( void )
{
    return HC_UM_USERCONFIG;

} // UCEDIT_DLG::QueryHelpContext


/*******************************************************************

    NAME:       UCEDIT_DLG::OnClickedClientSpecified

    SYNOPSIS:   Processing when 'client specified' checkbox is clicked.

********************************************************************/

VOID UCEDIT_DLG::OnClickedClientSpecified( )
{
    BOOL bCheckedOrIndeterminate = (_cbClientSpecified.IsChecked() ||
                                    _cbClientSpecified.IsIndeterminate() );

    /* Enable or disable the Initial Program labels and edit fields
     * based on new state of 'client specified' checkbox.
     */
    _sltCommandLine1.Enable( !bCheckedOrIndeterminate );
    _sleCommandLine.Enable( !bCheckedOrIndeterminate );
    _sltWorkingDirectory1.Enable( !bCheckedOrIndeterminate );
    _sleWorkingDirectory.Enable( !bCheckedOrIndeterminate );

} // UCEDIT_DLG::OnClickedClientSpecified


/*******************************************************************

    NAME:       UCEDIT_DLG::OnSelchangeCallback

    SYNOPSIS:   Special processing upon callback LB selection change.

********************************************************************/

VOID UCEDIT_DLG::OnSelchangeCallback( )
{
    INT item = _scbCallback.QueryCurrentItem();
    BOOL bEnable = ( (item >= 0) &&
                     ((CALLBACKCLASS)item != Callback_Disable) );

    /* Enable/disable phone number label and edit field based on
     * callback list box selection.
     */
    _sltPhoneNumber.Enable( bEnable );
    _slePhoneNumber.Enable( bEnable );

} // UCEDIT_DLG::OnSelchangeCallback


/*******************************************************************

    NAME:       UCEDIT_DLG::OnCommand

    SYNOPSIS:   Handles control notifications

    RETURNS:    TRUE if message was handled; FALSE otherwise

********************************************************************/

BOOL UCEDIT_DLG::OnCommand( const CONTROL_EVENT & ce )
{
    USER_SUB2PROP_DLG * psubpropDialog = NULL;
    APIERR err = ERROR_NOT_ENOUGH_MEMORY; // if dialog not allocated

    switch ( ce.QueryCid() ) {

        case IDC_UCE_INITIALPROGRAM_INHERIT:
            OnClickedClientSpecified();
            return TRUE;

        case IDC_UCE_CALLBACK:
            if ( ce.QueryCode() == LBN_SELCHANGE )
                OnSelchangeCallback();
            break;
/*
        case IDC_UCE_NWLOGON:
            psubpropDialog = new UCNWLOGON_DLG( this,
                                                QueryParent()->Querypulb() );
            if ( psubpropDialog != NULL )
            {
                err = NERR_Success;

                if ( psubpropDialog->GetInfo() )
                    err = psubpropDialog->Process(); // Dismiss code not used
                delete psubpropDialog;
                this->SetDialogFocus( _pushbuttonNWLogon );
            }

            if ( err != NERR_Success )
                ::MsgPopup( this, err );
            return TRUE;
*/

        default:
            break;
    }

    return USER_SUBPROP_DLG::OnCommand( ce );

} // UCEDIT_DLG::OnCommand
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\trust.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990-1992              **/
/**********************************************************************/

/*
    trust.cxx
    This file contains the class definitions for the TRUST_DIALOG
    class.  The TRUST_DIALOG class is used to manipulate the trusted
    domain list.


    FILE HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.
        KeithMo     03-Sep-1992 Added UI_DOMAIN for WAN support.
        KeithMo     11-Jan-1993 Removed UI_DOMAIN (new WAN Plan).

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <lmodom.hxx>
#include <lmouser.hxx>
#include <errmap.hxx>
#include <adminapp.hxx>
#include <usrmain.hxx>
#include <trust.hxx>
#include <apisess.hxx>
#include <lmodev.hxx>

extern "C"
{
    #include <usrmgr.h>
    #include <usrmgrrc.h>
    #include <mnet.h>
    #include <umhelpc.h>

    #include <crypt.h>          // required by logonmsv.h
    #include <logonmsv.h>       // required by ssi.h
    #include <ssi.h>            // for SSI_ACCOUNT_NAME_POSTFIX

    #include <limits.h>         // for UINT_MAX

}   // extern "C"


//
//  If this manifest is #defined non-zero, then the TRUSTED_DIALOG constructor
//  will pass NULL to the ADMIN_AUTHORITY constructor, forcing all LSA & SAM
//  operations to take place on the local machine.  This is due to a bug in
//  NT redirector that prevents the LsaSetSecret API from being successfully
//  remoted.  This manifest should be changed to zero after the redirector
//  has been fixed.
//

#define LOCAL_ADMIN_ONLY 0

//
//  These manifests are used to control/validate the length
//  limits of domain names & passwords.
//

#define MAX_DOMAIN_LENGTH       LM20_DNLEN
#define MAX_PASSWORD_LENGTH     LM20_PWLEN

//
//  This makes some of the SID code a little prettier.
//

#define NULL_PSID ((PSID)NULL)


//
//  TRUST_DIALOG methods
//

/*******************************************************************

    NAME:           TRUST_DIALOG :: TRUST_DIALOG

    SYNOPSIS:       TRUST_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pszDomainName       - Name of the target domain.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUST_DIALOG :: TRUST_DIALOG( UM_ADMIN_APP * pumadminapp,
                              const TCHAR * pszDomainName,
                              ADMIN_AUTHORITY * padminauth )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_TRUST_LIST ), ((OWNER_WINDOW *)pumadminapp)->QueryHwnd()),
    _pumadminapp( pumadminapp ),
    _sltDomain( this, IDTL_DOMAIN ),
    _lbTrustedDomains( this, IDTL_TRUSTED_LIST, pszDomainName ),
    _lbPermittedDomains( this, IDTL_PERMITTED_LIST, pszDomainName ),
    _pbCancel( this, IDCANCEL ),
    _pbRemoveTrusted( this, IDTL_REMOVE_TRUSTED ),
    _pbRemovePermitted( this, IDTL_REMOVE_PERMITTED ),
    _nlsDomain( pszDomainName ),
    _nlsCloseText( IDS_TRUST_CLOSE ),
    _padminauth( padminauth )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( padminauth != NULL && padminauth->QueryError() == NERR_Success );

    //
    //  This may take a while...
    //

    AUTO_CURSOR cursor;

    //
    //  Let's see if everything constructed properly.
    //

    APIERR err = QueryError();

    err = ( err != NERR_Success ) ? err : _nlsDomain.QueryError();
    err = ( err != NERR_Success ) ? err : _nlsCloseText.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Fill in the trusted domain listbox.
        //

        err = _lbTrustedDomains.Fill( _padminauth->QueryLSAPolicy() );
    }

    if( err == NERR_Success )
    {
        //
        //  Fill in the permitted domains listbox.
        //

        err = _lbPermittedDomains.Fill( _padminauth->QueryAccountDomain() );
    }

    if( err == NERR_Success )
    {
        //
        //  Display the domain name.
        //

        _sltDomain.SetText( pszDomainName );

        //
        //  Adjust the trusted/permitted domain remove buttons.
        //

        AdjustButtons();
    }

    if( err != NERR_Success )
    {
        ReportError( err );
    }

}   // TRUST_DIALOG :: TRUST_DIALOG


/*******************************************************************

    NAME:           TRUST_DIALOG :: ~TRUST_DIALOG

    SYNOPSIS:       TRUST_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUST_DIALOG :: ~TRUST_DIALOG( VOID )
{
    // nothing to do here

}   // TRUST_DIALOG :: ~TRUST_DIALOG


/*******************************************************************

    NAME:           TRUST_DIALOG :: QueryHelpContext

    HISTORY:
        thomaspa     31-Apr-1992 Created for the User Manager.

********************************************************************/
ULONG TRUST_DIALOG :: QueryHelpContext( VOID )
{
    return HC_UM_POLICY_TRUST_LANNT + _pumadminapp->QueryHelpOffset();
}


/*******************************************************************

    NAME:       TRUST_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      event                   - Specifies the control which
                                          initiated the command.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
BOOL TRUST_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    APIERR err = NERR_Success;

    switch( event.QueryCid() )
    {
    case IDTL_ADD_TRUSTED :
        err = GetNewTrustedDomain();
        break;

    case IDTL_ADD_PERMITTED :
        err = GetNewPermittedDomain();
        break;

    case IDTL_REMOVE_TRUSTED :
        err = RemoveTrustedDomain();
        break;

    case IDTL_REMOVE_PERMITTED :
        err = RemovePermittedDomain();
        break;

    default:
        //
        //  If we made it this far, then we're not interested in the message.
        //

        return FALSE;
    }

    //
    //  We only get to this point if we handled the command.
    //  Display any appropriate (useful and informative)
    //  error messages.
    //

    if( err != NERR_Success )
    {
        MsgPopup( this, err );
    }

    return TRUE;

}   // TRUST_DIALOG :: OnCommand


/*******************************************************************

    NAME:       TRUST_DIALOG :: GetNewTrustedDomain

    SYNOPSIS:   Get a new trusted domain & password from the user,
                then update the trusted domain list.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.
        jonn        20-Jun-1995 Handle credential conflict

********************************************************************/
APIERR TRUST_DIALOG :: GetNewTrustedDomain( VOID )
{
    NLS_STR nlsDomain;
    NLS_STR nlsPassword;
    BOOL    fGotDomain = FALSE;

    //
    //  Ensure the strings constructed properly.
    //

    APIERR err = nlsDomain.QueryError();
    err = ( err != NERR_Success ) ? err : nlsPassword.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Prompt the user for the domain name & password.
        //

        ADD_TRUST_DIALOG * pDlg = new ADD_TRUST_DIALOG( this,
                                                        &nlsDomain,
                                                        &nlsPassword );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fGotDomain );

        delete pDlg;
    }

    //
    //  ADD_TRUST_DIALOG's OnOK method copies the new domain name into
    //  nlsDomain and the new password into nlsPassword.  This may leave
    //  either of these strings in an error state.
    //

    err = ( err != NERR_Success ) ? err : nlsDomain.QueryError();
    err = ( err != NERR_Success ) ? err : nlsPassword.QueryError();

    //
    //  The new domain's SID will be returned in this object.
    //

    LSA_PRIMARY_DOM_INFO_MEM lsaprim;

    err = ( err != NERR_Success ) ? err : lsaprim.QueryError();

    //
    //  Now we can actually update the LSA database.
    //  This may take a while...
    //

    AUTO_CURSOR cursor;

    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  See if the domain is already trusted.  If it is,
        //  just select it & pretend we didn't get a domain.
        //

        INT cItems = _lbTrustedDomains.QueryCount();

        for( INT i = 0 ; i < cItems ; i++ )
        {
            TRUSTED_LBI * plbi = _lbTrustedDomains.QueryItem( i );
            UIASSERT( plbi != NULL );

            if( ::stricmpf( nlsDomain, plbi->QueryDomainName() ) == 0 )
            {
                //
                //  Found it!.
                //

                _lbTrustedDomains.SelectItem( i );
                fGotDomain = FALSE;
                err = IERR_UM_AlreadyTrusted;
                break;
            }
        }
    }

    BOOL fTrustAccountOk = FALSE;

    if( ( err == NERR_Success ) && fGotDomain )
    {
        err = ConfirmTrustRelationship( nlsDomain,
                                        nlsPassword,
                                        &fTrustAccountOk );

        if ( err == ERROR_SESSION_CREDENTIAL_CONFLICT )
            return NERR_Success;
    }


    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        // ConfirmTrustRelationship may have displayed a popup, so make
        // sure we still have a wait-cursor.
        //
        AUTO_CURSOR cursor2;

        //
        //  Force a repaint of the dialog to elimiate any random
        //  half-drawn controls that were underneath the prompt dialog.
        //

        RepaintNow();

        //
        //  Update the LSA database.
        //

        err = W_AddTrustedDomain( nlsDomain,
                                  nlsPassword,
                                  &lsaprim );
        switch (err)
        {
        case ERROR_FILE_EXISTS:
            TRACEEOL( "TRUST_DIALOG::GetNewTrustedDomain: W_AddTrustedDomain returned ERROR_FILE_ALREADY_EXISTS" );
            MsgPopup( this,
                      IERR_UM_DomainsMightShareSids,
                      err,
                      MPSEV_ERROR,
                      HC_UM_TRUST_DOMAINS_SHARE_SIDS,
                      MP_OK,
                      (NLS_STR **)NULL );

            return NERR_Success; // do not report this error again

        default:
            break;
        }
    }

    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  The LSA database was updated properly.
        //  Now, update the listbox.
        //

        TRUSTED_LBI * plbi = new TRUSTED_LBI( nlsDomain,
                                              lsaprim.QueryPSID() );
        INT iItem = _lbTrustedDomains.AddItem( plbi );

        if( iItem < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _lbTrustedDomains.SelectItem( iItem );
            _pbRemoveTrusted.Enable( TRUE );
        }
    }

    if( ( err == NERR_Success ) && fGotDomain )
    {

        //  Now tell the user whether they have successfully completed
        //  both sides of the trust relationship, or he still must do
        //  the other side.
        if ( fTrustAccountOk )
        {
            MsgPopup( this,
                      IDS_UM_TrustComplete,
                      MPSEV_INFO,
                      IDOK,
                      nlsDomain.QueryPch()  );
        }
        else
        {
            MsgPopup( this,
                      IDS_UM_TrustIncomplete,
                      MPSEV_INFO,
                      IDOK,
                      _nlsDomain.QueryPch(), // this domain
                      nlsDomain.QueryPch()  ); // domain to trust
        }
        //
        //  Since we just committed a major change to the database,
        //  change the text of the "Cancel" button to "Close".
        //

        _pbCancel.SetText( _nlsCloseText );
    }

    return err;

}   // TRUST_DIALOG :: GetNewTrustedDomain

const TCHAR * const pszIPCName = SZ("\\IPC$") ;

/*******************************************************************

    NAME:       TRUST_DIALOG :: ConfirmTrustRelationship

    SYNOPSIS:   Checks to see if the interdomain trust account has already
                been established on the other domain.

    ENTRY:      nlsDomainName           - Name of the newly trusted domain.

                nlsPassword             - The password for the trusted domain.

    EXIT:       fTrustAccountOk         - True if the account and password
                                          are correct on the server (trusted)
                                          side.


    RETURNS:    APIERR                  - Any errors encountered.  Returns
                                          IERR_UM_InvalidTrustPassword if
                                          the password entered doesn't match
                                          the password set up on the trusted
                                          side.
                                          ERROR_SESSION_CREDENTIAL_CONFLICT
                                          as return value means that the user
                                          encountered this error and decided
                                          not to continue.

    HISTORY:
        thomaspa    07-Apr-1993 Created
        jonn        20-Jun-1995 Handle credential conflict

********************************************************************/
APIERR TRUST_DIALOG :: ConfirmTrustRelationship( NLS_STR & nlsDomainName,
                                                 NLS_STR & nlsPassword,
                                                 BOOL * fTrustAccountOk )
{
    ASSERT( fTrustAccountOk != NULL );
    *fTrustAccountOk = FALSE;
    APIERR err = NERR_Success;
    APIERR errConnect = NERR_Success;

    DEVICE2 devIPC( SZ("") ) ;  // Deviceless connection

    NLS_STR nlsDomainNameWithPostfix;
    DOMAIN * pdomain = NULL;

    NLS_STR nlsPDC;

    do { // Error breakout loop
        NLS_STR nlsPostfix;

        if ( (err = nlsPostfix.QueryError()) != NERR_Success
          || (err = nlsPostfix.MapCopyFrom((WCHAR *)SSI_ACCOUNT_NAME_POSTFIX))
            != NERR_Success )
            break;


        nlsDomainNameWithPostfix = _nlsDomain;

        if ( (err = nlsDomainNameWithPostfix.QueryError()) != NERR_Success
          || (err = nlsDomainNameWithPostfix.Append( nlsPostfix ))
                != NERR_Success )
        {
            break;
        }

        pdomain = new DOMAIN( nlsDomainName.QueryPch() );

        if ( pdomain == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        if ( (err = pdomain->GetInfo()) != NERR_Success )
            break;

        nlsPDC = pdomain->QueryPDC() ;
        NLS_STR nlsIPC = nlsPDC;
        nlsIPC.Append( pszIPCName ) ;
        if ( ((err = nlsPDC.QueryError()) != NERR_Success )
          || ((err = nlsIPC.QueryError()) != NERR_Success )
          || ((err = devIPC.GetInfo()) != NERR_Success ) )
        {
            break;
        }

        errConnect = devIPC.Connect( nlsIPC.QueryPch(),
                              nlsPassword.QueryPch(),
                              nlsDomainNameWithPostfix.QueryPch(),
                              nlsDomainName.QueryPch() ) ;
    } while ( FALSE );

    if ( err == NERR_Success )
    {
        switch( errConnect )
        {
        case NERR_Success:
            // This probably means we got connected using the guest account,
            // meaning that the account doesn't exist.
            devIPC.Disconnect();
            break;
        case ERROR_LOGON_FAILURE:
        {
            // Either the account doesn't exist or the password is wrong
            API_SESSION apisess( pdomain->QueryPDC(), TRUE );
            PBYTE pbBuf = NULL;
            APIERR tmperr = ::MNetUserGetInfo( pdomain->QueryPDC(),
                                            (TCHAR *)nlsDomainNameWithPostfix.QueryPch(),
                                            0,
                                            &pbBuf );
            if ( tmperr == NERR_Success )
                err = IERR_UM_InvalidTrustPassword;
            else
                err = NERR_Success;

            ::MNetApiBufferFree( &pbBuf );

            break;
        }
        case ERROR_SESSION_CREDENTIAL_CONFLICT:
            // We cannot confirm the trust relationship if there is already
            // a session to the server.  JonN 6/20/95
            NLS_STR * apnls[4];
            apnls[0] = &_nlsDomain;
            apnls[1] = &nlsDomainName;
            apnls[2] = &nlsPDC;
            apnls[3] = NULL;
            if( MsgPopup( this,
                          IDS_UM_Trust_SessConflict,
                          MPSEV_WARNING,
                          HC_UM_TRUST_SESS_CONFLICT,
                          MP_YESNO,
                          apnls,
                          MP_NO ) == IDYES )
            {
                err = NERR_Success;
            } else {
                err = ERROR_SESSION_CREDENTIAL_CONFLICT;
            }
            break;

        case ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT:
            *fTrustAccountOk = TRUE;
            // fall through
        default:
            err = NERR_Success;
            break;
        }
    }

    delete pdomain;
    return err;
}

/*******************************************************************

    NAME:       TRUST_DIALOG :: W_AddTrustedDomain

    SYNOPSIS:   Setup the "client" side of the trust relationship.

    ENTRY:      nlsDomainName           - Name of the newly trusted domain.

                nlsPassword             - The password for the trusted domain.

                plsaprim                - Points to an LSA_PRIMARY_DOM_INFO_MEM
                                          that will receive the domain's PSID.

    EXIT:       If successful, then the client (trusting) side of the
                trust relationship has been established.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Apr-1992 Created for the User Manager.
        KeithMo     11-Jan-1993 Use GetAnyValidDC.

********************************************************************/
APIERR TRUST_DIALOG :: W_AddTrustedDomain( NLS_STR & nlsDomainName,
                                           NLS_STR & nlsPassword,
                                           LSA_PRIMARY_DOM_INFO_MEM * plsaprim )
{
    UIASSERT( nlsDomainName.QueryError() == NERR_Success );
    UIASSERT( nlsPassword.QueryError() == NERR_Success );
    UIASSERT( plsaprim != NULL );
    UIASSERT( plsaprim->QueryError() == NERR_Success );

    //
    //  Find a valid DC in the target domain.
    //

    NLS_STR nlsValidDC;

    APIERR err = nlsValidDC.QueryError();

    if( err == NERR_Success )
    {
        //
        //  CODEWORK:  GetAnyValidDC creates a NULL session
        //  to the DC to verify its availability, then promptly
        //  destroys the session.  We then create another
        //  (identical) session to the same machine.  Wasteful.
        //

        err = DOMAIN::GetAnyValidDC( NULL,
                                     nlsDomainName,
                                     &nlsValidDC );
    }

    if( err == NERR_Success )
    {
        //
        //  Create an appropriate (null?) session to the DC.
        //

        API_SESSION apisess( nlsValidDC );

        err = apisess.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Open the LSA Policy on the DC so we can
            //  query the primary domain's SID.
            //

            LSA_POLICY lsapolTrusted( nlsValidDC );

            if( err == NERR_Success )
            {
                err = lsapolTrusted.QueryError();
            }

            if( err == NERR_Success )
            {
                err = lsapolTrusted.GetPrimaryDomain( plsaprim );
            }

            if( err == NERR_Success )
            {
                //
                //  Now, join them in a bond of holy trustedness.
                //

                LSA_POLICY * plsapolFocus = _padminauth->QueryLSAPolicy();
                UIASSERT( plsapolFocus != NULL );

                err = plsapolFocus->TrustDomain( nlsDomainName,
                                                 plsaprim->QueryPSID(),
                                                 nlsPassword,
                                                 FALSE );
            }
        }
    }

    return err;

}   // TRUST_DIALOG :: W_AddTrustedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: GetNewPermittedDomain

    SYNOPSIS:   Get a new permitted domain & password from the user,
                then update the SAM database accordingly.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: GetNewPermittedDomain( VOID )
{
    NLS_STR nlsDomain;
    NLS_STR nlsPassword;
    BOOL    fGotDomain = FALSE;

    //
    //  Ensure the strings constructed properly.
    //

    APIERR err = nlsDomain.QueryError();
    err = ( err != NERR_Success ) ? err : nlsPassword.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Prompt the user for the domain name & password.
        //

        ADD_PERMITTED_DIALOG * pDlg = new ADD_PERMITTED_DIALOG( this,
                                                                &nlsDomain,
                                                                &nlsPassword );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                               : pDlg->Process( &fGotDomain );

        delete pDlg;
    }

    //
    //  ADD_PERMITTED_DIALOG's OnOK method copies the new domain name into
    //  nlsDomain and the new password into nlsPassword.  This may leave
    //  either of these strings in an error state.
    //

    err = ( err != NERR_Success ) ? err : nlsDomain.QueryError();
    err = ( err != NERR_Success ) ? err : nlsPassword.QueryError();

    //
    //  Now we can actually update the SAM database.
    //  This may take a while...
    //

    AUTO_CURSOR cursor;
    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  See if the domain is already permitted to trust.  If it is,
        //  just select it & pretend we didn't get a domain.
        //

        INT cItems = _lbPermittedDomains.QueryCount();

        for( INT i = 0 ; i < cItems ; i++ )
        {
            PERMITTED_LBI * plbi = _lbPermittedDomains.QueryItem( i );
            UIASSERT( plbi != NULL );

            if( ::stricmpf( nlsDomain, plbi->QueryDomainName() ) == 0 )
            {
                //
                //  Found it!.
                //

                _lbPermittedDomains.SelectItem( i );
                fGotDomain = FALSE;
                err = IERR_UM_AlreadyPermitted;
                break;
            }
        }
    }

    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  Force a repaint of the dialog to elimiate any random
        //  half-drawn controls that were underneath the prompt dialog.
        //

        RepaintNow();

        //
        //  Update the SAM database.
        //

        err = W_AddPermittedDomain( nlsDomain,
                                    nlsPassword );
    }

    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  The SAM database was updated properly.
        //  Now, update the listbox.
        //

        PERMITTED_LBI * plbi = new PERMITTED_LBI( nlsDomain );
        INT iItem = _lbPermittedDomains.AddItem( plbi );

        if( iItem < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _lbPermittedDomains.SelectItem( iItem );
            _pbRemovePermitted.Enable( TRUE );
        }
    }

    if( ( err == NERR_Success ) && fGotDomain )
    {
        //
        //  Since we just committed a major change to the database,
        //  change the text of the "Cancel" button to "Close".
        //

        _pbCancel.SetText( _nlsCloseText );
    }

    return err;

}   // TRUST_DIALOG :: GetNewPermittedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: W_AddPermittedDomain

    SYNOPSIS:   Setup the "server" side of the trust relationship.

    ENTRY:      nlsDomainName           - Name of the domain allowed to
                                          trust "us".

                nlsPassword             - The allowed domain's password.

    EXIT:       If successful, then the server (trusted) side of the
                trust relationship has been established.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: W_AddPermittedDomain( NLS_STR & nlsDomainName,
                                             NLS_STR & nlsPassword )
{
    UIASSERT( nlsDomainName.QueryError() == NERR_Success );
    UIASSERT( nlsPassword.QueryError() == NERR_Success );

    //
    //  Tack on the account name postfix onto the domain name.
    //

    NLS_STR nlsPostfix;

    APIERR err = nlsPostfix.QueryError();

    if( err == NERR_Success )
    {
        err = nlsPostfix.MapCopyFrom( (WCHAR *)SSI_ACCOUNT_NAME_POSTFIX );
    }

    NLS_STR nlsDomainNameWithPostfix( nlsDomainName );

    if( err == NERR_Success )
    {
        err = nlsDomainNameWithPostfix.QueryError();
    }

    if( err == NERR_Success )
    {
        err = nlsDomainNameWithPostfix.Append( nlsPostfix );
    }

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Create the necessary SAM account.
    //

#if LOCAL_ADMIN_ONLY
    TRACEEOL(   "USRMGR: Creating SAM account on LOCAL MACHINE, not "
             << _padminauth->QueryServer() );

    USER_2 user2( nlsDomainNameWithPostfix );
#else   // !LOCAL_ADMIN_ONLY
    USER_2 user2( nlsDomainNameWithPostfix, _padminauth->QueryServer() );
#endif  // LOCAL_ADMIN_ONLY

    err = user2.QueryError();

    if( err == NERR_Success )
    {
        err = user2.CreateNew();
    }

    if( err == NERR_Success )
    {
        err = user2.SetPassword( nlsPassword );
    }

    if( err == NERR_Success )
    {
        user2.SetUserFlags( UF_INTERDOMAIN_TRUST_ACCOUNT | UF_SCRIPT );
        err = user2.Write();
    }

    return err;

}   // TRUST_DIALOG :: W_AddPermittedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: RemoveTrustedDomain

    SYNOPSIS:   Remove an existing trusted domain from the
                trusted domain list.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: RemoveTrustedDomain( VOID )
{
    TRUSTED_LBI * plbi = _lbTrustedDomains.QueryItem();
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  IDS_TRUST_WARN_DELETE_TRUSTED,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryDomainName(),
                  _nlsDomain,
                  MP_NO ) != IDYES )
    {
        return NERR_Success;
    }

    AUTO_CURSOR cursor;

    RepaintNow();

    APIERR err = W_NukeTrustedDomain( plbi );

    if( err == NERR_Success )
    {
        INT iItem  = _lbTrustedDomains.QueryCurrentItem();
        _lbTrustedDomains.DeleteItem( iItem );
        INT cItems = _lbTrustedDomains.QueryCount();

        if( cItems == 0 )
        {
            _pbRemoveTrusted.Enable( FALSE );
            _pbCancel.ClaimFocus();
        }
        else
        {
            if( iItem == cItems )
            {
                iItem--;
            }

            _lbTrustedDomains.SelectItem( iItem );
        }

        //
        //  Since we just committed a major change to the database,
        //  change the text of the "Cancel" button to "Close".
        //

        _pbCancel.SetText( _nlsCloseText );
    }

    return err;

}   // TRUST_DIALOG :: RemoveTrustedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: W_NukeTrustedDomain

    SYNOPSIS:   Remove an existing trusted domain from the PDC's
                trusted domain list.

    ENTRY:      plbi                    - The TRUSTED_LBI representing
                                          the domain to nuke.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: W_NukeTrustedDomain( const TRUSTED_LBI * plbi )
{
    UIASSERT( plbi != NULL );

    LSA_POLICY * plsapol = _padminauth->QueryLSAPolicy();
    UIASSERT( plsapol != NULL );

    ALIAS_STR nlsDomainName( plbi->QueryDomainName() );

    return plsapol->DistrustDomain( plbi->QueryDomainPSID(),
                                    nlsDomainName,
                                    FALSE );

}   // TRUST_DIALOG :: W_NukeTrustedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: RemovePermittedDomain

    SYNOPSIS:   Remove an existing SAM account for a domain we
                permit to trust us.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: RemovePermittedDomain( VOID )
{
    PERMITTED_LBI * plbi = _lbPermittedDomains.QueryItem();
    UIASSERT( plbi != NULL );

    if( MsgPopup( this,
                  IDS_TRUST_WARN_DELETE_PERMITTED,
                  MPSEV_WARNING,
                  MP_YESNO,
                  plbi->QueryDomainName(),
                  _nlsDomain,
                  MP_NO ) != IDYES )
    {
        return NERR_Success;
    }

    AUTO_CURSOR cursor;

    RepaintNow();

    APIERR err = W_NukePermittedDomain( plbi->QueryDomainName() );

    if( err == NERR_Success )
    {
        INT iItem  = _lbPermittedDomains.QueryCurrentItem();
        _lbPermittedDomains.DeleteItem( iItem );
        INT cItems = _lbPermittedDomains.QueryCount();

        if( cItems == 0 )
        {
            _pbRemovePermitted.Enable( FALSE );
            _pbCancel.ClaimFocus();
        }
        else
        {
            if( iItem == cItems )
            {
                iItem--;
            }

            _lbPermittedDomains.SelectItem( iItem );
        }

        //
        //  Since we just committed a major change to the database,
        //  change the text of the "Cancel" button to "Close".
        //

        _pbCancel.SetText( _nlsCloseText );
    }

    return err;

}   // TRUST_DIALOG :: RemovePermittedDomain


/*******************************************************************

    NAME:       TRUST_DIALOG :: W_NukePermittedDomain

    SYNOPSIS:   Remove an existing SAM account for a domain we
                permit to trust us.

    ENTRY:      pszDomainName           - The name of the domain we
                                          no longer allow to trust us.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUST_DIALOG :: W_NukePermittedDomain( const TCHAR * pszDomainName )
{
    UIASSERT( pszDomainName != NULL );

    //
    //  Tack on the account name postfix onto the domain name.
    //

    NLS_STR nlsPostfix;

    APIERR err = nlsPostfix.QueryError();

    if( err == NERR_Success )
    {
        err = nlsPostfix.MapCopyFrom( (WCHAR *)SSI_ACCOUNT_NAME_POSTFIX );
    }

    NLS_STR nlsDomainNameWithPostfix( pszDomainName );

    if( err == NERR_Success )
    {
        err = nlsDomainNameWithPostfix.QueryError();
    }

    if( err == NERR_Success )
    {
        err = nlsDomainNameWithPostfix.Append( nlsPostfix );
    }

    //
    //  Delete the SAM account.
    //

    if( err == NERR_Success )
    {
#if LOCAL_ADMIN_ONLY
        TRACEEOL(   "USRMGR: Creating SAM account on LOCAL_MACHINE, not "
                 << _padminauth->QueryServer() );

        USER_2 user2( nlsDomainNameWithPostfix );
#else   // !LOCAL_ADMIN_ONLY
        USER_2 user2( nlsDomainNameWithPostfix, _padminauth->QueryServer() );
#endif  // LOCAL_ADMIN_ONLY

        err = user2.QueryError();

        if( err == NERR_Success )
        {
            err = user2.GetInfo();
        }

        if( err == NERR_Success )
        {
            err = user2.Delete();
        }
    }

    return err;

}   // TRUST_DIALOG :: W_NukePermittedDomain


/*******************************************************************

    NAME:           TRUST_DIALOG :: AdjustButtons

    SYNOPSIS:       Enables/disables the "Remove" buttons to reflect
                    the current state of the listboxen.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
VOID TRUST_DIALOG :: AdjustButtons( VOID )
{
    _pbRemoveTrusted.Enable( _lbTrustedDomains.QuerySelCount() > 0 );
    _pbRemovePermitted.Enable( _lbPermittedDomains.QuerySelCount() > 0 );

}   // TRUST_DIALOG :: AdjustButtons



//
//  TRUSTED_LISTBOX methods
//

/*******************************************************************

    NAME:           TRUSTED_LISTBOX :: TRUSTED_LISTBOX

    SYNOPSIS:       TRUSTED_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pszDomainName       - The domain of focus.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUSTED_LISTBOX :: TRUSTED_LISTBOX( OWNER_WINDOW * powner,
                                    CID            cid,
                                    const TCHAR  * pszDomainName )
  : BLT_LISTBOX( powner, cid ),
    _nlsGullibleDomain( pszDomainName ),
    _pTrustedDomainEnum( NULL )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsGullibleDomain )
    {
        ReportError( _nlsGullibleDomain.QueryError() );
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     1,
                                     powner,
                                     cid,
                                     FALSE );

}   // TRUSTED_LISTBOX :: TRUSTED_LISTBOX


/*******************************************************************

    NAME:           TRUSTED_LISTBOX :: ~TRUSTED_LISTBOX

    SYNOPSIS:       TRUSTED_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUSTED_LISTBOX :: ~TRUSTED_LISTBOX( VOID )
{
    delete _pTrustedDomainEnum;
    _pTrustedDomainEnum = NULL;

}   // TRUSTED_LISTBOX :: ~TRUSTED_LISTBOX


/*******************************************************************

    NAME:           TRUSTED_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    ENTRY:          plsapol             - An LSA_POLICY for the domain's
                                          PDC.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUSTED_LISTBOX :: Fill( const LSA_POLICY * plsapol )
{
    UIASSERT( plsapol != NULL );

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    APIERR err;

    do
    {
        //
        //  Eliminate that annoying listbox flicker.
        //

        SetRedraw( FALSE );

        //
        //  Delete any existing enumerator.
        //

        delete _pTrustedDomainEnum;

        //
        //  Create a new trusted domain enumerator.
        //

        _pTrustedDomainEnum = new TRUSTED_DOMAIN_ENUM( plsapol );

        err = ( _pTrustedDomainEnum == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                              : _pTrustedDomainEnum->QueryError();

        err = ( err != NERR_Success ) ? err : _pTrustedDomainEnum->GetInfo();

        if( err != NERR_Success )
        {
            break;
        }

        //
        //  Now that we know it's safe, delete everything in the listbox.
        //

        DeleteAllItems();

        //
        //  It's enumeration time.
        //

        TRUSTED_DOMAIN_ENUM_ITER iterTrustedDomains( *_pTrustedDomainEnum );
        const TRUSTED_DOMAIN_ENUM_OBJ * pobjTrust;

        while( ( pobjTrust = iterTrustedDomains( &err ) ) != NULL )
        {
            TRUSTED_LBI * plbi = new TRUSTED_LBI( pobjTrust );

            if( AddItem( plbi ) < 0 )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if( err != NERR_Success )
        {
            break;
        }

        if( QueryCount() > 0 )
        {
            //
            //  Select the first item.
            //

            SelectItem( 0 );
        }

    } while( FALSE );

    //
    //  Enable redraw & force a refresh.
    //

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // TRUSTED_LISTBOX :: Fill


//
//  TRUSTED_LBI methods
//

/*******************************************************************

    NAME:           TRUSTED_LBI :: TRUSTED_LBI

    SYNOPSIS:       TRUSTED_LBI class constructor.

    ENTRY:          pobjDomain          - A TRUSTED_DOMAIN_ENUM_OBJ
                                          representing the trusted domain.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUSTED_LBI :: TRUSTED_LBI( const TRUSTED_DOMAIN_ENUM_OBJ * pobjDomain )
  : LBI(),
    _bufferSID(),
    _nlsDomain(),
    _psidDomain( NULL_PSID )
{
    UIASSERT( pobjDomain != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomain )
    {
        ReportError( _nlsDomain.QueryError() );
        return;
    }

    if( !_bufferSID )
    {
        ReportError( _bufferSID.QueryError() );
        return;
    }

    APIERR err = pobjDomain->QueryDomainName( &_nlsDomain );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Since a PSID is a real pointer into some quasi-random
    //  chuck of memory, make a copy so we can reference it later.
    //

    err = DuplicateSID( pobjDomain->QueryDomainSID() );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // TRUSTED_LBI :: TRUSTED_LBI


/*******************************************************************

    NAME:           TRUSTED_LBI :: TRUSTED_LBI

    SYNOPSIS:       TRUSTED_LBI class constructor.

    ENTRY:          pszDomain           - The name of the trusted domain.

                    psidDomain          - The domain's SID.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
TRUSTED_LBI :: TRUSTED_LBI( const TCHAR * pszDomain,
                            PSID          psidDomain )
  : LBI(),
    _bufferSID(),
    _nlsDomain( pszDomain ),
    _psidDomain( NULL_PSID )
{
    UIASSERT( pszDomain != NULL );
    UIASSERT( psidDomain != NULL_PSID );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomain )
    {
        ReportError( _nlsDomain.QueryError() );
        return;
    }

    if( !_bufferSID )
    {
        ReportError( _bufferSID.QueryError() );
        return;
    }

    //
    //  Since a PSID is a real pointer into some quasi-random
    //  chuck of memory, make a copy so we can reference it later.
    //

    APIERR err = DuplicateSID( psidDomain );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // TRUSTED_LBI :: TRUSTED_LBI


/*******************************************************************

    NAME:           TRUSTED_LBI :: ~TRUSTED_LBI

    SYNOPSIS:       TRUSTED_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
TRUSTED_LBI :: ~TRUSTED_LBI()
{
    _psidDomain = NULL_PSID;

}   // TRUSTED_LBI :: ~TRUSTED_LBI


/*******************************************************************

    NAME:           TRUSTED_LBI :: DuplicateSID

    SYNOPSIS:       Duplicates the specified SID into the LBI's
                    BUFFER object.

    ENTRY:          psid                - The SID to duplicate.

    EXIT:           If successful, then _bufferSID has been resized
                    and the SID copied into said buffer.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR TRUSTED_LBI :: DuplicateSID( PSID psid )
{
    UIASSERT( psid != NULL_PSID );
    UIASSERT( ::RtlValidSid( psid ) );
    UIASSERT( _psidDomain == NULL_PSID );

    //
    //  Retrieve the SID's length.
    //

    ULONG cbSID = ::RtlLengthSid( psid );

    APIERR err = ( cbSID > UINT_MAX ) ? ERROR_NOT_ENOUGH_MEMORY
                                      : NERR_Success;

    if( err == NERR_Success )
    {
        //
        //  Resize our buffer object.
        //

        APIERR err = _bufferSID.Resize( (UINT)cbSID );
    }

    if( err == NERR_Success )
    {
        //
        //  Save the pointer to the new SID.
        //

        _psidDomain = (PSID)_bufferSID.QueryPtr();

        //
        //  Copy the SID into its new home.
        //

        err = ERRMAP::MapNTStatus( ::RtlCopySid( (ULONG)_bufferSID.QuerySize(),
                                                 _psidDomain,
                                                 psid ) );
    }

    return err;

}   // TRUSTED_LBI :: DuplicateSID


/*******************************************************************

    NAME:           TRUSTED_LBI :: Paint

    SYNOPSIS:       Draw an entry in TRUSTED_LISTBOX.

    ENTRY:          plb                 - Pointer to a LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/
VOID TRUSTED_LBI :: Paint( LISTBOX      * plb,
                           HDC            hdc,
                           const RECT   * prect,
                           GUILTT_INFO  * pGUILTT ) const
{
    STR_DTE dteDomain( _nlsDomain );

    DISPLAY_TABLE dtab( 1, ((TRUSTED_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteDomain;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // TRUSTED_LBI :: Paint


/*******************************************************************

    NAME:       TRUSTED_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
WCHAR TRUSTED_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsDomain );

    return _nlsDomain.QueryChar( istr );

}   // TRUSTED_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       TRUSTED_LBI :: Compare

    SYNOPSIS:   Compare two TRUSTED_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
INT TRUSTED_LBI :: Compare( const LBI * plbi ) const
{
    const TRUSTED_LBI * ptlbi = (const TRUSTED_LBI *)plbi;

    return _nlsDomain._stricmp( ptlbi->_nlsDomain );

}   // TRUSTED_LBI :: Compare



//
//  PERMITTED_LISTBOX methods
//

/*******************************************************************

    NAME:           PERMITTED_LISTBOX :: PERMITTED_LISTBOX

    SYNOPSIS:       PERMITTED_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pszPermittingDomain - The name of the "permitting"
                                          domain.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
PERMITTED_LISTBOX :: PERMITTED_LISTBOX( OWNER_WINDOW * powner,
                                        CID            cid,
                                        const TCHAR  * pszPermittingDomain )
  : BLT_LISTBOX( powner, cid ),
    _nlsPermittingDomain( pszPermittingDomain )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsPermittingDomain )
    {
        ReportError( _nlsPermittingDomain.QueryError() );
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     1,
                                     powner,
                                     cid,
                                     FALSE );

}   // PERMITTED_LISTBOX :: PERMITTED_LISTBOX


/*******************************************************************

    NAME:           PERMITTED_LISTBOX :: ~PERMITTED_LISTBOX

    SYNOPSIS:       PERMITTED_LISTBOX class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
PERMITTED_LISTBOX :: ~PERMITTED_LISTBOX( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // PERMITTED_LISTBOX :: ~PERMITTED_LISTBOX


/*******************************************************************

    NAME:           PERMITTED_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available services.

    ENTRY:          psamdom             - A SAM_DOMAIN for the PDC.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
APIERR PERMITTED_LISTBOX :: Fill( const SAM_DOMAIN * psamdom )
{
    UIASSERT( psamdom != NULL );

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    APIERR err;

    do
    {
        //
        //  Eliminate that annoying listbox flicker.
        //

        SetRedraw( FALSE );

        //
        //  Create the SAM user enumerator.
        //

        SAM_USER_ENUM enumSamUsers( psamdom,
                                    USER_INTERDOMAIN_TRUST_ACCOUNT );

        if( !enumSamUsers )
        {
            err = enumSamUsers.QueryError();
            break;
        }

        err = enumSamUsers.GetInfo();

        if( err != NERR_Success )
        {
            break;
        }

        //
        //  Now that we know it's safe, delete everything in the listbox.
        //

        DeleteAllItems();

        //
        //  It's enumeration time.
        //

        SAM_USER_ENUM_ITER iterSamUsers( enumSamUsers );
        const SAM_USER_ENUM_OBJ * pobjUser;

        while( ( pobjUser = iterSamUsers( &err ) ) != NULL )
        {
            const UNICODE_STRING * punicode = pobjUser->QueryUnicodeUserName();
            UIASSERT( punicode != NULL );
            WCHAR * pwch = (WCHAR *)punicode->Buffer +
                                ( punicode->Length / sizeof(WCHAR) ) - 1;
            UIASSERT( pwch != NULL );

            //
            //  Remove the trailing '$'.
            //
            //  BUGBUG!  Move this into the PERMITTED_LBI constructor!
            //

            *pwch = L'\0';

            PERMITTED_LBI * plbi = new PERMITTED_LBI( pobjUser );

            if( AddItem( plbi ) < 0 )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }

        if( err != NERR_Success )
        {
            break;
        }

        if( QueryCount() > 0 )
        {
            //
            //  Select the first item.
            //

            SelectItem( 0 );
        }

    } while( FALSE );

    //
    //  Enable redraw & force a refresh.
    //

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // PERMITTED_LISTBOX :: Fill


//
//  PERMITTED_LBI methods
//

/*******************************************************************

    NAME:           PERMITTED_LBI :: PERMITTED_LBI

    SYNOPSIS:       PERMITTED_LBI class constructor.

    ENTRY:          pobjUser            - A SAM_USER_ENUM_OBJ
                                          representing the "permitted"
                                          domain.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
PERMITTED_LBI :: PERMITTED_LBI( const SAM_USER_ENUM_OBJ * pobjUser )
  : LBI(),
    _nlsDomain()
{
    UIASSERT( pobjUser != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomain )
    {
        ReportError( _nlsDomain.QueryError() );
        return;
    }

    APIERR err = pobjUser->QueryUserName( &_nlsDomain );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // PERMITTED_LBI :: PERMITTED_LBI


/*******************************************************************

    NAME:           PERMITTED_LBI :: PERMITTED_LBI

    SYNOPSIS:       PERMITTED_LBI class constructor.

    ENTRY:          pszDomain           - Name of the "permitted" domain.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
PERMITTED_LBI :: PERMITTED_LBI( const TCHAR * pszDomain )
  : LBI(),
    _nlsDomain( pszDomain )
{
    UIASSERT( pszDomain != NULL );

    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomain )
    {
        ReportError( _nlsDomain.QueryError() );
        return;
    }

}   // PERMITTED_LBI :: PERMITTED_LBI


/*******************************************************************

    NAME:           PERMITTED_LBI :: ~PERMITTED_LBI

    SYNOPSIS:       PERMITTED_LBI class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
PERMITTED_LBI :: ~PERMITTED_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // PERMITTED_LBI :: ~PERMITTED_LBI


/*******************************************************************

    NAME:           PERMITTED_LBI :: Paint

    SYNOPSIS:       Draw an entry in PERMITTED_LISTBOX.

    ENTRY:          plb                 - Pointer to a LISTBOX.

                    hdc                 - The DC to draw upon.

                    prect               - Clipping rectangle.

                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/

VOID PERMITTED_LBI :: Paint( LISTBOX      * plb,
                             HDC            hdc,
                             const RECT   * prect,
                             GUILTT_INFO  * pGUILTT ) const
{
    STR_DTE dteDomain( _nlsDomain );

    DISPLAY_TABLE dtab( 1, ((PERMITTED_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteDomain;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // PERMITTED_LBI :: Paint


/*******************************************************************

    NAME:       PERMITTED_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
WCHAR PERMITTED_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsDomain );

    return _nlsDomain.QueryChar( istr );

}   // PERMITTED_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       PERMITTED_LBI :: Compare

    SYNOPSIS:   Compare two PERMITTED_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
        KeithMo     08-Apr-1992 Created for the User Manager.

********************************************************************/
INT PERMITTED_LBI :: Compare( const LBI * plbi ) const
{
    const PERMITTED_LBI * ptlbi = (const PERMITTED_LBI *)plbi;

    return _nlsDomain._stricmp( ptlbi->_nlsDomain );

}   // PERMITTED_LBI :: Compare



//
//  ADD_TRUST_DIALOG methods.
//

/*******************************************************************

    NAME:           ADD_TRUST_DIALOG :: ADD_TRUST_DIALOG

    SYNOPSIS:       ADD_TRUST_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pnlsDomainName      - Will receive the domain entered.

                    pnlsPassword        - Will receive the password entered.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
ADD_TRUST_DIALOG :: ADD_TRUST_DIALOG( TRUST_DIALOG * pdlgTrust,
                                      NLS_STR * pnlsDomainName,
                                      NLS_STR * pnlsPassword )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_ADD_TRUSTED_DOMAIN ),
                   ((OWNER_WINDOW *)pdlgTrust)->QueryHwnd(),
#ifdef FE_SB
                FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
#else
                TRUE                   // Use Ansi form of dialog to
                                       // canonicalize the computernames
#endif
                ),
    _pdlgTrust( pdlgTrust ),
    _sleDomainName( this, IDAT_DOMAIN, MAX_DOMAIN_LENGTH ),
    _password( this, IDAT_PASSWORD, MAX_PASSWORD_LENGTH ),
    _pnlsDomainName( pnlsDomainName ),
    _pnlsPassword( pnlsPassword ),
    _nlsTmpDomain( MAX_DOMAIN_LENGTH ),
    _nlsTmpPassword( MAX_PASSWORD_LENGTH )
{
    UIASSERT( pnlsDomainName != NULL );
    UIASSERT( pnlsPassword != NULL );
    UIASSERT( pnlsDomainName->QueryError() == NERR_Success );
    UIASSERT( pnlsPassword->QueryError() == NERR_Success );

    //
    //  Let's make sure everything constructed OK.
    //

    APIERR err;

    if( ( ( err = QueryError()                 ) != NERR_Success ) ||
        ( ( err = _nlsTmpDomain.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsTmpPassword.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // ADD_TRUST_DIALOG :: ADD_TRUST_DIALOG


/*******************************************************************

    NAME:           ADD_TRUST_DIALOG :: ~ADD_TRUST_DIALOG

    SYNOPSIS:       ADD_TRUST_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
ADD_TRUST_DIALOG :: ~ADD_TRUST_DIALOG( VOID )
{
    _pnlsDomainName = NULL;
    _pnlsPassword   = NULL;

}   // ADD_TRUST_DIALOG :: ~ADD_TRUST_DIALOG



/*******************************************************************

    NAME:           ADD_TRUST_DIALOG :: QueryHelpContext

    HISTORY:
        thomaspa     31-Apr-1992 Created for the User Manager.

********************************************************************/
ULONG ADD_TRUST_DIALOG :: QueryHelpContext( VOID )
{
    return HC_UM_ADD_TRUSTED_LANNT + _pdlgTrust->QueryAdminApp()->QueryHelpOffset();
}



/*******************************************************************

    NAME:       ADD_TRUST_DIALOG :: OnOK

    SYNOPSIS:   Invoked when the user presses OK.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
BOOL ADD_TRUST_DIALOG :: OnOK( VOID )
{
    REQUIRE( _sleDomainName.QueryText( &_nlsTmpDomain ) == NERR_Success );
    REQUIRE( _password.QueryText( &_nlsTmpPassword ) == NERR_Success );

    MSGID idMsg = 0;    // until proven otherwise...
    CONTROL_WINDOW * pctrlBad = NULL;

    //
    //  Validate that the domain name & password are OK.
    //
    NLS_STR nlsFocusDom;
    LSA_POLICY * plsapolFocus
                = _pdlgTrust->QueryAdminAuthority()->QueryLSAPolicy();
    APIERR err = plsapolFocus->QueryPrimaryDomainName( &nlsFocusDom );

    if( ::I_MNetNameValidate( NULL,
                              _nlsTmpDomain,
                              NAMETYPE_DOMAIN,
                              0 ) != NERR_Success )
    {
        idMsg = IERR_UM_DomainInvalid;
        pctrlBad = (CONTROL_WINDOW *)&_sleDomainName;
    }
    else
    if ( err == NERR_Success && _nlsTmpDomain._stricmp( nlsFocusDom ) == 0 )
    {
        // Make sure we aren't trying to trust ourselves
        idMsg = IERR_UM_CantTrustYourself;
        pctrlBad = (CONTROL_WINDOW *)&_sleDomainName;
    }
    else
    if( ::I_MNetNameValidate( NULL,
                              _nlsTmpPassword,
                              NAMETYPE_PASSWORD,
                              0 ) != NERR_Success )
    {
        idMsg = IERR_UM_PasswordInvalid;
        pctrlBad = (CONTROL_WINDOW *)&_password;
    }
    else
    {
        //
        //  Everything is cool, so update the caller's
        //  domain name & password.
        //

        *_pnlsDomainName = _nlsTmpDomain;
        *_pnlsPassword   = _nlsTmpPassword;
    }

    if( idMsg == 0 )
    {
        UIASSERT( pctrlBad == NULL );

        //
        //  idMsg will only be 0 if all dialog
        //  controls were verified.  So, we can
        //  dismiss the dialog.
        //

        Dismiss( TRUE );
    }
    else
    {
        UIASSERT( pctrlBad != NULL );

        //
        //  Something failed validation.  Tell the user
        //  the bad news, clear the control, then set the
        //  input focus to the offending control.
        //

        MsgPopup( this,
                  idMsg,
                  MPSEV_WARNING,
                  IDOK );

        if( pctrlBad == (CONTROL_WINDOW *)&_password )
        {
            _password.SetText( SZ("") );
        }

        pctrlBad->ClaimFocus();
    }

    return TRUE;

}   // ADD_TRUST_DIALOG :: OnOK



//
//  ADD_PERMITTED_DIALOG methods.
//

/*******************************************************************

    NAME:           ADD_PERMITTED_DIALOG :: ADD_PERMITTED_DIALOG

    SYNOPSIS:       ADD_PERMITTED_DIALOG class constructor.

    ENTRY:          hWndOwner           - The owning window.

                    pnlsDomainName      - Will receive the domain entered.

                    pnlsPassword        - Will receive the password entered.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
ADD_PERMITTED_DIALOG :: ADD_PERMITTED_DIALOG( TRUST_DIALOG * pdlgTrust,
                                              NLS_STR * pnlsDomainName,
                                              NLS_STR * pnlsPassword )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_PERMIT_DOMAIN ),
                   ((OWNER_WINDOW *)pdlgTrust)->QueryHwnd(),
#ifdef FE_SB
                FALSE                  // Use Unicode form of dialog to
                                       // canonicalize the computernames
#else
                TRUE                   // Use Ansi form of dialog to
                                       // canonicalize the computernames
#endif
                ),
    _pdlgTrust( pdlgTrust ),
    _sleDomainName( this, IDPD_DOMAIN, MAX_DOMAIN_LENGTH ),
    _password( this, IDPD_PASSWORD, MAX_PASSWORD_LENGTH ),
    _passwordConfirm( this, IDPD_CONFIRM_PASSWORD, MAX_PASSWORD_LENGTH ),
    _pnlsDomainName( pnlsDomainName ),
    _pnlsPassword( pnlsPassword ),
    _nlsTmpPassword( MAX_PASSWORD_LENGTH ),
    _nlsTmpConfirm( MAX_PASSWORD_LENGTH ),
    _nlsTmpDomain( MAX_DOMAIN_LENGTH )
{
    UIASSERT( pnlsDomainName != NULL );
    UIASSERT( pnlsPassword != NULL );
    UIASSERT( pnlsDomainName->QueryError() == NERR_Success );
    UIASSERT( pnlsPassword->QueryError() == NERR_Success );

    //
    //  Let's make sure everything constructed OK.
    //

    APIERR err;

    if( ( ( err = QueryError()                 ) != NERR_Success ) ||
        ( ( err = _nlsTmpDomain.QueryError()   ) != NERR_Success ) ||
        ( ( err = _nlsTmpPassword.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsTmpConfirm.QueryError()  ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // ADD_PERMITTED_DIALOG :: ADD_PERMITTED_DIALOG


/*******************************************************************

    NAME:           ADD_PERMITTED_DIALOG :: ~ADD_PERMITTED_DIALOG

    SYNOPSIS:       ADD_PERMITTED_DIALOG class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
ADD_PERMITTED_DIALOG :: ~ADD_PERMITTED_DIALOG( VOID )
{
    _pnlsDomainName = NULL;
    _pnlsPassword   = NULL;

}   // ADD_PERMITTED_DIALOG :: ~ADD_PERMITTED_DIALOG


/*******************************************************************

    NAME:       ADD_PERMITTED_DIALOG :: OnOK

    SYNOPSIS:   Invoked when the user presses OK.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        KeithMo     16-Apr-1992 Created for the User Manager.

********************************************************************/
BOOL ADD_PERMITTED_DIALOG :: OnOK( VOID )
{
    REQUIRE( _sleDomainName.QueryText( &_nlsTmpDomain ) == NERR_Success );
    REQUIRE( _password.QueryText( &_nlsTmpPassword ) == NERR_Success );
    REQUIRE( _passwordConfirm.QueryText( &_nlsTmpConfirm ) == NERR_Success );

    MSGID idMsg = 0;    // until proven otherwise...
    CONTROL_WINDOW * pctrlBad = NULL;

    //
    //  Validate that the domain name & password are OK.
    //  Also validate that the password matches the confirmation
    //  password.
    //
    NLS_STR nlsFocusDom;
    LSA_POLICY * plsapolFocus
                = _pdlgTrust->QueryAdminAuthority()->QueryLSAPolicy();
    APIERR err = plsapolFocus->QueryPrimaryDomainName( &nlsFocusDom );

    if( ::I_MNetNameValidate( NULL,
                              _nlsTmpDomain,
                              NAMETYPE_DOMAIN,
                              0 ) != NERR_Success )
    {
        idMsg = IERR_UM_DomainInvalid;
        pctrlBad = (CONTROL_WINDOW *)&_sleDomainName;
    }
    else
    if ( err == NERR_Success && _nlsTmpDomain._stricmp(nlsFocusDom) == 0 )
    {
        // Make sure we aren't trying to trust ourselves
        idMsg = IERR_UM_CantTrustYourself;
        pctrlBad = (CONTROL_WINDOW *)&_sleDomainName;
    }
    else
    if( _nlsTmpPassword.strcmp( _nlsTmpConfirm ) != 0 )
    {
        idMsg = IERR_UM_PasswordMismatch;
        pctrlBad = (CONTROL_WINDOW *)&_password;
    }
    else
    if( ::I_MNetNameValidate( NULL,
                              _nlsTmpPassword,
                              NAMETYPE_PASSWORD,
                              0 ) != NERR_Success )
    {
        idMsg = IERR_UM_PasswordInvalid;
        pctrlBad = (CONTROL_WINDOW *)&_password;
    }
    else
    {
        //
        //  Everything is cool, so update the caller's
        //  domain name & password.
        //

        *_pnlsDomainName = _nlsTmpDomain;
        *_pnlsPassword   = _nlsTmpPassword;
    }

    if( idMsg == 0 )
    {
        UIASSERT( pctrlBad == NULL );

        //
        //  idMsg will only be 0 if all dialog
        //  controls were verified.  So, we can
        //  dismiss the dialog.
        //

        Dismiss( TRUE );
    }
    else
    {
        UIASSERT( pctrlBad != NULL );

        //
        //  Something failed validation.  Tell the user
        //  the bad news, clear the control, then set the
        //  input focus to the offending control.
        //

        MsgPopup( this,
                  idMsg,
                  MPSEV_WARNING,
                  IDOK );

        if( pctrlBad == (CONTROL_WINDOW *)&_password )
        {
            //
            //  If something related to passwords failed
            //  validation, we need to also clear the
            //  confirmation SLE.
            //

            _password.SetText( SZ("") );
            _passwordConfirm.SetText( SZ("") );
        }

        pctrlBad->ClaimFocus();
    }

    return TRUE;

}   // ADD_PERMITTED_DIALOG :: OnOK



/*******************************************************************

    NAME:           ADD_PERMITTED_DIALOG :: QueryHelpContext

    HISTORY:
        thomaspa     31-Apr-1992 Created for the User Manager.

********************************************************************/
ULONG ADD_PERMITTED_DIALOG :: QueryHelpContext( VOID )
{
    return HC_UM_PERMIT_TRUST_LANNT + _pdlgTrust->QueryAdminApp()->QueryHelpOffset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\uconfig.cxx ===
/*******************************************************************************
*
*   uconfig.cxx
*   USER_CONFIG class implementation
*
*   Implementation file for the Citrix User Configuration data object class
*
*  Copyright Citrix Systems Inc. 1994
*
*  Author: Butch Davis
*
*  $Log:   N:\nt\private\net\ui\admin\user\user\citrix\VCS\uconfig.cxx  $
*  
*     Rev 1.11   13 Jan 1998 09:25:32   donm
*  removed encryption settings
*  
*     Rev 1.10   Oct 08 1997 14:19:28   scottc
*  added WFHomeDir
*  
*     Rev 1.9   24 Feb 1997 11:27:42   butchd
*  CPR 4660: properly saves User Configuration when either OK or Close pressed
*  
*     Rev 1.8   25 Jul 1996 16:35:24   chrisc
*  Add WinFrame profile path to USERCONFIG class
*
*     Rev 1.7   16 Jul 1996 16:46:54   TOMA
*  force client lpt to default
*
*     Rev 1.6   16 Jul 1996 15:09:00   TOMA
*  force client lpt to def
*
*     Rev 1.6   15 Jul 1996 18:06:34   TOMA
*  force client lpt to def
*
*     Rev 1.5   28 Feb 1996 13:29:36   butchd
*  CPR 2192/Incident 14904hq: Map Root home directory enhancement
*
*     Rev 1.4   21 Nov 1995 15:39:00   billm
*  CPR 404, Added NWLogon configuration dialog
*
*     Rev 1.3   19 May 1995 09:43:02   butchd
*  update
*
*     Rev 1.2   18 May 1995 10:14:34   butchd
*  NT 3.51 sync
*
*     Rev 1.1   09 Dec 1994 16:50:28   butchd
*  update
*
*******************************************************************************/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_NETLIB
#define INCL_ICANON
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_SETCONTROL
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_TIME_DATE
#include <blt.hxx>

// usrmgrrc.h must be included after blt.hxx (more exactly, after bltrc.h)
extern "C"
{
    #include <usrmgrrc.h>
    #include <mnet.h>
    #include <ntsam.h>
    #include <ntlsa.h>
    #include <ntseapi.h>
    #include <umhelpc.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>

#include "uconfig.hxx"  // will include <citrix\winsta.h>


/*******************************************************************

    NAME:       USER_CONFIG::USER_CONFIG

    SYNOPSIS:   Constructor for USER_CONFIG class

    ENTRY:      pszUserName -   name of user for USERCONFIG data
                pszServerName - name of server for USERCONFIG data

********************************************************************/


USER_CONFIG::USER_CONFIG( const TCHAR *pszUserName,
                          const TCHAR *pszServerName )
        :
            _nlsUserName(),
            _nlsServerName(),

            _fAllowLogon(),
            _ulConnection(),
            _ulDisconnection(),
            _ulIdle(),
            _nlsInitialProgram(),
            _nlsWorkingDirectory(),
            _fClientSpecified(),
            _fAutoClientDrives(),
            _fAutoClientLpts(),
            _fForceClientLptDef(),
            _fHomeDirectoryMapRoot(),
            _iBroken(),
            _iReconnect(),
            _iCallback(),
            _nlsPhoneNumber(),
            _nlsNWLogonServer(),
            _nlsWFProfilePath(),
            _iShadow(),
            _nlsWFHomeDir(),
            _nlsWFHomeDirDrive()

{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _nlsUserName.QueryError()) != NERR_Success)
        || ((err = _nlsServerName.QueryError()) != NERR_Success)
        || ((err = _nlsInitialProgram.QueryError()) != NERR_Success)
        || ((err = _nlsWorkingDirectory.QueryError()) != NERR_Success)
        || ((err = _nlsPhoneNumber.QueryError()) != NERR_Success)
        || ((err = _nlsUserName.
                        CopyFrom( pszUserName?
                                    pszUserName : SZ("") )) != NERR_Success)
        || ((err = _nlsServerName.CopyFrom(pszServerName)) != NERR_Success)
        || ((err = _nlsNWLogonServer.QueryError()) != NERR_Success)
        || ((err = _nlsWFProfilePath.QueryError()) != NERR_Success)
        || ((err = _nlsWFHomeDir.QueryError())     != NERR_Success)
        || ((err = _nlsWFHomeDirDrive.QueryError())     != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       USER_CONFIG::GetInfo

    SYNOPSIS:   Gets specified user's userconfig data

    ENTRY:

********************************************************************/

APIERR USER_CONFIG::GetInfo()
{
    APIERR err;
    ULONG Length;
    USERCONFIG UserConfig;

    if ( (err = RegUserConfigQuery( (WCHAR *)_nlsServerName.QueryPch(),
                                    (WCHAR *)_nlsUserName.QueryPch(),
                                    &UserConfig,
                                    sizeof(UserConfig),
                                    &Length )) == NERR_Success ) {
        
        err = UCStructToMembers( &UserConfig );
    }
    
    _fWFHomeDirDirty = FALSE;    
    _fDirty = FALSE;
    return err ;
}


/*******************************************************************

    NAME:       USER_CONFIG::SetDefaults

    SYNOPSIS:   Initializes default user configuration values to the
                settings indicated by the default USERCONFIG structure.

    ENTRY:      pDefaultUCStruct - default USERCONFIG structure.

********************************************************************/

VOID USER_CONFIG::SetDefaults( PUSERCONFIG pDefaultUCStruct )
{
    /* Set the member variables from the specified USERCONFIG structure
     * contents and flag object as 'not dirty'.
     */
    UCStructToMembers( pDefaultUCStruct );
    _fDirty = FALSE;
    _fWFHomeDirDirty = FALSE;
}


/*******************************************************************

    NAME:       USER_CONFIG::SetInfo

    SYNOPSIS:   Sets specified user's userconfig data if the object is 'dirty'.

    ENTRY:

    NOTES:      This method will reset the 'dirty' flag.

********************************************************************/

APIERR USER_CONFIG::SetInfo()
{
    APIERR err;
    USERCONFIG UserConfig;
    USERCONFIG ucCurrent;

    /* If the object is not 'dirty', no need to save info.
     */
    if ( !_fDirty )
        return NERR_Success;

    /* Zero-initialize USERCONFIG structure and copy member variable
     * contents there.
     */
    ::memsetf( &UserConfig, 0x0, sizeof(USERCONFIG) );
    MembersToUCStruct( &UserConfig );
    
    DWORD Length = 0;

    err = RegUserConfigQuery( (WCHAR *)_nlsServerName.QueryPch(),
                                    (WCHAR *)_nlsUserName.QueryPch(),
                                    &ucCurrent,
                                    sizeof( USERCONFIG ),
                                    &Length );
 
	// see if our current state has changed
	if( err != ERROR_SUCCESS )
	{
		// we could be setting properties of a new user object that has no
		// TS specific properties set.  The return error is file_not_found
		// this error is blanketed and we can proceed on.
		// all other errors we need to report.
		
		if( err != ERROR_FILE_NOT_FOUND )
		{
			return err;
		}

		err = ERROR_SUCCESS;
	}


    if( memcmp( &UserConfig , &ucCurrent , sizeof( USERCONFIG ) ) != 0 )
    {
    /*
     * Save user's configuration.
     */
        err = RegUserConfigSet( (WCHAR *)_nlsServerName.QueryPch(),
                            (WCHAR *)_nlsUserName.QueryPch(),
                            &UserConfig,
                            sizeof(UserConfig) );
    }

//  Don't reset 'dirty' flag to behave properly with new RegUserConfig APIs
//  (we might get called twice, just like the UsrMgr objects to, so we want
//   to happily write our our data twice, just like they do)
//    _fDirty = FALSE;

//
//  By not setting _fDirty = FALSE here we try to check the validity of the RemoteWFHomeDir whenever OK is pressed
//  This is because MS used 2 structures to hold its HomeDir, and could compare the two.  We only have one and rely
//  on this dirty flag.  This flag is used in USERPROP_DLG::I_PerformOne_Write(...) and is set in the
//  USER_CONFIG::GetInfo and USER_CONFIG::GetDefaults and USERPROF_DLG_NT::PerformOne()
//
    _fWFHomeDirDirty = FALSE;


    return err;
}


/*******************************************************************

    NAME:       USER_CONFIG::UCStructToMembers

    SYNOPSIS:   Copies a given USERCONFIG structure elements into
                corresponding member variables.

    ENTRY:      pUCStruct - pointer to USERCONFIG structure.

********************************************************************/

APIERR USER_CONFIG::UCStructToMembers( PUSERCONFIG pUCStruct )
{
    APIERR err;

    _fAllowLogon = (BOOL)!pUCStruct->fLogonDisabled;
    _ulConnection = pUCStruct->MaxConnectionTime;
    _ulDisconnection = pUCStruct->MaxDisconnectionTime;
    _ulIdle = pUCStruct->MaxIdleTime;
    err = _nlsInitialProgram.CopyFrom( pUCStruct->InitialProgram );
    if ( err == NERR_Success )
        err = _nlsWorkingDirectory.CopyFrom( pUCStruct->WorkDirectory );
    _fClientSpecified = pUCStruct->fInheritInitialProgram;
    _fAutoClientDrives = pUCStruct->fAutoClientDrives;
    _fAutoClientLpts = pUCStruct->fAutoClientLpts;
    _fForceClientLptDef = pUCStruct->fForceClientLptDef;
    _fHomeDirectoryMapRoot = pUCStruct->fHomeDirectoryMapRoot;
    _iBroken = (INT)pUCStruct->fResetBroken;
    _iReconnect = (INT)pUCStruct->fReconnectSame;
    _iCallback = (INT)pUCStruct->Callback;
    if ( err == NERR_Success )
        err = _nlsPhoneNumber.CopyFrom( pUCStruct->CallbackNumber );
    _iShadow = (INT)pUCStruct->Shadow;
    if ( err == NERR_Success )
        err = _nlsNWLogonServer.CopyFrom( pUCStruct->NWLogonServer );
    if ( err == NERR_Success )
        err = _nlsWFProfilePath.CopyFrom( pUCStruct->WFProfilePath );
    if ( err == NERR_Success )
        err = _nlsWFHomeDir.CopyFrom( pUCStruct->WFHomeDir );
    if ( err == NERR_Success )
        err = _nlsWFHomeDirDrive.CopyFrom( pUCStruct->WFHomeDirDrive);


    return err;
}


/*******************************************************************

    NAME:       USER_CONFIG::MembersToUCStruct

    SYNOPSIS:   Copies member variables into a given USERCONFIG
                structure elements.

    ENTRY:      pUCStruct - pointer to USERCONFIG structure.

********************************************************************/

VOID USER_CONFIG::MembersToUCStruct( PUSERCONFIG pUCStruct )
{
    pUCStruct->fLogonDisabled = !_fAllowLogon;
    pUCStruct->MaxConnectionTime = _ulConnection;
    pUCStruct->MaxDisconnectionTime = _ulDisconnection;
    pUCStruct->MaxIdleTime = _ulIdle;
    strcpy( pUCStruct->InitialProgram, _nlsInitialProgram.QueryPch() );
    strcpy( pUCStruct->WorkDirectory, _nlsWorkingDirectory.QueryPch() );
    pUCStruct->fInheritInitialProgram = _fClientSpecified;
    pUCStruct->fAutoClientDrives = _fAutoClientDrives;
    pUCStruct->fAutoClientLpts = _fAutoClientLpts;
    pUCStruct->fForceClientLptDef = _fForceClientLptDef;
    pUCStruct->fHomeDirectoryMapRoot = _fHomeDirectoryMapRoot;
    pUCStruct->fResetBroken = _iBroken;
    pUCStruct->fReconnectSame = _iReconnect;
    pUCStruct->Callback = (CALLBACKCLASS)_iCallback;
    strcpy( pUCStruct->CallbackNumber, _nlsPhoneNumber.QueryPch() );
    pUCStruct->Shadow = (SHADOWCLASS)_iShadow;
    strcpy( pUCStruct->NWLogonServer, _nlsNWLogonServer.QueryPch() );
    strcpy( pUCStruct->WFProfilePath, _nlsWFProfilePath.QueryPch() );
    strcpy( pUCStruct->WFHomeDir, _nlsWFHomeDir.QueryPch() );
    strcpy( pUCStruct->WFHomeDirDrive, _nlsWFHomeDirDrive.QueryPch() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\umembdlg.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    umembdlg.cxx
    USER_MEMB_DIALOG class implementation

    NTISSUES bug 573 (closed) confirms our handling for multi-selection.


    FILE HISTORY:
	rustanl     21-Aug-1991     Created
	jonn        07-Oct-1991     Split off memblb.cxx
	jonn        10-Oct-1991     LMOENUM update
	o-SimoP     14-Oct-1991     USER_MEMB_DIALOG modified to inherit
				    from USER_SUBPROP_DLG
	o-SimoP     31-Oct-1991     Code Review changes, attended by JimH,
				    ChuckC, JonN and I
	JonN	    18-Dec-1991     Logon Hours code review changes part 2
	JonN	    11-Feb-1992     Removed group renaming, "phantom groups,"
					and "locking groups"
	JonN	    27-Feb-1992     Multiple bitmaps in both panes
        JonN        06-Mar-1992     Moved GetOne from subprop subclasses
        JonN        02-Apr-1992     Load by ordinal only
*/


#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_SETCONTROL
#define INCL_BLT_TIMER
#include <blt.hxx>

extern "C"
{
    #include <usrmgrrc.h>
    #include <ntlsa.h>
    #include <ntsam.h>
    #include <umhelpc.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>

#include <lmouser.hxx>
#include <lmomemb.hxx>
#include <lmoeusr.hxx>
#include <ntuser.hxx>
#include <uintsam.hxx>
#include <lmoeali.hxx>

#include <userprop.hxx>
#include <usubprop.hxx>
#include <umembdlg.hxx>
#include <usrmain.hxx>  // pszSpecialGroup* constants for IS_USERPRIV macro


UMEMB_SC_LISTBOX::UMEMB_SC_LISTBOX( USER_MEMB_DIALOG * pumembdlg,
                                    CID cid,
                                    const SUBJECT_BITMAP_BLOCK & bmpblock )
        : GROUP_SC_LISTBOX( pumembdlg, cid, bmpblock ),
          _pumembdlg( pumembdlg )
{
    ASSERT( _pumembdlg != NULL );
}


UMEMB_SC_LISTBOX::~UMEMB_SC_LISTBOX()
{
    // nothing to do here
}


BOOL UMEMB_SC_LISTBOX::OnLMouseButtonUp( const MOUSE_EVENT & mouseevent )
{
    BOOL fReturn = GROUP_SC_LISTBOX::OnLMouseButtonUp( mouseevent );
    _pumembdlg->UpdatePrimaryGroupButton();
    return fReturn;
}

/*******************************************************************

    NAME:	UMEMB_SET_CONTROL::UMEMB_SET_CONTROL

    SYNOPSIS:   Constructor

    ENTRY:      Same as SET_CONTROL, pluse pumembdlg - parent dialog

    HISTORY:
    	Thomaspa	    17-Mar-1993	  Created
********************************************************************/
UMEMB_SET_CONTROL::UMEMB_SET_CONTROL( USER_MEMB_DIALOG * pumembdlg,
                                      CID cidAdd,
                                      CID cidRemove,
                                      LISTBOX *plbOrigBox,
                                      LISTBOX *plbNewBox )
        : BLT_SET_CONTROL( pumembdlg, cidAdd, cidRemove,
                           CURSOR::Load(IDC_GROUPONE),
                           CURSOR::Load(IDC_GROUPMANY),
                           plbOrigBox, plbNewBox,
                           COL_WIDTH_WIDE_DM ),
          _pumembdlg( pumembdlg )
{
    ASSERT( _pumembdlg != NULL );
}

/*******************************************************************

    NAME:	UMEMB_SET_CONTROL::OnRemove

    SYNOPSIS:   Virtual replacement to check if removing from primary
                group.

    ENTRY:      none

    HISTORY:
    	Thomaspa	    17-Mar-1993	  Created
********************************************************************/

APIERR UMEMB_SET_CONTROL::DoRemove()
{
    if ( _pumembdlg->CheckIfRemovingPrimaryGroup() )
    {
        ::MsgPopup( _pumembdlg, IERR_UM_NotInPrimaryGroup );
        return NERR_Success;
    }

    return SET_CONTROL::DoRemove();
}



/*******************************************************************

    NAME:	USER_MEMB_DIALOG::USER_MEMB_DIALOG

    SYNOPSIS:   Constructor for Group Membership subdialog

    ENTRY:	pupropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
    	o-SimoP	    14-Oct-1991	    changes due to inheritance from
					USER_MEMB_DIALOG
********************************************************************/

USER_MEMB_DIALOG::USER_MEMB_DIALOG( USERPROP_DLG * pupropdlgParent,
				    const LAZY_USER_LISTBOX * pulb )
    :	USER_SUBPROP_DLG( pupropdlgParent,
                          MAKEINTRESOURCE(IDD_USERMEMB_DLG),
                          pulb ),
	_sltIn( this, IDC_UMEMB_IN_TITLE ),
	_sltNotIn( this, IDC_UMEMB_NOT_IN_TITLE ),
	_lbIn(    this,
                  IDC_UMEMB_IN_LB,
                  pupropdlgParent->QueryBitmapBlock() ),
	_lbNotIn( this,
                  IDC_UMEMB_NOT_IN_LB,
                  pupropdlgParent->QueryBitmapBlock() ),
        _psc( NULL ),
	_psltPrimaryGroupLabel( NULL ),
	_phiddenPrimaryGroupLabel( NULL ),
	_psltPrimaryGroup( NULL ),
	_phiddenPrimaryGroup( NULL ),
	_ppbSetPrimaryGroup( NULL ),
	_phiddenSetPrimaryGroup( NULL ),
	_ulPrimaryGroupId( 0 ),
	_ulNewPrimaryGroupId( 0 ),
	_strlGroupsToJoin(),
	_strlGroupsToLeave()
{
    if ( QueryError() != NERR_Success )
	return;

    _psc = new UMEMB_SET_CONTROL( this, IDC_UMEMB_ADD, IDC_UMEMB_REMOVE,
                            &_lbNotIn, &_lbIn );
    if( _psc == NULL )
    {
	ReportError( ERROR_NOT_ENOUGH_MEMORY );
	return;
    }
    APIERR err;
    if(    (err = _psc->QueryError()) != NERR_Success
		)
    {
	delete _psc;
	ReportError( err );
	return;
    }

    _lbIn.Set_SET_CONTROL( _psc );
    _lbNotIn.Set_SET_CONTROL( _psc );

    if ( QueryTargetServerType() == UM_LANMANNT )
    {
	err = ERROR_NOT_ENOUGH_MEMORY;
	_psltPrimaryGroupLabel = new SLT( this, IDC_UM_PRIMARY_GROUP_LABEL );
	_psltPrimaryGroup = new SLT( this, IDC_UM_PRIMARY_GROUP );
	_ppbSetPrimaryGroup = new PUSH_BUTTON( this, IDC_UM_SET_PRIMARY_GROUP );

	if ( _psltPrimaryGroupLabel == NULL
	    || (err = _psltPrimaryGroupLabel->QueryError()) != NERR_Success
	    || _psltPrimaryGroup == NULL
	    || (err = _psltPrimaryGroup->QueryError()) != NERR_Success
	    || _ppbSetPrimaryGroup == NULL
	    || (err = _ppbSetPrimaryGroup->QueryError()) != NERR_Success )
	{
	    delete _psc;
	    delete _psltPrimaryGroupLabel;
	    delete _psltPrimaryGroup;
	    delete _ppbSetPrimaryGroup;
	    ReportError( err );
	    return;
	}

	// Initially, disable the Set Primary Group button
	_ppbSetPrimaryGroup->Enable( FALSE );
    }
    else
    {
	err = ERROR_NOT_ENOUGH_MEMORY;
	_phiddenPrimaryGroupLabel = new HIDDEN_CONTROL( this,
						IDC_UM_PRIMARY_GROUP_LABEL );
	_phiddenPrimaryGroup = new HIDDEN_CONTROL( this, IDC_UM_PRIMARY_GROUP );
	_phiddenSetPrimaryGroup = new HIDDEN_CONTROL( this,
						IDC_UM_SET_PRIMARY_GROUP );

	if ( _phiddenPrimaryGroupLabel == NULL
	    || (err = _phiddenPrimaryGroupLabel->QueryError()) != NERR_Success
	    || _phiddenPrimaryGroup == NULL
	    || (err = _phiddenPrimaryGroup->QueryError()) != NERR_Success
	    || _phiddenSetPrimaryGroup == NULL
	    || (err = _phiddenSetPrimaryGroup->QueryError()) != NERR_Success )
	{
	    delete _psc;
	    delete _phiddenPrimaryGroupLabel;
	    delete _phiddenPrimaryGroup;
	    delete _phiddenSetPrimaryGroup;
	    ReportError( err );
	    return;
	}
    }


}  // USER_MEMB_DIALOG::USER_MEMB_DIALOG


/*******************************************************************

    NAME:	USER_MEMB_DIALOG::~USER_MEMB_DIALOG

    SYNOPSIS:   Destructor for Group Membership subdialog

    HISTORY:
    	o-SimoP	    18-Oct-1991
		
********************************************************************/

USER_MEMB_DIALOG::~USER_MEMB_DIALOG()
{

    _lbIn.Set_SET_CONTROL( NULL );
    _lbNotIn.Set_SET_CONTROL( NULL );

    delete _psc;
    delete _phiddenPrimaryGroupLabel;
    delete _phiddenPrimaryGroup;
    delete _phiddenSetPrimaryGroup;
    delete _psltPrimaryGroupLabel;
    delete _psltPrimaryGroup;
    delete _ppbSetPrimaryGroup;
}  // USER_MEMB_DIALOG::~USER_MEMB_DIALOG


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
    	o-SimoP	17-Oct-1991	created
********************************************************************/

APIERR USER_MEMB_DIALOG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    USER_MEMB * pumemb = QueryUserMembPtr( iObject );
    ASSERT( (!DoShowGroups()) || pumemb != NULL );
    ASSERT( (!DoShowGroups()) || pumemb->QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    if ( QueryTargetServerType() != UM_DOWNLEVEL && !IsNewVariant() )
    {
        SAM_RID_MEM * psamrmAccounts = NULL;
        SAM_RID_MEM * psamrmBuiltin = NULL;

        err = QueryParent()->I_GetAliasMemberships(
                            QueryUser3Ptr( iObject )->QueryUserId(),
                            &psamrmAccounts,
                            &psamrmBuiltin );
        if (err != NERR_Success)
        {
            return err;
        }

        SetAccountsSamRidMemPtr( iObject, psamrmAccounts );
        SetBuiltinSamRidMemPtr ( iObject, psamrmBuiltin  );
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );
	
} // USER_MEMB_DIALOG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USER_MEMB_DIALOG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    NOTES:	See NTISSUES bug 755.  Is the currently implemented
		handling of operator right groups correct?

		NTISSUES bugs 758 and 571 confirm our handling of GUESTS/
		USERS/ ADMINS groups.  If a user is in !=1 of these, we
		pretend the user is in exactly one.

    HISTORY:
    	o-SimoP	14-Oct-1991	created
	o-SimoP	27-Nov-1991	Uses IS_USERPRIV_GROUP macro	
********************************************************************/

APIERR USER_MEMB_DIALOG::InitControls()
{
    UINT nCount = QueryObjectCount();
    APIERR  err;
    if ( nCount > 1 )   // set headers indicating multiple users
    {
	NLS_STR nls;
	if ( ( err = nls.QueryError()) != NERR_Success ||
	     ( err = nls.Load( IDS_UMEMB_MULT_IN_TITLE )) != NERR_Success )
	{
	    return err;
	}
	_sltIn.SetText( nls );

	err = nls.Load( IDS_UMEMB_MULT_NOT_IN_TITLE );
	if ( err != NERR_Success )
	{
	    return err;	
	}
	_sltNotIn.SetText( nls );
    }

    UINT iObject;


    if ( DoShowGroups() )
    {
	//
	// First do the Groups ( global groups )
	//

	GROUP0_ENUM ge0( QueryLocation() );
	err = ge0.QueryError();
	if(   err != NERR_Success
	    || (err = ge0.GetInfo()) != NERR_Success )
	{
            return err;
	}

	// we put all groups but special groups to NotIn listbox
	GROUP0_ENUM_ITER gei0( ge0 );
	const GROUP0_ENUM_OBJ * pgi0;
	while ( ( pgi0 = gei0()) != NULL )
	{
            const TCHAR * psz = pgi0->QueryName();
            // do not add if it is ADMINS, USERS, or GROUPS...
	    if( !IS_USERPRIV_GROUP( psz ) )
	    {
	        GROUP_SC_LBI * pmsclbi = new GROUP_SC_LBI( psz, GROUPLB_GROUP );
	        // no need for error checking, AddItem does it
	        if ( _lbNotIn.AddItem( pmsclbi ) < 0 )
	        {
		    return ERROR_NOT_ENOUGH_MEMORY;
	        }
            }
        }
    }

    //
    // Now do the Aliases ( local groups )
    //

    if ( QueryTargetServerType() != UM_DOWNLEVEL )
    {

	// First do the Aliases in the Accounts domain
	ALIAS_ENUM aeAccount( *QueryAdminAuthority()->QueryAccountDomain() );
	err = aeAccount.QueryError();
	if(   err != NERR_Success
	    || (err = aeAccount.GetInfo()) != NERR_Success )
	{
	    return err;
	}

	// we put all aliases to NotIn listbox
	ALIAS_ENUM_ITER aeiAccount( aeAccount );
	const ALIAS_ENUM_OBJ * paiAccount;
	while ( ( paiAccount = aeiAccount.Next( & err )) != NULL
		&& err == NERR_Success )
	{
	    NLS_STR nlsName;
            err = ((ALIAS_ENUM_OBJ *)paiAccount)->GetName( &nlsName );
            ULONG rid = paiAccount->QueryRid();
	    GROUP_SC_LBI * pmsclbi = new GROUP_SC_LBI(nlsName.QueryPch(),
						      GROUPLB_ALIAS,
						      rid,
						      FALSE); // not Builtin
	    // no need for error checking, AddItem does it
	    if ( _lbNotIn.AddItem( pmsclbi ) < 0 )
	    {
	        return ERROR_NOT_ENOUGH_MEMORY;
	    }
        }


	// Now do the Aliases in the Builtin domain
	ALIAS_ENUM aeBuiltin( *QueryAdminAuthority()->QueryBuiltinDomain() );
	err = aeBuiltin.QueryError();
	if(   err != NERR_Success
	    || (err = aeBuiltin.GetInfo()) != NERR_Success )
	{
	    return err;
	}

	// we put all aliases to NotIn listbox
	ALIAS_ENUM_ITER aeiBuiltin( aeBuiltin );
	const ALIAS_ENUM_OBJ * paiBuiltin;
	while ( ( paiBuiltin = aeiBuiltin.Next( &err )) != NULL
		&& err == NERR_Success )
	{
	    NLS_STR nlsName;
            err = ((ALIAS_ENUM_OBJ *)paiBuiltin)->GetName( &nlsName );
            ULONG rid = paiBuiltin->QueryRid();
	    GROUP_SC_LBI * pmsclbi = new GROUP_SC_LBI(nlsName.QueryPch(),
						      GROUPLB_ALIAS,
						      rid,
						      TRUE); // Builtin
	    // no need for error checking, AddItem does it
	    if ( _lbNotIn.AddItem( pmsclbi ) < 0 )
	    {
	        return ERROR_NOT_ENOUGH_MEMORY;
	    }
        }
    }



    iObject = 0;
    if ( DoShowGroups() )
    {

        USER_MEMB * pumemb = QueryUserMembPtr( iObject );

        // we move first user's groups to In box
        err = _lbNotIn.SelectMembItems( *pumemb );
        if ( err != NERR_Success )
        {
	    return err;
        }
    } // if DoShowGroups()

    if ( QueryTargetServerType() != UM_DOWNLEVEL && !IsNewVariant() )
    {
        SAM_RID_MEM * psamrmAccounts = QueryAccountsSamRidMemPtr( iObject );
        SAM_RID_MEM * psamrmBuiltin = QueryBuiltinSamRidMemPtr( iObject );

        // we move first user's aliases to In box
        err = _lbNotIn.SelectItems2( *psamrmAccounts, FALSE );
        if ( err != NERR_Success )
        {
	    return err;
        }
        err = _lbNotIn.SelectItems2( *psamrmBuiltin, TRUE );
        if ( err != NERR_Success )
        {
	    return err;
        }
    }

    err = _psc->DoAdd();
    if ( err != NERR_Success )
    {
        return err;
    }

    // then we move aliases that others are not in to NotIn lbox
    iObject++;
    for(; iObject < nCount; iObject++ )
    {
        _lbIn.SelectAllItems();
	if ( DoShowGroups() )
	{
	    USER_MEMB * pumemb = QueryUserMembPtr( iObject );
	    err = _lbIn.SelectMembItems( *pumemb, FALSE );
	    if ( err != NERR_Success )
	    {
	        return err;
	    }
	}
	if ( QueryTargetServerType() != UM_DOWNLEVEL && !IsNewVariant() )
	{
            SAM_RID_MEM * psamrmAccounts = QueryAccountsSamRidMemPtr( iObject );
            SAM_RID_MEM * psamrmBuiltin = QueryBuiltinSamRidMemPtr( iObject );
            err = _lbIn.SelectItems2( *psamrmAccounts, FALSE, FALSE );
            if ( err != NERR_Success )
            {
                return err;
            }
            err = _lbIn.SelectItems2( *psamrmBuiltin, TRUE, FALSE );
            if ( err != NERR_Success )
            {
                return err;
            }
	}

        err = _psc->DoRemove();
        if ( err != NERR_Success )
        {
            return err;
        }	
    }




    // now we mark items in Inbox
    nCount = _lbIn.QueryCount();
    for( INT i = 0; i < (INT)nCount; i++ )
    {
	GROUP_SC_LBI * pmemblbi = (GROUP_SC_LBI *) _lbIn.QueryItem( i );
	ASSERT( pmemblbi != NULL );
	pmemblbi->SetIn();
    }

/*
    At this point, the listbox contents reflect the state of the
    real object.  We now overlay onto this any pending changes
    to alias membership from previous invocations of this subdialog,
    or from the alias membership of the cloned user.

    Note that we only work with AddToAliases(), RemoveFromAliases() is
    not interesting.
*/
    {
        _lbNotIn.RemoveSelection();

        RID_AND_SAM_ALIAS *prasm;

        SLIST_OF( RID_AND_SAM_ALIAS ) * pslrasm
                      = QueryParent()->QuerySlAddToAliases();

        ITER_SL_OF(RID_AND_SAM_ALIAS) iterAddToAliases( *pslrasm );

        while (    (err == NERR_Success)
                && ( prasm  = iterAddToAliases.Next() ) != NULL )
        {
            INT iItem;
            err = _lbNotIn.FindItemByRid( prasm->QueryRID(),
                                          prasm->IsBuiltin(),
                                          &iItem );
            if ( err == NERR_Success && iItem >= 0 )
                _lbNotIn.SelectItem( iItem );
        }

        if ( err == NERR_Success )
            err = _psc->DoAdd();
    }



    _lbNotIn.RemoveSelection();
    _lbIn.RemoveSelection();
    if( _lbIn.QueryCount() > 0 )
    {
	_lbIn.SelectItem( 0, TRUE );
	_lbIn.ClaimFocus();
    }
    if( _lbNotIn.QueryCount() > 0 )
    {
	_lbNotIn.SelectItem( 0, TRUE );
        _lbIn.RemoveSelection();
        _lbNotIn.ClaimFocus();
    }
    _psc->EnableMoves(FALSE);
    _psc->EnableMoves(TRUE);

    // Now set the primary group slt.
    if ( QueryTargetServerType() == UM_LANMANNT )
    {
	iObject = 0;
        // Note that for New Users, USER_3::W_CreateNew() will initialize
        // PrimaryGroup to DOMAIN_GROUP_RID_USERS, so no need to do it here.
	_ulPrimaryGroupId = (ULONG)QueryUser3Ptr( iObject )->QueryPrimaryGroupId();

	iObject++;
	nCount = QueryObjectCount();
        for(; iObject < nCount; iObject++ )
	{
	    if ( _ulPrimaryGroupId
		!= (ULONG)QueryUser3Ptr( iObject )->QueryPrimaryGroupId() )
	    {
		// They are not all the same.  Make it indeterminate.
		_ulPrimaryGroupId = 0;
		break;
	    }
	}

	if ( _ulPrimaryGroupId != 0 )
	{
	    OS_SID ossidPrimaryGroup(
		    QueryAdminAuthority()->QueryAccountDomain()->QueryPSID(),
		    _ulPrimaryGroupId );

	    LSA_TRANSLATED_NAME_MEM lsatnm;
	    LSA_REF_DOMAIN_MEM lsardm;

	    if ( (err = ossidPrimaryGroup.QueryError()) != NERR_Success
		|| (err = lsatnm.QueryError()) != NERR_Success
		|| (err = lsardm.QueryError()) != NERR_Success )
	    {
		return err;
	    }

	    PSID psidPrimaryGroup = ossidPrimaryGroup.QueryPSID();
	    LSA_POLICY * plsapol = QueryAdminAuthority()->QueryLSAPolicy();
	    if ( (err = plsapol->TranslateSidsToNames(
				&psidPrimaryGroup,
				1,
				&lsatnm,
				&lsardm )) != NERR_Success )
	    {
		return err;
	    }

	    NLS_STR nlsTemp;
	    if ( (err = nlsTemp.QueryError()) != NERR_Success
		|| (err = lsatnm.QueryName( 0, &nlsTemp )) != NERR_Success )
	    {
		return err;
	    }
	    _psltPrimaryGroup->SetText( nlsTemp );

	}
    }

    return USER_SUBPROP_DLG::InitControls();

} // USER_MEMB_DIALOG::InitControls


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::ChangesUserMembPtr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_MEMB
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_MEMB is changed

    HISTORY:
	JonN	18-Dec-1991   created

********************************************************************/

BOOL USER_MEMB_DIALOG::ChangesUserMembPtr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_MEMB is changed

    HISTORY:
	Thomaspa	04-Dec-1992   created

********************************************************************/

BOOL USER_MEMB_DIALOG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
    	o-SimoP	14-Oct-1991	created
********************************************************************/

APIERR USER_MEMB_DIALOG::W_DialogToMembers()
{
    APIERR err = NERR_Success;
    INT cCount = _lbIn.QueryCount();
    _strlGroupsToJoin.Clear();
    QueryParent()->QuerySlAddToAliases()->Clear(); // CODEWORK would be nice to not do this

    // first we check InListbox for candidate groups for adding
    INT i = 0;
    for( ; i < cCount; i++ )
    {
	GROUP_SC_LBI * pmemblbi = (GROUP_SC_LBI *) _lbIn.QueryItem( i );
	ASSERT( pmemblbi != NULL );
	if( !pmemblbi->IsIn() ) // we collect from InLb only those who
	{			    // not initially was in it
	    if ( pmemblbi->IsAlias() )
	    {
		err = GetAliasFromLb( pmemblbi,
				      QueryParent()->QuerySlAddToAliases() );
	    }
	    else
	    {
		err = GetGroupFromLb( pmemblbi, &_strlGroupsToJoin );
	    }
	    if( err != NERR_Success )
		break;
        }

    }

    // then check Not in listbox for candidate groups for removing
    cCount = _lbNotIn.QueryCount();
    _strlGroupsToLeave.Clear();
    QueryParent()->QuerySlRemoveFromAliases()->Clear();
    for( i = 0; (err == NERR_Success) && (i < cCount); i++ )
    {
	GROUP_SC_LBI * pmemblbi = (GROUP_SC_LBI *) _lbNotIn.QueryItem( i );
	ASSERT( pmemblbi != NULL );
	if( pmemblbi->IsIn() ) // we collect from NotInLb only those who
	{			// was initially in InLb
	    if ( pmemblbi->IsAlias() )
	    {
		err = GetAliasFromLb( pmemblbi,
				      QueryParent()->QuerySlRemoveFromAliases() );
	    }
	    else
	    {
	        err = GetGroupFromLb( pmemblbi, &_strlGroupsToLeave );
	    }
	    if( err != NERR_Success )
		break;
        }
    }

    // Now handle primary group
    if ( QueryTargetServerType() == UM_LANMANNT && _ulNewPrimaryGroupId != 0 )
    {
	_ulPrimaryGroupId = _ulNewPrimaryGroupId;
    }

    return err == NERR_Success ? USER_SUBPROP_DLG::W_DialogToMembers() : err;

} // USER_MEMB_DIALOG::W_DialogToMembers


/*******************************************************************

    NAME:	USER_MEMB_DIALOG::GetGroupFromLb

    SYNOPSIS:	puts groups in listbox to STRLIST

    ENTRY:	pgrlbi    -	pointer to LBI
	
		pstrl    -	pointer to STRLIST that gets group names
				from listbox

    RETURNS:	error code

    HISTORY:
    	o-SimoP	30-Oct-1991	created
********************************************************************/

APIERR USER_MEMB_DIALOG::GetGroupFromLb( GROUP_SC_LBI * pmemblbi,
			     STRLIST * pstrl )
{
    APIERR err = NERR_Success;
    ASSERT( !pmemblbi->IsAlias() );

    NLS_STR * pnls = new NLS_STR( pmemblbi->QueryPch() );
    if( pnls == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;
    if( (err = pnls->QueryError()) != NERR_Success )
    {
        delete pnls;
        return err;
    }
    err = pstrl->Add( pnls );
    return err;

} // USER_MEMB_DIALOG::GetGroupFromLb


/*******************************************************************

    NAME:	USER_MEMB_DIALOG::GetAliasFromLb

    SYNOPSIS:	puts aliases in listbox to SLIST

    ENTRY:	pgrlbi    -	pointer to LBI
	
		psl    -	pointer to SLIST that gets alias names
				from listbox

    RETURNS:	error code

    HISTORY:
    	Thomaspa	28-Apr-1992	created
********************************************************************/

APIERR USER_MEMB_DIALOG::GetAliasFromLb( GROUP_SC_LBI * pmemblbi,
			     SLIST_OF(RID_AND_SAM_ALIAS) * psl )
{
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;


    RID_AND_SAM_ALIAS * prasm = new RID_AND_SAM_ALIAS( pmemblbi->QueryRID(),
						       pmemblbi->IsBuiltin() );
    if ( prasm == NULL )
	return err;

    err = psl->Add( prasm );
    if( err != NERR_Success )
	    return err;
   return err;

} // USER_MEMB_DIALOG::GetAliasFromLb


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    HISTORY:
    	o-SimoP	18-Oct-1991	created
	JonN	18-Dec-1991     Logon Hours code review changes part 2
********************************************************************/

APIERR USER_MEMB_DIALOG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    APIERR err;
    {	// add groups if not found
	ITER_STRLIST istr( _strlGroupsToJoin );
	NLS_STR *pnls;
	while( (pnls = istr.Next()) != NULL )
	{
	    UINT i;	// we don't use this
	    if( !pusermemb->FindAssocName( pnls->QueryPch(), &i ) )
	    {
		err = pusermemb->AddAssocName( pnls->QueryPch() );
		if( err != NERR_Success )
		    return err;
	    }
	}
    }

    {	// delete groups if found
	ITER_STRLIST istr( _strlGroupsToLeave );
	NLS_STR *pnls;
	while( (pnls = istr.Next()) != NULL )
	{
	    UINT i;
	    if( pusermemb->FindAssocName( pnls->QueryPch(), &i ) )
	    {
		err = pusermemb->DeleteAssocName( i );
		if( err != NERR_Success )
		    return err;
	    }
	}
    }

    // Handle the primary group
    if ( QueryTargetServerType() == UM_LANMANNT )
    {
	if ((err = ((USER_3 *)puser2)->SetPrimaryGroupId( _ulPrimaryGroupId ))
		!= NERR_Success)
	{
	    return err;
	}
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USER_MEMB_DIALOG::W_MembersToLMOBJ



/*******************************************************************

    NAME:       USER_MEMB_DIALOG::OnCommand

    SYNOPSIS:   Takes care of Set Primary Group button

    ENTRY:      ce -            Notification event

    RETURNS:    TRUE if action was taken
                FALSE otherwise

    HISTORY:
               Thomaspa  01-Dec-1992    created

********************************************************************/

BOOL USER_MEMB_DIALOG::OnCommand( const CONTROL_EVENT & ce )
{

    switch ( ce.QueryCid() )
    {
    case IDC_UM_SET_PRIMARY_GROUP:
       {
	APIERR err = OnSetPrimaryGroup();
	if ( err != NERR_Success )
	    ::MsgPopup( this, err );
	return TRUE;
	break;
       }
    case IDC_UMEMB_NOT_IN_LB:
       {
        switch ( ce.QueryCode() )
        {
        case LBN_SELCHANGE:
        case LBN_DBLCLK:
            UpdatePrimaryGroupButton();
	}
        break;
       }
    case IDC_UMEMB_IN_LB:
       {
        switch ( ce.QueryCode() )
        {
        case LBN_DBLCLK:
        case LBN_SELCHANGE:
            UpdatePrimaryGroupButton();
	}
        break;
       }
    case IDC_UMEMB_REMOVE:
    case IDC_UMEMB_ADD:
       {
        UpdatePrimaryGroupButton();
	break;
       }
    default:
	break;
    }

    return USER_SUBPROP_DLG::OnCommand( ce ) ;

}



/*******************************************************************

    NAME:       USER_MEMB_DIALOG::OnSetPrimaryGroup

    SYNOPSIS:	Handles Set Primary Group button

    ENTRY:	none
			
    RETURNS:	error code

    HISTORY:
    	Thomaspa	01-Dec-1992	created
********************************************************************/
APIERR USER_MEMB_DIALOG::OnSetPrimaryGroup()
{
    INT iSelection;
    APIERR err;
    AUTO_CURSOR autocur;

    if ( (err = _lbIn.QuerySelItems( &iSelection, 1 ))
                		!= NERR_Success )
    {
	return err;
    }

    GROUP_SC_LBI * plbi = _lbIn.QueryItem( iSelection );

    const TCHAR * pszPrimaryGroup = plbi->QueryPch();

    _psltPrimaryGroup->SetText( pszPrimaryGroup );


    SAM_DOMAIN * psamdomAccount = QueryAdminAuthority()->QueryAccountDomain();
    SAM_RID_MEM samrm;
    SAM_SID_NAME_USE_MEM samsnum;

    err = ERROR_NOT_ENOUGH_MEMORY;
    if ( (err = samrm.QueryError()) != NERR_Success
	|| (err = samsnum.QueryError()) != NERR_Success
	|| (psamdomAccount == NULL)
	|| (err = psamdomAccount->QueryError()) != NERR_Success
	|| (err = psamdomAccount->TranslateNamesToRids( &pszPrimaryGroup,
                                 			1,
                                 			&samrm,
                                 			&samsnum)) != NERR_Success )
    {
	return err;
    }
    _ulNewPrimaryGroupId = samrm.QueryRID( 0 );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::UpdatePrimaryGroupButton

    SYNOPSIS:	Enables/disables Set Primary Group button

    HISTORY:
    	JonN    	21-Jan-1993	created
********************************************************************/
void USER_MEMB_DIALOG::UpdatePrimaryGroupButton()
{
    if ( QueryTargetServerType() == UM_LANMANNT )
    {
        if ( _lbIn.QuerySelCount() == 1 )
        {
            INT iSelection;
            APIERR err;

            if ( (err = _lbIn.QuerySelItems( &iSelection, 1 ))
        		!= NERR_Success )
            {
                MsgPopup( this, err );
            }
            else
            {
                GROUP_SC_LBI * plbi = _lbIn.QueryItem( iSelection );

                _ppbSetPrimaryGroup->Enable( !(plbi->IsAlias()) );
            }
        }
        else
        {
            _ppbSetPrimaryGroup->Enable( FALSE );
        }

    }
}


/*******************************************************************

    NAME:       USER_MEMB_DIALOG::CheckIfRemovingPrimaryGroup

    SYNOPSIS:	Displayas an error message if the user tries to remove
                a user from its primary group

    HISTORY:
    	Thomaspa    	17-Mar-1993	created
********************************************************************/
BOOL USER_MEMB_DIALOG::CheckIfRemovingPrimaryGroup()
{
    if ( QueryTargetServerType() != UM_LANMANNT )
    {
        return FALSE;
    }
    APIERR err = NERR_Success;
    INT cSelections = _lbIn.QuerySelCount();

    BUFFER buffLBSel( cSelections * sizeof( INT ) );

    if ( (err = buffLBSel.QueryError()) != NERR_Success )
    {
        ::MsgPopup( this, err );
        return FALSE;
    }

    INT * piSelections = (INT *) buffLBSel.QueryPtr();

    if ( (err = _lbIn.QuerySelItems( piSelections, cSelections ))
                != NERR_Success )
    {
        ::MsgPopup( this, err );
        return FALSE;
    }

    BOOL fPrimaryGroupSelected = FALSE;
    NLS_STR nlsPrimaryGroup;
    if ( (err = _psltPrimaryGroup->QueryText( &nlsPrimaryGroup )) != NERR_Success )
    {
        ::MsgPopup( this, err );
        return FALSE;
    }
    for ( INT i = cSelections - 1; i >= 0; i-- )
    {
        GROUP_SC_LBI * plbi = _lbIn.QueryItem( piSelections[i] );
        if ( !(plbi->IsAlias()) )
        {
            ALIAS_STR nlsGroup = plbi->QueryPch();
            if ( nlsPrimaryGroup == nlsGroup )
            {
                fPrimaryGroupSelected = TRUE;
                break;
            }
        }
    }

    return fPrimaryGroupSelected;
}

/*******************************************************************

    NAME:       USER_MEMB_DIALOG::PerformOne

    SYNOPSIS:	Handle adding/removing users to/from aliases before
		passing control on to USER_SUBPROP_DLG::PerformOne()

    ENTRY:	iObject		- index of user

		puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    HISTORY:
    	Thomaspa	28-Apr-1992	created
********************************************************************/

APIERR USER_MEMB_DIALOG::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{

    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( (!IsNewVariant()) || (iObject == 0) );
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    UITRACE( SZ("USER_MEMB_DLG::PerformOne : ") );
    UITRACE( QueryObjectName( iObject ) );
    UITRACE( SZ("\n\r") );

    *perrMsg = IDS_UMEditFailure;
    *pfWorkWasDone = FALSE;

    if (!IsDownlevelVariant() && !IsNewVariant())
    {
	APIERR err;
	APIERR errFirst = NERR_Success;


	SAM_DOMAIN * psamdomAccount =
			QueryAdminAuthority()->QueryAccountDomain();

	SAM_DOMAIN * psamdomBuiltin =
			QueryAdminAuthority()->QueryBuiltinDomain();

	ULONG ridUser = QueryUser3Ptr( iObject )->QueryUserId();

	OS_SID ossidUser( psamdomAccount->QueryPSID(), ridUser );

	if ( (err = ossidUser.QueryError()) != NERR_Success )
	{
		return err;
	}

    	SLIST_OF( RID_AND_SAM_ALIAS ) * pslrasm =
		QueryParent()->QuerySlRemoveFromAliases();

	ITER_SL_OF(RID_AND_SAM_ALIAS) iterRemoveFromAliases( *pslrasm );

	RID_AND_SAM_ALIAS *prasm;
	while ( ( prasm  = iterRemoveFromAliases.Next() ) != NULL )
	{
	    SAM_ALIAS * psamalias;
	    if ( (psamalias = prasm->QuerySamAlias()) == NULL )
	    {
		psamalias = new SAM_ALIAS(
					prasm->IsBuiltin() ? *psamdomBuiltin
							 : *psamdomAccount,
					prasm->QueryRID() );
		err = ERROR_NOT_ENOUGH_MEMORY;
		if ( psamalias == NULL ||
		    (err = psamalias->QueryError()) != NERR_Success )
		{
		    if ( errFirst == NERR_Success)
			errFirst = err;
		    continue;	// No point in trying this alias
		}

		prasm->SetSamAlias( psamalias );
				
	    }

	    err = psamalias->RemoveMember( ossidUser.QuerySid() );
            switch (err)
            {
                case NERR_Success:
                    *pfWorkWasDone = TRUE;
                    break;

                case STATUS_MEMBER_NOT_IN_ALIAS:
                case ERROR_MEMBER_NOT_IN_ALIAS:
                    break;

                default:
		    if ( errFirst == NERR_Success )
		        errFirst = err;
		    break;
	    }
	
	}

    	pslrasm = QueryParent()->QuerySlAddToAliases();

	ITER_SL_OF(RID_AND_SAM_ALIAS) iterAddToAliases( *pslrasm );

	while ( ( prasm  = iterAddToAliases.Next() ) != NULL )
	{
	    SAM_ALIAS * psamalias;
	    if ( (psamalias = prasm->QuerySamAlias()) == NULL )
	    {
		psamalias = new SAM_ALIAS(
					prasm->IsBuiltin() ? *psamdomBuiltin
							 : *psamdomAccount,
					prasm->QueryRID() );
		err = ERROR_NOT_ENOUGH_MEMORY;
		if ( psamalias == NULL ||
		    (err = psamalias->QueryError()) != NERR_Success )
		{
		    if ( errFirst == NERR_Success)
			errFirst = err;
		    continue;	// No point in trying this alias
		}

		prasm->SetSamAlias( psamalias );
				
	    }

	    err = psamalias->AddMember( ossidUser.QuerySid() );
            switch (err)
            {
                case NERR_Success:
                    *pfWorkWasDone = TRUE;
                    break;

                case STATUS_MEMBER_IN_ALIAS:
                case ERROR_MEMBER_IN_ALIAS:
                    break;

                default:
		    if ( errFirst == NERR_Success )
		        errFirst = err;
		    break;
	    }
	
	}

	if ( errFirst != NERR_Success )
	    return W_MapPerformOneError( errFirst );
    }


    // USER_SUBPROP_DLG::PerformOne() will reset *pfWorkWasDone, so let's not
    // lose track of it.
    // CODEWORK:  Really, no one should just set WorkWasDone to FALSE.
    //            See PerformSeries for details.
    BOOL fWorkWasDoneAbove = *pfWorkWasDone;
    APIERR errBelow = USER_SUBPROP_DLG::PerformOne( iObject, perrMsg, pfWorkWasDone );
    if (fWorkWasDoneAbove)
        *pfWorkWasDone = TRUE;
    return errBelow;

} // USER_SUBPROP_DLG::PerformOne




/*******************************************************************

    NAME:       USER_MEMB_DIALOG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.
z
    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
        o-SimoP  14-Oct-1991    created

********************************************************************/

ULONG USER_MEMB_DIALOG::QueryHelpContext( void )
{
    return HC_UM_GROUPMEMB_LANNT + QueryHelpOffset();

}// USER_MEMB_DIALOG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\udelperf.cxx ===
/**********************************************************************/
/**           Microsoft Windows NT                                   **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    udelperf.cxx
    USER_DELETE_PERFORMER & GROUP_DELETE_PERFORMER class


    FILE HISTORY:
        o-SimoP     09-Aug-1991     Created
        o-SimoP     20-Aug-1991     CR changes, attended by ChuckC, JonN
                                    ErichCh, RustanL and me.
                                    gdelperf.cxx merged to this file
        JonN        26-Aug-1991     PROP_DLG code review changes
        o-SimoP     30-Sep-1991     PerformOnes changes according
                                    to latest spec (1.3)
        terryk      10-Nov-1991     change I_NetXXX to I_MNetXXX
        JonN        16-Aug-1992     Added YesToAll dialog
        JonN        17-Sep-1992     Delete User without WKSTA started
*/

#include <ntincl.hxx>

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

// must be included after blt.hxx (more exactly, bltrc.h)
extern "C"
{
    #include <usrmgrrc.h>
    #include <mnet.h>

    #include <ntlsa.h>
    #include <ntsam.h>
    #include <umhelpc.h>
}


#include <lmoeusr.hxx>
#include <lmogroup.hxx>
#include <lmowks.hxx>
#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>
#include <asel.hxx>
#include <userprop.hxx>
#include <adminper.hxx>
#include <udelperf.hxx>
#include <usrmain.hxx>
#include <uitrace.hxx>

#include <ntacutil.hxx> // for QuerySystemSid



/*******************************************************************

    NAME:       USER_DELETE_PERFORMER::USER_DELETE_PERFORMER

    SYNOPSIS:   Constructor for USER_DELETE_PERFORMER object

    ENTRY:      powin -         pointer to owner window

                lasyusersel  -  LAZY_USER_SELECTION reference, selection
                                of groups or users. It is assumed that
                                the object should not be changed during
                                the lifetime of this object.

                loc   -         LOCATION reference, current focus.
                                It is assumed that the object should not
                                be changed during the lifetime of this object.

    HISTORY:
        o-SimoP     12-Aug-1991     Created

********************************************************************/

USER_DELETE_PERFORMER::USER_DELETE_PERFORMER(
        const UM_ADMIN_APP    * powin,
        const LAZY_USER_SELECTION & lazyusersel,
        const LOCATION        & loc )
        : PERFORMER( powin ),
          _lazyusersel( lazyusersel ),
          _loc( loc ),
          _nlsCurrUserOfTool(),
          _fUserRequestedYesToAll( FALSE ),
          _possidLoggedOnUser( NULL )
{
    if( QueryError() != NERR_Success )
        return;
    _possidLoggedOnUser = new OS_SID();
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _possidLoggedOnUser == NULL
        || (err = _possidLoggedOnUser->QueryError()) != NERR_Success
        || (err = _nlsCurrUserOfTool.QueryError()) != NERR_Success
        || (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                        UI_SID_CurrentProcessUser,
                        _possidLoggedOnUser )) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

// no longer needed
#if 0

    WKSTA_10 wksta10;
    err = wksta10.GetInfo();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
    _nlsCurrUserOfTool = wksta10.QueryLogonUser();
    err = _nlsCurrUserOfTool.QueryError();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

#endif // 0

}


/*******************************************************************

    NAME:       USER_DELETE_PERFORMER::~USER_DELETE_PERFORMER

    SYNOPSIS:   Destructor for USER_DELETE_PERFORMER object

    HISTORY:
        o-SimoP     12-Aug-1991     Created

********************************************************************/

USER_DELETE_PERFORMER::~USER_DELETE_PERFORMER()
{
    delete _possidLoggedOnUser;
    _possidLoggedOnUser = NULL;
}


/*******************************************************************

    NAME:       USER_DELETE_PERFORMER::PerformOne

    SYNOPSIS:   PERFORMER::PerformSeries calls this

    ENTRY:      iObject  -      index to LAZY_USER_SELECTION listbox

                perrMsg  -      pointer to error message, that
                                is only used when this function
                                return value is not NERR_Success

    RETURNS:    An error code which is NERR_Success on success.

    HISTORY:
        o-SimoP     12-Aug-1991 Created
        JonN        26-Aug-1991 added pfWorkWasDone parameter
        beng        04-Jun-1992 Change confirmation sequence slightly
        JonN        27-Jul-1992 Remove from builtin aliases
        JonN        16-Aug-1992 Added YesToAll
        JonN        19-Aug-1992 for single-select, MP_YESNO, not MP_YESNOCANCEL
        JonN        17-Sup-1992 Check for delete self without using WKSTA,
                                also compare logged-on domain

********************************************************************/

APIERR USER_DELETE_PERFORMER::PerformOne(
    UINT        iObject,
    APIERR  *   perrMsg,
    BOOL *      pfWorkWasDone )
{
    UIASSERT(   (perrMsg != NULL)
             && (pfWorkWasDone != NULL)
             && (_possidLoggedOnUser != NULL)
             && (_possidLoggedOnUser->QueryError() == NERR_Success)
            );

    *perrMsg = IDS_CannotDeleteUser;
    *pfWorkWasDone = FALSE;

    APIERR err = NERR_Success;

    if ( !IsDownlevelVariant() )
    {
        ADMIN_AUTHORITY * padminauth = QueryAdminAuthority();
        UIASSERT( padminauth != NULL && padminauth->QueryError() == NERR_Success );

        SAM_DOMAIN * pdomAccount = padminauth->QueryAccountDomain();
        UIASSERT(   pdomAccount != NULL && pdomAccount->QueryError() == NERR_Success );

        ULONG ridDeletedUser = ((USER_LBI *)QueryObjectItem(iObject))->QueryRID();
        OS_SID ossidDeletedUser(
                    pdomAccount->QueryPSID(),
                    ridDeletedUser );
        if ( (err = ossidDeletedUser.QueryError()) != NERR_Success
           )
        {
            DBGEOL( SZ("ADMIN: udelperf: NT_ACCOUNTS_UTILITY::QuerySystemSid() error") );
            return err;
        }

#if defined(DEBUG) && defined(TRACE)
        {
            NLS_STR nlsLoggedOnUser, nlsDeletedUser;
            if (   !!nlsLoggedOnUser
                && !!nlsDeletedUser
                && !_possidLoggedOnUser->QueryRawID( &nlsLoggedOnUser )
                && !ossidDeletedUser.QueryRawID( &nlsDeletedUser )
               )
            {
                TRACEEOL(   SZ("Logged on user ")
                         << nlsLoggedOnUser );
                TRACEEOL(   SZ("Deleted user   ")
                         << nlsDeletedUser );
            }
        }

#endif

        if ( *_possidLoggedOnUser == ossidDeletedUser )
        {
            // User may not delete himself
            ::MsgPopup( QueryOwnerWindow(), IDS_CannotDelUserOfTool,
                        MPSEV_INFO, MP_OK );
            return NERR_Success;
        }
    }

    // Format the display name
    USER_LBI * pulbi = (USER_LBI *)QueryObjectItem(iObject);
    ASSERT( pulbi != NULL );
    NLS_STR nlsDisplayName( pulbi->QueryName() );
    err = nlsDisplayName.QueryError();

    if ( err == NERR_Success )
    {
        NLS_STR nlsFullName( pulbi->QueryFullNameCch() );
        if (   (err = nlsFullName.QueryError()) == NERR_Success
            && (err = nlsFullName.CopyFrom( pulbi->QueryFullNamePtr(),
                                            pulbi->QueryFullNameCb() )) == NERR_Success
    	    && nlsFullName.QueryPch() != NULL
    	    && *(nlsFullName.QueryPch()) )
        {
            nlsDisplayName += SZ(" (");
            nlsDisplayName += nlsFullName;
            nlsDisplayName += SZ(")");
            err = nlsDisplayName.QueryError();
        }

    }
    if ( err != NERR_Success )
    {
        return err;
    }

    // It is important that nPopupReturned be a UINT, otherwise we will
    // call the wrong form of DELETE_USERS_DLG::Process().
    UINT nPopupReturned;
    err = NERR_Success;
    if ( _fUserRequestedYesToAll )
    {
        nPopupReturned = IDYES;
    }
    else if ( QueryObjectCount() == 1 )
    {
        nPopupReturned = ::MsgPopup( QueryOwnerWindow(),
                                     IDS_ConfirmUserDelete,
                                     MPSEV_WARNING, // was MPSEV_INFO
                                     MP_YESNO,
                                     nlsDisplayName.QueryPch() );
    }
    else
    {
        DELETE_USERS_DLG dlgDelUser((UM_ADMIN_APP *)QueryOwnerWindow(),
				    nlsDisplayName.QueryPch());
        if (   (err = dlgDelUser.QueryError()) != NERR_Success
            || (err = dlgDelUser.Process( &nPopupReturned )) != NERR_Success
           )
        {
            return err;
        }
    }

    switch (nPopupReturned)
    {
    case IDC_DelUsers_YesToAll:
        _fUserRequestedYesToAll = TRUE;
        // fall through

    case IDYES:
        break;

    case IDNO:  // skip this
        return NERR_Success;

    case IDCANCEL:
        return IERR_CANCEL_NO_ERROR;

    default:
        UIASSERT( FALSE );
        DBGEOL(    SZ("User Manager: DELETE_USERS_DLG returned ")
                << nPopupReturned );
        return NERR_Success;
    }

    AUTO_CURSOR autocur;

//
// USER::Delete() works fine (for NULL focus) even if WKSTA is not running
//

    const TCHAR *pszName = QueryObjectName( iObject );
    USER user( pszName, QueryLocation() );
    err = user.QueryError();
    if ( err == NERR_Success )
        err = user.Delete();

    if ( err == NERR_Success )
        *pfWorkWasDone = TRUE;

    //
    // JonN 7/27/92  Remove user account from builtin aliases
    // No warning on error
    //
    if ( (err == NERR_Success) && (!IsDownlevelVariant()) )
    {
        ADMIN_AUTHORITY * padminauth = QueryAdminAuthority();
        UIASSERT( padminauth != NULL && padminauth->QueryError() == NERR_Success );

        SAM_DOMAIN * pdomBuiltin = padminauth->QueryBuiltinDomain();
        UIASSERT( pdomBuiltin != NULL && pdomBuiltin->QueryError() == NERR_Success );

        SAM_DOMAIN * pdomAccount = padminauth->QueryAccountDomain();
        UIASSERT(   pdomAccount != NULL && pdomAccount->QueryError() == NERR_Success );

        ULONG ridDeletedUser = ((USER_LBI *)QueryObjectItem(iObject))->QueryRID();
        OS_SID ossidDeletedUser(
                    pdomAccount->QueryPSID(),
                    ridDeletedUser );
        APIERR errTemp = ossidDeletedUser.QueryError();
        if (errTemp == NERR_Success)
            errTemp = pdomBuiltin->RemoveMemberFromAliases( ossidDeletedUser.QueryPSID() );

#if defined(DEBUG) && defined(TRACE)
        if (errTemp != NERR_Success)
        {
            TRACEEOL( "User Manager: Error " << errTemp << " removing user from builtin aliases" );
        }
#endif
    }

    autocur.TurnOff();

    if (err == NERR_Success)
    {
        //
        // Notify the extensions
        //
        QueryUMAdminApp()->NotifyDeleteExtensions(
                                QueryOwnerWindow()->QueryHwnd(),
                                (USER_LBI *)QueryObjectItem( iObject ) );
    }

    // hydra
    if( err == NERR_Success )
    {
        err = RegUserConfigDelete( (WCHAR *)QueryLocation().QueryServer(),
                                   (WCHAR *)pszName );
    }

    return err;
}


/*******************************************************************

    NAME:       GROUP_DELETE_PERFORMER::GROUP_DELETE_PERFORMER

    SYNOPSIS:   Constructor for GROUP_DELETE_PERFORMER object

    ENTRY:      powin -         pointer to owner window

                asel  -         ADMIN_SELECTION reference, selection
                                of groups or users. It is assumed that
                                the object should not be changed during
                                the lifetime of this object.

                loc   -         LOCATION reference, current focus.
                                It is assumed that the object should not
                                be changed during the lifetime of this object.

    HISTORY:
        o-SimoP     12-Aug-1991     Created

********************************************************************/

GROUP_DELETE_PERFORMER::GROUP_DELETE_PERFORMER(
        const UM_ADMIN_APP   * powin,
        const ADMIN_SELECTION & asel,
        const LOCATION       & loc )
        : DELETE_PERFORMER( powin, asel, loc )
{
    if( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       GROUP_DELETE_PERFORMER::~GROUP_DELETE_PERFORMER

    SYNOPSIS:   Destructor for GROUP_DELETE_PERFORMER object

    HISTORY:
        o-SimoP     12-Aug-1991     Created

********************************************************************/

GROUP_DELETE_PERFORMER::~GROUP_DELETE_PERFORMER()
{
    ;
}


/*******************************************************************

    NAME:       GROUP_DELETE_PERFORMER::PerformOne

    SYNOPSIS:   PERFORMER::PerformSeries calls this

    ENTRY:      iObject  -      index to ADMIN_SELECTION listbox

                perrMsg  -      pointer to error message, that
                                is only used when this function
                                return value is not NERR_Success

    RETURNS:    An error code which is NERR_Success on success.

    NOTES:      This routine will handle deleting both Groups and Aliases.

    BUGBUG:     NTISSUE 763 specs behavior here which is not currently
                implemented.

    HISTORY:
        o-SimoP     12-Aug-1991 Created
        JonN        26-Aug-1991 added pfWorkWasDone parameter
        Thomaspa    10-Apr-1992 added support for aliases
        beng        04-Jun-1992 Deleting aliases allows confirmation, too
        JonN        19-Aug-1992 for single-select, MP_YESNO, not MP_YESNOCANCEL

********************************************************************/

APIERR GROUP_DELETE_PERFORMER::PerformOne(
    UINT        iObject,
    APIERR  *   perrMsg,
    BOOL *      pfWorkWasDone )
{
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    *perrMsg = IDS_CannotDeleteGroup;
    *pfWorkWasDone = FALSE;

    BOOL fAlias = ((GROUP_LBI*)QueryObjectItem(iObject))->IsAliasLBI();
    APIERR err = NERR_Success;

    const TCHAR *pszName = QueryObjectName( iObject );

    // Determine whether in fact this item may be deleted

    if (fAlias)
    {
        ALIAS_LBI * paliaslbi = (ALIAS_LBI *)QueryObjectItem( iObject );
        if ( paliaslbi->IsBuiltinAlias() )
        {
            return IERR_CannotDeleteSystemGrp; // BUGBUG another error
        }
    }
    else
    {
        if (( ::I_MNetNameCompare( NULL, pszName,
            ::pszSpecialGroupUsers, NAMETYPE_GROUP, 0L )  == NERR_Success ) ||
            ( ::I_MNetNameCompare( NULL, pszName,
            ::pszSpecialGroupAdmins, NAMETYPE_GROUP, 0L ) == NERR_Success ) ||
            ( ::I_MNetNameCompare( NULL, pszName,
            ::pszSpecialGroupGuests, NAMETYPE_GROUP, 0L ) == NERR_Success ) )
        {
            return IERR_CannotDeleteSystemGrp;
        }
    }

    // Last chance for the user to wimp out

    switch ( ::MsgPopup( QueryOwnerWindow(), IDS_ConfirmGroupDelete,
                         MPSEV_WARNING, // was MPSEV_INFO
                         MP_YESNO,
                         pszName ) )
    {
    case IDYES:
        break;

    case IDNO:      // skip this group (don't report an error, of course)
    default:
        return NERR_Success;
    }

    // Do it to it

    AUTO_CURSOR autocur;

    if (fAlias)
    {
        ALIAS_LBI * paliaslbi = (ALIAS_LBI *)QueryObjectItem( iObject );
        SAM_DOMAIN * psamdomain = QueryAdminAuthority()->QueryAccountDomain();

        SAM_ALIAS * psamalias = new SAM_ALIAS( *psamdomain,
                                               paliaslbi->QueryRID() );

        err = ERROR_NOT_ENOUGH_MEMORY;
        if ( (psamalias == NULL)
            || ((err = psamalias->QueryError()) != NERR_Success) )
        {
                return err;
        }

        err = psamalias->Delete();

        delete psamalias;
    }
    else
    {
        GROUP group( pszName, QueryLocation() );
        err = group.QueryError();

        if (err == NERR_Success)
	{
	    if (!IsDownlevelVariant())
            {
	        // Delete the group from any aliases in the Builtin Domain

                ADMIN_AUTHORITY * padminauth = QueryAdminAuthority();
                UIASSERT( padminauth != NULL
		    && padminauth->QueryError() == NERR_Success );

                SAM_DOMAIN * pdomBuiltin = padminauth->QueryBuiltinDomain();
                UIASSERT( pdomBuiltin != NULL
		    && pdomBuiltin->QueryError() == NERR_Success );

                SAM_DOMAIN * pdomAccount = padminauth->QueryAccountDomain();
                UIASSERT( pdomAccount != NULL
		    && pdomAccount->QueryError() == NERR_Success );


	        SAM_RID_MEM SAMRidMem ;
	        SAM_SID_NAME_USE_MEM SAMSidNameUseMem ;

	        APIERR errTemp;
	        if ( (errTemp = SAMRidMem.QueryError()) ||
		     (errTemp = SAMSidNameUseMem.QueryError()) ||
		     (errTemp = pdomAccount->TranslateNamesToRids(
							&pszName,
							1,
							&SAMRidMem,
							&SAMSidNameUseMem )))
	        {
		    TRACEEOL("GROUP_DELETE_PERFORMER::PerformOne - "
				<< "TranslateNamesToRidsfailed with error "
				<< errTemp ) ;
	        }

		// Can't delete the group until after we have looked up
		// its RID.
                err = group.Delete();

	        if (err == NERR_Success && errTemp == NERR_Success)
	        {
                    OS_SID ossidDeletedGroup( pdomAccount->QueryPSID(),
                    		      SAMRidMem.QueryRID( 0 ));

                    errTemp = ossidDeletedGroup.QueryError();

                    if (errTemp == NERR_Success)
                        errTemp = pdomBuiltin->RemoveMemberFromAliases(
					ossidDeletedGroup.QueryPSID() );

	        }
            }
 	    else
	    {
                err = group.Delete();
	    }

	}

    }

    autocur.TurnOff();

    if ( err == NERR_Success )
    {
        *pfWorkWasDone = TRUE;

        //
        // Notify the extensions
        //
        QueryUMAdminApp()->NotifyDeleteExtensions(
                                QueryOwnerWindow()->QueryHwnd(),
                                (GROUP_LBI *)QueryObjectItem( iObject ) );
    }

    return err;
}



/*******************************************************************

    NAME:       DELETE_USERS_DLG::DELETE_USERS_DLG

    SYNOPSIS:   Constructor for DELETE_USERS_DLG object

    HISTORY:
	JonN	16-Aug-1992	Created

********************************************************************/

DELETE_USERS_DLG::DELETE_USERS_DLG(
	UM_ADMIN_APP * pumadminapp,
	const TCHAR * pszUserName )
        : DIALOG_WINDOW(  MAKEINTRESOURCE(IDD_DELETE_USERS),
			 ((OWNER_WINDOW *)pumadminapp)->QueryHwnd() ),
	  _pumadminapp( pumadminapp ),
          _sltText( this, IDC_DelUsers_Text )
{
    if( QueryError() != NERR_Success )
        return;

    ALIAS_STR nlsInsert( pszUserName );
    RESOURCE_STR nls( IDS_ConfirmUserDelete );
    nls.InsertParams( nlsInsert );

    APIERR err = nls.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltText.SetText( nls );
}


/*******************************************************************

    NAME:       DELETE_USERS_DLG::~DELETE_USERS_DLG

    SYNOPSIS:   Destructor for DELETE_USERS_DLG object

    HISTORY:
	JonN	16-Aug-1992	Created

********************************************************************/

DELETE_USERS_DLG::~DELETE_USERS_DLG()
{
    ;
}


/*******************************************************************

    NAME:       DELETE_USERS_DLG::OnCommand

    SYNOPSIS:   Handles control notifications

    RETURNS:    TRUE if message was handled; FALSE otherwise

    HISTORY:
	JonN	16-Aug-1992	Created

********************************************************************/

BOOL DELETE_USERS_DLG::OnCommand( const CONTROL_EVENT & ce )
{
    switch ( ce.QueryCid())
    {
    case IDYES:
    case IDC_DelUsers_YesToAll:
    case IDNO:
        Dismiss( ce.QueryCid() );
        return TRUE;

    default:
        break;
    }

    return DIALOG_WINDOW::OnCommand( ce );

}  // DELETE_USERS_DLG::OnCommand



/*********************************************************************

    NAME:       DELETE_USERS_DLG::OnCancel

    SYNOPSIS:   Called when the dialog's Cancel button is clicked.
                Assumes that the Cancel button has control ID IDCANCEL.

    RETURNS:
        TRUE if action was taken,
        FALSE otherwise.

    NOTES:
        The default implementation dismisses the dialog, returning FALSE.
        This variant returns TRUE if a user has already been added.

    HISTORY:
        jonn      13-May-1992      Templated from bltdlg.cxx

*********************************************************************/

BOOL DELETE_USERS_DLG::OnCancel( void )
{
    Dismiss( IDCANCEL );
    return TRUE;
} // DELETE_USERS_DLG::OnCancel


/*******************************************************************

    NAME:       DELETE_USERS_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    NOTES:	As per FuncSpec, context-sensitive help should be
		available here to explain how to promote a backup
		domain controller to primary domain controller.

    HISTORY:
	JonN	16-Aug-1992	Created

********************************************************************/

ULONG DELETE_USERS_DLG::QueryHelpContext( void )
{
    return HC_UM_DELMULTIUSER_LANNT + _pumadminapp->QueryHelpOffset();

} // DELETE_USERS_DLG :: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\umsplit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    umsplit.cxx
        Source file for the User Manager Splitter Bar custom control

    FILE HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)
*/


#include <ntincl.hxx> // UNICODE_STRING

extern "C"
{
    #include <ntsam.h> // DOMAIN_DISPLAY_USER
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_DIALOG
#define INCL_BLT_APP
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>
#include <umsplit.hxx>
#include <usrmain.hxx>


/*********************************************************************

    NAME:       USRMGR_SPLITTER_BAR::USRMGR_SPLITTER_BAR

    SYNOPSIS:   Splitter bar for the User Manager main window

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

USRMGR_SPLITTER_BAR::USRMGR_SPLITTER_BAR( OWNER_WINDOW * powin,
                                          CID cid,
                                          UM_ADMIN_APP * pumadminapp
                                          )
    : H_SPLITTER_BAR ( powin, cid,
                       XYPOINT( 0, 0 ), XYDIMENSION( 0, 0 ),
                       WS_CHILD ),
      _pumadminapp( pumadminapp )
{
    ASSERT( pumadminapp != NULL && _pumadminapp->QueryError() == NERR_Success );
}

USRMGR_SPLITTER_BAR::~USRMGR_SPLITTER_BAR()
{
    // nothing to do here
}


/*********************************************************************

    NAME:       USRMGR_SPLITTER_BAR::MakeDisplayContext

    SYNOPSIS:   See bltsplit.hxx

    HISTORY:
        jonn    11-Oct-93   Created

**********************************************************************/

VOID USRMGR_SPLITTER_BAR::MakeDisplayContext( DISPLAY_CONTEXT ** ppdc )
{
    ASSERT( ppdc != NULL );
    *ppdc = new DISPLAY_CONTEXT( this );
}


/*********************************************************************

    NAME:       USRMGR_SPLITTER_BAR::OnDragRelease

    SYNOPSIS:   This will be called when the user has finished moving
                the splitter bar.

    HISTORY:
        jonn    11-Oct-93   Created

**********************************************************************/

VOID USRMGR_SPLITTER_BAR::OnDragRelease( const XYPOINT & xyClientCoords )
{
    XYRECT xyrectOwner( QueryOwnerHwnd() );
    INT dyOwnerHeight = xyrectOwner.CalcHeight();

    /*
     *   Convert drag release point to main window coordinates
     */
    XYPOINT xyTemp( xyClientCoords );
    xyTemp.ClientToScreen( WINDOW::QueryHwnd() );
    xyTemp.ScreenToClient( WINDOW::QueryOwnerHwnd() );

    _pumadminapp->ChangeUserSplit( xyTemp.QueryY() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\umx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    umx.cxx
    This file contains the class definitions for the classes related
    to the User Manager Extensions.


    FILE HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

*/

#include <ntincl.hxx>

extern "C"
{
    #include <ntsam.h>
    #include <ntlsa.h>

}   // extern "C"

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_APP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#define INCL_BLT_MENU
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <adminapp.hxx>
#include <lmodom.hxx>

#include <usrlb.hxx>
#include <usrmain.hxx>
#include <umx.hxx>

extern "C"
{
    #include <adminapp.h>

}   // extern "C"


//
//  UM_MENU_EXT methods.
//

/*******************************************************************

    NAME:       UM_MENU_EXT :: UM_MENU_EXT

    SYNOPSIS:   UM_MENU_EXT class constructor.

    ENTRY:      pumaapp                 - The "owning" app.

                pszExtensionDll         - The name of the extension DLL.

                dwDelta                 - The menu/control ID delta
                                          for this extension.

                hWnd                    - The "owning" app window.

    EXIT:       The object is constructed.

    HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

********************************************************************/
UM_MENU_EXT :: UM_MENU_EXT( UM_ADMIN_APP * pumaapp,
                            const TCHAR  * pszExtensionDll,
                            DWORD          dwDelta,
                            HWND           hWnd )
  : AAPP_MENU_EXT( pszExtensionDll, dwDelta ),
    _pumaapp( pumaapp ),
    _pumxLoad( NULL ),
    _pumxGetError( NULL ),
    _pumxUnload( NULL ),
    _pumxMenuInit( NULL ),
    _pumxRefresh( NULL ),
    _pumxActivate( NULL ),
    _pumxCreate( NULL ),
    _pumxDelete( NULL ),
    _pumxRename( NULL )
{
    UIASSERT( pumaapp != NULL );
    UIASSERT( pszExtensionDll != NULL );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "UM_MENU_EXT failed to construct" );
        return;
    }

    //
    //  Let's see if we can load the DLL.
    //
    //  Added LOAD_WITH_ALTERED_SEARCH_PATH for Touchdown -- JonN 7/14/94
    //

    HMODULE hDll = ::LoadLibraryEx( pszExtensionDll,
                                    NULL,
                                    LOAD_WITH_ALTERED_SEARCH_PATH );

    if( hDll == NULL )
    {
        DBGEOL( "UM_MENU_EXT : cannot load " << pszExtensionDll );
        ReportError( (APIERR)::GetLastError() );
        return;
    }

    SetDllHandle( hDll );

    //
    //  Let's see if the entrypoints are available.
    //

    _pumxLoad     = (PUMX_LOADMENU)
                        ::GetProcAddress( hDll, SZ_UME_LOADMENU );
    _pumxGetError = (PUMX_GETEXTENDEDERRORSTRING)
                        ::GetProcAddress( hDll, SZ_UME_GETEXTENDEDERRORSTRING );
    _pumxUnload   = (PUMX_UNLOADMENU)
                        ::GetProcAddress( hDll, SZ_UME_UNLOADMENU );
    _pumxMenuInit = (PUMX_INITIALIZEMENU)
                        ::GetProcAddress( hDll, SZ_UME_INITIALIZEMENU );
    _pumxRefresh  = (PUMX_REFRESH)
                        ::GetProcAddress( hDll, SZ_UME_REFRESH );
    _pumxActivate = (PUMX_MENUACTION)
                        ::GetProcAddress( hDll, SZ_UME_MENUACTION );
    _pumxCreate   = (PUMX_CREATE)
                        ::GetProcAddress( hDll, SZ_UME_CREATE );
    _pumxDelete   = (PUMX_DELETE)
                        ::GetProcAddress( hDll, SZ_UME_DELETE );
    _pumxRename   = (PUMX_RENAME)
                        ::GetProcAddress( hDll, SZ_UME_RENAME );

    if( ( _pumxLoad     == NULL ) ||
        ( _pumxGetError == NULL ) ||
        ( _pumxUnload   == NULL ) ||
        ( _pumxMenuInit == NULL ) ||
        ( _pumxRefresh  == NULL ) ||
        ( _pumxActivate == NULL ) ||
        ( _pumxCreate   == NULL ) ||
        ( _pumxDelete   == NULL ) ||
        ( _pumxRename   == NULL ) )
    {
        DBGEOL( "UM_MENU_EXT : entrypoint(s) missing from " << pszExtensionDll );
        ReportError( ERROR_PROC_NOT_FOUND );
        return;
    }

    //
    //  Send a load notification.
    //

    UMS_LOADMENU umsload;

    umsload.dwVersion   = UM_MENU_EXT_VERSION;
    umsload.dwMenuDelta = dwDelta;

    APIERR err = I_Load( hWnd, &umsload );

    if( err != NERR_Success )
    {
        DBGEOL( "UM_MENU_EXT : load notification returned " << err );
        ReportError( err );
        return;
    }

    //
    //  Save the extension's version number.
    //

    SetVersion( umsload.dwVersion );

    //
    //  Save other data from the extension.
    //

    SetMenuHandle( umsload.hMenu );

    err = SetMenuName( umsload.szMenuName );

    if( err == NERR_Success )
    {
        err = SetHelpFileName( umsload.szHelpFileName );
    }

    //
    //  Adjust the menu IDs.
    //

    err = BiasMenuIds( dwDelta );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // UM_MENU_EXT :: UM_MENU_EXT


/*******************************************************************

    NAME:       UM_MENU_EXT :: ~UM_MENU_EXT

    SYNOPSIS:   UM_MENU_EXT class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

********************************************************************/
UM_MENU_EXT :: ~UM_MENU_EXT( VOID )
{
    if( _pumxUnload != NULL )
    {
        I_Unload();
    }

    _pumxLoad     = NULL;
    _pumxGetError = NULL;
    _pumxUnload   = NULL;
    _pumxMenuInit = NULL;
    _pumxRefresh  = NULL;
    _pumxActivate = NULL;
    _pumxCreate   = NULL;
    _pumxDelete   = NULL;
    _pumxRename   = NULL;

}   // UM_MENU_EXT :: ~UM_MENU_EXT


/*******************************************************************

    NAME:       UM_MENU_EXT :: Refresh

    SYNOPSIS:   Sends a refresh notification to the extension.

    HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: Refresh( HWND hwndParent ) const
{
    I_Refresh( hwndParent );

}   // UM_MENU_EXT :: Refresh


/*******************************************************************

    NAME:       UM_MENU_EXT :: MenuInit

    SYNOPSIS:   Sends a menu init notification to the extension.

    HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: MenuInit( VOID ) const
{
    I_MenuInit();

}   // UM_MENU_EXT :: MenuInit


/*******************************************************************

    NAME:       UM_MENU_EXT :: NotifyCreate

    SYNOPSIS:   Sends a create notification to the extension.

    HISTORY:
        JonN        23-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: NotifyCreate( HWND hwndParent,
                                  PUMS_GETSEL pumsSelection ) const
{
    I_NotifyCreate( hwndParent, pumsSelection );

}   // UM_MENU_EXT :: NotifyCreate


/*******************************************************************

    NAME:       UM_MENU_EXT :: NotifyDelete

    SYNOPSIS:   Sends a delete notification to the extension.

    HISTORY:
        JonN        23-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: NotifyDelete( HWND hwndParent,
                                  PUMS_GETSEL pumsSelection ) const
{
    I_NotifyDelete( hwndParent, pumsSelection );

}   // UM_MENU_EXT :: NotifyDelete


/*******************************************************************

    NAME:       UM_MENU_EXT :: NotifyRename

    SYNOPSIS:   Sends a rename notification to the extension.

    HISTORY:
        JonN        23-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: NotifyRename( HWND hwndParent,
                                  PUMS_GETSEL pumsSelection,
                                  const TCHAR * pchNewName   ) const
{
    I_NotifyRename( hwndParent, pumsSelection, pchNewName );

}   // UM_MENU_EXT :: NotifyRename


/*******************************************************************

    NAME:       UM_MENU_EXT :: Activate

    SYNOPSIS:   Activates the extension.

    ENTRY:      dwId                    - The id for this activation.

    HISTORY:
        JonN        19-Nov-1992     Created, templated from smx.cxx

********************************************************************/
VOID UM_MENU_EXT :: Activate( HWND hwndParent, DWORD dwId ) const
{

    UIASSERT( ( dwId > 0 ) && ( dwId < 100 ) )
    I_Activate( hwndParent, dwId );

}   // UM_MENU_EXT :: Activate


//
//  USRMGR_MENU_EXT_MGR methods.
//

/*******************************************************************

    NAME:       USRMGR_MENU_EXT_MGR :: USRMGR_MENU_EXT_MGR

    SYNOPSIS:   USRMGR_MENU_EXT_MGR class constructor.

    ENTRY:      pExtMgrIf               - Points to an object representing
                                          the interface between the
                                          extension manager & the application.

                dwInitialDelta          - The initial menu/control ID delta.

                dwDeltaDelta            - The "inter-delta offset".

    EXIT:       The object is constructed.

    HISTORY:
        JonN        23-Nov-1992     Created.

********************************************************************/
USRMGR_MENU_EXT_MGR :: USRMGR_MENU_EXT_MGR( UI_EXT_MGR_IF * pExtMgrIf,
                                            DWORD           dwInitialDelta,
                                            DWORD           dwDeltaDelta )
  : UI_MENU_EXT_MGR( pExtMgrIf, dwInitialDelta, dwDeltaDelta )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        DBGEOL( "USRMGR_MENU_EXT_MGR failed to construct" );
        return;
    }

}   // USRMGR_MENU_EXT_MGR :: USRMGR_MENU_EXT_MGR


/*******************************************************************

    NAME:       USRMGR_MENU_EXT_MGR :: ~USRMGR_MENU_EXT_MGR

    SYNOPSIS:   USRMGR_MENU_EXT_MGR class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        JonN        23-Nov-1992     Created.

********************************************************************/
USRMGR_MENU_EXT_MGR :: ~USRMGR_MENU_EXT_MGR( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // USRMGR_MENU_EXT_MGR :: ~USRMGR_MENU_EXT_MGR


/*******************************************************************

    NAME:       USRMGR_MENU_EXT_MGR :: NotifyCreateExtensions

    SYNOPSIS:   This method notifies all loaded extensions that a
                user has been created.

    HISTORY:
        JonN        23-Nov-1992     Created.

********************************************************************/
VOID USRMGR_MENU_EXT_MGR::NotifyCreateExtensions( HWND hwndParent,
                                                  PUMS_GETSEL pumsSelection )
{
    UIASSERT(   QueryExtMgrIf() != NULL
             && QueryExtMgrIf()->QueryError() == NERR_Success );

    //
    //  Enumerate & refresh the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        ((UM_MENU_EXT *)pExt)->NotifyCreate( hwndParent, pumsSelection );
    }

}   // UI_EXT_MGR :: NotifyCreateExtensions


/*******************************************************************

    NAME:       USRMGR_MENU_EXT_MGR :: NotifyDeleteExtensions

    SYNOPSIS:   This method notifies all loaded extensions that a
                user has been deleted.

    HISTORY:
        JonN        23-Nov-1992     Created.

********************************************************************/
VOID USRMGR_MENU_EXT_MGR::NotifyDeleteExtensions( HWND hwndParent,
                                                  PUMS_GETSEL pumsSelection )
{
    UIASSERT(   QueryExtMgrIf() != NULL
             && QueryExtMgrIf()->QueryError() == NERR_Success );

    //
    //  Enumerate & refresh the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        ((UM_MENU_EXT *)pExt)->NotifyDelete( hwndParent, pumsSelection );
    }

}   // UI_EXT_MGR :: NotifyDeleteExtensions


/*******************************************************************

    NAME:       USRMGR_MENU_EXT_MGR :: NotifyRenameExtensions

    SYNOPSIS:   This method notifies all loaded extensions that a
                user has been renamed.

    HISTORY:
        JonN        23-Nov-1992     Created.

********************************************************************/
VOID USRMGR_MENU_EXT_MGR::NotifyRenameExtensions( HWND hwndParent,
                                                  PUMS_GETSEL pumsSelection,
                                                  const TCHAR * pchNewName )
{
    UIASSERT(   QueryExtMgrIf() != NULL
             && QueryExtMgrIf()->QueryError() == NERR_Success );

    //
    //  Enumerate & refresh the extension objects.
    //

    ITER_SL_OF( UI_EXT ) iter( *QueryExtensions() );
    UI_EXT * pExt;

    while( ( pExt = iter.Next() ) != NULL )
    {
        ((UM_MENU_EXT *)pExt)->NotifyRename( hwndParent,
                                             pumsSelection,
                                             pchNewName );
    }

}   // UI_EXT_MGR :: NotifyRenameExtensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\useracct.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    useracct.cxx


    FILE HISTORY:
    JonN	29-Jul-1991	Created
    JonN        26-Aug-1991     PROP_DLG code review changes
    JonN	11-Sep-1991	USERPROP_DLG code review changes part 1 (9/6/91)
				Attending: KevinL, RustanL, JonN, o-SimoP
    o-SimoP	20-Sep-1991	Major changes
    o-SimoP	25-Sep-1991	Code review changes (9/24/91)
				Attending: JimH, JonN, DavidHov and I
    JonN	08-Oct-1991	LM_OBJ type changes
    JonN	17-Oct-1991	Uses SLE_STRIP
    terryk	10-Nov-1991	change I_NetXXX to I_MNetXXX
    JonN	01-Jan-1992	PerformOne calls USER_SUBPROP_DLG::PerformOne
    JonN	18-Feb-1992	Restructured for NT:
				Moved UserCannotChangePass to USERPROP
				Removed unnecessary controls
    JonN	21-Feb-1992	Added NT variant
    JonN        06-Mar-1992     Moved GetOne from subprop subclasses
    terryk      17-Apr-1992     Added INTL_PROFILE object
    JonN        28-Apr-1992     Enabled NT variant
    Yi-HsinS	08-Dev-1992	Fixed WIN_TIME class usage
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETACCESS
#define INCL_NETCONS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_APP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_TIME_DATE
#include <blt.hxx>
extern "C"
{
    #include <mnet.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>


extern "C"
{
    #include <usrmgrrc.h>
    #include <umhelpc.h>
}

#include <usrmain.hxx>
#include <useracct.hxx>
#include <lmowks.hxx>
#include <lmomisc.hxx>  // for tod
#include <ntuser.hxx>   // for USER_3
#include <intlprof.hxx>
#include <errmap.hxx>


#define SECONDS_PER_DAY  60*60*24


//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:	USERACCT_DLG::USERACCT_DLG

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
		downlevel variant

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
    JonN        29-Jul-1991     Created
    o-SimoP	20-Sep-1991	Major changes
    terryk	17-Apr-1992	added INTL_PROFILE object

********************************************************************/

USERACCT_DLG::USERACCT_DLG(
	USERPROP_DLG * puserpropdlgParent,
        const TCHAR * pszResourceName,
	const LAZY_USER_LISTBOX * pulb
	) : USER_SUBPROP_DLG(
		puserpropdlgParent,
                pszResourceName,
		pulb
		),
	    _lAccountExpires( TIMEQ_FOREVER ),
	    _fIndeterminateAcctExpires( FALSE ),
	    _pmgrpAccountExpires( NULL ),
	    _pbltdspgrpEndOf( NULL )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    _pmgrpAccountExpires = new MAGIC_GROUP( this, IDDT_RB_NEVER, 2 );

    INTL_PROFILE intlprof;  // get it for the time date format
    if ( (err = intlprof.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _pbltdspgrpEndOf = new BLT_DATE_SPIN_GROUP( this, intlprof,
			IDDT_SPINB_END_OF,
			IDDT_SPINB_UP_ARROW, IDDT_SPINB_DOWN_ARROW,
			IDDT_SPING_MONTH, IDDT_SPING_SEP1, IDDT_SPING_DAY,
			IDDT_SPING_SEP2, IDDT_SPING_YEAR, IDDT_SPING_FRAME );
    if( _pmgrpAccountExpires == NULL || _pbltdspgrpEndOf == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if( (err = _pmgrpAccountExpires->QueryError()) != NERR_Success ||
	(err = _pbltdspgrpEndOf->QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}// USERACCT_DLG::USERACCT_DLG



/*******************************************************************

    NAME:       USERACCT_DLG::~USERACCT_DLG

    SYNOPSIS:   Destructor for User Properties Accounts subdialog

    HISTORY:
    JonN        29-Jul-1991     Created

********************************************************************/

USERACCT_DLG::~USERACCT_DLG( void )
{
    delete _pmgrpAccountExpires;
    delete _pbltdspgrpEndOf;

}// USERACCT_DLG::~USERACCT_DLG



/*******************************************************************

    NAME:       USERACCT_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
               o-SimoP 20-Sep-1991    created
               JonN    01-Apr-1993    Convert from GMT

********************************************************************/

APIERR USERACCT_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{
    APIERR err = NERR_Success;

    USER_2 * puser2Curr = QueryUser2Ptr( iObject );

    LONG lCurrAccntExpires = puser2Curr->QueryAccountExpires();
    if (lCurrAccntExpires != TIMEQ_FOREVER)
    {
        // Let WIN_TIME convert from GMT
        WIN_TIME wintime( (ULONG) lCurrAccntExpires, TRUE ); // GMT
        err = wintime.QueryTimeLocal( (ULONG *) &lCurrAccntExpires );
    }

    if ( iObject == 0 ) // first object
    {
	_lAccountExpires = lCurrAccntExpires;
    }
    else	// iObject > 0
    {
	if ( !_fIndeterminateAcctExpires )
	{
	    if ( _lAccountExpires != lCurrAccntExpires )
		_fIndeterminateAcctExpires = TRUE;
	}
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );
	
} // USERACCT_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERACCT_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERACCT_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
               JonN  29-Jul-1991    created

********************************************************************/

APIERR USERACCT_DLG::InitControls()
{
    APIERR err = NERR_Success;

    if ( !_fIndeterminateAcctExpires )
    {
	if( _lAccountExpires == TIMEQ_FOREVER )
	{
	    err = SetDayField( AI_DAY_DEFAULT );
	    _pmgrpAccountExpires->SetSelection( IDDT_RB_NEVER );	
            (*_pmgrpAccountExpires)[IDDT_RB_NEVER]->ClaimFocus();
	}	
	else
	{
	    err = SetDayField( AI_DAY_FROM_MEMBER );
    	    _pmgrpAccountExpires->SetSelection( IDDT_RB_END_OF );
            (*_pmgrpAccountExpires)[IDDT_RB_END_OF]->ClaimFocus();
	}
    }
    else
    {
	err = SetDayField( AI_DAY_DEFAULT );
        _plbLogonName->ClaimFocus();
    }

    if( err != NERR_Success )
	return err;

    err = _pmgrpAccountExpires->AddAssociation(
	    IDDT_RB_END_OF,
	    _pbltdspgrpEndOf );

    return (err == NERR_Success) ? USER_SUBPROP_DLG::InitControls() : err;

} // USERACCT_DLG::InitControls


/*******************************************************************

    NAME:       USERACCT_DLG::SetDayField
	
    SYNOPSIS:	Set day field in Account dlg

    ENTRY:	day  -	AI_DAY_DEFAULT, current day + about 30 days
	                AI_DAY_FROM_MEMBER read day info from member

    HISTORY:
               o-SimoP  16-Sep-1991    created

********************************************************************/

APIERR USERACCT_DLG::SetDayField( enum AI_DAY_TYPE day )
{
    WIN_TIME time( TRUE ); // GMT
    APIERR err = time.QueryError();

    if ( err == NERR_Success )
    {
        if( day == AI_DAY_DEFAULT )
        {
            ULONG ulTimeGMT;
            // QueryCurrentTime only callable when in GMT mode
            if (   (err = time.SetCurrentTime()) != NERR_Success
                || (err = time.QueryTimeGMT( &ulTimeGMT )) != NERR_Success
                || (err = time.SetTimeGMT ( ulTimeGMT + (30*SECONDS_PER_DAY) ))
                        != NERR_Success
               )
            {
                DBGEOL( "USERACCT_DLG::SetDayField: could not fetch current day" );
            }
        }
        else
        {
	    err = time.SetTimeLocal( _lAccountExpires );
        }

        if ( err == NERR_Success )
        {
            err = time.SetGMT( FALSE );
        }

        if ( err == NERR_Success )
        {
            // Subtract one day since we display the "end of" day
            ULONG tTime;
            err = time.QueryTimeLocal( &tTime );
            if ( err == NERR_Success )
            {
                err = time.SetTimeLocal( tTime - SECONDS_PER_DAY );
            }

            if ( err == NERR_Success )
            {
                _pbltdspgrpEndOf->SetYear( time.QueryYear() );
                _pbltdspgrpEndOf->SetMonth( time.QueryMonth() );
                _pbltdspgrpEndOf->SetDay( time.QueryDay() );
            }
        }
    }

    return err;
}


/*******************************************************************

    NAME:       USERACCT_DLG::OnOK

    SYNOPSIS:   OK button handler

    HISTORY:
               JonN    29-Jul-1991    created
	       o-SimoP 20-Sep-1991    modified
********************************************************************/

BOOL USERACCT_DLG::OnOK( void )
{
    APIERR err = W_DialogToMembers();

    switch( err )
    {
    case NERR_Success:
	break;
	
    case IERR_CANCEL_NO_ERROR:	// Message was given by control
	return TRUE;
	
    default:
	::MsgPopup( this, err );
	return TRUE;
    }

    if (   PerformSeries()
        && (IsNewVariant() || QueryWorkWasDone()) ) /* QueryWWD is
			    * here because we don't want to dismiss
			    * dialog when control reports error */
	Dismiss(); // Dismiss code not used
    return TRUE;

}   // USERACCT_DLG::OnOK


/*******************************************************************

    NAME:       USERACCT_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	       o-SimoP  20-Sep-1991    created

********************************************************************/

APIERR USERACCT_DLG::W_DialogToMembers()
{
    CID cid = _pmgrpAccountExpires->QuerySelection();
    if( cid != RG_NO_SEL )
    {
	_fIndeterminateAcctExpires = FALSE;
	if( cid == IDDT_RB_NEVER )
	    _lAccountExpires = TIMEQ_FOREVER;
	else
	{
	    if( _pbltdspgrpEndOf->IsValid() )
	    {
                // We pass FALSE to the ctor, indicating that we will be
                // entering local times
		WIN_TIME time( FALSE );
                APIERR err = time.QueryError();
                if ( err == NERR_Success )
                {
		    time.SetDay( _pbltdspgrpEndOf->QueryDay() );
		    time.SetMonth( _pbltdspgrpEndOf->QueryMonth() );
		    time.SetYear( _pbltdspgrpEndOf->QueryYear() );

                    // Add one day since we display the "end of" day
                    ULONG tTime;
                    if (   (err = time.Normalize()) != NERR_Success
                        || (err = time.QueryTimeLocal( &tTime )) != NERR_Success
                        || (err = time.SetTimeLocal( tTime + SECONDS_PER_DAY )) != NERR_Success
                        || (err = time.QueryTimeLocal( (ULONG *) &_lAccountExpires )) != NERR_Success
                       )
                    {
                        DBGEOL( "USERACCT_DLG::W_DialogToMembers: normalize error " << err );
		    }
                }

                if ( err != NERR_Success )
 		    return err;
	    }
	    else
	    {	// bltdspgrpEndOf gives error messages
		return IERR_CANCEL_NO_ERROR;
	    }
	}
    }
    else // RG_NO_SEL
    {
	_fIndeterminateAcctExpires = TRUE;
    }

    return USER_SUBPROP_DLG::W_DialogToMembers();

} // USERACCT_DLG::W_DialogToMembers


/*******************************************************************

    NAME:       USERACCT_DLG::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_2 is changed

    HISTORY:
	JonN	31-Dec-1991   created

********************************************************************/

BOOL USERACCT_DLG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       USERACCT_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	       o-SimoP  20-Sep-1991    created

********************************************************************/

APIERR USERACCT_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    APIERR err = NERR_Success;

    if ( !_fIndeterminateAcctExpires )
    {
        ULONG  ulCurrAcctExpiresLocal = (ULONG) _lAccountExpires;
        ULONG  ulCurrAcctExpiresGMT;
        if (ulCurrAcctExpiresLocal == TIMEQ_FOREVER)
        {
            ulCurrAcctExpiresGMT = TIMEQ_FOREVER;
        }
        else
        {
            // Let WIN_TIME convert from GMT
            WIN_TIME wintime( FALSE ); // local time
            if (   (err = wintime.SetTimeLocal( ulCurrAcctExpiresLocal )) != NERR_Success
                || (err = wintime.QueryTimeGMT( &ulCurrAcctExpiresGMT )) != NERR_Success
               )
            {
                DBGEOL( "USERACCT_DLG::W_MembersFromLMOBJ: conversion failed with error "
                        << err );
                return err;
            }
        }

	err = puser2->SetAccountExpires( (LONG)ulCurrAcctExpiresGMT );
	if( err != NERR_Success )
	    return err;
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERACCT_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       USERACCT_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
               o-SimoP  20-Sep-1991    created

********************************************************************/

ULONG USERACCT_DLG::QueryHelpContext( void )
{

    return HC_UM_DETAIL_LANNT + QueryHelpOffset();

} // USERACCT_DLG :: QueryHelpContext



/*******************************************************************

    NAME:	USERACCT_DLG_DOWNLEVEL::USERACCT_DLG_DOWNLEVEL

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
		downlevel variant

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
    JonN        29-Jul-1991     Created
    o-SimoP	20-Sep-1991	Major changes
    terryk	17-Apr-1992	added INTL_PROFILE object
    thomaspa    22-Oct-1992	Merged with USERPRIV_DLG

********************************************************************/

USERACCT_DLG_DOWNLEVEL::USERACCT_DLG_DOWNLEVEL(
	USERPROP_DLG * puserpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USERACCT_DLG(
		puserpropdlgParent,
		MAKEINTRESOURCE(IDD_DETAILS_DOWNLEVEL),
		pulb
		),
	    _uPrivilege( USER_PRIV_USER ),
	    _fIndeterminatePrivilege( FALSE ),
	    _ulAuthFlags( 0L ),
	    _ulIndeterminateAuthFlags( 0L ),
	    _aptriOperator( NULL ),
	    _mgrpPrivilegeLevel( this, IDPL_RB_ADMIN, 3 ),
	    _nlsCurrUserOfTool(),
	    _fAdminPrivDelTest( FALSE )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    if ( (err =  _mgrpPrivilegeLevel.QueryError()) != NERR_Success ||
         (err = _nlsCurrUserOfTool.QueryError()) != NERR_Success
       )
    {
        ReportError( err );
        return;
    }

    _aptriOperator = (TRISTATE **) new PVOID[ NUM_OPERATOR_TYPES ];
    if (_aptriOperator == NULL)
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    for (INT i = 0; i < NUM_OPERATOR_TYPES; i++)
	_aptriOperator[i] = NULL;

    for (i = 0; i < NUM_OPERATOR_TYPES; i++)
    {
	_aptriOperator[i] = new TRISTATE( this, IDPL_CB_ACCOUNTOP + i );
	err = ERROR_NOT_ENOUGH_MEMORY;
	if (   _aptriOperator[i] == NULL
	    || (err = _aptriOperator[i]->QueryError()) != NERR_Success
	    || (err = _mgrpPrivilegeLevel.AddAssociation(
			IDPL_RB_USER, _aptriOperator[i] ) != NERR_Success )
	   )
	{
	    ReportError( err );
	    return;
	}
    }

    _aulOperatorFlags[ 0 ] = AF_OP_ACCOUNTS;
    _aulOperatorFlags[ 1 ] = AF_OP_SERVER;
    _aulOperatorFlags[ 2 ] = AF_OP_PRINT;
    _aulOperatorFlags[ 3 ] = AF_OP_COMM;

}// USERACCT_DLG_DOWNLEVEL::USERACCT_DLG_DOWNLEVEL



/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::~USERACCT_DLG_DOWNLEVEL

    SYNOPSIS:   Destructor for User Properties Privilege Level subdialog

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

USERACCT_DLG_DOWNLEVEL::~USERACCT_DLG_DOWNLEVEL( void )
{
    if (_aptriOperator != NULL)
    {
	for (INT i =0; i < NUM_OPERATOR_TYPES; i++)
	    delete _aptriOperator[i];
	delete _aptriOperator;
    }
    _aptriOperator = NULL;
}



/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

APIERR USERACCT_DLG_DOWNLEVEL::W_LMOBJtoMembers(
	UINT		iObject
	)
{

    USER_2 * puser2Curr = QueryUser2Ptr( iObject );
    UINT uCurrPriv = puser2Curr->QueryPriv();
    ULONG ulCurrAuthFlags = puser2Curr->QueryAuthFlags();

    if ( iObject == 0 ) // first object
    {
	_uPrivilege = uCurrPriv;
	_ulAuthFlags = ulCurrAuthFlags;
    }
    else	// iObject > 0
    {
	if ( !_fIndeterminatePrivilege )
	{
	    if ( _uPrivilege != uCurrPriv )
	        _fIndeterminatePrivilege = TRUE;
	}

	_ulIndeterminateAuthFlags |= ( _ulAuthFlags & ~ulCurrAuthFlags);
	_ulIndeterminateAuthFlags |= (~_ulAuthFlags &  ulCurrAuthFlags);
    }

    return USERACCT_DLG::W_LMOBJtoMembers( iObject );
	
} // USERACCT_DLG_DOWNLEVEL::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERPRIV_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

APIERR USERACCT_DLG_DOWNLEVEL::InitControls()
{
    if( QueryObjectCount() == 1 ) // we don't need tri state now
    {
	for (INT i = 0; i < NUM_OPERATOR_TYPES; i++)
	    _aptriOperator[i]->EnableThirdState( FALSE );
    }
	
    if ( !_fIndeterminatePrivilege )
    {
	_mgrpPrivilegeLevel.SetSelection( (UINT)(IDPL_RB_GUEST - _uPrivilege) );
	for (INT i = 0; i < NUM_OPERATOR_TYPES; i++)
	{
	    if (_ulIndeterminateAuthFlags & _aulOperatorFlags[i])
		_aptriOperator[i]->SetIndeterminate();
	    else
	    {
		_aptriOperator[i]->SetCheck(
			!!(_ulAuthFlags & _aulOperatorFlags[i]) );
		_aptriOperator[i]->EnableThirdState( FALSE );
	    }

	}
    }

    return USERACCT_DLG::InitControls();

} // USERACCT_DLG_DOWNLEVEL::InitControls


/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

APIERR USERACCT_DLG_DOWNLEVEL::W_DialogToMembers()
{
    CID cid = _mgrpPrivilegeLevel.QuerySelection();

    // _uPrivilege always set in switch, or else error
    _ulIndeterminateAuthFlags = 0L;
    _ulAuthFlags = 0L;

    switch (cid)
    {
    case RG_NO_SEL:
	_fIndeterminatePrivilege = TRUE;
	break;

    case IDPL_RB_USER:
	{
	    for (INT i = 0; i < NUM_OPERATOR_TYPES; i++)
	    {
		if (_aptriOperator[i]->IsIndeterminate())
		    _ulIndeterminateAuthFlags |= _aulOperatorFlags[i];
		else if (_aptriOperator[i]->IsChecked())
		    _ulAuthFlags |= _aulOperatorFlags[i];
	    }
	}
	// fall through

    case IDPL_RB_ADMIN:
    case IDPL_RB_GUEST:
	_fIndeterminatePrivilege = FALSE;
	_uPrivilege = IDPL_RB_GUEST - cid;
	break;

    default:
	ASSERT( FALSE );
	return ERROR_GEN_FAILURE;
    }

    return USERACCT_DLG::W_DialogToMembers();

} // USERACCT_DLG_DOWNLEVEL::W_DialogToMembers


/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::PerformOne
	
    SYNOPSIS:	PERFORMER::PerformSeries calls this

    ENTRY:	iObject  -	index of the object to save

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success
					
		pfWorkWasDone - indicates whether any UAS changes were
				successfully written out.  This
				may return TRUE even if the PerformOne
				action as a whole failed (i.e. PerformOne
				returned other than NERR_Success).
					
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
               JonN  30-Jul-1991    created
	       JonN  26-Aug-1991    PROP_DLG code review changes
	       JonN  31-Dec-1991    Calls parent to do work
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

APIERR USERACCT_DLG_DOWNLEVEL::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    UIASSERT( iObject < QueryObjectCount() );
    UIASSERT( (perrMsg != NULL) && (pfWorkWasDone != NULL) );

    UITRACE( SZ("USERACCT_DLG::PerformOne : ") );
    UITRACE( QueryObjectName( iObject ) );
    UITRACE( SZ("\n\r") );

    *perrMsg = IDS_UMEditFailure;
    *pfWorkWasDone = FALSE;

    USER_2 * puser2Old = QueryUser2Ptr( iObject );
    UIASSERT( puser2Old != NULL );

    APIERR err = NERR_Success;
    do // fake loop
    {

        if( iObject == 0 )  // we set _fAdminPrivDelTest flag TRUE/FALSE
        {
            if( !_fIndeterminatePrivilege && _uPrivilege != USER_PRIV_ADMIN )
            {
                WKSTA_10 wksta10;
                err = wksta10.GetInfo();
                if( err != NERR_Success )
                    break;
                _nlsCurrUserOfTool = wksta10.QueryLogonUser();
                err = _nlsCurrUserOfTool.QueryError();
                if( err != NERR_Success )
                    break;
                _fAdminPrivDelTest = TRUE;
            }
            else
                _fAdminPrivDelTest = FALSE;
        }

        if ( !_fIndeterminatePrivilege
	     && puser2Old->QueryPriv() != _uPrivilege )
        {
            if( _fAdminPrivDelTest &&
                stricmpf( _nlsCurrUserOfTool.QueryPch(),
			puser2Old->QueryName() ) == 0 )
            {
                    // Admin trying to change his privilege information
                    // does he/she know he/she is doing...
	        MSGID msgID = IDS_OkToDelAdminInDomain;
                const TCHAR * psz = QueryLocation().QueryDomain();
                if( psz == NULL )        // must be some server
                {
                    psz = QueryLocation().QueryServer();
                    if( psz == NULL )    // local computer
                    {
                        WKSTA_10 wksta10;
                        err = wksta10.GetInfo();
                        if( err != NERR_Success )
                            break;
                        psz = wksta10.QueryName();
                    }
		    msgID = IDS_OkToDelAdminOnServer;
		
                }

                if( ::MsgPopup( this, msgID, MPSEV_ERROR,
                        MP_OKCANCEL, psz ) == MP_CANCEL )
                {
                    return NERR_Success;    // Wants to remain ADMIN
                }
            }

        }

    } while ( FALSE );  // end of fake loop

    if( err != NERR_Success )
    {
	err = W_MapPerformOneError( err );
    }
    else
    {
	err = USERACCT_DLG::PerformOne( iObject, perrMsg, pfWorkWasDone );
    }

    return err;

} // USERACCT_DLG_DOWNLEVEL::PerformOne


/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_2 is changed

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

BOOL USERACCT_DLG_DOWNLEVEL::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    UNREFERENCED( this );
    return TRUE;
}


/*******************************************************************

    NAME:       USERACCT_DLG_DOWNLEVEL::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
    JonN        05-Feb-1992     Templated from USERACCT_DLG
    Thomaspa	22-Oct-1992	Merged USERACCT_DLG_DOWNLEVEL and USERPRIV_DLG

********************************************************************/

APIERR USERACCT_DLG_DOWNLEVEL::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    APIERR err;

    if ( !_fIndeterminatePrivilege )
    {
	ULONG ulNewAuthFlags = 0L;
	if ( _uPrivilege == USER_PRIV_USER )
	{
	    ulNewAuthFlags  = puser2->QueryAuthFlags();
	    ulNewAuthFlags |= (_ulAuthFlags & ~_ulIndeterminateAuthFlags);
	    ulNewAuthFlags &= (_ulAuthFlags |  _ulIndeterminateAuthFlags);
	}
        if (   (err = puser2->SetPriv( _uPrivilege )) != NERR_Success
	    || (err = puser2->SetAuthFlags( ulNewAuthFlags )) != NERR_Success
	   )
	{
	    return err;
	}
    }

    return USERACCT_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERACCT_DLG_DOWNLEVEL::W_MembersToLMOBJ





/*******************************************************************

    NAME:	USERACCT_DLG_NT::USERACCT_DLG_NT

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
		NT variant

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
    JonN        21-Feb-1992     Created

********************************************************************/

USERACCT_DLG_NT::USERACCT_DLG_NT(
	USERPROP_DLG * puserpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USERACCT_DLG(
		puserpropdlgParent,
		MAKEINTRESOURCE(IDD_DETAILS_NT),
		pulb
		),
	    _fRemoteAccount( FALSE ),
	    _fIndeterminateRemoteAccount( FALSE ),
	    _prgrpAccountType( NULL )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    _prgrpAccountType = new RADIO_GROUP( this, IDDT_RB_HOME, 2 );
    if( _prgrpAccountType == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if( (err = _prgrpAccountType->QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}// USERACCT_DLG_NT::USERACCT_DLG_NT



/*******************************************************************

    NAME:       USERACCT_DLG_NT::~USERACCT_DLG_NT

    SYNOPSIS:   Destructor for User Properties Accounts subdialog

    HISTORY:
    JonN        21-Feb-1992     Created

********************************************************************/

USERACCT_DLG_NT::~USERACCT_DLG_NT( void )
{
    delete _prgrpAccountType;
}



/*******************************************************************

    NAME:       USERACCT_DLG_NT::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
               JonN   21-Feb-1992    created

********************************************************************/

APIERR USERACCT_DLG_NT::W_LMOBJtoMembers(
	UINT		iObject
	)
{

    USER_3 * puser3Curr = QueryUser3Ptr( iObject );
    BOOL fRemoteAccount;
    switch (puser3Curr->QueryAccountType())
    {
    case AccountType_Normal:
	fRemoteAccount = FALSE;
	break;
    case AccountType_Remote:
	fRemoteAccount = TRUE;
	break;
    default:
	UIDEBUG( SZ("USERACCT_DLG_NT: Account neither home nor remote\r\n") );
	// CODEWORK Warn the user of this condition?
	_fIndeterminateRemoteAccount = TRUE;
	break;
    }

    if ( !_fIndeterminateRemoteAccount )
    {
        if ( iObject == 0 ) // first object
        {
	    _fRemoteAccount = fRemoteAccount;
        }
        else	// iObject > 0
        {
	    if ( _fRemoteAccount != fRemoteAccount )
		_fIndeterminateRemoteAccount = TRUE;
        }
    }

    return USERACCT_DLG::W_LMOBJtoMembers( iObject );
	
} // USERACCT_DLG_NT::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERACCT_DLG_NT::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERACCT_DLG_NT,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
               JonN  21-Feb-1992    created

********************************************************************/

APIERR USERACCT_DLG_NT::InitControls()
{

    if ( !_fIndeterminateRemoteAccount )
    {
	_prgrpAccountType->SetSelection(
		(_fRemoteAccount) ? IDDT_RB_REMOTE : IDDT_RB_HOME );	
    }

    return USERACCT_DLG::InitControls();

} // USERACCT_DLG_NT::InitControls


/*******************************************************************

    NAME:       USERACCT_DLG_NT::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
               JonN  21-Feb-1992    created

********************************************************************/

APIERR USERACCT_DLG_NT::W_DialogToMembers()
{
    CID cid = _prgrpAccountType->QuerySelection();
    switch (cid)
    {
    case RG_NO_SEL:
	_fIndeterminateRemoteAccount = TRUE;
	break;
    case IDDT_RB_HOME:
	_fIndeterminateRemoteAccount = FALSE;
	_fRemoteAccount = FALSE;
	break;
    case IDDT_RB_REMOTE:
	_fIndeterminateRemoteAccount = FALSE;
	_fRemoteAccount = TRUE;
	break;
    default:
	UIASSERT( FALSE );
	_fIndeterminateRemoteAccount = TRUE;
	// CODEWORK Warn the user of this condition?
	break;
    }

    return USERACCT_DLG::W_DialogToMembers();

} // USERACCT_DLG_NT::W_DialogToMembers


/*******************************************************************

    NAME:       USERACCT_DLG_NT::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
    JonN        21-Feb-1992     Created

********************************************************************/

APIERR USERACCT_DLG_NT::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    APIERR err;

    if ( !_fIndeterminateRemoteAccount )
    {
	err = ((USER_3 *)puser2)->SetAccountType(
	    (_fRemoteAccount) ? AccountType_Remote : AccountType_Normal );
	if( err != NERR_Success )
	    return err;
    }

    return USERACCT_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERACCT_DLG_NT::W_MembersToLMOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\usr2lb.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    usr2lb.cxx
    This file contains the methods for the USER2_LBI and USER2_LISTBOX
    classes.


    FILE HISTORY:
        JonN        01-Aug-1991 Templated from SHARES_LBI, SHARES_LISTBOX
        o-SimoP     11-Dec-1991 USER2_LBI deleted, USER_LISTBOX_BASE added
        o-SimoP     26-Dec-1991 USER2_LBI added
        o-SimoP     31-Dec-1991 CR changes, attended by BenG, JonN and I
        JonN        27-Feb-1992 Multiple bitmaps in both panes
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h> // for DOMAIN_DISPLAY_USER
}   // extern "C"

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_CLIENT
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uitrace.hxx>
#include <uiassert.hxx>

#include <adminapp.hxx>
#include <propdlg.hxx>
#include <usrlb.hxx>
#include <usr2lb.hxx>

extern "C" {

#include <usrmgrrc.h>

}   // extern "C"


const UINT USER_LISTBOX_BASE::_nColCount = 3; // column's count in user
                                // properties and its subdialog's user listbox

DEFINE_ONE_SHOT_OF( USER2_LBI )

/*******************************************************************

    NAME:       USER_LISTBOX_BASE::USER_LISTBOX_BASE

    SYNOPSIS:   constructor

    ENTRY:          powin               - The "owning" DIALOG_WINDOW.
                    cid                 - The listbox CID.
                    pulb                - pointer to main user lb

    HISTORY:
        o-SimoP     11-Dec-1991 Created
********************************************************************/
USER_LISTBOX_BASE::USER_LISTBOX_BASE( OWNER_WINDOW * powin, CID cid,
                                 const LAZY_USER_LISTBOX * pulb )
        : FORWARDING_BASE( powin ),
          _pulb( pulb )
{
    if ( QueryError() != NERR_Success )
        return;

    switch ( pulb->QuerySortOrder() )
    {
    case ULB_SO_LOGONNAME:
        _iAccountIndex = 1;
        _iFullnameIndex = 2;
        break;

    default:
        UIASSERT( FALSE ); //Control should never reach this point
        // fall through

    case ULB_SO_FULLNAME:
        _iAccountIndex = 2;
        _iFullnameIndex = 1;
        break;
    }

    _pdtab = new DISPLAY_TABLE( _nColCount, _adxColWidths );
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if(    _pdtab == NULL
        || (err = _pdtab->CalcColumnWidths( _adxColWidths,
                _nColCount,
                powin, cid, TRUE )) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       USER_LISTBOX_BASE::~USER_LISTBOX_BASE()

    SYNOPSIS:   destructor

    HISTORY:
        o-SimoP     7-Nov-1991      Created
********************************************************************/

USER_LISTBOX_BASE::~USER_LISTBOX_BASE()
{
    delete _pdtab;
    _pdtab = NULL;

}  // USER_LISTBOX_BASE::~USER_LISTBOX_BASE


/*******************************************************************

    NAME:           USER2_LISTBOX :: USER2_LISTBOX

    SYNOPSIS:       USER2_LISTBOX class constructor.

    ENTRY:          ppropdlgOwner       - The "owning" DIALOG_WINDOW.
                    cid                 - The listbox CID.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        JonN        01-Aug-1991 Templated from SHARES_LBI, SHARES_LISTBOX
        o-SimoP     11-Dec-1991 inherits from BLT_LISTBOX and USER_LISTBOX_BASE
********************************************************************/
USER2_LISTBOX :: USER2_LISTBOX( BASEPROP_DLG * ppropdlgOwner,
                                CID             cid,
                                const LAZY_USER_LISTBOX * pulb )
    : BLT_LISTBOX( ppropdlgOwner, cid, TRUE ),
      USER_LISTBOX_BASE( ppropdlgOwner, cid, pulb ),
      _posh( NULL ),
      _poshSave( NULL )
{
    if( QueryError() != NERR_Success )
        return;

    if( pulb == NULL )          // this is constructed but never used
        return;                 // i.e there is single selection case

    INT cSelCount = pulb->QuerySelCount();
    _posh = new ONE_SHOT_HEAP( cSelCount * sizeof( USER2_LBI ) );
    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if(    _posh == NULL
       || (err = _posh->QueryError()) != NERR_Success )
    {
        delete _posh;
        _posh = NULL;
        ReportError( err );
        return;
    }
    _poshSave = ONE_SHOT_OF( USER2_LBI )::QueryHeap();
    ONE_SHOT_OF( USER2_LBI )::SetHeap( _posh );
}   // USER2_LISTBOX :: USER2_LISTBOX


/*******************************************************************

    NAME:           USER2_LISTBOX :: ~USER2_LISTBOX

    SYNOPSIS:       USER2_LISTBOX class destructor.

    ENTRY:          None.

    EXIT:           The object is destroyed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     30-May-1991 Created for the Server Manager.
        JonN        01-Aug-1991 Templated from SHARES_LBI, SHARES_LISTBOX

********************************************************************/
USER2_LISTBOX :: ~USER2_LISTBOX()
{
    DeleteAllItems();   // this is because of deleting the heap where LBIs are
    if( _posh != NULL )
    {
        ONE_SHOT_OF( USER2_LBI )::SetHeap( _poshSave );
        delete _posh;
        _posh = NULL;
    }
}   // USER2_LISTBOX :: ~USER2_LISTBOX


/*******************************************************************

    NAME:           USER2_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox, with selected users from main user lb

    RETURNS:        error code

    HISTORY:
        JonN        01-Aug-1991 Created
        o-SimoP     11-Dec-1991 Uses LBIs from main lb
********************************************************************/
APIERR USER2_LISTBOX :: Fill( VOID )
{
    INT cSelCount = _pulb->QuerySelCount();
    UIASSERT( cSelCount >= 0 );
    APIERR err = NERR_Success;
    if( cSelCount == 0 )
        return err;
    else
    {
        BUFFER buf( sizeof(INT) * cSelCount );
        if( (err = buf.QueryError()) != NERR_Success )
        {
            return err;
        }
        INT * aiSel = (INT *) buf.QueryPtr();
        err = _pulb->QuerySelItems( aiSel, cSelCount );
        if( err != NERR_Success )
            return err;
        for( INT i = 0; i < cSelCount; i++ )
        {
            USER_LBI * pulbi = _pulb->QueryItem( aiSel[ i ] );
            USER2_LBI * pu2lbi = new USER2_LBI( *pulbi );
            if( AddItem( pu2lbi ) < 0 )
                return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    return err;

}   // USER2_LISTBOX :: Fill


/*******************************************************************

    NAME:       USER2_LBI::USER2_LBI

    SYNOPSIS:   USER2_LISTBOX LBI constructor

    ENTRY:      ulbi    -       reference to main user listbox's LBI

    HISTORY:
        o-SimoP     26-Dec-1991 Created
********************************************************************/

USER2_LBI::USER2_LBI( const USER_LBI & ulbi )
        : LBI(),
          _ulbi( ulbi )
{
    if( QueryError() != NERR_Success )
        return;
}


/*******************************************************************

    NAME:       USER2_LBI::Compare

    SYNOPSIS:   Compares two USER2_LBI's

    ENTRY:      plbi -      Pointer to other USER2_LBI object ('this'
                            being the first)

    RETURNS:    < 0         *this < *plbi
                = 0         *this = *plbi
                > 0         *this > *plbi

    HISTORY:
        o-SimoP     26-Dec-1991 Created
********************************************************************/

INT USER2_LBI::Compare( const LBI * plbi ) const
{
    return _ulbi.Compare( &((USER2_LBI *)plbi)->_ulbi );
}

/*******************************************************************

    NAME:       USER2_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item

    RETURNS:    The leading character of the listbox item

    HISTORY:
        o-SimoP     26-Dec-1991 Created
********************************************************************/

WCHAR USER2_LBI::QueryLeadingChar( void ) const
{
    return _ulbi.QueryLeadingChar();
}


/*******************************************************************

    NAME:       USER2_LBI::Paint

    SYNOPSIS:   Paints the USER2_LBI

    ENTRY:      plb -       Pointer to listbox which provides the context
                            for this LBI.

                hdc -       The device context handle to be used

                prect -     Pointer to clipping rectangle

                pGUILTT -   Pointer to GUILTT structure

    HISTORY:
        o-SimoP     26-Dec-1991 Created
        beng        22-Apr-1992 Change to LBI::Paint

********************************************************************/

VOID USER2_LBI::Paint( LISTBOX * plb,
                       HDC hdc,
                       const RECT * prect,
                       GUILTT_INFO * pGUILTT ) const
{
    DISPLAY_TABLE * pdtab = ((USER2_LISTBOX * )plb)->QueryDisplayTable();
    UIASSERT( pdtab != NULL );

    UNICODE_STR_DTE dteAccount(  _ulbi.QueryAccountUstr()  );
    UNICODE_STR_DTE dteFullname( _ulbi.QueryFullNameUstr() );

    (*pdtab)[ 0           ] = (DM_DTE *)((USER2_LISTBOX * )plb)->QueryDmDte( _ulbi.QueryIndex() );
    (*pdtab)[ ((USER2_LISTBOX * )plb)->QueryAccountIndex() ] = &dteAccount;
    (*pdtab)[ ((USER2_LISTBOX * )plb)->QueryFullnameIndex() ] = &dteFullname;
    pdtab->Paint( plb, hdc, prect, pGUILTT );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\uprofile.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**          Copyright(c) Microsoft Corp., 1990, 1991                **/
/**********************************************************************/

/*
    uprofile.cxx


    FILE HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx
	JonN	27-Feb-1992	Split USERPROF_DLG into DOWNLEVEL and NT variants
        JonN    06-Mar-1992     Moved GetOne from subprop subclasses
	JonN	22-Apr-1992	Reformed %USERNAME% logic (NTISSUE #974)
	JonN	10-Jun-1992	Profile field only from LANMANNT variants
        JonN    31-Aug-1992     Re-enable %USERNAME%
        JonN    07-Oct-1993     Allow remote homedir without homedir drive
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntsam.h>
}


#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETCONS
#define INCL_ICANON
#define INCL_NETLIB
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_APP
#define INCL_BLT_CLIENT
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>
extern "C"
{
    #include <mnet.h>
}

#include <uitrace.hxx>
#include <uiassert.hxx>
#include <bltmsgp.hxx>


extern "C"
{
    #include <usrmgrrc.h>
    #include <umhelpc.h>
}

#include <usrmain.hxx>
#include <uprofile.hxx>
#include <lmowks.hxx>
#include <ntuser.hxx> // USER_3
#include <security.hxx>
#include <nwuser.hxx>
// hydra
#include "uconfig.hxx"

//
// Helper functions
//

BOOL IsLocalHomeDir( const TCHAR * pchHomeDir,
                     const TCHAR * pchHomeDirDrive = NULL );
BOOL IsLocalHomeDir( const USER_3 * puser3 );


#define UI_PROF_DEVICE_Z SZ("Z:")

//
// BEGIN MEMBER FUNCTIONS
//


/*******************************************************************

    NAME:	USERPROF_DLG::USERPROF_DLG

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
                base class

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

USERPROF_DLG::USERPROF_DLG(
	USERPROP_DLG * puserpropdlgParent,
        const TCHAR * pszResourceName,
	const LAZY_USER_LISTBOX * pulb
	) : USER_SUBPROP_DLG(
		puserpropdlgParent,
		pszResourceName,
		pulb
		),
	    _nlsLogonScript(),
	    _fIndeterminateLogonScript( FALSE ),
	    _fIndetNowLogonScript( FALSE ),
	    _sleLogonScript( this, IDPR_ET_LOGON_SCRIPT, MAXPATHLEN )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    if( (err = _nlsLogonScript.QueryError()) != NERR_Success
      )
    {
        ReportError( err );
        return;
    }

}// USERPROF_DLG::USERPROF_DLG



/*******************************************************************

    NAME:       USERPROF_DLG::~USERPROF_DLG

    SYNOPSIS:   Destructor for User Properties Accounts subdialog,
                base class

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

USERPROF_DLG::~USERPROF_DLG( void )
{
    // Nothing to do
}


/*******************************************************************

    NAME:       USERPROF_DLG::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx
	JonN	10-Mar-1992	%USERNAME% logic
        JonN    22-Apr-1992     No %USERNAME% for logon script

********************************************************************/

APIERR USERPROF_DLG::W_LMOBJtoMembers(
	UINT		iObject
	)
{

    USER_2 * puser2Curr = QueryUser2Ptr( iObject );
    ALIAS_STR nlsCurrScript( puser2Curr->QueryScriptPath() );
    APIERR err = NERR_Success;

    if ( iObject == 0 ) // first object
    {
	if(   (err = _nlsLogonScript.CopyFrom( nlsCurrScript )) != NERR_Success
          )
	{
	    return err;
	}
    }
    else	// iObject > 0
    {
	if ( !_fIndeterminateLogonScript )
	{
	    if ( _nlsLogonScript._stricmp( nlsCurrScript ) != 0 )
		_fIndeterminateLogonScript = TRUE;
	}
    }

    return USER_SUBPROP_DLG::W_LMOBJtoMembers( iObject );
	
} // USERPROF_DLG::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERPROF_DLG::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERPROF_DLG,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx
        JonN    22-Apr-1992     No %USERNAME% for logon script

********************************************************************/

APIERR USERPROF_DLG::InitControls()
{
    if( !_fIndeterminateLogonScript )
    {
	_sleLogonScript.SetText( _nlsLogonScript );
    }

    return USER_SUBPROP_DLG::InitControls();

} // USERPROF_DLG::InitControls


/*******************************************************************

    NAME:       USERPROF_DLG::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	       o-SimoP  20-Sep-1991    created

********************************************************************/

APIERR USERPROF_DLG::W_DialogToMembers()
{

    APIERR err = CheckPath( &_sleLogonScript, &_nlsLogonScript,
	    _fIndeterminateLogonScript, &_fIndetNowLogonScript,
		    // path must be relative
	    ITYPE_PATH_RELND, 0L );

    if (err != NERR_Success)
        return err;

    return USER_SUBPROP_DLG::W_DialogToMembers();

} // USERPROF_DLG::W_DialogToMembers


/*******************************************************************

    NAME:	USERPROF_DLG::CheckPath

    SYNOPSIS:	checks logon script and home directory paths

    ENTRY:	psle	- pointer to SLE_STRIP (path)
		pnls	- pointer to NLS_STR to store path
		fIndeterminate - Indet, valuated in GetOne
		pfIndetNow     - pointer to IndetNow
		ulType	       - path type
		ulMask	       - optional mask
                fDoDegeneralize - call DegeneralizeString before checking
                pstrlstDegeneralizeExtensions - for DegeneralizeString

    RETURNS:	NERR_Success on success
                IERR_CANCEL_NO_ERROR for bad path
                otherwise error code

    NOTES:	The pathtype must either be exactly ulType, or it
                must contain all bits in ulMask (ulMask == 0L means
                no mask).  The empty string is always valid, and
                may return *pfIndetNow==TRUE.  No pathtype containing
                ITYPE_WILD matches ulMask.

                In the case of a bad path, CheckPath will also display
                a generic Bad Path message popup, and set focus and
                selection to the offending SLE.

    HISTORY:
	       o-SimoP  25-Sep-1991    created
	       JonN     10-Mar-1992    %USERNAME% logic
               JonN     22-Apr-1992    Reformed %USERNAME% (NTISSUE #974)
********************************************************************/

APIERR USERPROF_DLG::CheckPath(
	SLE_STRIP *	psle,
	NLS_STR *	pnls,
	BOOL    	fIndeterminate,
	BOOL    *	pfIndetNow,
	ULONG		ulType,
	ULONG		ulMask,
        BOOL            fDoDegeneralize,
        STRLIST * pstrlstDegeneralizeExtensions
	)
{
    APIERR err = NERR_Success;
    if( psle->QueryTextLength() == 0 )
    {
	if( !fIndeterminate )
	{
	    *pfIndetNow = FALSE;
	    *pnls = NULL;
	    err = pnls->QueryError();
	}
	else
	{
	    *pfIndetNow = TRUE;
	}
    }
    else
    {
        // CODEWORK use VALIDATED_DIALOG where appropriate
        // This will clear leading/trailing whitespace
	if (   ((err = psle->QueryText( pnls )) != NERR_Success )
	    || ((err = pnls->QueryError()) != NERR_Success ) )
	{
	    return err;
	}
        NLS_STR nlsTemp = *pnls;  // check Degeneralize()d path

        // The SZ("X") is an example username; if we don't include it,
        // "\\foo\bar\%USERNAME%" will expand to "\\foo\bar\" which is
        // an invalid UNC path.
        //
        // CODEWORK We could pass the actual object name for non-NEW variants

	if (   ((err = nlsTemp.QueryError()) != NERR_Success )
            || (fDoDegeneralize &&
                  (err = DegeneralizeString(
                            &nlsTemp,
                            SZ("X"),
                            (pstrlstDegeneralizeExtensions == NULL)
                               ? NULL
                               : *pstrlstDegeneralizeExtensions))
                          != NERR_Success ) )
	{
	    return err;
	}
	ULONG ulPathType = 0L;
        if ( ulMask == 0xFFFFFFFF )
        {
            TRACEEOL( "USERPROP_DLG::CheckPath: Don't bother with I_MNetPathType" );
        }
        else if ( (err = ::I_MNetPathType( NULL, nlsTemp.QueryPch(),
                &ulPathType, 0 )) != NERR_Success )
	{
	    err = IERR_CANCEL_NO_ERROR;
	}
	else if ( ulPathType != ulType )
	{
	    // is part of it what we want
	    if(     ulMask == 0L
                || (ulPathType & ulMask) != ulMask
		|| (ulPathType & ITYPE_WILD) )
            {
		err = IERR_CANCEL_NO_ERROR;
            }
	}

        if (err == IERR_CANCEL_NO_ERROR)
        {
            ::MsgPopup( this,
		        ulType == ITYPE_PATH_RELND ? IDS_InvalidRelPath
						   : IDS_InvalidPath,
	                MPSEV_ERROR,
                        MP_OK,
                        pnls->QueryPch() );
            psle->ClaimFocus();
	    psle->SelectString();	

        }
	
	*pfIndetNow = FALSE;
    }

    return err;

} // USERPROF_DLG::CheckPath


/*******************************************************************

    NAME:       USERPROF_DLG::ChangesUser2Ptr

    SYNOPSIS:	Checks whether W_MembersToLMOBJ changes the USER_2
		for this object.

    ENTRY:	index to object

    RETURNS:	TRUE iff USER_2 is changed

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

BOOL USERPROF_DLG::ChangesUser2Ptr( UINT iObject )
{
    UNREFERENCED( iObject );
    return TRUE;
}


/*******************************************************************

    NAME:       USERPROF_DLG::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	       o-SimoP  20-Sep-1991    created
               JonN     10-Mar-1992    %USERNAME% logic

********************************************************************/

APIERR USERPROF_DLG::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{

    if ( !_fIndetNowLogonScript )
    {
        APIERR err = NERR_Success;
        if ( (err = puser2->SetScriptPath( _nlsLogonScript )) != NERR_Success )
        {
	    return err;
        }
    }

    return USER_SUBPROP_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERPROF_DLG::W_MembersToLMOBJ


/*******************************************************************

    NAME:       USERPROF_DLG::QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG - The help context for this dialog.

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

ULONG USERPROF_DLG::QueryHelpContext( void )
{

    return HC_UM_USERPROFILE_LANNT + QueryHelpOffset();

} // USERPROF_DLG::QueryHelpContext





/*******************************************************************

    NAME:	USERPROF_DLG_DOWNLEVEL::USERPROF_DLG_DOWNLEVEL

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
                LM2.x variant

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

USERPROF_DLG_DOWNLEVEL::USERPROF_DLG_DOWNLEVEL(
	USERPROP_DLG * puserpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USERPROF_DLG(
		puserpropdlgParent,
		MAKEINTRESOURCE(IDD_PROFILE_DOWNLEVEL),
		pulb
		),
	    _nlsHomeDir(),
	    _fIndeterminateHomeDir( FALSE ),
	    _fIndetNowHomeDir( FALSE ),		
	    _sleHomeDir( this, IDPR_ET_REMOTE_HOMEDIR, MAXPATHLEN )
{

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    if( (err = _nlsHomeDir.QueryError()) != NERR_Success
      )
    {
        ReportError( err );
        return;
    }

}// USERPROF_DLG_DOWNLEVEL::USERPROF_DLG_DOWNLEVEL



/*******************************************************************

    NAME:       USERPROF_DLG_DOWNLEVEL::~USERPROF_DLG_DOWNLEVEL

    SYNOPSIS:   Destructor for User Properties Accounts subdialog,
                LM2.x variant

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

USERPROF_DLG_DOWNLEVEL::~USERPROF_DLG_DOWNLEVEL( void )
{
    // Nothing to do
}


/*******************************************************************

    NAME:       USERPROF_DLG_DOWNLEVEL::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx
        JonN    22-Apr-1992     Reformed %USERNAME% (NTISSUE #974)
        JonN    01-Sep-1992     Reactivated %USERNAME%

********************************************************************/

APIERR USERPROF_DLG_DOWNLEVEL::W_LMOBJtoMembers(
	UINT		iObject
	)
{

    USER_2 * puser2Curr = QueryUser2Ptr( iObject );

    NLS_STR nlsCurrHomeDir;
    APIERR err = NERR_Success;
    if ( IsNewVariant() )
    {
        nlsCurrHomeDir = ((NEW_USERPROP_DLG *)QueryParent())->QueryNewHomeDir();
        err = nlsCurrHomeDir.QueryError();
    }
    else
    {
        nlsCurrHomeDir = puser2Curr->QueryHomeDir();
        err = nlsCurrHomeDir.QueryError();
        if ( (err == NERR_Success) && (QueryObjectCount() > 1) )
        {
            err = GeneralizeString( &nlsCurrHomeDir,
                                    puser2Curr->QueryName() );
        }
    }
    if (err != NERR_Success)
    {
	return err;
    }

    if ( iObject == 0 ) // first object
    {
	if( ( err = _nlsHomeDir.CopyFrom( nlsCurrHomeDir ) ) != NERR_Success )
	{
	    return err;
	}
    }
    else	// iObject > 0
    {
	if ( !_fIndeterminateHomeDir )
	{
	    if ( _nlsHomeDir._stricmp( nlsCurrHomeDir ) != 0 )
            {
                /*
                    It is possible that all the users have the same homedir,
                    but the stricmp() failed because the homedir name is
                    the same as the first user, so it was generalized.
                    Note that this can occur only for multiselect, thus
                    it is never a NewVariant().
                    Recover from this state here.
                */
                if ( ::stricmpf( puser2Curr->QueryHomeDir(),
                                 QueryUser2Ptr(0)->QueryHomeDir() ) == 0 )
                {
	            if( ( err = _nlsHomeDir.CopyFrom( puser2Curr->QueryHomeDir() ) ) != NERR_Success )
	            {
	                return err;
	            }
                }
                else
                {
		    _fIndeterminateHomeDir = TRUE;
                }
            }
	}
    }

    return USERPROF_DLG::W_LMOBJtoMembers( iObject );
	
} // USERPROF_DLG_DOWNLEVEL::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERPROF_DLG_DOWNLEVEL::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERPROF_DLG_DOWNLEVEL,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

APIERR USERPROF_DLG_DOWNLEVEL::InitControls()
{
    if( !_fIndeterminateHomeDir )
    {
	_sleHomeDir.SetText( _nlsHomeDir );
    }

    return USERPROF_DLG::InitControls();

} // USERPROF_DLG_DOWNLEVEL::InitControls


/*******************************************************************

    NAME:       USERPROF_DLG_DOWNLEVEL::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx

********************************************************************/

APIERR USERPROF_DLG_DOWNLEVEL::W_DialogToMembers()
{

    APIERR err = CheckPath( &_sleHomeDir, &_nlsHomeDir, _fIndeterminateHomeDir,
	    &_fIndetNowHomeDir, ITYPE_PATH_ABSD, ITYPE_UNC, TRUE );
	    // homedir can be null string,
	    // local absolute path or UNC path
            // degeneralize with null extension

    if (err != NERR_Success)
        return err;

    return USERPROF_DLG::W_DialogToMembers();

} // USERPROF_DLG_DOWNLEVEL::W_DialogToMembers


/*******************************************************************

    NAME:       USERPROF_DLG_DOWNLEVEL::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	JonN	18-Feb-1992	Templated from useracct.cxx
        JonN    22-Apr-1992     Reformed %USERNAME% (NTISSUE #974)

********************************************************************/

APIERR USERPROF_DLG_DOWNLEVEL::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{

    if ( !_fIndetNowHomeDir )
    {
        NLS_STR nlsTemp( _nlsHomeDir );
        APIERR err = nlsTemp.QueryError();
        if (   err != NERR_Success
           )
        {
            return err;
        }

        if ( IsNewVariant() )
        {
            err = ((NEW_USERPROP_DLG *)QueryParent())->SetNewHomeDir( nlsTemp );
        }
        else
        {
            err = DegeneralizeString( &nlsTemp,
                                      puser2->QueryName(),
                                      NULL,
                                      QueryParent()->QueryGeneralizedHomeDirPtr() );
            if (err == NERR_Success)
                err = puser2->SetHomeDir( nlsTemp );
        }
        if (err != NERR_Success)
            return err;
    }

    return USERPROF_DLG::W_MembersToLMOBJ( puser2, pusermemb );

}// USERPROF_DLG_DOWNLEVEL::W_MembersToLMOBJ



/*******************************************************************

    NAME:	USERPROF_DLG_NT::USERPROF_DLG_NT

    SYNOPSIS:   Constructor for User Properties Accounts subdialog,
                NT variant

    ENTRY:	puserpropdlgParent - pointer to parent properties
				     dialog

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG
	JonN	19-May-1992	Uses LMO_DEV_ALLDEVICES
        JonN    18-Aug-1992     Added _psltProfileText
        JonN    30-Nov-1994     _psleProfile active for UM_WINNT

********************************************************************/

USERPROF_DLG_NT::USERPROF_DLG_NT(
	USERPROP_DLG * puserpropdlgParent,
	const LAZY_USER_LISTBOX * pulb
	) : USERPROF_DLG(
		puserpropdlgParent,
                ( MAKEINTRESOURCE(puserpropdlgParent->IsNetWareInstalled()?
                      IDD_PROFILE : IDD_NO_NETWARE_PROFILE) ),
		pulb
		),
            // CODEWORK these fields not needed for MUM
	    _nlsProfile(),
	    // _fIndeterminateProfile( FALSE ),
	    // _fIndetNowProfile( FALSE ),		
	    _psleProfile( NULL ),
            _psltProfileText( NULL ),

	    // _fIsLocalHomeDir( FALSE ),
	    // _fIndeterminateIsLocalHomeDir( FALSE ),
	    // _fIndetNowIsLocalHomeDir( FALSE ),
	    _mgrpIsLocalHomeDir( this, IDPR_RB_LOCAL_HOMEDIR, 2 ),

	    _nlsLocalHomeDir(),
	    // _fIndeterminateLocalHomeDir( FALSE ),
	    // _fIndetNowLocalHomeDir( FALSE ),		
	    _sleLocalHomeDir( this, IDPR_ET_LOCAL_HOMEDIR, MAXPATHLEN ),

	    _nlsRemoteDevice(),
	    // _fIndeterminateRemoteDevice( FALSE ),
	    // _fIndetNowRemoteDevice( FALSE ),		
	    _devcbRemoteDevice( this, IDPR_CB_REMOTE_DEVICE,
                                LMO_DEV_DISK, LMO_DEV_ALLDEVICES_DEFZ ),
        // hydra
     
        // _fIsLocalWFHomeDir( FALSE ),
	    // _fIndeterminateIsLocalWFHomeDir( FALSE ),
	    // _fIndetNowIsLocalWFHomeDir( FALSE ),
	    _mgrpIsLocalWFHomeDir( this, IDPR_RB_LOCAL_WFHOMEDIR, 2 ),

	    _nlsLocalWFHomeDir(),
	    // _fIndeterminateLocalWFHomeDir( FALSE ),
	    // _fIndetNowLocalWFHomeDir( FALSE ),		
	    _sleLocalWFHomeDir( this, IDPR_ET_LOCAL_WFHOMEDIR, MAXPATHLEN ),

	    _nlsRemoteWFDevice(),
	    // _fIndeterminateRemoteWFDevice( FALSE ),
	    // _fIndetNowRemoteWFDevice( FALSE ),		
	    _devcbRemoteWFDevice( this, IDPR_CB_WFREMOTE_DEVICE,
                                LMO_DEV_DISK, LMO_DEV_ALLDEVICES_DEFZ ),

	    _nlsRemoteWFHomeDir(),
	    // _fIndeterminateRemoteHomeDir( FALSE ),
	    // _fIndetNowRemoteHomeDir( FALSE ),		
	    _sleRemoteWFHomeDir( this, IDPR_ET_REMOTE_WFHOMEDIR, MAXPATHLEN ),

	    _cbHomeDirectoryMapRoot( this, IDPR_CB_HOMEDIR_MAPROOT ),
            // _fHomeDirectoryMapRoot( FALSE ),
            // _fIndeterminateHomeDirectoryMapRoot( FALSE ),
	    _nlsWFProfile(),
	    _psleWFProfile( NULL ),
       _psltWFProfileText( NULL ),
       // _fIndeterminateWFProfile( FALSE ),
       // _fIndeterNowWFProfile ( FALSE ),

       // hydra end



	    _nlsRemoteHomeDir(),
	    // _fIndeterminateRemoteHomeDir( FALSE ),
	    // _fIndetNowRemoteHomeDir( FALSE ),		
	    _sleRemoteHomeDir( this, IDPR_ET_REMOTE_HOMEDIR, MAXPATHLEN ),


	    _nlsNWHomeDir(),
	    // _fIndeterminateNWHomeDir( FALSE ),
	    // _fIndetNowNWHomeDir( FALSE ),		
        _sleNWHomeDir (this, IDPR_ET_NW_HOMEDIR, MAXPATHLEN),
        _sltNWHomeDir (this, IDPR_ST_NW_HOMEDIR),

        _fIsNetWareInstalled (puserpropdlgParent->IsNetWareInstalled()),
        _fIsNetWareChecked   (puserpropdlgParent->IsNetWareInstalled() ?
                              puserpropdlgParent->IsNetWareChecked() : FALSE)
{
    // CODEWORK these should be initialized above, but this overloads CFRONT
    _fIndeterminateProfile = FALSE;
    _fIndetNowProfile = FALSE;		
    _fIsLocalHomeDir = FALSE;
    _fIndeterminateIsLocalHomeDir = FALSE;
    _fIndetNowIsLocalHomeDir = FALSE;
    _fIndeterminateLocalHomeDir = FALSE;
    _fIndetNowLocalHomeDir = FALSE;
    _fIndeterminateRemoteDevice = FALSE;
    _fIndetNowRemoteDevice = FALSE;	
    _fIndeterminateRemoteHomeDir = FALSE;
    _fIndetNowRemoteHomeDir = FALSE;		
    _fIndeterminateNWHomeDir = FALSE;
    _fIndetNowNWHomeDir = FALSE;

    // hydra
    _fHomeDirectoryMapRoot = FALSE;
    _fIndeterminateHomeDirectoryMapRoot = FALSE;
    _fIndeterminateWFProfile = FALSE;
    _fIndetNowWFProfile = FALSE;
    _fIsLocalWFHomeDir              = FALSE;
    _fIndeterminateIsLocalWFHomeDir = FALSE;
    _fIndetNowIsLocalWFHomeDir      = FALSE;
    _fIndeterminateLocalWFHomeDir   = FALSE;
    _fIndetNowLocalWFHomeDir        = FALSE;
    _fIndeterminateRemoteWFDevice   = FALSE;
    _fIndetNowRemoteWFDevice        = FALSE;	
    _fIndeterminateRemoteWFHomeDir  = FALSE;
    _fIndetNowRemoteWFHomeDir       = FALSE;
    // hydra end

    APIERR err = QueryError();
    if( err != NERR_Success )
        return;

    // We do not use the _psleProfile field in the UM_DOWNLEVEL case
    UIASSERT( (QueryTargetServerType() != UM_LANMANNT) || (!fMiniUserManager) );

    if ( QueryEnableUserProfile() )
    {
        _psleProfile = new SLE_STRIP( this, IDPR_ET_PROFILE_PATH, MAXPATHLEN );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   (_psleProfile == NULL)
            || ((err = _psleProfile->QueryError()) != NERR_Success)
           )
        {
            ReportError( err );
            return;
        }

        // hydra
        _psleWFProfile = new SLE_STRIP( this, IDPR_ET_WFPROFILE_PATH, DIRECTORY_LENGTH );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if ((_psleProfile == NULL)||
            ((err = _psleWFProfile->QueryError()) != NERR_Success))
        {
            ReportError( err );
            return;
        }
        // hydra end

        if (QueryTargetServerType() == UM_DOWNLEVEL)
        {
            _psltProfileText = new SLT( this, IDPR_ET_PROFILE_TEXT );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (_psltProfileText == NULL)
                || ((err = _psltProfileText->QueryError()) != NERR_Success)
               )
            {
                ReportError( err );
                return;
            }
            _psleProfile->Enable( FALSE );
            _psltProfileText->Enable( FALSE );

            // hydra
            _psltWFProfileText = new SLT( this, IDPR_ET_WFPROFILE_TEXT );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if ((_psltWFProfileText == NULL) ||
                ((err = _psltWFProfileText->QueryError()) != NERR_Success))
            {
                ReportError( err );
                return;
            }
            _psleWFProfile->Enable( FALSE );
            _psltWFProfileText->Enable( FALSE );
            // hydra end
        }
    }

    if ( !QueryEnableUserProfile() )
    {
        _sleLogonScript.ClaimFocus();
    }

    if(   (err = _nlsProfile.QueryError()) != NERR_Success
       || (err = _nlsLocalHomeDir.QueryError()) != NERR_Success
       || (err = _nlsRemoteDevice.QueryError()) != NERR_Success
       || (err = _nlsRemoteHomeDir.QueryError()) != NERR_Success
       || (err = _nlsNWHomeDir.QueryError()) != NERR_Success
       || (err = _mgrpIsLocalHomeDir.AddAssociation( IDPR_RB_LOCAL_HOMEDIR,
                        &_sleLocalHomeDir )) != NERR_Success
       || (err = _mgrpIsLocalHomeDir.AddAssociation( IDPR_RB_REMOTE_HOMEDIR,
                        &_devcbRemoteDevice )) != NERR_Success
       || (err = _mgrpIsLocalHomeDir.AddAssociation( IDPR_RB_REMOTE_HOMEDIR,
                        &_sleRemoteHomeDir )) != NERR_Success
       // hydra
       || (err = _nlsLocalWFHomeDir.QueryError())  != NERR_Success
       || (err = _nlsRemoteWFDevice.QueryError())  != NERR_Success
       || (err = _nlsRemoteWFHomeDir.QueryError()) != NERR_Success
       || (err = _mgrpIsLocalWFHomeDir.AddAssociation( IDPR_RB_LOCAL_WFHOMEDIR,
                                                       &_sleLocalWFHomeDir )) != NERR_Success
       || (err = _mgrpIsLocalWFHomeDir.AddAssociation( IDPR_RB_REMOTE_WFHOMEDIR,
                                                       &_devcbRemoteWFDevice )) != NERR_Success
       || (err = _mgrpIsLocalWFHomeDir.AddAssociation( IDPR_RB_REMOTE_WFHOMEDIR,
                                                       &_sleRemoteWFHomeDir )) != NERR_Success  
       //#ifdef CITRIX
       // || (err = _mgrpIsLocalHomeDir.AddAssociation( IDPR_RB_REMOTE_HOMEDIR,
       //               &_cbHomeDirectoryMapRoot )) != NERR_Success
       || (err = _nlsWFProfile.QueryError()) != NERR_Success
       // hydra end
      )
    {
        ReportError( err );
        return;
    }


}// USERPROF_DLG_NT::USERPROF_DLG_NT



/*******************************************************************

    NAME:       USERPROF_DLG_NT::~USERPROF_DLG_NT

    SYNOPSIS:   Destructor for User Properties Accounts subdialog,
                LM2.x variant

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG

********************************************************************/

USERPROF_DLG_NT::~USERPROF_DLG_NT( void )
{
    delete _psleProfile;
    _psleProfile = NULL;
    delete _psltProfileText;
    _psltProfileText = NULL;
    // hydra
    delete _psleWFProfile;
    _psleWFProfile = NULL;
    delete _psltWFProfileText;
    _psltWFProfileText = NULL;
    // hydra end

}


/*******************************************************************

    NAME:       IsLocalHomeDir

    SYNOPSIS:	Determines whether a particular homedir / homedir-drive
                combination is considered by this dialog to indicate
                a local homedir.

    RETURNS:	BOOL

    HISTORY:
        JonN    21-Oct-1993     Created

********************************************************************/

BOOL IsLocalHomeDir( const TCHAR * pchHomeDir, const TCHAR * pchHomeDirDrive )
{
    /*
     *  Home directory is considered remote if either:
     *  (1)  A remote homedir drive is specified, or
     *  (2)  The homedir starts with two backslashes
     */

    BOOL fIsLocalHomeDir = (   (pchHomeDirDrive == NULL)
                            || (*pchHomeDirDrive == TCH('\0')) );
    if ( fIsLocalHomeDir && (pchHomeDir != NULL) )
    {
        fIsLocalHomeDir &= (   (pchHomeDir[0] != TCH('\\'))
                            || (pchHomeDir[1] != TCH('\\')) );
    }

    return fIsLocalHomeDir;
}

BOOL IsLocalHomeDir( const USER_3 * puser3 )
{
    return IsLocalHomeDir( puser3->QueryHomeDir(),
                           puser3->QueryHomedirDrive() );
}


/*******************************************************************

    NAME:       USERPROF_DLG_NT::W_LMOBJtoMembers

    SYNOPSIS:	Loads class data members from initial data

    ENTRY:	Index of user to examine.  W_LMOBJToMembers expects to be
		called once for each user, starting from index 0.

    RETURNS:	error code

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG
        JonN    22-Apr-1992     Reformed %USERNAME% (NTISSUE #974)

********************************************************************/

APIERR USERPROF_DLG_NT::W_LMOBJtoMembers(
	UINT		iObject
	)
{

    USER_3 * puser3Curr = QueryUser3Ptr( iObject );
    ASSERT( puser3Curr != NULL );
    // hydra
    USER_CONFIG * pUserConfig = QueryParent()->QueryUserConfigPtr( iObject );
    ASSERT( pUserConfig != NULL );
    NLS_STR nlsCurrWFProfile = pUserConfig->QueryWFProfilePath();
    NLS_STR nlsCurrWFHomeDir, nlsCurrRemoteWFDevice;
    // hydra end

    NLS_STR nlsCurrProfile, nlsCurrHomeDir, nlsCurrRemoteDevice;
    APIERR err = NERR_Success;
    if ( IsNewVariant() )
    {
        nlsCurrProfile = ((NEW_USERPROP_DLG *)QueryParent())->QueryNewProfile();
        nlsCurrHomeDir = ((NEW_USERPROP_DLG *)QueryParent())->QueryNewHomeDir();
        // hydra
        nlsCurrWFProfile = ((NEW_USERPROP_DLG *)QueryParent())->QueryNewWFProfile();
        nlsCurrWFHomeDir = ((NEW_USERPROP_DLG *)QueryParent())->QueryNewWFHomeDir();
        // hydra end
    }
    else
    {
        nlsCurrProfile = puser3Curr->QueryProfile();
        nlsCurrHomeDir = puser3Curr->QueryHomeDir();
        // hydra 
        nlsCurrWFProfile = pUserConfig->QueryWFProfilePath();
        nlsCurrWFHomeDir = pUserConfig->QueryWFHomeDir();
        // hydra end
        if (   (nlsCurrProfile.QueryError() == NERR_Success)
            && (QueryObjectCount() > 1)
           )
        {
            err = GeneralizeString( &nlsCurrProfile,
                                    puser3Curr->QueryName(),
                                    QueryParent()->QueryExtensionReplace() );
        }
        if (   (err == NERR_Success)
            && (nlsCurrHomeDir.QueryError() == NERR_Success)
            && (QueryObjectCount() > 1)
           )
        {
            err = GeneralizeString( &nlsCurrHomeDir,
                                    puser3Curr->QueryName() );
        }
        // hydra
        if ((err == NERR_Success) &&
            (nlsCurrWFProfile.QueryError() == NERR_Success) &&
            (QueryObjectCount() > 1)) {
            err = GeneralizeString( &nlsCurrWFProfile,
                                    puser3Curr->QueryName(),
                                    QueryParent()->QueryExtensionReplace() );
        }
        
        if (   (err == NERR_Success)
            && (nlsCurrWFHomeDir.QueryError() == NERR_Success)
            && (QueryObjectCount() > 1)
           )
        {
            err = GeneralizeString( &nlsCurrWFHomeDir,
                                    puser3Curr->QueryName() );
        }
        // hydra end
    }
    nlsCurrRemoteDevice = puser3Curr->QueryHomedirDrive();
    nlsCurrRemoteWFDevice = pUserConfig->QueryWFHomeDirDrive();

    if(   err != NERR_Success
       || (err = nlsCurrProfile.QueryError()) != NERR_Success
       // hydra
       || (err = nlsCurrWFProfile.QueryError()) != NERR_Success
       || (err = nlsCurrWFHomeDir.QueryError()) != NERR_Success
       // hydra end
       || (err = nlsCurrHomeDir.QueryError()) != NERR_Success
       || (err = nlsCurrRemoteDevice.QueryError()) != NERR_Success
      )
    {
        DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string1 error " << err );
	return err;
    }

    TRACEEOL(   "USERPROF_DLG:  read user \""
             << puser3Curr->QueryName()
             << "\", homedir \""
             << nlsCurrHomeDir
             << "\", homedir drive \""
             << nlsCurrRemoteDevice
             << "\"" );

    /*
     *  Home directory is considered remote if either:
     *  (1)  A remote homedir drive is specified, or
     *  (2)  The homedir starts with two backslashes
     */

    BOOL fCurrIsLocalHomeDir = IsLocalHomeDir(
                                nlsCurrHomeDir.QueryPch(),
                                puser3Curr->QueryHomedirDrive() );

    
    // hydra
    BOOL fCurrIsLocalWFHomeDir = IsLocalHomeDir(
                                nlsCurrWFHomeDir.QueryPch(),
                                pUserConfig->QueryWFHomeDirDrive() );
  

    /*
     *  If the homedir is remote, but the homedir drive is NULL,
     *  we consider the homedir drive to be Z:
     */
    if ( (!fCurrIsLocalHomeDir) && nlsCurrRemoteDevice.strlen() == 0 )
    {
        TRACEEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: forcing drive to Z:" );
        if ( (err = nlsCurrRemoteDevice.CopyFrom( UI_PROF_DEVICE_Z ))
                        != NERR_Success )
        {
            DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string2 error " << err );
	    return err;
        }
    }

    // hydra 
    if ( (!fCurrIsLocalWFHomeDir) && nlsCurrRemoteWFDevice.strlen() == 0 )
    {
        TRACEEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: forcing drive to Z:" );
        if ( (err = nlsCurrRemoteWFDevice.CopyFrom( UI_PROF_DEVICE_Z ))
                        != NERR_Success )
        {
            DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string2 error " << err );
	    return err;
        }
    }
    // hydra end

    if ( iObject == 0 ) // first object
    {
        _fIsLocalHomeDir = fCurrIsLocalHomeDir;
        // hydra
        _fIsLocalWFHomeDir = fCurrIsLocalWFHomeDir;

        if ( QueryEnableUserProfile() )
        {
	    if( ( err = _nlsProfile.CopyFrom( nlsCurrProfile ) ) != NERR_Success )
	    {
                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string3 error " << err );
	        return err;
	    }
        // hydra
	     if ((err = _nlsWFProfile.CopyFrom(nlsCurrWFProfile)) != NERR_Success )
	     {
            DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string3 error " << err );
	         return err;
	     }
        _fIndeterminateWFProfile = FALSE;
        // hydra end

        }
        if (_fIsLocalHomeDir)
        {
            _fIndeterminateRemoteDevice = TRUE;
            _fIndeterminateRemoteHomeDir = TRUE;
            if( (err = _nlsLocalHomeDir.CopyFrom( nlsCurrHomeDir )) != NERR_Success)
            {
                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string4 error " << err );
                return err;
            }
        }
        else
        {
            _fIndeterminateLocalHomeDir = TRUE;
            if(   (err = _nlsRemoteDevice.CopyFrom( nlsCurrRemoteDevice )) != NERR_Success
               || (err = _nlsRemoteHomeDir.CopyFrom( nlsCurrHomeDir )) != NERR_Success
              )
            {
                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string5 error " << err );
                return err;
            }
        }
        // hydra
        if (_fIsLocalWFHomeDir)
        {
            _fIndeterminateRemoteWFDevice = TRUE;
            _fIndeterminateRemoteWFHomeDir = TRUE;
            
            if( (err = _nlsLocalWFHomeDir.CopyFrom( nlsCurrWFHomeDir )) != NERR_Success)
            {
                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string4 error " << err );
                
                return err;
            }
        }
        else
        {
            _fIndeterminateLocalWFHomeDir = TRUE;
            if(   (err = _nlsRemoteWFDevice.CopyFrom( nlsCurrRemoteWFDevice )) != NERR_Success
               || (err = _nlsRemoteWFHomeDir.CopyFrom( nlsCurrWFHomeDir )) != NERR_Success
              )
            {
                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string5 error " << err );
                return err;
            }
        }

        _fHomeDirectoryMapRoot = pUserConfig->QueryHomeDirectoryMapRoot();

        // hydra end


        if (_fIsNetWareChecked)
        {
            if (((err = QueryUserNWPtr(iObject)->QueryNWHomeDir(&_nlsNWHomeDir)) != NERR_Success) ||
                ((err = _nlsNWHomeDir.QueryError()) != NERR_Success))
            {
                return err;
            }
        }
    }
    else	// iObject > 0
    {
        if ( QueryEnableUserProfile() )
        {
	    if ( !_fIndeterminateProfile )
	    {
	        if ( _nlsProfile._stricmp( nlsCurrProfile ) != 0 )
                {
                /*
                    It is possible that all the users have the same profile,
                    but the stricmp() failed because the profile name is
                    the same as the first user, so it was generalized.
                    Note that this can occur only for multiselect, thus
                    it is never a NewVariant().
                    Recover from this state here.
                */
                    if ( ::stricmpf( puser3Curr->QueryProfile(),
                                     QueryUser3Ptr(0)->QueryProfile() ) == 0 )
                    {
	                if( ( err = _nlsProfile.CopyFrom( puser3Curr->QueryProfile() ) ) != NERR_Success )
	                {
                            DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string6 error " << err );
	                    return err;
	                }
                    }
                    else
                    {
	                _fIndeterminateProfile = TRUE;
                    }
                }
	    }

        // hydra
        if (!_fIndeterminateWFProfile) {
           if ( _nlsWFProfile._stricmp( nlsCurrWFProfile ) != 0 ) {
               /*
                It is possible that all the users have the same profile,
                but the stricmp() failed because the profile name is
                the same as the first user, so it was generalized.
                Note that this can occur only for multiselect, thus
                it is never a NewVariant().
                Recover from this state here.
                */
               if (::stricmpf(pUserConfig->QueryWFProfilePath(),
                              QueryParent()->QueryUserConfigPtr(0)->QueryWFProfilePath()) == 0) {
                    if((err=_nlsWFProfile.CopyFrom
                            (pUserConfig->QueryWFProfilePath())) != NERR_Success )  {
                       DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string6 error " << err );
                        return err;
                   }
               } else {
                   _fIndeterminateWFProfile = TRUE;
               }
           }
       }
       // hydra end

        }
        if ( !_fIndeterminateIsLocalHomeDir )
        {
            if ( _fIsLocalHomeDir != fCurrIsLocalHomeDir )
            {
                _fIndeterminateIsLocalHomeDir = TRUE;
                _fIndeterminateLocalHomeDir   = TRUE;
                _fIndeterminateRemoteDevice   = TRUE;
                _fIndeterminateRemoteHomeDir  = TRUE;
            }
            else if ( _fIsLocalHomeDir )
            {
	        if ( !_fIndeterminateLocalHomeDir )
	        {
        	    if ( _nlsLocalHomeDir._stricmp( nlsCurrHomeDir ) != 0 )
                    {
                    /*
                        It is possible that all the users have the same homedir,
                        but the stricmp() failed because the homedir name is
                        the same as the first user, so it was generalized.
                        Note that this can occur only for multiselect, thus
                        it is never a NewVariant().
                        Recover from this state here.
                    */
                        if ( ::stricmpf( puser3Curr->QueryHomeDir(),
                                         QueryUser3Ptr(0)->QueryHomeDir() ) == 0 )
                        {
	                    if( ( err = _nlsLocalHomeDir.CopyFrom( puser3Curr->QueryHomeDir() ) ) != NERR_Success )
	                    {
                                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string7 error " << err );
	                        return err;
	                    }
                        }
                        else
                        {
	                    _fIndeterminateLocalHomeDir = TRUE;
                        }
                    }
	        }
            }
            else // !_fIsLocalHomeDir
            {
	        if ( !_fIndeterminateRemoteDevice )
	        {
        	    if ( _nlsRemoteDevice._stricmp( nlsCurrRemoteDevice ) != 0 )
        		_fIndeterminateRemoteDevice = TRUE;
	        }
	        if ( !_fIndeterminateRemoteHomeDir )
	        {
        	    if ( _nlsRemoteHomeDir._stricmp( nlsCurrHomeDir ) != 0 )
                    {
                    /*
                        It is possible that all the users have the same homedir,
                        but the stricmp() failed because the homedir name is
                        the same as the first user, so it was generalized.
                        Note that this can occur only for multiselect, thus
                        it is never a NewVariant().
                        Recover from this state here.
                    */
                        if ( ::stricmpf( puser3Curr->QueryHomeDir(),
                                         QueryUser3Ptr(0)->QueryHomeDir() ) == 0 )
                        {
	                    if( ( err = _nlsRemoteHomeDir.CopyFrom( puser3Curr->QueryHomeDir() ) ) != NERR_Success )
	                    {
                                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string8 error " << err );
	                        return err;
	                    }
                        }
                        else
                        {
	                    _fIndeterminateRemoteHomeDir = TRUE;
                        }
                    }
	        }
            }
        }

        // hydra
        if ( !_fIndeterminateIsLocalWFHomeDir )
        {
            if ( _fIsLocalWFHomeDir != fCurrIsLocalWFHomeDir )
            {
                _fIndeterminateIsLocalWFHomeDir = TRUE;
                _fIndeterminateLocalWFHomeDir   = TRUE;
                _fIndeterminateRemoteWFDevice   = TRUE;
                _fIndeterminateRemoteWFHomeDir  = TRUE;
            }
            else if ( _fIsLocalWFHomeDir )
            {
	        if ( !_fIndeterminateLocalWFHomeDir )
	        {                           
        	    if ( _nlsLocalWFHomeDir._stricmp( nlsCurrWFHomeDir ) != 0 )
                    {
                    /*
                        It is possible that all the users have the same homedir,
                        but the stricmp() failed because the homedir name is
                        the same as the first user, so it was generalized.
                        Note that this can occur only for multiselect, thus
                        it is never a NewVariant().
                        Recover from this state here.
                    */
                        if ( ::stricmpf( pUserConfig->QueryWFHomeDir(),
                                         QueryParent()->QueryUserConfigPtr( 0 )->QueryWFHomeDir() ) == 0 )
                        {
	                    if( ( err = _nlsLocalWFHomeDir.CopyFrom( pUserConfig->QueryWFHomeDir() ) ) != NERR_Success )
	                    {
                                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string7 error " << err );
	                        return err;
	                    }
                        }
                        else
                        {
	                    _fIndeterminateLocalWFHomeDir = TRUE;
                        }
                    }
	        }
            }
            else // !_fIsLocalHomeDir
            {
	        if ( !_fIndeterminateRemoteWFDevice )
	        {
        	    if ( _nlsRemoteWFDevice._stricmp( nlsCurrRemoteWFDevice ) != 0 )
        		_fIndeterminateRemoteWFDevice = TRUE;
	        }
	        if ( !_fIndeterminateRemoteWFHomeDir )
	        {
        	    if ( _nlsRemoteWFHomeDir._stricmp( nlsCurrWFHomeDir ) != 0 )
                    {
                    /*
                        It is possible that all the users have the same homedir,
                        but the stricmp() failed because the homedir name is
                        the same as the first user, so it was generalized.
                        Note that this can occur only for multiselect, thus
                        it is never a NewVariant().
                        Recover from this state here.
                    */
                        if ( ::stricmpf( pUserConfig->QueryWFHomeDir(),
                                         QueryParent()->QueryUserConfigPtr( 0 )->QueryWFHomeDir() ) == 0 )
                        {
	                    if( ( err = _nlsRemoteWFHomeDir.CopyFrom( pUserConfig->QueryWFHomeDir() ) ) != NERR_Success )
	                    {
                                DBGEOL( "USERPROF_DLG_NT::W_LMOBJtoMembers: string8 error " << err );
	                        return err;
	                    }
                        }
                        else
                        {
	                    _fIndeterminateRemoteWFHomeDir = TRUE;
                        }
                    }
	        }
            }
        }
        
        if ( !_fIndeterminateHomeDirectoryMapRoot &&
             (_fHomeDirectoryMapRoot != pUserConfig->QueryHomeDirectoryMapRoot()) ) {
                _fIndeterminateHomeDirectoryMapRoot = TRUE;
                _fHomeDirectoryMapRoot = FALSE;
            }
            // hydra end

        if (_fIsNetWareChecked && !_fIndeterminateNWHomeDir)
        {
            NLS_STR nlsNWHomeDir;
            if (((err = QueryUserNWPtr(iObject)->QueryNWHomeDir(&nlsNWHomeDir)) != NERR_Success) ||
                ((err = nlsNWHomeDir.QueryError()) != NERR_Success))
            {
                return err;
            }

            if ( _nlsNWHomeDir._stricmp (nlsNWHomeDir) != 0)
            {
                _fIndeterminateNWHomeDir = TRUE;
            }
        }
    }

    return USERPROF_DLG::W_LMOBJtoMembers( iObject );
	
} // USERPROF_DLG_NT::W_LMOBJtoMembers


/*******************************************************************

    NAME:       USERPROF_DLG_NT::InitControls

    SYNOPSIS:   Initializes the controls maintained by USERPROF_DLG_NT,
		according to the values in the class data members.
			
    RETURNS:	An error code which is NERR_Success on success.

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG
        JonN    30-Nov-1994     _psleProfile active for UM_WINNT

********************************************************************/

APIERR USERPROF_DLG_NT::InitControls()
{    
    if ( QueryEnableUserProfile() )
    {
        if( !_fIndeterminateProfile )
        {
            _psleProfile->SetText( _nlsProfile );
        }
        // hydra
        if (!_fIndeterminateWFProfile)
        {
            _psleWFProfile->SetText(_nlsWFProfile);
        }
        // hydra end

    }

    if( !_fIndeterminateIsLocalHomeDir )
    {
	_mgrpIsLocalHomeDir.SetSelection( (_fIsLocalHomeDir)
                                                ? IDPR_RB_LOCAL_HOMEDIR
                                                : IDPR_RB_REMOTE_HOMEDIR );
    }
    
    if( !_fIndeterminateLocalHomeDir )
    {
	_sleLocalHomeDir.SetText( _nlsLocalHomeDir );
    }
    
    if( !_fIndeterminateRemoteDevice )
    {
	_devcbRemoteDevice.SetText( _nlsRemoteDevice );
    }
    else
    {
	_devcbRemoteDevice.SetText( NULL );
    }
    if( !_fIndeterminateRemoteHomeDir )
    {
	_sleRemoteHomeDir.SetText( _nlsRemoteHomeDir );
    }

    // hydra 
    if( !_fIndeterminateIsLocalWFHomeDir ){
	    _mgrpIsLocalWFHomeDir.SetSelection( (_fIsLocalWFHomeDir)
                                                ? IDPR_RB_LOCAL_WFHOMEDIR
                                                : IDPR_RB_REMOTE_WFHOMEDIR );
    }
        
    if( !_fIndeterminateLocalWFHomeDir ){
        
        _sleLocalWFHomeDir.SetText( _nlsLocalWFHomeDir );
    }
   
    
    if( !_fIndeterminateRemoteWFDevice ){
	    _devcbRemoteWFDevice.SetText( _nlsRemoteWFDevice );
    }
    else{
	    _devcbRemoteWFDevice.SetText( NULL );
    }
    
    if( !_fIndeterminateRemoteWFHomeDir ){
	    _sleRemoteWFHomeDir.SetText( _nlsRemoteWFHomeDir );
    }

    if( !_fIndeterminateHomeDirectoryMapRoot ) { //&& (!_fIndeterminateIsLocalWFHomeDir || 
                                                 //!_fIndeterminateIsLocalHomeDir) ){
	    
        _cbHomeDirectoryMapRoot.SetCheck( _fHomeDirectoryMapRoot );
	    _cbHomeDirectoryMapRoot.EnableThirdState(FALSE);
    }
    else{
        _cbHomeDirectoryMapRoot.SetIndeterminate();
    }
    // hydra end

    if (_fIsNetWareInstalled)
    {
        //
        // We only need to show the NWHomeDirectory SLE if there are FPNW
        // servers in the domain. So, first check if there are FPNW servers
        // in the domain. If errors occur, then we'll assume that FPNW is not
        // installed and ignore the errors
        //
        BOOL fIsFPNWInstalled = FALSE;

        RESOURCE_STR nlsFPNWSvcAcc( IDS_FPNW_SVC_ACCOUNT_NAME );
        if ( nlsFPNWSvcAcc.QueryError() == NO_ERROR )
        {
            USER_11 user11( nlsFPNWSvcAcc, QueryLocation());
            if (  ( user11.QueryError() == NO_ERROR )
               && ( user11.GetInfo() == NO_ERROR )
               )
            {
                fIsFPNWInstalled = TRUE;
            }
        }

        if ( fIsFPNWInstalled )
        {
            if (_fIsNetWareChecked)
            {
                if (!_fIndeterminateNWHomeDir)
                    _sleNWHomeDir.SetText (_nlsNWHomeDir);
            }
            else
            {
                _sltNWHomeDir.Enable (FALSE);
                _sleNWHomeDir.Enable (FALSE);
            }
        }
        else
        {
            _sltNWHomeDir.Show (FALSE);
            _sleNWHomeDir.Show (FALSE);
        }
    }

    return USERPROF_DLG::InitControls();

} // USERPROF_DLG_NT::InitControls


/*******************************************************************

    NAME:       USERPROF_DLG_NT::W_DialogToMembers

    SYNOPSIS:	Loads data from dialog into class data members

    RETURNS:	error message (not necessarily an error code)

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG
        JonN    30-Nov-1994     _psleProfile active for UM_WINNT

********************************************************************/

APIERR USERPROF_DLG_NT::W_DialogToMembers()
{
    APIERR err = NERR_Success;

    if ( QueryEnableUserProfile() )
    {
//
// We no longer validate this path, since it is permitted to contain
// %SERVERNAME% re: bug 5850 USRMGR: %SERVERNAME% support missing
//
        err = CheckPath( _psleProfile, &_nlsProfile, _fIndeterminateProfile,
                &_fIndetNowProfile, 0L, 0xFFFFFFFF,
                TRUE, &(QueryParent()->QueryExtensionReplace()) );
                // Profile can be null string,
                // local absolute path or UNC path
                // degeneralize with QueryExtensionReplace()

        if (err != NERR_Success)
            return err;

        // hydra
        err = CheckPath( _psleWFProfile, &_nlsWFProfile,
                         _fIndeterminateWFProfile,&_fIndetNowWFProfile,
                         0L, 0xFFFFFFFF, TRUE,
                         &(QueryParent()->QueryExtensionReplace()) );
                // WinFrame profile can be null string,
                // local absolute path or UNC path
                // degeneralize with QueryExtensionReplace()

        if (err != NERR_Success)
            return err;
        // hydra end
    }

    CID cid = _mgrpIsLocalHomeDir.QuerySelection();
    switch (cid)
    {

    case RG_NO_SEL:
        _fIndetNowIsLocalHomeDir = TRUE;
        break;

    case IDPR_RB_LOCAL_HOMEDIR:

        _fIndetNowIsLocalHomeDir = FALSE;
        _fIsLocalHomeDir = TRUE;

        err = CheckPath( &_sleLocalHomeDir, &_nlsLocalHomeDir,
                _fIndeterminateLocalHomeDir, &_fIndetNowLocalHomeDir,
                ITYPE_PATH_ABSD, 0L, TRUE );
                // Local homedir must be local absolute path
                // degeneralize with no extension
        if ( err != NERR_Success )
        {
            return err;
        }
        // This field is permitted to be blank for LocalHomedir
        // if (   _fIndeterminateIsLocalHomedir
        //     && !_fIndetNowIsLocalHomedir
        //    { don't worry about it, the users who used to have a
        //      remote homedir will now have a blank local homedir }
        break;

    case IDPR_RB_REMOTE_HOMEDIR:

        _fIndetNowIsLocalHomeDir = FALSE;
        _fIsLocalHomeDir = FALSE;

        err = CheckPath( &_sleRemoteHomeDir, &_nlsRemoteHomeDir,
                _fIndeterminateRemoteHomeDir, &_fIndetNowRemoteHomeDir,
                ITYPE_UNC, 0L, TRUE );
                // Remote homedir must be UNC path
                // degeneralize with no extension
        if ( err != NERR_Success )
        {
            return err;
        }

        if (    ((err = _devcbRemoteDevice.QueryText( &_nlsRemoteDevice )) != NERR_Success )
	     || ((err = _nlsRemoteDevice.QueryError()) != NERR_Success ) )
        {
            return err;
        }


        // validate remote device field
        // CODEWORK create method to perform this validation
        if ( _nlsRemoteDevice.strlen() != 0 )
        {
            ULONG ulPathType;
            err = ::I_MNetPathType( NULL, _nlsRemoteDevice.QueryPch(),
            	&ulPathType, INPT_FLAGS_OLDPATHS );

            if (   (err != NERR_Success)
                || (ulPathType != ITYPE_DEVICE_DISK)
               )
            {
                _devcbRemoteDevice.ClaimFocus();
                _devcbRemoteDevice.SelectString();	
                return IERR_UM_RemoteDriveRequired;
            }
        }



        _fIndetNowRemoteDevice = ( _fIndeterminateRemoteDevice &&
		(_nlsRemoteDevice.strlen() == 0) );

#if defined(DEBUG) && defined(TRACE)
        TRACEEOL( "USERPROP_DLG_NT::W_DialogToMembers: _fIndetNowRemoteDevice = "
                        << ( (_fIndetNowRemoteDevice) ? "TRUE" : "FALSE" ) );
        TRACEEOL( "USERPROP_DLG_NT::W_DialogToMembers: _fIndetNowRemoteHomeDir = "
                        << ( (_fIndetNowRemoteHomeDir) ? "TRUE" : "FALSE" ) );
#endif

        //
        // This loop ensures that, if the Remote Homedir radio button
        // is selected, every user has a valid remote homedir.
        // The old homedir is assumed to be valid if it starts
        // with two backslashes.
        //
        if ( _nlsRemoteHomeDir.strlen() == 0 )
        {
            if ( !_fIndetNowRemoteHomeDir )
            {
                _sleRemoteHomeDir.ClaimFocus();
                _sleRemoteHomeDir.SelectString();
                return IERR_UM_RemoteHomedirRequired;
            }

            UINT i;
            for (i = 0; i < QueryObjectCount(); i++)
            {
                if ( IsLocalHomeDir(QueryUser3Ptr(i)->QueryHomeDir()) )
                {
                    _sleRemoteHomeDir.ClaimFocus();
                    _sleRemoteHomeDir.SelectString();
                    return IERR_UM_RemoteHomedirRequired;
                }
            }
        }
        // hydra
        if ( !_cbHomeDirectoryMapRoot.IsIndeterminate() ) {

            _fHomeDirectoryMapRoot = _cbHomeDirectoryMapRoot.IsChecked();
            _fIndeterminateHomeDirectoryMapRoot = FALSE;
        }
        // hydra end

        break;

    default:
        ASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    
// hydra 
// start of old code for WFHomeDir

    CID wfcid = _mgrpIsLocalWFHomeDir.QuerySelection();
    switch (wfcid)
    {

    case RG_NO_SEL:
        _fIndetNowIsLocalWFHomeDir = TRUE;
        break;

    case IDPR_RB_LOCAL_WFHOMEDIR:

        _fIndetNowIsLocalWFHomeDir = FALSE;
        _fIsLocalWFHomeDir = TRUE;

        err = CheckPath( &_sleLocalWFHomeDir, &_nlsLocalWFHomeDir,
                _fIndeterminateLocalWFHomeDir, &_fIndetNowLocalWFHomeDir,
                ITYPE_PATH_ABSD, 0L, TRUE );
                // Local homedir must be local absolute path
                // degeneralize with no extension
        
        if ( err != NERR_Success )
        {
            return err;
        }
        // This field is permitted to be blank for LocalHomedir
        // if (   _fIndeterminateIsLocalHomedir
        //     && !_fIndetNowIsLocalHomedir
        //    { don't worry about it, the users who used to have a
        //      remote homedir will now have a blank local homedir }
        break;

    case IDPR_RB_REMOTE_WFHOMEDIR:

        _fIndetNowIsLocalWFHomeDir = FALSE;
        _fIsLocalWFHomeDir = FALSE;

  
         err = CheckPath( &_sleRemoteWFHomeDir, &_nlsRemoteWFHomeDir,
                _fIndeterminateRemoteWFHomeDir, &_fIndetNowRemoteWFHomeDir,
                ITYPE_UNC, 0L, TRUE );
        
                // Remote wfhomedir must be UNC path
                // degeneralize with no extension
        if ( err != NERR_Success )
        {
            return err;
        }

        if (    ((err = _devcbRemoteWFDevice.QueryText( &_nlsRemoteWFDevice )) != NERR_Success )
	     || ((err = _nlsRemoteWFDevice.QueryError()) != NERR_Success ) )
        {
            return err;
        }


        // validate remote device field
        // CODEWORK create method to perform this validation
        if ( _nlsRemoteWFDevice.strlen() != 0 )
        {
            ULONG ulPathType;
            err = ::I_MNetPathType( NULL, _nlsRemoteWFDevice.QueryPch(),
            	&ulPathType, INPT_FLAGS_OLDPATHS );

            if (   (err != NERR_Success)
                || (ulPathType != ITYPE_DEVICE_DISK)
               )
            {
                _devcbRemoteWFDevice.ClaimFocus();
                _devcbRemoteWFDevice.SelectString();	
                return IERR_UM_RemoteDriveRequired;
            }
        }



        _fIndetNowRemoteWFDevice = ( _fIndeterminateRemoteWFDevice &&
		(_nlsRemoteWFDevice.strlen() == 0) );

#if defined(DEBUG) && defined(TRACE)
        TRACEEOL( "USERPROP_DLG_NT::W_DialogToMembers: _fIndetNowRemoteWFDevice = "
                        << ( (_fIndetNowRemoteWFDevice) ? "TRUE" : "FALSE" ) );
        TRACEEOL( "USERPROP_DLG_NT::W_DialogToMembers: _fIndetNowRemoteWFHomeDir = "
                        << ( (_fIndetNowRemoteWFHomeDir) ? "TRUE" : "FALSE" ) );
#endif

        //
        // This loop ensures that, if the Remote Homedir radio button
        // is selected, every user has a valid remote homedir.
        // The old homedir is assumed to be valid if it starts
        // with two backslashes.
        //
        if ( _nlsRemoteWFHomeDir.strlen() == 0 )
        {
            if ( !_fIndetNowRemoteWFHomeDir )
            {
                _sleRemoteWFHomeDir.ClaimFocus();
                _sleRemoteWFHomeDir.SelectString();
                return IERR_UM_RemoteHomedirRequired;
            }

            UINT i;
            for (i = 0; i < QueryObjectCount(); i++)
            {
                if ( IsLocalHomeDir( QueryParent()->QueryUserConfigPtr(i)->QueryWFHomeDir() ) )
                {
                    _sleRemoteWFHomeDir.ClaimFocus();
                    _sleRemoteWFHomeDir.SelectString();
                    return IERR_UM_RemoteHomedirRequired;
                }
            }
        }

        
        if ( !_cbHomeDirectoryMapRoot.IsIndeterminate() ) {

            _fHomeDirectoryMapRoot = _cbHomeDirectoryMapRoot.IsChecked();
            _fIndeterminateHomeDirectoryMapRoot = FALSE;
        }


        break;

    default:
        ASSERT( FALSE );

        return ERROR_GEN_FAILURE;

    }
// end of case statement for WFHomeDir


    if ( _fIsLocalWFHomeDir && _fIsLocalHomeDir ){
        _fHomeDirectoryMapRoot = FALSE;
    }
// hydra end

    if (_fIsNetWareChecked)
    {
        err = CheckPath( &_sleNWHomeDir, &_nlsNWHomeDir, _fIndeterminateNWHomeDir,
                &_fIndetNowNWHomeDir, ITYPE_PATH_RELND, 0L);

        if (err != NERR_Success)
            return err;
    }

    return USERPROF_DLG::W_DialogToMembers();

} // USERPROF_DLG_NT::W_DialogToMembers


// hydra
/*******************************************************************

    NAME:       USERPROF_DLG_NT::PerformOne
	
    SYNOPSIS:	PERFORMER::PerformSeries calls this

    ENTRY:	iObject  -	index of the object to save

    		perrMsg  -	pointer to error message, that
				is only used when this function
				return value is not NERR_Success
					
		pfWorkWasDone - set to TRUE unless this is a new variant.
                                Actual writing of the USER_CONFIG object 
                                will only take place if changes were made 
                                or the object was 'dirty' to begin with.
					
    RETURNS:	An error code which is NERR_Success on success.

    NOTES:	This PerformOne() override first calls the
                USER_SUBPROP_DLG::PerformOne() member function, then
                performs USER_CONFIG updating.

********************************************************************/

APIERR USERPROF_DLG_NT::PerformOne(
	UINT		iObject,
	APIERR *	perrMsg,
	BOOL *		pfWorkWasDone
	)
{
    APIERR err = NERR_Success;
    USER_CONFIG * pUserConfig = QueryParent()->QueryUserConfigPtr( iObject );
    ASSERT( pUserConfig != NULL );

// WFHomeDir

    // Homedir was validated in W_DialogToMembers()
    // Only degeneralize if we will be writing information
        if ( !_fIndetNowIsLocalWFHomeDir )
        {
            NLS_STR nlsTemp( pUserConfig->QueryWFHomeDir() );
            USER_3 * puser3 = QueryUser3Ptr( iObject );
            
            if ( (err = nlsTemp.QueryError()) != NERR_Success )
            {
                return err;
            }

            if (_fIsLocalWFHomeDir)
            {

            //
            // If the admin has specified a local homedir and provided
            // a local homedir path, , accept it.
            // Otherwise, if the user has specified a local homedir but
            // has not provided a local homedir path, _and_ the user
            // previously had a remote homedir, set the user's homedir
            // to NULL.
            //

                if ( !_fIndetNowLocalWFHomeDir )
                {
                    err = nlsTemp.CopyFrom( _nlsLocalWFHomeDir );
                }
                else if ( !IsLocalHomeDir( pUserConfig->QueryWFHomeDir(), pUserConfig->QueryWFHomeDirDrive() ) )
                {
                    err = nlsTemp.CopyFrom( NULL );
                }

                if (   err != NERR_Success
                    || (err = pUserConfig->SetWFHomeDirDrive( NULL ))
                                 != NERR_Success
                   )
                {
                    return err;
                }
            }
            else // !_fIsLocalHomeDir
            {

            //
            // We have already guaranteed in W_DialogToMembers that
            // every user has a valid homedir and/or homedir drive
            // if the corresponding IndetNow flag is set.
            //

                if ( !_fIndetNowRemoteWFHomeDir )
                {
                    err = nlsTemp.CopyFrom( _nlsRemoteWFHomeDir );
                }

                if (   err == NERR_Success
                    && !_fIndetNowRemoteWFDevice
                   )
                {
                    err = pUserConfig->SetWFHomeDirDrive( _nlsRemoteWFDevice );
                    pUserConfig->SetDirty();
                }

                if (   err != NERR_Success)
                {
                    return err;
                }
            }
            if ( IsNewVariant() )
            {
                err = ((NEW_USERPROP_DLG *)QueryParent())->SetNewWFHomeDir( nlsTemp );
            }
            else
            {
                err = DegeneralizeString( &nlsTemp,
                                          puser3->QueryName(),
                                          NULL,
                                          QueryParent()->QueryGeneralizedHomeDirPtr() );
                
                if ( (err == NERR_Success) && (nlsTemp._stricmp(pUserConfig->QueryWFHomeDir()) != 0) ) {
                    pUserConfig->SetWFHomeDir(nlsTemp.QueryPch());
                    pUserConfig->SetDirty();
                    pUserConfig->SetWFHomeDirDirty();
                }                
            }
            
            if (err != NERR_Success)
                return err;
        }
// end WFHomeDirStuff
    
    /*
     * First, we call the parent's PerformOne().  If that's sucessful,
     * we do our stuff.
     */
    err = USER_SUBPROP_DLG::PerformOne( iObject, perrMsg, pfWorkWasDone );
    if( err == NERR_Success )
    {
        *perrMsg = IDS_UMEditFailure;

        if ( !IsNewVariant() )
            *pfWorkWasDone = TRUE;

        if ( !_fIndeterminateHomeDirectoryMapRoot &&
             (_fHomeDirectoryMapRoot != pUserConfig->QueryHomeDirectoryMapRoot()) ) {

            pUserConfig->SetHomeDirectoryMapRoot( _fHomeDirectoryMapRoot );
            pUserConfig->SetDirty();
        }

        if ( !_fIndetNowWFProfile) {
            NLS_STR nlsTemp( _nlsWFProfile );
            USER_3 * puser3 = QueryUser3Ptr( iObject );

            err = nlsTemp.QueryError();
            if (err != NERR_Success)
                return err;

            if ((!IsNewVariant()) && (err == NERR_Success))
                err = DegeneralizeString(&nlsTemp,
                                         puser3->QueryName(),
                                         QueryParent()->QueryExtensionReplace());
            if (err != NERR_Success)
                    return err;

            if (nlsTemp._stricmp(pUserConfig->QueryWFProfilePath()) != 0) {
                pUserConfig->SetWFProfilePath(nlsTemp.QueryPch());
                pUserConfig->SetDirty();
		if ( IsNewVariant() )
		{
		    err = ((NEW_USERPROP_DLG *)QueryParent())->SetNewWFProfile( nlsTemp );
		}
            }
        }

        /* Output now if this is not a 'new' user.
         */
        if ( !IsNewVariant() )
            err = pUserConfig->SetInfo();
    }

    return err;

} // USERPROF_DLG_NT::PerformOne
// hydra end

/*******************************************************************

    NAME:       USERPROF_DLG_NT::W_MembersToLMOBJ

    SYNOPSIS:	Loads class data members into the USER_2 object

    ENTRY:	puser2		- pointer to a USER_2 to be modified
	
		pusermemb	- pointer to a USER_MEMB to be modified
			
    RETURNS:	error code

    NOTES:	If some fields were different for multiply-selected
    		objects, the initial contents of the edit fields
		contained only a default value.  In this case, we only
		want to change the LMOBJ if the value of the edit field
		has changed.  This is also important for "new" variants,
		where PerformOne will not always copy the object and
		work with the copy.

    NOTES:	Note that the LMOBJ is not changed if the current
		contents of the edit field are the same as the
		initial contents.

    HISTORY:
	JonN	27-Feb-1992	Split from USERPROF_DLG
        JonN    22-Apr-1992     Reformed %USERNAME% (NTISSUE #974)
        JonN    30-Nov-1994     _psleProfile active for UM_WINNT

********************************************************************/

APIERR USERPROF_DLG_NT::W_MembersToLMOBJ(
	USER_2 *	puser2,
	USER_MEMB *	pusermemb )
{
    PUSER_3 puser3 = (USER_3 *) puser2;

    APIERR err = NERR_Success;

    if ( QueryEnableUserProfile() )
    {
        if ( !_fIndetNowProfile )
        {
            NLS_STR nlsTemp( _nlsProfile );
            err = nlsTemp.QueryError();
            if (   err != NERR_Success
               )
            {
                return err;
            }

            if ( IsNewVariant() )
            {
                //  CODEWORK just call these SetNewProfile et al
                err = ((NEW_USERPROP_DLG *)QueryParent())->SetNewProfile( nlsTemp );
            }
            else
            {
                err = DegeneralizeString( &nlsTemp,
                                          puser3->QueryName(),
                                          QueryParent()->QueryExtensionReplace() );
                if (err == NERR_Success)
                    err = puser3->SetProfile( nlsTemp );
            }
        if (err != NERR_Success)
            return err;
        }
    }

    // Homedir was validated in W_DialogToMembers()
    // Only degeneralize if we will be writing information
    if ( !_fIndetNowIsLocalHomeDir )
    {
        NLS_STR nlsTemp( puser3->QueryHomeDir() );
        if ( (err = nlsTemp.QueryError()) != NERR_Success )
        {
            return err;
        }

        if (_fIsLocalHomeDir)
        {

            //
            // If the admin has specified a local homedir and provided
            // a local homedir path, , accept it.
            // Otherwise, if the user has specified a local homedir but
            // has not provided a local homedir path, _and_ the user
            // previously had a remote homedir, set the user's homedir
            // to NULL.
            //

            if ( !_fIndetNowLocalHomeDir )
            {
                err = nlsTemp.CopyFrom( _nlsLocalHomeDir );
            }
            else if ( !IsLocalHomeDir( puser3 ) )
            {
                err = nlsTemp.CopyFrom( NULL );
            }

            if (   err != NERR_Success
                || (err = puser3->SetHomedirDrive( NULL ))
                             != NERR_Success
               )
            {
                return err;
            }
        }
        else // !_fIsLocalHomeDir
        {

            //
            // We have already guaranteed in W_DialogToMembers that
            // every user has a valid homedir and/or homedir drive
            // if the corresponding IndetNow flag is set.
            //

            if ( !_fIndetNowRemoteHomeDir )
            {
                err = nlsTemp.CopyFrom( _nlsRemoteHomeDir );
            }

            if (   err == NERR_Success
                && !_fIndetNowRemoteDevice
               )
            {
                err = puser3->SetHomedirDrive( _nlsRemoteDevice );
            }

            if (   err != NERR_Success
               )
            {
                return err;
            }
        }
        if ( IsNewVariant() )
        {
            err = ((NEW_USERPROP_DLG *)QueryParent())->SetNewHomeDir( nlsTemp );
        }
        else
        {
            err = DegeneralizeString( &nlsTemp,
                                      puser3->QueryName(),
                                      NULL,
                                      QueryParent()->QueryGeneralizedHomeDirPtr() );
            if (err == NERR_Success)
                err = puser3->SetHomeDir( nlsTemp );
        }
        if (err != NERR_Success)
            return err;
    }

    TRACEEOL(   "USERPROF_DLG: wrote user \""
             << puser3->QueryName()
             << "\", homedir \""
             << puser3->QueryHomeDir()
             << "\", homedir drive \""
             << puser3->QueryHomedirDrive()
             << "\"" );

    if (_fIsNetWareChecked && !_fIndetNowNWHomeDir)
    {
        if (( err = ((USER_NW *) puser2)->SetNWHomeDir (_nlsNWHomeDir.QueryPch(), TRUE)) != NERR_Success)
        {
            return err;
        }
    }

    return USERPROF_DLG::W_MembersToLMOBJ( puser3, pusermemb );

}// USERPROF_DLG_NT::W_MembersToLMOBJ
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\admin\user\user\usrlb.cxx ===
/**********************************************************************/
/**                Microsoft Windows NT                              **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    usrlb.cxx
    USER_LISTBOX, USER_LBI, and USER_COLUMN_HEADER module

    FILE HISTORY:
        rustanl     01-Jul-1991     Created from usrmain.cxx
        jonn        10-Oct-1991     LMOENUM update
        o-SimoP     26-Nov-1991     Added IsDestroyable
        o-SimoP     31-Dec-1991     CR changes, attended by BenG, JonN and I
        JonN        03-Feb-1992     NT_USER_ENUM
        JonN        27-Feb-1992     multiple bitmaps in both panes
        JonN        15-Mar-1992     Enabled NT_USER_ENUM
        JonN        01-Apr-1992     NT enumerator CR changes, attended by
                                    JimH, JohnL, KeithMo, JonN, ThomasPa

        CODEWORK  The USER_LBI ctors which allocate memory, should allocate
                  it in one piece rather than four seperate pieces.
*/

#include <ntincl.hxx>
extern "C"
{
    #include <ntlsa.h>
    #include <ntsam.h>
}

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_APP
#define INCL_BLT_CC
#define INCL_BLT_TIMER
#include <blt.hxx>

#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <uiassert.hxx>
#include <lmoenum.hxx>
#include <lmoeusr.hxx>  // Downlevel user enumerator
#ifdef WIN32
#include <lmoent.hxx>   // NT user enumerator
#endif // WIN32

#include <usrcolw.hxx>
#include <usrmgrrc.h>
#include <usrmain.hxx>
#include <usrlb.hxx>
#include <memblb.hxx>

#include <uintmem.hxx> // FillUnicodeString




/*******************************************************************

    NAME: ::FillUnicodeString

    SYNOPSIS: Standalone method for filling in a UNICODE_STRING

    ENTRY:	punistr - Unicode string to be filled in.
		pch - Source for filling the unistr

    EXIT:

    NOTES: punistr->Buffer is allocated here and must be deallocated
	by the caller using FreeUnicodeString.

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR FillUnicodeString( UNICODE_STRING * punistr, const TCHAR * pch )
{
    if ( pch == NULL )
        pch = SZ("");

    USHORT cTchar = (USHORT)::strlenf(pch);

    // Length and MaximumLength are counts of bytes.
    punistr->Length = cTchar * sizeof(WCHAR);
    punistr->MaximumLength = punistr->Length + sizeof(WCHAR);
    punistr->Buffer = new WCHAR[cTchar + 1];
    APIERR err = NERR_Success;
    if (punistr->Buffer == NULL)
        err = ERROR_NOT_ENOUGH_MEMORY;
    else
        ::memcpyf( punistr->Buffer, pch, punistr->MaximumLength );

    return err;
}


/******