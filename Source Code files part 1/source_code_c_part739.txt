dwType)
{
    CSimpleReg hkTest;
    CSimpleString strClsid;
    CSimpleString strRegPath;
    HKEY    hk = NULL;
    TraceEnter (TRACE_PROPUI, "GetDeviceUIKey");
    if (S_OK == GetClsidFromDevice (pWiaItemRoot, strClsid))
    {
        strRegPath.Format(c_szPropkey, strClsid.String());
        hkTest = CSimpleReg (HKEY_CLASSES_ROOT, strRegPath, false, KEY_READ );
        Trace(TEXT("szRegPath for UI key: %s"), strRegPath.String());
        if (TestKeyForExtension (hkTest, dwType))
        {
            RegOpenKeyEx (hkTest, NULL, 0, KEY_READ, &hk);
        }
    }
    TraceLeave ();
    return hk;
}



/*****************************************************************************

   GetGeneralUIKey

   Retrieves the reg key of the General prop sheet page for this item type

 *****************************************************************************/

STDAPI_(HKEY)
GetGeneralUIKey (IUnknown *pWiaItemRoot, DWORD dwType)
{

    HKEY hk = NULL;
    LPCTSTR pszDevice = NULL;
    CSimpleReg  hkTest;
    TCHAR   szRegPath[MAX_PATH];
    WORD    wType;


    TraceEnter (TRACE_PROPUI, "GetGeneralUIKey");

    if (SUCCEEDED(GetDeviceTypeFromDevice (pWiaItemRoot, &wType)))
    {
        switch (wType)
        {
            case StiDeviceTypeScanner:
                pszDevice = c_szScannerKey;
                break;
            case StiDeviceTypeStreamingVideo:
            case StiDeviceTypeDigitalCamera:
                pszDevice = c_szCameraKey;
                break;
            default:
                Trace (TEXT("Unknown device type in GetGeneralUIKey"));
                break;
        }
        wsprintf (szRegPath, pszDevice, cszImageCLSID);

        hkTest = CSimpleReg (HKEY_CLASSES_ROOT,szRegPath,false,KEY_READ);
        if (TestKeyForExtension (hkTest, dwType))
        {
            RegOpenKeyEx (hkTest, NULL, 0, KEY_READ, &hk);
        }
    }
    TraceLeave ();
    return hk;
}

#define MAX_PAGES 20


/*****************************************************************************

   AddPropPageProc

   Given a propertysheet page, adds it to the array of pages
   in the propsheetheader. Assumes the array is adequately allocated.

 *****************************************************************************/

BOOL CALLBACK AddPropPageProc (HPROPSHEETPAGE hPage, LPPROPSHEETHEADER ppsh)
{
    BOOL bRet= TRUE;
    TraceEnter (TRACE_PROPUI, "AddPropPageProc");
    if (ppsh->nPages >= MAX_PAGES)
    {
        Trace (TEXT("Max pages reached in AddPropPageProc"));
        bRet = FALSE;
    }
    else
    {
        ppsh->phpage[ppsh->nPages++] = hPage;
    }

    TraceLeave ();
    return bRet;
}



/*****************************************************************************

   ExtendPropSheetFromClsid

   <Notes>

 *****************************************************************************/

HRESULT
ExtendPropSheetFromClsid (REFCLSID          clsid,
                          LPPROPSHEETHEADER ppsh,
                          IDataObject*      pDataObj)
{
    HRESULT                     hr;
    CComPtr<IShellExtInit>      pInit;
    CComQIPtr<IShellPropSheetExt, &IID_IShellPropSheetExt> pExt;

    TraceEnter (TRACE_PROPUI, "ExtendPropSheetFromClsid");
    hr = CoCreateInstance (clsid,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IShellExtInit,
                           reinterpret_cast<LPVOID*>(&pInit));

    FailGracefully (hr, "CoCreateInstance failed in ExtendPropSheetFromClsid");
    hr = pInit->Initialize (NULL, pDataObj, NULL);
    FailGracefully (hr, "Initialize failed in ExtendPropSheetFromClsid");

    pExt = pInit;   // implicit QI for IID_IShellPropSheetExt
    if (!pExt)
    {
        ExitGracefully( hr, E_FAIL, "QueryInterface for IShellPropSheetExt failed in ExtendPropSheetFromClsid" );
    }

    hr = pExt->AddPages (reinterpret_cast<LPFNADDPROPSHEETPAGE>(AddPropPageProc),
                         reinterpret_cast<LPARAM>(ppsh));
    FailGracefully (hr, "AddPages failed in ExtendPropSheetFromClsid");

exit_gracefully:

    TraceLeaveResult (hr);
}


/*****************************************************************************

   ExtendPropSheetFromKey

   Reads the CLSIDs stored in the given registry key
   and invokes the IPropertySheetExt handler

 *****************************************************************************/

HRESULT
ExtendPropSheetFromKey (HKEY                hkey,
                        LPPROPSHEETHEADER   ppsh,
                        IDataObject*        pDataObj)
{
    HRESULT hr    = S_OK;
    DWORD   i     = 0;
    DWORD   dwLen = MAX_PATH;
    TCHAR   szSubKey[MAX_PATH];

    CLSID   clsid;

    TraceEnter (TRACE_PROPUI, "ExtendPropSheetFromKey");
    // enum the keys
    while (ERROR_SUCCESS == RegEnumKeyEx (hkey,
                                          i++,
                                          szSubKey,
                                          &dwLen,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL))
    {
        LPWSTR pClsid;
        #ifdef UNICODE
        pClsid = szSubKey;
        #else
        WCHAR szw[MAX_PATH];

        MultiByteToWideChar (CP_ACP, 0, szSubKey, -1, szw, ARRAYSIZE(szw));
        pClsid = szw;
        #endif

        dwLen = MAX_PATH;

        // szSubKey is the string name of a CLSID
        if (SUCCEEDED(CLSIDFromString (pClsid, &clsid)))
        {
            hr = ExtendPropSheetFromClsid(clsid, ppsh, pDataObj);
            FailGracefully (hr, "ExtendPropSheetFromClsid failed in ExtendPropSheetFromKey");
        }
    }
exit_gracefully:
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CWiaPropUI::GetItemPropertyPages

   Fill in the propsheetheader with array of hpropsheetpages for the given item

 *****************************************************************************/

HRESULT
CWiaPropUI::GetItemPropertyPages (IWiaItem *pItem, LPPROPSHEETHEADER ppsh)
{

    HRESULT             hr      = S_OK;
    HKEY                hSubkey = NULL;
    HKEY                aKeys[2];
    CComPtr<IWiaItem>   pDevice;
    CComPtr<IDataObject>pdo;
    LONG lType;
    WORD wDevType;
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::GetItemPropertyPages");


    ppsh->dwFlags &= ~PSH_PROPSHEETPAGE;
    // Use LocalAlloc instead of new, because client will be freeing this array, just to make sure we're
    // using the same allocator/deallocator methods
    ppsh->phpage = reinterpret_cast<HPROPSHEETPAGE*>(LocalAlloc (LPTR,sizeof (HPROPSHEETPAGE) * MAX_PAGES));
    if (!(ppsh->phpage))
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pItem->GetItemType (&lType);
        pItem->GetRootItem (&pDevice);
        VerifyCachedDevice(pDevice);
        GetDeviceTypeFromDevice (pDevice, &wDevType);
        //
        // special-case scanner items, They aren't enumerated in the namespace
        // so we have to build the dataobject directly
        if (!(lType & WiaItemTypeRoot) && wDevType == StiDeviceTypeScanner)
        {
            LPITEMIDLIST pidl = IMCreateScannerItemIDL (pItem, NULL);
            CImageDataObject *pido = new CImageDataObject (pItem);
            if (pido)
            {
                hr = pido->Init(NULL, 1,
                                const_cast<LPCITEMIDLIST*>(&pidl),
                                NULL);
                if (SUCCEEDED(hr))
                {
                    hr = pido->QueryInterface(IID_IDataObject,
                                              reinterpret_cast<LPVOID*>(&pdo));
                    ProgramDataObjectForExtension (pdo, pItem);
                }
                pido->Release ();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = GetDataObjectForItem (pItem, &pdo);
        }
    }
    if (SUCCEEDED(hr))
    {

        aKeys[0] = GetGeneralUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
        aKeys[1] = GetDeviceUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
        for (int i=0;i<2;i++)
        {
            if (aKeys[i])
            {
                RegOpenKeyEx (aKeys[i],
                              c_szPropSheetHandler,
                              0,
                              KEY_READ,
                              &hSubkey);
                if (hSubkey)
                {
                    ExtendPropSheetFromKey (hSubkey, ppsh, pdo);
                    RegCloseKey (hSubkey);
                    hSubkey = NULL;
                }

                RegCloseKey (aKeys[i]);
            }
        }
    }

    if ((FAILED(hr) || !(ppsh->nPages)) && ppsh->phpage)
    {
        LocalFree(ppsh->phpage);
    }
    TraceLeaveResult (hr);

}



CPropSheetExt::CPropSheetExt ()
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::CPropSheetExt");
    TraceLeave ();
}

CPropSheetExt::~CPropSheetExt ()
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::~CPropSheetExt");
    TraceLeave ();

}

STDMETHODIMP
CPropSheetExt::QueryInterface (REFIID  riid,
                                LPVOID* ppvObj
                                )
{
    HRESULT hr;
    INTERFACES iface[]=
    {

        &IID_IShellExtInit,         static_cast<IShellExtInit*>(this),
        &IID_IShellPropSheetExt,    static_cast<IShellPropSheetExt*>(this)
    };

    TraceEnter( TRACE_PROPUI, "CPropSheetExt::QueryInterface" );

    hr = HandleQueryInterface(riid, ppvObj, iface, ARRAYSIZE(iface));

    TraceLeaveResult( hr );
}

#undef CLASS_NAME
#define CLASS_NAME CPropSheetExt
#include "unknown.inc"

/*****************************************************************************

   CPropSheetExt::Initialize

   Called by the shell to init the property sheet extension. Just store the
   data object for future use

 *****************************************************************************/

STDMETHODIMP
CPropSheetExt::Initialize (LPCITEMIDLIST   pidlFolder,
                           LPDATAOBJECT    lpdobj,
                           HKEY            hkeyProgID)
{
    HRESULT         hr   = S_OK;


    TraceEnter (TRACE_PROPUI, "CPropSheetExt::Initialize");
    if (!lpdobj)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_pdo = lpdobj;
    }
    TraceLeaveResult (hr);

}

// max. number of General tabs on one multi-sel sheet
#define MAX_PROPERTY_PAGES   12

STDMETHODIMP
CPropSheetExt::AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam)
{
    HRESULT                 hr = S_OK;
    LPIDA  pida= NULL;
    LPITEMIDLIST pidl = NULL;
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddPages");
    //
    // Initialize the common controls
    //
    INITCOMMONCONTROLSEX ice;
    ice.dwSize = sizeof(ice);
    ice.dwICC = 0xfff; // just register everything, we might need them one day
    if (!InitCommonControlsEx (&ice))
    {
        Trace(TEXT("InitCommonControlsEx failed! Error: %x"), GetLastError());
    }


    //
    // Loop through the array of idlists indicated by the dataobject.
    // If only 1 item is in the list, add all its pages.
    // If more than 1 item is in the list, add the general page for that item
    //
    hr = GetIDAFromDataObject (m_pdo, &pida, true);
    if (SUCCEEDED(hr))
    {
        if (pida->cidl == 1)
        {
            pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
            hr = AddPagesForIDL (pidl, false, lpfnAddPage, lParam);
        }
        else
        {
            for (UINT i=1;SUCCEEDED(hr) &&  i < MAX_PROPERTY_PAGES && i<=pida->cidl;i++)
            {
                pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[i]);
                if (!IsContainerIDL(pidl) )
                {
                    hr = AddPagesForIDL (pidl, true, lpfnAddPage, lParam);
                }
            }
        }
    }
    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


HRESULT
CPropSheetExt::AddPagesForIDL (LPITEMIDLIST pidl,
                               bool bGeneralPageOnly,
                               LPFNADDPROPSHEETPAGE lpfnAddPage,
                               LPARAM lParam)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddPagesForIDL");
    //
    // Handle WIA devices
    //
    if (!IsSTIDeviceIDL(pidl))
    {
        //
        // Get the IWiaItem * from the id list
        //
        CComPtr<IWiaItem> pItem;
        hr = IMGetItemFromIDL (pidl, &pItem, TRUE);
        if (SUCCEEDED(hr))
        {
            //
            // If this is a camera item (non-root) page, and it is not a folder
            //
            if (IsCameraItemIDL(pidl) && !IsContainerIDL(pidl))
            {
                //
                // Get the property that determines whether or not we should suppress this page
                // Ignore the return value, because if the item doesn't implement it,
                // nSuppressPropertyPages will still be 0, and the default is to display the property page
                //
                LONG nSuppressPropertyPages = 0;
                PropStorageHelpers::GetProperty( pItem, WIA_IPA_SUPPRESS_PROPERTY_PAGE, nSuppressPropertyPages );

                //
                // If the WIA_PROPPAGE_CAMERA_ITEM_GENERAL flag is not set for this item,
                // add the general camera item property page for it.
                //
                if ((nSuppressPropertyPages & WIA_PROPPAGE_CAMERA_ITEM_GENERAL) == 0)
                {
                    //
                    // we only have one page for pictures, so add it
                    //
                    CPropertyPage *pPage = new CWiaCameraItemPage (pItem);
                    if (pPage)
                    {
                        if (pPage->ItemSupported(pItem))
                        {
                            hr = pPage->AddPage(lpfnAddPage, lParam);
                        }
                        DoRelease(pPage);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            //
            // If this is a root (device) item
            //
            else if (IsDeviceIDL(pidl))
            {
                //
                // Get the device type
                //
                DWORD dwType = IMGetDeviceTypeFromIDL (pidl);

                if (!bGeneralPageOnly)
                {
                    hr = AddDevicePages (pItem, lpfnAddPage, lParam, dwType);
                }
                else
                {
                    //
                    // We are only going to add at most one page here, so if pPage is
                    // still NULL after we're done, we won't add any.
                    //
                    CPropertyPage *pPage = NULL;

                    switch (dwType)
                    {
                        default:
                        case StiDeviceTypeDefault:
                        case StiDeviceTypeScanner:
                            pPage = new CWiaScannerPage (pItem);
                            //
                            // If we can't create this page, we must be out of memory
                            //
                            if (!pPage)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            break;

                        case StiDeviceTypeDigitalCamera:
                        case StiDeviceTypeStreamingVideo:
                            pPage = new CWiaCameraPage (pItem);
                            //
                            // If we can't create this page, we must be out of memory
                            //
                            if (!pPage)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            break;
                    }

                    if (pPage)
                    {
                        hr = pPage->AddPage(lpfnAddPage,lParam, true);
                        DoRelease(pPage);
                    }
                }
            }
        }
    }
    //
    // Handle STI devices
    //
    else
    {
        MySTIInfo *pDevInfo;
        pDevInfo = new MySTIInfo;


        if (pDevInfo)
        {
            CSimpleStringWide strDeviceId;
            IMGetDeviceIdFromIDL (pidl, strDeviceId);
            pDevInfo->dwPageMask = bGeneralPageOnly ? STIPAGE_GENERAL : 0xffffffff;
            hr = GetSTIInfoFromId (strDeviceId, &pDevInfo->psdi);
            if (SUCCEEDED(hr))
            {
                hr = AddSTIPages (lpfnAddPage, lParam, pDevInfo);
            }

            pDevInfo->Release ();
        }

        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    TraceLeaveResult (hr);
}


HRESULT
CPropSheetExt::AddDevicePages(IWiaItem *pDevice, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, DWORD dwType)
{
    HRESULT hr = S_OK;
    TraceEnter(TRACE_PROPUI, "CPropSheetExt::AddDevicePages");
    CPropertyPage *pPage ;


    switch (dwType)
    {
        default:
        case StiDeviceTypeDefault:
        case StiDeviceTypeScanner:
            pPage = new CWiaScannerPage (pDevice);
            break;
        case StiDeviceTypeDigitalCamera:
        case StiDeviceTypeStreamingVideo:
            pPage = new CWiaCameraPage (pDevice);
            break;
    }
    if (pPage)
    {
        hr = pPage->AddPage(lpfnAddPage,lParam);
        pPage->Release ();

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    // the general page is required. Other pages we can live without in low memory.
    if (SUCCEEDED(hr))
    {
        pPage = new CWiaEventsPage (pDevice);
        if (pPage)
        {
            if (pPage->ItemSupported(pDevice))
            {
                pPage->AddPage(lpfnAddPage, lParam);
            }
            pPage->Release ();
        }
        AddICMPage (lpfnAddPage, lParam);
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CPropSheetExt::AddStiPages

   Add the property sheets for the current STI device

 *****************************************************************************/


HRESULT
CPropSheetExt::AddSTIPages (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, MySTIInfo *pDevInfo)
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddSTIPages");
    BOOL bIsPnP;
    CSTIGeneralPage *pGeneralPage = NULL;
    CPortSettingsPage *pPortPage = NULL;
    CEventMonitor *pEventPage = NULL;
    HRESULT hr = S_OK;

    CSimpleString csKey(IsPlatformNT() ? REGSTR_PATH_STIDEVICES_NT : REGSTR_PATH_STIDEVICES);
    csKey += TEXT("\\");
    csKey += CSimpleStringConvert::NaturalString(CSimpleStringWide(pDevInfo->psdi -> szDeviceInternalName));
    csKey += REGSTR_PATH_EVENTS;
    CSimpleReg regEvents (HKEY_LOCAL_MACHINE, csKey, false, KEY_READ );

    bIsPnP = IsPnPDevice (pDevInfo->psdi);

    // general page, for all devices
    if (pDevInfo->dwPageMask & STIPAGE_GENERAL)
    {

        pGeneralPage= new CSTIGeneralPage (pDevInfo, bIsPnP);
        if (pGeneralPage)
        {
            pGeneralPage->AddPage (lpfnAddPage, lParam);
        }
        else
        {
            ExitGracefully (hr, E_OUTOFMEMORY, "");
        }
    }
    if (pDevInfo->dwPageMask & STIPAGE_PORTS)
    {

        // port settings page for serial devices
        pPortPage = new CPortSettingsPage (pDevInfo);
        if (pPortPage && pPortPage->IsNeeded())
        {
            pPortPage->AddPage (lpfnAddPage, lParam);
        }
    }

    //  Only use the event page if there are events...



    if ((STIPAGE_EVENTS & pDevInfo->dwPageMask) && regEvents.SubKeyCount ())
    {
        pEventPage = new CEventMonitor (pDevInfo);
        if (pEventPage)
        {
            pEventPage->AddPage (lpfnAddPage, lParam);
        }

    }


    if ((STIPAGE_EXTEND & pDevInfo->dwPageMask) && pDevInfo->psdi->pszPropProvider)
    {
        HMODULE hmExtension;

        CDelimitedString dsInterface (CSimpleStringConvert::NaturalString (CSimpleStringWide(pDevInfo->psdi->pszPropProvider)),
                                      TEXT(","));
        if (dsInterface.Size() < 2)
        {
            dsInterface.Append (CSimpleString(TEXT("EnumStiPropPages")));

        }
        hmExtension = LoadLibrary (dsInterface[0]); // will stay loaded until process exit
        if (hmExtension)
        {
            typedef BOOL    (WINAPI *ADDER)(PSTI_DEVICE_INFORMATION psdi, FARPROC fp, LPARAM lp);

            ADDER   adder = reinterpret_cast<ADDER>( GetProcAddress(hmExtension, CSimpleStringConvert::AnsiString(dsInterface[1])));

            if  (!adder || !(*adder)(pDevInfo->psdi, reinterpret_cast<FARPROC> (lpfnAddPage), lParam))
            {
                FreeLibrary(hmExtension);
                hmExtension = NULL;
            }
        }
    }


    // Add the ICM page
    if (STIPAGE_ICM & pDevInfo->dwPageMask)
    {
        AddICMPage (lpfnAddPage, lParam);
    }



exit_gracefully:
    DoRelease (pGeneralPage);
    DoRelease (pPortPage);
    DoRelease (pEventPage);
    TraceLeaveResult (hr);
}


CONST GUID CLSID_SCANNERUI = {0x176d6597, 0x26d3, 0x11d1, 0xb3, 0x50, 0x08,
           0x00, 0x36, 0xa7, 0x5b, 0x03};

/**************************************

CPropSheetExt::AddICMPage

Add the ICM page for this device

***************************************/


HRESULT
CPropSheetExt::AddICMPage (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam)
{
    HRESULT hr = S_OK;
    CComQIPtr<IShellExtInit, &IID_IShellExtInit> pInit;
    CComPtr<IShellPropSheetExt> pExt ;
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::AddICMPage");

    hr = CoCreateInstance (CLSID_SCANNERUI,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellPropSheetExt,
                            reinterpret_cast<LPVOID*>(&pExt)
                           );
    FailGracefully (hr, "No ICM handler registered");
    pInit = pExt;
    if (!pInit)
    {
        ExitGracefully (hr, E_FAIL, "");
    }
    hr = pInit->Initialize (NULL, m_pdo, NULL);
    FailGracefully (hr, "Initialize failed for ICM sheet");
    hr = pExt->AddPages (lpfnAddPage, lParam);



exit_gracefully:
    TraceLeaveResult (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\progcb.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       progcg.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        6/4/98
 *
 *  DESCRIPTION: Progress callback class definitions
 *
 *****************************************************************************/

#ifndef __progcb_h
#define __progcb_h



class CWiaDataCallback : public IWiaDataCallback, CUnknown
{
    private:
        CComPtr<IWiaProgressDialog> m_pWiaProgressDialog;
        BOOL          m_bShowBytes;
        LONG          m_lLastStatus;
        CSimpleString m_strImageName;
        LONG          m_cbImage;
        ~CWiaDataCallback();

    public:
        CWiaDataCallback( LPCTSTR pImageName, LONG cbImage, HWND hwndOwner );


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IWiaDataCallback
        STDMETHOD(BandedDataCallback) (THIS_
                                       LONG lMessage,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbData);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\propset.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propset.cpp
 *
 *  VERSION:     1
 *
 *
 *  DATE:        06/15/1999
 *
 *  DESCRIPTION: This code implements the IPropertySetStorage interface
 *               for the WIA shell extension.
 *
 *****************************************************************************/
#include "precomp.hxx"
#pragma hdrstop

const GUID FMTID_ImageAcquisitionItemProperties = {0x38276c8a,0xdcad,0x49e8,{0x85, 0xe2, 0xb7, 0x38, 0x92, 0xff, 0xfc, 0x84}};

const GUID *SUPPORTED_FMTS[] =
{
    &FMTID_ImageAcquisitionItemProperties,
};

/******************************************************************************

CPropSet constructor/destructor

Init or destroy private data

******************************************************************************/

CPropSet::CPropSet (LPITEMIDLIST pidl)
{
    m_pidl = ILClone (pidl);
}

CPropSet::~CPropSet ()
{
    DoILFree (m_pidl);
}



/******************************************************************************

CPropSet::QueryInterface



******************************************************************************/

STDMETHODIMP
CPropSet::QueryInterface (REFIID riid, LPVOID *pObj)
{
    INTERFACES iFace[] =
    {
        &IID_IPropertySetStorage, (IPropertySetStorage *)(this),
    };

    return HandleQueryInterface (riid, pObj, iFace, ARRAYSIZE(iFace));
}

#undef CLASS_NAME
#define CLASS_NAME CPropSet
#include "unknown.inc"

/******************************************************************************

CPropSet::Create

Create the requested IPropertyStorage sub-object. Not supported; our properties are read-only

******************************************************************************/

STDMETHODIMP
CPropSet::Create (REFFMTID rfmtid,
                  const CLSID *pclsid,
                  DWORD dwFlags,
                  DWORD dwMode,
                  IPropertyStorage **ppstg)
{
    TraceEnter (TRACE_PROPS, "CPropSet::Create");
    TraceLeaveResult (E_UNEXPECTED);
}

/******************************************************************************

CPropSet::Open

Return the requested IPropertyStorage


******************************************************************************/
#define VALID_MODES STGM_DIRECT | STGM_READ | STGM_WRITE | STGM_READWRITE | STGM_SHARE_DENY_NONE

STDMETHODIMP
CPropSet::Open (REFFMTID rfmtid,
                DWORD dwMode,
                IPropertyStorage **ppStg)
{
    HRESULT hr = STG_E_FILENOTFOUND;
    TraceEnter (TRACE_PROPS, "CPropSet::Open");
    if (IsEqualGUID (rfmtid, FMTID_ImageAcquisitionItemProperties))
    {
        if ((!VALID_MODES) & dwMode)
        {
            hr = STG_E_INVALIDFUNCTION;
        }
        else
        {
            CComPtr<IWiaItem> pItem;
            IMGetItemFromIDL (m_pidl, &pItem);
            hr = pItem->QueryInterface (IID_IPropertyStorage,
                                   reinterpret_cast<LPVOID*>(ppStg));
        }
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

CPropSet::Delete

Delete the specified property set. Not supported.

******************************************************************************/

STDMETHODIMP
CPropSet::Delete (REFFMTID rfmtid)
{
    return STG_E_ACCESSDENIED;
}


/******************************************************************************

CPropSet::Enum

Return an enumerator of our property sets

******************************************************************************/

STDMETHODIMP
CPropSet::Enum (IEnumSTATPROPSETSTG **ppEnum)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPS, "CPropSet::Enum");
    *ppEnum = new CPropStgEnum (m_pidl);
    if (!*ppEnum)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
    }
    TraceLeaveResult (hr);
}


/******************************************************************************

CPropStgEnum constructor



******************************************************************************/

CPropStgEnum::CPropStgEnum (LPITEMIDLIST pidl, ULONG idx) : m_cur(idx)
{
    ZeroMemory (&m_stat, sizeof(m_stat));
    m_pidl = ILClone (pidl);
}


/******************************************************************************

CPropStgEnum::QueryInterface



******************************************************************************/

STDMETHODIMP
CPropStgEnum::QueryInterface (REFIID riid, LPVOID* pObj)
{
    INTERFACES iFace[] = {&IID_IEnumSTATPROPSETSTG, (IEnumSTATPROPSETSTG *)this,};

    return HandleQueryInterface (riid, pObj, iFace, ARRAYSIZE(iFace));
}

#undef CLASS_NAME
#define CLASS_NAME CPropStgEnum
#include "unknown.inc"


/******************************************************************************

CPropStgEnum::Next

Return the next STATPROPSETSTG struct in our list

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Next (ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG i=0;
    CComPtr<IWiaItem> pItem;
    CComQIPtr<IPropertyStorage, &IID_IPropertyStorage> pps;

    TraceEnter (TRACE_PROPS, "CPropStgEnum::Next");
    if (!celt || !rgelt || (celt > 1 && !pceltFetched))
    {
        TraceLeaveResult (E_INVALIDARG);
    }
    if (!m_cur)
    {
        // init our STATPROPSETSTG struct
        if (SUCCEEDED(IMGetItemFromIDL(m_pidl, &pItem)))
        {
            pps = pItem;
            pps->Stat(&m_stat);
        }
    }
    // We use the same STATPROPSETSTG given us by WIA but replace the FMTID

    if (celt && m_cur < ARRAYSIZE(SUPPORTED_FMTS))
    {
        for (i = 1;i<=celt && m_cur < ARRAYSIZE(SUPPORTED_FMTS);i++,rgelt++,m_cur++)
        {
            *rgelt = m_stat;
            (*rgelt).fmtid = *(SUPPORTED_FMTS[m_cur]);
        }
    }
    if (i<celt)
    {
        hr = S_FALSE;
    }
    if (pceltFetched)
    {
        *pceltFetched = i;
    }

    TraceLeaveResult (hr);
}

/******************************************************************************

CPropStgEnum::Skip

Skips items in the enumeration

******************************************************************************/
STDMETHODIMP
CPropStgEnum::Skip (ULONG celt)
{
    HRESULT hr = S_OK;
    ULONG maxSkip = ARRAYSIZE(SUPPORTED_FMTS) - m_cur;
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Skip");
    m_cur = min (ARRAYSIZE(SUPPORTED_FMTS), m_cur+celt);
    if (maxSkip < celt)
    {
        hr = S_FALSE;
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

CPropStgEnum::Reset

Reset the enumeration index to 0

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Reset ()
{
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Reset");
    m_cur = 0;
    TraceLeaveResult (S_OK);
}


/******************************************************************************

CPropStgEnum::Clone

Copy the enumeration object

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Clone (IEnumSTATPROPSETSTG **ppEnum)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Clone");
    *ppEnum = new CPropStgEnum (m_pidl, m_cur);
    if (!*ppEnum)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceLeaveResult (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\propui.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propui.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/1/99
 *
 *  DESCRIPTION: CWiaPropUI Definition
 *
 *****************************************************************************/

#ifndef _propui_h_
#define _propui_h_

#define STIPAGE_NONE            0x00000000
#define STIPAGE_ICM             0x00000001
#define STIPAGE_EVENTS          0x00000002
#define STIPAGE_PORTS           0x00000004
#define STIPAGE_GENERAL         0x00000008
#define STIPAGE_EXTEND          0x00000010
#define STIPAGE_DEBUG           0x80000000
#define STIPAGE_ALL             0xFFFFFFFF


struct PROPTHREADDATA
{
    CSimpleString strName;
    HKEY *aKeys;
    UINT cKeys;
    CSimpleStringWide strDeviceId;
    CSimpleStringWide strItemName;
};


const TCHAR c_szPropkey[] = TEXT("CLSID\\%s");
const TCHAR c_szParentClass[] = TEXT("PropUISheetParent");
const TCHAR c_szParentName[] = TEXT("PropUISheetParent");
const TCHAR c_szScannerKey[] = TEXT("CLSID\\%ls\\Scanner");
const TCHAR c_szCameraKey[] = TEXT("CLSID\\%ls\\Camera");
const TCHAR c_szStiPropKey[] = TEXT("CLSID\\%ls\\STIDevices");
const TCHAR c_szPropSheetHandler[] = TEXT("shellex\\PropertySheetHandlers");
const TCHAR c_szContextMenuHandler[] = TEXT("shellext\\ContextMenuHandlers");
const TCHAR c_szConnectSettings[] = TEXT("OnConnect\\%ls");

// Implement COM interface

class CPropSheetExt : public IShellPropSheetExt, public IShellExtInit, public CUnknown
{
public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppvObj) ;
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();


    // IShellExtInit
    STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj,HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam);
    STDMETHODIMP ReplacePage (UINT uPageID,LPFNADDPROPSHEETPAGE lpfnReplacePage,LPARAM lParam) {return E_NOTIMPL;};
    CPropSheetExt ();
private:
    HRESULT  AddSTIPages (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam, MySTIInfo *pDevInfo);
    HRESULT  AddICMPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam);
    HRESULT  AddDevicePages (IWiaItem *pDevice, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam, DWORD dwType);
    HRESULT  AddPagesForIDL (LPITEMIDLIST pidl, bool bGeneralPageOnly, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam);
    ~CPropSheetExt ();

    CComPtr<IDataObject> m_pdo;
};

class CWiaPropUI: public IWiaPropUI, public CUnknown
{
public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppvObj) ;
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // IWiaPropUI methods

    STDMETHODIMP ShowItemProperties(IN HWND hParent,LPCWSTR szDeviceId, IN LPCWSTR szItemName, ULONG uFlags);
    STDMETHODIMP GetItemPropertyPages (IWiaItem *pItem,
                                       IN OUT LPPROPSHEETHEADER ppsh);

    CWiaPropUI ();

private:

    ~CWiaPropUI();

    // Helper functions
    VOID     InitMembers (HWND hParent,
                          LPCWSTR szDeviceId,
                          LPCWSTR szItemName,
                          ULONG  uFlags) ;

    HRESULT  OnShowItem ();
    HRESULT  LaunchSheet (HKEY *aKeys,
                          UINT cKeys);

    DWORD                   m_dwFlags;
    CComPtr<IWiaItem>       m_pDevice;
    CComPtr<IWiaItem>       m_pItem;
    HWND                    m_hParent;
    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strTitle;
    CComPtr<IDataObject>    m_pdo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\progcb.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2002
 *
 *  TITLE:       proccb.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        6/4/98
 *
 *  DESCRIPTION: Implements code to have IBandedTransfer work
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop




/*****************************************************************************

   CWiaDataCallback::CWiaDataCallback,::~CWiaDataCallback

   Constructor / Destructor for class

 *****************************************************************************/

CWiaDataCallback::CWiaDataCallback( LPCTSTR pImageName, LONG cbImage, HWND hwndOwner )
{



    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::CWiaDataCallback()" );

    //
    // Save incoming params...
    //
    // m_strImageName is not currently referenced, let's leave it here for
    // debugging purposes
    if (pImageName && *pImageName)
    {
        m_strImageName = CSimpleString(pImageName);
    }    

    m_cbImage     = cbImage;
    m_lLastStatus = 0;
    m_bShowBytes  = FALSE;

    Trace(TEXT("Creating the progress dialog "));

    if (SUCCEEDED(CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog )) && m_pWiaProgressDialog)
    {
        if (!SUCCEEDED(m_pWiaProgressDialog->Create( hwndOwner, 0 )))
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        if (m_pWiaProgressDialog)
        {
            //
            // Get the name of the image
            //
            CSimpleString strImageName(pImageName);

            //
            // Set the text in the progress dialog and show it
            //
            m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString().Format( IDS_RETREIVING, GLOBAL_HINSTANCE, strImageName.String())));
            m_pWiaProgressDialog->SetMessage( L"" );
            m_pWiaProgressDialog->Show();
        }
    }


    TraceLeave();

}


CWiaDataCallback::~CWiaDataCallback()
{

    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::~CWiaDataCallback()" );

    //
    // Destroy the progress window and release the interface
    //
    if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }

    TraceLeave();
}



/*****************************************************************************

   CWiaDataCallback::AddRef,Release

   IUnknown impl

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CWiaDataCallback
#include "unknown.inc"


/*****************************************************************************

   CWiaDataCallback::QI Wrapper

   Setup code & wrapper for common QI code

 *****************************************************************************/

STDMETHODIMP CWiaDataCallback::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IWiaDataCallback, (IWiaDataCallback *)this
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*****************************************************************************

   CWiaDataCallback::BandedDataCallback

   Actual method that gets called to give status

 *****************************************************************************/

STDMETHODIMP
CWiaDataCallback::BandedDataCallback(LONG lMessage,
                                     LONG lStatus,
                                     LONG lPercentComplete,
                                     LONG lOffset,
                                     LONG lLength,
                                     LONG lReserved,
                                     LONG lResLength,
                                     BYTE *pbData)
{

    HRESULT hr = S_OK;
    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::BandedDataCallback" );

    BOOL bCancelled = FALSE;
    if (m_pWiaProgressDialog && SUCCEEDED(m_pWiaProgressDialog->Cancelled(&bCancelled)) && bCancelled)
    {
        hr = S_FALSE;
    }
    //
    // Check to make sure we being called for status update...
    //

    else if (lMessage == IT_MSG_STATUS)
    {
        //
        // Make sure the dlg is created...
        //

        if (m_pWiaProgressDialog)
        {
            //
            // Get the right status string for this status event
            //

            if (m_lLastStatus != lStatus)
            {
                CSimpleString strStatusText;

                switch (lStatus)
                {
                default:
                case IT_STATUS_TRANSFER_FROM_DEVICE:
                    strStatusText = CSimpleString(IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = TRUE;
                    break;

                case IT_STATUS_PROCESSING_DATA:
                    strStatusText = CSimpleString(IDS_PROCESSING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = FALSE;
                    break;

                case IT_STATUS_TRANSFER_TO_CLIENT:
                    strStatusText = CSimpleString (IDS_TRANSFERRING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = FALSE;
                    break;
                }


                if (strStatusText && m_pWiaProgressDialog)
                {
                    m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(strStatusText) );
                }
                m_lLastStatus = lStatus;
            }

            //
            // Update the gas gauge...
            //
            m_pWiaProgressDialog->SetPercentComplete(lPercentComplete);
        }

    }
    if (100 == lPercentComplete && m_pWiaProgressDialog)
    {
        //
        // Close the status window and release the interface
        //
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;

    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\propset.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propset.h
 *
 *  VERSION:     1
 *
 *
 *  DATE:        06/15/1999
 *
 *  DESCRIPTION: This code implements the IPropertySetStorage interface
 *               for the WIA shell extension.
 *
 *****************************************************************************/

class CPropSet : public CUnknown, public IPropertySetStorage
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID *pObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // IPropertySetStorage
    STDMETHODIMP Create( REFFMTID rfmtid,
        const CLSID  *pclsid,
        DWORD grfFlags,
        DWORD grfMode,
        IPropertyStorage **ppprstg);

    STDMETHODIMP Open( REFFMTID rfmtid,
        DWORD grfMode,
        IPropertyStorage **ppprstg);

    STDMETHODIMP Delete(REFFMTID rfmtid);

    STDMETHODIMP Enum( IEnumSTATPROPSETSTG **ppenum);

    CPropSet (LPITEMIDLIST pidl);

private:
    LPITEMIDLIST m_pidl;
    ~CPropSet ();
};

class CPropStgEnum : public CUnknown, public IEnumSTATPROPSETSTG
{
public:
    // IEnumSTATPROPSETSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void) ;
    STDMETHODIMP Clone(IEnumSTATPROPSETSTG **ppenum);

    //IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(THIS_ REFIID, OUT PVOID *);

    CPropStgEnum (LPITEMIDLIST pidl, ULONG idx=0);
private:
    ~CPropStgEnum () {DoILFree(m_pidl);};
    ULONG m_cur;
    STATPROPSETSTG m_stat;
    LPITEMIDLIST m_pidl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\prpages.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2002
 *
 *  TITLE:       prpages.cpp
 *
 *
 *  DESCRIPTION: WIA Property pages classes implementation
 *
 *****************************************************************************/
#include "precomp.hxx"
#include "uiexthlp.h"
#include "propstrm.h"
#include "psutil.h"
#include "winsvc.h"
#pragma hdrstop


void DeleteHandler(WIA_EVENT_HANDLER *peh)
{
    if (peh)
    {
        SysFreeString(peh->bstrCommandline);
        SysFreeString(peh->bstrDescription);
        SysFreeString(peh->bstrIcon);
        SysFreeString(peh->bstrName);
        delete peh;
    }
}

/*****************************************************************************

    CPropertyPage::PropPageCallback

    Called by the system at various points of the propsheetpage's lifetime.
    We use this function to manage refcounts on the parent object.

*****************************************************************************/

UINT
CPropertyPage::PropPageCallback (HWND hwnd, UINT uMsg, PROPSHEETPAGE *psp)
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::PropPageCallback");
    CPropertyPage *pcpp = reinterpret_cast<CPropertyPage *>(psp->lParam);
    TraceAssert (pcpp);
    switch (uMsg)
    {
        case PSPCB_ADDREF:
            pcpp->AddRef ();
            break;

        case PSPCB_RELEASE:
            pcpp->Release();
            break;

        case PSPCB_CREATE:
        default:
            break;

    }
    TraceLeaveValue (1);
}

/*****************************************************************************

   CPropertyPage::DlgProc

   Pass messages to derived class virtual functions as appropriate.

 *****************************************************************************/


INT_PTR CALLBACK
CPropertyPage::DlgProc(HWND hwnd,
                       UINT uMsg,
                       WPARAM wp,
                       LPARAM lp)
{

    TraceEnter (TRACE_CORE, "CPropertyPage::DlgProc");
    Trace(TEXT("Msg: %x, wp:%x, lp:%x"), uMsg, wp, lp);
    CPropertyPage *pcpp = reinterpret_cast<CPropertyPage*>(GetWindowLongPtr(hwnd, DWLP_USER));
    INT_PTR iRet = TRUE;
    switch  (uMsg) {

        case    WM_INITDIALOG:
            pcpp = reinterpret_cast<CPropertyPage *>(reinterpret_cast<PROPSHEETPAGE *>( lp) -> lParam);

            SetWindowLongPtr(hwnd, DWLP_USER,reinterpret_cast<LONG_PTR>(pcpp));

            pcpp -> m_hwnd = hwnd;

            // We are in init mode
            pcpp->m_bInit = TRUE;
            iRet = pcpp -> OnInit();
            pcpp->SaveCurrentState ();
            // Init mode has completed
            pcpp->m_bInit = FALSE;
            break;

        case WM_HELP:      // F1

            pcpp->OnHelp (wp, lp);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            pcpp->OnContextMenu (wp, lp);

            return TRUE;

        case  WM_COMMAND:
           iRet =  pcpp -> OnCommand(HIWORD(wp), LOWORD(wp), (HWND) lp);
           // ignore messages during initialization
           if (!(pcpp->m_bInit) && pcpp->StateChanged ())
           {
               pcpp->EnableApply ();

           }
           break;

        case  WM_NOTIFY:
        {

            LRESULT lResult = PSNRET_NOERROR;
            LPNMHDR lpnmh = reinterpret_cast<LPNMHDR>( lp);

            if (!pcpp->OnNotify(lpnmh, &lResult))
            {
                if  (lpnmh -> code == PSN_SETACTIVE)
                    pcpp -> m_hwndSheet = lpnmh -> hwndFrom;

                LPPSHNOTIFY pn = reinterpret_cast<LPPSHNOTIFY>(lp);
                Trace (TEXT("CPropertyPage::DlgProc :WM_NOTIFY. code=%d, lParam=%d"), pn->hdr.code, pn->lParam);

                switch (pn->hdr.code)
                {
                    case PSN_APPLY:
                        if (pcpp->StateChanged())
                        {
                            pcpp->SaveCurrentState ();
                            lResult = pcpp->OnApplyChanges (static_cast<BOOL>(pn->lParam));
                        }
                        break;

                    case PSN_SETACTIVE:
                        lResult = pcpp->OnSetActive ();

                        break;

                    case PSN_QUERYCANCEL:
                        lResult = pcpp->OnQueryCancel();
                        break;

                    case PSN_KILLACTIVE:
                        lResult = pcpp->OnKillActive ();
                        break;

                    case PSN_RESET:
                        pcpp->OnReset (!(pn->lParam));
                        break;

                    default:
                        lResult = PSNRET_NOERROR;
                        iRet = FALSE;
                        break;
                }
            }
            SetWindowLongPtr (hwnd, DWLP_MSGRESULT, lResult);

        }
        break;

        case    WM_MEASUREITEM: {
            #define MINIY       16
            #define MINIX       16


            // Code lifted from setupx
            // WARNING...this message occurs before WM_INITDIALOG and is not virtualized...
            // ...it could be but don't try to use pcpp.

            LPMEASUREITEMSTRUCT lpMi;
            SIZE                size;
            HDC                 hDC;

            hDC  = GetDC(hwnd);
            if (hDC)
            {

                lpMi = reinterpret_cast<LPMEASUREITEMSTRUCT>(lp);

                SelectFont(hDC, GetWindowFont(GetParent(hwnd)));
                GetTextExtentPoint32(hDC, TEXT("X"), 1, &size);

                // size is the max of character size of shell icon size plus the border
                lpMi->itemHeight = max(size.cy, MINIY) + GetSystemMetrics(SM_CYBORDER) * 2;

                ReleaseDC(hwnd, hDC);
            }
        }
        break;

        case WM_DRAWITEM:
            pcpp -> OnDrawItem(reinterpret_cast<LPDRAWITEMSTRUCT>(lp));
            break;

        case WM_DESTROY:
        {
            // Delete the icon resource we loaded to put into the page...

            HICON hIcon;

            hIcon = reinterpret_cast<HICON>(SendDlgItemMessage (hwnd, IDC_ITEMICON, STM_SETICON, 0, 0));

            if (hIcon)
            {
                DestroyIcon(hIcon);
            }
            pcpp->OnDestroy();
        }
        break;

        default:

            if (pcpp)
            {
                iRet = pcpp->OnRandomMsg (uMsg, wp, lp);
                // ignore messages during initialization
                if (!(pcpp->m_bInit) && pcpp->StateChanged ())
                {
                    pcpp->EnableApply ();
                }
            }
            else
            {
                iRet = FALSE;
            }
            break;
    }
    TraceLeave ();
    return iRet;

}



/*****************************************************************************

   CPropertyPage constructor / destructor

   Init private data, etc.

 *****************************************************************************/

CPropertyPage::CPropertyPage(unsigned uResource,
                             MySTIInfo *pDevInfo,
                             IWiaItem *pItem,
                             const DWORD *pHelpIDs)
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::CPropertyPage");

    CComPtr<IWiaItem> pDevice;

    TraceAssert (pDevInfo || pItem);
    m_pdwHelpIDs = pHelpIDs;
    m_bInit = FALSE;
    m_pDevInfo = pDevInfo;
    if (pDevInfo)
    {
        m_psdi = pDevInfo->psdi;
        pDevInfo->AddRef();
    }
    else
    {
        m_psdi = NULL;
    }

    m_psp.hInstance = GLOBAL_HINSTANCE;
    m_psp.dwSize = sizeof(m_psp);
    m_psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    m_psp.pszTemplate = MAKEINTRESOURCE(uResource);

    m_psp.pfnDlgProc = DlgProc;
    m_psp.lParam = (LPARAM) this;
    m_psp.pfnCallback = PropPageCallback;

    m_hwnd = m_hwndSheet = NULL;
    m_hpsp = NULL;
    if (pItem)
    {
        m_pItem = pItem;
        CComPtr<IWiaItem> pRoot;
        pItem->GetRootItem (&pRoot);
        PropStorageHelpers::GetProperty (pRoot, WIA_DIP_DEV_ID,   m_strDeviceId);
        PropStorageHelpers::GetProperty (pRoot, WIA_DIP_UI_CLSID, m_strUIClassId);
    }

    m_cRef = 1;
    TraceLeave ();
}

CPropertyPage::~CPropertyPage ()
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::~CPropertyPage");
    LONG cRef;

    if (m_pDevInfo)
    {
        m_pDevInfo->Release();
    }
    TraceLeave ();
}

/*****************************************************************************

   CPropertyPage::AddRef

   <Notes>

 *****************************************************************************/

LONG
CPropertyPage::AddRef ()
{
    return InterlockedIncrement (&m_cRef);
}


/*****************************************************************************

   CPropertyPage::Release

   <Notes>

 *****************************************************************************/

LONG
CPropertyPage::Release ()
{
    LONG lRet;
    lRet = InterlockedDecrement (&m_cRef);
    if (!lRet)
    {
        delete this;
    }
    return lRet;

}

HRESULT
CPropertyPage::AddPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, bool bUseName)
{
    CSimpleStringWide strValue;
    // override the tab label with the name of the item if requested
    if (bUseName)
    {

        if (m_pDevInfo)
        {
            m_psp.dwFlags |= PSP_USETITLE;
            m_psp.pszTitle = m_pDevInfo->psdi->pszLocalName;
        }
        else
        {
            LONG lType;
            PROPID pid;

            m_pItem->GetItemType(&lType);
            if (lType & WiaItemTypeRoot)
            {
                pid = WIA_DIP_DEV_NAME;
            }
            else
            {
                pid = WIA_IPA_ITEM_NAME;
            }
            if (PropStorageHelpers::GetProperty(m_pItem, pid, strValue ))
            {
                m_psp.dwFlags |= PSP_USETITLE;
                m_psp.pszTitle = strValue.String();
            }
        }
    }
    if   (!m_hpsp)
        m_hpsp = CreatePropertySheetPage(&m_psp);

    if  (!m_hpsp)
        return  E_FAIL;

    return (*lpfnAddPage)(m_hpsp, lParam) ? S_OK: E_FAIL;

}
void
CPropertyPage::EnableApply ()
{
    PropSheet_Changed (m_hwndSheet, m_hwnd);
}


//
// Define a struct associating a dialog control with a property
//
struct CONTROLPROP
{
    DWORD dwPropid;
    SHORT resId;
};

typedef CONTROLPROP *PCONTROLPROP;

//
// Define a function for updating the page in ways the CONTROLPROP array can't
//
typedef VOID (CALLBACK *UPDATEPROC)(HWND, BOOL, IWiaPropertyStorage*);
//
// Now define a struct containing the CONTROLPROP array
// and UPDATEPROC for a page
//
struct PAGEDATA
{
    UPDATEPROC pfnUpdate;
    PCONTROLPROP pProps;
    INT   nProps;
};

VOID CALLBACK CameraUpdateProc (      HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK CameraItemUpdateProc (  HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK CameraFolderUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK ScannerUpdateProc (     HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);


static CONTROLPROP CameraProps[] =
{
    {WIA_DIP_DEV_DESC,           IDC_DESCRIPTION},
    {WIA_DPC_BATTERY_STATUS,     IDC_BATTERY},
    {WIA_DIP_VEND_DESC,          IDC_MANUFACTURER},
    {WIA_DIP_PORT_NAME,          IDC_WIA_PORT_STATIC},

};


static CONTROLPROP CameraItemProps[] =
{
    {WIA_IPA_ITEM_NAME,          IDC_IMAGE_NAME},
    {WIA_IPA_ITEM_TIME,          IDC_IMAGE_TIME}
};

static CONTROLPROP CameraFolderProps[] =
{
{0,0}
};


static CONTROLPROP ScannerProps[] =
{
{WIA_DIP_DEV_DESC, IDC_DESCRIPTION},
{WIA_DIP_VEND_DESC, IDC_MANUFACTURER},
{WIA_DIP_PORT_NAME, IDC_WIA_PORT_STATIC},
};

static const PAGEDATA PropPages[] =
{
    {CameraUpdateProc,          CameraProps,        ARRAYSIZE(CameraProps)},
    {ScannerUpdateProc,         ScannerProps,       ARRAYSIZE(ScannerProps)},
    {CameraItemUpdateProc,      CameraItemProps,    ARRAYSIZE(CameraItemProps)},
    {CameraFolderUpdateProc,    CameraFolderProps,  ARRAYSIZE(CameraFolderProps)},
};

enum EPageIndex
{
    kCamera = 0,
    kScanner = 1,
    kCameraItem = 2,
    kCameraFolder = 3,
};



/*****************************************************************************

   GetPageData

   Returns PAGEDATA struct appropriate for the type of item or device

 *****************************************************************************/


const PAGEDATA *
GetPageData (IWiaItem *pWiaItemRoot, IWiaItem *pItem)
{
    LONG lItemType = WiaItemTypeImage;
    WORD wDeviceType;
    EPageIndex idx = kCamera;
    TraceEnter (TRACE_PROPUI, "GetPageData");
    if (pItem)
    {
        pItem->GetItemType (&lItemType);
    }

    GetDeviceTypeFromDevice (pWiaItemRoot, &wDeviceType);
    switch (wDeviceType)
    {
        case StiDeviceTypeScanner:
            TraceAssert (!pItem);
            idx = kScanner;
            break;
        case StiDeviceTypeStreamingVideo:
        case StiDeviceTypeDigitalCamera:
            if (!pItem)
            {
                idx = kCamera;
            }
            else if (lItemType & (WiaItemTypeImage | WiaItemTypeVideo | WiaItemTypeFile))
            {
                idx = kCameraItem;
            }
            else if (lItemType & WiaItemTypeFolder)
            {
                idx = kCameraFolder;
            }
            else
            {
                Trace (TEXT("Unknown item type in GetPageData"));
            }
            break;
        default:
            Trace (TEXT("Unknown device type in GetPageData"));
            break;
    }
    TraceLeave ();
    return &PropPages[idx];
}


/*****************************************************************************

   ConstructPortChoices
   Builds a list of ports this device can be on, if they can be changed.

 *****************************************************************************/

static LPCWSTR caPortSpeeds [] =
{L"9600",
 L"19200",
 L"38400",
 L"57600",
 L"115200",
 NULL,
};

VOID
ConstructPortChoices (HWND                 hwnd,
                      LPCWSTR              szPortSpeed,
                      IWiaPropertyStorage* pps)
{
    TraceEnter (TRACE_PROPUI, "ConstructPortChoices");
    #ifdef UNICODE
    Trace(TEXT("passed in szPortSpeed is %s"),(szPortSpeed && (*szPortSpeed)) ? szPortSpeed : TEXT("<NULL>"));
    #endif

    CComQIPtr<IWiaItem, &IID_IWiaItem> pItem(pps);
    CWiaCameraPage * pWiaCamPage = (CWiaCameraPage *)GetWindowLongPtr( hwnd, DWLP_USER );


    if (!pps || !pWiaCamPage)
    {
        Trace(TEXT("bad params -- pProps | pps is NULL"));
        goto exit_gracefully;
    }

    //
    // Get current port name
    //
    pWiaCamPage->m_strPort.GetWindowText(GetDlgItem(hwnd, IDC_WIA_PORT_STATIC));

    Trace(TEXT("pWiaCamPage->m_strPort is '%s'"),pWiaCamPage->m_strPort.String());
    pWiaCamPage->m_strPortSpeed = CSimpleString(szPortSpeed);
    //
    // Get list of all possible ports
    //
    WCHAR szDeviceId[ MAX_PATH ];
    *szDeviceId = 0;

    if (pItem)
    {
        PWIA_PORTLIST pWiaPorts = NULL;

        GetDeviceIdFromDevice( pItem, szDeviceId );
        if (pWiaCamPage->m_pfnWiaCreatePortList && pWiaCamPage->m_pfnWiaDestroyPortList)
        {
            pWiaPorts = pWiaCamPage->m_pfnWiaCreatePortList( szDeviceId );

            if (pWiaPorts)
            {
                //
                // Clear out any old port lists
                //

                SendDlgItemMessage( hwnd, IDC_WIA_PORT_LIST, CB_RESETCONTENT, 0, 0 );

                //
                // Add each possible port to the combobox
                //

                for (INT i=0; i < (INT)(pWiaPorts->dwNumberOfPorts); i++)
                {
                    #ifdef UNICODE
                    SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_ADDSTRING, 0, (LPARAM)pWiaPorts->szPortName[i] );
                    #else
                    CHAR sz[ 64 ];

                    WideCharToMultiByte( CP_ACP, 0, pWiaPorts->szPortName[i], -1, sz, ARRAYSIZE(sz), NULL, NULL );
                    SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_ADDSTRING, 0, (LPARAM)sz );
                    #endif
                }

                //
                // Select the current port
                //

                if (CB_ERR != SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pWiaCamPage->m_strPort.String() ))
                {
                    ShowWindow(GetDlgItem(hwnd, IDC_WIA_PORT_LIST), SW_SHOW);
                    ShowWindow(GetDlgItem(hwnd, IDC_WIA_PORT_STATIC), SW_HIDE);
                }

                pWiaCamPage->m_pfnWiaDestroyPortList( pWiaPorts );

                ShowWindow(GetDlgItem(hwnd, IDC_BATTERY_LABEL), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_BATTERY), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_PORT_SPEED), SW_SHOW);
                ShowWindow(GetDlgItem(hwnd, IDC_PORT_SPEED_LABEL), SW_SHOW);

                //
                // Reset port speed list
                //

                SendDlgItemMessage( hwnd, IDC_PORT_SPEED, CB_RESETCONTENT, 0, 0 );

                //
                // Fill the list of port speeds
                //

                for (LPCWSTR *ppszPort=caPortSpeeds;*ppszPort;ppszPort++)
                {
                    SendDlgItemMessage(hwnd, IDC_PORT_SPEED, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(*ppszPort));
                }
                if (szPortSpeed && *szPortSpeed)
                {
                    Trace(TEXT("Selecting port speed of %s"),szPortSpeed);
                    SendDlgItemMessage(hwnd, IDC_PORT_SPEED, CB_SELECTSTRING, (WPARAM)-1, reinterpret_cast<LPARAM>(szPortSpeed));
                }
            }
        }
    }
exit_gracefully:
    TraceLeave();
}


/*****************************************************************************

   FillPropsFromStorage
   Given the array of property IDs and resources,
   fill in the data

 *****************************************************************************/

VOID
FillPropsFromStorage (HWND              hwnd,
                      PCONTROLPROP      pProps,
                      INT               nProps,
                      IWiaPropertyStorage* pps,
                      DWORD             dwFlags)
{

    PROPVARIANT *ppv;
    PROPSPEC    *pSpec;
    INT          i;
    WORD         wId;

    TraceEnter (TRACE_PROPUI, "FillPropsFromStorage");

    ppv   = new PROPVARIANT[nProps];
    pSpec = new PROPSPEC[nProps];

    if (!ppv || !pSpec)
    {
        Trace (TEXT("Out of memory in FillPropsFromStorage"));
        goto exit_gracefully;
    }
    ZeroMemory (ppv, sizeof(PROPSPEC)*nProps);
    // fill in the PROPSPEC array
    for (i=0;i<nProps;i++)
    {
        pSpec[i].ulKind = PRSPEC_PROPID;
        pSpec[i].propid = pProps[i].dwPropid;
    }
    // Query for the properties
    if (SUCCEEDED(pps->ReadMultiple (nProps, pSpec, ppv)))
    {
        // loop through the properties, filling in controls
        for (i=0;i<nProps;i++)
        {
            wId = pProps[i].resId;
            switch (ppv[i].vt)
            {
                case VT_LPWSTR:
                    #ifdef UNICODE
                    SetDlgItemText (hwnd,
                                    wId,
                                    ppv[i].pwszVal);
                    #else
                    {
                        CHAR sz[ MAX_PATH ];
                        WideCharToMultiByte (CP_ACP, 0, ppv[i].pwszVal,
                                             -1, sz, ARRAYSIZE(sz),
                                             NULL, NULL );
                        SetDlgItemText (hwnd, wId, sz);
                    }
                    #endif // UNICODE
                    break;
                case VT_BSTR:
                    #ifdef UNICODE
                    SetDlgItemText (hwnd,
                                    wId,
                                    ppv[i].bstrVal);
                    #else
                    {
                        CHAR sz[ MAX_PATH ];
                        WideCharToMultiByte (CP_ACP, 0, ppv[i].bstrVal,
                                             -1, sz, ARRAYSIZE(sz),
                                             NULL, NULL );
                        SetDlgItemText (hwnd, wId, sz);
                    }
                    #endif
                    break;

                case VT_I4:
                    SetDlgItemInt (hwnd,
                                   wId,
                                   static_cast<UINT>(ppv[i].lVal),
                                   TRUE);
                    break;

                case VT_UI4:
                    SetDlgItemInt (hwnd,
                                   wId,
                                   ppv[i].ulVal,
                                   TRUE);
                    break;
                case VT_FILETIME:
                default:
                    Trace(TEXT("Unexpected property type for %d in FillPropsFromStorage %x"), pSpec[i].propid, ppv[i].vt);
                    break;
            }
            if (dwFlags & PROPUI_READONLY)
            {
                EnableWindow (GetDlgItem (hwnd,wId),
                              FALSE);
            }
        }
    }
    else
    {
        Trace (TEXT("ReadMultiple failed in FillPropsFromStorage"));
    }
exit_gracefully:
    if (pSpec)
    {
        delete [] pSpec;
    }
    FreePropVariantArray (nProps, ppv);
    if (ppv)
    {
        delete [] ppv;
    }
    TraceLeave();
}


/*****************************************************************************

   FillItemGeneralProps

   Given an IWiaItem, fill in the General prop page for it

 *****************************************************************************/

VOID
FillItemGeneralProps (HWND      hwnd,
                      IWiaItem* pWiaItemRoot,
                      IWiaItem* pItem,
                      DWORD     dwFlags)
{
    const PAGEDATA  *pPage;

    TraceEnter (TRACE_PROPUI, "FillItemGeneralProps");

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    pPage = GetPageData (pWiaItemRoot,pItem);
    if (pps && pPage)
    {
        FillPropsFromStorage (hwnd,
                              pPage->pProps,
                              pPage->nProps,
                              pps,
                              dwFlags);

        // invoke the update proc
        (pPage->pfnUpdate)(hwnd, TRUE, pps);
    }

    TraceLeave();
}


/*****************************************************************************

   FillCameraGeneralProps

   Fill in the General prop page for the camera device

 *****************************************************************************/

VOID
FillDeviceGeneralProps (HWND        hwnd,
                        IWiaItem*   pWiaItemRoot,
                        DWORD       dwFlags)
{
    const PAGEDATA   *pPage;

    TraceEnter (TRACE_PROPUI, "FillDeviceGeneralProps");

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pWiaItemRoot);
    pPage = GetPageData (pWiaItemRoot, NULL);

    if (pps && pPage)
    {
        FillPropsFromStorage (hwnd,
                              pPage->pProps,
                              pPage->nProps,
                              pps,
                              dwFlags);

        // invoke the update proc
        (pPage->pfnUpdate)(hwnd, TRUE, pps);
    }

    TraceLeave();
}

// define a  struct to match WIA flash modes with friendly strings
// relies on FLASHMODE_* being 1-based enumeration
struct FMODE
{
    INT iMode;
    UINT idString;
} cFlashModes [] =
{
    FLASHMODE_AUTO, IDS_FLASHMODE_AUTO,
    FLASHMODE_OFF, IDS_FLASHMODE_OFF,
    FLASHMODE_FILL, IDS_FLASHMODE_FILL,
    FLASHMODE_REDEYE_AUTO, IDS_FLASHMODE_REDEYE_AUTO,
    FLASHMODE_REDEYE_FILL, IDS_FLASHMODE_REDEYE_FILL,
    FLASHMODE_EXTERNALSYNC, IDS_FLASHMODE_EXTERNALSYNC,
    0, IDS_FLASHMODE_DEVICE,
};

/*****************************************************************************

    FillFlashList

    Given the valid values for the flash property, fill in the listbox
    with friendly strings

*****************************************************************************/

VOID
FillFlashList (HWND hwnd, const PROPVARIANT &pvValues, INT iMode)
{
    TraceEnter (TRACE_PROPUI, "FillFlashList");
    INT iTemp;
    CSimpleString strMode;
    TCHAR szNum[10];
    LRESULT lPos;
    Trace(TEXT("Flash mode has %d values"), WIA_PROP_LIST_COUNT(&pvValues));
    ShowWindow(hwnd, SW_SHOW);
    for (size_t i=0;i<WIA_PROP_LIST_COUNT(&pvValues);i++)
    {
        iTemp = pvValues.caul.pElems[WIA_LIST_VALUES + i];
        if (iTemp >= ARRAYSIZE(cFlashModes)) // it's a custom mode
        {
            strMode.LoadString(IDS_FLASHMODE_DEVICE, GLOBAL_HINSTANCE);
            strMode.Concat (_itot(iTemp, szNum, 10));
        }
        else
        {
            strMode.LoadString(cFlashModes[iTemp-1].idString, GLOBAL_HINSTANCE);
        }
        // add the string to the list
        lPos = SendMessage (hwnd, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strMode.String()));
        if (lPos != CB_ERR)
        {
            // associate its mode with it
            SendMessage (hwnd, CB_SETITEMDATA, lPos, iTemp);
            if (iTemp == iMode)
            {
                // set the current selection
                SendMessage (hwnd, CB_SETCURSEL, lPos, 0);
            }
        }
    }
    TraceLeave ();
}
/*****************************************************************************

    UpdateFlashMode

    Updates the flash mode controls on the camera general page. If the device
    supports Write access to the property AND provides a set of valid values,
    we enable the list box and fill it in with friendly names of the flash modes.
    For modes whose values fall outside the set of standard WIA identifiers,
    we substitute "Device Mode #", where # starts at 1 .

*****************************************************************************/
VOID
UpdateFlashMode (HWND hwnd, INT iMode, ULONG ulFlags, const PROPVARIANT &pvValues)
{
    TraceEnter (TRACE_PROPUI, "UpdateFlashMode");

    // First get the current mode string
    FMODE *pMode;
    CSimpleString strMode;
    TCHAR szNum[MAX_PATH];
    for (pMode = cFlashModes;pMode->iMode && iMode != pMode->iMode;pMode++);//intentional
    strMode.LoadString (pMode->idString, GLOBAL_HINSTANCE);
    if (pMode->idString == IDS_FLASHMODE_DEVICE)
    {
        strMode.Concat (_itot(iMode, szNum, 10));
    }
    if (!(ulFlags & WIA_PROP_WRITE) || !(ulFlags & WIA_PROP_LIST))
    {
        strMode.SetWindowText(GetDlgItem (hwnd, IDC_FLASH_MODE_STATIC));
        ShowWindow (GetDlgItem (hwnd, IDC_FLASH_MODE_LIST), SW_HIDE);
    }
    else
    {
        ShowWindow (GetDlgItem(hwnd, IDC_FLASH_MODE_STATIC), SW_HIDE);
        FillFlashList (GetDlgItem(hwnd, IDC_FLASH_MODE_LIST), pvValues, iMode);
    }
    TraceLeave ();
}


VOID
UpdateTimeStatic(HWND hwnd, PROPVARIANT *ppv)
{
    TCHAR szTime[MAX_PATH] = TEXT("");
    TCHAR szDate[MAX_PATH] = TEXT("");

    TimeToStrings (reinterpret_cast<SYSTEMTIME*>(ppv->caub.pElems),
                   szTime, szDate);
    CSimpleString strText;
    strText.Format (TEXT("%s, %s"), szDate, szTime);
    strText.SetWindowText(GetDlgItem (hwnd, IDC_CURRENT_TIME));

}
/*****************************************************************************

   CameraUpdateProc

   Update controls in the camera General tab. Doesn't touch the picture size
   slider because that control needs data that is private to the CWiaCameraPage
   object.

 *****************************************************************************/

VOID CALLBACK
CameraUpdateProc (HWND              hwnd,
                  BOOL              bInit,
                  IWiaPropertyStorage* pps)
{

    TraceEnter (TRACE_PROPUI, "CameraUpdateProc");
    UINT    iConnect;

    CSimpleString   strTemp;

    // read more properties that require special formatting
    static PROPSPEC ps[] = {{PRSPEC_PROPID,WIA_DPC_PICTURES_TAKEN},
                            {PRSPEC_PROPID,WIA_DPC_PICTURES_REMAINING},
                            {PRSPEC_PROPID,WIA_DPC_FLASH_MODE},
                            {PRSPEC_PROPID,WIA_DPA_DEVICE_TIME},
                            {PRSPEC_PROPID,WIA_DPC_POWER_MODE},
                            {PRSPEC_PROPID,WIA_DIP_DEV_ID}}; // this is so we can get port choices


    PROPVARIANT pv[ARRAYSIZE(ps)] = {0};
    if (pps && SUCCEEDED(pps->ReadMultiple(ARRAYSIZE(ps), ps, pv)))
    {
        CSimpleString strFormat;
        PROPVARIANT pvValidValues[ARRAYSIZE(ps)] ={0};
        ULONG ulFlags[ARRAYSIZE(ps)];

        pps->GetPropertyAttributes(ARRAYSIZE(ps), ps, ulFlags, pvValidValues);
        // Pictures taken/remaining aren't supported by all cameras, so
        // make sure those propvariants are populated before
        // constructing the string
        if (pv[0].vt != VT_EMPTY) // num taken is supported
        {
            if (pv[1].vt != VT_EMPTY && pv[1].lVal >= 0) // num remaining is supported
            {
                strFormat.LoadString(IDS_PICTURE_COUNT, GLOBAL_HINSTANCE);
                strTemp.Format (strFormat, pv[0].lVal, pv[0].lVal + pv[1].lVal);
            }
            else
            {
                // just show number taken
                strTemp.Format (TEXT("%d"), pv[0].ulVal);
            }
            strTemp.SetWindowText (GetDlgItem(hwnd, IDC_TAKEN));
        }

        // Update the flash mode
        if (pv[2].vt != VT_EMPTY)
        {
            UpdateFlashMode (hwnd, pv[2].intVal, ulFlags[2], pvValidValues[2]);
        }

        // Show the device time if supported. Also, if the time property is R/W,
        // enable the button
        if (pv[3].vt != VT_EMPTY && pv[3].caub.cElems)
        {
            UpdateTimeStatic(hwnd, &pv[3]);
            ShowWindow (GetDlgItem(hwnd, IDC_SET_TIME), (ulFlags[3] & WIA_PROP_WRITE) ? SW_SHOW : SW_HIDE);
        }

        // Show the current power source ,if available
        if (pv[4].vt != VT_EMPTY)
        {
            strTemp.GetWindowText(GetDlgItem(hwnd, IDC_BATTERY));
            if (strTemp.String()[0] != TEXT('(')) // battery status is a number
            {
                CSimpleString strMode;
                strMode.LoadString(pv[4].vt == POWERMODE_BATTERY ? IDS_ON_BATTERY : IDS_PLUGGED_IN,
                                   GLOBAL_HINSTANCE);
                strTemp.Concat(strMode);
                strTemp.SetWindowText(GetDlgItem(hwnd, IDC_BATTERY));
            }
        }


        // if we got a device id, then look for com port settings
        if (pv[5].vt != VT_EMPTY)
        {
            // Get a property storage on the device node to check for com port/baudrate
            CComPtr<IWiaPropertyStorage> ppsDev;
            if (SUCCEEDED(GetDeviceFromDeviceId( pv[5].pwszVal, IID_IWiaPropertyStorage, reinterpret_cast<LPVOID *>(&ppsDev), FALSE )) && ppsDev)
            {
                static PROPSPEC psDev[] = {{PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
                                           {PRSPEC_PROPID, WIA_DIP_BAUDRATE}};

                PROPVARIANT pvDev[ARRAYSIZE(psDev)] = {0};

                // Read port & baudrate
                if (SUCCEEDED(ppsDev->ReadMultiple(ARRAYSIZE(psDev), psDev, pvDev)))
                {
                    if (pvDev[0].vt != VT_EMPTY)
                    {
                        if (pvDev[0].ulVal & STI_HW_CONFIG_SERIAL)
                        {
                            // purposely using pps, instead of ppsDev
                            ConstructPortChoices( hwnd, pvDev[1].pwszVal, pps );
                        }
                    }
                    FreePropVariantArray(ARRAYSIZE(pvDev), pvDev);
                }
            }
        }
        FreePropVariantArray(ARRAYSIZE(pvValidValues), pvValidValues);
    }
    FreePropVariantArray(ARRAYSIZE(pv), pv);
    TraceLeave ();
}

/*****************************************************************************

    GetItemSize

    Queries the item for its size when transferred via preferred format and media
    type

*****************************************************************************/

UINT GetItemSize(IWiaPropertyStorage *pps)
{
    CComQIPtr<IWiaItem, &IID_IWiaItem> pItem(pps);
    // Save the current property stream in case changing
    // the transfer format alters it badly.
    CAutoRestorePropertyStream arps(pItem);
    GUID guidFmt;
    LONG lVal = 0;
    //
    // Query the preferred format and tymed and set them as the current
    // values for the item, then query the size
    //
    PropStorageHelpers::GetProperty(pItem, WIA_IPA_PREFERRED_FORMAT, guidFmt);
    PropStorageHelpers::SetProperty(pItem, WIA_IPA_FORMAT,  guidFmt);
    PropStorageHelpers::GetProperty(pItem, WIA_IPA_ITEM_SIZE, lVal);
    return static_cast<UINT>(lVal);
}
/*****************************************************************************

   CameraItemUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
CameraItemUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{


    TCHAR       szDate[MAX_PATH] = TEXT("");
    TCHAR       szTime[MAX_PATH] = TEXT("");

    PROPVARIANT pv[2];
    PROPSPEC    ps[2];
    SYSTEMTIME  st;

    TraceEnter (TRACE_PROPUI, "CameraItemUpdateProc");

    // Convert the size string to something friendly
    UINT uSize = GetItemSize (pps);
    StrFormatByteSize (uSize, szDate, ARRAYSIZE(szDate));
    SetDlgItemText (hwnd, IDC_IMAGE_SIZE, szDate);
    *szDate = TEXT('\0');
    // Get the FILETIME and convert to something readable
    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_ITEM_TIME;
    ps[1].propid = WIA_IPA_PREFERRED_FORMAT;
    if (S_OK == (pps->ReadMultiple (ARRAYSIZE(ps), ps, pv)))
    {

        if (pv[0].vt > VT_NULL &&  pv[0].caub.pElems && pv[0].caub.cElems)
        {
            st  = *(reinterpret_cast<SYSTEMTIME *>(pv[0].caub.pElems));
            TimeToStrings (&st, szTime, szDate);
        }

        SetDlgItemText( hwnd, IDC_IMAGE_DATE, szDate );
        SetDlgItemText( hwnd, IDC_IMAGE_TIME, szTime );

        //
        // Map the format GUID to an extension and file format description
        //
        if (pv[1].puuid)
        {
            CComQIPtr<IWiaItem, &IID_IWiaItem>pItem(pps);
            CSimpleString strExt = CSimpleString(TEXT(".")) + WiaUiExtensionHelper::GetExtensionFromGuid(pItem,*pv[1].puuid);
            DWORD cch = ARRAYSIZE(szDate);
            CSimpleString strDesc;
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME, strExt, NULL, szDate, &cch)))
            {
                strDesc = szDate;
            }
            else
            {
                strDesc.LoadString(IDS_OTHER_FORMAT, GLOBAL_HINSTANCE);
            }
            strDesc.SetWindowText (GetDlgItem (hwnd, IDC_IMAGE_FORMAT));
        }
        FreePropVariantArray (ARRAYSIZE(pv), pv);
    }
    TraceLeave ();

}



/*****************************************************************************

   CameraFolderUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
CameraFolderUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{

    TraceEnter (TRACE_PROPUI, "CameraFolderUpdateProc");
    TraceLeave ();

}


/*****************************************************************************

   ScannerUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
ScannerUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{

    TraceEnter (TRACE_PROPUI, "ScannerUpdateProc");
    // need the STI device status and the X and Y optical resolution
    static const PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_DPS_OPTICAL_XRES},
                            {PRSPEC_PROPID, WIA_DPS_OPTICAL_YRES},
                            {PRSPEC_PROPID, WIA_DIP_DEV_ID}};

    PROPVARIANT pv[3] = {0};
 
    CSimpleString strResolution;
    CSimpleString strStatus;
    // optical resolution "XxY DPI"
    if (S_OK == pps->ReadMultiple(3, ps, pv))
    {
        strResolution.Format(TEXT("%dx%d DPI"), pv[0].ulVal, pv[1].ulVal);
        strResolution.SetWindowText(GetDlgItem(hwnd, IDC_RESOLUTION));
    }
    // "Online" or "Offline"
    if (bInit)
    {
        CComPtr<IStillImage> pSti;
        if (SUCCEEDED(StiCreateInstance (GLOBAL_HINSTANCE, STI_VERSION, &pSti, NULL)))
        {
            CComPtr<IStiDevice> pDevice;
            if (SUCCEEDED(pSti->CreateDevice(pv[2].bstrVal, 0, &pDevice, NULL)))
            {
                STI_DEVICE_STATUS sds = {0};
                sds.dwSize = sizeof(sds);
                sds.StatusMask = STI_DEVSTATUS_ONLINE_STATE;
                if (SUCCEEDED(pDevice->LockDevice(1000)))
                {
                    if (SUCCEEDED(pDevice->GetStatus(&sds)))
                    {
                        Trace(TEXT("Device online state: %x\n"), sds.dwOnlineState);
                        if (sds.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
                        {
                            strStatus.LoadString(IDS_OPERATIONAL, GLOBAL_HINSTANCE);
                        }
                        else
                        {
                            strStatus.LoadString(IDS_OFFLINE, GLOBAL_HINSTANCE);
                        }
                        strStatus.SetWindowText(GetDlgItem(hwnd, IDC_DEVICE_STATUS));                        
                    }
                    pDevice->UnLockDevice();
                }
            }
        }
    }
    FreePropVariantArray (ARRAYSIZE(pv), pv);
    TraceLeave ();
}


/******************************************************************************

    TestWiaDevice

    Runs a simple diagnostic on the device and displays a dialog with the result

*******************************************************************************/

VOID
TestWiaDevice (HWND hwnd, IWiaItem *pItem)
{

    HRESULT hr;
    STI_DIAG sd = {0};
    sd.dwSize = sizeof(sd);
    TraceEnter(TRACE_PROPUI, "TestWiaDevice");
    hr = pItem->Diagnostic(sizeof(sd), reinterpret_cast<LPBYTE>(&sd));
    if (S_OK == hr)
    {
        if (S_OK == sd.sErrorInfo.dwGenericError )
        {
            UIErrors::ReportMessage(hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_SUCCESS),
                                    MAKEINTRESOURCE(IDS_SUCCESS),
                                    MB_ICONINFORMATION);

        }
        else
        {

            UIErrors::ReportMessage(hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                    MAKEINTRESOURCE(IDS_NO_SUCCESS),
                                    MB_ICONSTOP);

        }
    }
    else
    {
        UIErrors::ReportMessage(hwnd,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                MAKEINTRESOURCE(IDS_TEST_UNAVAIL),
                                MB_ICONSTOP);
    }
    TraceLeave ();
}

/******************************************************************************

SetDeviceTime

Sync the PC time with the device

******************************************************************************/

VOID
SetDeviceTime (HWND hwndCameraPage, IWiaItem *pDevice)
{
    SYSTEMTIME st;
    PROPVARIANT pv = {0};
    GetLocalTime(&st);
    pv.vt = VT_UI2 | VT_VECTOR;
    pv.caui.cElems = sizeof(SYSTEMTIME)/sizeof(USHORT);
    pv.caui.pElems = reinterpret_cast<USHORT*>(&st);
    if(PropStorageHelpers::SetProperty(pDevice, WIA_DPA_DEVICE_TIME, pv))
    {
        UpdateTimeStatic(hwndCameraPage, &pv);
    }
    else
    {
        UIErrors::ReportMessage(hwndCameraPage, GLOBAL_HINSTANCE, NULL, 
                                MAKEINTRESOURCE(IDS_TIME_ERR_TITLE),
                                MAKEINTRESOURCE(IDS_TIME_ERR), 
                                MB_ICONWARNING | MB_OK);
    }
}

static const DWORD pScannerGeneralHelp[] =
{
    -1L, -1L,
    IDC_DESCRIPTION, IDH_WIA_DESCRIBE,
    IDC_MANUFACTURER_LABEL, IDH_WIA_MAKER,
    IDC_MANUFACTURER, IDH_WIA_MAKER,
    IDC_TESTSCAN, IDH_WIA_TEST_BUTTON,
    IDC_PORT_LABEL, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_STATIC, IDH_WIA_PORT_NAME,
    IDC_STATUS_LABEL, IDH_WIA_STATUS,
    IDC_DEVICE_STATUS, IDH_WIA_STATUS,
    IDC_RESOLUTION_LABEL, IDH_WIA_PIC_RESOLUTION,
    IDC_RESOLUTION, IDH_WIA_PIC_RESOLUTION,
    0,0
};
/******************************************************************************

    CWiaScannerPage::CWiaScannerPage

******************************************************************************/
CWiaScannerPage::CWiaScannerPage (IWiaItem *pItem) : CDevicePage (IDD_SCANNER_GENERAL, pItem, pScannerGeneralHelp)
{
}


/******************************************************************************

    CWiaScannerPage::OnInit

    Fill in the icon and WIA properties

******************************************************************************/

INT_PTR
CWiaScannerPage::OnInit ()
{
    TraceEnter (TRACE_PROPUI, "CWiaScannerPage::OnInit");

    HICON hIcon = NULL;
    WiaUiExtensionHelper::GetDeviceIcons(CComBSTR(m_strUIClassId.String()),MAKELONG(0,StiDeviceTypeScanner),NULL,&hIcon,0);

    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0));
    if (old)
    {
        DestroyIcon( old );
    }
    FillDeviceGeneralProps (m_hwnd, m_pItem, 0);
    TraceLeaveValue (TRUE);
}

/******************************************************************************

    CWiaScannerPage::OnCommand

    Handle the test button

******************************************************************************/

INT_PTR
CWiaScannerPage::OnCommand (WORD wCode, WORD widItem, HWND hwndItem)
{
    TraceEnter (TRACE_PROPUI, "CWiaScannerPage::OnCommand");
    switch (widItem)
    {
        case IDC_TESTSCAN:
            TestWiaDevice (m_hwnd, m_pItem);
            break;

    }
    TraceLeaveValue (0);
}

/******************************************************************************

    SubclassComboBox

    Set the wndproc for the ComboBox part of the ComboEx control to our wndproc

******************************************************************************/

static TCHAR cszPropProcPtr[] = TEXT("OldProcPtr");
VOID
SubclassComboBox (HWND hList)
{
    TraceEnter (TRACE_PROPUI, "SubclassComboBox");
    LONG_PTR lOldProc   ;

    HWND hCombo = FindWindowEx (hList, NULL, TEXT("ComboBox"), NULL);
    if (hCombo)
    {
        lOldProc = SetWindowLongPtr (hCombo, GWLP_WNDPROC,
                                  reinterpret_cast<LONG_PTR>(MyComboWndProc));
        SetProp (hCombo, cszPropProcPtr, reinterpret_cast<HANDLE>(lOldProc));
    }
    TraceLeave ();
}
/*****************************************************************************

    CAppListBox

    This classes subclasses the ComboBox to work around a bug
    that causes the list to drop down at bad times. Uses a window property
    to store the previous wndproc

*****************************************************************************/

CAppListBox::CAppListBox (HWND hList, HWND hStatic, HWND hNoApps)
{
    m_hwnd = hList;
    m_hstatic = hStatic;
    m_hnoapps = hNoApps;
    SubclassComboBox (hList);
    m_himl = NULL;
}

CAppListBox::~CAppListBox()
{
    if (m_himl)
    {
        ImageList_Destroy (m_himl);
    }
    FreeAppData();
}


/*****************************************************************************

    MyComboWndProc

    Bypass the combobox's window proc for WM_LBUTTONDOWN and WM_RBUTTONDOWN
    messages, send them to user32's combobox proc instead. Comctl32's subclass
    proc is buggy! We can do this because we don't need drag/drop support

*****************************************************************************/
LRESULT WINAPI
MyComboWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    static WNDPROC pfnDefProc = NULL;
    WNDPROC pfnWndProc = reinterpret_cast<WNDPROC>(GetProp (hwnd, cszPropProcPtr));

    if (!pfnDefProc)
    {
        WNDCLASS wc;
        wc.lpfnWndProc = NULL;
        GetClassInfo (GetModuleHandle(TEXT("user32.dll")),TEXT("ComboBox"), &wc);
        pfnDefProc = wc.lpfnWndProc;
    }
    if (msg == WM_LBUTTONDOWN || msg == WM_RBUTTONDOWN)
    {
        if (pfnDefProc)
        {
            return pfnDefProc(hwnd, msg, wp, lp);
        }
    }
    if (msg == WM_DESTROY)
    {
        RemoveProp (hwnd, cszPropProcPtr);
    }
    if (pfnWndProc)
    {
        return pfnWndProc (hwnd, msg, wp, lp);
    }
    else
    {
        return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
    }

}

// WIAXFER.EXE's clsid
static const CLSID CLSID_PersistCallback = {0x7EFA65D9,0x573C,0x4E46,{0x8C,0xCB,0xE7,0xFB,0x9E,0x56,0xCD,0x57}};

/*****************************************************************************

    CAppListBox::FillAppListBox

    Query WIA for the connection event handlers registered for our item
    and add their info to the list box

*****************************************************************************/

UINT
CAppListBox::FillAppListBox (IWiaItem *pItem, EVENTINFO *pei)
{
    TraceEnter (TRACE_PROPUI, "CAppListBoxPage::FillAppListBox");

    CComPtr<IEnumWIA_DEV_CAPS> pEnumHandlers;

    WIA_EVENT_HANDLER wehHandler;
    WIA_EVENT_HANDLER *pData = NULL;

    COMBOBOXEXITEM cbex = {0};
    CSimpleString strItem;
    HICON hIcon;
    INT cxIcon = min(16,GetSystemMetrics (SM_CXSMICON));
    INT cyIcon = min(16,GetSystemMetrics (SM_CYSMICON));

    HRESULT hr;
    WPARAM nDefault = 0;
    DWORD dw;
    UINT nHandlers=0;
    INT nIcons=0;

    
    // Turn off redraws until we've added the complete list
    SendMessage (m_hwnd, WM_SETREDRAW, FALSE, 0);

    SendMessage (m_hwnd, CBEM_SETIMAGELIST, 0, NULL);

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    // Create our event icon image list and add the default icon to it
    m_himl = ImageList_Create (cxIcon,
                             cyIcon,
                             PrintScanUtil::CalculateImageListColorDepth() | ILC_MASK,
                             10,
                             100);
    hIcon = reinterpret_cast<HICON>(LoadImage (GLOBAL_HINSTANCE,
                                               MAKEINTRESOURCE(IDI_EVENT),
                                               IMAGE_ICON,
                                               cxIcon,
                                               cyIcon,
                                               LR_SHARED | LR_DEFAULTCOLOR));

    if (-1 != ImageList_AddIcon (m_himl, hIcon))
    {
        nIcons++;
    }

    FreeAppData();

    // Assign this imagelist to the comboboxex
    SendMessage (m_hwnd, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(m_himl));

    // For the given event, enumerate the installed handlers
    if (!pei)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = pItem->EnumRegisterEventInfo (0,
                                           &pei->guidEvent,
                                           &pEnumHandlers);
    }

    while (S_OK == hr)
    {
        ZeroMemory(&wehHandler, sizeof(wehHandler));
        hr = pEnumHandlers->Next(1, &wehHandler, &dw);

        if (S_OK == hr)
        {
            // ignore wiaacmgr, WIA_EVENT_HANDLER_NO_ACTION and WIA_EVENT_HANDLER_PROMPT
            if (!IsEqualGUID(wehHandler.guid, CLSID_PersistCallback)
                && !IsEqualGUID(wehHandler.guid, WIA_EVENT_HANDLER_NO_ACTION)
                && !IsEqualGUID(wehHandler.guid, WIA_EVENT_HANDLER_PROMPT))
            {
                pData = new WIA_EVENT_HANDLER;
            }
        }

        if (pData)
        {

            // Add the string and icon to the comboboxex
            // and save the structure as item data

            strItem = CSimpleStringConvert::NaturalString (CSimpleStringWide(wehHandler.bstrName));

            CopyMemory (pData, &wehHandler, sizeof(wehHandler));
            ZeroMemory (&cbex, sizeof(cbex));
            cbex.mask = CBEIF_TEXT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
            cbex.iItem = -1;
            cbex.pszText = const_cast<LPTSTR>(strItem.String());

            if (pData->bstrIcon)
            {
                if (AddIconToImageList (m_himl, pData->bstrIcon))
                {
                    cbex.iImage = cbex.iSelectedImage = nIcons++;
                }
            }

            cbex.lParam = reinterpret_cast<LPARAM>(pData);
            if (-1 == SendMessage (m_hwnd,
                                   CBEM_INSERTITEM,
                                   0,
                                   reinterpret_cast<LPARAM>(&cbex)))
            {
                DeleteHandler (pData);
            }
            else
            {
                if (pData->ulFlags & WIA_IS_DEFAULT_HANDLER)
                {
                    nDefault = nHandlers;
                }
                nHandlers++;
            }
        } // the data wasn't copied from the struct, so free it
        else if (S_OK == hr)
        {
            SysFreeString(wehHandler.bstrCommandline);
            SysFreeString(wehHandler.bstrDescription);
            SysFreeString(wehHandler.bstrIcon);
            SysFreeString(wehHandler.bstrName);         
        }
        pData = NULL;
    }
    if (pei)
    {
        pei->nHandlers = nHandlers;
    }



    EnableWindow (m_hstatic, nHandlers > 0);

    ShowWindow (m_hwnd, nHandlers > 0 ? SW_SHOW : SW_HIDE);

    ShowWindow (m_hnoapps, nHandlers > 0 ? SW_HIDE : SW_SHOW);
    // Set selection to the current default or the user's current choice
    if (pei && pei->bNewHandler)
    {
        SetAppSelection (GetParent(m_hwnd), IDC_WIA_APPS, pei->clsidNewHandler);
    }
    else
    {
        SendMessage (m_hwnd, CB_SETCURSEL, nDefault, 0);
    }


    SendMessage (m_hwnd, WM_SETREDRAW, TRUE, 0);
    TraceLeave ();
    return nHandlers;
}

/*****************************************************************************

    CAppListBox::FreeAppData

    Free event data associated with the given applist listbox

*****************************************************************************/

void
CAppListBox::FreeAppData ()
{
    TraceEnter (TRACE_PROPUI, "CAppListBox::FreeAppData");
    COMBOBOXEXITEM ci ={0};
    LRESULT nItems;

    nItems = SendMessage (m_hwnd,
                          CB_GETCOUNT ,
                          0,0);
    ci.mask = CBEIF_LPARAM;    
    for (ci.iItem = 0;ci.iItem<nItems;ci.iItem++)
    {
        SendMessage (m_hwnd,
                     CBEM_GETITEM,
                     0,
                     reinterpret_cast<LPARAM>(&ci));
        if (ci.lParam)
        {
            WIA_EVENT_HANDLER *peh = reinterpret_cast<WIA_EVENT_HANDLER*>(ci.lParam);
            DeleteHandler(peh);            
        }
        ci.lParam = 0;
    }
    SendMessage(m_hwnd, CB_RESETCONTENT, 0, 0);
    TraceLeave ();
}

static const DWORD pCameraGeneralHelp[] =
{
    -1L, -1L,
    IDC_DESCRIPTION, IDH_WIA_DESCRIBE,
    IDC_MANUFACTURER_LABEL, IDH_WIA_MAKER,
    IDC_MANUFACTURER, IDH_WIA_MAKER,
    IDC_TAKEN, IDH_WIA_PICS_TAKEN,
    IDC_BATTERY_LABEL, IDH_WIA_BATTERY_STATUS,
    IDC_BATTERY, IDH_WIA_BATTERY_STATUS,
    IDC_TESTCAM, IDH_WIA_TEST_BUTTON,
    IDC_PORT_LABEL, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_STATIC, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_LIST, IDH_WIA_PORT_NAME,
    IDC_TAKEN_LABEL, IDH_WIA_PICS_TAKEN,
    IDC_FLASH_LABEL, IDH_WIA_FLASH_MODE,
    IDC_FLASH_MODE_LIST, IDH_WIA_FLASH_MODE_LIST,
    IDC_FLASH_MODE_STATIC, IDH_WIA_FLASH_MODE,
    IDC_PORT_SPEED, IDH_WIA_PORT_SPEED,
    IDC_PORT_SPEED_LABEL, IDH_WIA_PORT_SPEED,
    IDC_TIME_LABEL, IDH_WIA_CAMERA_TIME_STATIC,
    IDC_CURRENT_TIME, IDH_WIA_CAMERA_TIME_STATIC,
    IDC_SET_TIME, IDH_WIA_CAMERA_TIME_BUTTON,
    IDC_IMAGESIZE_SLIDER, IDH_WIA_IMAGE_SIZE_SLIDER,
    IDC_IMAGESIZE_STATIC, IDH_WIA_IMAGE_SIZE_STATIC,
    IDC_ITEMICON, 0,
    0,0
};
/*****************************************************************************

   CWiaCameraPage::CWiaCameraPage

   <Notes>

 *****************************************************************************/


CWiaCameraPage::CWiaCameraPage (IWiaItem *pItem) :
                CDevicePage (IDD_CAMERA_GENERAL, pItem, pCameraGeneralHelp)
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::CWiaCameraPage");
    m_pSizes = NULL;
    m_nSizes = 0;
    m_nSelSize = 0;
    m_lFlash = -1;
    
    //
    // Load sti_ci to get the port list functions
    //

    m_hStiCi = LoadClassInstaller();

    if (m_hStiCi)
    {
        m_pfnWiaCreatePortList  = (PFN_WIA_CREATE_PORTLIST)GetProcAddress( m_hStiCi, "WiaCreatePortList" );
        m_pfnWiaDestroyPortList = (PFN_WIA_DESTROY_PORTLIST)GetProcAddress( m_hStiCi, "WiaDestroyPortList" );
    }
    else
    {
        m_pfnWiaCreatePortList  = NULL;
        m_pfnWiaDestroyPortList = NULL;

    }

    SetWindowLongPtr( m_hwnd, DWLP_USER, (LONG_PTR)this );

    TraceLeave ();
}

CWiaCameraPage::~CWiaCameraPage ()
{
    if (m_hStiCi)
    {
        m_pfnWiaCreatePortList  = NULL;
        m_pfnWiaDestroyPortList = NULL;
        FreeLibrary( m_hStiCi );
    }

    if (m_pSizes)
    {
        delete [] m_pSizes;
    }

}

/*****************************************************************************
   fnComparePt

   Used to call qsort() to sort array of POINT structs


*****************************************************************************/
int __cdecl fnComparePt (const void *ppt1, const void *ppt2)
{
    LONG prod1, prod2; // image resolutions shouldn't be big enough to overflow a LONG
    prod1 = reinterpret_cast<const POINT*>(ppt1)->x * reinterpret_cast<const POINT*>(ppt1)->y;
    prod2 = reinterpret_cast<const POINT*>(ppt2)->x * reinterpret_cast<const POINT*>(ppt2)->y;
    if (prod1 < prod2)
    {
        return -1;
    }
    else if (prod1 == prod2)
    {
        return 0;
    }
    return 1;
}

/*****************************************************************************

    CWiaCameraPage::UpdatePictureSize

    Determines the appearance of the Picture Size slider on the camera general
    page. Hides it if the property isn't writable or there is no list of valid
    values.

*****************************************************************************/
VOID
CWiaCameraPage::UpdatePictureSize (IWiaPropertyStorage *pps)
{
    INT iWidth;
    INT iHeight;
    PROPVARIANT vValidVals[2];
    PROPVARIANT *pvWidthVals = &vValidVals[0];
    PROPVARIANT *pvHeightVals = &vValidVals[1];
    ULONG       ulFlags[2];
    PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
                      {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT}};
    PROPVARIANT vCurVals[2];

    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::UpdatePictureSize");


    ZeroMemory (vCurVals, sizeof(vCurVals));
    ZeroMemory (vValidVals, sizeof(vValidVals));
    pps->ReadMultiple (2, ps, vCurVals);
    pps->GetPropertyAttributes(2, ps, ulFlags, vValidVals);
    iWidth = vCurVals[0].intVal;
    iHeight = vCurVals[1].intVal;

    HWND hSlider = GetDlgItem(m_hwnd, IDC_IMAGESIZE_SLIDER);

    m_nSizes = WIA_PROP_LIST_COUNT(pvWidthVals);
    Trace(TEXT("Camera supports %d image resolutions"), m_nSizes);
    if (!(ulFlags[0] & (WIA_PROP_WRITE | WIA_PROP_LIST)) ||
        !(ulFlags[1] & (WIA_PROP_WRITE | WIA_PROP_LIST)) ||
          WIA_PROP_LIST_COUNT(pvHeightVals)!= m_nSizes  )
    {
        // hide the slider; the property isn't modifiable, or the camera
        // doesn't support a proper list of valid values
         ShowWindow (hSlider, SW_HIDE);
         // allocate only 1 possible size value
         if (iWidth && iHeight && !m_pSizes)
         {
             m_nSizes = 1;
             m_nSelSize = 0;
             m_pSizes = new POINT[m_nSizes];
             if (m_pSizes)
             {
                 m_pSizes[0].x = iWidth;
                 m_pSizes[0].y = iHeight;
             }
         }
    }
    else
    {
        //
        //build the array of sizes
        if (!m_pSizes)
        {
            m_pSizes = new POINT[m_nSizes];
            if (m_pSizes)
            {
                // set the ticks on the slider
                SendMessage (hSlider,
                             TBM_SETRANGE,
                             FALSE,
                             static_cast<LPARAM>(MAKELONG(0, m_nSizes-1)));

                for (size_t i=0;i<m_nSizes;i++)
                {
                    m_pSizes[i].x = pvWidthVals->cal.pElems[WIA_LIST_VALUES + i];//WIA_PROP_LIST_VALUE(pvWidthVals, i);
                    m_pSizes[i].y = pvHeightVals->cal.pElems[WIA_LIST_VALUES + i];//WIA_PROP_LIST_VALUE(pvHeightVals, i);
                }
                // sort the list by ascending order of x*y
                qsort (m_pSizes, m_nSizes, sizeof(POINT), fnComparePt);
                // now go through the sorted list looking for the current value
                // to set the slider
                for (size_t i=0;i<m_nSizes;i++)
                {
                    if (m_pSizes[i].x == iWidth && m_pSizes[i].y == iHeight)
                    {
                        SendMessage (hSlider,
                                     TBM_SETPOS,
                                     TRUE,
                                     i);
                        m_nSelSize = i;

                    }
                }
                // Display the slider and labels
                ShowWindow (hSlider, SW_SHOW);
                ShowWindow (GetDlgItem(m_hwnd, IDC_LOW_QUALITY), SW_SHOW);
                ShowWindow (GetDlgItem(m_hwnd, IDC_HIGH_QUALITY), SW_SHOW);
            }
        }
    }
    // Update the current resolution string
    UpdateImageSizeStatic (m_nSelSize);
    FreePropVariantArray (2, vCurVals);
    FreePropVariantArray (2, vValidVals);
    TraceLeave();
}

/*****************************************************************************

   CWiaCameraPage::OnInit

   <Notes>

 *****************************************************************************/

INT_PTR
CWiaCameraPage::OnInit ()
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnInit");

    WORD wType = StiDeviceTypeDefault;
    GetDeviceTypeFromDevice (m_pItem, &wType);

    HICON hIcon = NULL;
    WiaUiExtensionHelper::GetDeviceIcons(CComBSTR(m_strUIClassId.String()),MAKELONG(0,wType),NULL,&hIcon,0);

    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0));
    if (old)
    {
        DestroyIcon(old);
    }
    FillDeviceGeneralProps (m_hwnd, m_pItem, 0);
    m_lFlash = SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0);
    Trace(TEXT("m_lFlash is %d"), m_lFlash);
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> p(m_pItem);
    if (p)
    {
        UpdatePictureSize (p);
    }
    TraceLeave ();
    return TRUE;
}

/*****************************************************************************

   CWiaCameraPage::OnCommand

   Handle the Test Device button press

 *****************************************************************************/

INT_PTR
CWiaCameraPage::OnCommand (WORD wCode, WORD widItem, HWND hwndItem)
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnCommand");

    switch (widItem)
    {
        case IDC_TESTCAM:
            TestWiaDevice (m_hwnd, m_pItem);
            break;

        case IDC_SET_TIME:
            SetDeviceTime (m_hwnd, m_pItem);
            break;

    }
    TraceLeaveValue (0);
}

/*****************************************************************************

   CWiaCameraPage::StateChanged

   Determine if the user changed anything on the dialog since the last
   SaveCurrentState() call

 *****************************************************************************/
bool
CWiaCameraPage::StateChanged ()
{
    bool bRet = false;
    TraceEnter(TRACE_PROPUI, "CWiaCameraPage::StateChanged");
    if (SendMessage(GetDlgItem(m_hwnd, IDC_IMAGESIZE_SLIDER), TBM_GETPOS, 0, 0) != m_nSelSize)
    {
        bRet = true;
    }
    if (!bRet && m_lFlash != -1)
    {
        bRet = (m_lFlash != SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0));

    }
    if (!bRet && IsWindowVisible(GetDlgItem(m_hwnd, IDC_WIA_PORT_LIST)))
    {
        LRESULT iSel = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETCURSEL, 0, 0 );

        if (iSel != CB_ERR)
        {
            TCHAR szCurPort[ 128 ];
            *szCurPort = 0;
            LRESULT iRes;

            iRes = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szCurPort );

            if ((iRes != CB_ERR) && *szCurPort)
            {
                if (lstrcmpi( szCurPort, m_strPort) != 0)
                {
                    bRet = TRUE;
                }
            }
            *szCurPort = 0;
            iSel = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETCURSEL, 0, 0 );
            iRes = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szCurPort );

            if (lstrcmpi( szCurPort, m_strPortSpeed) != 0)
            {
                    bRet = TRUE;
            }
        }
    }
    TraceLeaveValue (bRet);
}

void
CWiaCameraPage::SaveCurrentState()
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::SaveCurrentState");
    TraceLeave ();
}

void
CWiaCameraPage::UpdateImageSizeStatic (LRESULT lIndex)
{
    CSimpleString strResolution;
    if (m_pSizes)
    {
        strResolution.Format(TEXT("%d x %d"), m_pSizes[lIndex].x, m_pSizes[lIndex].y);
        strResolution.SetWindowText(GetDlgItem(m_hwnd, IDC_IMAGESIZE_STATIC));
    }
}

INT_PTR
CWiaCameraPage::OnRandomMsg (UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_HSCROLL: // from our trackbar
            {
                LRESULT l = SendDlgItemMessage (m_hwnd, IDC_IMAGESIZE_SLIDER,
                                                TBM_GETPOS, 0, 0);
                UpdateImageSizeStatic (l);
                return TRUE;
            }
    }
    return FALSE;
}

LONG
CWiaCameraPage::OnApplyChanges(BOOL bHitOK)
{
    LONG lRet = PSNRET_NOERROR;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnApplyChanges");
    HRESULT hr = WriteImageSizeToDevice ();
    if (SUCCEEDED(hr))
    {
        hr = WriteFlashModeToDevice ();
    }
    if (SUCCEEDED(hr) && IsWindowVisible(GetDlgItem(m_hwnd, IDC_WIA_PORT_LIST)))
    {
        hr = WritePortSelectionToDevice();
    }
    if (FAILED(hr))
    {
        UIErrors::ReportError(m_hwnd, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
        lRet = PSNRET_INVALID;
    }

    if (!bHitOK)
    {
        // if the user hit Apply, re-read the device properties, as they may have changed
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(m_pItem);
        CameraUpdateProc (m_hwnd, FALSE, pps);
    }
    TraceLeaveValue (lRet);
}

HRESULT
CWiaCameraPage::WritePortSelectionToDevice()
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::WritePortSelectionToDevice");

    LRESULT iSel = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETCURSEL, 0, 0 );

    if (iSel != CB_ERR)
    {
        TCHAR *pszCurPort = NULL;
        TCHAR *pszBaudRate = NULL;
        LRESULT iRes;

        iRes = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETLBTEXTLEN, (WPARAM)iSel, NULL );
        if (iRes != CB_ERR)
        {
            pszCurPort = new TCHAR[iRes];
            if (pszCurPort)
            {
                iRes = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)pszCurPort );
            }
            else
            {
                iRes = CB_ERR;              
            }
        }
        if (iRes != CB_ERR)
        {
            // the user isn't required to pick a baud rate
            iSel = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETCURSEL, 0, 0);
            if (iSel != CB_ERR)
            {
                iRes = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETLBTEXTLEN, (WPARAM)iSel, NULL );
                if (iRes != CB_ERR)
                {
                    pszBaudRate = new TCHAR[iRes];
                    if (pszBaudRate)
                    {
                        iRes = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)pszBaudRate );
                    }
                    else
                    {
                        iRes = CB_ERR;                      
                    }
                }
            }
        }
    
        if ((iRes != CB_ERR) && pszCurPort && *pszCurPort)
        {
            Trace(TEXT("Chosen port: %s, speed:%s"), pszCurPort, pszBaudRate);
            if ((lstrcmpi(pszCurPort, m_strPort) != 0) || (lstrcmpi(pszBaudRate, m_strPortSpeed) != 0))
            {
                CComPtr<IWiaPropertyStorage> pps;

                hr = GetDeviceFromDeviceId( m_strDeviceId, IID_IWiaPropertyStorage, reinterpret_cast<LPVOID *>(&pps), FALSE );
                if (SUCCEEDED(hr) && pps)
                {
                    static const PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DIP_PORT_NAME},
                                                   {PRSPEC_PROPID, WIA_DIP_BAUDRATE}};
                    PROPVARIANT pv[2];
                    ULONG       ulItems = (pszBaudRate ? 2:1);

                    ZeroMemory (pv, sizeof(pv));
                    #ifdef UNICODE
                    pv[0].vt = VT_LPWSTR;
                    pv[0].pwszVal = pszCurPort;
                    pv[1].vt = VT_LPWSTR;
                    pv[1].pwszVal = pszBaudRate;
                    #else
                    pv[0].vt = VT_LPSTR;
                    pv[0].pszVal = pszCurPort;
                    pv[1].vt = VT_LPSTR;
                    pv[1].pszVal = pszBaudRate;
                    #endif

                    hr = pps->WriteMultiple (ulItems, ps, pv, 2);

                    if (SUCCEEDED(hr))
                    {
                        Trace(TEXT("pps->WriteMultiple( %d items, comport = %s, baudrate = %s ) was successful"),ulItems,pszCurPort,pszBaudRate);
                        //
                        // The "nominal" port value has changed, record it.
                        //

                        m_strPort = CSimpleString(pszCurPort);
                        if (pszBaudRate)
                        {
                            m_strPortSpeed = CSimpleString(pszBaudRate);
                        }
                        SetDlgItemText (m_hwnd, IDC_WIA_PORT_STATIC, m_strPort);
                    }
                }
            }
            else
            {
                hr = S_OK;
            }
        }
        DoDelete(pszBaudRate);
        DoDelete(pszCurPort);
    }
    TraceLeaveResult (hr);
}

HRESULT
CWiaCameraPage::WriteImageSizeToDevice ()
{
    TraceEnter(TRACE_PROPUI, "CWiaCameraPage::WriteImageSizeToDevice");
    static const PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
                                   {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT}};
    PROPVARIANT pv[2] = {0};
    HRESULT hr = S_OK;
    LRESULT nNewSize = SendDlgItemMessage (m_hwnd, IDC_IMAGESIZE_SLIDER, TBM_GETPOS, 0, 0);   
    if (m_pSizes && m_nSizes > 1)
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>pps(m_pItem);
        if (pps)
        {
            pv[0].vt= VT_I4;
            pv[0].intVal = m_pSizes[nNewSize].x;
            pv[1].vt= VT_I4;
            pv[1].intVal = m_pSizes[nNewSize].y;
            hr = pps->WriteMultiple (2, ps, pv,2);
        }
        else
        {
            hr = E_FAIL;
        }
        if (S_OK == hr)
        {
            m_nSelSize = nNewSize;
        }
    }
    TraceLeaveResult (hr);
}

HRESULT
CWiaCameraPage::WriteFlashModeToDevice()
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::WriteFlashModeToDevice");
    if (m_lFlash != -1)
    {
        LRESULT lFlash = SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0);
    
        INT iMode = static_cast<INT>(SendDlgItemMessage(m_hwnd, IDC_FLASH_MODE_LIST, CB_GETITEMDATA, lFlash, 0));

        if (!PropStorageHelpers::SetProperty(m_pItem, WIA_DPC_FLASH_MODE, iMode))
        {
            hr = WIA_ERROR_INCORRECT_HARDWARE_SETTING;
        }
        else
        {
            m_lFlash = lFlash;
        }
    }
    TraceLeaveResult (hr);
}
/*****************************************************************************

   CWiaFolderPage::CWiaFolderPage

   <Notes>

 *****************************************************************************/

CWiaFolderPage::CWiaFolderPage (IWiaItem *pItem) : CPropertyPage (IDD_CONTAINER_GENERAL, NULL, pItem)
{
}


static const DWORD pItemHelp [] =
{
    IDC_ITEMICON, -1,
    IDC_STATIC_NAME, IDH_WIA_PIC_NAME,
    IDC_STATIC_DATE, IDH_WIA_DATE_TAKEN,
    IDC_STATIC_TIME, IDH_WIA_TIME_TAKEN,
    IDC_STATIC_FORMAT, IDH_WIA_IMAGE_FORMAT,
    IDC_STATIC_SIZE, IDH_WIA_PICTURE_SIZE,
    IDC_IMAGE_NAME, IDH_WIA_PIC_NAME,
    IDC_IMAGE_DATE, IDH_WIA_DATE_TAKEN,
    IDC_IMAGE_TIME, IDH_WIA_TIME_TAKEN,
    IDC_IMAGE_FORMAT, IDH_WIA_IMAGE_FORMAT,
    IDC_IMAGE_SIZE, IDH_WIA_PICTURE_SIZE,
    0,0
};

/*****************************************************************************

   CWiaCameraItemPage::CWiaCameraItemPage

   <Notes>

 *****************************************************************************/

CWiaCameraItemPage::CWiaCameraItemPage (IWiaItem *pItem)
                   :CPropertyPage (IDD_IMAGE_GENERAL, NULL, pItem, pItemHelp)
{

}


/*****************************************************************************

   CWiaCameraItemPage::OnInit

   <Notes>

 *****************************************************************************/

INT_PTR
CWiaCameraItemPage::OnInit ()
{
    IWiaItem *pRoot;

    SHFILEINFO sfi = {0};
    LPITEMIDLIST pidl;


    CSimpleString strPath;

    // make a pidl for the item to leverage the format code
    pidl = IMCreateCameraItemIDL (m_pItem, m_strDeviceId, NULL);
    IMGetImagePreferredFormatFromIDL (pidl, NULL, &strPath);
    SHGetFileInfo (strPath,
                   FILE_ATTRIBUTE_NORMAL,
                   &sfi,
                   sizeof(sfi), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);

    // Use our bitmap icon if shgetfileinfo didn't work
    if (!(sfi.hIcon))
    {
        sfi.hIcon = LoadIcon (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDI_PICTURE_BMP));
    }
    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(sfi.hIcon), 0));
    if (old)
    {
        DestroyIcon(old);
    }
    m_pItem->GetRootItem (&pRoot);
    FillItemGeneralProps (m_hwnd, pRoot, m_pItem, 0);
    DoILFree (pidl);
    return TRUE;
}

bool
CWiaCameraItemPage::ItemSupported (IWiaItem *pItem)
{
    // We only support properties for image items
    bool bRet = false;
    LONG lType;
    if (SUCCEEDED(pItem->GetItemType(&lType)))
    {
        if (lType & (WiaItemTypeImage | WiaItemTypeVideo | WiaItemTypeFile))
        {
            bRet = true;
        }
    }
    return bRet;
}


//
// Define constants for dwords stored in the registry
#define ACTION_RUNAPP    0
#define ACTION_AUTOSAVE  1
#define ACTION_NOTHING   2
#define ACTION_PROMPT    3
#define ACTION_MAX       3
/*****************************************************************************

   CWiaEventsPage::GetConnectionSettings

   Fills in the connect event autosave controls with the current user settings.

/*****************************************************************************/

DWORD
CWiaEventsPage::GetConnectionSettings ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetConnectionSettings");
    DWORD dwAction = ACTION_RUNAPP;

    CSimpleString strSubKey;
    strSubKey.Format (c_szConnectSettings, m_strDeviceId.String());
    CSimpleReg reg (HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS, false, KEY_READ, NULL);
    CSimpleReg regSettings (reg, strSubKey, false, KEY_READ, NULL);
    CSimpleString strFolderPath;
    DWORD bAutoDelete = 0;
    DWORD bUseDate = 0;
    TCHAR szMyPictures[MAX_PATH] = TEXT("");


    SHGetFolderPath (NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, NULL, 0, szMyPictures);
    strFolderPath = szMyPictures; // default path if registry fails

    // Find out the current settings in the registry
    if (regSettings.OK())
    {
        dwAction = regSettings.Query(REGSTR_VALUE_CONNECTACT, dwAction);
        if (dwAction > ACTION_MAX)
        {
                dwAction = ACTION_RUNAPP;
        }

        strFolderPath = regSettings.Query (REGSTR_VALUE_SAVEFOLDER, CSimpleString(reinterpret_cast<LPCTSTR>(szMyPictures)));
        bAutoDelete = regSettings.Query (REGSTR_VALUE_AUTODELETE, bAutoDelete);
        bUseDate = regSettings.Query(REGSTR_VALUE_USEDATE, bUseDate);
    }
    // If another app has made itself the default handler for connection since
    // the last time the user invoked this sheet, we need to make sure
    // we reflect that in the active action.
    if (dwAction != ACTION_RUNAPP)
    {
        VerifyCurrentAction (dwAction);
    }

    // turn on the defaults
    CheckDlgButton (m_hwnd, IDB_DELETEONSAVE, bAutoDelete);
    CheckDlgButton (m_hwnd, IDB_USEDATE, bUseDate);
    strFolderPath.SetWindowText(GetDlgItem (m_hwnd, IDC_FOLDERPATH));



    TraceLeaveValue(dwAction);
}


/*****************************************************************************

    CWiaEventsPage::EnableAutoSave

    Enable controls appropriate to the Automatically save.. option

*****************************************************************************/

void
CWiaEventsPage::EnableAutoSave(BOOL bEnable)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::EnableAutoSave");

    EnableWindow (GetDlgItem(m_hwnd, IDB_QUIETSAVE), bEnable && !m_bReadOnly);
    BOOL bAutoSave = IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE);
    EnableWindow (GetDlgItem (m_hwnd, IDB_USEDATE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_DELETEONSAVE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDC_FOLDERPATH), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_BROWSE), bAutoSave);
}


static const TCHAR c_szWiaxfer[] = TEXT("\\wiaacmgr.exe");
static const TCHAR c_szWiaxferRegister[] = TEXT(" /RegConnect ");
static const TCHAR c_szWiaxferUnregister[] = TEXT(" /UnregConnect ");

/*****************************************************************************

    CWiaEventsPage::RegisterWiaxfer

    Invoke wiaxfer to register itself

*****************************************************************************/

bool
CWiaEventsPage::RegisterWiaxfer (bool bRegister)
{
    TCHAR szAppName[MAX_PATH+1+ARRAYSIZE(c_szWiaxfer)];
    STARTUPINFO sui = {0};
    PROCESS_INFORMATION pi;
    bool bRet = false;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::RegisterWiaxfer");
    UINT cch=GetSystemDirectory(szAppName, ARRAYSIZE(szAppName));
    if (cch)
    {
        TCHAR szCmdLine[MAX_PATH+1+ARRAYSIZE(c_szWiaxfer)+ARRAYSIZE(c_szWiaxferUnregister)+STI_MAX_INTERNAL_NAME_LENGTH];
        StrCatBuff(szAppName, c_szWiaxfer, ARRAYSIZE(szAppName)); // GetSystemDirectory doesn't provide the backslash
        wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s%s%s"), 
                  szAppName, 
                  bRegister ? c_szWiaxferRegister : c_szWiaxferUnregister,
                  m_strDeviceId.String());

        sui.cb = sizeof(sui);
        if (CreateProcess (szAppName, szCmdLine,
                            NULL,
                            NULL,
                            TRUE,
                            0,
                            NULL,
                            NULL,
                            &sui,
                            &pi))
        
        
        {
            bRet = true;
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);
        }
    }
    TraceLeave ();
    return bRet;
}

LONG
CWiaEventsPage::ApplyAutoSave()
{
    // Attempt to register the wiaxfer application as the default handler
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::ApplyAutoSave");
    LONG lRet = PSNRET_NOERROR;

    // validate folder path is not empty. wiaxfer will validate it for
    // real when the camera actually connects

    if (!(*m_szFolderPath))
    {
        UIErrors::ReportMessage (NULL,
                                 GLOBAL_HINSTANCE,
                                 NULL,
                                 MAKEINTRESOURCE(IDS_INVALID_PATH_CAPTION),
                                 MAKEINTRESOURCE(IDS_INVALID_PATH),
                                 MB_ICONSTOP);
        lRet = PSNRET_INVALID;
    }
    else
    {
        UpdateWiaxferSettings ();
        if (!RegisterWiaxfer (true))
        {
            UIErrors::ReportMessage (NULL,
                                     GLOBAL_HINSTANCE,
                                     NULL,
                                     MAKEINTRESOURCE(IDS_NO_WIAXFER_CAPTION),
                                     MAKEINTRESOURCE(IDS_NO_WIAXFER),
                                     MB_ICONSTOP);
            lRet = PSNRET_INVALID;
        }
    }
    TraceLeave ();
    return lRet;
}



static const TCHAR c_szConnectionSettings[] = TEXT("OnConnect\\%ls");

void
CWiaEventsPage::UpdateWiaxferSettings ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::UpdateWiaxferSettings");
    CSimpleReg regSettings (HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS, true, KEY_READ|KEY_WRITE );
    CSimpleString strSubKey;
    // Settings are per-device
    strSubKey.Format (c_szConnectionSettings, m_strDeviceId.String());
    CSimpleReg regActions (regSettings, strSubKey, true, KEY_READ|KEY_WRITE );


    if (regActions.Open ())
    {
        // Set the default action
        regActions.Set(REGSTR_VALUE_CONNECTACT, m_dwAction);

        if (ACTION_AUTOSAVE == m_dwAction)
        {
            // Set the actions for auto-download
            regActions.Set(REGSTR_VALUE_SAVEFOLDER, m_szFolderPath);
            regActions.Set(REGSTR_VALUE_AUTODELETE, m_bAutoDelete?1:0);
            regActions.Set(REGSTR_VALUE_USEDATE, m_bUseDate?1:0);
        }
        else
        {
            // Nothing to do for ACTION_RUNAPP or ACTION_NOTHING
        }
    }
    TraceLeave ();
}

void
CWiaEventsPage::SaveConnectState ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::SaveConnectState");
    GetDlgItemText (m_hwnd, IDC_FOLDERPATH, m_szFolderPath, ARRAYSIZE(m_szFolderPath));
    m_bAutoDelete = IsDlgButtonChecked (m_hwnd, IDB_DELETEONSAVE);
    m_bUseDate = IsDlgButtonChecked (m_hwnd, IDB_USEDATE);
    if (IsDlgButtonChecked (m_hwnd, IDB_LAUNCHAPP))
    {
        m_dwAction = ACTION_RUNAPP;
    }
    else if (IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE))
    {
        m_dwAction = ACTION_AUTOSAVE;
    }
    else if (IsDlgButtonChecked (m_hwnd, IDC_PROMPT))
    {
        m_dwAction = ACTION_PROMPT;
    }
    else
    {
        m_dwAction = ACTION_NOTHING;
    }

    TraceLeave ();
}


int
ConnectPageBrowseCallback (HWND hwnd, UINT msg, LPARAM lp, LPARAM szPath )
{
    // set the default selection to the current folder path
    if (BFFM_INITIALIZED == msg)
    {
        SendMessage (hwnd, BFFM_SETSELECTION, TRUE, szPath);
    }
    return 0;
}
void
CWiaEventsPage::GetSavePath ()
{
    BROWSEINFO bi;
    ULONG ul;
    CSimpleString strCaption(IDS_SAVEPATH_CAPTION, GLOBAL_HINSTANCE);
    LPITEMIDLIST pidlCurrent;
    TCHAR szNewPath[MAX_PATH] = TEXT("\0");
    HRESULT hr;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetSavePath");

    ZeroMemory (&bi, sizeof(bi));


    bi.hwndOwner = m_hwnd;
    bi.lpszTitle = strCaption;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;
    bi.pszDisplayName = szNewPath;
    bi.lParam = reinterpret_cast<LPARAM>(m_szFolderPath);
    bi.lpfn = ConnectPageBrowseCallback;
    pidlCurrent = SHBrowseForFolder (&bi);
    if (pidlCurrent)
    {
        SHGetPathFromIDList (pidlCurrent, szNewPath);
        SetDlgItemText (m_hwnd, IDC_FOLDERPATH, szNewPath);
        ILFree (pidlCurrent);
    }
    DoILFree (bi.pidlRoot);
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::VerifyCurrentAction

    Make sure CLSID_PersistCallback is registered as the default connection
    event handler for this device. If it isn't, unregister wiaxfer.

*****************************************************************************/

void
CWiaEventsPage::VerifyCurrentAction (DWORD &dwAction)
{

    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::VerifyCurrentAction");
    EVENTINFO *pei;
    GUID guidEvent = WIA_EVENT_DEVICE_CONNECTED;
    GetEventInfo (m_pItem, guidEvent, &pei);
    if (pei)
    {
        if (pei->bHasDefault && IsEqualCLSID(WIA_EVENT_HANDLER_PROMPT, pei->clsidHandler))
        {
            dwAction = ACTION_PROMPT;
        }

        else if (!(pei->bHasDefault) ||
            !IsEqualCLSID(CLSID_PersistCallback, pei->clsidHandler))
        {
            dwAction = ACTION_RUNAPP;
            RegisterWiaxfer (false);
        }

        delete pei;
    }
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage constructor

*****************************************************************************/
static const DWORD pEventsHelpIds [] =
{
    -1L,-1L,
    IDC_SELECTTEXT, IDH_WIA_EVENT_LIST,
    IDC_WIA_EVENT_LIST, IDH_WIA_EVENT_LIST,
    IDC_WIA_APPS, IDH_WIA_APP_LIST,
    IDB_LAUNCHAPP, IDH_WIA_START_PROG,
    IDC_PROMPT, IDH_WIA_PROMPT_PROG,
    IDC_NOACTION , IDH_WIA_NO_ACTION,
    IDB_DELETEONSAVE, IDH_WIA_DELETE_IMAGES,
    IDB_USEDATE, IDH_WIA_SUBFOLD_DATE,
    IDB_BROWSE, IDH_WIA_BROWSE,
    IDB_QUIETSAVE, IDH_WIA_SAVE_TO,
    IDC_FOLDERPATH, IDH_WIA_SAVE_TO_FOLDER,
    0,0
};
CWiaEventsPage::CWiaEventsPage(IWiaItem *pItem)
               : CPropertyPage (IDD_WIA_EVENTS, NULL, pItem, pEventsHelpIds)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::CWiaEventsPage");
    m_bHandlerChanged = false;
    m_pAppsList = NULL;
    m_himl = NULL;
    m_bReadOnly = FALSE;
    TraceLeave ();
}

CWiaEventsPage::~CWiaEventsPage ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::~CWiaEventsPage");
    if (m_pAppsList)
    {
        delete m_pAppsList;
    }


    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::OnInit

    Enum available WIA events for this item as well as the apps registered
    to handle each one. Fill in the lists of each.

*****************************************************************************/
INT_PTR
CWiaEventsPage::OnInit()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnInit");
    EVENTINFO *pei;
    //
    // Find out if the user has rights to control services
    // if not, disable all the controls except the ones controlling
    // how auto-download works. Those settings are per-user
    //
    SC_HANDLE hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

    if (!hSCM) 
    {
        m_bReadOnly = TRUE;
    }
    else
    {
        CloseServiceHandle(hSCM);
    }
    SubclassComboBox (GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST));
    FillEventListBox();
    m_pAppsList = new CAppListBox (GetDlgItem(m_hwnd, IDC_WIA_APPS),
                                   GetDlgItem(m_hwnd, IDB_LAUNCHAPP),
                                   GetDlgItem(m_hwnd, IDS_NO_APPS));
    // Get the current event selection and update the apps list accordingly
    m_dwAction = GetConnectionSettings ();
    HandleEventComboNotification (CBN_SELCHANGE, GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST));
    
    TraceLeave ();
    return TRUE;
}

/*****************************************************************************

    CWiaEventsPage::OnApplyChanges

    Cycle through the events, looking for ones whose default app clsid has
    changed. Update the default event handler accordingly for each event.

*****************************************************************************/

LONG
CWiaEventsPage::OnApplyChanges (BOOL bHitOK)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnApplyChanges");
    LRESULT nItems = SendDlgItemMessage (m_hwnd, IDC_WIA_EVENT_LIST,
                                         CB_GETCOUNT, 0, 0);
    EVENTINFO *pei;
    LONG lRet = PSNRET_NOERROR;
    for (--nItems;nItems>=0;nItems--)
    {
        GetEventFromList (static_cast<LONG>(nItems), &pei);
        if (IsEqualCLSID(pei->clsidNewHandler, CLSID_PersistCallback))
        {
            lRet = ApplyAutoSave ();
        }
        if (pei && pei->bNewHandler) // user picked a new handler
        {
            if (!pei->bHasDefault || !IsEqualGUID (pei->clsidHandler, pei->clsidNewHandler))
            {
                // the new handler differs from the old one

                if (FAILED(SetDefaultHandler (m_pItem, pei)))
                {
                    UIErrors::ReportMessage (m_hwnd, GLOBAL_HINSTANCE, NULL,
                                             MAKEINTRESOURCE(IDS_REGISTER_FAILED_TITLE),
                                             MAKEINTRESOURCE(IDS_REGISTER_FAILED));

                    lRet = PSNRET_INVALID;
                }

            }
            if (lRet == PSNRET_NOERROR )
            {
                pei->bHasDefault = true;
                pei->clsidHandler = pei->clsidNewHandler;
            }
        }
    }
    m_bHandlerChanged = false; // reset changed state
    TraceLeaveValue (lRet);
}

/*****************************************************************************

    CWiaEventsPage::OnCommand


*****************************************************************************/


INT_PTR
CWiaEventsPage::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{
    INT_PTR iRet = 1;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnCommand");

    switch (widItem)
    {
        case IDC_WIA_EVENT_LIST:
            iRet = HandleEventComboNotification (wCode, hwndItem);
            break;

        case IDC_WIA_APPS:
            iRet = HandleAppComboNotification (wCode, hwndItem);
            break;

        case IDB_LAUNCHAPP:
            if (IsDlgButtonChecked(m_hwnd, IDB_LAUNCHAPP))
            {
                EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), TRUE);
                HandleAppComboNotification (CBN_SELCHANGE, GetDlgItem(m_hwnd, IDC_WIA_APPS));

            };
            break;

        case IDB_BROWSE:
            GetSavePath ();
            break;

        case IDB_QUIETSAVE:
        case IDC_PROMPT:
        case IDC_NOACTION:
            GUID guid;
            EVENTINFO *pei;

            if (!IsDlgButtonChecked(m_hwnd, IDB_LAUNCHAPP))
            {
                EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), FALSE);
            };
            LRESULT lEvent = SendDlgItemMessage (m_hwnd,
                                                 IDC_WIA_EVENT_LIST,
                                                 CB_GETCURSEL, 0, 0);
            if (IsDlgButtonChecked(m_hwnd, widItem) && lEvent >= 0)
            {
                BOOL bConnect;
                GetEventFromList (static_cast<LONG>(lEvent), &pei);
                bConnect= IsEqualCLSID (pei->guidEvent, WIA_EVENT_DEVICE_CONNECTED);
                if (pei)
                {
                    pei->bNewHandler = true;
                    if (widItem == IDC_NOACTION)
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_NOTHING;
                        }
                        guid = WIA_EVENT_HANDLER_NO_ACTION;
                    }
                    else if (widItem == IDC_PROMPT)
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_PROMPT;
                        }
                        guid = WIA_EVENT_HANDLER_PROMPT;
                    }
                    else
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_AUTOSAVE;
                        }
                        guid = CLSID_PersistCallback;
                    }
                    pei->clsidNewHandler = guid;
                    pei->strDesc = L"internal handler";
                    pei->strIcon = L"wiashext.dll, -101";
                    pei->strName = L"internal";
                    pei->strCmd = (BSTR)NULL;
                    pei->ulFlags = WIA_IS_DEFAULT_HANDLER;
                    if (!pei->bHasDefault ||
                        !IsEqualGUID(guid, pei->clsidHandler))
                    {
                        m_bHandlerChanged = true;
                    }
                }
            }
            break;
    }
    // Turn off controls related to auto-save if that button is not checked
    BOOL bAutoSave = IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE);
    EnableWindow (GetDlgItem (m_hwnd, IDB_USEDATE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_DELETEONSAVE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDC_FOLDERPATH), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_BROWSE), bAutoSave);
    TraceLeave ();
    return iRet;
}

/*****************************************************************************

    CWiaEventsPage::HandleEventComboNotification


    When the combobox selection changes, free the current application data
    and re-fill the app list

*****************************************************************************/


INT_PTR
CWiaEventsPage::HandleEventComboNotification(WORD wCode, HWND hCombo)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::HandleEventComboNotification");
    switch (wCode)
    {
        case CBN_SELCHANGE:
        {
            if (m_pAppsList)
            {
                LRESULT lItem;
                EVENTINFO *pei;
                lItem = SendMessage (hCombo, CB_GETCURSEL, 0, 0);
                if (lItem >= 0)
                {
                    EnableWindow (GetDlgItem (m_hwnd, IDC_NOACTION), !m_bReadOnly);
                    GetEventFromList (static_cast<LONG>(lItem), &pei);
                    bool bConnect = false;
                    if (pei)
                    {
                        if (IsEqualCLSID (pei->guidEvent, WIA_EVENT_DEVICE_CONNECTED))
                        {
                            bConnect= true;
                        }
                        m_pAppsList->FillAppListBox (m_pItem, pei);
                        if (pei->nHandlers)
                        {
                            EnableWindow (GetDlgItem (m_hwnd, IDB_LAUNCHAPP), !m_bReadOnly);
                            EnableWindow (GetDlgItem (m_hwnd, IDC_WIA_APPS), !m_bReadOnly);

                        }
                        // disable the "prompt" button if needed
                        EnableWindow (GetDlgItem(m_hwnd, IDC_PROMPT), (!m_bReadOnly && pei->nHandlers >= 2));

                        // Make sure our radio buttons are in the proper state
                        if (IsEqualCLSID (pei->clsidNewHandler, WIA_EVENT_HANDLER_PROMPT))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDC_PROMPT);
                        }
                        else if (!(pei->nHandlers) || IsEqualCLSID (pei->clsidNewHandler, WIA_EVENT_HANDLER_NO_ACTION))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDC_NOACTION);
                        }
                        else if (IsEqualCLSID (pei->clsidNewHandler, CLSID_PersistCallback))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDB_QUIETSAVE);
                        }
                        else
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDB_LAUNCHAPP);
                        }
                        // only enable the app list if "run an app" is selected
                        if (!IsDlgButtonChecked (m_hwnd, IDB_LAUNCHAPP) || m_bReadOnly)
                        {
                            EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), FALSE);
                        }
                        EnableAutoSave (bConnect?TRUE:FALSE);
                    }
                }
            }
        }
        break;
    }
    TraceLeave ();
    return 0;
}

bool
CWiaEventsPage::StateChanged()
{
    TCHAR szNewPath[MAX_PATH];
    BOOL bNewDel;
    LONG lNewSel;
    bool bRet = m_bHandlerChanged;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::StateChanged");
    GetDlgItemText (m_hwnd, IDC_FOLDERPATH, szNewPath, MAX_PATH);
    // empty path is an invalid state
    if (lstrcmp(szNewPath, m_szFolderPath) || !*m_szFolderPath)
    {
        bRet= true;
    }
    bNewDel = IsDlgButtonChecked (m_hwnd, IDB_DELETEONSAVE);
    if (bNewDel != m_bAutoDelete)
    {
        bRet = true;
    }
    bNewDel = IsDlgButtonChecked (m_hwnd, IDB_USEDATE);
    if (bNewDel != m_bUseDate)
    {
        bRet =  true;
    }
    TraceLeaveValue (bRet);
}

void
CWiaEventsPage::SaveCurrentState()
{
    SaveConnectState ();

}

/*****************************************************************************

    CWiaEventsPage::FillEventsListBox

    Enumerate the supported events for our device, and add a comboboxitemex
    entry for each one. The LPARAM of the item is a pointer to an EVENTINFO
    struct.

*****************************************************************************/

void
CWiaEventsPage::FillEventListBox ()
{

    WIA_DEV_CAP wdc;
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;

    COMBOBOXEXITEM cbex;
    HICON      hIcon;
    INT cxIcon = min(16,GetSystemMetrics (SM_CXSMICON));
    INT cyIcon = min(16,GetSystemMetrics (SM_CYSMICON));
    UINT nEvents = 0;
    HWND hCombo;
    WORD wType;
    INT iDefault = 0;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::FillEventListBox");

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    // Create our event icon image list and add the default icon to it
    m_himl = ImageList_Create (cxIcon,
                             cyIcon,
                             PrintScanUtil::CalculateImageListColorDepth()|ILC_MASK,
                             10,
                             100);

    hIcon = LoadIcon (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDI_EVENT));
   /* hIcon = reinterpret_cast<HICON>(LoadImage (GLOBAL_HINSTANCE,
                                               MAKEINTRESOURCE(IDI_EVENT),
                                               IMAGE_ICON,
                                               cxIcon,
                                               cyIcon,
                                               LR_SHARED | LR_DEFAULTCOLOR));*/
    if (hIcon)
    {
        ImageList_AddIcon (m_himl, hIcon);

        // ImageList has made a (bitmap) copy of our icon, so we can destroy it now
        DestroyIcon( hIcon );
    }

    hCombo = GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST);

    // Turn off redraws until we've added the complete list
    SendMessage (hCombo, WM_SETREDRAW, FALSE, 0);

    // Assign this imagelist to the comboboxex
    SendMessage (hCombo, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(m_himl));

    GetDeviceTypeFromDevice (m_pItem, &wType);
    // Enum the events this device supports and add them to the list
    if (SUCCEEDED(m_pItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,
                                                  &pEnum)))
    {

        INT i = 1; // current image list index
        EVENTINFO *pei;
        CSimpleStringWide strNameW;
        CSimpleString strName;
        INT iItem; //index of inserted item
        while (S_OK == pEnum->Next (1, &wdc, NULL))
        {
            Trace(TEXT("wdc.ulFlags == %x"), wdc.ulFlags);
            // only enum Action events
            if (wdc.ulFlags & WIA_ACTION_EVENT)
            {
                strNameW = wdc.bstrName;
                ZeroMemory (&cbex, sizeof(cbex));
                cbex.mask = CBEIF_TEXT | CBEIF_LPARAM | CBEIF_SELECTEDIMAGE | CBEIF_IMAGE;
                strName = CSimpleStringConvert::NaturalString(strNameW);
                cbex.pszText = const_cast<LPTSTR>(strName.String());
                cbex.iItem = -1;

                // Set the appropriate icon
                if (wdc.bstrIcon && *(wdc.bstrIcon))
                {
                    if (AddIconToImageList (m_himl, wdc.bstrIcon))
                    {
                        cbex.iImage = cbex.iSelectedImage = i++;
                    }
                } // default to 0, the default icon

                // Save the current event info as lParam
                GetEventInfo (m_pItem, wdc.guid, &pei);
                cbex.lParam = reinterpret_cast<LPARAM>(pei);
                iItem = (INT)SendMessage (hCombo,
                                          CBEM_INSERTITEM,
                                          0,
                                          reinterpret_cast<LPARAM>(&cbex));
                if (-1 == iItem)
                {
                    DoDelete( pei); // clean up if insert failed
                }
                else
                {
                    //
                    // If the inserted GUID is the scan event for scanners or the connect event for
                    // cameras, make it the default selection
                    if ((wType == StiDeviceTypeDigitalCamera && wdc.guid == WIA_EVENT_DEVICE_CONNECTED)
                        || (wType == StiDeviceTypeScanner && wdc.guid == WIA_EVENT_SCAN_IMAGE))
                    {
                        Trace(TEXT("Default item should be %d: %s"), iItem, cbex.pszText);
                        iDefault = iItem;
                    }
                    nEvents++;
                }
            }
            SysFreeString(wdc.bstrCommandline);
            SysFreeString(wdc.bstrDescription);
            SysFreeString(wdc.bstrIcon);
            SysFreeString(wdc.bstrName);
        }
    }
    // Inform the user if there are no events
    if (!nEvents)
    {
        EnableWindow (GetDlgItem(m_hwnd, IDC_SELECTTEXT), FALSE);
        ShowWindow (GetDlgItem(m_hwnd, IDC_SELECTTEXT), SW_HIDE);
        ShowWindow (hCombo, SW_HIDE);
        ShowWindow (GetDlgItem(m_hwnd, IDC_NOEVENTS), SW_SHOW);

    }
    else
    {
        ShowWindow (GetDlgItem(m_hwnd, IDC_NOEVENTS), SW_HIDE);
    }
    SendMessage (hCombo, CB_SETCURSEL, iDefault, 0);
    SendMessage (hCombo, WM_SETREDRAW, TRUE, 0);
    TraceLeave ();
}


/*****************************************************************************
    CWiaEventsPage::GetEventFromList

    Retrieve the EVENTINFO struct for the given index

*****************************************************************************/
void
CWiaEventsPage::GetEventFromList (LONG idx, EVENTINFO **ppei)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetEventFromList");
    TraceAssert (ppei);
    HWND hCombo = GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST);
    COMBOBOXEXITEM cbex = {0};
    cbex.mask = CBEIF_LPARAM;
    cbex.iItem = idx;
    SendMessage (hCombo,
                 CBEM_GETITEM,
                 0,
                 reinterpret_cast<LPARAM>(&cbex));
    *ppei = reinterpret_cast<EVENTINFO*>(cbex.lParam);

    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::HandleAppComboNotification

    When the user changes the selected app to handle the current selected event,
    update that event's EVENTINFO struct.

*****************************************************************************/
INT_PTR
CWiaEventsPage::HandleAppComboNotification (WORD wCode, HWND hCombo)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::HandleAppComboNotification");
    switch (wCode)
    {
        case CBN_SELCHANGE:
        {
            EVENTINFO *pei;
            WIA_EVENT_HANDLER weh;
            LRESULT lEvent = SendDlgItemMessage (m_hwnd,
                                                 IDC_WIA_EVENT_LIST,
                                                 CB_GETCURSEL, 0, 0);
            if (lEvent >= 0)
            {
                GetSelectedHandler (m_hwnd, IDC_WIA_APPS, weh);
                GetEventFromList (static_cast<LONG>(lEvent), &pei);
                if (pei)
                {
                    pei->bNewHandler = true;
                    pei->clsidNewHandler = weh.guid;
                    pei->strDesc = weh.bstrDescription;
                    pei->strIcon = weh.bstrIcon;
                    pei->strName = weh.bstrName;
                    pei->ulFlags = weh.ulFlags;
                    pei->strCmd  = weh.bstrCommandline;
                    if (!pei->bHasDefault ||
                        !IsEqualGUID(weh.guid, pei->clsidHandler))
                    {
                        m_bHandlerChanged = true;
                    }
                }
            }
        }
        break;
    }
    TraceLeave ();
    return 0;
}

/*****************************************************************************

    CWiaEventsPage::OnNotify

    Handle notifications from the event comboex

*****************************************************************************/

bool
CWiaEventsPage::OnNotify(LPNMHDR pnmh, LRESULT *presult)
{
    bool bRet = false;
    TraceEnter(TRACE_PROPUI, "CWiaEventsPage::OnNotify)");
    if (pnmh->hwndFrom == GetDlgItem(m_hwnd, IDC_WIA_EVENT_LIST))
    {

        NMCOMBOBOXEX *pnmc = reinterpret_cast<NMCOMBOBOXEX*>(pnmh);
        switch (pnmh->code)
        {
            case CBEN_DELETEITEM:
                //
                // We get this message when the comboboxex is destroyed
                // Need to free the EVENTINFO structs we store with each item
                //
                Trace(TEXT("Got CBEN_DELETEITEM. item: %d, mask: %x"),
                      pnmc->ceItem.iItem, pnmc->ceItem.mask);
                if (pnmc->ceItem.mask & CBEIF_LPARAM)
                {
                    delete reinterpret_cast<EVENTINFO *>(pnmc->ceItem.lParam);
                }
                break;
        }
        bRet = true;
    }
    TraceLeaveValue(bRet);
}

/*****************************************************************************

    CWiaEventsPage::OnDestroy

    Clean up stuff that requires our hwnd

*****************************************************************************/

void
CWiaEventsPage::OnDestroy()
{
    DoDelete(m_pAppsList);
}

/*****************************************************************************

    GetSelectedHandler

    Retrieve the WIA_EVENT_HANDLER info from the listbox for the current
    selection

*****************************************************************************/
bool
GetSelectedHandler (HWND hDlg, INT idCtrl, WIA_EVENT_HANDLER &weh)
{

    bool bRet = false;
    COMBOBOXEXITEM cbex;

    TraceEnter (TRACE_PROPUI, "GetSelectedHandler");
    ZeroMemory (&weh, sizeof(weh));
    ZeroMemory (&cbex, sizeof(cbex));
    cbex.mask = CBEIF_LPARAM;
    cbex.iItem = SendDlgItemMessage (hDlg,
                                     idCtrl,
                                     CB_GETCURSEL,
                                     0,0);
    if (cbex.iItem >=0)
    {
        SendDlgItemMessage (hDlg,
                            idCtrl,
                            CBEM_GETITEM,
                            0,
                            reinterpret_cast<LPARAM>(&cbex));
        if (cbex.lParam)
        {
            weh = *(reinterpret_cast<WIA_EVENT_HANDLER*>(cbex.lParam));
            bRet = true;
        }
    }

    TraceLeave ();
    return bRet;
}



/*****************************************************************************

     AddIconToImageList

     Load the icon indicated by bstrIconPath and add it to himl

*****************************************************************************/

bool
AddIconToImageList (HIMAGELIST himl, BSTR bstrIconPath)
{
    bool bRet = false;
    TraceEnter (TRACE_PROPUI, "AddIconToImageList");

    CSimpleString strPath;
    LONG  nIcon;
    HICON hIcon = NULL;
    HICON hUnused;
    HRESULT hr;
    CSimpleStringWide strIconPath = bstrIconPath;
    int nComma = strIconPath.ReverseFind(L",");

    if (nComma >= 0)
    {
        nIcon = wcstol (bstrIconPath+nComma+1, NULL, 10);
        strPath = CSimpleStringConvert::NaturalString(strIconPath.SubStr(0, nComma));
        Trace (TEXT("icon path is %s, %d"), strPath.String(), nIcon);
        hr = SHDefExtractIcon (strPath, nIcon, 0, &hUnused, &hIcon, 0);
        Trace(TEXT("SHDefExtractIcon returned %x"), hr);
        if (SUCCEEDED(hr) && hIcon)
        {
            ImageList_AddIcon (himl, hIcon);
            DestroyIcon(hIcon);
            DestroyIcon(hUnused);
            bRet = true;
        }
    }

    TraceLeave ();
    return bRet;
}

/*****************************************************************************

    SetAppSelection

    Given a clsid, find it in the app combobox and select it

*****************************************************************************/

void
SetAppSelection (HWND hDlg, INT idCtrl, CLSID &clsidSel)
{
    TraceEnter (TRACE_PROPUI, "SetAppSelection");
    COMBOBOXEXITEM cbex;
    WIA_EVENT_HANDLER *peh;
    HWND hCombo = GetDlgItem (hDlg, idCtrl);
    LRESULT lItems = SendMessage (hCombo,
                                  CB_GETCOUNT,
                                  0,0);
    cbex.mask = CBEIF_LPARAM;

    for (cbex.iItem=0;cbex.iItem < lItems;cbex.iItem++)
    {
        cbex.lParam = NULL;
        SendMessage (hCombo,
                     CBEM_GETITEM,
                     0,
                     reinterpret_cast<LPARAM>(&cbex));
        peh = reinterpret_cast<WIA_EVENT_HANDLER*>(cbex.lParam);
        if (peh)
        {
            if (IsEqualCLSID(clsidSel, peh->guid))
            {
                SendMessage (hCombo,
                             CB_SETCURSEL,
                             cbex.iItem, 0);
            }
        }
    }

    TraceLeave ();
}

/*****************************************************************************

    SetDefaultHandler

    Register the new default handler for the selected event for our item

*****************************************************************************/

HRESULT
SetDefaultHandler (IWiaItem *pItem, EVENTINFO *pei)
{
    HRESULT hr;
    TraceEnter (TRACE_PROPUI, "SetDefaultHandler");

    CComPtr<IWiaDevMgr> pDevMgr;
    WCHAR szDeviceId[STI_MAX_INTERNAL_NAME_LENGTH];
    GetDeviceIdFromDevice (pItem, szDeviceId);
    CComBSTR strDeviceId(szDeviceId);
    hr = GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr));
    if (SUCCEEDED(hr))
    {
        pDevMgr->RegisterEventCallbackCLSID (WIA_REGISTER_EVENT_CALLBACK,
                                             strDeviceId,
                                             &pei->guidEvent,
                                             &pei->clsidNewHandler,
                                             pei->strName,
                                             pei->strDesc,
                                             pei->strIcon);

        hr = pDevMgr->RegisterEventCallbackCLSID (WIA_SET_DEFAULT_HANDLER,
                                                  strDeviceId,
                                                  &pei->guidEvent,
                                                  &pei->clsidNewHandler,
                                                  pei->strName,
                                                  pei->strDesc,
                                                  pei->strIcon);
    }

    TraceLeaveResult (hr);
}

/*****************************************************************************

    GetEventInfo

    Return the current default handler and number of handlers for this event

*****************************************************************************/

void
GetEventInfo (IWiaItem *pItem, const GUID &guid, EVENTINFO **ppei)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetEventInfo");
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;
    WIA_EVENT_HANDLER weh;
    EVENTINFO *pei;
    HRESULT hr;
    pei = new EVENTINFO;
    if (pei)
    {
        ZeroMemory (pei, sizeof(EVENTINFO));
        pei->guidEvent = guid;
    }

    hr = pItem->EnumRegisterEventInfo (0,
                                       &guid,
                                       &pEnum);

    if (pei && S_OK == hr)
    {
        TraceAssert (pEnum.p);
        while (S_OK == pEnum->Next (1, &weh, 0))
        {
            pei->nHandlers++;
            if (weh.ulFlags & WIA_IS_DEFAULT_HANDLER)
            {
                pei->bHasDefault = true;
                pei->clsidHandler = weh.guid;
                pei->clsidNewHandler = weh.guid;
                pei->strCmd = weh.bstrCommandline;
            }
            // Free the enumerated strings
            SysFreeString (weh.bstrDescription);
            SysFreeString (weh.bstrIcon);
            SysFreeString (weh.bstrName);
            SysFreeString (weh.bstrCommandline);
        }
    }
    *ppei = pei;
    TraceLeave ();
}

bool CWiaEventsPage::ItemSupported(IWiaItem *pItem)
{
    bool bRet = false;
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;
    if (SUCCEEDED(pItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,
                                                  &pEnum)))
    {
        WIA_DEV_CAP wdc;
        ULONG ul = 0;
        while (!bRet && S_OK == pEnum->Next(1, &wdc, &ul))
        {
            bRet =  ((wdc.ulFlags & WIA_ACTION_EVENT) > 0);
            SysFreeString (wdc.bstrCommandline);
            SysFreeString (wdc.bstrDescription);
            SysFreeString (wdc.bstrIcon);
            SysFreeString (wdc.bstrName);            
        }
    }
    return bRet;
}

CDevicePage::CDevicePage (unsigned uResource, IWiaItem *pItem , const DWORD *pHelpIDs) :
    CPropertyPage (uResource, NULL, pItem, pHelpIDs)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\prpages.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       prpages.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        11/9/99
 *
 *  DESCRIPTION: WIA Property pages classes
 *
 *****************************************************************************/
#ifndef __PRPAGES_H_
#define __PRPAGES_H_
#include "wiacsh.h"


//
// Defines for using WiaCreatePorts & WiaDestroyPorts
//
// These were stolen from exports.h in printscan\wia\setup\clsinst
//

typedef struct _WIA_PORTLIST {

    DWORD   dwNumberOfPorts;
    LPWSTR  szPortName[1];

} WIA_PORTLIST, *PWIA_PORTLIST;


typedef PWIA_PORTLIST (CALLBACK *PFN_WIA_CREATE_PORTLIST)  (LPWSTR        szDeviceId);
typedef void          (CALLBACK *PFN_WIA_DESTROY_PORTLIST) (PWIA_PORTLIST pWiaPortList);

struct MySTIInfo
{
    PSTI_DEVICE_INFORMATION psdi;
    DWORD                   dwPageMask; // which pages to add
    VOID                    AddRef () {InterlockedIncrement(&m_cRef);};
    VOID                    Release () {
                                        InterlockedDecrement(&m_cRef);
                                        if (!m_cRef) delete this;
                                       };
    MySTIInfo () { m_cRef = 1;};
private:
    LONG                    m_cRef;
    ~MySTIInfo () {if (psdi) LocalFree (psdi);};
};


class CPropertyPage {

    //  Dialog procedure

    static INT_PTR CALLBACK    DlgProc(HWND hwnd, UINT uMsg, WPARAM wp,
                                    LPARAM lp);
private:
    BOOL m_bInit;
    static UINT PropPageCallback (HWND hwnd, UINT uMsg, PROPSHEETPAGE *psp);
    const DWORD *m_pdwHelpIDs;

protected:

    HWND                    m_hwnd, m_hwndSheet;
    PROPSHEETPAGE           m_psp;
    HPROPSHEETPAGE          m_hpsp;
    LONG                    m_cRef;
    PSTI_DEVICE_INFORMATION m_psdi;
    CComPtr<IWiaItem>       m_pItem;
    MySTIInfo              *m_pDevInfo;
    virtual                ~CPropertyPage();
    void                    EnableApply ();
    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strUIClassId;

public:


    CPropertyPage(unsigned uResource, MySTIInfo *pDevInfo, IWiaItem *pItem = NULL, const DWORD *pHelpIDs=NULL);
    LONG    AddRef ();
    LONG    Release ();

    HRESULT AddPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, bool bUseName = false);

    BOOL    Enroll(PROPSHEETHEADER& psh) {
        if   (!m_hpsp)
            m_hpsp = CreatePropertySheetPage(&m_psp);

        if  (!m_hpsp)
            return  FALSE;

        psh.phpage[psh.nPages++] = m_hpsp;
        return  TRUE;
    }

    inline VOID SetWindow(HWND hwnd) {m_hwnd = hwnd;}
    inline VOID SetWndSheet(HWND hwnd) {m_hwndSheet = hwnd;}

    //  virtual functions to give subclasses control
    virtual VOID OnHelp (WPARAM wp, LPARAM lp) {if (0xffff != LOWORD(reinterpret_cast<HELPINFO*>(lp)->iCtrlId)) WiaHelp::HandleWmHelp(wp, lp, m_pdwHelpIDs);};
    virtual VOID OnContextMenu (WPARAM wp, LPARAM lp) {if (65535 != GetWindowLong(reinterpret_cast<HWND>(wp), GWL_ID)) WiaHelp::HandleWmContextMenu (wp, lp, m_pdwHelpIDs);};

    virtual bool ItemSupported (IWiaItem *pItem) {return true;};
    virtual INT_PTR OnInit() { return   TRUE; }

    virtual INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem) { return  FALSE; }

    virtual LONG    OnSetActive() { return  0L; }

    virtual LONG    OnApplyChanges(BOOL bHitOK) {return PSNRET_NOERROR;}

    virtual LONG    OnKillActive() {return FALSE;}

    virtual LONG    OnQueryCancel() {return FALSE;}
    virtual VOID    OnReset(BOOL bHitCancel) {};

    virtual void    OnDrawItem(LPDRAWITEMSTRUCT lpdis) { return; }
    virtual INT_PTR OnRandomMsg(UINT msg, WPARAM wp, LPARAM lp) {return 0;};
    virtual bool    OnNotify(LPNMHDR pnmh, LRESULT *presult) {return false;};
    // Sheets that allow the user to change settings need to implement these
    // functions for proper Apply button management.
    virtual void    SaveCurrentState () {}
    virtual bool    StateChanged () {return false;}
    virtual void    OnDestroy () {};
};

class CDevicePage : public CPropertyPage
{
    public:

        CDevicePage(unsigned uResource, IWiaItem *pItem , const DWORD *pHelpIDs);
};

class CWiaScannerPage : public CDevicePage
{
    public:
        CWiaScannerPage (IWiaItem *pItem);
        INT_PTR OnInit ();
        INT_PTR OnCommand (WORD wCode, WORD widItem, HWND hwndItem);
};

class CWiaCameraPage : public CDevicePage
{
    public:
        CWiaCameraPage (IWiaItem *pItem);
        ~CWiaCameraPage ();
        INT_PTR OnInit ();
        INT_PTR OnCommand (WORD wCode, WORD widItem, HWND hwndItem);
        void    SaveCurrentState ();
        bool    StateChanged ();
        INT_PTR OnRandomMsg (UINT msg, WPARAM wp, LPARAM lp);
        LONG    OnApplyChanges (BOOL bHitOK);

    private:

        VOID UpdatePictureSize (IWiaPropertyStorage *pps);
        HRESULT WriteImageSizeToDevice ();
        VOID UpdateImageSizeStatic (LRESULT lIndex);
        HRESULT WriteFlashModeToDevice ();
        HRESULT WritePortSelectionToDevice();


        POINT *m_pSizes;      // sorted list of supported resolutions
        size_t    m_nSizes;   // the length of m_pSizes;
        LRESULT   m_nSelSize; // which size is selected in the slider
        LRESULT   m_lFlash;   // which flash mode is selected. Set to -1 if read-only
        HMODULE   m_hStiCi;

    public:

        PFN_WIA_CREATE_PORTLIST  m_pfnWiaCreatePortList;
        PFN_WIA_DESTROY_PORTLIST m_pfnWiaDestroyPortList;
        CSimpleString m_strPort; // hold initial port setting
        CSimpleString m_strPortSpeed;

};


class CWiaFolderPage  : public CPropertyPage
{
    public:
        CWiaFolderPage (IWiaItem *pItem);
};

class CWiaCameraItemPage  : public CPropertyPage
{
    public:
        CWiaCameraItemPage (IWiaItem *pItem);

        INT_PTR OnInit ();
        bool ItemSupported (IWiaItem *pItem);
};

//
// This struct holds per-item data for each event in the event list.
// The data uses CLSIDs, not offsets into the app listbox, to avoid
// dependency problems in the future.
//
struct EVENTINFO
{
    GUID guidEvent;
    INT   nHandlers;      // number of entries in the apps listbox
    bool  bHasDefault;    // whether it already has a default handler
    bool  bNewHandler;    // set when clsidNewHandler is filled in
    CLSID clsidHandler;   // current default handler
    CLSID clsidNewHandler;// current selection in the app listbox
    CComBSTR strIcon;
    CComBSTR strName;
    CComBSTR strDesc;
    CComBSTR strCmd;
    ULONG ulFlags;
};
LRESULT WINAPI MyComboWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

class CAppListBox
{
public:
    CAppListBox (HWND hList, HWND hStatic, HWND hNoApps);

    UINT FillAppListBox (IWiaItem *pItem, EVENTINFO *pei);
    void FreeAppData ();
    ~CAppListBox();
private:
    HIMAGELIST m_himl;
    HWND m_hwnd;
    HWND m_hstatic;
    HWND m_hnoapps;
    WNDPROC m_ProcOld;

};




class CWiaEventsPage : public CPropertyPage
{
    public:
        CWiaEventsPage (IWiaItem *pItem);
        ~CWiaEventsPage();
        INT_PTR OnInit();
        LONG OnApplyChanges(BOOL bHitOK);
        INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
        void    SaveCurrentState ();
        bool    StateChanged();
        bool    ItemSupported(IWiaItem *pItem);
        bool    OnNotify(LPNMHDR pnmh, LRESULT *presult);
        void    OnDestroy();

    private:
        void FillEventListBox();

        void GetEventFromList(LONG idx, EVENTINFO **ppei);
        INT_PTR HandleEventComboNotification(WORD wCode, HWND hCombo);
        INT_PTR HandleAppComboNotification(WORD wCode, HWND hCombo);
        bool RegisterWiaxfer(bool bRegister);
        void GetSavePath();
        void UpdateWiaxferSettings();
        DWORD GetConnectionSettings();
        void EnableAutoSave(BOOL bEnable);
        LONG ApplyAutoSave();
        void SaveConnectState();
        void CWiaEventsPage::VerifyCurrentAction(DWORD &dwAction);
        TCHAR m_szFolderPath[MAX_PATH];
        BOOL  m_bAutoDelete;
        BOOL  m_bUseDate;
        bool  m_bHandlerChanged; // determines if Apply should be enabled
        DWORD m_dwAction; // what to do for device connect
        CAppListBox *m_pAppsList;
        HIMAGELIST m_himl;
        BOOL  m_bReadOnly;
};

// helper functions
UINT FillAppListBox (HWND hDlg, INT idCtrl, IWiaItem *pItem, EVENTINFO *pei);
bool GetSelectedHandler (HWND hDlg, INT idCtrl, WIA_EVENT_HANDLER &weh);
void FreeAppData (HWND hDlg, INT idCtrl);
bool AddIconToImageList (HIMAGELIST himl, BSTR strIconPath);
void SetAppSelection (HWND hDlg, INT idCtrl, CLSID &clsidSel);
HRESULT SetDefaultHandler (IWiaItem *pItem, EVENTINFO *pei);
void GetEventInfo (IWiaItem *pItem, const GUID &guid, EVENTINFO **ppei);
LPWSTR ItemNameFromIndex (int i);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\stiprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stiprop.h
//
//--------------------------------------------------------------------------


BOOL IsPnPDevice(PSTI_DEVICE_INFORMATION psdi, CSimpleString *szConnection = NULL);
HANDLE SelectDevInfoFromFriendlyName(const CSimpleStringWide &pszLocalName);
HRESULT GetSti ();

class CSTIPropertyPage : public CPropertyPage
{
public:
    CSTIPropertyPage (unsigned uResource, MySTIInfo *pDevInfo, IWiaItem *pItem=NULL) :
        CPropertyPage (uResource, pDevInfo, pItem)
    {
        // Make sure STI is loaded
        GetSti ();
    }

    VOID OnHelp (WPARAM wp, LPARAM lp);
    VOID OnContextMenu (WPARAM wp, LPARAM lp);

};
class CSTIGeneralPage : public CSTIPropertyPage
{

public:

    CSTIGeneralPage(MySTIInfo *pDevInfo, BOOL pnp) :
      CSTIPropertyPage(pnp ? IDD_GENERAL_PAGE : IDD_GENERALPNP_PAGE, pDevInfo, NULL) {m_bIsPnP = pnp;}

    INT_PTR    OnInit();
    INT_PTR    OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG    OnApplyChanges(BOOL bHitOK);
    BOOL    BuildPortList (HWND hwndParent, UINT CtrlId);
    UINT    GetDeviceStatus (void);

    BOOL            m_bIsPnP;
    CSimpleString m_szConnection;
};

/*
class CLoggingPage : public CPropertyPage
{

public:

    HKEY            m_hkThis;

    CLoggingPage();
    ~CLoggingPage();

    VOID FillLoggerList(HWND hwnd,UINT  id);

    INT_PTR    OnInit();
    INT_PTR    OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    INT_PTR    OnNotify(UINT uCode, LPNMHDR lpnmh);
};
*/
class CPortSettingsPage : public CSTIPropertyPage
{

    UINT m_uBaudRate;
public:

    CPortSettingsPage(MySTIInfo *pDevInfo) :
      CSTIPropertyPage(IDD_SERIAL_PORT_SETTS_PAGE, pDevInfo) { }

    INT_PTR  OnInit();
    INT_PTR  OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG     OnApplyChanges(BOOL bHitOK);
    //BOOL    BuildPortList (HWND hwndParent, UINT CtrlId);
    UINT BuildBaudRateList(HWND hwndParent,UINT CtrlId);

    BOOL    IsNeeded(VOID);
};

class CIdMatrix
{

    LPBYTE          m_lpMatrix;
    UINT            m_uiCount;

public:

    CIdMatrix() {m_lpMatrix=NULL; m_uiCount = 0;}

    ~CIdMatrix() {if (m_lpMatrix) delete m_lpMatrix;}

    void    SetCount(UINT uic) {

        if (!uic)
            return;

        if (m_lpMatrix)
            delete m_lpMatrix;

        m_lpMatrix = new BYTE[uic + 1];
        m_uiCount = uic;

        return;

    }

    void    Clear(void) {

        if (!m_lpMatrix)
            return;

        for (UINT i = 0; i < (m_uiCount + 1); i++)
            *(m_lpMatrix + i) = 0 ;

        return;
    }

    void    Set(void) {

        if (!m_lpMatrix)
            return;

        for (UINT i = 0; i < (m_uiCount + 1); i++)
            *(m_lpMatrix + i) = 1 ;

        return;
    }

    void    Toggle(UINT Idx) {

        if (!m_lpMatrix || Idx > m_uiCount)
            return;

        LPBYTE lpb = &m_lpMatrix[Idx ];
        *lpb ^= 1;
        return;

    }

    BOOL    IsSet(UINT Idx)  {

        if (!m_lpMatrix || Idx > m_uiCount)
            return FALSE;

        LPBYTE lpb = &m_lpMatrix[Idx];

        return *lpb ? TRUE : FALSE;

    }

    UINT    EnumIdx (UINT Idx) {

        // Idx is the last one we enumerated
        if (!m_lpMatrix || ++Idx > m_uiCount) return static_cast<UINT>(-1);

        for (; Idx <= m_uiCount; Idx++) {

            if (m_lpMatrix[Idx])
            {
                return Idx;
            }


        }

        return static_cast<UINT>(-1);
    }

};

class CEventMonitor : public CSTIPropertyPage {

    HWND            m_hwndList;
    CSimpleReg      m_hkThis;
    // BUGBUG Temporary
    CSimpleReg            m_hkThisDevice;
    BOOL            m_ListChanged;
    CIdMatrix       m_IdMatrix;
    FARPROC         m_lpfnOldProc;
    DWORD           m_dwUserDisableNotifications;

public:

    CEventMonitor(MySTIInfo *pDevInfo);



    void    SetSelectionChanged (BOOL Changed) {m_ListChanged = Changed;}
    BOOL    HasSelectionChanged (void) {return m_ListChanged;}

    void    FillListbox (HWND hwndParent, UINT CtrlId);
    BOOL    BuildEventList (HWND hwndParent, UINT CtrlId);

    UINT    DrawCheckBox (HDC hDC, RECT rcItem, BOOL Checked);

    static LRESULT CALLBACK ListSubProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    INT_PTR OnInit();
    INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG    OnApplyChanges(BOOL bHitOK);
    VOID    OnReset (BOOL bHitCancel);
    VOID    OnDrawItem(LPDRAWITEMSTRUCT lpdis);

    bool    StateChanged () {if (HasSelectionChanged()) return true;
                             else return false;}

private:
    static bool EventListEnumProc (CSimpleReg::CKeyEnumInfo &Info);
    static bool FillListEnumProc (CSimpleReg::CValueEnumInfo &Info);
    ~CEventMonitor();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define IDI_STIEXT                      100
#define IDI_CAMERA                      101
#define IDI_SCANNER                     102
#define IDI_UNKNOWN                     104
#define IDI_FOLDER                      105
#define IDI_ADDDEVICE                   106
#define IDI_PICTURE_BMP                 107
#define IDI_REMOTECAM                   108
#define IDI_REMOTESCAN                  109
#define IDI_SELECT                      110
#define IDI_UNSELECT                    111
#define IDI_DEFAULT                     112
#define IDI_STILL_IMAGE                 113
#define IDI_VIDEO_CAMERA                114
#define IDI_EVENT                       IDI_DEFAULT
#define IDI_STIDEVICE                   115
#define IDI_GENERIC_IMAGE               116
#define IDI_AUDIO_IMAGE                 117
#define IDI_GENERIC_AUDIO               118
#define IDI_USE_WIZARD                  119
#define IDI_TAKE_PICTURE                120
#define IDI_SHOW_PROPERTIES             130
#define IDI_DELETE_ALL_IMAGES           131

#define IDC_STATIC                       -1
#define IDS_MULTIPROP_SEL               174
#define IDS_USE_WIZARD                  175
#define IDS_TAKE_PICTURE                176
#define IDS_CAMERA_PROPERTIES           177
#define IDS_DELETE_ALL                  178
#define IDS_DEVICENAME                  200
#define IDS_DEVICECLASS                 201
#define IDS_ITEMNAME                    220
#define IDS_ITEMTYPE                    221
#define IDS_ITEMDATE                    222
#define IDS_ITEMSIZE                    223
#define IDS_BYOBJECTNAME                250
#define IDS_BYTYPE                      251
#define IDS_BYDATE                      252
#define IDS_BYSIZE                      253
#define IDS_BMP_EXT                     254
#define IDS_ADD_DEVICE                  257
#define IDS_DOWNLOADING_IMAGE           258
#define IDS_PROCESSING_IMAGE            259
#define IDS_TRANSFERRING_IMAGE          260


#define IDS_RETREIVING                  265
#define IDS_DOWNLOAD_FAILED             270
#define IDS_DOWNLOAD_CAPTION            271
#define IDS_ON                          272
#define IDS_YES                         273
#define IDS_NO                          274
#define IDS_CAMERADEVICE                275
#define IDS_SCANNERDEVICE               276
#define IDS_UNKNOWNDEVICE               277

#define IDS_AUDIOITEM                   279
#define IDS_FOLDER                      280
#define IDS_UNKNOWNTYPE                 281
#define IDS_TITLECONFIRM                282
#define IDS_TITLECONFIRM_MULTI          283
#define IDS_CONFIRM                     284
#define IDS_CONFIRM_MULTI               285
#define IDS_TITLECONFIRM_FOLDER         286
#define IDS_CONFIRM_FOLDER              287
#define IDS_ADDWIZARDFAILED             289
#define IDS_OPERATIONAL                 290
#define IDS_OFFLINE                     296
#define IDS_TRANSFERRING                299
#define IDS_UNAVAILABLE                 304
#define IDS_BROWSER_TITLE               305
#define IDS_DIAGNOSTIC_FAILED           306
#define IDS_DIAGNOSTIC_SUCCESS          307
#define IDS_SUCCESS                     308
#define IDS_NO_SUCCESS                  309
#define IDS_CAMERA_EVENTS               310
#define IDS_SCANNER_EVENTS              311
#define IDS_SCANNER_CLIENT              312
#define IDS_TSHOOT_CMD                  313
#define IDS_CONFIRM_REMOVAL             314
#define IDS_REMOVAL_MESSAGE             315
#define IDS_USER_NOT_ADMIN              316
#define IDS_SCNAME                      317
#define IDS_NO_EVENTS                   318
#define IDS_NO_APPS                     319
#define IDS_OTHER_FORMAT                320
#define IDS_NO_WIAXFER                  322
#define IDS_NO_APP_SELECTED             323
#define IDS_NO_SCAN_CAPTION             324
#define IDS_NO_WIAXFER_CAPTION          325
#define IDS_INVALID_PATH_CAPTION        326
#define IDS_INVALID_PATH                327
#define IDS_SAVEPATH_CAPTION            328
#define IDS_ADDDEV_DESC                 329
#define IDS_FOLDER_DESC                 330
#define IDS_DISPLAYNAME                 331 // this value is referenced in the inf
#define IDS_WIACAM_INFOTIP              332
#define IDS_WIASCAN_INFOTIP             333
#define IDS_STIDEVICE_INFOTIP           334
#define IDS_PLAYINGSOUND                335
#define IDS_WIAVID_INFOTIP              336
#define IDS_INVALIDNAME_TITLE           337
#define IDS_INVALIDNAME                 338
#define IDS_TITLECONFIRM_DEVICE         339
#define IDS_WAVEFILE                    340
#define IDS_MPFILE                      341
#define IDS_TEST_UNAVAIL                342
#define IDS_REGISTER_FAILED_TITLE       343
#define IDS_REGISTER_FAILED             344
#define IDS_SNAPSHOTCAPTION             345
#define IDS_SNAPSHOTERR                 346
#define IDS_PICTURE_COUNT               347
#define IDS_PLUGGED_IN                  348
#define IDS_ON_BATTERY                  349
#define IDS_FLASHMODE_AUTO              350
#define IDS_FLASHMODE_OFF               351
#define IDS_FLASHMODE_FILL              352
#define IDS_FLASHMODE_REDEYE_AUTO       353
#define IDS_FLASHMODE_REDEYE_FILL       354
#define IDS_FLASHMODE_EXTERNALSYNC      355
#define IDS_FLASHMODE_DEVICE            356
#define IDS_TAKEN                       357
#define IDS_REMAIN                      358
#define IDS_SAVE_MYPICS                 359
#define IDS_COMMUNICATING_CAPTION       360
#define IDS_COMMUNICATING_WAITING       361
#define IDS_COMMUNICATING_BUSY          362
#define IDS_TITLEDELETE_ERROR           363
#define IDS_DELETE_ERROR                364
#define IDS_NO_SCAN                     365
#define IDS_WIZARD                      366
#define IDS_WIZARD_TYPE                 367

#define IDR_CAMERAITEMS                 369
#define IDR_ARRANGE                     370

#define IDR_CAMERA                      375
#define IDR_SCANNER                     377

#define IDS_CANT_INSTALL                380
#define IDS_PRIVILEGE_CAPTION           381
#define IDC_FORCE_ENUM                  401
#define IDD_GENERALPNP_PAGE             402
#define IDD_GENERAL_PAGE                403
#define IDD_EVENT_MONITOR               404
#define IDD_GENERAL                     405



#define IDD_IMAGE_GENERAL               525
#define IDC_STATIC_NAME                 526
#define IDC_STATIC_SIZE                 527
#define IDC_STATIC_DATE                 528
#define IDC_STATIC_FORMAT               529
#define IDC_IMAGE_NAME                  530
#define IDC_IMAGE_SIZE                  531
#define IDC_IMAGE_DATE                  532
#define IDC_IMAGE_FORMAT                533
#define IDC_STATIC_TIME                 534
#define IDC_IMAGE_TIME                  535
#define IDC_STATIC_CONTAINS             536
#define IDC_IMAGE_CONTAINS              537

#define IDD_CONTAINER_GENERAL           550

#define IDC_WIA_PORT_STATIC             574
#define IDD_CAMERA_GENERAL              575
#define IDC_DESCRIPTION                 576
#define IDC_ITEMICON                    577
#define IDC_TIME_LABEL                  578
#define IDC_WIA_PORT_LIST               579
#define IDC_TAKEN_LABEL                 580
#define IDC_MANUFACTURER                581
#define IDC_TAKEN                       582
#define IDC_FLASH_LABEL                 583
#define IDC_FLASH_MODE_STATIC           584
#define IDC_FLASH_MODE_LIST             585
#define IDC_BATTERY_LABEL               586
#define IDC_BATTERY                     587
#define IDC_SET_TIME                    588
#define IDC_CURRENT_TIME                589
#define IDC_IMAGESIZE_SLIDER            590
#define IDC_IMAGESIZE_STATIC            591
#define IDC_TESTCAM                     592
#define IDC_LOW_QUALITY                 593
#define IDC_HIGH_QUALITY                594
#define IDC_PORT_SPEED_LABEL            595
#define IDC_PORT_SPEED                  596
#define IDC_MANUFACTURER_LABEL          597


#define IDD_SCANNER_GENERAL             700
#define IDC_STATUS_LABEL                701
#define IDC_DEVICE_STATUS               702


#define IDD_CAMERA_CONNECT              750
#define IDB_RUNAPP                      751
#define IDB_DONOTHING                   753
#define IDC_PORT_LABEL                  754
#define IDC_RESOLUTION_LABEL            755
#define IDC_RESOLUTION                  756
#define IDC_TESTSCAN                    757

#define IDD_WIA_EVENTS                  800
#define IDC_WIA_EVENT_LIST              801
#define IDC_WIA_APPS                    802
#define IDB_LAUNCHAPP                   803
#define IDC_PROMPT                      804
#define IDC_NOACTION                    805
#define IDB_QUIETSAVE                   806
#define IDC_SELECTTEXT                  752
#define IDC_NOEVENTS                    807
#define IDC_SELECTEDAPP                 754
#define IDC_FOLDERPATH                  755
#define IDB_BROWSE                      756
#define IDB_DELETEONSAVE                757
#define IDB_USEDATE                     758

#define IDC_DEVICE_LIST                 1000

#define IDD_INTRO_TEXT                  1001


#define IDC_SCANNER_ICON                1004
#define IDC_CURRENT_DEFAULT             1005
#define IDC_BUTTON_TEST                 1006
#define IDC_DEVICE_ICON                 1007
#define IDC_FRIENDLY                    1008
#define IDC_MAKER                       1009
#define IDC_DESCRIBE                    1010
#define IDC_CAP_ADF                     1011
#define IDC_PORT_NAME                   1012
#define IDC_TWAIN_DS                    1013
#define IDC_PUSHBUTTON                  1014

#define IDC_TEST_BUTTON                 1019
#define IDC_ONLINE                      1020
#define IDC_OTHER_STATUS                1022
#define IDC_EVENT_LIST                  1023
#define IDC_EVENT_TEXT                  1024
#define IDC_COMMAND                     1025
#define IDC_BROWSE_BUTTON               1026
#define IDC_APP_LIST                    1028
#define IDC_CHECK_DISABLE_EVENTS        1041


#define IDC_COM_SETTINGS                1044

#define IDD_XFERSOUND                   1050
#define IDC_SNDSTATUS                   1051

#define IDD_TAKEPICTURE                 1100

#define IDD_SERIAL_PORT_SETTS_PAGE      1710
#define IDD_PORT_SETTS_PAGE             1711
#define IDC_BAUDRATE_COMBO              1711

#define IDS_SCANCAM_INTRO               2000
#define IDS_SCANCAM_NOSELTEXT           2001
#define IDS_SCANCAM_GETPIX              2002
#define IDS_SCANCAM_PROPERTIES          2003
#define IDS_SCANCAM_TASKS_HEADER        2004
#define IDS_CAMERA_TASKS_HEADER         2005
#define IDS_SCANCAM_TASKS_HEADER_TIP    2006
#define IDS_SCANCAM_ADDDEVICE_TIP       2007
#define IDS_SCANCAM_GETPIX_TIP          2008
#define IDS_SCANCAM_PROPERTIES_TIP      2009

#define IDS_WIACAM_MYCOMP_INFOTIP       2010
#define IDS_TIME_ERR_TITLE              2020
#define IDS_TIME_ERR                    2021

//
// Defines for camera item context menu id's
//
#define IMID_CI_FIRST       (0)
#define IMID_CI_PREVIEW     (IMID_CI_FIRST + 00)
#define IMID_CI_MYPICS      (IMID_CI_FIRST + 01)
#define IMID_CI_PLAYSND     (IMID_CI_FIRST + 07)
#define IMID_CI_SAVESND     (IMID_CI_FIRST + 8)
#define IMID_CI_PRINT       (IMID_CI_FIRST + 13)
//
// Defines for camera context menu id's
//

#define IMID_C_TAKE_PICTURE (IMID_CI_FIRST +9)
#define IMID_C_WIZARD       (IMID_CI_FIRST +10)
//
// scanner context menu

#define IMID_S_ACQUIRE  (IMID_CI_FIRST + 11)
#define IMID_S_WIZARD   (IMID_CI_FIRST + 12)


// IDs for menuhelp/status bar text

#define IDS_MH_IDFIRST    0x1200
#define SFVIDS_MH_PREVIEW   (IDS_MH_IDFIRST+IMID_CI_PREVIEW)
#define SFVIDS_MH_MYPICS    (IDS_MH_IDFIRST+IMID_CI_MYPICS)
#define SFVIDS_MH_PLAYSND   (IDS_MH_IDFIRST+IMID_CI_PLAYSND)
#define SFVIDS_MH_SAVESND   (IDS_MH_IDFIRST+IMID_CI_SAVESND)
#define SFVIDS_MH_TAKEPICTURE   (IDS_MH_IDFIRST+IMID_C_TAKE_PICTURE)
#define SFVIDS_MH_ACQUIRE   (IDS_MH_IDFIRST+IMID_S_ACQUIRE)
#define SFVIDS_MH_CWIZARD    (IDS_MH_IDFIRST+IMID_C_WIZARD)
#define SFVIDS_MH_SWIZARD    (IDS_MH_IDFIRST+IMID_S_WIZARD)
#define SFVIDS_MH_PUBLISH    (IDS_MH_IDFIRST+IMID_CI_PUBLISH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

USE_SHFUSION=1

!include          $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#NO_BROWSER_FILE = 1
TARGETNAME      = wiashext
TARGETTYPE      = DYNLINK
TARGETPATH      = obj
TARGETEXT       = dll
TARGETPATHLIB   = $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)
DLLDEF          = ..\wiashext.def
DLLENTRY        = _DllMainCRTStartup
DLLBASE         = 0x77000000
USE_MSVCRT      = 1
C_DEFINES       = $(C_DEFINES) -DWIA_DONT_DO_LEAK_CHECKS
ATL_VER         = 30
USE_STATIC_ATL  = 1
TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                                  \
        $(SHELL_LIB_PATH)\shdocvw.lib                                   \
        $(PROJECT_ROOT)\ui\shellext\lib\$(PLATFORM_SUFFIX)\$(O)\common.lib \
        $(SDK_LIB_PATH)\wininet.lib

DELAYLOAD=winmm.dll;setupapi.dll;sti.dll
          
DLOAD_ERROR_HANDLER=kernel32

INCLUDES=   $(INCLUDES);                     \
            $(PROJECT_ROOT)\ui\shellext\inc; \
            $(PROJECT_ROOT)\ui\shellext\src;\
            $(PROJECT_ROOT)\ui\shellext\src\res             

SOURCES=\
        ..\resource.rc     \
        ..\baseview.cpp    \
        ..\dataobj2.cpp    \
        ..\details.cpp     \
        ..\dll.cpp         \
        ..\enum.cpp        \
        ..\factory.cpp     \
        ..\folder.cpp      \
        ..\icon.cpp        \
        ..\image.cpp       \
        ..\idlist.cpp      \
        ..\moniker.cpp     \
        ..\progcb.cpp      \
        ..\propui.cpp      \
        ..\stream.cpp      \
        ..\util.cpp        \
        ..\verbs.cpp       \
        ..\stiprop.cpp     \
        ..\prpages.cpp     \
        ..\tls.cpp
               

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=wiashext.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\stream.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       stream.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: CImageStream defintion
 *
 *****************************************************************************/

#ifndef __stream_h
#define __stream_h

class CImageStream : public IStream, IWiaDataCallback, CUnknown
{
    private:
        HANDLE                  m_hThread;
        ULONG                   m_ulReadPos;
        ULONG                   m_ulWritePos;
        LONG                    m_bFirstTransfer;
        ULONG                   m_ulSize;
        BOOL                    m_bProgress;

        ~CImageStream( );

        HRESULT InitItem ();
        HRESULT _InitWorker();
    public:
        LONG                    m_bTransferred;
        LPITEMIDLIST            m_pidl;
        LPITEMIDLIST            m_pidlFull;
        LPVOID                  m_pBuffer;
        GUID                    m_guidFormat;

        CComPtr<IWiaProgressDialog> m_pWiaProgressDialog;
        HRESULT                 m_hResultDownload; // status of current download
        HANDLE                  m_hEventStart; // handle to set when download starts
        DWORD                   m_dwCookie;
        CComPtr<IGlobalInterfaceTable> m_pgit;


    public:
        CImageStream( LPITEMIDLIST pidlFull,
                      LPITEMIDLIST pidl,
                      BOOL bShowProgress = FALSE);


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IStream
        STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
        STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
        STDMETHOD(Commit)(DWORD grfCommitFlags);
        STDMETHOD(Revert)(void);
        STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
        STDMETHOD(Clone)(IStream **ppstm);

        // ISequentialStream
        STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

        // IWiaDataCallback
        STDMETHOD(BandedDataCallback) (LONG lMessage,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbData);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\stiprop.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       stiprop.cpp
 *
 *  VERSION:     2.0
 *
 *  AUTHOR:      VladS/DavidShi
 *
 *  DATE:        ??
 *
 *  DESCRIPTION: code which displays properties of STI devices
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

#include <windowsx.h>
#include    <setupapi.h>
#ifdef _TEXT
    #undef _TEXT
#endif
#include    <tchar.h>

#include <devguid.h>
extern "C" {
#ifdef ADD_ICM_UI

    #include <shlguid.h>
    #include <shlobjp.h>
    #include <shlwapi.h>
#endif
}
#include    <stiapi.h>

#include "stiprop.h"


// This definition comes from stici.h (STI Class installer)
#define MAX_DESCRIPTION     64
#define PORTS               TEXT("Ports")
#define PORTNAME            TEXT("PortName")
#define SERIAL              TEXT("Serial")
#define PARALLEL            TEXT("Parallel")
#define AUTO                TEXT("AUTO")

#define STI_SERVICE_NAME            TEXT("StiSvc")
#define STI_SERVICE_CONTROL_REFRESH 130

#define BIG_ENOUGH 256

// Some Useful macro
#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
    #define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define UToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
    #define TToU AToU
    #define UToT UToA
#endif


#define ADD_ICM_UI
// #define USE_SHELLDLL
DWORD aInfoPageIds[] = {

    IDC_TEST_BUTTON,            IDH_WIA_TEST_BUTTON,
    IDC_FRIENDLY,               IDH_WIA_FRIENDLY,
    IDC_MAKER,                  IDH_WIA_MAKER,
    IDC_DESCRIBE,               IDH_WIA_DESCRIBE,
    IDC_PORT_NAME,              IDH_WIA_PORT_NAME,
    IDC_EVENT_LIST,             IDH_WIA_EVENT_LIST,
    IDC_APP_LIST,               IDH_WIA_APP_LIST,
    IDC_COM_SETTINGS,           IDH_WIA_PORT_NAME,
    IDC_PORT_NAME,              IDH_WIA_PORT_NAME,
    //IDC_BAUDRATE_COMBO,         IDH_WIA_BAUD_RATE,
    0,0
};
//#include    "sticp.h"

static CComPtr<IStillImage> g_pSti;


BOOL
SendRefreshToStiMon(
                   VOID
                   );

#define MINIY       16
#define MINIX       16


typedef struct _DEVICEEVENT
{

    CSimpleString LaunchApplications;
    CSimpleString Description;
    DWORD          Launchable;
    CSimpleReg    hKeyEvent;
    GUID    Guid;


} DEVICEEVENT, *PDEVICEEVENT;

#define STR_HELPFILE TEXT("camera.hlp")
/*****************************************************************************

    CSTIPropertyPage::OnHelp
    CSTIPropertyPage::OnContextMenu

    Handle help commands

*****************************************************************************/
VOID
CSTIPropertyPage::OnHelp(WPARAM wp, LPARAM lp)
{
    if (0xffff != LOWORD(reinterpret_cast<LPHELPINFO>(lp)->iCtrlId))
    {

        WinHelp (reinterpret_cast<HWND>(reinterpret_cast<LPHELPINFO>(lp)->hItemHandle),
                 STR_HELPFILE,
                 HELP_WM_HELP,
                 reinterpret_cast<ULONG_PTR>(aInfoPageIds));
    }
}

VOID
CSTIPropertyPage::OnContextMenu(WPARAM wp, LPARAM lp)
{
    WinHelp (reinterpret_cast<HWND>(wp),
             STR_HELPFILE,
             HELP_CONTEXTMENU,
             reinterpret_cast<ULONG_PTR>(aInfoPageIds));

}
/*****************************************************************************

   GetSti

   Helper function to init IStillImage

 *****************************************************************************/


HRESULT GetSti ()
{
    HRESULT hr = S_OK;
    if (!g_pSti)
    {
        hr = ::StiCreateInstance (GLOBAL_HINSTANCE,
                             STI_VERSION,
                             &g_pSti,
                             NULL);
    }
    return hr;
}


/*****************************************************************************

   CSTIGeneralPage::OnInit

   Handles WM_INITDIALOG for general STI property page

 *****************************************************************************/

INT_PTR
CSTIGeneralPage::OnInit()
{

    UINT uDevStatus;



    if (!m_bIsPnP)
    {
        BuildPortList(m_hwnd, IDC_COM_SETTINGS);
    }
    HICON hIcon = LoadIcon(GLOBAL_HINSTANCE,
                           MAKEINTRESOURCE( (GET_STIDEVICE_TYPE(m_psdi -> DeviceType) == StiDeviceTypeScanner) ?
                                            IDI_SCANNER : IDI_CAMERA));

    SendDlgItemMessage(m_hwnd,
                       IDC_DEVICE_ICON,
                       STM_SETICON,
                       (WPARAM) hIcon,
                       0);

    CSimpleString csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszLocalName));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_FRIENDLY));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszVendorDescription));
    csWork.SetWindowText (GetDlgItem(m_hwnd,  IDC_MAKER));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszDeviceDescription));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_DESCRIBE));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszPortName));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_PORT_NAME));


    uDevStatus = GetDeviceStatus();
    csWork.LoadString(uDevStatus, GLOBAL_HINSTANCE);

    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_OTHER_STATUS));

    EnableWindow(GetDlgItem(m_hwnd, IDC_TEST_BUTTON),
                 (IDS_OPERATIONAL == uDevStatus));

    return  TRUE;
}


/*****************************************************************************

   CSTIGeneralPage::OnCommand

   WM_COMMAND handler -- all we need to handle is the TEST button

 *****************************************************************************/

INT_PTR
CSTIGeneralPage::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{


    if ((CBN_SELCHANGE == wCode) && (IDC_COM_SETTINGS == widItem))
    {
        // Enable Apply button
        SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
        return TRUE;
    }


    if (wCode != BN_CLICKED || widItem != IDC_TEST_BUTTON)
        return  FALSE;

    //  Attempt to create the device, and call the diagnostic routine
    PSTIDEVICE          psdThis = NULL;
    STI_DIAG            diag;

    HRESULT hr = g_pSti -> CreateDevice(m_psdi -> szDeviceInternalName,
                                        STI_DEVICE_CREATE_STATUS, &psdThis, NULL);

    if (SUCCEEDED(hr) && psdThis)
    {
        CWaitCursor    waitCursor;

        //
        // Need to claim device before using
        //
        hr = psdThis -> LockDevice(2000);
        if (SUCCEEDED(hr))
        {
            hr = psdThis -> Diagnostic(&diag);
            psdThis -> UnLockDevice();
        }

        psdThis -> Release();   //  We're done with it
    }
    else
    {
        hr = E_FAIL;
    }
    //
    // Display message box
    //
    if (SUCCEEDED(hr))
    {
        if (NOERROR == diag.sErrorInfo.dwGenericError )
        {

            UIErrors::ReportMessage(m_hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_SUCCESS),
                                    MAKEINTRESOURCE(IDS_SUCCESS),
                                    MB_ICONINFORMATION);

        }
        else
        {

            UIErrors::ReportMessage(m_hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                    MAKEINTRESOURCE(IDS_NO_SUCCESS),
                                    MB_ICONSTOP);

        }
    }
    else
    {

        UIErrors::ReportMessage(m_hwnd,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                MAKEINTRESOURCE(IDS_TEST_UNAVAIL),
                                MB_ICONSTOP);

    }

    return  TRUE;
}


/*****************************************************************************

   CSTIGeneralPage::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CSTIGeneralPage::OnApplyChanges (BOOL bHitOK)
{
    if (m_bIsPnP)
    {
        return PSNRET_NOERROR;
    }
    CSimpleString szText;
    WCHAR szPortName[BIG_ENOUGH];
    STI_DEVICE_INFORMATION l_sdi;
    extern HWND g_hDevListDlg;
    UINT        uDevStatus;
    CSimpleString     csWork;

    l_sdi = *m_psdi;
    szText.GetWindowText (GetDlgItem (m_hwnd, IDC_COM_SETTINGS));
    lstrcpynW (szPortName, CSimpleStringConvert::WideString (szText), ARRAYSIZE(szPortName));
    l_sdi.pszPortName = szPortName;
    g_pSti->SetupDeviceParameters(&l_sdi);

//
// pszPortName is buffered locally. Originally it points system static memory
// so the pointer may be changed to point local buffer. It's safe to copy
// strings.
//
    lstrcpyW(m_psdi->pszPortName, szPortName);
    uDevStatus = GetDeviceStatus();
    csWork.LoadString(uDevStatus, GLOBAL_HINSTANCE);

    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_OTHER_STATUS));
    EnableWindow(GetDlgItem(m_hwnd, IDC_TEST_BUTTON),
                 (IDS_OPERATIONAL == uDevStatus));
    return PSNRET_NOERROR;
}


/*****************************************************************************

   CSTIGeneralPage::BuildPortList

   <Notes>

 *****************************************************************************/

BOOL
CSTIGeneralPage::BuildPortList (HWND hwndParent, UINT CtrlId)
{

    HKEY                    hkPort;
    CSimpleString           szPort;
    CSimpleString           szTemp;
    HANDLE                  hDevInfo;
    GUID                    Guid;
    DWORD                   dwRequired;
    LONG                    Idx,id,CurrentId;
    DWORD                   err;
    SP_DEVINFO_DATA         spDevInfoData;
    HWND                    hwndCombo;


//
//  Retrieve a list of all of the ports on this box
//


    dwRequired = 0;
    SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired);

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PRESENT | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        return TRUE;
    }

    hwndCombo = GetDlgItem(hwndParent, CtrlId);
    memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    szTemp = CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi->pszPortName));


//
// Clear all item in list box
//
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    CurrentId = -1;

//
// AUTO is added if capable
//

    if (m_psdi->DeviceCapabilities.dwGeneric & STI_GENCAP_AUTO_PORTSELECT)
    {
        id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                               0, (LPARAM)AUTO);
        if (!_tcsicmp(szTemp, AUTO))
        {
            CurrentId = id;
        }
    }

    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)
    {

        hkPort = SetupDiOpenDevRegKey (hDevInfo, &spDevInfoData, DICS_FLAG_GLOBAL,
                                       0, DIREG_DEV, KEY_READ);

        if (hkPort == INVALID_HANDLE_VALUE)
        {
            err = GetLastError();
            continue;
        }


        if (!szPort.Load (hkPort, PORTNAME))
        {
            err = GetLastError();
            continue;
        }

        if (_tcsstr(szPort, TEXT("COM")))
        {
            // Communications Port
            if (_tcsicmp(m_szConnection, PARALLEL))
            {
                id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                       0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
            }
            else
            {
                id = LB_ERR;
            }
        }
        else if (_tcsstr(szPort, TEXT("LPT")))
        {
            // Printer Port
            if (_tcsicmp(m_szConnection, SERIAL))
            {
                id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                       0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
            }
            else
            {
                id = LB_ERR;
            }
        }
        else
        {
            // BOTH or Unknown port
            id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                   0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
        }
        if (id != LB_ERR)
        {
            SendMessage(hwndCombo, CB_SETITEMDATA,
                        id, Idx);
        }
        if (!_tcsicmp(szTemp, szPort))
        {
            CurrentId = id;
        }
    }

    if (CurrentId == -1)
    {

        //
        // CreateFile name is not COM/LPT/AUTO. add this name to the bottom.
        //

        CurrentId = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                      0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szTemp)));
    }

    SendMessage(hwndCombo, CB_SETCURSEL, CurrentId, 0);
    SendMessage(hwndParent,
                WM_COMMAND,
                MAKELONG (CtrlId, CBN_SELCHANGE),
                reinterpret_cast<LPARAM>(hwndCombo));

    SetupDiDestroyDeviceInfoList(hDevInfo);
    return  TRUE;

}


/*****************************************************************************

   CSTIGeneralPage::GetDeviceStatus

   <Notes>

 *****************************************************************************/

UINT
CSTIGeneralPage::GetDeviceStatus (void)
{
    PSTIDEVICE          psdThis = NULL;
    STI_DEVICE_STATUS   sds;
    UINT                idMessageString;

    TraceEnter (TRACE_PROPUI, "CSTIGeneralPage::GetDeviceStatus");
    HRESULT hr = g_pSti -> CreateDevice(m_psdi -> szDeviceInternalName,
                                        STI_DEVICE_CREATE_STATUS,
                                        &psdThis,
                                        NULL);

    if (SUCCEEDED(hr) && psdThis)
    {
        CWaitCursor    waitCursor;

        //
        // Need to claim device before using
        //
        hr = psdThis -> LockDevice(2000);
        if (SUCCEEDED(hr))
        {
            ZeroMemory(&sds,sizeof(sds));
            sds.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

            hr = psdThis -> GetStatus(&sds);
            psdThis -> UnLockDevice();
        }
        else
        {
            Trace ( TEXT("Failed to lock device for GetStatus HRes=%X"),hr);
        }

        psdThis -> Release();
    }
    else
    {
        hr = E_FAIL;
        Trace (TEXT(  "Failed to Create device for GetStatus HRes=%X"),hr);
    }


    //
    // Figure out message string to display as status and load appropriate resource
    //
    idMessageString = IDS_UNAVAILABLE;

    if (SUCCEEDED(hr) )
    {
        if ( sds.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
        {
            idMessageString = IDS_OPERATIONAL;
        }
        else
        {
            idMessageString = IDS_OFFLINE;
        }
    }
    TraceLeave ();
    return idMessageString;
}


/*****************************************************************************

   CEventMonitor constructor / desctructor

   <Notes>

 *****************************************************************************/

CEventMonitor::CEventMonitor(MySTIInfo *pDevInfo) :
CSTIPropertyPage(IDD_EVENT_MONITOR, pDevInfo)
{

    CSimpleString csKey(IsPlatformNT() ? REGSTR_PATH_STIDEVICES_NT : REGSTR_PATH_STIDEVICES);
    csKey += TEXT("\\");
    csKey += CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> szDeviceInternalName));

    csKey += REGSTR_PATH_EVENTS;
    m_hkThis = CSimpleReg (HKEY_LOCAL_MACHINE, csKey, true, KEY_READ|KEY_WRITE );
}

CEventMonitor::~CEventMonitor()
{
// Unsubclass the listbox
    SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                      GWLP_WNDPROC,
                      reinterpret_cast<LONG_PTR>(m_lpfnOldProc));
}



/*****************************************************************************

   CEventMonitor::OnInit

   OnInit handler- initializes the dialog box controls

 *****************************************************************************/

INT_PTR
CEventMonitor::OnInit()
{

    // Loads and sets the right Icon.
    HICON hIcon = LoadIcon(GLOBAL_HINSTANCE, MAKEINTRESOURCE(
                                                            (GET_STIDEVICE_TYPE(m_psdi -> DeviceType) == StiDeviceTypeScanner) ?
                                                            IDI_SCANNER : IDI_CAMERA));

    SendDlgItemMessage(m_hwnd,
                       IDC_DEVICE_ICON,
                       STM_SETICON,
                       (WPARAM) hIcon,
                       0);

    // Loads the right text (depending upon device type)
    CSimpleString csEventText;

    if (GET_STIDEVICE_TYPE(m_psdi->DeviceType) == StiDeviceTypeScanner)
    {

        csEventText.LoadString(IDS_SCANNER_EVENTS, GLOBAL_HINSTANCE);

    }
    else
    {

        csEventText.LoadString(IDS_CAMERA_EVENTS, GLOBAL_HINSTANCE);

    }

    csEventText.SetWindowText (GetDlgItem (m_hwnd, IDC_EVENT_TEXT));

    //
    // Set the current state of notifications for a device .
    // Nb: We don't contact STIMON here, just read registry setting
    //
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(m_dwUserDisableNotifications);
    HRESULT hr;

    hr = g_pSti -> GetDeviceValue(m_psdi -> szDeviceInternalName,
                                  STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS,
                                  &dwType,
                                  (LPBYTE)&m_dwUserDisableNotifications,
                                  &cbData);

    if (!SUCCEEDED(hr))
    {
        m_dwUserDisableNotifications = FALSE;
    }

    CheckDlgButton(m_hwnd,IDC_CHECK_DISABLE_EVENTS,m_dwUserDisableNotifications);

    //
    // Fill the list box first so that there is something to select against
    // when we select the first item in the Combobox (CBN_SELCHANGE).
    //
    FillListbox (m_hwnd, IDC_APP_LIST);

    // Put up the friendly name.
    CSimpleString csWork = CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi -> pszLocalName));
    csWork.SetWindowText(GetDlgItem(m_hwnd, IDC_FRIENDLY));

    BuildEventList (m_hwnd, IDC_EVENT_LIST);

    // Select the first item in the Combobox.
    SetSelectionChanged (FALSE);
    SendMessage(m_hwndList, CB_SETCURSEL, 0, 0);

    // Complete the initial selections in the listbox.
    SendMessage(m_hwnd,
                WM_COMMAND,
                MAKELONG (IDC_EVENT_LIST, CBN_SELCHANGE),
                (LPARAM)m_hwndList);

    // Finally sub-class the listbox window
    SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                      GWLP_USERDATA,
                      (LONG_PTR)this);
    m_lpfnOldProc = (FARPROC) SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                                                GWLP_WNDPROC,
                                                (LONG_PTR)ListSubProc);

    return TRUE;
}


/*****************************************************************************

   CEventMonitor::OnCommand

   Handle WM_COMMAND messages

 *****************************************************************************/

INT_PTR
CEventMonitor::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{

    PDEVICEEVENT    pDeviceEvent;

    switch (widItem)
    {

    case    IDC_EVENT_LIST:

        switch (wCode)
        {

        case    CBN_SELCHANGE: {

                TCHAR       szText[BIG_ENOUGH];
                LRESULT     Idx;

                if (HasSelectionChanged())
                {

                    // update the old list
                    GetDlgItemText (m_hwnd, widItem, szText, ARRAYSIZE(szText));

                    Idx = SendMessage(hwndItem,
                                      CB_FINDSTRING,
                                      static_cast<WPARAM>(-1),
                                      (LPARAM)(LPTSTR)szText);

                    if (Idx != CB_ERR)
                    {

                        // delete the old list
                        pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndItem,
                                                                   CB_GETITEMDATA,
                                                                   Idx,
                                                                   0);

                        if ( (INT_PTR) pDeviceEvent == CB_ERR)
                        {

                            break;
                        }



                        // build the new list
                        pDeviceEvent->LaunchApplications = TEXT("");


                        int AddCount;
                        int AppIdx;

                        for (AddCount = 0, AppIdx = -1;
                            (AppIdx = m_IdMatrix.EnumIdx(AppIdx)) != -1; NULL)
                        {

                            if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST, LB_GETTEXT,
                                                    AppIdx, (LPARAM)(LPTSTR)szText) != LB_ERR)
                            {

                                if (AddCount)
                                {

                                    pDeviceEvent->LaunchApplications += TEXT(",");
                                }

                                pDeviceEvent->LaunchApplications += szText;

                                AddCount++;
                            }
                        }

                        SetSelectionChanged(FALSE);
                    }


                }

                // This is the new selection
                Idx = SendMessage(hwndItem,
                                  CB_GETCURSEL,
                                  0,
                                  0);

                if (Idx == CB_ERR)
                {

                    return  TRUE;
                }

                m_IdMatrix.Clear();

                pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndItem, CB_GETITEMDATA,
                                                           Idx, 0);

                if ( (INT_PTR) pDeviceEvent == CB_ERR)
                {

                    break;
                }

                // check for wildcard in first item
                if (pDeviceEvent->LaunchApplications.Length()  &&
                    !lstrcmpi (pDeviceEvent->LaunchApplications, TEXT("*")))
                {

                    // Select the entire list

                    m_IdMatrix.Set();

                }
                else
                {

                    // Traversing through the listbox doing searches.
                    // but we are going to have to do the compare somewhere.

                    LRESULT AppMax = SendDlgItemMessage (m_hwnd, IDC_APP_LIST,
                                                         LB_GETCOUNT, 0, 0);

                    if (AppMax != LB_ERR)
                    {

                        for (int i = 0; i < AppMax; i++)
                        {

                            if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST,
                                                    LB_GETTEXT, i, (LPARAM)(LPTSTR)szText) == LB_ERR)
                            {

                                continue;
                            }

                            if (pDeviceEvent->LaunchApplications.Length() &&
                                _tcsstr (pDeviceEvent->LaunchApplications, szText))
                            {
                                m_IdMatrix.Toggle (i);

                            }

                        }

                    }

                }

                // Force the repaint.
                InvalidateRect (GetDlgItem (m_hwnd, IDC_APP_LIST), NULL, TRUE);

                return  TRUE;
            }

        default:
            break;

        }

        break;

    case    IDC_APP_LIST:

        switch (wCode)
        {

        case    LBN_DBLCLK: {

                // This is the new selection
                LRESULT Idx = SendMessage(hwndItem,
                                          LB_GETCURSEL,
                                          0,
                                          0);

                if (Idx == LB_ERR)
                    return  TRUE;

                m_IdMatrix.Toggle((UINT)Idx);

                // Force the repaint.
                InvalidateRect (hwndItem, NULL, FALSE);

                SetSelectionChanged (TRUE);

                PropSheet_Changed (GetParent(m_hwnd), m_hwnd);

                return  TRUE;
            }

        default:
            break;

        }

        break;

    case IDC_CHECK_DISABLE_EVENTS:
        //
        // Disable check box changed it' state - enable Apply button
        PropSheet_Changed (GetParent(m_hwnd), m_hwnd);
        SetSelectionChanged (TRUE);


        break;

    default:
        break;

    }

    return  FALSE;
}


/*****************************************************************************

   CEventMonitor::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CEventMonitor::OnApplyChanges(BOOL bHitOK)
{

    TCHAR szText[BIG_ENOUGH];

    HWND hwndEvents = GetDlgItem (m_hwnd, IDC_EVENT_LIST);

    LRESULT uiCount = SendMessage (hwndEvents, CB_GETCOUNT,
                                   0,0);

    LRESULT CurrentIdx = SendMessage(hwndEvents, CB_GETCURSEL,
                                     0,0);

    PDEVICEEVENT    pDeviceEvent;

    for (INT u = 0; u < uiCount; u++)
    {

        if ((CurrentIdx == u) && HasSelectionChanged())
        {

            pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndEvents,
                                                       CB_GETITEMDATA,
                                                       u,
                                                       0);

            if ( (INT_PTR) pDeviceEvent == CB_ERR)
            {

                break;
            }



            // build the new list
            pDeviceEvent->LaunchApplications = TEXT("");


            int AddCount;
            int AppIdx;

            for (AddCount = 0, AppIdx = -1;
                (AppIdx = m_IdMatrix.EnumIdx(AppIdx)) != -1; NULL)
            {

                if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST, LB_GETTEXT,
                                        AppIdx, (LPARAM)(LPTSTR)szText) != LB_ERR)
                {

                    if (AddCount)
                    {

                        pDeviceEvent->LaunchApplications += TEXT(",");
                    }

                    pDeviceEvent->LaunchApplications += szText;

                    AddCount++;
                }

            }

            if (!bHitOK)
            {

                SetSelectionChanged(FALSE);

            }

        }
        else
        {

            pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndEvents,
                                                       CB_GETITEMDATA, u, 0);

        }

        pDeviceEvent->LaunchApplications.Store (pDeviceEvent->hKeyEvent, REGSTR_VAL_LAUNCH_APPS);

        if (bHitOK)
        {
            DoDelete (pDeviceEvent);
        }

    }

    //
    // reset List box content
    //
    if (bHitOK)
    {

        SendMessage (hwndEvents, CB_RESETCONTENT, 0, 0);

    }

    //
    // Save disabling flag state
    //
    m_dwUserDisableNotifications = IsDlgButtonChecked(m_hwnd,IDC_CHECK_DISABLE_EVENTS);

    g_pSti -> SetDeviceValue(m_psdi -> szDeviceInternalName,
                             STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS,
                             REG_DWORD,
                             (LPBYTE)&m_dwUserDisableNotifications,
                             sizeof(m_dwUserDisableNotifications));


    //
    // Inform STIMON about the change , just made
    //
    SendRefreshToStiMon();
    return  PSNRET_NOERROR;
}


/*****************************************************************************

   CEventMonitor::OnReset

   <Notes>

 *****************************************************************************/

VOID
CEventMonitor::OnReset (BOOL bHitCancel)
{


    HWND hwndEvents = GetDlgItem (m_hwnd, IDC_EVENT_LIST);

    PDEVICEEVENT    pDeviceEvent;
    LRESULT         dwRet;

    for (unsigned u = 0;
        (dwRet = SendMessage (hwndEvents, CB_GETITEMDATA, u, 0)) != CB_ERR;
        u++)
    {

        pDeviceEvent = (PDEVICEEVENT)dwRet;

        DoDelete (pDeviceEvent);

    }

    m_dwUserDisableNotifications = FALSE;

    CheckDlgButton(m_hwnd,IDC_CHECK_DISABLE_EVENTS,m_dwUserDisableNotifications);

}


/*****************************************************************************

   CEventMonitor::OnDrawItem

   <Notes>

 *****************************************************************************/

void
CEventMonitor::OnDrawItem(LPDRAWITEMSTRUCT lpdis)
{

    // Code also lifted from setupx.

    HDC     hDC;
    TCHAR   szText[BIG_ENOUGH];
    int     bkModeSave;
    SIZE    size;
    DWORD   dwBackColor;
    DWORD   dwTextColor;
    UINT    itemState;
    RECT    rcItem;
    HICON   hIcon;

    hDC         = lpdis->hDC;
    itemState   = lpdis->itemState;
    rcItem      = lpdis->rcItem;
    hIcon       = (HICON)lpdis->itemData;


    if ((int)lpdis->itemID < 0)
        return;

    SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szText);

    GetTextExtentPoint32(hDC, szText, lstrlen(szText), &size);

    if (lpdis->itemAction != ODA_FOCUS)
    {
        bkModeSave = GetBkMode(hDC);

        dwBackColor = SetBkColor(hDC, GetSysColor((itemState & ODS_SELECTED) ?
                                                  COLOR_HIGHLIGHT : COLOR_WINDOW));
        dwTextColor = SetTextColor(hDC, GetSysColor((itemState & ODS_SELECTED) ?
                                                    COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

        // fill in the background; do this before mini-icon is drawn
        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rcItem, NULL, 0, NULL);

        // Draw the "preferred list" checkbox next
        rcItem.left += DrawCheckBox (hDC, rcItem, m_IdMatrix.IsSet(lpdis->itemID));

        // Draw the icon
        DrawIconEx (hDC,
                    rcItem.left,
                    rcItem.top + ((rcItem.bottom - rcItem.top) - MINIY) / 2,
                    hIcon,
                    0,
                    0,
                    0,
                    NULL,
                    DI_NORMAL);

        rcItem.left += (MINIX + 2);

        // draw the text transparently on top of the background
        SetBkMode(hDC, TRANSPARENT);

        ExtTextOut(hDC,
                   rcItem.left,
                   rcItem.top + ((rcItem.bottom - rcItem.top) - size.cy) / 2,
                   0,
                   NULL,
                   szText,
                   lstrlen(szText),
                   NULL);

        // Restore hdc colors.
        SetBkColor  (hDC, dwBackColor);
        SetTextColor(hDC, dwTextColor);
        SetBkMode   (hDC, bkModeSave);
    }

    if (lpdis->itemAction == ODA_FOCUS || (itemState & ODS_FOCUS))
        DrawFocusRect(hDC, &rcItem);
}


BOOL
/*****************************************************************************

   CEventMonitor::BuildEventList

   Enumerate the events for the current STI device

 *****************************************************************************/

CEventMonitor::BuildEventList (HWND hwndParent, UINT CtrlId)
{

    m_hwndList = GetDlgItem(hwndParent, CtrlId);

    return m_hkThis.EnumKeys (EventListEnumProc, reinterpret_cast<LPARAM>(this), true);
}

/*****************************************************************************

CEventMonitor::EventListEnumProc

Fill the event list combobox with the enumerated events

******************************************************************************/

bool
CEventMonitor::EventListEnumProc (CSimpleReg::CKeyEnumInfo &Info)
{
    CEventMonitor *pThis = reinterpret_cast<CEventMonitor *>(Info.lParam);

    PDEVICEEVENT pDeviceEvent;
    pDeviceEvent =  new DEVICEEVENT;

    if (!pDeviceEvent)
    {

        return false;
    }
    ZeroMemory (pDeviceEvent, sizeof(DEVICEEVENT));

    pDeviceEvent->hKeyEvent = CSimpleReg (pThis->m_hkThis, Info.strName);

    if (!pDeviceEvent->hKeyEvent.Open ())
    {
        delete pDeviceEvent;
        return false;
    }


    //
    // First check if its launchable (absence of the key assume means launchable???)
    //

    pDeviceEvent->Launchable = pDeviceEvent->hKeyEvent.Query (REGSTR_VAL_LAUNCHABLE, TRUE);
    if (!(pDeviceEvent->Launchable))
    {
        delete pDeviceEvent;
    }
    else
    {
        pDeviceEvent->Description = TEXT("");


        pDeviceEvent->Description.Load (pDeviceEvent->hKeyEvent, TEXT(""));

        pDeviceEvent->LaunchApplications =TEXT("");


        pDeviceEvent->LaunchApplications.Load (pDeviceEvent->hKeyEvent, REGSTR_VAL_LAUNCH_APPS);

        //
        // Load into the combo box
        //
        LRESULT id = SendMessage(pThis->m_hwndList,
                                 CB_ADDSTRING,
                                 0,
                                 reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(pDeviceEvent->Description)));

        SendMessage(pThis->m_hwndList, CB_SETITEMDATA, id, reinterpret_cast<LPARAM>(pDeviceEvent));

    }

    return true;
}

/*****************************************************************************

CEventMonitor::FillListEnumProc

Fills an array of strings with value names and values from the regkey enumeration

******************************************************************************/

bool
CEventMonitor::FillListEnumProc (CSimpleReg::CValueEnumInfo &Info)
{
    CSimpleDynamicArray<CSimpleString> *pValueList;
    CSimpleString pValue;
    pValueList = reinterpret_cast<CSimpleDynamicArray<CSimpleString> *>(Info.lParam);

    if (Info.nType == REG_SZ || Info.nType == REG_EXPAND_SZ)
    {
        // first append the value name
        pValueList->Append(Info.strName);
        // then append the value
        pValue = Info.reg.Query (Info.strName, TEXT(""));
        pValueList->Append (pValue);
    }
    return true;
}

/*****************************************************************************

   CEventMonitor::FillListbox

   Enumerate the list of registered event handlers and fill the list box

 *****************************************************************************/

void
CEventMonitor::FillListbox(HWND hwndParent, UINT CtrlId)
{


    HWND        hwnd;

    CSimpleString   szAppFriendly;
    TCHAR   szAppPath[MAX_PATH*2];;
    SHFILEINFO  shfi;

    LRESULT     Idx = LB_ERR;
    HICON       hIcon;
    CSimpleDynamicArray<CSimpleString> ValueList;


    hwnd = GetDlgItem (hwndParent, CtrlId);

    CSimpleReg  hkApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_REG_APPS);
    hkApps.Open();


    // Turn off listbox updates
    //
    SendMessage( hwnd, WM_SETREDRAW, 0,  0L );
    SendMessage( hwnd, LB_RESETCONTENT, 0,  0L ); // Make sure it's empty.

    // Load a "default" Icon.
    //
    hIcon = (HICON)LoadImage(GLOBAL_HINSTANCE,
                             MAKEINTRESOURCE(IDI_DEFAULT),
                             IMAGE_ICON,
                             16,
                             16,
                             LR_SHARED);

    // Build the list of value names and values
    //
    if (hkApps.EnumValues (FillListEnumProc, reinterpret_cast<LPARAM>(&ValueList)))
    {

        // cycle through the strings in the list to fill the listbox
        for (INT i=0;i<ValueList.Size();i+=2)
        {

            szAppFriendly = ValueList[i];
            Idx = SendMessage( hwnd,
                               LB_ADDSTRING,
                               0,
                               reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szAppFriendly )));

            if (Idx != LB_ERR)
            {

                ZeroMemory(&shfi,sizeof(shfi));

                shfi.hIcon = NULL;

                //
                // Command line parsing to remove arguments...
                //

                LPTSTR   pszLastSpace = NULL;
                lstrcpyn (szAppPath, ValueList[i+1], ARRAYSIZE(szAppPath));
                if (* szAppPath == TEXT('"'))
                {

                    //
                    // Remove leading and trailing quotes
                    //

                    PathRemoveArgs(szAppPath);

                    // use MoveMemory because it is safe with overlapping memory
                    MoveMemory(szAppPath,szAppPath+1,sizeof(szAppPath)-sizeof(TCHAR));
                    pszLastSpace = _tcschr(szAppPath,TEXT('"'));
                    if (pszLastSpace)
                    {
                        *pszLastSpace = TEXT('\0');
                    }
                }
                else
                {
                    pszLastSpace = _tcschr(szAppPath,TEXT('/'));
                }

                //
                // At this point szAppPath should contain original buffer with only executable file
                // specification in it, and pszLastSpace may be NULL
                //
                do
                {

                    if (pszLastSpace)
                    {
                        *pszLastSpace = TEXT('\0');
                    }

                    if (SHGetFileInfo(szAppPath,
                                  0,
                                  &shfi,
                                  sizeof( SHFILEINFO ),
                                  SHGFI_ICON | SHGFI_SHELLICONSIZE | SHGFI_SMALLICON) && shfi.hIcon)
                    {
                        break;
                    }

                } while ( (pszLastSpace = _tcsrchr(szAppPath,TEXT(' '))) != NULL);


                if (shfi.hIcon)
                {

                    SendMessage( hwnd,
                             LB_SETITEMDATA,
                             Idx,
                             (LPARAM)shfi.hIcon);
                }
                else
                {

                    SendMessage( hwnd,
                             LB_SETITEMDATA,
                             Idx,
                             (LPARAM)hIcon);
                }
            }
        }
    }

    if ( Idx != LB_ERR )
    {
        // Make sure we had some elements and no errors.
        SendMessage( hwnd, LB_SETCURSEL, 0, 0L );
    }

    // Now turn on listbox updates.
    SendMessage( hwnd, WM_SETREDRAW, (WPARAM) 1,  0L );

    if ((Idx = SendMessage (hwnd, LB_GETCOUNT, 0, 0)) != LB_ERR)
        m_IdMatrix.SetCount ((UINT)Idx);


}


/*****************************************************************************

   CEventMonitor::DrawCheckBox

   <Notes>

 *****************************************************************************/

UINT
CEventMonitor::DrawCheckBox (HDC hDC, RECT rcItem, BOOL Checked)
{


    HICON  hIcon;

    hIcon = (HICON)LoadImage(GLOBAL_HINSTANCE,
                             Checked ? MAKEINTRESOURCE(IDI_SELECT) : MAKEINTRESOURCE(IDI_UNSELECT),
                             IMAGE_ICON,
                             16,
                             16,
                             LR_SHARED);

    if (hIcon)
    {

        // Draw the icon
        DrawIconEx (hDC,
                    rcItem.left,
                    rcItem.top + ((rcItem.bottom - rcItem.top) - MINIY) / 2,
                    hIcon,
                    0,
                    0,
                    0,
                    NULL,
                    DI_NORMAL);

    }

    return (MINIX + 2);

}


/*****************************************************************************

   CEventMonitor::ListSubProc

   <Notes>

 *****************************************************************************/

LRESULT
CALLBACK
CEventMonitor::ListSubProc (HWND hwnd,
                            UINT msg,
                            WPARAM wParam,
                            LPARAM lParam)
{


    // Snatched from setupx

    LRESULT    rc;
    WORD        Id;

    CEventMonitor *pcem = (CEventMonitor *) GetWindowLongPtr (hwnd, GWLP_USERDATA);

    Id = LOWORD(GetWindowLong(hwnd, GWLP_ID));
    // Convert single click on icon to double click

    if (msg == WM_LBUTTONDOWN && LOWORD(lParam) <= MINIX)
    {

        // Call the standard window proc to handle the msg (and
        // select the proper list item)
        rc = CallWindowProc((WNDPROC)pcem->m_lpfnOldProc, hwnd, msg, wParam, lParam);

        // Now do the double click thing
        SendMessage(pcem->m_hwnd,
                    WM_COMMAND,
                    (WPARAM)MAKELONG (Id, LBN_DBLCLK),
                    (LPARAM)hwnd);

        //
        // now send a WM_LBUTTONDOWN to listbox so it
        // doesn't get stuck down (chicago problem).
        //

        CallWindowProc((WNDPROC)pcem->m_lpfnOldProc,
                       hwnd,
                       WM_LBUTTONUP,
                       wParam,
                       lParam);

        return (BOOL)rc;
    }

    if (msg == WM_KEYDOWN && wParam == VK_SPACE)
    {

        // Treat spacebar as double click
        SendMessage(pcem->m_hwnd,
                    WM_COMMAND,
                    (WPARAM)MAKELONG (Id, LBN_DBLCLK),
                    (LPARAM)hwnd);
    }

    return CallWindowProc((WNDPROC)pcem->m_lpfnOldProc,
                          hwnd,
                          msg,
                          wParam,
                          lParam);
}



/*****************************************************************************

   CPortSettingsPage::OnInit

   Initialize dialog window

 *****************************************************************************/

INT_PTR
CPortSettingsPage::OnInit(VOID)
{

    // Populate port names combobox
    //BuildPortList(m_hwnd, IDC_COM_SETTINGS);

    // BUGBUG How to synchronize with general page ???? May be, move port list here
    SetDlgItemText(m_hwnd,
                   IDC_PORT_NAME,
                   CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi -> pszPortName)));


    // Populate baud rate combobox
    m_uBaudRate = BuildBaudRateList(m_hwnd,IDC_BAUDRATE_COMBO);

    return  TRUE;
}


/*****************************************************************************

   CPortSettingsPage::BuildBaudRateList

   Fill out legal baud rates. Return current device baud rate

 *****************************************************************************/

UINT
CPortSettingsPage::BuildBaudRateList(HWND hwndParent,
                                     UINT CtrlId)
{


    UINT        uBaudRate;


    WORD        nComboChoice;
    HWND        hBaudBox = NULL;
    HRESULT     hr = E_FAIL;
    DWORD       dwType = REG_DWORD;
    DWORD       cbData = sizeof(uBaudRate);

    TraceAssert(g_pSti);

    hr = g_pSti->GetDeviceValue(m_psdi -> szDeviceInternalName,
                                REGSTR_VAL_BAUDRATE,
                                &dwType,
                                (LPBYTE)&uBaudRate,
                                &cbData);
    if (!SUCCEEDED(hr))
    {
        uBaudRate = 115200;
    }

    hBaudBox = GetDlgItem(hwndParent,CtrlId);

    //
    // Clear Contents of ComboBox
    //
    SendMessage(hBaudBox,
                CB_RESETCONTENT,
                0,
                0L);

    //
    // Populate ComboBox with Baud Choices
    // BUGBUG Should it be programmatic ?
    //
    ComboBox_AddString(hBaudBox,TEXT("9600"));
    ComboBox_AddString(hBaudBox,TEXT("19200"));
    ComboBox_AddString(hBaudBox,TEXT("38400"));
    ComboBox_AddString(hBaudBox,TEXT("57600"));
    ComboBox_AddString(hBaudBox,TEXT("115200"));

    //
    // Set ComboBox to highlight the value obtained from registry
    //
    switch (uBaudRate)
    {
    case 9600:   nComboChoice = 0; break;
    case 19200:  nComboChoice = 1; break;
    case 38400:  nComboChoice = 2; break;
    case 57600:  nComboChoice = 3; break;
    case 115200: nComboChoice = 4; break;
    default: nComboChoice = 4;
    }

    ComboBox_SetCurSel(hBaudBox,nComboChoice);

    return uBaudRate;
}


/*****************************************************************************

   CPortSettingsPage::OnCommand

   Enable the Apply button when the combobox selection changes

 *****************************************************************************/

INT_PTR
CPortSettingsPage::OnCommand(WORD wCode,
                             WORD widItem,
                             HWND hwndItem)
{


    if (CBN_SELCHANGE == wCode )
    {
        // Enable Apply button
        ::SendMessage(::GetParent(m_hwnd),
                      PSM_CHANGED,
                      (WPARAM)m_hwnd,
                      0);
        return TRUE;
    }

    return  FALSE;
}


/*****************************************************************************

   CPortSettingsPage::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CPortSettingsPage::OnApplyChanges(BOOL bHitOK)
{
    UINT    nComboChoice;
    HWND    hBaudBox ;
    UINT    uBaudRate = 0;

    hBaudBox = GetDlgItem(m_hwnd,IDC_BAUDRATE_COMBO);

    nComboChoice = ComboBox_GetCurSel(hBaudBox);

    //
    // Translate current selection into baudrate
    //
    switch (nComboChoice)
    {
    case 0: uBaudRate = 9600; break;
    case 1: uBaudRate = 19200; break;
    case 2: uBaudRate = 38400; break;
    case 3: uBaudRate = 57600; break;
    case 4: uBaudRate = 115200; break;
    default: uBaudRate = 115200;
    }


    //
    // Set New Baud Rate in STI Registry
    //
    if (uBaudRate != m_uBaudRate)
    {

        TraceAssert(g_pSti);

        g_pSti->SetDeviceValue(m_psdi -> szDeviceInternalName,
                               REGSTR_VAL_BAUDRATE,
                               REG_DWORD,
                               (LPBYTE)&uBaudRate,
                               sizeof(uBaudRate));
        m_uBaudRate = uBaudRate;
    }

    return PSNRET_NOERROR;
}


/*****************************************************************************

   CPortSettingsPage::IsNeeded

   <Notes>

 *****************************************************************************/

BOOL
CPortSettingsPage::IsNeeded(VOID)
{
    if (m_psdi->dwHardwareConfiguration & STI_HW_CONFIG_SERIAL)
    {
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************

   SendRefreshToStiMon

   Send refresh message to Sti Monitor, if it is running.  Currently CPL
   requests reread of all registry information for all active devices.

 *****************************************************************************/

BOOL
SendRefreshToStiMon(VOID)
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (hSvcMgr)
    {
        //
        // Open WIA service.
        //

        hService = OpenService(
            hSvcMgr,
            STI_SERVICE_NAME,
            SERVICE_USER_DEFINED_CONTROL
            );

        if (hService)
        {
            //
            // Inform WIA service to refresh its device settings.
            //

            rVal = ControlService(hService,
                                  STI_SERVICE_CONTROL_REFRESH,
                                  &ServiceStatus);
            if (!rVal)
            {
                //Trace(TEXT("SendRefreshToStiMon: ERROR!! ControlService failed. Err=0x%x\n"), GetLastError());
            }
        } else {
            //Trace(TEXT("SendRefreshToStiMon: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError());
        }

    } else {
        //Trace(TEXT("SendRefreshToStiMon: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError());
    }


    //
    //  Close Handles
    //

    if(NULL != hService){
        CloseServiceHandle( hService );
        hService = NULL;
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
        hSvcMgr = NULL;
    }

    return rVal;
}


/*****************************************************************************

   IsPnPDevice

   <Notes>

 *****************************************************************************/

BOOL
IsPnPDevice(PSTI_DEVICE_INFORMATION psdi, CSimpleString *pszConnection)

{
    CSimpleString           szInfPath;
    CSimpleString           szInfSection;
    HANDLE                  hDevInfo;


    SP_DEVINFO_DATA         spDevInfoData;
    DWORD                   err;
    HINF                    hInf;
    HKEY                    hKeyDevice;
    ULONG                   cbData;
    BOOL                    bIsPnP = TRUE;


    if (pszConnection)
    {
        *pszConnection = TEXT("");
    }

    hDevInfo = SelectDevInfoFromFriendlyName(psdi->pszLocalName);
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hDevInfo, &spDevInfoData);
    }
    else
    {
        return TRUE;
    }


    hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                       &spDevInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DRV,
                                       KEY_READ);
    if (hKeyDevice != INVALID_HANDLE_VALUE)
    {

        //
        // See if it's PnP or not
        //

        cbData = sizeof(bIsPnP);
        if (RegQueryValueEx(hKeyDevice,
                           REGSTR_VAL_ISPNP,
                           NULL,
                           NULL,
                           (LPBYTE)&bIsPnP,
                           &cbData) != ERROR_SUCCESS)
        {

            //
            // IsPnP is not found..
            //

            RegCloseKey(hKeyDevice);
            goto IsPnPDevice_Err;
        }

        if (!szInfPath.Load(hKeyDevice,REGSTR_VAL_INFPATH))

        {

            //
            //InfPath is not found..
            //

           RegCloseKey(hKeyDevice);
           goto IsPnPDevice_Err;
        }


        if (!szInfSection.Load(hKeyDevice,REGSTR_VAL_INFSECTION))

        {
            //
            //InfSection is not found..
            //

            RegCloseKey(hKeyDevice);
            goto IsPnPDevice_Err;
        }

        RegCloseKey(hKeyDevice);
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
    hDevInfo = NULL;
    //
    // Open Inf file and copy connection type to szConnection
    //
    if (pszConnection)
    {

       TCHAR szBuffer[MAX_PATH];
       hInf = SetupOpenInfFile(szInfPath,
                               NULL,
                               INF_STYLE_WIN4,
                               NULL);

       if (hInf == INVALID_HANDLE_VALUE)
       {
           err = GetLastError();
           goto IsPnPDevice_Err;
       }

       if(!SetupGetLineText(NULL,
                            hInf,
                            szInfSection,
                            TEXT("Connection"),
                            szBuffer,
                            MAX_PATH,
                            &cbData))
       {
           *pszConnection = TEXT("BOTH");
       }
       else
       {
           *pszConnection = szBuffer;
       }
       SetupCloseInfFile(hInf);
    }
IsPnPDevice_Err:

    if(hDevInfo)
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    return bIsPnP;
}


/*****************************************************************************

   SelectDevInfoFromFriendlyName

   <Notes>

 *****************************************************************************/

HANDLE
SelectDevInfoFromFriendlyName(const CSimpleStringWide &pszLocalName)
{

    CSimpleString           szTemp;
    CSimpleString           szFriendlyName;
    HANDLE                  hDevInfo;
    GUID                    Guid = GUID_DEVCLASS_IMAGE;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    DWORD                   err;
    BOOL                    Found = FALSE;
    HKEY                    hKeyDevice;


    szFriendlyName = CSimpleStringConvert::NaturalString (pszLocalName);
    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        err = GetLastError();
        return INVALID_HANDLE_VALUE;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)
    {
        hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if (hKeyDevice != INVALID_HANDLE_VALUE)
        {

            //
            // Is SubClass = STILLIMAGE?
            //

            if (!szTemp.Load (hKeyDevice, REGSTR_VAL_SUBCLASS) ||
                (_tcsicmp(szTemp, STILLIMAGE) != 0))
            {

                //
                // Skip this one.
                //

                RegCloseKey(hKeyDevice);
                continue;
            }

            //
            // Is FriendlyName same as pszLocalName?
            //


            if (!szTemp.Load (hKeyDevice, REGSTR_VAL_FRIENDLY_NAME))
            {
                if(_tcsicmp(szTemp, szFriendlyName) != 0)
                {

                    //
                    // Skip this one.
                    //

                    RegCloseKey(hKeyDevice);
                    continue;
                }
            }
            else
            {
                RegCloseKey(hKeyDevice);
                continue;
            }


            //
            // Found the target!
            //

            Found = TRUE;
            RegCloseKey(hKeyDevice);
            break;
        }

    }


    if(!Found)
    {

       //
       // FriendleName is not found. Something is corrupted.
       //
       SetupDiDestroyDeviceInfoList(hDevInfo);
       return INVALID_HANDLE_VALUE;
    }

    SetupDiSetSelectedDevice(hDevInfo,
                             &spDevInfoData);
    return hDevInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\stream.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2002
 *
 *  TITLE:       stream.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: IStream interface for streaming back images to callers
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

DWORD _ImageStreamThreadProc( LPVOID lpv );

#define TRANSFER_BUFFER_SIZE 0x1000
#define SLOP                 0x0200


/*****************************************************************************

   CImageStream::CImageStream,~CImageStream

   Constructor/Destructor for class

 *****************************************************************************/

CImageStream::CImageStream( LPITEMIDLIST pidlFull,
                            LPITEMIDLIST pidl,
                            BOOL bShowProgress)
    : m_ulReadPos(0),
      m_ulWritePos(0),
      m_ulSize(0),
      m_bTransferred(FALSE),
      m_pBuffer(NULL),
      m_guidFormat(WiaImgFmt_MEMORYBMP),
      m_bFirstTransfer(TRUE),
      m_bProgress(bShowProgress),
      m_hResultDownload (S_OK),
      m_hEventStart (NULL),
      m_dwCookie(0)
{
    //
    // Save the args
    //

    if (pidlFull)
    {
        m_pidlFull = ILClone( pidlFull );
    }
    else
    {
        m_pidlFull = NULL;
    }

    if (pidl)
    {
        m_pidl = ILClone( pidl );
    }
    else
    {
        m_pidl = NULL;
    }


}

CImageStream::~CImageStream()
{


    DoILFree( m_pidlFull );
    DoILFree( m_pidl );
    DoLocalFree( m_pBuffer );
    DoCloseHandle( m_hThread );
    DoCloseHandle (m_hEventStart);    
    if (m_dwCookie)
    {
        m_pgit->RevokeInterfaceFromGlobal(m_dwCookie);
    }
}

/******************************************************************************

    CImageStream::InitItem

    InitItem stores the IWiaItem interface pointer in a global interface
    table so the thread proc can just marshal it instead of having
    to call CreateDevice again

******************************************************************************/
HRESULT
CImageStream::InitItem ()
{
    HRESULT hr = S_OK;
    CComPtr<IWiaItem> pItem;
    DWORD dwCookie = 0;
    TraceEnter (TRACE_STREAM, "CImageStream::InitItem");
    if (!m_dwCookie)
    {

        if (!m_pgit)
        {
            hr = CoCreateInstance (CLSID_StdGlobalInterfaceTable,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   reinterpret_cast<LPVOID*>(&m_pgit));
        }

        if (SUCCEEDED(hr))
        {
            hr = IMGetItemFromIDL(m_pidl, &pItem);
            if (SUCCEEDED(hr))
            {
                hr = m_pgit->RegisterInterfaceInGlobal (pItem,
                                                        IID_IWiaItem,
                                                        &m_dwCookie);
                if (FAILED(hr))
                {
                    Trace(TEXT("Failed to register in GIT: %x"), hr);
                }
            }
        }
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CImageStream::AddRef,Release,etc.

   IUnknown methods.

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageStream
#include "unknown.inc"


/*****************************************************************************

   CImageStream::QI wrapper

 *****************************************************************************/

STDMETHODIMP CImageStream::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IStream,           (IStream           *)this,
        &IID_ISequentialStream, (ISequentialStream *)this,
        &IID_IWiaDataCallback,   (IWiaDataCallback   *)this
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*****************************************************************************

   CImageStream::Seek [IStream]

   Sets the current stream pointer.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Seek( LARGE_INTEGER dlibMove,
                    DWORD dwOrigin,
                    ULARGE_INTEGER *plibNewPosition
                   )
{
    HRESULT hr = STG_E_INVALIDFUNCTION;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Seek" );
    // sleep until we know the size of the image
    hr = _InitWorker();
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER liNew;
        hr = STG_E_INVALIDFUNCTION;
        switch (dwOrigin)
        {
            case STREAM_SEEK_SET:
                Trace(TEXT("dwOrigin = STREAM_SEEK_SET"));
                liNew = dlibMove;
                break;

            case STREAM_SEEK_CUR:
                Trace(TEXT("dwOrigin = STREAM_SEEK_CUR"));
                liNew.QuadPart = (LONGLONG)((LONG)m_ulReadPos) + dlibMove.QuadPart;
                break;

            case STREAM_SEEK_END:
                Trace(TEXT("dwOrigin = STREAM_SEEK_END"));
                liNew.QuadPart = (LONGLONG)((LONG)m_ulSize) + dlibMove.LowPart;
                break;

        }

        Trace(TEXT("liNew = %d:%d, m_ulSize = %d, dlibMove = %d:%d"),liNew.HighPart,liNew.LowPart,m_ulSize,dlibMove.HighPart,dlibMove.LowPart);

        if ((liNew.QuadPart <= (LONGLONG)(LONG)m_ulSize) && (liNew.QuadPart >= 0))
        {
            m_ulReadPos = liNew.LowPart;
            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = m_ulReadPos;
                Trace(TEXT("plibNewPosition = %d:%d"),plibNewPosition->HighPart,plibNewPosition->LowPart);
            }
            hr = S_OK;
        }
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::SetSize [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::SetSize( ULARGE_INTEGER libNewSize )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::SetSize" );

    TraceLeaveResult(hr);
}




/*****************************************************************************

   CImageStream::CopyTo [IStream]

   Copies the contents of the stream to another
   specified stream.

 *****************************************************************************/

STDMETHODIMP
CImageStream::CopyTo( IStream *pstm,
                      ULARGE_INTEGER cb,
                      ULARGE_INTEGER *pcbRead,
                      ULARGE_INTEGER *pcbWritten
                     )
{


    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::CopyTo" );
    HANDLE hThread;
    DWORD dw;

    //
    // NOTE: to satisfy RPC requirements that outgoing calls can't be made
    // from a thread responding to a sent message, spawn a thread
    // to do the work
    //


    m_hResultDownload = InitItem ();
    if (SUCCEEDED(m_hResultDownload))
    {
        AddRef ();

        hThread = CreateThread (NULL,
                                0,
                                _ImageStreamThreadProc,
                                reinterpret_cast<LPVOID>(this),
                                0,
                                &dw );

        if (hThread)
        {
            WaitForSingleObject (hThread, INFINITE);
            if (S_OK == m_hResultDownload)
            {

                if (cb.HighPart || (m_ulWritePos <= cb.LowPart))
                {
                    if (m_pBuffer)
                    {
                        //
                        // Copy the stream data
                        //

                        m_hResultDownload = pstm->Write( (void *)m_pBuffer, m_ulWritePos, NULL );
                        if (pcbWritten)
                        {
                            (*pcbWritten).HighPart = 0;
                            (*pcbWritten).LowPart = m_ulWritePos;
                        }
                    }
                }
            }
            CloseHandle( hThread );
        }

        else
        {
            Release ();
        }
    }
    TraceLeaveResult(m_hResultDownload);
}


/*****************************************************************************

   CImageStream::Commit [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Commit" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Revert [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Revert(void)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Revert" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::LockRegion [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::LockRegion( ULARGE_INTEGER libOffset,
                          ULARGE_INTEGER cb,
                          DWORD dwLockType
                         )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::LockRegion" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::UnlockRegion [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::UnlockRegion( ULARGE_INTEGER libOffset,
                            ULARGE_INTEGER cb,
                            DWORD dwLockType
                           )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::UnlockRegion" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Stat [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Stat( STATSTG *pstatstg,
                    DWORD grfStatFlag
                   )
{
    HRESULT hr = S_OK;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Stat" );
    ZeroMemory(pstatstg, sizeof(pstatstg));

    if (!(STATFLAG_NONAME & grfStatFlag))
    {
        CSimpleStringWide strName;
        CSimpleString strExt;
        IMGetNameFromIDL(m_pidl, strName);

        hr = IMGetImagePreferredFormatFromIDL( m_pidl, NULL, &strExt );
        if (SUCCEEDED(hr))
        {
            int cch = strName.Length()+1;
            strName.Concat (CSimpleStringConvert::WideString (strExt));
            pstatstg->pwcsName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc(cch*sizeof(WCHAR)));
            if (!(pstatstg->pwcsName))
            {
                hr = STG_E_INSUFFICIENTMEMORY;
            }
            else
            {
                lstrcpynW(pstatstg->pwcsName, strName.String(), cch);
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pstatstg->grfMode = STGM_READ | STGM_SHARE_EXCLUSIVE;
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Clone [IStream]

   Makes a copy of the stream object.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Clone( IStream **ppstm )
{
    HRESULT hr;
    CImageStream * pStream;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Clone" );

    if (!ppstm)
    {
        ExitGracefully( hr, E_INVALIDARG, "ppstm is NULL!" );
    }

    pStream = new CImageStream( m_pidlFull, m_pidl, m_bProgress );

    if ( !pStream )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create CImageStream");

    //
    // Get the requested interface on the new object and hand it back...
    //

    hr = pStream->QueryInterface( IID_IStream, (LPVOID *)ppstm);

    pStream->Release ();

exit_gracefully:

    TraceLeaveResult(hr);

}

HRESULT
CImageStream::_InitWorker()
{
    HRESULT hr = S_OK;
    TraceEnter(TRACE_STREAM, "CImageStream::_InitWorker");
    if (!m_hThread)
    {
        DWORD dw;
        hr = InitItem ();
        if (SUCCEEDED(hr))
        {
            m_hEventStart = CreateEvent (NULL, FALSE, FALSE, NULL);
            if (!m_hEventStart)
            {
                Trace(TEXT("CreateEvent failed in CImageStream::_InitWorker"));
                hr = E_FAIL;
            }
        }
        if (SUCCEEDED(hr))
        {
            AddRef ();
            m_hThread = CreateThread( NULL, 0, _ImageStreamThreadProc, (LPVOID)this, 0, &dw );
            if (!m_hThread)
            {
                Trace(TEXT("CreateThread failed in _InitWorker %d"), GetLastError());
                Release ();
            }
            else
            {
                WaitForSingleObject (m_hEventStart,120000); // wait up to 120 seconds
            }
            if (!m_ulWritePos)
            {
                Trace(TEXT("No data ready, bailing"));
                hr = E_FAIL;
            }
        }
    }
    return hr;
}
/*****************************************************************************

   CImageStream::Read [ISequentialStream]

   Read the specified number of bytes from the
   stream into the buffer provided.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Read( void *pv,
                    ULONG cb,
                    ULONG *pcbRead
                   )
{
    HRESULT hr = E_FAIL;


    ULONG ulWrite = 0;
    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Read" );
    Trace(TEXT("Bytes to read = %d"),cb );

    //
    // Check the params
    //

    if (!pv || !cb)
    {
        Trace(TEXT("pv = 0x%x, cb = %d, pcbRead = 0x%x"),pv,cb,pcbRead);
        ExitGracefully( hr, STG_E_INVALIDPOINTER, "bad incoming params" );
    }

    //
    // If we haven't started the download thread, do so now...
    //

    hr = _InitWorker();
    FailGracefully (hr, "_InitWorker failed");
    //
    // Read the bits once they are available
    //
    ulWrite = m_ulWritePos;
    if (ulWrite)
    {
        ULONG ulBytesLeftInStream = 0;

        //
        // Wait for enough data to be available (or we're at the end of
        // the file)
        //

        do
        {
            ulBytesLeftInStream = m_ulWritePos - m_ulReadPos;
            Trace(TEXT("CImageStream::Read --> %d bytes ready in stream"),ulBytesLeftInStream);

            if ((m_ulReadPos > m_ulWritePos) || (!m_bTransferred &&  (ulBytesLeftInStream < cb)))
            {
                Sleep( 500 );
            }
            // Seek guarantees m_ulReadPos will never exceed the image size
        } while(!m_bTransferred && (ulBytesLeftInStream < cb));

        // if the transfer completed, re-eval bytes left to make sure it's
        // synched
        if (m_bTransferred)
        {
            ulBytesLeftInStream = m_ulWritePos - m_ulReadPos;
        }
        if (S_OK == m_hResultDownload)
        {

            //
            // Read what we can out of the file, a read that
            // completes with less than cb bytes is considered
            // the end of the file
            //

            memcpy( pv, (LPBYTE)m_pBuffer + m_ulReadPos, min(cb, ulBytesLeftInStream) );

            if (pcbRead)
            {
                *pcbRead = min(cb, ulBytesLeftInStream);
            }

            m_ulReadPos += min(cb, ulBytesLeftInStream);

        }

    }
    hr = m_hResultDownload;
exit_gracefully:

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Revert [ISequentialStream]

   Writes the specified number of bytes into the
   stream from the buffer provided.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Write( const void *pv,
                     ULONG cb,
                     ULONG *pcbWritten
                    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Write" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   _ImageStreamThreadProc

   Actually does the work to get the bits from WIA and write them to
   the buffer we care about.

 *****************************************************************************/

DWORD _ImageStreamThreadProc( LPVOID lpv )
{
    HRESULT hr = E_FAIL;
    HRESULT hrCo = E_FAIL;

    CImageStream * pStream = (CImageStream *)lpv;
    WIA_FORMAT_INFO Format;
    WIA_DATA_TRANSFER_INFO  wiaDataTransInfo;

    LONG lBufSize = 65535;

    TraceEnter( TRACE_STREAM, "_ImageStreamThreadProc" );

    if (pStream)
    {
        hrCo = CoInitialize(NULL);
    }
    if (SUCCEEDED(hrCo))
    {
        CComPtr<IWiaItem>         pItem;
        CComPtr<IWiaDataTransfer> pWiaDataTran;
        CComPtr<IWiaDataCallback> pWiaDataCallback;

        //
        // Init the structure
        //  

        Format.lTymed    = TYMED_CALLBACK;

        TraceAssert (pStream->m_dwCookie);

        hr = pStream->m_pgit->GetInterfaceFromGlobal (pStream->m_dwCookie,
                                                      IID_IWiaItem,
                                                      reinterpret_cast<LPVOID*>(&pItem));
        if (SUCCEEDED(hr))
        {
        
            //
        // fill out structures for IBandedTransfer
        //

            if (!PropStorageHelpers::GetProperty (pItem, WIA_IPA_PREFERRED_FORMAT, Format.guidFormatID) ||
                IsEqualGUID(Format.guidFormatID, WiaImgFmt_BMP))
            {
                Format.guidFormatID = WiaImgFmt_MEMORYBMP;
            }

            pStream->m_guidFormat = Format.guidFormatID;
            SetTransferFormat (pItem, Format);
            //
            // Get the image transfer interface
            //

            hr = pItem->QueryInterface(IID_IWiaDataTransfer, (LPVOID *)&pWiaDataTran);
            if (SUCCEEDED(hr))
            {
            
            //
            // Set up callback so we can show progress...
            //

                hr = pStream->QueryInterface(IID_IWiaDataCallback, (LPVOID *)&pWiaDataCallback);
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the picture data...
                    //
                    PropStorageHelpers::GetProperty(pItem,
                                                    WIA_IPA_MIN_BUFFER_SIZE,
                                                    lBufSize);
                    ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                    wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                    wiaDataTransInfo.ulBufferSize = static_cast<ULONG>(2*lBufSize);
                    wiaDataTransInfo.bDoubleBuffer = TRUE;
                    hr = pWiaDataTran->idtGetBandedData( &wiaDataTransInfo, pWiaDataCallback );
                }
            }
            pStream->m_pgit->RevokeInterfaceFromGlobal (pStream->m_dwCookie); 
            pStream->m_dwCookie = 0;
        }
    }


    //
    // Signal that the file has been completely downloaded
    //
    if (pStream)
    {
        pStream->m_hResultDownload = hr;
        InterlockedExchange (&pStream->m_bTransferred, TRUE);
        //
        // Make sure the dialog goes away...
        //

        if (pStream->m_pWiaProgressDialog)
        {
            pStream->m_pWiaProgressDialog->Destroy();
            pStream->m_pWiaProgressDialog = NULL;
        }
        if (FAILED(hr) && pStream->m_hEventStart)
        {
            // wake up the Read for the error
            SetEvent (pStream->m_hEventStart);
        }
        pStream->Release ();
    }

    if (SUCCEEDED(hrCo))
    {
        MyCoUninitialize();
    }

    Trace(TEXT("_ImageStreamThreadProc, exiting w/hr = 0x%x"), hr );
    TraceLeave();
    ExitThread((DWORD)hr);
    return 0;
}


/*****************************************************************************

   CImageStream::BandedDataCallback

   Callback method from WIA -- calls us with a chunk of image data.

 *****************************************************************************/

STDMETHODIMP
CImageStream::BandedDataCallback (LONG lReason,
                                  LONG lStatus,
                                  LONG lPercentComplete,
                                  LONG lOffset,
                                  LONG lLength,
                                  LONG lReserved,
                                  LONG lResLength,
                                  BYTE *pbData)
{

    HRESULT hr = S_OK;

    TraceEnter( TRACE_STREAM, "CImageStream(IWiaDataCallback)::BandedDataCallback" );


    Trace(TEXT(" lReason=0x%x, lPercentComplete=%d, lStatus = 0x%x, lOffset = 0x%x, lLength = 0x%x"),
          lReason, lPercentComplete, lStatus, lOffset, lLength
          );

    switch( lReason )
    {

        case IT_MSG_DATA_HEADER:
        {
            WIA_DATA_CALLBACK_HEADER * pHead = (WIA_DATA_CALLBACK_HEADER *)pbData;

            if (pHead && (pHead->lSize == sizeof(WIA_DATA_CALLBACK_HEADER)))
            {
                if (IsEqualGUID (m_guidFormat, WiaImgFmt_MEMORYBMP))
                {
                    Trace (TEXT("Adding sizeof(BITMAPFILEHEADER) to image size"));
                    m_ulSize = sizeof(BITMAPFILEHEADER) + pHead->lBufferSize;
                }
                else
                {
                    m_ulSize = pHead->lBufferSize;
                }

                Trace(TEXT("Got header, creating a %d byte buffer"), m_ulSize);
                m_pBuffer = LocalAlloc( LPTR, m_ulSize );
                if (m_pBuffer)
                {
                    if (m_bProgress)
                    {
                        if (SUCCEEDED(CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog )) && m_pWiaProgressDialog)
                        {
                            if (!SUCCEEDED(m_pWiaProgressDialog->Create( NULL, WIA_PROGRESSDLG_NO_CANCEL|WIA_PROGRESSDLG_NO_ANIM)))
                            {
                                m_pWiaProgressDialog->Destroy();
                                m_pWiaProgressDialog = NULL;
                            }
                        }
                    }

                    if (m_pWiaProgressDialog)
                    {
                        m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_RETREIVING, GLOBAL_HINSTANCE)));
                        m_pWiaProgressDialog->SetMessage( L"" );
                        m_pWiaProgressDialog->Show();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        break;


        case IT_MSG_STATUS:
        {
            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE)
            {
                static BOOL bSetText = FALSE;

                if (m_pWiaProgressDialog)
                {
                    if (!bSetText)
                    {
                        m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString (IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE)));
                        bSetText = TRUE;
                    }
                    m_pWiaProgressDialog->SetPercentComplete( lPercentComplete );
                }
            }
        }
        break;

        case IT_MSG_DATA:
        {
            if (m_pBuffer)
            {
                bool bSet = false;
                if ((m_ulWritePos+lLength) > m_ulSize)
                {
                    TraceAssert (FALSE);
                    Trace(TEXT("m_ulWritePos+lLength > m_ulSize!"));
                    lLength = m_ulSize - m_ulWritePos;
                }
                if (m_bFirstTransfer)
                    {
                        bSet = true;
                        if (m_pWiaProgressDialog)
                        {
                            m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE)));
                        }


                        if (IsEqualGUID (m_guidFormat, WiaImgFmt_MEMORYBMP) )
                        {
                            UINT uiSrcScanLineWidth;
                            UINT uiScanLineWidth;
                            UINT cbDibSize;
                            UINT cbClrTableSize;
                            BITMAPINFO * pbi = (BITMAPINFO *)pbData;

                            //
                            // If we're transferring as a DIB, we need to write out the
                            // BITMAPFILEHEADER first...
                            //



                            // Calculate the size of the color table
                            if ((pbi->bmiHeader.biClrUsed==0) && (pbi->bmiHeader.biBitCount!=24))
                            {
                                cbClrTableSize = sizeof(RGBQUAD) * (DWORD)(1 << pbi->bmiHeader.biBitCount);
                            }
                            else
                            {
                                cbClrTableSize = sizeof(RGBQUAD) * pbi->bmiHeader.biClrUsed;
                            }

                            // Align scanline to ULONG boundary
                            uiSrcScanLineWidth = (pbi->bmiHeader.biWidth * pbi->bmiHeader.biBitCount) / 8;
                            uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

                            // Calculate DIB size and allocate memory for the DIB.
                            cbDibSize = (pbi->bmiHeader.biHeight > 0) ?
                                            pbi->bmiHeader.biHeight  * uiScanLineWidth :
                                          -(pbi->bmiHeader.biHeight) * uiScanLineWidth;

                            cbDibSize += (sizeof(BITMAPFILEHEADER) + pbi->bmiHeader.biSize + cbClrTableSize);



                            BITMAPFILEHEADER bmfh;

                            bmfh.bfType = 'MB';
                            bmfh.bfSize = cbDibSize;
                            bmfh.bfOffBits = lLength + sizeof(BITMAPFILEHEADER);

                            memcpy( (LPBYTE)m_pBuffer + m_ulWritePos, &bmfh, sizeof(BITMAPFILEHEADER) );
                            InterlockedExchangeAdd (reinterpret_cast<LONG*>(&m_ulWritePos),sizeof(BITMAPFILEHEADER));

                            
                        }
                        m_bFirstTransfer = FALSE;
                    }

                memcpy( (LPBYTE)m_pBuffer + m_ulWritePos, pbData, lLength );
                InterlockedExchangeAdd (reinterpret_cast<LONG*>(&m_ulWritePos), lLength);

                if (bSet)
                {
                    Trace (TEXT("Setting the start event from the callback"));
                    if (m_hEventStart)
                    {
                        SetEvent (m_hEventStart); // let the Read know there is data
                    }
                }

                Trace(TEXT("m_ulWritePos = %d, just transferred %d bytes"), m_ulWritePos, lLength);

                if (m_pWiaProgressDialog && m_ulSize)
                {
                    Trace (TEXT("Updating the status percent"));
                    m_pWiaProgressDialog->SetPercentComplete( (m_ulWritePos * 100) / m_ulSize );
                }
            }
            else
            {
                Trace (TEXT("m_pBuffer is NULL, returning E_FAIL"));
                hr = E_FAIL;
            }

        }
        break;

        case IT_MSG_TERMINATION:
        {
            if (m_pWiaProgressDialog)
            {
                m_pWiaProgressDialog->SetPercentComplete( 100 );
            }
            // an error occurred, no data received
            if (m_bFirstTransfer && m_hEventStart)
            {
                SetEvent(m_hEventStart);
            }

            Trace(TEXT("transfer complete"));
            m_bTransferred = TRUE;
        }
        break;

    }


    if ((lStatus == IT_STATUS_TRANSFER_TO_CLIENT) && (lPercentComplete == 100))
    {
        m_bTransferred = TRUE;
        Trace(TEXT("transfer complete"));
    }
    Trace (TEXT("LEAVE: CImageStream::BandedDataCallback: %x"), hr);
    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\tls.cpp ===
//
// Define a set of classes for managing the TLS data
// used by the shell extension
// Note that we do a potentially unsafe release of a COM interface but 
// this release has never caused a deadlock in WinME or XP.
#include <precomp.hxx>
#include "tls.h"

// The TlsHolder will be stored initially on an SList when created,
// then moved into a linked list during THREAD_DETACH
// During PROCESS_DETACH, all TlsHolder objects are deleted
class TlsManager::TlsHolder : public SLIST_ENTRY
{
public:
    TlsHolder() : _pNext(NULL), _pPrev(NULL) 
    {
        _apObjects = new ThreadLocalObject*[g_tls._nSlots];        
    }   
    ~TlsHolder() 
    {
        if (_apObjects)
        {
            for (ULONG i=0;i<g_tls._nSlots;++i)
            {
                DoDelete(_apObjects[i]);
            }
            delete [] _apObjects;
        }
    }
    TlsHolder *_pNext;
    TlsHolder *_pPrev;
    ThreadLocalObject **_apObjects;

private:
    TlsHolder( const TlsHolder& ); 
    TlsHolder& operator=( const TlsHolder& );
};


TlsManager::TlsManager() :
    _dwIndex( DWORD( -1 ) ),
    _nSlots( 0 ),
    _pFirstHolder( NULL ),
    _pLastHolder( NULL )
{
    InitializeSListHead(&_slist);
    _dwIndex = ::TlsAlloc();    
}

TlsManager::~TlsManager()
{
    // Always called inside of DllMain, so no synchronization needed

    TransferNewHolders();

    // Delete all of the holders
    TlsHolder* pHolder = _pFirstHolder;
    while( pHolder != NULL )
    {
        TlsHolder* pKill = pHolder;
        pHolder = pHolder->_pNext;
        delete pKill;
    }

    ::TlsFree(_dwIndex);
}

void TlsManager::OnThreadAttach() 
{
}

void TlsManager::OnThreadDetach() 
{
    // Always called inside of DllMain, so no synchronization needed
    TransferNewHolders();

    TlsHolder* pHolder = static_cast< TlsHolder* >( ::TlsGetValue(_dwIndex) );
    if( pHolder != NULL )
    {
        // Remove the holder from the non-synchronized list
        if( pHolder->_pNext == NULL )
        {
            _pLastHolder = pHolder->_pPrev;
        }
        else
        {
            pHolder->_pNext->_pPrev = pHolder->_pPrev;
        }
        if( pHolder->_pPrev == NULL )
        {            
            _pFirstHolder = pHolder->_pNext;
        }
        else
        {
            pHolder->_pPrev->_pNext = pHolder->_pNext;
        }
        delete pHolder;
    }
}

ULONG TlsManager::RegisterSlot()
{
    ULONG iSlot = _nSlots;
    _nSlots++;

    return( iSlot );
}

ThreadLocalObject* TlsManager::GetData( ULONG iSlot )
{
    TlsHolder* pHolder = static_cast< TlsHolder* >( ::TlsGetValue( _dwIndex ) );
    if( pHolder == NULL )
    {
        return( NULL );
    }
    return( pHolder->_apObjects[iSlot] );
}

BOOL TlsManager::SetData( ULONG iSlot, ThreadLocalObject *pObject )
{
    BOOL bRet = FALSE;
    TlsHolder* pHolder = static_cast< TlsHolder* >( ::TlsGetValue( _dwIndex ) );
    if( pHolder == NULL )
    {
        pHolder = CreateThreadData();
    }
    if (pHolder)
    {
        pHolder->_apObjects[iSlot] = pObject;
        bRet = TRUE;
    }   
    return bRet;
}

TlsManager::TlsHolder* TlsManager::CreateThreadData()
{
    TlsHolder* pHolder = new TlsHolder;
    BOOL bSuccess = pHolder && pHolder->_apObjects ? ::TlsSetValue( _dwIndex, pHolder ) : FALSE;
    if(!bSuccess)
    {
        delete pHolder;
    }
    else
    {
        InterlockedPushEntrySList( &_slist, pHolder );
    }
    return( pHolder );
}

void TlsManager::TransferNewHolders() throw()
{
    // Pop all entries off the slist, and link them into the non-synchronized list
    for( TlsHolder* pHolder = static_cast< TlsHolder* >( InterlockedFlushSList( &_slist ) ); pHolder != NULL; pHolder = static_cast< TlsHolder* >( pHolder->Next ) )
    {
        if( _pFirstHolder == NULL )
        {
            _pFirstHolder = pHolder;
            _pLastHolder = pHolder;
        }
        else
        {
            pHolder->_pNext = _pFirstHolder;
            _pFirstHolder->_pPrev = pHolder;
            _pFirstHolder = pHolder;
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
// class CThreadLocalObject
///////////////////////////////////////////////////////////////////////////////

ThreadLocalObject::ThreadLocalObject() 
{
}

ThreadLocalObject::~ThreadLocalObject()
{
}


///////////////////////////////////////////////////////////////////////////////
// class CTLSSlotBase
///////////////////////////////////////////////////////////////////////////////

TlsSlotBase::TlsSlotBase() :
    _iSlot( g_tls.RegisterSlot() )
{
}

TlsSlotBase::~TlsSlotBase()
{
}


TlsManager g_tls;
TLSSLOT g_tlsSlot;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\util.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 2002
 *
 *  TITLE:       util.h
 *
 *  DESCRIPTION: utility function definitions, etc.
 *
 *****************************************************************************/



#ifndef __util_h
#define __util_h

#define DC_INITIALIZE       (WM_USER+1)
#define DC_DESTROY          (WM_USER+2)
#define DC_GETDEVICE        (WM_USER+3)  // wParam = lpcr, lParam = Handle of event to signal
#define DC_GETDEVMGR        (WM_USER+4)  // wParam = Ptr to DWORD = g_dwDevMgrCookie on return, NULL if error, lParam = Handle of event to signal
#define DC_REFRESH          (WM_USER+5) // lparam = ptr to device id to recreate


void RecreateDevice (LPCWSTR szDeviceId);

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);

HRESULT GetDeviceIdFromDevice (IWiaItem *pWiaItemRoot, LPWSTR szDeviceId);
HRESULT GetDeviceIdFromItem (IWiaItem *pItem, LPWSTR szDeviceId);
HRESULT GetClsidFromDevice (IUnknown *pWiaItemRoot, CSimpleString &strClsid);
HRESULT GetDeviceTypeFromDevice (IUnknown *pWiaItemRoot, WORD *pwType);
HRESULT GetDevMgrObject( LPVOID * ppDevMgr );
HRESULT TryEnumDeviceInfo (DWORD dwFlags, IEnumWIA_DEV_INFO **ppEnum);
ULONG   GetRealSizeFromItem (IWiaItem *pItem);
VOID    SetTransferFormat (IWiaItem *pItem, WIA_FORMAT_INFO &fmt);
BOOL    TimeToStrings (SYSTEMTIME *pst, LPTSTR szTime, LPTSTR szDate);
BOOL    IsPlatformNT();
HRESULT RemoveDevice (LPCWSTR strDeviceId);
VOID    IssueChangeNotifyForDevice (LPCWSTR szDeviceId, LONG lEvent, LPITEMIDLIST pidl);
HRESULT BindToDevice (const CSimpleStringWide &strDeviceId, REFIID riid, LPVOID *ppvObj, LPITEMIDLIST *ppidl=NULL);
HRESULT GetDataObjectForItem (IWiaItem *pItem, IDataObject **ppdo);
HRESULT GetDataObjectForStiDevice (LPITEMIDLIST pidl, IDataObject **ppdo);
HRESULT MakeFullPidlForDevice (LPCWSTR pDeviceId, LPITEMIDLIST *ppidl);
HRESULT GetSTIInfoFromId (LPCWSTR szDeviceId, PSTI_DEVICE_INFORMATION *ppsdi);
HRESULT SaveSoundToFile (IWiaItem *pItem, CSimpleString szFile);
VOID    InvalidateDeviceCache ();
VOID    VerifyCachedDevice(IWiaItem *pRoot);

HRESULT GetDeviceParentFolder (const CSimpleStringWide &strDeviceId, CComPtr<IShellFolder> &psf,LPITEMIDLIST *ppidlFull);

#if (defined(DEBUG) && defined(SHOW_PATHS))
void PrintPath( LPITEMIDLIST pidl );
void StrretToString( LPSTRRET pStr, LPITEMIDLIST pidl, LPTSTR psz, UINT cch );
#endif

#if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))
void PrintAttributes( DWORD dwAttr );
#endif
BOOL UserCanModifyDevice ();
BOOL CanShowAddDevice();
void MyCoUninitialize();

void RunWizardAsync(LPCWSTR pszDeviceId);
HINSTANCE LoadClassInstaller();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\tls.h ===
#pragma once

// All data stored in a TLS slot must derive from ThreadLocalObject
class ThreadLocalObject
{
protected:
    ThreadLocalObject();

public:
    virtual ~ThreadLocalObject();

private:
    ThreadLocalObject( const ThreadLocalObject& );
    ThreadLocalObject& operator=( const ThreadLocalObject& );
};

// TlsManager will have 1 global instance
class TlsManager
{
private:
    class TlsHolder;

public:
    TlsManager();
    ~TlsManager();
    ThreadLocalObject *GetData(ULONG iSlot);
    BOOL SetData(ULONG iSlot, ThreadLocalObject *pData);
    ULONG RegisterSlot();
    void OnThreadAttach();
    void OnThreadDetach();

private:
    TlsHolder *CreateThreadData();
    void TransferNewHolders();

private:
    DWORD _dwIndex;
    ULONG _nSlots;
    SLIST_HEADER _slist;
    TlsHolder *_pFirstHolder;
    TlsHolder *_pLastHolder;
};

// Derivatives of TlsSlot should exist 1:1 with each type of data
// that has its own TLS slot
class TlsSlotBase
{
protected:
    TlsSlotBase();
    ~TlsSlotBase();

protected:
    const ULONG _iSlot;

private:
    TlsSlotBase( const TlsSlotBase& ) throw();
    TlsSlotBase& operator=( const TlsSlotBase& );
};


template< class T >
class TlsSlot : public TlsSlotBase
{
public:
    TlsSlot();
    ~TlsSlot();

    T* GetObject(bool bCreate = true);

private:
    T* CreateObject();

private:
    TlsSlot( const TlsSlot& );
    TlsSlot& operator=( const TlsSlot& );

};

template< class T >
inline TlsSlot< T >::TlsSlot()
{
}

template< class T >
inline TlsSlot< T >::~TlsSlot()
{
}

template< class T >
inline T* TlsSlot< T >::GetObject( bool bCreate /* = true */ ) 
{
    T* pObject = static_cast< T* >( g_tls.GetData(_iSlot) );
    if( (pObject == NULL) && bCreate )
    {
        pObject = CreateObject();
    }

    return( pObject );
}

template< class T >
inline T* TlsSlot< T >::CreateObject() 
{
    T* pObject = new T;
    if (pObject)
    {
        if (!g_tls.SetData(_iSlot, pObject))
        {
            delete pObject;
            pObject = NULL;
        }       
    }
    return( pObject );
}


// TLSDATA is used for IWiaItem caching
class TLSDATA : public ThreadLocalObject
{
public:
    CComBSTR strDeviceId;
    IWiaItem *pDevice; // only Released during cache invalidation, not destruction
    TLSDATA *pNext;
    ~TLSDATA()
    {
        if (pNext)
        {
            delete pNext;
        }
    }   
};

class TLSSLOT : public TlsSlot<TLSDATA>
{

};


// Define globals for the manager and for each slot we need.
// Currently wiashext only needs 1 slot, for the device cache
extern TlsManager g_tls;
extern TLSSLOT g_tlsSlot;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\util.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2002
 *
 *  TITLE:       util.cpp
 *
 *  DESCRIPTION: utility functions needed for this dll
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "runwiz.h"
#include "tls.h"
#pragma hdrstop


static WCHAR BOGUSDEVICEID[]= L"bogusdeviceid";

void CreateCacheEntry(CSimpleStringWide &strDeviceId, IWiaItem *pDevice)
{
    TLSDATA *pData = g_tlsSlot.GetObject(false);
    TLSDATA *pNew = pData ? new TLSDATA : g_tlsSlot.GetObject(true);
    if (pNew)
    {
        DoRelease(pNew->pDevice);
        pNew->pDevice = pDevice;
        pNew->pDevice->AddRef();
        pNew->strDeviceId = CComBSTR(strDeviceId.String());
        if (pData)
        {
            pNew->pNext = pData->pNext;
            pData->pNext = pNew;
        }                   
        else
        {
            pNew->pNext = NULL; // good to be explicit
        }
    }
}


HRESULT
GetDeviceFromEnum (IWiaDevMgr *pDevMgr, BSTR bstrDeviceId, PVOID *ppStg)
{
    HRESULT hr;

    CComPtr<IEnumWIA_DEV_INFO> pEnum;
    CComPtr<IWiaPropertyStorage> pStg;
    TraceEnter (TRACE_UTIL,"GetDeviceFromEnum");
    {

        ULONG ul;
        bool bFound = false;
        CSimpleStringWide strId;
        hr = pDevMgr->EnumDeviceInfo (0, &pEnum);

        while (SUCCEEDED(hr) && !bFound && S_OK == pEnum->Next (1, &pStg, &ul))
        {
            PropStorageHelpers::GetProperty(pStg, WIA_DIP_DEV_ID, strId);
            if (!wcscmp(strId, bstrDeviceId))
            {
                bFound = true;
                hr = pStg->QueryInterface(IID_IWiaPropertyStorage, ppStg);
            }
        }
        if (!bFound)
        {
            Trace(TEXT("Device %ls not found in enumeration!"), bstrDeviceId);
            hr = E_FAIL;
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

    InvalidateDeviceCache

    Delete the current thread's device cache.

*****************************************************************************/

VOID
InvalidateDeviceCache ()
{
    TraceEnter (TRACE_UTIL, "InvalidateDeviceCache");
    TLSDATA *pData = g_tlsSlot.GetObject(false);
    TLSDATA *pTail = pData ? pData->pNext : NULL;
    TLSDATA *pNext;
    while (pData)
    {
        pData->strDeviceId = CComBSTR(BOGUSDEVICEID);
        DoRelease(pData->pDevice);
        pNext = pData->pNext;
        if (pNext && pTail == pNext)
        {
            pData->pNext = NULL;
        }
        pData = pNext;              
    }
    DoDelete(pTail); // cut off the rest of the list
    TraceLeave ();
}
/*****************************************************************************

   GetDeviceFromDeviceId

   Given a device id, return the appropriate interface for that device. We cache
   interface pointers for a given device id in a structure on the current
   thread's TLS index.

 *****************************************************************************/
enum CreateDelayParams
{
    MaxRetries = 20,
    MinSleepTime = 100,
    SleepIncrement = 250
};

HRESULT
GetDeviceFromDeviceId( LPCWSTR pWiaItemRootId,
                       REFIID riid,
                       LPVOID * ppWiaItemRoot,
                       BOOL bShowProgress
                      )
{
    HRESULT             hr = E_FAIL;
    CComPtr<IWiaDevMgr> pDevMgr;
    TraceEnter( TRACE_UTIL, "GetDeviceFromDeviceId" );

    *ppWiaItemRoot = NULL;

    if (IsEqualGUID(riid, IID_IWiaPropertyStorage))
    {
        if (SUCCEEDED(GetDevMgrObject((void**)&pDevMgr)))
        {
            hr = GetDeviceFromEnum (pDevMgr,
                                    CComBSTR(pWiaItemRootId),
                                    ppWiaItemRoot);
        }
    }
    else
    {
        // first see if a cache entry exists. Use false to GetObject
        // because we don't want to create a new entry just yet if none exists
        TLSDATA *pData = g_tlsSlot.GetObject(false);
        TLSDATA *pCur = pData;

        while (pCur && !*ppWiaItemRoot)
        {
            if (!wcscmp(pWiaItemRootId, pCur->strDeviceId))
            {
                Trace(TEXT("Found device in cache"));
                hr = pCur->pDevice->QueryInterface (riid, ppWiaItemRoot);
                // if this fails, set the node's device id to a bogus id
                // and fall back to createdevice
                if (FAILED(hr))
                {
                    Trace(TEXT("QI on the root item failed: %x"), hr);
                    pCur->strDeviceId = CComBSTR(BOGUSDEVICEID);
                    DoRelease(pCur->pDevice);
                    *ppWiaItemRoot = NULL;
                    pCur = NULL;
                }
            }
            else
            {
                pCur = pCur->pNext;
            }
        }
        if (!*ppWiaItemRoot)
        {
            CComPtr<IWiaItem> pDevice;
            if (SUCCEEDED(GetDevMgrObject((void**)&pDevMgr)))
            {
                INT c=MaxRetries;
                CComPtr<IWiaProgressDialog> pProgress;
                BOOL bCancelled =FALSE;
                if (bShowProgress && SUCCEEDED(CoCreateInstance(CLSID_WiaDefaultUi,
                                               NULL,
                                               CLSCTX_INPROC_SERVER,
                                               IID_IWiaProgressDialog,
                                               reinterpret_cast<void**>(&pProgress))))
                {
                    if (!SUCCEEDED(pProgress->Create(NULL, WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE | WIA_PROGRESSDLG_NO_PROGRESS)))
                    {
                        pProgress->Destroy();
                        pProgress = NULL;
                        bShowProgress = FALSE;
                    }
                    else
                    {
                        pProgress->SetTitle(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_CAPTION, GLOBAL_HINSTANCE)));
                        pProgress->SetMessage(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_WAITING, GLOBAL_HINSTANCE)));
                        pProgress->Show();
                    }
                }
                else
                {
                    bShowProgress = FALSE;
                }
                // Try to call CreateDevice up to 20 times if it is returning
                // WIA_ERROR_BUSY
                // if caller wants progress UI, show the progress dialog
                // and don't terminate unless the user presses cancel or
                // the create returns something besides WIA_ERROR_BUSY
                DWORD dwSleep = MinSleepTime;
                do
                {
                    Trace(TEXT("Calling CreateDevice"));
                    hr = pDevMgr->CreateDevice (CComBSTR(pWiaItemRootId),
                                                &pDevice);
                    if (hr == WIA_ERROR_BUSY)
                    {
                        Sleep(dwSleep);
                        if (bShowProgress)
                        {
                            pProgress->SetMessage(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_BUSY, GLOBAL_HINSTANCE)));
                            pProgress->Cancelled(&bCancelled);
                        }
                        else
                        {
                            c--;
                        }
                        dwSleep += SleepIncrement;
                    }
                } while (c && hr == WIA_ERROR_BUSY && !bCancelled);
                if (bShowProgress)
                {
                    pProgress->Cancelled(&bCancelled);
                    pProgress->Destroy();
                    if (bCancelled)
                    {
                        hr = E_ABORT;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                // If a cache exists, append the new guy to the list, otherwise
                // start a new list
                CreateCacheEntry(CSimpleStringWide(pWiaItemRootId), pDevice);                
            }
            if (SUCCEEDED(hr) && pDevice.p)
            {
                hr = pDevice->QueryInterface (riid, ppWiaItemRoot);
            }
        }
    }
    TraceLeaveResult(hr);
}




/*****************************************************************************

   GetDeviceIdFromDevice

   Read the DeviceId property.  Assumes the szDeviceId param is big enough.

 *****************************************************************************/

HRESULT
GetDeviceIdFromDevice (IWiaItem *pWiaItemRoot, LPWSTR szDeviceId)
{
    HRESULT hr = E_FAIL;

    TraceEnter (TRACE_UTIL, "GetDeviceIdFromDevice");

    *szDeviceId = L'\0';
    CSimpleStringWide strDeviceId;
    if (PropStorageHelpers::GetProperty (pWiaItemRoot, WIA_DIP_DEV_ID, strDeviceId))
    {
        lstrcpyn (szDeviceId, strDeviceId, STI_MAX_INTERNAL_NAME_LENGTH);
        hr = S_OK;
    }
    TraceLeaveResult (hr);
}



/*****************************************************************************

   GetDeviceIdFromItem

   Read the DeviceId property. Assumes the szDeviceId param is big enough

 *****************************************************************************/

HRESULT
GetDeviceIdFromItem (IWiaItem *pItem, LPWSTR szDeviceId)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IWiaItem>   pWiaItemRoot;

    TraceEnter (TRACE_UTIL, "GetDeviceIdFromItem");

    *szDeviceId = TEXT('\0');

    if (pItem)
    {
        hr = pItem->GetRootItem (&pWiaItemRoot);
        if (pWiaItemRoot)
        {
            hr = GetDeviceIdFromDevice (pWiaItemRoot, szDeviceId);
        }
    }

    TraceLeaveResult (hr);
}


/*****************************************************************************

   GetClsidFromDevice

   Returns the CLSID of the device's UI extensions

 *****************************************************************************/

HRESULT
GetClsidFromDevice (IUnknown *punk,
                    CSimpleString &strClsid)
{
    HRESULT hr = E_FAIL;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(punk);
    TraceEnter (TRACE_UTIL, "GetClsidFromDevice");

    strClsid = CSimpleString(TEXT(""));
    if (pps)
    {
        PROPSPEC psp;
        PROPVARIANT pv;

        psp.ulKind = PRSPEC_PROPID;
        psp.propid = WIA_DIP_UI_CLSID;
        if (S_OK == (hr = pps->ReadMultiple (1, &psp, &pv)))
        {
            Trace(TEXT("bstrVal for clsid is %ls"), pv.bstrVal);

            strClsid = CSimpleStringConvert::NaturalString(CSimpleStringWide(pv.bstrVal));
            FreePropVariantArray (1, &pv);
        }
    }
    Trace(TEXT("UI Clsid is %s"), strClsid.String());
    TraceLeaveResult (hr);
}


/*****************************************************************************

   GetDeviceTypeFromDevice

   Returns type of the device

 *****************************************************************************/

HRESULT
GetDeviceTypeFromDevice (IUnknown *pWiaItemRoot, WORD *pwType)
{
    HRESULT hr = E_FAIL;
    LONG lType = 0;
    TraceEnter (TRACE_UTIL, "GetDeviceTypeFromDevice");
    if (pwType)
    {
        *pwType = StiDeviceTypeDefault;
    }
    if (pwType && PropStorageHelpers::GetProperty(pWiaItemRoot, WIA_DIP_DEV_TYPE, lType))
    {
        *pwType = GET_STIDEVICE_TYPE(lType);
        hr = S_OK;
    }

    TraceLeaveResult (hr);
}



/*****************************************************************************

   GetDevMgrObject

   Gets the global devmgr object

 *****************************************************************************/

HRESULT
GetDevMgrObject( LPVOID * ppDevMgr )
{

    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "GetDevMgrObject");
    
    hr = CoCreateInstance (CLSID_WiaDevMgr,
                           NULL,
                           CLSCTX_LOCAL_SERVER | CLSCTX_NO_FAILURE_LOG,
                           IID_IWiaDevMgr,
                           ppDevMgr);
    
    TraceLeaveResult( hr );
}





/*****************************************************************************

   SetTransferFormat

   Tell the device what kind of image data we want

 *****************************************************************************/

VOID
SetTransferFormat (IWiaItem *pItem, WIA_FORMAT_INFO &fmt)
{
    HRESULT hr = E_FAIL;

    TraceEnter( TRACE_UTIL, "SetTransferFormat" );

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);

    if (pps)
    {
        PROPVARIANT pv[2];

        PROPSPEC ps[2] = {
                          {PRSPEC_PROPID, WIA_IPA_FORMAT},
                          {PRSPEC_PROPID, WIA_IPA_TYMED}
                         };
        pv[0].vt = VT_CLSID;
        pv[1].vt = VT_I4;
        pv[0].puuid = &(fmt.guidFormatID);
        pv[1].lVal = fmt.lTymed;
        TraceGUID ("Transfer format guid:", fmt.guidFormatID);
        Trace (TEXT("Tymed: %d"), fmt.lTymed);
        hr = pps->WriteMultiple (2, ps, pv, 2);

        Trace(TEXT("WriteMultiple returned %x in SetTransferFormat"), hr);

    }

    TraceLeaveResultNoRet (hr);
}


/*****************************************************************************

   AddDeviceWasChosen

   RunnDll32 entrypoint for when the "add device" button is chosen.

 *****************************************************************************/
static const CHAR cszAddProc[] = "WiaAddDevice";
static const CHAR cszRemoveProc[] = "WiaRemoveDevice";

typedef HANDLE (WINAPI *AddDevProc)();
typedef BOOL (WINAPI *RemoveDevProc)(STI_DEVICE_INFORMATION *);
void
AddDeviceWasChosen(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{

    HMODULE hClassInst = NULL;
    HRESULT hr = E_FAIL;
    AddDevProc fnAddDevice;
    TraceEnter( TRACE_UTIL, "AddDeviceWasChosen" );

    if (!UserCanModifyDevice())
    {
        UIErrors::ReportMessage(hwndStub, GLOBAL_HINSTANCE, NULL,
                                MAKEINTRESOURCE(IDS_PRIVILEGE_CAPTION),
                                MAKEINTRESOURCE(IDS_CANT_INSTALL), MB_OK);
    }
    else
    {
        hr = CoInitialize (NULL);
    }

    if (SUCCEEDED(hr))
    {
        hClassInst = LoadClassInstaller();
        if (hClassInst)
        {
            fnAddDevice = reinterpret_cast<AddDevProc>(GetProcAddress(hClassInst, cszAddProc));
            if (fnAddDevice)
            {

                HANDLE hProcess;
                hProcess = fnAddDevice();
                if (hProcess)
                {
                    WiaUiUtil::MsgWaitForSingleObject (hProcess, INFINITE);
                    CloseHandle (hProcess);
                }
                // our folder will get a connect event when installation completes.
            }
            FreeLibrary (hClassInst);
        }

        MyCoUninitialize();
    }

    TraceLeave();
}

void AddDeviceWasChosenW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    TraceEnter( TRACE_UTIL, "AddDeviceWasChosenW" );


    // we don't use the commandline param for anything
    AddDeviceWasChosen (hwndStub, hAppInstance, NULL, 0);
    TraceLeave();
}

/*****************************************************************************

    RemoveDevice

    Uninstalls the device with the given device ID
*****************************************************************************/
struct RemoveDevInfo
{
    CComBSTR bstrDeviceId;
    HINSTANCE hLib;
};

LRESULT
RemoveDeviceThreadProc (RemoveDevInfo *pInfo)
{
    STI_DEVICE_INFORMATION *psdi;
    CComPtr<IStillImage> pSti;
    HRESULT hr ;

    HMODULE hClassInst;
    RemoveDevProc fnRemoveDevice;

    TraceEnter (TRACE_UTIL, "RemoveDeviceThreadProc");
    hr = StiCreateInstance (GLOBAL_HINSTANCE, STI_VERSION, &pSti, NULL);
    if (SUCCEEDED(hr) && pSti)
    {
        hr = pSti->GetDeviceInfo (pInfo->bstrDeviceId,
                                  reinterpret_cast<LPVOID*>(&psdi));
        if (SUCCEEDED(hr) && psdi)
        {
            hClassInst = LoadClassInstaller();
            fnRemoveDevice = reinterpret_cast<RemoveDevProc>(GetProcAddress(hClassInst, cszRemoveProc));
            if (fnRemoveDevice)
            {
                if (!fnRemoveDevice (psdi))
                {
                    hr = S_FALSE;
                    UIErrors::ReportMessage(NULL,
                                            GLOBAL_HINSTANCE,
                                            NULL,
                                            MAKEINTRESOURCE(IDS_TITLEDELETE_ERROR),
                                            MAKEINTRESOURCE(IDS_DELETE_ERROR),
                                            MB_ICONINFORMATION);
                }
            }
            if (hClassInst)
            {
                FreeLibrary (hClassInst);
            }
            LocalFree (psdi);
        }
    }
    TraceLeave();
    HINSTANCE hLib = pInfo->hLib;
    delete pInfo;
    FreeLibraryAndExitThread(hLib, 0);
}

HRESULT
RemoveDevice (LPCWSTR strDeviceId)
{
    HRESULT hr = E_OUTOFMEMORY;
    DWORD dwTid;
    TraceEnter (TRACE_UTIL, "RemoveDevice");
    RemoveDevInfo *pInfo = new RemoveDevInfo;
    if (pInfo)
    {
        pInfo->hLib = LoadLibrary(TEXT("wiashext.dll"));
        pInfo->bstrDeviceId = strDeviceId;
        HANDLE hThread = CreateThread (NULL, 0,
                                       reinterpret_cast<LPTHREAD_START_ROUTINE>(RemoveDeviceThreadProc),
                                       pInfo, 0, &dwTid);
        if (hThread)
        {
            CloseHandle (hThread);
            hr = S_OK;
        }
        else
        {
            FreeLibrary(pInfo->hLib);
            delete pInfo;
        }
    }
    TraceLeaveResult (hr);
}
/*****************************************************************************

   TimeToStrings

   Assumes buffers at least MAX_PATH long

 *****************************************************************************/

BOOL
TimeToStrings ( SYSTEMTIME *pst,
                LPTSTR szTime,
                LPTSTR szDate)
{

    BOOL iRes = TRUE;
    TraceEnter (TRACE_UTIL, "TimeToStrings");
    // make sure we're one-based
    if (!pst->wMonth)
    {
        pst->wMonth = 1; // force January
    }
    if (szDate)
    {
        *szDate = TEXT('\0');
        iRes = GetDateFormat( LOCALE_USER_DEFAULT,
                              0,
                              pst,
                              NULL, //TEXT("ddd',' MMM dd yyyy"),
                              szDate,
                              MAX_PATH
                             );

        if (!iRes)
        {
            Trace (TEXT("GetDateFormat failed in CameraItemUpdateProc: %d"), GetLastError());
        }
    }

    if (iRes && szTime)
    {
        *szTime = TEXT('\0');

        //
        // Set the image/container time
        //


        iRes = GetTimeFormat( LOCALE_USER_DEFAULT,
                              0,
                              pst,
                              NULL,//TEXT("hh':'mm':'ss tt"),
                              szTime,
                              MAX_PATH
                             );
        if (!iRes)
        {
            Trace (TEXT("GetTimeFormat failed in CameraItemUpdateProc: %d"), GetLastError());
        }
    }
    TraceLeave ();
    return iRes;
}


#if (defined(DEBUG) && defined(SHOW_PATHS))
////////////////////////////////////////////////////////
//
// PrintPath
//
//   Debug code to print out a path, given a pidl.
//
////////////////////////////////////////////////////////
void PrintPath( LPITEMIDLIST pidl )
{
    TCHAR szPath[ MAX_PATH ];

    TraceEnter (TRACE_UTIL, "PrintPath");
    if (SHGetPathFromIDList( pidl, szPath ))
    {
        LPTSTR pFileName = PathFindFileName( szPath );

        Trace(TEXT("shell pidl points to '%s'"), pFileName );
    }
    else
    {
        Trace(TEXT("*** Couldn't get path from shell pidl! ***"));
    }
    TraceLeave ();
}

#endif


BOOL
IsPlatformNT()
{
    OSVERSIONINFO  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc

/******************************************************************************

GetRealSizeFromItem

Query the item for its size based on the current format and tymed settings

******************************************************************************/


ULONG
GetRealSizeFromItem (IWiaItem *pItem)
{
    ULONG uRet = 0;
    CComQIPtr <IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps;
    TraceEnter (TRACE_UTIL, "GetRealSizeFromItem");
    pps = pItem;
    if (pps)
    {
        PROPVARIANT pv;
        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = WIA_IPA_ITEM_SIZE;
        if (S_OK == pps->ReadMultiple(1, &ps, &pv))
        {
            uRet = pv.ulVal;
            PropVariantClear (&pv);
        }
    }
    TraceLeave();
    return uRet;
}


HRESULT
SaveSoundToFile (IWiaItem *pItem, CSimpleString szFile)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    PROPVARIANT pv;
    PROPSPEC ps;
    TraceEnter (TRACE_UTIL, "SaveSoundToFile");
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = WIA_IPC_AUDIO_DATA;
    if (pps)
    {
        hr = pps->ReadMultiple (1, &ps, &pv);
        if (S_OK == hr)
        {
            TraceAssert (pv.caub.cElems);
            hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE != hFile)
            {
                DWORD dwWritten;
                if (!WriteFile (hFile, pv.caub.pElems, pv.caub.cElems, &dwWritten, NULL))
                {
                    DWORD dw = GetLastError ();
                    hr = HRESULT_FROM_WIN32(dw);
                }
                else if (dwWritten < pv.caub.cElems)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                }
                else
                {
                    hr = S_OK;
                }
                CloseHandle (hFile);
                if (FAILED(hr))
                {
                    DeleteFile (szFile);
                }
            }
            else
            {
                DWORD dw = GetLastError ();
                hr = HRESULT_FROM_WIN32(dw);
            }
        }
        else
        {
            hr = E_FAIL; //S_FALSE is the same as a failure for us
        }
    }
    PropVariantClear (&pv);
    TraceLeaveResult (hr);
}

STDAPI_(HRESULT)
TakeAPicture (BSTR strDeviceId)
{
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "TakeAPicture");
    CComPtr<IWiaItem> pDevice;
    CComPtr<IWiaItem> pItem;
    hr = GetDeviceFromDeviceId (strDeviceId,
                                IID_IWiaItem,
                                reinterpret_cast<LPVOID*>(&pDevice),
                                TRUE);
    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strName;
        hr = pDevice->DeviceCommand (0,
                                     &WIA_CMD_TAKE_PICTURE,
                                     &pItem);
        if (SUCCEEDED(hr))
        {
            IssueChangeNotifyForDevice (strDeviceId, SHCNE_UPDATEDIR, NULL);
        }
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

    IssueChangeNotifyForDevice

    Given a device id, find this device in the My Computer folder and
    get its full PIDL. Issue a SHChangeNotify as requested.
******************************************************************************/

VOID
IssueChangeNotifyForDevice (LPCWSTR szDeviceId, LONG lEvent, LPITEMIDLIST pidl)
{
    TraceEnter (TRACE_UTIL, "IssueChangeNotifyForDevice");
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlCpl    = NULL;
    LPITEMIDLIST pidlUpdate = NULL;
    if (!szDeviceId)
    {
        SHGetSpecialFolderLocation (NULL, CSIDL_DRIVES, &pidlFolder);
        SHGetSpecialFolderLocation (NULL, CSIDL_CONTROLS, &pidlCpl);
    }
    else
    {
        CComPtr<IShellFolder> psfDevice;
        BindToDevice (szDeviceId, IID_IShellFolder,
                      reinterpret_cast<LPVOID*>(&psfDevice),
                      &pidlFolder);
    }
    if (pidlFolder)
    {
        if (pidl)
        {
            pidlUpdate = ILCombine (pidlFolder, pidl);
        }
        else
        {
            pidlUpdate = ILClone(pidlFolder);
        }
        if (pidlUpdate)
        {
            SHChangeNotify (lEvent,
                            SHCNF_IDLIST,
                            pidlUpdate, 0);
            ILFree (pidlUpdate);
        }
        if (pidlCpl)
        {
            SHChangeNotify (lEvent,
                            SHCNF_IDLIST,
                            pidlCpl, 0);
            ILFree (pidlCpl);
        }
        ILFree (pidlFolder);
    }
    TraceLeave ();
}

bool IsDeviceInFolder (const CSimpleStringWide &strDeviceId, IShellFolder *psf, LPITEMIDLIST *ppidl)
{
    bool bRet = false;
    CComPtr<IEnumIDList> pEnum;

    TraceEnter (TRACE_UTIL, "IsDeviceInFolder");
    if (SUCCEEDED(psf->EnumObjects (NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &pEnum)))
    {
        LPITEMIDLIST pidlItem;
        ULONG ul;
        while (!bRet && S_OK == pEnum->Next(1,&pidlItem, &ul))
        {
            if (IsDeviceIDL(pidlItem) || IsSTIDeviceIDL(pidlItem))
            {
                CSimpleStringWide strId;
                IMGetDeviceIdFromIDL (pidlItem, strId);
                if (!_wcsicmp(strId,strDeviceId))
                {
                    bRet = true;
                    if (ppidl)
                    {
                        *ppidl = ILClone(pidlItem);
                    }
                }
            }
            DoILFree (pidlItem);
        }
    }

    TraceLeaveValue (bRet);
}
/******************************************************************************

    GetDeviceParentFolder

    Find the folder that is the parent of the given device. First we try
    My Computer directly, then we try My Computer/Scanners and Cameras. Also fills in the full pidl
    for the device

******************************************************************************/

HRESULT GetDeviceParentFolder (const CSimpleStringWide &strDeviceId,
                               CComPtr<IShellFolder> &psf,
                               LPITEMIDLIST *ppidlFull)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "GetDeviceParentFolder");
    CComPtr<IShellFolder> psfDrives;
    CComPtr<IShellFolder> psfDesktop;
    CComPtr<IEnumIDList> pEnum;
    LPITEMIDLIST pidl1 = NULL;
    LPITEMIDLIST pidlItem = NULL;

    Trace (TEXT("Looking in my computer for %ls"), strDeviceId.String());

    if (ppidlFull)
    {
        *ppidlFull = NULL;
    }

    hr = SHGetDesktopFolder (&psfDesktop);
    if (FAILED(hr))
    {
        TraceLeaveResult(hr);
    }

    // First, try to find the device in My Computer.
    if (SUCCEEDED(SHGetSpecialFolderLocation (NULL, CSIDL_DRIVES,  &pidl1)))
    {

        hr = psfDesktop->BindToObject (pidl1,
                                       NULL,
                                       IID_IShellFolder,
                                       reinterpret_cast<LPVOID*>(&psfDrives));
        if (SUCCEEDED(hr) && IsDeviceInFolder (strDeviceId, psfDrives, &pidlItem))
        {
            if (ppidlFull)
            {
                *ppidlFull = ILCombine (pidl1, pidlItem);
            }
            psf = psfDrives;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

    }
    if (FAILED(hr))
    {
        Trace(TEXT("Looking in control panel\\scanners and cameras"));
        LPITEMIDLIST pidlFolder;
        // If no luck in my computer, try the scanners and cameras folder in control panel
        // Note that on winnt we have to use ::{} around our guid, and on millennium we use ;;{}
        // this is so ParseDisplayName does the right thing
        #ifdef NODELEGATE
        static  WCHAR szFolderPath[MAX_PATH] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
        #else
        static  WCHAR szFolderPath[MAX_PATH] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\;;{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
        #endif
        if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL,
                                                   szFolderPath,
                                                   NULL,
                                                   &pidlFolder,
                                                   NULL)))
        {
            if (SUCCEEDED(psfDesktop->BindToObject (pidlFolder,
                                                    NULL,
                                                    IID_IShellFolder,
                                                    reinterpret_cast<LPVOID*>(&psfDrives))))
            {
                if (IsDeviceInFolder (strDeviceId, psfDrives, &pidlItem))
                {
                    psf = psfDrives;
                    if (ppidlFull)
                    {
                        *ppidlFull = ILCombine (pidlFolder, pidlItem);
                    }
                    hr = S_OK;
                }

            }
            else
            {
                Trace(TEXT("BindToObject returned %x"), hr);
            }
        }
        else
        {
            Trace(TEXT("ParseDisplayName returned %x"), hr);
        }
        DoILFree (pidlFolder);
    }

    DoILFree (pidl1);
    DoILFree (pidlItem);

    TraceLeaveResult (hr);
}

/******************************************************************************

    BindToDevice

    Returns an interface for the given WIA device, as well as its full PIDL

******************************************************************************/
HRESULT BindToDevice (const CSimpleStringWide &strDeviceId,
                      REFIID riid,
                      LPVOID *ppvObj,
                      LPITEMIDLIST *ppidlFull)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "BindToDevice");

    CComPtr<IShellFolder> psfParent;
    LPITEMIDLIST pidlDevice;

    hr = GetDeviceParentFolder(strDeviceId, psfParent, &pidlDevice);
    if (SUCCEEDED(hr))
    {
        if (ppvObj)
        {
            hr = psfParent->BindToObject (ILFindLastID(pidlDevice),
                                          NULL,
                                          riid,
                                          ppvObj);
        }
        if (ppidlFull)
        {
            *ppidlFull = ILClone(pidlDevice);
        }
    }
    DoILFree (pidlDevice);
    TraceLeaveResult (hr);
}




/******************************************************************************

    GetDataObjectForStiDevice

    Since we don't show STI devices in a delegated folder, we can init
    the CImageDataObject directly.

*******************************************************************************/

HRESULT
GetDataObjectForStiDevice (LPCWSTR szDeviceId, IDataObject **ppdo)
{
    HRESULT hr = E_OUTOFMEMORY;

    LPITEMIDLIST pidl;

    STIDeviceIDLFromId (szDeviceId, &pidl, NULL);
    CImageDataObject *pido = new CImageDataObject (NULL);
    TraceEnter (TRACE_UTIL, "GetDataObjectForStiDevice");
    *ppdo = NULL;
    if (pido)
    {
        hr = pido->Init(NULL, 1,
                   const_cast<LPCITEMIDLIST*>(&pidl),
                   NULL);
        if (SUCCEEDED(hr))
        {
            hr = pido->QueryInterface (IID_IDataObject,
                                       reinterpret_cast<LPVOID*>(ppdo));
        }
        pido->Release();
    }

    TraceLeaveResult(hr);
}


HRESULT GetDataObjectForItem (IWiaItem *pItem, IDataObject **ppdo)
{
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "GetDataObjectForItem");
    CComPtr<IWiaItem> pDevice;
    CSimpleStringWide strDeviceId;
    *ppdo =NULL;
    LPITEMIDLIST pidlItem;
    LONG lType = 0;

    pItem->GetRootItem (&pDevice);
    PropStorageHelpers::GetProperty(pDevice, WIA_DIP_DEV_ID, strDeviceId);
    pItem->GetItemType (&lType);
    if (lType & WiaItemTypeRoot)
    {
        // it's a device
        pidlItem = IMCreateDeviceIDL (pItem, NULL);
    }
    else // it's a camera item
    {
        pidlItem = IMCreateCameraItemIDL (pItem, strDeviceId, NULL);
    }
    if (!pidlItem)
    {
        hr = E_FAIL;
    }
    else
    {
        CImageDataObject *pobj = new CImageDataObject (pItem);
        if (!pobj)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pobj->Init (NULL,
                             1,
                             const_cast<LPCITEMIDLIST*>(&pidlItem),
                             NULL);
            if (SUCCEEDED(hr))
            {
                *ppdo = pobj;
                // add the proper clipboard format for extensions to use.
                ProgramDataObjectForExtension (pobj, pItem);
            }
        }
        ILFree(pidlItem);
    }

    TraceLeaveResult (hr);
}

HRESULT
MakeFullPidlForDevice (LPCWSTR pDeviceId, LPITEMIDLIST *ppidl)
{
    CComPtr<IShellFolder> psf;
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "MakeFullPidlForDevice");
    hr = GetDeviceParentFolder (pDeviceId, psf, ppidl);
    TraceLeaveResult (hr);
}
/******************************************************************************

    TryEnumDeviceInfo

    Attempt to enumerate installed devices.
******************************************************************************/

HRESULT
TryEnumDeviceInfo (DWORD dwFlags, IEnumWIA_DEV_INFO **ppEnum)
{
    HRESULT hr = E_FAIL;
    CComPtr<IWiaDevMgr> pDevMgr;
    TraceEnter (TRACE_UTIL, "TryEnumDeviceInfo");

    {
        hr = GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr));
        if (SUCCEEDED(hr))
        {
            hr = pDevMgr->EnumDeviceInfo (dwFlags, ppEnum);
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

   GetSTIInfoFromId

   Copy the STI_DEVICE_INFORMATION struct from STI

 *****************************************************************************/

HRESULT
GetSTIInfoFromId (LPCWSTR szDeviceId, PSTI_DEVICE_INFORMATION *ppsdi)
{
    HRESULT hr = E_INVALIDARG;
    PSTI psti = NULL;

    TraceEnter (TRACE_IDLIST, "GetSTIInfoFromId");
    if (ppsdi)
    {

        hr = StiCreateInstance (GLOBAL_HINSTANCE,
                                STI_VERSION,
                                &psti,
                                NULL);
        if (SUCCEEDED(hr))
        {
            hr = psti->GetDeviceInfo (const_cast<LPWSTR>(szDeviceId), reinterpret_cast<LPVOID*>(ppsdi));
        }
        else
        {
            Trace(TEXT("StiCreateInstance failed %x in GetSTIInfoFromId"), hr);
        }
    }

    DoRelease (psti);
    TraceLeaveResult (hr);
}


#if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))

////////////////////////////////////////////////////////
//
// PrintAttributes
//
//
//
////////////////////////////////////////////////////////
void PrintAttributes( DWORD dwAttr )
{

    TCHAR sz[ MAX_PATH ];
    TraceEnter (TRACE_UTIL, "PrintAttributes");
    lstrcpyn( sz, TEXT("Attribs = "), ARRAYSIZE(sz) );
    int cch = ARRAYSIZE(sz);
    if (dwAttr & SFGAO_CANCOPY)
    {
        StrCatBuff( sz, TEXT("SFGAO_CANCOPY "), cch );
    }
    if (dwAttr & SFGAO_CANMOVE)
    {
        StrCatBuff( sz,TEXT("SFGAO_CANMOVE "), cch);
    }
    if (dwAttr & SFGAO_CANLINK)
    {
        StrCatBuff( sz, TEXT("SFGAO_CANLINK "), cch);
    }
    if (dwAttr & SFGAO_CANRENAME)
    {
        StrCatBuff( sz, TEXT("SFGAO_CANRENAME "), cch);
    }
    if (dwAttr & SFGAO_CANDELETE)
    {
        StrCatBuff( sz, TEXT("SFGAO_CANDELETE "), cch);
    }
    if (dwAttr & SFGAO_HASPROPSHEET)
    {
        StrCatBuff( sz, TEXT("SFGAO_HASPROPSHEET "), cch);
    }
    if (dwAttr & SFGAO_DROPTARGET)
    {
        StrCatBuff( sz, TEXT("SFGAO_DROPTARGET "), cch);
    }
    if (dwAttr & SFGAO_LINK)
    {
        StrCatBuff( sz, TEXT("SFGAO_LINK "), cch);
    }
    if (dwAttr & SFGAO_SHARE)
    {
        StrCatBuff( sz, TEXT("SFGAO_SHARE "), cch);
    }
    if (dwAttr & SFGAO_READONLY)
    {
        StrCatBuff( sz, TEXT("SFGAO_READONLY "), cch);
    }
    if (dwAttr & SFGAO_GHOSTED)
    {
        StrCatBuff( sz, TEXT("SFGAO_GHOSTED "), cch);
    }
    if (dwAttr & SFGAO_HIDDEN)
    {
        StrCatBuff( sz, TEXT("SFGAO_HIDDEN "), cch);
    }
    if (dwAttr & SFGAO_FOLDER)
    {
        StrCatBuff (sz, TEXT("SFGAO_FOLDER"), cch);
    }
    if (dwAttr & SFGAO_FILESYSANCESTOR)
    {
        StrCatBuff( sz, TEXT("SFGAO_FILESYSANCESTOR "), cch);
    }
    if (dwAttr & SFGAO_FILESYSTEM)
    {
        StrCatBuff( sz, TEXT("SFGAO_FILESYSTEM "), cch);
    }
    if (dwAttr & SFGAO_HASSUBFOLDER)
    {
        StrCatBuff( sz, TEXT("SFGAO_HASSUBFOLDER "), cch);
    }
    if (dwAttr & SFGAO_VALIDATE)
    {
        StrCatBuff( sz, TEXT("SFGAO_VALIDATE "), cch);
    }
    if (dwAttr & SFGAO_REMOVABLE)
    {
        StrCatBuff( sz, TEXT("SFGAO_REMOVABLE "), cch);
    }
    if (dwAttr & SFGAO_COMPRESSED)
    {
        StrCatBuff( sz, TEXT("SFGAO_COMPRESSED "), cch);
    }
    if (dwAttr & SFGAO_BROWSABLE)
    {
        StrCatBuff( sz, TEXT("SFGAO_BROWSABLE "), cch);
    }
    if (dwAttr & SFGAO_NONENUMERATED)
    {
        StrCatBuff( sz, TEXT("SFGAO_NONENUMERATED "), cch);
    }
    if (dwAttr & SFGAO_NEWCONTENT)
    {
        StrCatBuff( sz, TEXT("SFGAO_NEWCONTENT "), cch);
    }
    if (dwAttr & SFGAO_CANMONIKER)
    {
        StrCatBuff( sz, TEXT("SFGAO_CANMONIKER "), cch);
    }
    Trace( sz );
    TraceLeave ();
}
#endif


BOOL
UserCanModifyDevice ()
{
    // checks the current user's token for SE_LOAD_DRIVER_PRIVILEGE
    BOOL bRet = FALSE;
    HANDLE Token;
    // use a static PRIVILEGE_SET because we only look for one LUID
    PRIVILEGE_SET pset;
    pset.Control = PRIVILEGE_SET_ALL_NECESSARY;
    pset.PrivilegeCount = 1;
    if (OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,&Token))
    {
        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &pset.Privilege[0].Luid);
        tp.Privileges[0].Luid = pset.Privilege[0].Luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        AdjustTokenPrivileges(Token, false, &tp, 0, NULL, NULL);
        PrivilegeCheck(Token, &pset, &bRet);

        CloseHandle(Token);
    }

    return bRet;
}

BOOL
CanShowAddDevice()
{
#if 0
    OSVERSIONINFOEX osvi = {0};
    ULONGLONG dwlConditionMask =0;
    //
    //  On Whistler Personal, hide the icon if the
    // current user lacks installation privileges. On other SKUs the user is more likely
    // to know about shift-rclick for "Run As..."
    //
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.wSuiteMask = VER_SUITE_PERSONAL;
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );
    return UserCanModifyDevice() || !VerifyVersionInfo( &osvi,VER_SUITENAME,dwlConditionMask);
#else
    return TRUE;
#endif
}

void VerifyCachedDevice(IWiaItem *pRoot)
{
    WCHAR szDeviceId[STI_MAX_INTERNAL_NAME_LENGTH];
    TLSDATA *pCur = g_tlsSlot.GetObject(false);

    GetDeviceIdFromDevice(pRoot, szDeviceId);
    while (pCur && wcscmp(szDeviceId, pCur->strDeviceId))
    {
        pCur = pCur->pNext;
    }
    if (!pCur)
    {
        CreateCacheEntry(CSimpleStringWide(szDeviceId), pRoot);
    }
    else
    {
        //
        // replace the current root item with the new one, as the old one may be disconnected
        // and we don't have an event handler to catch it.
        //
        DoRelease(pCur->pDevice);
        pCur->pDevice = pRoot;
        pCur->pDevice->AddRef();
    }
}

void MyCoUninitialize()
{
    // Make sure we release open IWiaItem interfaces before COM unloads
    InvalidateDeviceCache();
    CoUninitialize();
}

DWORD WINAPI _RunWizardThread(void *pszDeviceId)
{
    InterlockedIncrement (&GLOBAL_REFCOUNT);
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        RunWiaWizard::RunWizard(reinterpret_cast<LPCWSTR>(pszDeviceId));
        CoUninitialize();
    }   
    delete [] reinterpret_cast<WCHAR *>(pszDeviceId);
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    return 0;
}

void RunWizardAsync(LPCWSTR pszDeviceId)
{
    // make a heap copy of the string for consumption by the thread
    int cch = lstrlen(pszDeviceId)+1;
    WCHAR *pString = new WCHAR[cch];
    if (pString)
    {
        lstrcpyn(pString, pszDeviceId, cch);
        DWORD dw;
        HANDLE hThread = CreateThread(NULL, 0, 
                                      _RunWizardThread,
                                      reinterpret_cast<void*>(pString),
                                      0, &dw);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            delete [] pString;
        }
    }
}

#ifdef UNICODE
static const WCHAR cszClassInst[] = L"sti_ci.dll";
#else
static const CHAR cszClassInst[] = "sti_ci32.dll";
#endif

HINSTANCE LoadClassInstaller()
{
    return LoadLibrary(cszClassInst);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\verbs.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2002
 *
 *  TITLE:       <FILENAME>
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        5/27/98
 *
 *  DESCRIPTION: This file contains the code which implements the verbs
 *               on the objects in our shell namespace extension
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "prwiziid.h"
#include "wininet.h"
#include <wiadevd.h>
#pragma hdrstop



static const TCHAR cszCameraItems [] = TEXT("CameraItems");
static const TCHAR cszTempFileDir [] = TEXT("TemporaryImageFiles");
/*****************************************************************************

   GetSetSettingsBool

   Goes to the registry to get the specified boolean setting and
   returns TRUE or FALSE depending on what is found there...

 *****************************************************************************/

BOOL
GetSetSettingsBool( LPCTSTR pValue, BOOL bSet, BOOL bValue )
{
    HKEY hKey = NULL;
    BOOL bRes = bValue;
    DWORD dwType, dwData, cbData;
    LONG lRes;

    //
    // param validation
    //

    if (!pValue)
        goto exit_gracefully;

    //
    // Try to open the settings key for this user...
    //

    lRes = RegCreateKeyEx( HKEY_CURRENT_USER,
                           REGSTR_PATH_SHELL_USER_SETTINGS,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           NULL );

    if ((lRes != ERROR_SUCCESS) || (hKey == NULL))
        goto exit_gracefully;

    if (!hKey)
        goto exit_gracefully;

    if (bSet)
    {
        lRes = RegSetValueEx( hKey,
                              pValue,
                              0,
                              REG_DWORD,
                              (LPBYTE)&bValue,
                              sizeof(BOOL)
                             );

        bRes = (lRes == ERROR_SUCCESS);
    }
    else
    {
        //
        // Try to get the DWORD value for this item...
        //

        cbData = sizeof(dwData);
        dwData = 0;
        lRes = RegQueryValueEx( hKey,
                                pValue,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwData,
                                &cbData
                               );

        if ((dwType == REG_DWORD) && dwData)
        {
            bRes = TRUE;
        }
    }

exit_gracefully:

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    return bRes;

}



/*****************************************************************************

   GetIDAFromDataObject

   Utility function to get list of IDLISTs from a dataobject

 *****************************************************************************/

HRESULT
GetIDAFromDataObject( LPDATAOBJECT pDataObject, LPIDA * ppida, bool bShellFmt )
{

    HRESULT         hr = E_FAIL;
    FORMATETC       fmt;
    STGMEDIUM       stgmed;
    SIZE_T          uSize;
    LPVOID          lpv;
    LPIDA           lpida = NULL;

    TraceEnter( TRACE_VERBS, "GetIDAFromDataObject" );
    ZeroMemory (&fmt, sizeof(fmt));
    ZeroMemory (&stgmed, sizeof(stgmed));
    //
    // Check incoming params...
    //

    if (!ppida)
    {
        ExitGracefully( hr, E_INVALIDARG, "ppida is null" );
    }
    *ppida = NULL;

    if (!pDataObject)
    {
        ExitGracefully( hr, E_INVALIDARG, "pDataObject is null" );
    }

    //
    // Make sure the format we want is registered...
    //

    RegisterImageClipboardFormats();

    //
    // Ask for IDA...
    //

    fmt.cfFormat = bShellFmt ? g_cfShellIDList : g_cfMyIDList;
    fmt.ptd      = NULL;
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex   = -1;
    fmt.tymed    = TYMED_HGLOBAL;

    stgmed.tymed          = TYMED_HGLOBAL;
    stgmed.hGlobal        = NULL;
    stgmed.pUnkForRelease = NULL;

    hr = pDataObject->GetData( &fmt, &stgmed );
    FailGracefully( hr, "GetData for idlists failed" );

    //
    // Make a copy of it...
    //

    uSize = GlobalSize( (HGLOBAL)stgmed.hGlobal );
    if (!uSize)
    {
        ExitGracefully( hr, E_FAIL, "Couldn't get size of memory block" );
    }

    lpida = (LPIDA)LocalAlloc( LPTR, uSize );
    if (lpida)
    {

        lpv = (LPVOID)GlobalLock( (HGLOBAL)stgmed.hGlobal );
        CopyMemory( (PVOID)lpida, lpv, uSize );
        GlobalUnlock( stgmed.hGlobal );

        hr = S_OK;
        *ppida = lpida;

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit_gracefully:

    if (stgmed.hGlobal)
    {
        ReleaseStgMedium( &stgmed );
    }

    TraceLeaveResult(hr);

}




/*****************************************************************************

   PreviewImage

   Download the pic and run the default viewer.

 *****************************************************************************/

HRESULT PreviewImage(LPCTSTR pFileName, HWND hwndOwner )
{
    TraceEnter( TRACE_VERBS, "PreviewImage" );

    SHELLEXECUTEINFO sei;
    HRESULT hr = S_OK;

    //
    // Download the picture from the camera...
    //

    DWORD dwAttrib = GetFileAttributes( pFileName );

    if (dwAttrib != -1)
    {
        // being a preview, file is read-only
        if (!SetFileAttributes(pFileName, (dwAttrib | FILE_ATTRIBUTE_READONLY)))
        {
            Trace(TEXT("couldn't add READONLY (0x%x) attribute on %s, GLE=%d"),dwAttrib | FILE_ATTRIBUTE_READONLY,pFileName,GetLastError());
        }
    }
    else
    {
        Trace(TEXT("couldn't get file attributes for %s, GLE=%d"),pFileName,GetLastError());
    }

    //
    // Exec the app to view the picture
    //
    ZeroMemory( &sei,  sizeof(sei) );
    sei.cbSize = sizeof(sei);
    sei.lpFile = pFileName;
    sei.nShow = SW_NORMAL;
    sei.fMask = SEE_MASK_WAITFORINPUTIDLE | SEE_MASK_INVOKEIDLIST;

    if (!ShellExecuteEx (&sei))
    {
        DWORD dw= GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
    }

    TraceLeaveResult(hr);
}


#define FILETIME_UNITS_PER_DAY 0xC92A69C000
void DeleteOldFiles(const CSimpleString &strTempDir, bool bTempName)
{
    WIN32_FIND_DATA wfd;
    HANDLE hFind;
    LPCTSTR szFormat;
    SYSTEMTIME stCurrentTime;
    ULONGLONG  ftCurrentTime;
    CSimpleString strMask;

    TraceEnter(TRACE_VERBS, "DeleteOldFiles");
    GetSystemTime (&stCurrentTime);
    SystemTimeToFileTime (&stCurrentTime, reinterpret_cast<FILETIME*>(&ftCurrentTime));

    ZeroMemory (&wfd, sizeof(wfd));
    if (bTempName)
    {
        strMask.Format (TEXT("%s\\%s*.*"), strTempDir.String(), g_cszTempFilePrefix);
    }
    else
    {
        strMask.Format (TEXT("%s\\*.*"), strTempDir.String());
    }

    Trace(TEXT("strMask for deletion is %s"), strMask.String());
    hFind  = FindFirstFile (strMask, &wfd);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        ULONGLONG uiDiff;
        do
        {
            uiDiff = ftCurrentTime - *(reinterpret_cast<ULONGLONG*>(&wfd.ftLastWriteTime));
            if (uiDiff > FILETIME_UNITS_PER_DAY)
            {
                SetFileAttributes(wfd.cFileName, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (wfd.cFileName);
            }
        } while (FindNextFile (hFind, &wfd));
        FindClose (hFind);
    }
    TraceLeave();
}

HRESULT OldDoPreviewVerb(HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    LPIDA           lpida = NULL;
    LPITEMIDLIST    pidl;
    UINT            cidl;
    INT             i;

    HRESULT hr = E_FAIL;
    TraceEnter( TRACE_VERBS, "OldDoPreviewVerb" );
    //
    // Get the lpida for the dataobject
    //

    hr = GetIDAFromDataObject( pDataObject, &lpida );
    FailGracefully( hr, "couldn't get lpida from dataobject" );

    //
    // Loop through and do open for the items we understand.
    //
    // Currently this is: camera items (not containers)
    //

    cidl = lpida->cidl;

    for (i = 1; (i-1) < (INT)cidl; i++)
    {
        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[i]);

        if (IsCameraItemIDL( pidl ))
        {
            if (IsContainerIDL( pidl ))
            {
                //
                // We don't do anything for those right now...
                //
            }
            else
            {
                CSimpleStringWide strImgName;
                ULONG ulSize;
                GUID lFormat;
                TCHAR szFileName[MAX_PATH];
                FILETIME ftCreate;
                FILETIME ftExp = {0};
                CSimpleString strExt;
                hr = IMGetImagePreferredFormatFromIDL( pidl, &lFormat, &strExt );

                //
                // Generate temp file name...
                //
                IMGetNameFromIDL(pidl, strImgName);
                IMGetImageSizeFromIDL(pidl, &ulSize);
                IMGetCreateTimeFromIDL(pidl, &ftCreate);
                CSimpleStringWide strCacheName = CSimpleStringWide(L"temp:")+strImgName+CSimpleStringConvert::WideString(strExt);
                if (SUCCEEDED(hr) && CreateUrlCacheEntry(strCacheName, ulSize, strExt.String()+1,szFileName, 0))
                {
                    //
                    // Show it
                    //
                    CSimpleString strPath = CSimpleString(szFileName);
                    Trace(TEXT("downloading bits to %s"),strPath.String());
                    hr = DownloadPicture( strPath, pidl, hwndOwner );
                    if (SUCCEEDED(hr))
                    {
                        if (CommitUrlCacheEntry(strCacheName, strPath.String(), ftExp, ftCreate, STICKY_CACHE_ENTRY, NULL, 0, NULL, NULL))
                        {
                            hr = PreviewImage(strPath, hwndOwner);
                        }
                        else
                        {
                            DWORD dw = GetLastError();
                            hr = HRESULT_FROM_WIN32(dw);
                        }
                    }
                }
                else if (SUCCEEDED(hr))
                {
                    DWORD dw = GetLastError();
                    hr = HRESULT_FROM_WIN32(dw);
                }
            }
        }
    }


exit_gracefully:

    if (lpida)
    {
        LocalFree(lpida);
        lpida = NULL;
    }
    TraceLeaveResult(hr);
}
/*****************************************************************************

   DoPreviewVerb

   User selected "Preview" on the item in question.

 *****************************************************************************/
/* e84fda7c-1d6a-45f6-b725-cb260c236066 */
DEFINE_GUID(CLSID_PhotoVerbs,
            0xe84fda7c, 0x1d6a, 0x45f6, 0xb7, 0x25, 0xcb, 0x26, 0x0c, 0x23, 0x60, 0x66);


HRESULT DoPreviewVerb( HWND hwndOwner, LPDATAOBJECT pDataObject )
{

    HRESULT         hr = E_FAIL;
    CComPtr<IShellExtInit> pExtInit;

    TraceEnter( TRACE_VERBS, "DoPreviewVerb" );
    hr = CoCreateInstance(CLSID_PhotoVerbs,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IShellExtInit,
                          reinterpret_cast<VOID**>(&pExtInit));
    if (SUCCEEDED(hr))
    {
        hr = pExtInit->Initialize(NULL, pDataObject, NULL);
        if (SUCCEEDED(hr))
        {
            CComQIPtr<IContextMenu, &IID_IContextMenu> pcm(pExtInit);
            hr = SHInvokeCommandOnContextMenu(hwndOwner, NULL, pcm, 0, "preview");            
        }
    }
    else
    {
        // if the preview app isn't around, invoke the default handler
        // using a temp file
        hr = OldDoPreviewVerb(hwndOwner, pDataObject);
    }

    TraceLeaveResult(hr);

}



/*****************************************************************************

   DoSaveInMyPics

   User selected "Save to my pictures" on the items in question

 *****************************************************************************/

HRESULT DoSaveInMyPics( HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT         hr    = S_OK;
    LPITEMIDLIST    pidlMyPics = NULL;

    CComPtr<IShellFolder> pDesktop;
    CComPtr<IShellFolder> pMyPics;
    CComPtr<IDropTarget>  pDrop;
    CWaitCursor *pwc;
    TraceEnter( TRACE_VERBS, "DoSaveInMyPics" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
        ExitGracefully( hr, E_INVALIDARG, "pDataObject was NULL!" );


    //
    // Get the path for the My Pictures directory...
    //

    hr = SHGetFolderLocation(hwndOwner, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, NULL, 0, &pidlMyPics );
    FailGracefully( hr, "My Pictures is undefined!!!" );

    //
    // Get an IDropTarget for My Pictures
    hr = SHGetDesktopFolder (&pDesktop);
    if (SUCCEEDED(hr) && pDesktop)
    {
        hr = pDesktop->BindToObject (pidlMyPics,
                                     NULL,
                                     IID_IShellFolder,
                                     reinterpret_cast<LPVOID*>(&pMyPics));
        FailGracefully (hr, "Unable to get IShellFolder for My Pictures");
        hr = pMyPics->CreateViewObject (hwndOwner,
                                        IID_IDropTarget,
                                        reinterpret_cast<LPVOID*>(&pDrop));
        FailGracefully (hr, "Unable to get IDropTarget for My Pictures");
        //
        // Call SHLWAPI's SHSimulateDragDrop to do the work. This is a private API
        //
        pwc = new CWaitCursor ();
        hr = SHSimulateDrop (pDrop, pDataObject, MK_CONTROL|MK_LBUTTON, NULL, NULL);
        DoDelete (pwc);
    }



exit_gracefully:

    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_CANCELLED)
    {
        UIErrors::ReportMessage(hwndOwner,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DOWNLOAD_CAPTION),
                                MAKEINTRESOURCE (IDS_DOWNLOAD_FAILED),
                                MB_OK);

    }
    else if (SUCCEEDED(hr))
    {

        TCHAR szPath[MAX_PATH];
        SHGetFolderPath (hwndOwner, CSIDL_MYPICTURES, NULL, 0, szPath);
        ShellExecute (hwndOwner,
                      NULL,
                      szPath,
                      NULL,
                      szPath,
                      SW_SHOW);

    }
    DoILFree (pidlMyPics);
    TraceLeaveResult(hr);

}



/*****************************************************************************

   CImageFolder::DoProperties

   User selected "Properties" on the item in question.

 *****************************************************************************/
STDMETHODIMP
CImageFolder::DoProperties(LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    IGlobalInterfaceTable *pgit = NULL;
    TraceEnter (TRACE_VERBS, "CImageFolder::DoProperties");

    hr = CoCreateInstance (CLSID_StdGlobalInterfaceTable,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IGlobalInterfaceTable,
                           reinterpret_cast<LPVOID *>(&pgit));

    if (pgit)
    {
        PROPDATA *pData = new PROPDATA;
        if (!pData)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pgit->RegisterInterfaceInGlobal (pDataObject, IID_IDataObject, &pData->dwDataCookie);
        }
        if (SUCCEEDED(hr))
        {
            DWORD dw;
            pData->pThis = this;
            pData->pgit = pgit;
            pgit->AddRef();
            AddRef ();

            HANDLE hThread= CreateThread (NULL,
                                          0,
                                          reinterpret_cast<LPTHREAD_START_ROUTINE>(PropThreadProc),
                                          reinterpret_cast<LPVOID>(pData),
                                          0,
                                          &dw);
            if (hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                delete pData;
                dw = GetLastError ();
                hr = HRESULT_FROM_WIN32(dw);
                Release ();
                pgit->RevokeInterfaceFromGlobal (pData->dwDataCookie);
            }
        }
        else
        {
            DoDelete (pData);
        }
        pgit->Release();
    }

    TraceLeaveResult (hr);
}

VOID
CImageFolder::PropThreadProc (PROPDATA *pData)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_VERBS, "CImageFolder::PropThreadProc");
    InterlockedIncrement (&GLOBAL_REFCOUNT); // prevent MyCoUninitialize from unloading the DLL

    if (pData && pData->pgit && pData->pThis)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            CComPtr<IDataObject> pdo;

            hr = pData->pgit->GetInterfaceFromGlobal (pData->dwDataCookie,
                                                     IID_IDataObject,
                                                     reinterpret_cast<LPVOID*>(&pdo));
            if (SUCCEEDED(hr))
            {

                hr = pData->pThis->_DoProperties(pdo);

            }
            pData->pgit->RevokeInterfaceFromGlobal (pData->dwDataCookie);

            if (FAILED(hr) && hr != E_ABORT)
            {
                UIErrors::ReportError(NULL, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
            pData->pgit->Release();
            pData->pThis->Release ();
            delete pData;
        }
        if (SUCCEEDED(hr))
        {
            MyCoUninitialize ();
        }
    }

    InterlockedDecrement (&GLOBAL_REFCOUNT);
    TraceLeave ();
}


HRESULT
CImageFolder::_DoProperties( LPDATAOBJECT pDataObject )
{

    HRESULT         hr    = S_OK;
    LPIDA           lpida = NULL;
    LPITEMIDLIST    pidl;
    CSimpleStringWide strDeviceId;
    CSimpleStringWide strTitle;
    CSimpleStringWide strName;
    CComPtr<IWiaPropertyStorage> pDevice;
    HKEY            aKeys[2];
    int cKeys=1;
    TraceEnter( TRACE_VERBS, "CImageFolder::_DoProperties" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Get the lpida for the dataobject
        //

        hr = GetIDAFromDataObject (pDataObject, &lpida, true);
        if (SUCCEEDED(hr))
        {

            pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(lpida) + lpida->aoffset[1]);
            IMGetDeviceIdFromIDL (pidl, strDeviceId);
            IMGetNameFromIDL (pidl, strName);
            if (lpida->cidl > 1)
            {
                strTitle.Format (IDS_MULTIPROP_SEL, GLOBAL_HINSTANCE, strName.String());
            }
            else
            {
                strTitle = strName;
            }

            if (!IsSTIDeviceIDL(pidl))
            {
                hr = GetDeviceFromDeviceId (strDeviceId,
                                            IID_IWiaPropertyStorage,
                                            reinterpret_cast<LPVOID*>(&pDevice),
                                            TRUE);
                if (SUCCEEDED(hr))
                {
                    if (1 == lpida->cidl)
                    {
                        ProgramDataObjectForExtension (pDataObject, pidl);
                    }
                    aKeys[1] = GetDeviceUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
                    if (aKeys[1])
                    {
                        cKeys++;
                    }

                    //
                    // Now find the extensions for this type of device
                    //
                    aKeys[0] = GetGeneralUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
                }
            }
            else

            {
                CSimpleString strKeyPath;
                strKeyPath.Format (c_szStiPropKey, cszImageCLSID);
                RegCreateKeyEx (HKEY_CLASSES_ROOT,
                                strKeyPath,
                                0,
                                NULL,
                                0,
                                KEY_READ,
                                NULL,
                                &aKeys[0],
                                NULL);
                aKeys[1] = NULL;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!aKeys[0])
        {
            hr = E_FAIL;
            Trace(TEXT("GetGeneralKey failed in DoProperties"));
        }
        else
        {
            Trace(TEXT("Calling SHOpenPropSheet!"));
            SHOpenPropSheet (CSimpleStringConvert::NaturalString(strTitle),
                             aKeys, cKeys, NULL, pDataObject, NULL, NULL);
        }
        for (cKeys=1;cKeys>=0;cKeys--)
        {
            if (aKeys[cKeys])
            {
                RegCloseKey (aKeys[cKeys]);
            }
        }
    }

    if (lpida)
    {
        LocalFree(lpida);
    }

    TraceLeaveResult(hr);
}


/*****************************************************************************

   ConfirmItemDelete

   Prompt the user to confirm they REALLY want to delete the items from the device

 *****************************************************************************/

BOOL
ConfirmItemDelete (HWND hwndOwner, LPIDA pida)
{
    TCHAR           szConfirmTitle[MAX_PATH];
    TCHAR           szConfirmText [MAX_PATH];
    TCHAR           szFormattedText [MAX_PATH];
    CSimpleStringWide strItemName;
    CSimpleString   strName;
    INT             idTitle;
    LPITEMIDLIST    pidl;
    BOOL            bRet;

    TraceEnter (TRACE_VERBS, "ConfirmItemDelete");

    pidl = (reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida)+pida->aoffset[1]));
    IMGetNameFromIDL (pidl, strItemName);
    strName = CSimpleStringConvert::NaturalString (strItemName);
    if (pida->cidl > 1)
    {
        idTitle = IDS_TITLECONFIRM_MULTI;

        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM_MULTI, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, pida->cidl);
    }
    else if (IsContainerIDL(pidl))
    {
        idTitle = IDS_TITLECONFIRM_FOLDER;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM_FOLDER, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    else if (IsDeviceIDL(pidl) || IsSTIDeviceIDL(pidl))
    {
        idTitle = IDS_TITLECONFIRM_DEVICE;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    else
    {
        idTitle = IDS_TITLECONFIRM;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    LoadString (GLOBAL_HINSTANCE, idTitle, szConfirmTitle, ARRAYSIZE(szConfirmTitle));


    bRet = (IDYES==MessageBox (hwndOwner,
                               szFormattedText,
                               szConfirmTitle,
                               MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND | MB_APPLMODAL
                               ));
    TraceLeave ();
    return bRet;
}



/*****************************************************************************

   DoDeletePicture

   User selected "Delete" on the items in question.

 *****************************************************************************/

HRESULT
DoDeleteItem( HWND hwndOwner, LPDATAOBJECT pDataObject, BOOL bNoUI )
{
    HRESULT             hr           = S_OK;
    LPIDA               lpida        = NULL;
    CComBSTR            bstrFullPath ;
    LPITEMIDLIST        pidl,pidlParent;
    UINT                cidl;
    CSimpleStringWide   strDeviceId;
    UINT                 i;
    BOOL                bDoIt = FALSE;
    CComPtr<IWiaItem>   pWiaItemRoot;
    CComPtr<IWiaItem>   pItem;
    LPITEMIDLIST pidlReal;
    TraceEnter( TRACE_VERBS, "DoDeleteItem" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
        ExitGracefully( hr, E_INVALIDARG, "pDataObject was NULL!" );

    //
    // Get the lpida for the dataobject
    //

    hr = GetIDAFromDataObject( pDataObject, &lpida, true );
    FailGracefully( hr, "couldn't get lpida from dataobject" );

    //
    // Loop through for each item...
    //

    cidl = lpida->cidl;
    pidlParent = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[0]);
    if (cidl)
    {
        if (bNoUI)
        {
            bDoIt = TRUE;
        }
        else
        {
            bDoIt = ConfirmItemDelete (hwndOwner, lpida);
        }
    }

    if (bDoIt)
    {

      for (i = 1; (i-1) < cidl; i++)
      {

        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[i]);

        //
        // Get the DeviceId...

        hr = IMGetDeviceIdFromIDL( pidl,strDeviceId);
        FailGracefully( hr, "IMGetDeviceIdFromIDL failed" );

        if (IsDeviceIDL (pidl) || IsSTIDeviceIDL (pidl))
        {
            hr = RemoveDevice (strDeviceId);
        }
        else if (IsPropertyIDL (pidl)) // ignore sound idls
        {
            continue;
        }
        else
        {
            //
            //  Create the device...
            //

            hr = GetDeviceFromDeviceId( strDeviceId,
                                        IID_IWiaItem,
                                        (LPVOID *)&pWiaItemRoot,
                                        TRUE
                                        );
            FailGracefully( hr, "GetDeviceFromDeviceId failed" );

            //
            // Get actual item in question...
            //

            hr = IMGetFullPathNameFromIDL( pidl, &bstrFullPath );
            FailGracefully( hr, "couldn't get full path name from pidl" );

            // BUGBUG: When access rights are implemented, check them

            hr = pWiaItemRoot->FindItemByName( 0, bstrFullPath, &pItem );
            FailGracefully( hr, "Couldn't find item by name" );

            if (pItem)
            {

                // physically remove the item
                hr = WiaUiUtil::DeleteItemAndChildren(pItem);
            }
            // inform the shell of our action
            // for device removal, our folder will get a disconnect event
            pidlReal = ILCombine( pidlParent, pidl );
            if (SUCCEEDED(hr) && pidlReal)
            {
                UINT uFlags = SHCNF_IDLIST;
                if (i+1 == cidl)
                {
                    uFlags |= SHCNF_FLUSH;//only flush at the end
                }
                SHChangeNotify( SHCNE_DELETE,
                                uFlags,
                                pidlReal,
                                NULL );

            }
            DoILFree( pidlReal );
        }
      }
    }
    
exit_gracefully:

    if (lpida)
    {
        LocalFree(lpida);
        lpida = NULL;
    }
    if (FAILED(hr))
    {
        // show an error message here
        hr = S_FALSE; // keep web view from popping up error boxes
    }
    TraceLeaveResult( hr );

}

/*****************************************************************************

   DoDeleteAllItems

   Called by camocx to delete all the items in a camera

 *****************************************************************************/

STDAPI_(HRESULT)
DoDeleteAllItems( BSTR bstrDeviceId, HWND hwndOwner )
{
    HRESULT hr = E_FAIL;

    CComPtr<IShellFolder> psfDevice;
    CComPtr<IEnumIDList> pEnum;
    LPITEMIDLIST *aidl = NULL;
    INT cidl = 0;

    HDPA dpaItems = DPA_Create (5);
    TraceEnter (TRACE_VERBS, "DoDeleteAllItems");

    hr = BindToDevice (bstrDeviceId,
                       IID_IShellFolder,
                       reinterpret_cast<LPVOID*>(&psfDevice));
    if (SUCCEEDED(hr))
    {
        Trace(TEXT("Found the device folder, getting the data object"));
        hr = psfDevice->EnumObjects (NULL,
                                     SHCONTF_FOLDERS | SHCONTF_NONFOLDERS,
                                     &pEnum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlItem;
            ULONG ul;
            CComPtr<IDataObject> pdo;
            while (S_OK == pEnum->Next (1, &pidlItem, &ul))
            {
                DPA_AppendPtr (dpaItems, pidlItem);
            }
            cidl = DPA_GetPtrCount(dpaItems);
            if (cidl)
            {
                aidl = new LPITEMIDLIST[cidl];
                if (aidl)
                {
                    for (INT i=0;aidl && i<cidl;i++)
                    {
                        aidl[i] = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(dpaItems, i));
                    }
                    hr = psfDevice->GetUIObjectOf (NULL,
                                                   static_cast<UINT>(cidl),
                                                   const_cast<LPCITEMIDLIST*>(aidl),
                                                   IID_IDataObject,
                                                   NULL,
                                                   reinterpret_cast<LPVOID*>(&pdo));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            if (cidl && SUCCEEDED(hr))
            {
                hr = DoDeleteItem (hwndOwner, pdo, FALSE);
                //
                // If deletion via individual items fails, try WIA_CMD_DELETE_ALL_ITEMS
                //
                if (S_OK != hr)
                {
                    CComPtr<IWiaItem> pDevice;
                    Trace(TEXT("DoDeleteItem failed %x, using WIA_CMD_DELETE_ALL_ITEMS"), hr);
                    hr = GetDeviceFromDeviceId(bstrDeviceId, 
                                               IID_IWiaItem, 
                                               reinterpret_cast<LPVOID*>(&pDevice), 
                                               TRUE);
                    if (SUCCEEDED(hr))
                    {
                        hr = WiaUiUtil::IsDeviceCommandSupported(pDevice, WIA_CMD_DELETE_ALL_ITEMS) ? S_OK : E_FAIL;
                        if (SUCCEEDED(hr))
                        {
                            CComPtr<IWiaItem> pUnused;
                            hr = pDevice->DeviceCommand(0,
                                                        &WIA_CMD_DELETE_ALL_ITEMS,
                                                        &pUnused);
                            Trace(TEXT("DeviceCommand returned %x"), hr);
                            if (SUCCEEDED(hr))
                            {
                                IssueChangeNotifyForDevice(bstrDeviceId, SHCNE_UPDATEDIR, NULL);
                            }       
                        }
                    }
                }
            }
            if (aidl)
            {
                delete [] aidl;
            }

        }
    }
    DPA_DestroyCallback (dpaItems, _EnumDestroyCB, NULL);
    TraceLeaveResult (hr);
}

/*****************************************************************************

   DoGotoMyPics

   <Notes>

 *****************************************************************************/


HRESULT DoGotoMyPics( HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT         hr           = S_OK;


    TraceEnter( TRACE_VERBS, "DoGotoMyPics" );

    TraceLeaveResult( hr );

}

/*****************************************************************************

   DoSaveSndVerb

   Download the image's sound property to a file and save to the requested
   location.

 *****************************************************************************/


HRESULT
DoSaveSndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    TraceEnter (TRACE_VERBS, "DoSaveSndVerb");
    if (SUCCEEDED(GetIDAFromDataObject (pDataObject, &pida)))
    {
        // There's the image pidl plus the audio property pidl
        TraceAssert (pida->cidl==2);
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        CComPtr<IWiaItem> pItem;
        TCHAR szFileName[MAX_PATH] = TEXT("\0");
        OPENFILENAME ofn;


        ZeroMemory (&ofn, sizeof(ofn));
        ofn.hInstance = GLOBAL_HINSTANCE;
        ofn.hwndOwner = hwndOwner;
        ofn.lpstrFile = szFileName;
        ofn.lpstrFilter = TEXT("WAV file\0*.wav\0");
        ofn.lpstrDefExt = TEXT("wav");
        ofn.lStructSize = sizeof(ofn);
        ofn.nMaxFile = ARRAYSIZE(szFileName);;
        ofn.Flags = OFN_OVERWRITEPROMPT;
        if (GetSaveFileName (&ofn))
        {
            Trace(TEXT("File name to save:%s"), szFileName);
            hr = IMGetItemFromIDL (pidl,&pItem, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = SaveSoundToFile (pItem, szFileName);
            }
            if (FAILED(hr) && hr != E_ABORT)
            {
                UIErrors::ReportError(hwndOwner, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
        }
        else
        {
            Trace(TEXT("GetSaveFileName failed, error %d"), CommDlgExtendedError());
        }
    }
    if (pida)
    {
        LocalFree(pida);

    }
    TraceLeaveResult (hr);
}

/******************************************************************************

    DoPlaySndVerb

    Save the item's audio property to a temp file, play the sound, then delete the file
    We do this in a separate thread to keep the UI responsive and to guarantee the
    temp file gets cleaned up.

*******************************************************************************/

struct PSDATA
{
    HWND hwndOwner;
    LPITEMIDLIST pidl;
};

INT_PTR
PlaySndDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    INT_PTR iRet = TRUE;
    TraceEnter (TRACE_VERBS, "PlaySndDlgProc");
    PSDATA *pData;
    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            PostMessage (hwnd, WM_USER+1, 0, 0);
            break;

        case WM_USER+1:
        {

            // get a temp file name
            HRESULT hr;
            CComPtr<IWiaItem> pItem;
            TCHAR szTempFile[MAX_PATH] = TEXT("");
            GetTempPath (MAX_PATH, szTempFile);
            GetTempFileName (szTempFile, TEXT("psv"), 0, szTempFile);
            pData = reinterpret_cast<PSDATA*>(GetWindowLongPtr(hwnd, DWLP_USER));
            TraceAssert (pData);
            // save to the temp file
            IMGetItemFromIDL (pData->pidl, &pItem);
            hr = SaveSoundToFile( pItem, szTempFile);
            if (SUCCEEDED(hr))
            {
                CSimpleString strStatus(IDS_PLAYINGSOUND, GLOBAL_HINSTANCE);
                strStatus.SetWindowText (GetDlgItem(hwnd, IDC_SNDSTATUS));
                if (!PlaySound (szTempFile, NULL, SND_FILENAME | SND_NOWAIT))
                {
                    DWORD dw = GetLastError ();
                    hr = HRESULT_FROM_WIN32(dw);
                }
            }
            else
            {
                Trace(TEXT("SaveSoundToFile failed"));
            }
            DeleteFile (szTempFile);
            if (FAILED(hr))
            {
                UIErrors::ReportError (hwnd, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
            EndDialog (hwnd, 0);
        }
            break;
        default:
            iRet = FALSE;
            break;
    }
    TraceLeaveValue (iRet);
}

DWORD
PlaySndThread (LPVOID pData)
{
    TraceEnter (TRACE_VERBS, "PlaySndThread");
    if (SUCCEEDED(CoInitialize (NULL)))
    {
        LPITEMIDLIST pidl = reinterpret_cast<PSDATA*>(pData)->pidl;
        HWND hwnd = reinterpret_cast<PSDATA*>(pData)->hwndOwner;
        DialogBoxParam (GLOBAL_HINSTANCE,
                   MAKEINTRESOURCE(IDD_XFERSOUND),
                   hwnd,
                   PlaySndDlgProc,
                   reinterpret_cast<LPARAM>(pData));
        ILFree (pidl);
        delete reinterpret_cast<PSDATA*>(pData);
        TraceLeave();
        MyCoUninitialize ();
    }
    return 0;
}

HRESULT
DoPlaySndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    TraceEnter (TRACE_VERBS, "DoPlaySndVerb");
    if (SUCCEEDED(GetIDAFromDataObject(pDataObject, &pida)))
    {
        // The image PIDL is always stored before the audio property pidl

        Trace(TEXT("GetIDAFromDataObject succeeded"));
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        PSDATA *pData = new PSDATA;
        if (pData)
        {
            HANDLE hThread;
            DWORD dw;
            pData->pidl = ILClone(pidl);
            pData->hwndOwner = hwndOwner;
            hThread = CreateThread (NULL, 0,
                                    PlaySndThread,
                                    reinterpret_cast<LPVOID>(pData),
                                    0, &dw);
            if (hThread)
            {
                hr = S_OK;
                CloseHandle (hThread);
            }
            else
            {
                delete pData;
            }
        }
    }
    else
    {
        Trace(TEXT("GetIDAFromDataObject failed"));
    }
    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


/******************************************************************************

    DoAcquireScanVerb

    Launch the handler for the chosen scanner's scan event

******************************************************************************/

static const CLSID CLSID_Manager = {0xD13E3F25,0x1688,0x45A0,{0x97,0x43,0x75,0x9E,0xB3,0x5C,0xDF,0x9A}};
HRESULT
DoAcquireScanVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    LPITEMIDLIST pidl;
    bool bUseCallback = true;
    CComPtr<IWiaEventCallback>pec;
    CComPtr<IWiaItem> pItem;
    WIA_EVENT_HANDLER weh = {0};

    TraceEnter (TRACE_VERBS, "DoAcquireScanVerb");
    hr = GetIDAFromDataObject (pDataObject, &pida);
    if (SUCCEEDED(hr))
    {

        TraceAssert (pida->cidl == 1);
        pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        hr = IMGetItemFromIDL (pidl, &pItem);
    }
    if (SUCCEEDED(hr))
    {
        if (FAILED(WiaUiUtil::GetDefaultEventHandler(pItem, WIA_EVENT_SCAN_IMAGE, &weh)))
        {
            weh.guid = CLSID_Manager;
        }
        if (weh.bstrCommandline && *(weh.bstrCommandline))
        {
            Trace(TEXT("Got a command line!"));
            bUseCallback = false;
            hr = S_OK;
        }
        else
        {
            // if the user has chosen "Do Nothing" as the default action for this event,
            // use the wizard.
            if (IsEqualGUID (weh.guid, WIA_EVENT_HANDLER_NO_ACTION))
            {
                weh.guid = CLSID_Manager;
            }

            TraceGUID ("Got a GUID:", weh.guid);
            hr = CoCreateInstance (weh.guid,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaEventCallback,
                                   reinterpret_cast<LPVOID*>(&pec));
        }
    }

    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strDeviceId;
        IMGetDeviceIdFromIDL (pidl, strDeviceId);
        if (bUseCallback)
        {

            ULONG  ulEventType;
            CSimpleStringWide strName;
            CSimpleString strEvent(SFVIDS_MH_ACQUIRE, GLOBAL_HINSTANCE);

            IMGetNameFromIDL (pidl, strName);
            ulEventType = WIA_ACTION_EVENT;
            CoAllowSetForegroundWindow (pec, NULL);
            hr = pec->ImageEventCallback(
                                        &GUID_ScanImage,
                                        CComBSTR(CSimpleStringConvert::WideString(strEvent).String()),                      // Event Description
                                        CComBSTR(strDeviceId),
                                        CComBSTR(strName),                      // Device Description
                                        StiDeviceTypeScanner,
                                        NULL,
                                        &ulEventType,
                                        0);
        }
        else
        {
            PROCESS_INFORMATION pi;
            STARTUPINFO si;


            TCHAR szCommand[MAX_PATH*2];
            ZeroMemory (&si, sizeof(si));
            ZeroMemory (&pi, sizeof(pi));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;
            UINT cch = SysStringLen(weh.bstrCommandline)+1;
            #ifdef UNICODE
            lstrcpyn (szCommand, weh.bstrCommandline, (int)min(ARRAYSIZE(szCommand),cch)); 
            #else
            WideCharToMultiByte (CP_ACP, 0,
                                 weh.bstrCommandline, SysStringLen(weh.bstrCommandline)+1,
                                 szCommand, ARRAYSIZE(szCommand),
                                 NULL, NULL);
            #endif

            Trace(TEXT("Command line for STI app is %s"), szCommand);
            if (CreateProcess (NULL,szCommand,NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                CloseHandle (pi.hProcess);
                CloseHandle (pi.hThread);
            }
        }
    }
    if (FAILED(hr))
    {
         // Inform the user
         UIErrors::ReportMessage(hwndOwner,
                                 GLOBAL_HINSTANCE,
                                 NULL,
                                 MAKEINTRESOURCE(IDS_NO_SCAN_CAPTION),
                                 MAKEINTRESOURCE(IDS_NO_SCAN),
                                 MB_OK);
    }
    SysFreeString (weh.bstrDescription);
    SysFreeString (weh.bstrIcon);
    SysFreeString (weh.bstrName);
    SysFreeString (weh.bstrCommandline);

    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}

HRESULT
DoWizardVerb(HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    TraceEnter (TRACE_VERBS, "DoWizardVerb");
    LPIDA pida = NULL;
    HRESULT hr = GetIDAFromDataObject(pDataObject, &pida);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);

        //
        // Get the device ID
        //
        CSimpleStringWide strDeviceId;
        IMGetDeviceIdFromIDL( pidl, strDeviceId );

        //
        // Make sure this is a valid device ID
        //
        if (strDeviceId.Length())
        {
            //
            // Run the wizard
            //
            RunWizardAsync(strDeviceId);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


/**************************************
TakePictureDlgProc

Takes the picture then closes the dialog


***************************************/

INT_PTR
TakePictureDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    BOOL bRet = TRUE;
    BSTR bstrDeviceId;
    HRESULT hr;

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            PostMessage (hwnd, WM_USER+10, 0, 0);
            break;

        case WM_USER+10:
            bstrDeviceId = reinterpret_cast<BSTR>(GetWindowLongPtr (hwnd, DWLP_USER));
            if (bstrDeviceId)
            {

                hr = TakeAPicture (bstrDeviceId);

                if (FAILED(hr))
                {
                    UIErrors::ReportMessage(hwnd,
                                            GLOBAL_HINSTANCE,
                                            NULL,
                                            MAKEINTRESOURCE(IDS_SNAPSHOTCAPTION),
                                            MAKEINTRESOURCE(IDS_SNAPSHOTERR));
                }
                SysFreeString (bstrDeviceId);
            }
            SetWindowLongPtr (hwnd, DWLP_USER, 0);
            DestroyWindow (hwnd);
            return TRUE;

        default:
            bRet= FALSE;
            break;
    }
    return bRet;
}

HRESULT
DoTakePictureVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    LPITEMIDLIST pidl;
    CSimpleStringWide strDeviceId;

    TraceEnter (TRACE_VERBS, "DoWizardVerb");
    hr = GetIDAFromDataObject (pDataObject, &pida);

    if (SUCCEEDED(hr))
    {
        HWND hDlg;
        TraceAssert (pida->cidl == 1);
        pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        TraceAssert (IsDeviceIDL(pidl));

        IMGetDeviceIdFromIDL (pidl, strDeviceId);
        hDlg = CreateDialogParam (GLOBAL_HINSTANCE,
                              MAKEINTRESOURCE(IDD_TAKEPICTURE),
                              NULL,
                              TakePictureDlgProc,
                              reinterpret_cast<LPARAM>(SysAllocString(strDeviceId)));
        if (hDlg)
        {
            hr = S_OK;
        }
        else
        {
            DWORD dw = GetLastError();
            hr = HRESULT_FROM_WIN32 (dw);
        }
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}

HRESULT DoPrintVerb (HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT hr;
    TraceEnter(TRACE_VERBS, "DoPrintVerb");

    CComPtr<IDropTarget> pDropTarget;
    hr = CoCreateInstance( CLSID_PrintPhotosDropTarget, NULL, CLSCTX_INPROC_SERVER, IID_IDropTarget, (void**)&pDropTarget );
    if (SUCCEEDED(hr))
    {
        //
        // Perform the drop
        //
        DWORD dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
        POINTL pt = { 0, 0 };
        hr = pDropTarget->Drop( pDataObject, 0, pt, &dwEffect );
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\cfgdlg.h ===
#ifndef _CFGDLG_H_INCLUDED
#define _CFGDLG_H_INCLUDED

#define UWM_CONFIG_CHANGED (WM_USER+1300)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\verbs.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       verbs.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        5/27/98
 *
 *  DESCRIPTION: Definitions used by verb code
 *
 *****************************************************************************/

#ifndef __verbs_h
#define __verbs_h


HRESULT DoAcquireScanVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoSaveSndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoPlaySndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoPreviewVerb(   HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoSaveInMyPics(  HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoDeleteItem( HWND hwndOwner, LPDATAOBJECT pDataObject, BOOL bNoUI );
HRESULT DoGotoMyPics(    HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoWizardVerb (HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoPrintVerb (HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoTakePictureVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT GetIDAFromDataObject( LPDATAOBJECT pDataObject, LPIDA * ppida, bool bShellFmt = false);
const WCHAR cszImageCLSID[] =  L"{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
const TCHAR g_cszTempFilePrefix[] =  TEXT("_CA");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\shellext\src\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Imaging Devices Shell Folder UI"
#define VER_INTERNALNAME_STR            "wiashext"
#define VER_ORIGINALFILENAME_STR        "wiashext.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\cfgdlg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       CFGDLG.CPP
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Screensaver Configuration Dialog
*
*******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "cfgdlg.h"
#include "ssmprsrc.h"
#include "simstr.h"
#include "ssdata.h"
#include "simcrack.h"
#include "ssutil.h"
#include "ssconst.h"
#include "simidlst.h"
#include "wiacsh.h"

static const DWORD g_HelpIDs[] =
{
    IDC_MYPICTURES_ICON,        -1,
    IDC_DIALOG_DESCRIPTION,     -1,
    IDC_DIVIDER,                -1,

    IDC_FREQUENCY_STATIC,       IDH_WIA_CHANGE_PICS,
    IDC_FREQUENCY,              IDH_WIA_CHANGE_PICS,
    IDC_MINUTES_AND_SECONDS,    IDH_WIA_CHANGE_PICS,
    IDC_FREQ_LESS,              IDH_WIA_CHANGE_PICS,
    IDC_FREQ_MORE,              IDH_WIA_CHANGE_PICS,

    IDC_MAX_SIZE_STATIC,        IDH_WIA_PIC_SIZE,
    IDC_SIZE_LESS,              IDH_WIA_PIC_SIZE,
    IDC_SIZE_MORE,              IDH_WIA_PIC_SIZE,
    IDC_MAX_SIZE,               IDH_WIA_PIC_SIZE,
    IDC_IMAGE_SIZE_DESC,        IDH_WIA_PIC_SIZE,

    IDC_IMAGEDIR,               IDH_WIA_PICTURE_FOLDER,
    IDC_ALLOWSTRETCHING,        IDH_WIA_STRETCH_PICS,
    IDC_DISPLAYFILENAME,        IDH_WIA_SHOW_FILE_NAMES,
    IDC_ENABLE_TRANSITIONS,     IDH_WIA_TRANSITION_EFFECTS,
    IDC_ALLOW_KEYBOARDCONTROL,  IDH_WIA_ALLOW_SCROLL,

    IDOK,                       IDH_OK,
    IDCANCEL,                   IDH_CANCEL,
    IDC_BROWSE,                 IDH_WIA_BROWSE,

    0, 0
};

static CSimpleString ConstructMinutesAndSecondsString( HINSTANCE hInstance, UINT nTotalSeconds )
{
    CSimpleString strResult;
    UINT nMinutes = nTotalSeconds / 60;
    UINT nSeconds = nTotalSeconds % 60;
    if (0==nMinutes)
    {
        if (1==nSeconds)
        {
            strResult.Format( IDS_SECOND, hInstance, nSeconds );
        }
        else
        {
            strResult.Format( IDS_SECONDS, hInstance, nSeconds );
        }
    }
    else if (0==nSeconds)
    {
        if (1==nMinutes)
        {
            strResult.Format( IDS_MINUTE, hInstance, nMinutes );
        }
        else
        {
            strResult.Format( IDS_MINUTES, hInstance, nMinutes );
        }
    }
    else if (1==nMinutes && 1==nSeconds)
    {
        strResult.Format( IDS_MINUTE_AND_SECOND, hInstance, nMinutes, nSeconds );
    }
    else if (1==nMinutes)
    {
        strResult.Format( IDS_MINUTE_AND_SECONDS, hInstance, nMinutes, nSeconds );
    }
    else if (1==nSeconds)
    {
        strResult.Format( IDS_MINUTES_AND_SECOND, hInstance, nMinutes, nSeconds );
    }
    else
    {
        strResult.Format( IDS_MINUTES_AND_SECONDS, hInstance, nMinutes, nSeconds );
    }
    return strResult;
}


BOOL WINAPI ScreenSaverConfigureDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            ScreenSaverUtil::SetIcons( hDlg, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), IDI_MONITOR );

            CMyDocsScreenSaverData MyDocsScreenSaverData( HKEY_CURRENT_USER, REGISTRY_PATH );
            
            //
            // Initialize path
            //
            SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_SETTEXT, 0, (LPARAM)MyDocsScreenSaverData.ImageDirectory().String() );
            
            //
            // Initialize change frequency
            //
            SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_SETRANGE, 1, MAKELONG(6,180) );
            SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_SETPOS, 1, MyDocsScreenSaverData.ChangeInterval() / 1000 );
            CSimpleString strRes = ConstructMinutesAndSecondsString( (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), MyDocsScreenSaverData.ChangeInterval() / 1000 );
            SendDlgItemMessage( hDlg, IDC_MINUTES_AND_SECONDS, WM_SETTEXT, 0, (LPARAM)strRes.String() );

            //
            // Initialize maximum screen percentage size
            //
            SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_SETRANGE, 1, MAKELONG(25,100) );
            SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_SETPOS, 1, MyDocsScreenSaverData.MaxScreenPercent() );
            strRes.Format( IDS_PERCENT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), MyDocsScreenSaverData.MaxScreenPercent() );
            SendDlgItemMessage( hDlg, IDC_IMAGE_SIZE_DESC, WM_SETTEXT, 0, (LPARAM)strRes.String() );

            SendDlgItemMessage( hDlg, IDC_DISPLAYFILENAME, BM_SETCHECK, MyDocsScreenSaverData.DisplayFilename() ? BST_CHECKED : BST_UNCHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ENABLE_TRANSITIONS, BM_SETCHECK, MyDocsScreenSaverData.DisableTransitions() ? BST_UNCHECKED : BST_CHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ALLOWSTRETCHING, BM_SETCHECK, MyDocsScreenSaverData.AllowStretching() ? BST_CHECKED : BST_UNCHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ALLOW_KEYBOARDCONTROL, BM_SETCHECK, MyDocsScreenSaverData.AllowKeyboardControl() ? BST_CHECKED : BST_UNCHECKED, 0 );
        }
        return (TRUE);

    case WM_HSCROLL:
        {
            HWND hWndScroll = (HWND)lParam;
            if (GetDlgItem( hDlg, IDC_FREQUENCY )==hWndScroll)
            {
                UINT nFrequency = (UINT)SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_GETPOS, 0, 0 );
                CSimpleString strRes = ConstructMinutesAndSecondsString( (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), nFrequency );
                SendDlgItemMessage( hDlg, IDC_MINUTES_AND_SECONDS, WM_SETTEXT, 0, (LPARAM)strRes.String() );
            }
            else if (GetDlgItem( hDlg, IDC_MAX_SIZE )==hWndScroll)
            {
                int nPercent = (int)SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_GETPOS, 0, 0 );
                CSimpleString strRes;
                strRes.Format( IDS_PERCENT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), nPercent );
                SendDlgItemMessage( hDlg, IDC_IMAGE_SIZE_DESC, WM_SETTEXT, 0, (LPARAM)strRes.String() );
            }
        }
        return TRUE;

    case WM_CONTEXTMENU:
        WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
        return true;

    case WM_HELP:
        WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
        return true;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_BROWSE:
                {
                    TCHAR szTxt[MAX_PATH];
                    SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_GETTEXT, sizeof(szTxt)/sizeof(szTxt[0]), (LPARAM)szTxt );
                    CSimpleString strPrompt( IDS_DIRECTORYPROMPT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE) );
                    if (ScreenSaverUtil::SelectDirectory( hDlg, strPrompt.String(), szTxt ))
                    {
                        SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_SETTEXT, 0, (LPARAM)szTxt );
                    }
                }
                return TRUE;

            case IDOK:
                {
                    TCHAR szTxt[MAX_PATH];
                    CMyDocsScreenSaverData MyDocsScreenSaverData( HKEY_CURRENT_USER, REGISTRY_PATH );
                    
                    //
                    // Get the image path
                    //
                    if (SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_GETTEXT, sizeof(szTxt)/sizeof(szTxt[0]), (LPARAM)szTxt ))
                    {
                        //
                        // If this is the my pictures folder, delete the path name, so we will use the default next time
                        //
                        if (CSimpleIdList().GetSpecialFolder(hDlg,CSIDL_MYPICTURES).Name() == CSimpleString(szTxt))
                        {
                            MyDocsScreenSaverData.ImageDirectory(TEXT(""));
                        }
                        else
                        {
                            MyDocsScreenSaverData.ImageDirectory(szTxt);
                        }
                    }
                    UINT nFrequency = (UINT)SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_GETPOS, 0, 0 );
                    MyDocsScreenSaverData.ChangeInterval(nFrequency * 1000);
                    int nPercent = (int)SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_GETPOS, 0, 0 );
                    MyDocsScreenSaverData.MaxScreenPercent(nPercent);

                    bool bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_DISPLAYFILENAME, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.DisplayFilename(bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ENABLE_TRANSITIONS, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.DisableTransitions(!bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ALLOWSTRETCHING, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.AllowStretching(bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ALLOW_KEYBOARDCONTROL, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.AllowKeyboardControl(bChecked);

                    MyDocsScreenSaverData.Write();
                    HWND hWndParent = (HWND)GetWindowLongPtr( hDlg, GWLP_HWNDPARENT );

                    if (hWndParent)
                        PostMessage( hWndParent, UWM_CONFIG_CHANGED, 0, 0 );
                    EndDialog(hDlg, IDOK);
                }
                return (TRUE);

            case IDCANCEL:
                {
                    EndDialog(hDlg, IDCANCEL);
                }
                return (TRUE);
            }
        }
        return (FALSE);
    }
    return (FALSE);
}


BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    InitCommonControls();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\extimer.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "extimer.h"

CExclusiveTimer::CExclusiveTimer(void)
: m_nTimerId(0),
  m_hWnd(NULL)
{
}


CExclusiveTimer::~CExclusiveTimer(void)
{
    Kill();
}


void CExclusiveTimer::Kill(void)
{
    if (m_hWnd && m_nTimerId)
    {
        KillTimer( m_hWnd, m_nTimerId );
        m_hWnd = NULL;
        m_nTimerId = 0;
    }
}


void CExclusiveTimer::Set( HWND hWnd, UINT nTimerId, UINT nMilliseconds )
{
    Kill();
    m_hWnd = hWnd;
    m_nTimerId = nTimerId;
    if (m_hWnd && m_nTimerId)
    {
        SetTimer( m_hWnd, m_nTimerId, nMilliseconds, NULL );
    }
}


UINT CExclusiveTimer::TimerId(void) const
{
    return m_nTimerId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\extimer.h ===
#ifndef __EXTIMER_H_INCLUDED
#define __EXTIMER_H_INCLUDED

#include <windows.h>

class CExclusiveTimer
{
private:
    UINT m_nTimerId;
    HWND m_hWnd;

private:
    // No implementation
    CExclusiveTimer( const CExclusiveTimer & );
    CExclusiveTimer &operator=( const CExclusiveTimer & );

public:
    CExclusiveTimer(void);
    ~CExclusiveTimer(void);
    void Kill(void);
    void Set( HWND hWnd, UINT nTimerId, UINT nMilliseconds );
    UINT TimerId(void) const;
};

#endif //__EXTIMER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\findfile.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDFILE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Directory recursing class.  A derived class should be created,
 *               which overrides FoundFile, or you can pass in a callback function
 *               that is called for each file and directory found.  A cancel callback
 *               is also provided.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "findfile.h"
#include "simtok.h"

static CSimpleString EnsureTrailingBackslash( const CSimpleString &filename )
{
    if (!filename.Length())
        return (filename + CSimpleString(TEXT("\\")));
    else if (!filename.MatchLastCharacter(TEXT('\\')))
        return (filename + CSimpleString(TEXT("\\")));
    else return filename;
}

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam, int nStackLevel, const int cnMaxDepth )
{
    //
    // Prevent stack overflows
    //
    if (nStackLevel >= cnMaxDepth)
    {
        return true;
    }
    WIA_PUSH_FUNCTION((TEXT("RecursiveFindFiles( %s, %s )"), strDirectory.String(), strMask.String() ));
    bool bFindResult = true;
    bool bContinue = true;
    WIN32_FIND_DATA FindData;
    HANDLE hFind = FindFirstFile( EnsureTrailingBackslash(strDirectory) + TEXT("*"), &FindData );
    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (bFindResult && bContinue)
        {
            if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && lstrcmp(FindData.cFileName,TEXT("..")) && lstrcmp(FindData.cFileName,TEXT(".")))
            {
                if (pfnFindFilesCallback)
                    bContinue = pfnFindFilesCallback( false, EnsureTrailingBackslash(strDirectory)+FindData.cFileName, &FindData, pvParam );
                if (bContinue)
                    bContinue = RecursiveFindFiles( EnsureTrailingBackslash(strDirectory) + FindData.cFileName, strMask, pfnFindFilesCallback, pvParam, nStackLevel+1 );
            }
            bFindResult = (FindNextFile(hFind,&FindData) != FALSE);
        }
        FindClose(hFind);
    }
    CSimpleStringToken<CSimpleString> strMasks(strMask);
    while (bContinue)
    {
        CSimpleString TempMask = strMasks.Tokenize(TEXT(";"));
        if (!TempMask.Length())
            break;
        TempMask.TrimLeft();
        TempMask.TrimRight();
        if (TempMask.Length())
        {
            hFind = FindFirstFile( EnsureTrailingBackslash(strDirectory)+TempMask, &FindData );
            if (hFind != INVALID_HANDLE_VALUE)
            {
                bFindResult = true;
                while (bFindResult && bContinue)
                {
                    if (pfnFindFilesCallback)
                    {
                        bContinue = pfnFindFilesCallback( true, EnsureTrailingBackslash(strDirectory)+FindData.cFileName, &FindData, pvParam );
                    }
                    bFindResult = (FindNextFile(hFind,&FindData) != FALSE);
                }
                FindClose(hFind);
            }
        }
    }
    return bContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\findimgs.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDIMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Specialization of CFindFiles class that looks for image files and
 *               stores them in a dynamic array which is shuffled on initialization
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "findimgs.h"
#include "ssutil.h"

CFindImageFiles::CFindImageFiles(void)
  : m_nCurrentFile(0)
{
}

CFindImageFiles::~CFindImageFiles(void)
{
}


bool CFindImageFiles::NextFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size())
    {
        if (m_nCurrentFile >= m_ImageFiles.Size())
        {
            m_nCurrentFile = 0;
        }
        strFilename = m_ImageFiles[m_nCurrentFile];
        m_nCurrentFile++;
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}

bool CFindImageFiles::PreviousFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size()==1)
    {
        m_nCurrentFile = 0;
        strFilename = m_ImageFiles[0];
        bResult = (strFilename.Length() != 0);
    }
    else if (m_ImageFiles.Size()>=2)
    {
        m_nCurrentFile--;
        if (m_nCurrentFile < 0)
            m_nCurrentFile = m_ImageFiles.Size()-1;
        int nPrevFile = m_nCurrentFile-1;
        if (nPrevFile < 0)
            nPrevFile = m_ImageFiles.Size()-1;
        strFilename = m_ImageFiles[nPrevFile];
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}


void CFindImageFiles::Shuffle(void)
{
    for (int i=0;i<m_ImageFiles.Size();i++)
    {
        ScreenSaverUtil::Swap( m_ImageFiles[i], m_ImageFiles[m_RandomNumberGen.Generate(i,m_ImageFiles.Size())]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\findimgs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000, 1999, 2000
 *
 *  TITLE:       FINDIMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Specialization of CFindFiles class that looks for image files and
 *               stores them in a dynamic array which is shuffled on initialization
 *
 *******************************************************************************/
#ifndef __FINDIMGS_H_INCLUDED
#define __FINDIMGS_H_INCLUDED

#include <windows.h>
#include "findfile.h"
#include "randgen.h"
#include "simarray.h"

class CFindImageFiles
{
private:
    CSimpleDynamicArray<CSimpleString> m_ImageFiles;
    CRandomNumberGen                   m_RandomNumberGen;
    int                                m_nCurrentFile;

private:
    CFindImageFiles( const CFindImageFiles & );
    CFindImageFiles &operator=( const CFindImageFiles & );

public:
    CFindImageFiles(void);
    virtual ~CFindImageFiles(void);

    bool NextFile( CSimpleString &strFilename );
    bool PreviousFile( CSimpleString &strFilename );
    void Shuffle(void);
    bool FoundFile( LPCTSTR pszFilename )
    {
        if (pszFilename)
            m_ImageFiles.Append(pszFilename);
        return true;
    }


    void Reset(void)
    {
        m_nCurrentFile = 0;
    }
    int Count(void) const
    {
        return(m_ImageFiles.Size());
    }
    CSimpleString operator[](int nIndex)
    {
        return(m_ImageFiles[nIndex]);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\findthrd.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDTHRD.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __FINDTHRD_H_INCLUDED
#define __FINDTHRD_H_INCLUDED

#include <gphelper.h>

class CFoundFileMessageData
{
private:
    CSimpleString m_strFilename;

private:
    CFoundFileMessageData(void);
    CFoundFileMessageData( const CFoundFileMessageData & );
    CFoundFileMessageData &operator=( const CFoundFileMessageData & );

public:
    CFoundFileMessageData( const CSimpleString &strFilename )
      : m_strFilename(strFilename)
    {
    }
    ~CFoundFileMessageData(void)
    {
    }
    CSimpleString Name(void) const
    {
        return m_strFilename;
    }
};

class CFindFilesThread
{
private:
    CSimpleString       m_strDirectory;
    CSimpleString       m_strMask;
    HWND                m_hwndNotify;
    UINT                m_nNotifyMessage;
    HANDLE              m_hEventCancel;
    int                 m_nDirectoryCount;
    int                 m_nFailedFileCount;
    int                 m_nSuccessfulFileCount;
    int                 m_nMaxFailedFiles;
    int                 m_nMaxSuccessfulFiles;
    int                 m_nMaxDirectories;
    CImageFileFormatVerifier m_ImageFileFormatVerifier;

private:
    CFindFilesThread(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
      : m_strDirectory(strDirectory),
        m_strMask(strMask),
        m_hwndNotify(hwndNotify),
        m_nNotifyMessage(nNotifyMessage),
        m_hEventCancel(NULL),
        m_nDirectoryCount(0),
        m_nFailedFileCount(0),
        m_nSuccessfulFileCount(0),
        m_nMaxFailedFiles(nMaxFailedFiles),
        m_nMaxSuccessfulFiles(nMaxSuccessfulFiles),
        m_nMaxDirectories(nMaxDirectories)
    {
        if (!DuplicateHandle( GetCurrentProcess(), hEventCancel, GetCurrentProcess(), &m_hEventCancel, 0, FALSE, DUPLICATE_SAME_ACCESS ))
            m_hEventCancel = NULL;
    }
    ~CFindFilesThread(void)
    {
        if (m_hEventCancel)
        {
            CloseHandle(m_hEventCancel);
            m_hEventCancel = NULL;
        }
    }

private:
    static bool FoundFile( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *, PVOID pvParam )
    {
        CFindFilesThread *pThis = reinterpret_cast<CFindFilesThread*>(pvParam);
        if (pThis)
            return pThis->FoundFile( bIsFile, pszFilename );
        return false;
    }

    bool FoundFile( bool bIsFile, LPCTSTR pszFilename )
    {
        WIA_PUSH_FUNCTION((TEXT("CFindFilesThread::FoundFile( %d, %s )"), bIsFile, pszFilename ));
        // Check to see if we've been cancelled
        if (m_hEventCancel)
        {
            DWORD dwRes = WaitForSingleObject(m_hEventCancel,0);
            if (WAIT_OBJECT_0 == dwRes)
                return false;
        }

        // If this is a file, and it is an image file that we can decode, package up a message and send it off
        if (bIsFile)
        {
            if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
            {
                if (m_ImageFileFormatVerifier.IsImageFile(pszFilename))
                {
                    m_nSuccessfulFileCount++;
                    CFoundFileMessageData *pFoundFileMessageData = new CFoundFileMessageData( pszFilename );
                    if (pFoundFileMessageData)
                    {
                        PostMessage( m_hwndNotify, m_nNotifyMessage, true, reinterpret_cast<LPARAM>(pFoundFileMessageData) );
                    }
                }
                else m_nFailedFileCount++;
            }
        }
        else m_nDirectoryCount++;

        // If we've exceeded the number of failures we're allowed, stop searching
        if (m_nMaxFailedFiles && m_nFailedFileCount >= m_nMaxFailedFiles)
        {
            WIA_TRACE((TEXT("FailedFileCount exceeded MaxFailedFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of files we want to handle, stop searching
        if (m_nMaxSuccessfulFiles && m_nSuccessfulFileCount >= m_nMaxSuccessfulFiles)
        {
            WIA_TRACE((TEXT("m_nSuccessfulFileCount exceeded MaxSuccessfulFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of directories we're allowed, stop searching
        if (m_nMaxDirectories && m_nDirectoryCount >= m_nMaxDirectories)
        {
            WIA_TRACE((TEXT("DirectoryCount exceeded MaxDirectories, bailing out")));
            return false;
        }

        return true;
    }

    bool Find(void)
    {
        bool bResult = RecursiveFindFiles( m_strDirectory, m_strMask, FoundFile, this );

        // Tell the window we're done
        if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
        {
            PostMessage( m_hwndNotify, m_nNotifyMessage, FALSE, FALSE );
        }
        return bResult;
    }

    static DWORD __stdcall ThreadProc( PVOID pVoid )
    {
        CFindFilesThread *pFindFilesThread = reinterpret_cast<CFindFilesThread*>(pVoid);
        if (pFindFilesThread)
        {
            pFindFilesThread->Find();
            delete pFindFilesThread;
        }
        return 0;
    }
public:
    static HANDLE Find(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
    {
        HANDLE hThread = NULL;
        CFindFilesThread *pFindFilesThread = new CFindFilesThread( strDirectory, strMask, hwndNotify, nNotifyMessage, hEventCancel, nMaxFailedFiles, nMaxSuccessfulFiles, nMaxDirectories );
        if (pFindFilesThread)
        {
            DWORD dwThreadId;
            hThread = CreateThread( NULL, 0, ThreadProc, pFindFilesThread, 0, &dwThreadId );
            if (!hThread)
            {
                delete pFindFilesThread;
            }
            else
            {
                SetThreadPriority( hThread, THREAD_PRIORITY_LOWEST );
            }
        }
        return hThread;
    }
};

#endif //__FINDTHRD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\findfile.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDFILE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Directory recursing class.  A derived class should be created,
 *               which overrides FoundFile, or you can pass in a callback function
 *               that is called for each file and directory found.  A cancel callback
 *               is also provided.
 *
 *******************************************************************************/
#ifndef __FINDFILE_H_INCLUDED
#define __FINDFILE_H_INCLUDED

#include <windows.h>
#include "simstr.h"

typedef bool (*FindFilesCallback)( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *pFindData, PVOID pvParam );

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam, int nStackLevel=0, const int cnMaxDepth=10 );


#endif // __FINDFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\imagescr.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMAGESCR.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: My Pictures Slideshow screen saver class
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "imagescr.h"
#include "simreg.h"
#include "waitcurs.h"
#include "ssutil.h"
#include "findthrd.h"
#include "ssmprsrc.h"
#include <shlobj.h>

CImageScreenSaver::CImageScreenSaver( HINSTANCE hInstance, const CSimpleString &strRegistryKey )
: m_pPainter(NULL),
m_hInstance(hInstance),
m_MyDocsScreenSaverData( HKEY_CURRENT_USER, strRegistryKey )
{
    EnumDisplayMonitors( NULL, NULL, MonitorEnumProc, reinterpret_cast<LPARAM>(this) );
}

CImageScreenSaver::~CImageScreenSaver(void)
{
    if (m_pPainter)
        delete m_pPainter;
    m_pPainter = NULL;
}

BOOL CALLBACK CImageScreenSaver::MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, LPRECT prcMonitor, LPARAM lParam )
{
    CImageScreenSaver *pThis = reinterpret_cast<CImageScreenSaver*>(lParam);
    if (pThis)
    {
        if (hMonitor)
        {
            MONITORINFOEX MonitorInfoEx;
            ZeroMemory( &MonitorInfoEx, sizeof(MonitorInfoEx) );
            MonitorInfoEx.cbSize = sizeof(MonitorInfoEx);
            if (GetMonitorInfo( hMonitor, reinterpret_cast<MONITORINFO*>(&MonitorInfoEx)))
            {
                pThis->m_ScreenList.Append( MonitorInfoEx.rcMonitor );
                WIA_TRACE((TEXT("Monitor = [%s], rcMonitor = (%d,%d,%d,%d), rcWork = (%d,%d,%d,%d), dwFlags = %08X\n"),
                           MonitorInfoEx.szDevice,
                           MonitorInfoEx.rcMonitor.left, MonitorInfoEx.rcMonitor.top, MonitorInfoEx.rcMonitor.right, MonitorInfoEx.rcMonitor.bottom,
                           MonitorInfoEx.rcWork.left, MonitorInfoEx.rcWork.top, MonitorInfoEx.rcWork.right, MonitorInfoEx.rcWork.bottom,
                           MonitorInfoEx.dwFlags ));
            }
            else
            {
                WIA_TRACE((TEXT("MonitorEnumProc, GetMonitorInfo failed (%d)\n"), GetLastError()));
            }
        }
        else
        {
            WIA_TRACE((TEXT("MonitorEnumProc, hMonitor == NULL\n")));
        }
    }
    else
    {
        WIA_TRACE((TEXT("MonitorEnumProc, pThis == NULL\n")));
    }
    return TRUE;
}


bool CImageScreenSaver::IsValid(void) const
{
    return(true);
}

HANDLE CImageScreenSaver::Initialize( HWND hwndNotify, UINT nNotifyMessage, HANDLE hEventCancel )
{
    HANDLE hResult = NULL;

    //
    // Get the file extensions for the file types we are able to deal with
    //
    CSimpleString strExtensions;
    m_GdiPlusHelper.ConstructDecoderExtensionSearchStrings(strExtensions);
    WIA_TRACE((TEXT("strExtensions = %s"), strExtensions.String()));

    //
    // Start the image finding thread
    //
    hResult = CFindFilesThread::Find(
                                    m_MyDocsScreenSaverData.ImageDirectory(),
                                    strExtensions,
                                    hwndNotify,
                                    nNotifyMessage,
                                    hEventCancel,
                                    m_MyDocsScreenSaverData.MaxFailedFiles(),
                                    m_MyDocsScreenSaverData.MaxSuccessfulFiles(),
                                    m_MyDocsScreenSaverData.MaxDirectories()
                                    );

    //
    // Return the thread handle
    //
    return hResult;
}

bool CImageScreenSaver::TimerTick( CSimpleDC &ClientDC )
{
    if (m_pPainter && ClientDC.IsValid())
    {
        return m_pPainter->TimerTick( ClientDC );
    }
    return false;
}

void CImageScreenSaver::Paint( CSimpleDC &PaintDC )
{
    if (m_pPainter && PaintDC.IsValid())
    {
        m_pPainter->Paint( PaintDC );
    }
}

int CImageScreenSaver::ChangeTimerInterval(void) const
{
    return(m_MyDocsScreenSaverData.ChangeInterval());
}

int CImageScreenSaver::PaintTimerInterval(void) const
{
    return(m_MyDocsScreenSaverData.PaintInterval());
}


bool CImageScreenSaver::AllowKeyboardControl(void)
{
    return(m_MyDocsScreenSaverData.AllowKeyboardControl());
}

bool CImageScreenSaver::ReplaceImage( bool bForward, bool bNoTransition )
{
    CSimpleString strCurrentFile;
    if (m_pPainter)
    {
        delete m_pPainter;
        m_pPainter = NULL;
    }

    if (!m_VisibleAreaList.Size())
    {
        return false;
    }

    if (m_FindImageFiles.Count())
    {
        //
        // exit the loop when we get a valid image or we've exhausted the list
        //
        int nNumTries = 0;
        while (!m_pPainter && nNumTries < m_FindImageFiles.Count())
        {
            CSimpleString strNextFile;

            bool bNextFile = bForward ? m_FindImageFiles.NextFile(strNextFile) : m_FindImageFiles.PreviousFile(strNextFile);
            if (bNextFile)
            {
                CSimpleDC ClientDC;
                if (ClientDC.GetDC(NULL))
                {
                    CBitmapImage *pBitmapImage = new CBitmapImage;
                    if (pBitmapImage)
                    {
                        int nAreaToUse = CRandomNumberGen().Generate(0,m_VisibleAreaList.Size());
                        RECT rcAreaToUse = m_VisibleAreaList[nAreaToUse];
                        WIA_TRACE((TEXT("Chosen Image Area [%d] = (%d,%d), (%d,%d)"), nAreaToUse, rcAreaToUse.left, rcAreaToUse.top, rcAreaToUse.right, rcAreaToUse.bottom ));
                        if (pBitmapImage->Load( ClientDC, strNextFile, rcAreaToUse, m_MyDocsScreenSaverData.MaxScreenPercent(), m_MyDocsScreenSaverData.AllowStretching(), m_MyDocsScreenSaverData.DisplayFilename() ))
                        {
                            if (m_MyDocsScreenSaverData.DisableTransitions() || bNoTransition)
                            {
                                m_pPainter = new CSimpleTransitionPainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                            }
                            else
                            {
                                m_pPainter = GetRandomImagePainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                            }

                            //
                            // If we couldn't create a painter, delete the bitmap
                            //
                            if (!m_pPainter)
                            {
                                WIA_TRACE((TEXT("%hs (%d): Unable to create a painter\n"), __FILE__, __LINE__ ));
                                delete pBitmapImage;
                            }
                        }
                        else
                        {
                            WIA_TRACE((TEXT("%hs (%d): pBitmapImage->Load() failed\n"), __FILE__, __LINE__ ));
                            delete pBitmapImage;
                        }
                    }
                    else
                    {
                        WIA_TRACE((TEXT("%hs (%d): CImageScreenSaver::CreateImage() failed\n"), __FILE__, __LINE__ ));
                    }
                }
                else
                {
                    WIA_TRACE((TEXT("%hs (%d): ClientDC.GetDC() failed\n"), __FILE__, __LINE__ ));
                }
            }
            else
            {
                WIA_TRACE((TEXT("%hs (%d): m_FindImageFiles.NextFile() failed\n"), __FILE__, __LINE__ ));
            }
            nNumTries++;
        }
    }
    else
    {
        //
        // Create a new image
        //
        CBitmapImage *pBitmapImage = new CBitmapImage;
        if (pBitmapImage)
        {
            //
            // Get a desktop DC
            //
            CSimpleDC ClientDC;
            if (ClientDC.GetDC(NULL))
            {
                //
                // Figure out which screen to display the message on
                //
                RECT rcAreaToUse = m_VisibleAreaList[CRandomNumberGen().Generate(0,m_VisibleAreaList.Size())];

                //
                // Create the bitmap with an appropriate message
                //
                if (pBitmapImage->CreateFromText( CSimpleString().Format( IDS_NO_FILES_FOUND, g_hInstance, m_MyDocsScreenSaverData.ImageDirectory().String() ), rcAreaToUse, m_MyDocsScreenSaverData.MaxScreenPercent() ))
                {
                    //
                    // Create a simple painter to display it
                    //
                    m_pPainter = new CSimpleTransitionPainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                    if (!m_pPainter)
                    {
                        //
                        // If we couldn't get a painter, destroy the bitmap
                        //
                        delete pBitmapImage;
                    }
                }
                else
                {
                    //
                    // If we couldn't create a bitmap, destroy it
                    //
                    delete pBitmapImage;
                }
            }
        }
    }
    return(m_pPainter != NULL);
}

CImagePainter *CImageScreenSaver::GetRandomImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &dc, const RECT &rcAreaToUse, const RECT &rcClient )
{
    CImagePainter *pPainter = NULL;
    int nPainter = CRandomNumberGen().Generate(0,5);
    if (!pPainter)
    {
        switch (nPainter)
        {
        case 0:
            pPainter = new CSimpleTransitionPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 1:
            pPainter = new CSlidingTransitionPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 2:
            pPainter = new CRandomBlockPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 3:
            pPainter = new CAlphaFadePainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 4:
            pPainter = new COpenCurtainPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        }
    }
    if (!pPainter)
    {
        WIA_TRACE((TEXT("%hs (%d): pPainter is NULL\n"), __FILE__, __LINE__ ));
        return(NULL);
    }
    if (!pPainter->IsValid())
    {
        WIA_TRACE((TEXT("%hs (%d): pPainter->IsValid() == FALSE\n"), __FILE__, __LINE__ ));
        delete pPainter;
        return(NULL);
    }
    return(pPainter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\imagescr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMAGESCR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: My Pictures Slideshow screen saver class
 *
 *******************************************************************************/
#ifndef __IMAGESCR_H_INCLUDED
#define __IMAGESCR_H_INCLUDED

#include <windows.h>
#include <atlbase.h>
#include "findimgs.h"
#include "painters.h"
#include "ssdata.h"
#include "waitcurs.h"
#include "simlist.h"
#include "simarray.h"
#include "gphelper.h"

class CImageScreenSaver
{
private:
    CFindImageFiles           m_FindImageFiles;
    CImagePainter            *m_pPainter;
    HINSTANCE                 m_hInstance;
    RECT                      m_rcClient;
    CMyDocsScreenSaverData    m_MyDocsScreenSaverData;
    CSimpleDynamicArray<RECT> m_ScreenList;
    CSimpleDynamicArray<RECT> m_VisibleAreaList;
    CGdiPlusHelper            m_GdiPlusHelper;

private:
    // No implementation
    CImageScreenSaver(void);
    CImageScreenSaver( const CImageScreenSaver & );
    CImageScreenSaver &operator=( const CImageScreenSaver & );

private:
    static BOOL CALLBACK MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, LPRECT prcMonitor, LPARAM lParam );

public:
    CImageScreenSaver( HINSTANCE hInstance, const CSimpleString &strRegistryKey );
    ~CImageScreenSaver(void);
    bool IsValid(void) const;
    HANDLE Initialize( HWND hwndNotify, UINT nNotifyMessage, HANDLE hEventCancel );
    bool TimerTick( CSimpleDC &ClientDC );
    void Paint( CSimpleDC &PaintDC );
    int ChangeTimerInterval(void) const;
    int PaintTimerInterval(void) const;
    bool ReplaceImage( bool bForward, bool bNoTransition );
    bool AllowKeyboardControl(void);
    int Count(void) const
    {
        return m_FindImageFiles.Count();
    }
    void ResetFileQueue(void)
    {
        m_FindImageFiles.Reset();
        m_FindImageFiles.Shuffle();
    }
    bool FoundFile( LPCTSTR pszFilename )
    {
        return m_FindImageFiles.FoundFile( pszFilename );
    }
    void SetScreenRect( HWND hWnd )
    {
        WIA_PUSHFUNCTION(TEXT("CImageScreenSaver::SetScreenRect"));
        GetClientRect( hWnd, &m_rcClient );
        WIA_TRACE((TEXT("m_rcClient = (%d,%d), (%d,%d)"), m_rcClient.left, m_rcClient.top, m_rcClient.right, m_rcClient.bottom ));
        m_VisibleAreaList.Destroy();
        for (int i=0;i<m_ScreenList.Size();i++)
        {
            WIA_TRACE((TEXT("m_ScreenList[%d] = (%d,%d), (%d,%d)"), i, m_ScreenList[i].left, m_ScreenList[i].top, m_ScreenList[i].right, m_ScreenList[i].bottom ));
            RECT rcScreenInClientCoords = m_ScreenList[i];
            WiaUiUtil::ScreenToClient( hWnd, &rcScreenInClientCoords );
            RECT rcIntersection;
            if (IntersectRect( &rcIntersection, &m_rcClient, &rcScreenInClientCoords ))
            {
                m_VisibleAreaList.Append(rcIntersection);
                WIA_TRACE((TEXT("Adding Visible Area = (%d,%d), (%d,%d)"), rcIntersection.left, rcIntersection.top, rcIntersection.right, rcIntersection.bottom ));
            }
        }
    }
    void ReadConfigData(void)
    {
        m_MyDocsScreenSaverData.Read();
    }
    CBitmapImage *CreateImage( LPCTSTR pszFilename );
    CImagePainter *GetRandomImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &dc, const RECT &rcAreaToUse, const RECT &rcClient );
};

#endif // __IMAGESCR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\imgs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image decoding and scaling wrapper.
 *
 *******************************************************************************/
#ifndef __IMGS_H_INCLUDED
#define __IMGS_H_INCLUDED

#include <windows.h>
#include "simdc.h"
#include "simstr.h"

class CBitmapImage
{
private:
    HBITMAP m_hBitmap;
    HPALETTE m_hPalette;

private:
    operator=( const CBitmapImage & );
    CBitmapImage( const CBitmapImage & );

public:
    CBitmapImage(void);
    virtual ~CBitmapImage(void);
    void Destroy(void);
    bool IsValid(void) const;
    HPALETTE Palette(void) const;
    HBITMAP GetBitmap(void) const;
    SIZE ImageSize(void) const;

    HPALETTE PreparePalette( CSimpleDC &dc, HBITMAP hBitmap );

    bool Load( CSimpleDC  &dc, LPCTSTR pszFilename, const RECT &rcScreen, int nMaxScreenPercent, bool bAllowStretching, bool bDisplayFilename );
    bool CreateFromText( LPCTSTR pszText, const RECT &rcScreen, int nMaxScreenPercent );
};

#endif //__IMGS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\imgs.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMGS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image class
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "imgs.h"
#include <windowsx.h>
#include <atlbase.h>
#include "ssutil.h"
#include "gphelper.h"

CBitmapImage::CBitmapImage(void)
  : m_hBitmap(NULL),
    m_hPalette(NULL)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::CBitmapImage"));
}

CBitmapImage::~CBitmapImage(void)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::~CBitmapImage"));
    Destroy();
}

void CBitmapImage::Destroy(void)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::Destroy"));
    if (m_hBitmap)
        DeleteObject(m_hBitmap);
    m_hBitmap = NULL;
    if (m_hPalette)
        DeleteObject(m_hPalette);
    m_hPalette = NULL;
}


bool CBitmapImage::IsValid(void) const
{
    return(m_hBitmap != NULL);
}


HPALETTE CBitmapImage::Palette(void) const
{
    return(m_hPalette);
}


HBITMAP CBitmapImage::GetBitmap(void) const
{
    return(m_hBitmap);
}

// Create a palette for the image
HPALETTE CBitmapImage::PreparePalette( CSimpleDC &dc, HBITMAP hBitmap )
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::PreparePalette"));
    HPALETTE hPalette = NULL;
    if (GetDeviceCaps(dc,RASTERCAPS) & RC_PALETTE)
    {
        if (hBitmap)
        {
            DIBSECTION ds = {0};
            GetObject(hBitmap, sizeof (DIBSECTION), &ds);

            int nColors;
            if (ds.dsBmih.biClrUsed != 0)
            {
                nColors = ds.dsBmih.biClrUsed;
            }
            else
            {
                //
                // Handle the special case of an image that claims to be
                // a 32bit DIB as a 24bit DIB
                //
                if (ds.dsBmih.biBitCount == 32)
                {
                    nColors = 1 << 24;
                }
                else
                {
                    nColors = 1 << ds.dsBmih.biBitCount;
                }
            }

            //
            // Create a halftone palette if the DIB section contains more
            // than 256 colors
            //
            if (nColors > 256)
            {
                hPalette = CreateHalftonePalette(dc);
            }

            //
            // Create a custom palette from the DIB section's color table
            // if the number of colors is 256 or less
            //
            else
            {
                RGBQUAD* pRGB = new RGBQUAD[nColors];
                if (pRGB)
                {
                    CSimpleDC MemDC;
                    MemDC.CreateCompatibleDC(dc);
                    SelectObject( MemDC, hBitmap );
                    GetDIBColorTable( MemDC, 0, nColors, pRGB );

                    UINT nSize = sizeof (LOGPALETTE) + (sizeof (PALETTEENTRY) * (nColors - 1));

                    LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];
                    if (pLP)
                    {
                        pLP->palVersion = 0x300;
                        pLP->palNumEntries = (WORD)nColors;

                        for (int i=0; i<nColors; i++)
                        {
                            pLP->palPalEntry[i].peRed = pRGB[i].rgbRed;
                            pLP->palPalEntry[i].peGreen = pRGB[i].rgbGreen;
                            pLP->palPalEntry[i].peBlue = pRGB[i].rgbBlue;
                            pLP->palPalEntry[i].peFlags = 0;
                        }

                        hPalette = CreatePalette(pLP);
                        delete[] pLP;
                    }
                    delete[] pRGB;
                }
            }
        }
    }
    else
    {
        hPalette = CreateHalftonePalette(dc);
    }
    WIA_TRACE((TEXT("Returning palette %08X"), hPalette ));
    return hPalette;
}



SIZE CBitmapImage::ImageSize(void) const
{
    SIZE sizeImage = {0,0};
    if (IsValid())
    {
        BITMAP bm = {0};
        if (GetObject( m_hBitmap, sizeof(bm), &bm ))
        {
            sizeImage.cx = bm.bmWidth;
            sizeImage.cy = bm.bmHeight;
        }
    }
    return(sizeImage);
}

bool CBitmapImage::CreateFromText( LPCTSTR pszText, const RECT &rcScreen, int nMaxScreenPercent )
{
    Destroy();
    HDC hDesktopDC = GetDC(NULL);
    if (hDesktopDC)
    {
        //
        // Calculate the maximum size of the text rectangle
        //
        RECT rcImage = { 0, 0, WiaUiUtil::MulDivNoRound(rcScreen.right - rcScreen.left,nMaxScreenPercent,100), WiaUiUtil::MulDivNoRound(rcScreen.bottom - rcScreen.top,nMaxScreenPercent,100) };

        //
        // Create a mem dc to hold the bitmap
        //
        CSimpleDC MemDC;
        if (MemDC.CreateCompatibleDC(hDesktopDC))
        {
            //
            // Use the default UI font
            //
            SelectObject( MemDC, GetStockObject( DEFAULT_GUI_FONT ) );

            //
            // Figure out how big the bitmap has to be
            //
            DrawText( MemDC, pszText, lstrlen(pszText), &rcImage, DT_NOPREFIX|DT_WORDBREAK|DT_CALCRECT|DT_RTLREADING );

            //
            // Create the bitmap
            //
            m_hBitmap = CreateCompatibleBitmap( hDesktopDC, rcImage.right, rcImage.bottom );

            if (m_hBitmap)
            {
                //
                // Set the appropriate colors and select the bitmap into the DC
                //
                SetBkColor( MemDC, RGB(0,0,0) );
                SetTextColor( MemDC, RGB(255,255,255) );
                SelectBitmap( MemDC, m_hBitmap );

                //
                // Draw the actual text
                //
                DrawText( MemDC, pszText, lstrlen(pszText), &rcImage, DT_NOPREFIX|DT_WORDBREAK|DT_RTLREADING );
            }

        }

        //
        // Free the desktop DC
        //
        ReleaseDC(NULL,hDesktopDC);
    }
    return m_hBitmap != NULL;
}


bool CBitmapImage::Load( CSimpleDC  &dc,
                         LPCTSTR     pszFilename,
                         const RECT &rcScreen,
                         int         nMaxScreenPercent,
                         bool        bAllowStretching,
                         bool        bDisplayFilename
                       )
{
    //
    // Clean up, if necessary
    //
    Destroy();

    //
    // Validate the arguments
    //
    if (!pszFilename || !lstrlen(pszFilename))
    {
        return false;
    }

    //
    // Try to load and scale the image using GDI plus
    //
    CGdiPlusHelper GdiPlusHelper;
    if (SUCCEEDED(GdiPlusHelper.LoadAndScale( m_hBitmap, pszFilename, WiaUiUtil::MulDivNoRound(rcScreen.right - rcScreen.left,nMaxScreenPercent,100), WiaUiUtil::MulDivNoRound(rcScreen.bottom - rcScreen.top,nMaxScreenPercent,100), bAllowStretching )) && m_hBitmap)
    {
        //
        // Get the size of the image
        //
        SIZE sizeImage = ImageSize();

        //
        // Prepare the image's palette, if it has one
        //
        m_hPalette = PreparePalette( dc, m_hBitmap );

        //
        // Add the image title
        //
        if (bDisplayFilename && *pszFilename)
        {
            CSimpleDC MemoryDC;
            if (MemoryDC.CreateCompatibleDC(dc))
            {
                //
                // Prepare the DC and select the current image into it
                //
                ScreenSaverUtil::SelectPalette( MemoryDC, Palette(), FALSE );
                SelectBitmap( MemoryDC, m_hBitmap );
                SetBkMode( MemoryDC, TRANSPARENT );

                //
                // Create the title DC
                //
                CSimpleDC ImageTitleDC;
                if (ImageTitleDC.CreateCompatibleDC(dc))
                {
                    //
                    // Prepare the title DC
                    //
                    ScreenSaverUtil::SelectPalette( ImageTitleDC, Palette(), FALSE );
                    SelectFont( ImageTitleDC, (HFONT)GetStockObject(DEFAULT_GUI_FONT) );
                    SetBkMode( ImageTitleDC, TRANSPARENT );

                    //
                    // Calculate the rectangle needed to print the filename
                    //
                    RECT rcText;
                    rcText.left = 0;
                    rcText.top = 0;
                    rcText.right = sizeImage.cx;
                    rcText.bottom = sizeImage.cy;

                    //
                    // Make a nice margin
                    //
                    InflateRect( &rcText, -2, -2 );
                    DrawText( ImageTitleDC, pszFilename, lstrlen(pszFilename), &rcText, DT_PATH_ELLIPSIS|DT_SINGLELINE|DT_NOPREFIX|DT_TOP|DT_LEFT|DT_CALCRECT );
                    InflateRect( &rcText, 2, 2 );

                    //
                    // If the text rect is bigger than the scaled image, make it the same size
                    //
                    if (rcText.right > sizeImage.cx)
                        rcText.right = sizeImage.cx;
                    if (rcText.bottom > sizeImage.cy)
                        rcText.bottom = sizeImage.cy;

                    //
                    // Create the bitmap we'll use for the filename
                    //
                    BITMAPINFO bmi;
                    ZeroMemory( &bmi, sizeof(BITMAPINFO) );
                    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    bmi.bmiHeader.biWidth           = rcText.right - rcText.left;
                    bmi.bmiHeader.biHeight          = rcText.bottom - rcText.top;
                    bmi.bmiHeader.biPlanes          = 1;
                    bmi.bmiHeader.biBitCount        = 24;
                    bmi.bmiHeader.biCompression     = BI_RGB;
                    PBYTE pBitmapData = NULL;
                    HBITMAP hBmpImageTitle = CreateDIBSection( dc, &bmi, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
                    if (hBmpImageTitle)
                    {
                        //
                        // Initialize the Alpha blend stuff
                        //
                        BLENDFUNCTION BlendFunction;
                        ZeroMemory( &BlendFunction, sizeof(BlendFunction) );
                        BlendFunction.BlendOp = AC_SRC_OVER;
                        BlendFunction.SourceConstantAlpha = 128;

                        //
                        // Select our new bitmap into the memory dc
                        //
                        HBITMAP hOldBitmap = SelectBitmap( ImageTitleDC, hBmpImageTitle );

                        //
                        // White background
                        //
                        FillRect( ImageTitleDC, &rcText, (HBRUSH)GetStockObject(WHITE_BRUSH));

                        //
                        // Alpha blend from the stretched bitmap to our text rect
                        //
                        AlphaBlend( ImageTitleDC, 0, 0, rcText.right - rcText.left, rcText.bottom - rcText.top, MemoryDC, rcText.left, rcText.top, rcText.right, rcText.bottom, BlendFunction );

                        //
                        // Draw the actual text
                        //
                        InflateRect( &rcText, -2, -2 );
                        DrawText( ImageTitleDC, pszFilename, lstrlen(pszFilename), &rcText, DT_PATH_ELLIPSIS|DT_SINGLELINE|DT_NOPREFIX|DT_TOP|DT_LEFT );
                        InflateRect( &rcText, 2, 2 );

                        //
                        // Copy back to the current image
                        //
                        BitBlt( MemoryDC, rcText.left, rcText.top, rcText.right - rcText.left, rcText.bottom - rcText.top, ImageTitleDC, 0, 0, SRCCOPY );

                        //
                        // Restore the dc's bitmap, and delete our title background
                        //
                        DeleteObject( SelectObject( ImageTitleDC, hOldBitmap ) );
                    }
                }
            }
        }
    }
    return (m_hBitmap != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\painters.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       PAINTERS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image transition base class and derived classes
 *
 *******************************************************************************/
#ifndef __PAINTERS_H_INCLUDED
#define __PAINTERS_H_INCLUDED

#include <windows.h>
#include "imgs.h"
#include "randgen.h"
#include "simdc.h"

class CImagePainter
{
private:
    CBitmapImage     *m_pBitmapImage;
    DWORD             m_dwInitialTickCount;
    bool              m_bFirstFrame;
    bool              m_bAlreadyPaintedLastFrame;

protected:
    CRandomNumberGen  m_RandomNumberGen;
    RECT              m_rcScreen;
    RECT              m_rcImageArea;
    RECT              m_rcFinal;
    DWORD             m_dwDuration;

private:
    CImagePainter(void);
    CImagePainter( const CImagePainter & );
    operator=( const CImagePainter & );

public:
    CImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CImagePainter(void);
    DWORD ElapsedTime(void) const;
    CBitmapImage *BitmapImage(void);
    void Paint( CSimpleDC &PaintDC );
    bool TimerTick( CSimpleDC &ClientDC );
    void Erase( CSimpleDC &ClientDC, RECT &rc );

    virtual void Paint( CSimpleDC &PaintDC, CSimpleDC &MemoryDC );
    virtual bool NeedPainting(void);
    virtual bool IsValid(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC ) = 0;
};


class CSimpleTransitionPainter : public CImagePainter
{
public:
    CSimpleTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CSimpleTransitionPainter(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CSlidingTransitionPainter : public CImagePainter
{
private:
    RECT m_rcOriginal;
    RECT m_rcPrevious;
public:
    CSlidingTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CSlidingTransitionPainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CRandomBlockPainter : public CImagePainter
{
private:
    int *m_pBlockAddresses;
    int  m_nBlockSize;
    int  m_nStartIndex;
    SIZE m_sizeBlockCount;
public:
    CRandomBlockPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CRandomBlockPainter(void);
    virtual bool NeedPainting(void);
    virtual bool IsValid(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CAlphaFadePainter : public CImagePainter
{
private:
    BLENDFUNCTION m_bfBlendFunction;
    HBITMAP m_hbmpBuffer;
    CSimpleDC CompatDC;
public:
    CAlphaFadePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual bool IsValid(void);
    virtual ~CAlphaFadePainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class COpenCurtainPainter : public CImagePainter
{
private:
    int   m_nCurrentWidth;
    int   m_nFinalWidth;
public:
    COpenCurtainPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~COpenCurtainPainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


#endif // __PAINTERS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\painters.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       PAINTERS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image transition base class and derived classes
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "painters.h"
#include <windowsx.h>
#include "ssutil.h"


CImagePainter::CImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: m_pBitmapImage(pBitmapImage),
  m_dwInitialTickCount(0),
  m_rcScreen(rcScreen),
  m_rcImageArea(rcImageArea),
  m_bFirstFrame(true),
  m_dwDuration(0),
  m_bAlreadyPaintedLastFrame(false)
{
    if (m_pBitmapImage)
    {
        m_rcFinal = m_RandomNumberGen.Generate( m_pBitmapImage->ImageSize().cx, m_pBitmapImage->ImageSize().cy, rcImageArea );
        WIA_TRACE((TEXT("Image size: (%d, %d)"), m_pBitmapImage->ImageSize().cx, m_pBitmapImage->ImageSize().cy ));
        WIA_TRACE((TEXT("Chosen Final Rect = (%d,%d), (%d,%d)"), m_rcFinal.left, m_rcFinal.top, m_rcFinal.right, m_rcFinal.bottom ));
    }
}


CImagePainter::~CImagePainter(void)
{
    if (m_pBitmapImage)
    {
        delete m_pBitmapImage;
    }
    m_pBitmapImage = NULL;
}


DWORD CImagePainter::ElapsedTime(void) const
{
    DWORD dwElapsed = GetTickCount() - m_dwInitialTickCount;
    if (dwElapsed > m_dwDuration)
        dwElapsed = m_dwDuration;
    return(dwElapsed);
}


CBitmapImage *CImagePainter::BitmapImage(void)
{
    return(m_pBitmapImage);
}


void CImagePainter::Paint( CSimpleDC &PaintDC )
{
    if (PaintDC.IsValid() && m_pBitmapImage)
    {
        ScreenSaverUtil::SelectPalette( PaintDC, m_pBitmapImage->Palette(), FALSE );
        CSimpleDC MemoryDC;
        if (MemoryDC.CreateCompatibleDC(PaintDC))
        {
            ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
            Paint( PaintDC, MemoryDC );
        }
    }
}

void CImagePainter::Paint( CSimpleDC &PaintDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    BitBlt( PaintDC, m_rcFinal.left, m_rcFinal.top, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), MemoryDC, 0, 0, SRCCOPY );
}

bool CImagePainter::TimerTick( CSimpleDC &ClientDC )
{
    bool bStopPainting = false;

    if (m_bFirstFrame)
    {
        m_dwInitialTickCount = GetTickCount();
        Erase( ClientDC, m_rcScreen );
    }

    //
    if (m_bFirstFrame || NeedPainting())
    {
        if (m_pBitmapImage && ClientDC.IsValid())
        {
            ScreenSaverUtil::SelectPalette( ClientDC, m_pBitmapImage->Palette(), FALSE );
            CSimpleDC MemoryDC;
            if (MemoryDC.CreateCompatibleDC(ClientDC))
            {
                ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
                PaintFrame( ClientDC, MemoryDC );
            }
        }
        if (m_bFirstFrame)
            m_bFirstFrame = false;
    }
    else bStopPainting = true;
    return bStopPainting;
}


void CImagePainter::Erase( CSimpleDC &ClientDC, RECT &rc )
{
    FillRect( ClientDC, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH) );
}


bool CImagePainter::NeedPainting(void)
{
    return(false);
}


bool CImagePainter::IsValid(void)
{
    return(m_pBitmapImage && m_pBitmapImage->GetBitmap());
}

/****************************************************************************
CSimpleTransitionPainter
*****************************************************************************/
CSimpleTransitionPainter::CSimpleTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
}


CSimpleTransitionPainter::~CSimpleTransitionPainter(void)
{
}

void CSimpleTransitionPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    SIZE sizeImage = BitmapImage()->ImageSize();
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, sizeImage.cx, sizeImage.cy, MemoryDC, 0, 0, SRCCOPY );
}

/****************************************************************************
 CSlidingTransitionPainter
*****************************************************************************/
CSlidingTransitionPainter::CSlidingTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
    m_dwDuration = 5000;
    ZeroMemory(&m_rcPrevious,sizeof(m_rcPrevious));
    switch (CRandomNumberGen().Generate(8))
    {
    case 0:
        // left, top
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 1:
        // top
        m_rcOriginal.left = m_rcFinal.left;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = m_rcFinal.right;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 2:
        // right, top
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 3:
        // right
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = m_rcFinal.top;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = m_rcFinal.bottom;
        break;
    case 4:
        // right, bottom
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 5:
        // bottom
        m_rcOriginal.left = m_rcFinal.left;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = m_rcFinal.right;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 6:
        // left,bottom
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 7:
        // left
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = m_rcFinal.top;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = m_rcFinal.bottom;
        break;
    }
}

CSlidingTransitionPainter::~CSlidingTransitionPainter(void)
{
}

bool CSlidingTransitionPainter::NeedPainting(void)
{
    if (!memcmp( &m_rcPrevious, &m_rcFinal, sizeof(RECT)))
        return false;
    return true;
}

void CSlidingTransitionPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    SIZE sizeImage = BitmapImage()->ImageSize();
    DWORD dwElapsedTime = ElapsedTime();
    SIZE sizeDelta;
    sizeDelta.cx = m_rcFinal.left - m_rcOriginal.left;
    sizeDelta.cy = m_rcFinal.top - m_rcOriginal.top;
    SIZE sizeOffset;
    sizeOffset.cx = MulDiv(sizeDelta.cx,dwElapsedTime,m_dwDuration);
    sizeOffset.cy = MulDiv(sizeDelta.cy,dwElapsedTime,m_dwDuration);

    // Make sure we don't overshoot the final rect
    if (WiaUiUtil::Absolute(sizeOffset.cx) > WiaUiUtil::Absolute(m_rcFinal.left - m_rcOriginal.left))
        sizeOffset.cx = m_rcFinal.left - m_rcOriginal.left;
    if (WiaUiUtil::Absolute(sizeOffset.cy) > WiaUiUtil::Absolute(m_rcFinal.top - m_rcOriginal.top))
        sizeOffset.cy = m_rcFinal.top - m_rcOriginal.top;

    RECT rcCurr = m_rcOriginal;
    ScreenSaverUtil::NormalizeRect(rcCurr);
    OffsetRect( &rcCurr, sizeOffset.cx, sizeOffset.cy );
    ScreenSaverUtil::EraseDiffRect( ClientDC, m_rcPrevious, rcCurr, (HBRUSH)GetStockObject(BLACK_BRUSH) );
    BitBlt( ClientDC, rcCurr.left, rcCurr.top, sizeImage.cx, sizeImage.cy, MemoryDC, 0, 0, SRCCOPY );
    m_rcPrevious = rcCurr;
}

/****************************************************************************
 CRandomBlockPainter
*****************************************************************************/
CRandomBlockPainter::CRandomBlockPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen ),m_pBlockAddresses(NULL),m_nBlockSize(10),m_nStartIndex(0)
{
    m_dwDuration = 2000;
    SIZE sizeImage = BitmapImage()->ImageSize();
    m_sizeBlockCount.cx = WiaUiUtil::Align( sizeImage.cx, m_nBlockSize ) / m_nBlockSize;
    m_sizeBlockCount.cy = WiaUiUtil::Align( sizeImage.cy, m_nBlockSize ) / m_nBlockSize;
    m_pBlockAddresses = new int[m_sizeBlockCount.cx * m_sizeBlockCount.cy];
    if (m_pBlockAddresses)
    {
        int i;
        for (i=0;i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            m_pBlockAddresses[i] = i;
        }
        for (i=0;i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            ScreenSaverUtil::Swap( m_pBlockAddresses[i], m_pBlockAddresses[m_RandomNumberGen.Generate(i,m_sizeBlockCount.cx * m_sizeBlockCount.cy)]);
        }
    }
}


CRandomBlockPainter::~CRandomBlockPainter(void)
{
    if (m_pBlockAddresses)
        delete[] m_pBlockAddresses;
    m_pBlockAddresses = NULL;
}


bool CRandomBlockPainter::NeedPainting(void)
{
    return(m_nStartIndex < m_sizeBlockCount.cx * m_sizeBlockCount.cy);
}


bool CRandomBlockPainter::IsValid(void)
{
    return (CImagePainter::IsValid() && m_pBlockAddresses != NULL);
}

void CRandomBlockPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    if (m_pBlockAddresses)
    {
        SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
        int nDoUntilIndex = ((m_sizeBlockCount.cx * m_sizeBlockCount.cy) * ElapsedTime()) / m_dwDuration;
        for (int i=m_nStartIndex;i<nDoUntilIndex && i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            int nRow = (m_pBlockAddresses[i] / m_sizeBlockCount.cx) * m_nBlockSize;
            int nCol = (m_pBlockAddresses[i] % m_sizeBlockCount.cx) * m_nBlockSize;
            BitBlt( ClientDC, m_rcFinal.left+nCol, m_rcFinal.top+nRow, m_nBlockSize, m_nBlockSize, MemoryDC, nCol, nRow, SRCCOPY );
        }
        m_nStartIndex = nDoUntilIndex;
    }
}



/****************************************************************************
 CAlphaFadePainter
*****************************************************************************/
CAlphaFadePainter::CAlphaFadePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
    m_dwDuration = 6000;
    if (BitmapImage())
    {
        ZeroMemory(&m_bfBlendFunction,sizeof(m_bfBlendFunction));
        m_bfBlendFunction.BlendOp = AC_SRC_OVER;
        m_bfBlendFunction.SourceConstantAlpha = 0;
        m_hbmpBuffer = CreateCompatibleBitmap( ClientDC, BitmapImage()->ImageSize().cx, BitmapImage()->ImageSize().cy );
        CompatDC.CreateCompatibleDC( ClientDC );
    }
}


bool CAlphaFadePainter::IsValid(void)
{
    return (CImagePainter::IsValid() && m_hbmpBuffer != NULL && CompatDC.IsValid());
}


CAlphaFadePainter::~CAlphaFadePainter(void)
{
    if (m_hbmpBuffer)
        DeleteObject(m_hbmpBuffer);
}


bool CAlphaFadePainter::NeedPainting(void)
{
    return(m_bfBlendFunction.SourceConstantAlpha < 0xFF);
}


void CAlphaFadePainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    ScreenSaverUtil::SelectPalette( CompatDC, BitmapImage()->Palette(), FALSE );
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    HBITMAP hOldBufferBitmap = SelectBitmap( CompatDC, m_hbmpBuffer );
    DWORD dwCurrentIndex = (ElapsedTime() * 0xFF) / m_dwDuration;
    m_bfBlendFunction.SourceConstantAlpha = (BYTE)(dwCurrentIndex > 255 ? 255 : dwCurrentIndex);
    RECT rcImage;
    rcImage.left = rcImage.top = 0;
    rcImage.right = BitmapImage()->ImageSize().cx;
    rcImage.bottom = BitmapImage()->ImageSize().cy;
    FillRect( CompatDC, &rcImage, (HBRUSH)GetStockObject(BLACK_BRUSH) );
    AlphaBlend( CompatDC, 0, 0, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), MemoryDC, 0, 0, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), m_bfBlendFunction );
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), CompatDC, 0, 0, SRCCOPY );
    SelectBitmap( CompatDC, hOldBufferBitmap );
}


/****************************************************************************
 COpenCurtainPainter
*****************************************************************************/
COpenCurtainPainter::COpenCurtainPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen ), m_nCurrentWidth(0)
{
    m_dwDuration = 3000;
    m_nFinalWidth = WiaUiUtil::Align(BitmapImage()->ImageSize().cx,2)/2;
}

COpenCurtainPainter::~COpenCurtainPainter(void)
{
}

bool COpenCurtainPainter::NeedPainting(void)
{
    return (m_nCurrentWidth < m_nFinalWidth);
}

void COpenCurtainPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    m_nCurrentWidth = WiaUiUtil::MulDivNoRound( m_nFinalWidth, ElapsedTime(), m_dwDuration );
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, m_nCurrentWidth, m_rcFinal.bottom-m_rcFinal.top, MemoryDC, 0, 0, SRCCOPY );
    BitBlt( ClientDC, m_rcFinal.right-m_nCurrentWidth, m_rcFinal.top, m_nCurrentWidth, RECT_HEIGHT(m_rcFinal), MemoryDC, RECT_WIDTH(m_rcFinal)-m_nCurrentWidth, 0, SRCCOPY );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\randgen.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       RANDGEN.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Random number generator class
 *
 *******************************************************************************/
#ifndef __RANDGEN_H_INCLUDED
#define __RANDGEN_H_INCLUDED

#include <windows.h>

#ifndef RECT_WIDTH
#define RECT_WIDTH(rc) (rc.right-rc.left)
#endif

#ifndef RECT_HEIGHT
#define RECT_HEIGHT(rc) (rc.bottom-rc.top)
#endif

class CRandomNumberGen
{
private:
    long m_nOldRand;
public:
    CRandomNumberGen( long nSeed = GetTickCount() )
        : m_nOldRand(nSeed)
    {
    }
    int Generate(void)
    {
        return(((m_nOldRand = m_nOldRand * 214013L + 2531011L) >> 16) & 0x7fff);
    }
    int Generate( int nMin, int nMax )
    {
        if (nMax - nMin == 0)
            return nMin;
        return(Generate() % (nMax - nMin)) + nMin;
    }
    int Generate( int nMax )
    {
        return (Generate( 0, nMax ));
    }
    RECT Generate( int nWidth, int nHeight, const RECT &rcRange )
    {
        RECT rcReturn;
        rcReturn.left = rcRange.left + Generate( 0, RECT_WIDTH(rcRange)-nWidth );
        rcReturn.top = rcRange.top + Generate( 0, RECT_HEIGHT(rcRange)-nHeight );
        rcReturn.right = rcReturn.left + nWidth;
        rcReturn.bottom = rcReturn.top + nHeight;
        return rcReturn;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\simdc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       SIMDC.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Simple DC class.  Cleans up DCs in order to simplify code.
*
*******************************************************************************/
#ifndef __SIMDC_H_INCLUDED
#define __SIMDC_H_INCLUDED

#include <windows.h>
#include <uicommon.h>
#include "ssmprsrc.h"

extern HINSTANCE g_hInstance;

class CSimpleDC
{
public:
    // Where'd we get it from?
    enum CContextSource
    {
        FromWindowDC,
        FromClientDC,
        FromPaintDC,
        FromCompatibleDC,
        FromCreateDC,
        FromNullDC
    };

private:
    HDC            m_hDC;
    HWND           m_hWnd;
    CContextSource m_nSource;
    PAINTSTRUCT    m_PaintStruct;

    HBITMAP        m_hOriginalBitmap;
    HBRUSH         m_hOriginalBrush;
    HFONT          m_hOriginalFont;
    HPEN           m_hOriginalPen;
    HPALETTE       m_hOriginalPalette;

private:
    // No implementation
    CSimpleDC &operator=( const CSimpleDC &other );
    CSimpleDC( const CSimpleDC &other );

private:
    void SaveState(void)
    {
        if (m_hDC)
        {
            HBITMAP hTempBitmap = LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_1) );
            if (hTempBitmap)
            {
                m_hOriginalBitmap = reinterpret_cast<HBITMAP>(SelectObject(m_hDC,hTempBitmap));
                if (m_hOriginalBitmap)
                {
                    SelectObject( m_hDC, m_hOriginalBitmap );
                }
                DeleteObject(hTempBitmap);
            }
            m_hOriginalBrush = reinterpret_cast<HBRUSH>(SelectObject(m_hDC,GetStockObject(NULL_BRUSH)));
            m_hOriginalFont = reinterpret_cast<HFONT>(SelectObject(m_hDC,GetStockObject(SYSTEM_FONT)));
            m_hOriginalPen = reinterpret_cast<HPEN>(SelectObject(m_hDC,GetStockObject(NULL_PEN)));
            m_hOriginalPalette = reinterpret_cast<HPALETTE>(SelectPalette(m_hDC,reinterpret_cast<HPALETTE>(GetStockObject(DEFAULT_PALETTE)),TRUE));
        }
    }
    void RestoreState(void)
    {
        if (m_hDC)
        {
            if (m_hOriginalBitmap)
                SelectObject( m_hDC, m_hOriginalBitmap );
            if (m_hOriginalBrush)
                SelectObject( m_hDC, m_hOriginalBrush );
            if (m_hOriginalFont)
                SelectObject( m_hDC, m_hOriginalFont );
            if (m_hOriginalPen)
                SelectObject( m_hDC, m_hOriginalPen );
            if (m_hOriginalPalette)
                SelectPalette( m_hDC, m_hOriginalPalette, TRUE );
        }
    }

public:
    CSimpleDC(void)
      : m_hDC(NULL),
        m_hWnd(NULL),
        m_nSource(FromNullDC),
        m_hOriginalBitmap(NULL),
        m_hOriginalBrush(NULL),
        m_hOriginalFont(NULL),
        m_hOriginalPen(NULL),
        m_hOriginalPalette(NULL)
    {
        ::ZeroMemory(&m_PaintStruct,sizeof(m_PaintStruct));
    }
    virtual ~CSimpleDC(void)
    {
        Release();
    }
    void Release(void)
    {
        RestoreState();
        if (m_hDC)
        {
            switch (m_nSource)
            {
            case FromWindowDC:
                if (m_hDC)
                    ReleaseDC( m_hWnd, m_hDC );
                break;

            case FromClientDC:
                if (m_hDC)
                    ReleaseDC( m_hWnd, m_hDC );
                break;

            case FromPaintDC:
                if (m_hDC)
                    EndPaint( m_hWnd, &m_PaintStruct );
                break;

            case FromCompatibleDC:
                if (m_hDC)
                    DeleteDC( m_hDC );
                break;

            case FromCreateDC:
                if (m_hDC)
                    DeleteDC( m_hDC );
                break;

            case FromNullDC:
                break;
            }
        }
        ZeroMemory( &m_PaintStruct, sizeof(m_PaintStruct));
        m_hDC         = NULL;
        m_hWnd        = NULL;
        m_nSource     = FromNullDC;
    }

    bool GetWindowDC( HWND hWnd )
    {
        Release();
        if (m_hDC = ::GetWindowDC(hWnd))
        {
            m_hWnd = hWnd;
            m_nSource = FromWindowDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool GetDC( HWND hWnd )
    {
        Release();
        if (m_hDC = ::GetDC(hWnd))
        {
            m_hWnd = hWnd;
            m_nSource = FromClientDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool BeginPaint( HWND hWnd )
    {
        Release();
        m_hDC = ::BeginPaint( hWnd, &m_PaintStruct );
        if (m_hDC)
        {
            m_hWnd = hWnd;
            m_nSource = FromPaintDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateCompatibleDC( HDC hDC )
    {
        Release();
        m_hDC = ::CreateCompatibleDC( hDC );
        if (m_hDC)
        {
            m_nSource = FromCompatibleDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateDC( LPCTSTR lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData )
    {
        Release();
        m_hDC = ::CreateDC( lpszDriver, lpszDevice, lpszOutput, lpInitData );
        if (m_hDC)
        {
            m_nSource = FromCreateDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool IsValid(void) const
    {
        return (m_hDC != NULL && m_nSource != FromNullDC);
    }

    operator HDC(void)
    {
        return m_hDC;
    }
};

#endif // __SIMDC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\sources.inc ===
#
# Builds the my pictures screensaver common library, SSCOMMON.LIB
#

SYNCHRONIZE_BLOCK=1

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)

ATL_VER = 30
USE_STATIC_ATL = 1

TARGETNAME=sscommon
TARGETTYPE=LIBRARY

SOURCES=..\cfgdlg.cpp   \
        ..\findfile.cpp \
        ..\findimgs.cpp \
        ..\imagescr.cpp \
        ..\imgs.cpp     \
        ..\painters.cpp \
        ..\ssdata.cpp   \
        ..\sshndler.cpp \
        ..\extimer.cpp  \
        ..\ssutil.cpp



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\sshndler.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SSHNDLER.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __SSHNDLER_H_INCLUDED
#define __SSHNDLER_H_INCLUDED

#include <windows.h>
#include "imagescr.h"
#include "extimer.h"
#include "simstr.h"
#include "findthrd.h"

//
// We will shuffle the list every [SHUFFLE_INTERVAL] images until we are done gathering files.
//
#define SHUFFLE_INTERVAL            50

//
// To decrease the tendency to see the same image first, we will try to vary the image that
// causes the screensaver to be started to a random image index less than this number
//
#define MAX_START_IMAGE             20

//
// Number of ms to wait before starting up the screensaver timers
// in case we don't find an image before this timer runs.
//
#define BACKUP_START_TIMER_PERIOD 5000

class CScreenSaverHandler
{
private:
    CImageScreenSaver        *m_pImageScreenSaver;
    HINSTANCE                 m_hInstance;
    CSimpleString             m_strRegistryPath;
    HWND                      m_hWnd;
    UINT                      m_nPaintTimerId;
    UINT                      m_nChangeTimerId;
    UINT                      m_nBackupStartTimerId;
    UINT                      m_nBackupStartTimerPeriod;
    UINT                      m_nFindNotifyMessage;
    bool                      m_bPaused;
    CExclusiveTimer           m_Timer;
    HANDLE                    m_hFindThread;
    HANDLE                    m_hFindCancel;
    bool                      m_bScreensaverStarted;
    int                       m_nStartImage;
    int                       m_nShuffleInterval;
    CRandomNumberGen          m_Random;

private:
    // No implementation
    CScreenSaverHandler(void);
    CScreenSaverHandler( const CScreenSaverHandler & );
    CScreenSaverHandler &operator=( const CScreenSaverHandler & );

public:
    void Initialize(void);
    CScreenSaverHandler( HWND hWnd, UINT nFindNotifyMessage, UINT nPaintTimer, UINT nChangeTimer, UINT nBackupStartTimer, LPCTSTR szRegistryPath, HINSTANCE hInstance );
    ~CScreenSaverHandler(void);

    // Message handlers
    bool HandleKeyboardMessage( UINT nMessage, WPARAM nVirtkey );
    void HandleConfigChanged(void);
    void HandleTimer( WPARAM nEvent );
    void HandlePaint(void);
    void HandleFindFile( CFoundFileMessageData *pFoundFileMessageData );
};

#endif // __SSHNDLER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssdata.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSDATA.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Encapsulates reading and writing setting for this screensaver
 *               from the registry
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "ssdata.h"
#include <shlobj.h>
#include "simreg.h"
#include "ssutil.h"

// These are defined so I can build using vc5 headers
#if !defined(CSIDL_WINDOWS)
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#endif
#if !defined(CSIDL_MYPICTURES)
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#endif


CMyDocsScreenSaverData::CMyDocsScreenSaverData( HKEY hKeyRoot, const CSimpleString &strRegistryKeyName )
  : m_hKeyRoot(hKeyRoot),
    m_strRegistryKeyName(strRegistryKeyName),
    m_strImageDirectory(TEXT("")),
    m_nPaintTimerInterval(0),
    m_nChangeTimerInterval(0),
    m_bDisplayFilename(0),
    m_nMaxScreenPercent(0),
    m_bDisableTransitions(0),
    m_bAllowStretching(false),
    m_bAllowKeyboardControl(true),
    m_nMaxFailedFiles(0),
    m_nMaxSuccessfulFiles(0),
    m_nMaxDirectories(0),
    m_pszImageDirectoryValue(TEXT("ImageDirectory")),
    m_pszPaintIntervalValue(TEXT("PaintInterval")),
    m_pszChangeIntervalValue(TEXT("ChangeInterval")),
    m_pszDisplayFilename(TEXT("DisplayFilename")),
    m_pszMaxScreenPercent(TEXT("MaxScreenPercent")),
    m_pszDisableTransitions(TEXT("DisableTransitions")),
    m_pszAllowStretching(TEXT("AllowStretching")),
    m_pszAllowKeyboardControl(TEXT("AllowKeyboardControl")),
    m_pszMaxFailedFiles(TEXT("MaxFailedFiles")),
    m_pszMaxSuccessfulFiles(TEXT("MaxSuccessfulFiles")),
    m_pszMaxDirectories(TEXT("MaxDirectories"))
{
    Read();
}


CMyDocsScreenSaverData::~CMyDocsScreenSaverData(void)
{
}


void CMyDocsScreenSaverData::Read(void)
{
    CSimpleReg reg( m_hKeyRoot, m_strRegistryKeyName, false, KEY_READ );
    m_strImageDirectory = reg.Query( m_pszImageDirectoryValue, GetDefaultImageDir() );
    m_nPaintTimerInterval = reg.Query( m_pszPaintIntervalValue, nDefaultPaintInterval );
    m_nChangeTimerInterval = reg.Query( m_pszChangeIntervalValue, nDefaultChangeInterval );
    m_bDisplayFilename = (reg.Query( m_pszDisplayFilename, bDefaultDisplayFilename ) != 0);
    m_nMaxScreenPercent = reg.Query( m_pszMaxScreenPercent, nDefaultScreenPercent );
    m_bDisableTransitions = (reg.Query( m_pszDisableTransitions, bDefaultDisableTransitions ) != 0);
    m_bAllowStretching = (reg.Query( m_pszAllowStretching, bDefaultAllowStretching ) != 0);
    m_bAllowKeyboardControl = (reg.Query( m_pszAllowKeyboardControl, bDefaultAllowKeyboardControl ) != 0);
    m_nMaxFailedFiles = reg.Query( m_pszMaxFailedFiles, nDefaultMaxFailedFiles );
    m_nMaxSuccessfulFiles = reg.Query( m_pszMaxSuccessfulFiles, nDefaultMaxSuccessfulFiles );
    m_nMaxDirectories = reg.Query( m_pszMaxDirectories, nDefaultMaxDirectories );
}

void CMyDocsScreenSaverData::Write(void)
{
    CSimpleReg reg( m_hKeyRoot, m_strRegistryKeyName, true, KEY_WRITE );
    //
    // If we don't have a directory, we will delete the value to cause the default to be used instead
    //
    if (!m_strImageDirectory.Length())
    {
        reg.Delete( m_pszImageDirectoryValue );
    }
    else
    {
        reg.Set( m_pszImageDirectoryValue, m_strImageDirectory );
    }
    reg.Set( m_pszPaintIntervalValue, m_nPaintTimerInterval );
    reg.Set( m_pszChangeIntervalValue, m_nChangeTimerInterval );
    reg.Set( m_pszDisplayFilename, (DWORD)m_bDisplayFilename );
    reg.Set( m_pszMaxScreenPercent, m_nMaxScreenPercent );
    reg.Set( m_pszDisableTransitions, (DWORD)m_bDisableTransitions );
    reg.Set( m_pszAllowStretching, (DWORD)m_bAllowStretching );
    reg.Set( m_pszAllowKeyboardControl, (DWORD)m_bAllowKeyboardControl );
    reg.Set( m_pszMaxFailedFiles, m_nMaxFailedFiles );
    reg.Set( m_pszMaxSuccessfulFiles, m_nMaxSuccessfulFiles );
    reg.Set( m_pszMaxDirectories, m_nMaxDirectories );
}

CSimpleString CMyDocsScreenSaverData::ImageDirectory(void) const
{
    return(m_strImageDirectory);
}

void CMyDocsScreenSaverData::ImageDirectory( const CSimpleString &str )
{
    m_strImageDirectory = str;
}

UINT CMyDocsScreenSaverData::ChangeInterval(void) const
{
    return(m_nChangeTimerInterval);
}

void CMyDocsScreenSaverData::ChangeInterval( UINT nInterval )
{
    m_nChangeTimerInterval = nInterval;
}

UINT CMyDocsScreenSaverData::PaintInterval(void) const
{
    return(m_nPaintTimerInterval);
}

void CMyDocsScreenSaverData::PaintInterval( UINT nInterval )
{
    m_nPaintTimerInterval = nInterval;
}

bool CMyDocsScreenSaverData::DisplayFilename(void) const
{
    return(m_bDisplayFilename);
}

void CMyDocsScreenSaverData::DisplayFilename( bool bDisplayFilename )
{
    m_bDisplayFilename = bDisplayFilename;
}

int CMyDocsScreenSaverData::MaxScreenPercent(void) const
{
    return m_nMaxScreenPercent;
}

void CMyDocsScreenSaverData::MaxScreenPercent( int nMaxScreenPercent )
{
    m_nMaxScreenPercent = nMaxScreenPercent;
}

bool CMyDocsScreenSaverData::DisableTransitions(void) const
{
    return m_bDisableTransitions;
}

void CMyDocsScreenSaverData::DisableTransitions( bool bDisableTransitions )
{
    m_bDisableTransitions = bDisableTransitions;
}

bool CMyDocsScreenSaverData::AllowStretching(void) const
{
    return m_bAllowStretching;
}

void CMyDocsScreenSaverData::AllowStretching( bool bAllowStretching )
{
    m_bAllowStretching = bAllowStretching;
}


bool CMyDocsScreenSaverData::AllowKeyboardControl(void) const
{
    return m_bAllowKeyboardControl;
}

void CMyDocsScreenSaverData::AllowKeyboardControl( bool bAllowKeyboardControl )
{
    m_bAllowKeyboardControl = bAllowKeyboardControl;
}

int CMyDocsScreenSaverData::MaxFailedFiles(void) const
{
    return m_nMaxFailedFiles;
}

void CMyDocsScreenSaverData::MaxFailedFiles( int nMaxFailedFiles )
{
    m_nMaxFailedFiles = nMaxFailedFiles;
}

int CMyDocsScreenSaverData::MaxSuccessfulFiles(void) const
{
    return m_nMaxSuccessfulFiles;
}

void CMyDocsScreenSaverData::MaxSuccessfulFiles( int nMaxSuccessfulFiles )
{
    m_nMaxSuccessfulFiles = nMaxSuccessfulFiles;
}

int CMyDocsScreenSaverData::MaxDirectories(void) const
{
    return m_nMaxDirectories;
}

void CMyDocsScreenSaverData::MaxDirectories( int nMaxDirectories )
{
    m_nMaxDirectories = nMaxDirectories;
}

CSimpleString CMyDocsScreenSaverData::GetDefaultImageDir(void)
{
    CSimpleString strResult(TEXT(""));
    LPITEMIDLIST pidl;
    TCHAR szPath[MAX_PATH];
    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        hr = SHGetSpecialFolderLocation( NULL, CSIDL_MYPICTURES, &pidl );
        if (SUCCEEDED(hr))
        {
            if (SHGetPathFromIDList( pidl, szPath ))
            {
                if (lstrlen(szPath))
                    strResult = szPath;
            }
            pMalloc->Free(pidl);
        }
        if (0 == strResult.Length())
        {
            hr = SHGetSpecialFolderLocation( NULL, CSIDL_PERSONAL, &pidl );
            if (SUCCEEDED(hr))
            {
                if (SHGetPathFromIDList( pidl, szPath ))
                {
                    if (lstrlen(szPath))
                        strResult = szPath;
                }
                pMalloc->Free(pidl);
            }
        }
        if (0 == strResult.Length())
        {
            hr = SHGetSpecialFolderLocation( NULL, CSIDL_WINDOWS, &pidl );
            if (SUCCEEDED(hr))
            {
                if (SHGetPathFromIDList( pidl, szPath ))
                {
                    if (lstrlen(szPath))
                        strResult = szPath;
                }
                pMalloc->Free(pidl);
            }
        }
        pMalloc->Release();
    }
    WIA_TRACE((TEXT("CImageScreenSaver::GetDefaultDirectory: returned %s\n"),strResult.String()));
    return(strResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssmprsrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssmprsrc.rc
//
#define IDS_NO_FILES_FOUND              2
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDC_ENABLE_TRANSITIONS          1009
#define IDC_MAX_SIZE                    1010
#define IDC_IMAGE_SIZE_DESC             1011
#define IDC_ALLOW_KEYBOARDCONTROL       1012
#define IDC_ALLOWSTRETCHING             1013
#define IDC_FREQ_LESS                   1018
#define IDC_FREQ_MORE                   1019
#define IDC_SIZE_LESS                   1020
#define IDC_SIZE_MORE                   1021
#define IDC_MYPICTURES_ICON             1022
#define IDC_DIALOG_DESCRIPTION          1023
#define IDC_FREQUENCY_STATIC            1024
#define IDC_MAX_SIZE_STATIC             1025
#define IDC_DIVIDER                     1026
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDS_PERCENT                     2009
#define IDB_1                           2009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2011
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssconst.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       SSCONST.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Systemwide constants
*
*******************************************************************************/
#ifndef __SSCONST_H_INCLUDED
#define __SSCONST_H_INCLUDED

#define REGISTRY_PATH TEXT("Control Panel\\Screen Saver.Slideshow")

#endif // __SSCONST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\ssmypics\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sstest\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssutil.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSUTIL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Useful utility functions
 *
 *******************************************************************************/
#ifndef __SSUTIL_H_INCLUDED
#define __SSUTIL_H_INCLUDED

#include <windows.h>
#include <uicommon.h>

namespace ScreenSaverUtil
{
    bool SetIcons( HWND hWnd, HINSTANCE hInstance, int nResId );
    bool IsValidRect( RECT &rc );
    void EraseDiffRect( HDC hDC, const RECT &oldRect, const RECT &diffRect, HBRUSH hBrush );
    bool SelectDirectory( HWND hWnd, LPCTSTR pszPrompt, TCHAR szDirectory[] );
    HPALETTE SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground );
    void NormalizeRect( RECT &rc );

    template <class T>
    void Swap( T &a, T &b )
    {
        T temp = a;
        a = b;
        b = temp;
    }
} // Namespace

#endif //__SSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssdata.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSDATA.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Encapsulates reading and writing setting for this screensaver
 *               from the registry
 *
 *******************************************************************************/
#ifndef __SSDATA_H_INCLUDED
#define __SSDATA_H_INCLUDED

#include <windows.h>
#include "simstr.h"

class CMyDocsScreenSaverData
{
private:
    HKEY            m_hKeyRoot;
    CSimpleString   m_strRegistryKeyName;
    CSimpleString   m_strImageDirectory;
    UINT            m_nPaintTimerInterval;
    UINT            m_nChangeTimerInterval;
    bool            m_bDisplayFilename;
    int             m_nMaxScreenPercent;
    bool            m_bDisableTransitions;
    bool            m_bAllowStretching;
    bool            m_bAllowKeyboardControl;
    int             m_nMaxFailedFiles;
    int             m_nMaxSuccessfulFiles;
    int             m_nMaxDirectories;

    LPCTSTR         m_pszImageDirectoryValue;
    LPCTSTR         m_pszPaintIntervalValue;
    LPCTSTR         m_pszChangeIntervalValue;
    LPCTSTR         m_pszDisplayFilename;
    LPCTSTR         m_pszMaxScreenPercent;
    LPCTSTR         m_pszDisableTransitions;
    LPCTSTR         m_pszAllowStretching;
    LPCTSTR         m_pszAllowKeyboardControl;
    LPCTSTR         m_pszMaxFailedFiles;
    LPCTSTR         m_pszMaxSuccessfulFiles;
    LPCTSTR         m_pszMaxDirectories;

    enum
    {
        nDefaultChangeInterval       = 6000,
        nDefaultPaintInterval        = 0,
        bDefaultDisplayFilename      = 0,
        nDefaultScreenPercent        = 90,
        bDefaultDisableTransitions   = 0,
        bDefaultAllowStretching      = 0,
        bDefaultAllowKeyboardControl = 1,
        nDefaultMaxFailedFiles       = 1000,
        nDefaultMaxSuccessfulFiles   = 65536,
        nDefaultMaxDirectories       = 200
    };
    // No implementation
    CMyDocsScreenSaverData(void);
    CMyDocsScreenSaverData &operator=( const CMyDocsScreenSaverData & );
    CMyDocsScreenSaverData( const CMyDocsScreenSaverData & );
public:
    CMyDocsScreenSaverData( HKEY hKeyRoot, const CSimpleString &strRegistryKeyName );
    ~CMyDocsScreenSaverData(void);
    void Read(void);
    void Write(void);
    CSimpleString ImageDirectory(void) const;
    void ImageDirectory( const CSimpleString &str );
    UINT ChangeInterval(void) const;
    void ChangeInterval( UINT nInterval );
    UINT PaintInterval(void) const;
    void PaintInterval( UINT nInterval );
    bool DisplayFilename(void) const;
    void DisplayFilename( bool bDisplayFilename );
    int  MaxScreenPercent(void) const;
    void MaxScreenPercent( int nMaxScreenPercent );
    bool DisableTransitions(void) const;
    void DisableTransitions( bool bDisableTransitions );
    bool AllowStretching(void) const;
    void AllowStretching( bool bAllowStretching );
    bool AllowKeyboardControl(void) const;
    void AllowKeyboardControl( bool bAllowKeyboardControl );
    int  MaxFailedFiles(void) const;
    void MaxFailedFiles( int nMaxFailedFiles );
    int  MaxSuccessfulFiles(void) const;
    void MaxSuccessfulFiles( int nMaxSuccessfulFiles );
    int  MaxDirectories(void) const;
    void MaxDirectories( int nMaxDirectories );
    CSimpleString GetDefaultImageDir(void);
};


#endif // __SSDATA_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\ssutil.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSUTIL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Useful functions that are used more than once
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "ssutil.h"
#include <shlobj.h>

bool ScreenSaverUtil::SetIcons( HWND hWnd, HINSTANCE hInstance, int nResId )
{
    HICON hIconSmall = (HICON)LoadImage( hInstance, MAKEINTRESOURCE(nResId), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0 );
    HICON hIconLarge = (HICON)LoadImage( hInstance, MAKEINTRESOURCE(nResId), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0 );
    if (hIconSmall)
    {
        SendMessage( hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall );
    }
    if (hIconLarge)
    {
        SendMessage( hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIconLarge );
    }
    return(hIconSmall && hIconLarge);
}

bool ScreenSaverUtil::IsValidRect( RECT &rc )
{
    return(rc.left < rc.right && rc.top < rc.bottom);
}

void ScreenSaverUtil::NormalizeRect( RECT &rc )
{
    if (rc.left > rc.right)
        Swap(rc.left,rc.right);
    if (rc.top > rc.bottom)
        Swap(rc.top,rc.bottom);
}

void ScreenSaverUtil::EraseDiffRect( HDC hDC, const RECT &oldRect, const RECT &newRect, HBRUSH hBrush )
{
    RECT rc;

    // Top
    rc.left = oldRect.left;
    rc.top = oldRect.top;
    rc.bottom = newRect.top;
    rc.right = oldRect.right;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Left
    rc.left = oldRect.left;
    rc.top = newRect.top;
    rc.right = newRect.left;
    rc.bottom = newRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Right
    rc.left = newRect.right;
    rc.top = newRect.top;
    rc.right = oldRect.right;
    rc.bottom = newRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Bottom
    rc.left = oldRect.left;
    rc.top = newRect.bottom;
    rc.right = oldRect.right;
    rc.bottom = oldRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
}

static int CALLBACK ChangeDirectoryCallback( HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
    if (uMsg == BFFM_INITIALIZED)
    {
        SendMessage( hWnd, BFFM_SETSELECTION, 1, (LPARAM)lpData );
    }
    return 0;
}


bool ScreenSaverUtil::SelectDirectory( HWND hWnd, LPCTSTR pszPrompt, TCHAR szDirectory[] )
{
    bool bResult = false;
    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[MAX_PATH];

        BROWSEINFO BrowseInfo;
        ::ZeroMemory( &BrowseInfo, sizeof(BrowseInfo) );
        BrowseInfo.hwndOwner = hWnd;
        BrowseInfo.pszDisplayName = szDisplayName;
        BrowseInfo.lpszTitle = pszPrompt;
        BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn = ChangeDirectoryCallback;
        BrowseInfo.lParam = (LPARAM)szDirectory;
        BrowseInfo.iImage = 0;

        LPITEMIDLIST pidl = SHBrowseForFolder(&BrowseInfo);

        if (pidl != NULL)
        {
            TCHAR szResult[MAX_PATH];
            if (SHGetPathFromIDList(pidl,szResult))
            {
                lstrcpy( szDirectory, szResult );
                bResult = true;
            }
            pMalloc->Free(pidl);
        }
        pMalloc->Release();
    }
    return bResult;
}

HPALETTE ScreenSaverUtil::SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground )
{
    HPALETTE hOldPalette = NULL;
    if (hDC && hPalette)
    {
        hOldPalette = ::SelectPalette( hDC, hPalette, bForceBackground );
        RealizePalette( hDC );
        SetBrushOrgEx( hDC, 0,0, NULL );
    }
    return hOldPalette;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sscommon\sshndler.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999,2000
 *
 *  TITLE:       SSHNDLER.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "sshndler.h"
#include "ssutil.h"

CScreenSaverHandler::CScreenSaverHandler( HWND hWnd, UINT nFindNotifyMessage, UINT nPaintTimer, UINT nChangeTimer, UINT nBackupStartTimer, LPCTSTR szRegistryPath, HINSTANCE hInstance )
  : m_hWnd(hWnd),
    m_hInstance(hInstance),
    m_strRegistryPath(szRegistryPath),
    m_nFindNotifyMessage(nFindNotifyMessage),
    m_nPaintTimerId(nPaintTimer),
    m_nChangeTimerId(nChangeTimer),
    m_nBackupStartTimerId(nBackupStartTimer),
    m_nBackupStartTimerPeriod(BACKUP_START_TIMER_PERIOD),
    m_pImageScreenSaver(NULL),
    m_bPaused(false),
    m_hFindThread(NULL),
    m_hFindCancel(NULL),
    m_bScreensaverStarted(false),
    m_nStartImage(0),
    m_nShuffleInterval(SHUFFLE_INTERVAL)
{
    m_nStartImage = m_Random.Generate(MAX_START_IMAGE);
}

void CScreenSaverHandler::Initialize(void)
{
    CWaitCursor wc;

    HDC hDC = GetDC(m_hWnd);
    if (hDC)
    {
        m_pImageScreenSaver = new CImageScreenSaver( m_hInstance, m_strRegistryPath );
        if (m_pImageScreenSaver)
        {
            m_pImageScreenSaver->SetScreenRect(m_hWnd);

            if (m_pImageScreenSaver->IsValid())
            {
                m_hFindCancel = CreateEvent( NULL, TRUE, FALSE, NULL );
                if (m_hFindCancel)
                {
                    m_hFindThread = m_pImageScreenSaver->Initialize( m_hWnd, m_nFindNotifyMessage, m_hFindCancel );
                }

                SetTimer( m_hWnd, m_nBackupStartTimerId, m_nBackupStartTimerPeriod, NULL );
            }
            else
            {
                WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, m_pImageScreenSaver->IsValid() returned failed\n")));
                delete m_pImageScreenSaver;
                m_pImageScreenSaver = NULL;
            }
        }
        else
        {
            WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, unable to create m_pImageScreenSaver\n")));
        }
        ReleaseDC( m_hWnd, hDC );
    }
    else
    {
        WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, GetDC failed\n")));
    }
}


CScreenSaverHandler::~CScreenSaverHandler(void)
{
    if (m_pImageScreenSaver)
    {
        delete m_pImageScreenSaver;
        m_pImageScreenSaver = NULL;
    }
    if (m_hFindCancel)
    {
        SetEvent(m_hFindCancel);
        CloseHandle(m_hFindCancel);
        m_hFindCancel = NULL;
    }
    if (m_hFindThread)
    {
        WaitForSingleObject( m_hFindThread, INFINITE );
        CloseHandle(m_hFindThread);
        m_hFindThread = NULL;
    }
}


bool CScreenSaverHandler::HandleKeyboardMessage( UINT nMessage, WPARAM nVirtkey )
{
    if (m_pImageScreenSaver && m_pImageScreenSaver->AllowKeyboardControl())
    {
        if (nMessage == WM_KEYDOWN)
        {
            switch (nVirtkey)
            {
            case VK_DOWN:
                if (nMessage == WM_KEYDOWN)
                {
                    m_bPaused = !m_bPaused;
                    if (!m_bPaused)
                    {
                        if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,false))
                            m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                    }
                }
                return true;

            case VK_LEFT:
                if (nMessage == WM_KEYDOWN)
                {
                    if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(false,true))
                        m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                }
                return true;

            case VK_RIGHT:
                if (nMessage == WM_KEYDOWN)
                {
                    if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,true))
                        m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                }
                return true;
            }
        }
    }
    return false;
}


void CScreenSaverHandler::HandleConfigChanged(void)
{
    if (m_pImageScreenSaver)
    {
        m_pImageScreenSaver->SetScreenRect(m_hWnd);
        m_pImageScreenSaver->ReadConfigData();
    }
}


void CScreenSaverHandler::HandleTimer( WPARAM nEvent )
{
    if (nEvent == m_nPaintTimerId)
    {
        if (m_pImageScreenSaver)
        {
            CSimpleDC ClientDC;
            if (ClientDC.GetDC(m_hWnd))
            {
                bool bResult = m_pImageScreenSaver->TimerTick( ClientDC );
                if (bResult)
                {
                    m_Timer.Set( m_hWnd, m_nChangeTimerId, m_pImageScreenSaver->ChangeTimerInterval() );
                }
            }
        }
    }
    else if (nEvent == m_nChangeTimerId)
    {
        m_Timer.Kill();
        if (!m_bPaused && m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,false))
        {
            m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
            
            //
            // Mark that we've been started
            //
            if (!m_bScreensaverStarted)
            {
                m_bScreensaverStarted = true;
            }
        }
    }
    else if (nEvent == m_nBackupStartTimerId)
    {
        //
        // Make sure we don't get any more of these
        //
        KillTimer( m_hWnd, m_nBackupStartTimerId );

        //
        // If the screensaver hasn't started, start it.
        //
        if (!m_bScreensaverStarted)
        {
            //
            // Shuffle the list
            //
            m_pImageScreenSaver->ResetFileQueue();

            //
            // If we haven't gotten any images, start the timer so we can display the error message
            //
            SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
        }
    }
}


void CScreenSaverHandler::HandlePaint(void)
{
    if (m_pImageScreenSaver)
    {
        CSimpleDC PaintDC;
        if (PaintDC.BeginPaint(m_hWnd))
        {
            m_pImageScreenSaver->Paint( PaintDC );
        }
    }
}

void CScreenSaverHandler::HandleFindFile( CFoundFileMessageData *pFoundFileMessageData )
{
    WIA_PUSHFUNCTION(TEXT("CScreenSaverHandler::HandleFindFile"));
    //
    // Make sure we have a screensaver object
    //
    if (m_pImageScreenSaver)
    {
        //
        // If this is a found file message
        //
        if (pFoundFileMessageData)
        {
            //
            // Add it to the list, and check for cancel
            //
            bool bResult = m_pImageScreenSaver->FoundFile( pFoundFileMessageData->Name() );

            //
            // If the find operation was cancelled, set the cancel event
            //
            if (!bResult)
            {
                SetEvent( m_hFindCancel );
            }

            //
            // If this is the image on which we should start, start up the screensaver pump
            //
            if (!m_bScreensaverStarted && m_pImageScreenSaver->Count() && m_nStartImage+1 == m_pImageScreenSaver->Count())
            {
                WIA_TRACE((TEXT("Starting after image %d was found"), m_nStartImage ));

                //
                // Shuffle the images
                //
                m_pImageScreenSaver->ResetFileQueue();

                //
                // If this is our first image, start things up
                //
                SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
            }

            //
            // If we have some images, and the shuffle count interval has been reached, shuffle the images
            //
            if (m_pImageScreenSaver->Count() && (m_pImageScreenSaver->Count() % m_nShuffleInterval) == 0)
            {
                WIA_TRACE((TEXT("Shuffling the image list at %d images"), m_pImageScreenSaver->Count() ));
                //
                // Shuffle the images
                //
                m_pImageScreenSaver->ResetFileQueue();
            }
            delete pFoundFileMessageData;
        }
        else
        {
            //
            // Last message
            //
            m_pImageScreenSaver->ResetFileQueue();

            //
            // If we haven't gotten any images, start the timer so we can display the error message
            //
            if (!m_bScreensaverStarted)
            {
                SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\ssmypics\ssmypics.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SSMYPICS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Main screen saver wndproc
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <uicommon.h>
#include <commctrl.h>
#include <scrnsave.h>
#include <initguid.h>
#include <gdiplus.h>
#include "resource.h"
#include "imagescr.h"
#include "ssdata.h"
#include "simcrack.h"
#include "waitcurs.h"
#include "ssutil.h"
#include "ssconst.h"
#include "sshndler.h"
#include "findthrd.h"

#define ID_PAINTTIMER   1
#define ID_CHANGETIMER  2
#define ID_STARTTIMER   3
#define UWM_FINDFILE    (WM_USER+1301)

HINSTANCE g_hInstance = NULL;

LRESULT WINAPI ScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CScreenSaverHandler *pScreenSaverHandler = (CScreenSaverHandler*)GetWindowLongPtr(hWnd,GWLP_USERDATA);
    switch (uMsg)
    {
    case WM_CREATE:
        if (FAILED(CoInitialize(NULL)))
            return -1;
        g_hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        SetErrorMode(SEM_FAILCRITICALERRORS);
        break;

    case WM_ERASEBKGND:
        if (!pScreenSaverHandler)
        {
            pScreenSaverHandler = new CScreenSaverHandler( hWnd, UWM_FINDFILE, ID_PAINTTIMER, ID_CHANGETIMER, ID_STARTTIMER, REGISTRY_PATH, g_hInstance );
            if (pScreenSaverHandler)
                pScreenSaverHandler->Initialize();
        }
        SetWindowLongPtr( hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pScreenSaverHandler) );
        break;

    case WM_TIMER:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandleTimer(wParam);
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (pScreenSaverHandler)
            if (pScreenSaverHandler->HandleKeyboardMessage( uMsg, wParam ))
                return 0;
        break;

    case WM_PAINT:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandlePaint();
        break;

    case UWM_FINDFILE:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandleFindFile( reinterpret_cast<CFoundFileMessageData*>(lParam) );
        break;

    case WM_DESTROY:
        if (pScreenSaverHandler)
            delete pScreenSaverHandler;
        CoUninitialize();
        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)0 );
        break;
    }
    return (DefScreenSaverProc(hWnd, uMsg, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\ssmypics\sources.inc ===
SYNCHRONIZE_DRAIN=1

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED  = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

MAJORCOMP=imagein
MINORCOMP=ssmypics

TARGETNAME=ssmypics
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
TARGETLIBS=

ATL_VER = 30
USE_STATIC_ATL = 1

UMTYPE=windows
UMAPPL=ssmypics
UMAPPLEXT=.scr
UMLIBS=$(O)\ssmypics.res

INCLUDES=$(INCLUDES)                          \
         $(PROJECT_ROOT)\ui\ssmypics\sscommon;

LINKLIBS=\
        $(SDK_LIB_PATH)\$(SCRNSAVE_LIB_NAME).lib       \
        $(SDK_LIB_PATH)\shell32.lib                    \
        $(SDK_LIB_PATH)\msimg32.lib                    \
        $(SDK_LIB_PATH)\oleaut32.lib                   \
        $(SDK_LIB_PATH)\ole32.lib                      \
        $(SDK_LIB_PATH)\uuid.lib                       \
        $(SDK_LIB_PATH)\gdiplus.lib                    \
        $(SDK_LIB_PATH)\shlwapi.lib                    \
        $(SDK_LIB_PATH)\comctl32.lib                   \
        $(SDK_LIB_DEST)\$(PLATFORM_SUFFIX)\*\wiaguid.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib        \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\uicommon.lib   \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\sscommon.lib

SOURCES=\
        ..\ssmypics.cpp \
        ..\ssmypics.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SXS_ASSEMBLY_NAME=Microsoft.Windows.PrintingAndImaging.ssmypics
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=ssmypics.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\ssmypics\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssmypics.rc
//
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2007
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sstest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sstest.rc
//
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2007
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sstest\sources.inc ===
!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED  = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

MAJORCOMP=imagein
MINORCOMP=ssmypics

TARGETNAME=sstest
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
TARGETLIBS=

ATL_VER = 30
USE_STATIC_ATL = 1

# These are needed for gdi+
C_DEFINES=$(C_DEFINES) -DUSE_NEW_APIS -DUSE_NEW_APIS2 -DUSE_NEW_APIS3

UMTYPE=windows
UMAPPL=sstest
UMAPPLEXT=.exe
UMENTRY=winmain
UMLIBS=$(O)\sstest.res

USE_MSVCRT=1

INCLUDES=\
        $(INCLUDES) \
        $(PROJECT_ROOT)\ui\ssmypics\sscommon;

LINKLIBS=\
        $(SDK_LIB_PATH)\shell32.lib                    \
        $(SDK_LIB_PATH)\msimg32.lib                    \
        $(SDK_LIB_PATH)\oleaut32.lib                   \
        $(SDK_LIB_PATH)\ole32.lib                      \
        $(SDK_LIB_PATH)\uuid.lib                       \
        $(SDK_LIB_PATH)\gdiplus.lib                    \
        $(SDK_LIB_PATH)\shlwapi.lib                    \
        $(SDK_LIB_PATH)\comctl32.lib                   \
        $(SDK_LIB_DEST)\$(PLATFORM_SUFFIX)\*\wiaguid.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\$(O)\psutil.lib        \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\uicommon.lib   \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\sscommon.lib

SOURCES=\
        ..\sstest.cpp \
        ..\sstest.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\ssmypics\sstest\sstest.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SSTEST.CPP
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Test driver for My Pictures Screensaver
*
*******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <uicommon.h>
#include <initguid.h>
#include <gdiplus.h>
#include "cfgdlg.h"
#include "imagescr.h"
#include "simcrack.h"
#include "scrnsave.h"
#include "ssconst.h"
#include "resource.h"
#include "sshndler.h"
#include "ssmprsrc.h"
#include "findthrd.h"

#define MAIN_WINDOW_CLASSNAME      TEXT("TestScreenSaverWindow")

#define ID_PAINTTIMER              1
#define ID_CHANGETIMER             2
#define ID_STARTTIMER              3
#define UWM_FINDFILE               (WM_USER+1301)

HINSTANCE g_hInstance;

class CMainWindow
{
private:
    HWND m_hWnd;
    CScreenSaverHandler *m_pScreenSaverHandler;
public:
    CMainWindow( HWND hWnd )
        : m_hWnd(hWnd),m_pScreenSaverHandler(NULL)
    {
    }
    virtual ~CMainWindow(void)
    {
    }
    static HWND Create( DWORD dwExStyle, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance )
    {
        RegisterClass( hInstance );
        return CreateWindowEx( dwExStyle, MAIN_WINDOW_CLASSNAME, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, NULL );
    }
    static bool RegisterClass( HINSTANCE hInstance )
    {
        WNDCLASSEX wcex;
        ZeroMemory( &wcex, sizeof(wcex) );
        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_DBLCLKS;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInstance;
        wcex.hIcon = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hIconSm = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wcex.lpszClassName = MAIN_WINDOW_CLASSNAME;
        BOOL res = (::RegisterClassEx(&wcex) != 0);
        return (res != 0);
    }
    LRESULT OnDestroy( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            delete m_pScreenSaverHandler;
        m_pScreenSaverHandler = NULL;
        PostQuitMessage(0);
        return 0;
    }

    LRESULT OnTimer( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleTimer(wParam);
        return 0;
    }


    LRESULT OnPaint( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandlePaint();
        return 0;
    }

    LRESULT OnShowWindow( WPARAM, LPARAM )
    {
        if (!m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler = new CScreenSaverHandler( m_hWnd, UWM_FINDFILE, ID_PAINTTIMER, ID_CHANGETIMER, ID_STARTTIMER, REGISTRY_PATH, g_hInstance );
            if (m_pScreenSaverHandler)
                m_pScreenSaverHandler->Initialize();
        }
        return 0;
    }

    LRESULT OnLButtonDblClk( WPARAM, LPARAM )
    {
        RegisterDialogClasses(g_hInstance);
        DialogBox( g_hInstance, MAKEINTRESOURCE(IDD_CONFIG_DIALOG), m_hWnd, ScreenSaverConfigureDialog );
        return 0;
    }

    LRESULT OnConfigChanged( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleConfigChanged();
        return 0;
    }

    LRESULT OnSize( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleConfigChanged();
        return 0;
    }

    LRESULT OnKeydown( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYDOWN, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnKeyup( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYUP, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnChar( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_CHAR, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnFindFile( WPARAM wParam, LPARAM lParam )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleFindFile( reinterpret_cast<CFoundFileMessageData*>(lParam) );
        return 0;
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CMainWindow)
        {
            SC_HANDLE_MESSAGE( WM_SHOWWINDOW, OnShowWindow );
            SC_HANDLE_MESSAGE( WM_DESTROY, OnDestroy );
            SC_HANDLE_MESSAGE( WM_TIMER, OnTimer );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_KEYDOWN, OnKeydown );
            SC_HANDLE_MESSAGE( WM_KEYUP, OnKeyup );
            SC_HANDLE_MESSAGE( WM_CHAR, OnChar );
            SC_HANDLE_MESSAGE( WM_LBUTTONDBLCLK, OnLButtonDblClk );
            SC_HANDLE_MESSAGE( UWM_CONFIG_CHANGED, OnConfigChanged );
            SC_HANDLE_MESSAGE( UWM_FINDFILE, OnFindFile );
        }
        SC_END_MESSAGE_HANDLERS();
    }
};


int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        g_hInstance = hInstance;

        HWND hwndMain = CMainWindow::Create( 0, TEXT("My Pictures Screen Saver Test"), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance );
        if (hwndMain)
        {
            ShowWindow( hwndMain, nCmdShow );
            UpdateWindow( hwndMain );

            MSG msg;
            while (GetMessage(&msg, 0, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CoUninitialize();
    }
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\bkthread.h ===
#ifndef __BKTHREAD_H_INCLUDED
#define __BKTHREAD_H_INCLUDED

#include "tspqueue.h"
#include "modlock.h"

// Base class for all messages
class CThreadMessage
{
private:
    int m_nMessage;

private:
    //
    // No implementation
    //
    CThreadMessage(void);
    CThreadMessage( const CThreadMessage & );
    CThreadMessage &operator=( const CThreadMessage & );
public:
    CThreadMessage( int nMessage )
      : m_nMessage(nMessage)
    {
    }

    virtual ~CThreadMessage(void)
    {
    }

    int Message(void) const
    {
        return(m_nMessage);
    }
    int Message( int nMessage )
    {
        return(m_nMessage = nMessage);
    }
};

typedef CThreadSafePriorityQueue<CThreadMessage> CThreadMessageQueue;

class CNotifyThreadMessage : public CThreadMessage
{
private:
    //
    // No implementation
    //
    CNotifyThreadMessage(void);
    CNotifyThreadMessage( const CNotifyThreadMessage & );
    CNotifyThreadMessage &operator=( const CNotifyThreadMessage & );

private:
    HWND m_hWndNotify;

public:
    CNotifyThreadMessage( int nMessage, HWND hWndNotify )
      : CThreadMessage(nMessage),
    m_hWndNotify(hWndNotify)
    {
    }
    virtual ~CNotifyThreadMessage(void)
    {
        m_hWndNotify = NULL;
    }
    HWND NotifyWindow(void) const
    {
        return(m_hWndNotify);
    }
};

typedef BOOL (WINAPI *ThreadMessageHandler)( CThreadMessage *pMsg );

struct CThreadMessageMap
{
    int nMessage;
    ThreadMessageHandler pfnHandler;
};

class CBackgroundThread
{
private:
    HANDLE               m_hThread;
    DWORD                m_dwThreadId;
    CThreadMessageQueue *m_pMessageQueue;
    CThreadMessageMap   *m_pThreadMessageMap;
    CSimpleEvent         m_CancelEvent;
    HINSTANCE            m_hInstanceUnlock;

private:
    //
    // No implementation
    //
    CBackgroundThread(void);
    CBackgroundThread &operator=( const CBackgroundThread & );
    CBackgroundThread( const CBackgroundThread & );

private:
    //
    // Private constructor.  This is the only constructor.  It is only called from Create.
    //
    CBackgroundThread( CThreadMessageQueue *pMessageQueue, CThreadMessageMap *pThreadMessageMap, HANDLE hCancelEvent )
      : m_pMessageQueue(pMessageQueue),
        m_pThreadMessageMap(pThreadMessageMap),
        m_CancelEvent(hCancelEvent),
        m_hInstanceUnlock(NULL)
    {
    }

    bool HandleMessage( CThreadMessage *pMsg )
    {
        for (int i=0;pMsg && m_pThreadMessageMap && m_pThreadMessageMap[i].nMessage;i++)
        {
            if (m_pThreadMessageMap[i].nMessage == pMsg->Message())
            {
                //
                // reset the cancel event
                //
                m_CancelEvent.Reset();
                return (m_pThreadMessageMap[i].pfnHandler(pMsg) != FALSE);
            }
        }
        return(true);
    }

    HRESULT Run()
    {
        //
        // Make sure we got a good message queue
        //
        if (!m_pMessageQueue)
        {
            return E_POINTER;
        }

        //
        // Make sure the event handle is good
        //
        if (!m_pMessageQueue->QueueEvent())
        {
            return E_INVALIDARG;
        }

        //
        // Make sure we have a message queue
        //
        PostThreadMessage( GetCurrentThreadId(), WM_NULL, 0, 0 );

        //
        // Initialize COM on this thread.  As a single threaded apartment.
        //
        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            //
            // We will loop until we get a WM_QUIT message
            //
            while (true)
            {
                //
                // Wait for a message to be place in the priority queue, or a message to be placed in the thread's queue
                //
                HANDLE Handles[1] = {m_pMessageQueue->QueueEvent()};
                DWORD dwRes = MsgWaitForMultipleObjects(1,Handles,FALSE,INFINITE,QS_ALLINPUT|QS_ALLPOSTMESSAGE);

                //
                // If the event is signalled, there is a message in the queue
                //
                if (WAIT_OBJECT_0==dwRes)
                {
                    //
                    // Pull the message out of the queue
                    //
                    CThreadMessage *pMsg = m_pMessageQueue->Dequeue();
                    if (pMsg)
                    {
                        //
                        // Call the message handler.
                        //
                        BOOL bResult = HandleMessage(pMsg);
                        
                        //
                        // Delete the message
                        //
                        delete pMsg;

                        //
                        // If the handler returns false, exit the thread.
                        //
                        if (!bResult)
                        {
                            break;
                        }
                    }
                }
                else if (WAIT_OBJECT_0+1==dwRes)
                {
                    //
                    // pull all of the messages out of the queue and process them
                    //
                    MSG msg;
                    while (PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
                    {
                        //
                        // Break out of the loop
                        //
                        if (msg.message == WM_QUIT)
                        {
                            break;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            //
            // Shut down COM
            //
            CoUninitialize();
        }

        return(hr);
    }

    static DWORD ThreadProc(PVOID pData)
    {
        HRESULT hr = E_FAIL;
        HINSTANCE hInstUnlock = NULL;
        CBackgroundThread *pThread = (CBackgroundThread *)pData;
        if (pData)
        {
            hr = pThread->Run();
            hInstUnlock = pThread->m_hInstanceUnlock;
            delete pThread;
        }
        if (hInstUnlock)
        {
            FreeLibraryAndExitThread( hInstUnlock, static_cast<DWORD>(hr) );
        }
        else
        {
            ExitThread( static_cast<DWORD>(hr) );
        }
    }
public:
    ~CBackgroundThread(void)
    {
        //
        // Delete the thread handle
        //
        if (m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = 0;
        }

        //
        // Nuke the message queue
        //
        delete m_pMessageQueue;
    }
    static HANDLE Create( CThreadMessageQueue *pMessageQueue, CThreadMessageMap *pThreadMessageMap, HANDLE hCancelEvent, HINSTANCE hInstLock )
    {
        //
        // Make sure we have valid arguments
        //
        if (!pMessageQueue || !pThreadMessageMap)
        {
            WIA_ERROR((TEXT("!pMessageQueue || !pThreadMessageMap")));
            return NULL;
        }
        
        //
        // The duplicated handle we will be returning
        //
        HANDLE hReturnHandle = NULL;

        //
        // Create the thread class
        //
        CBackgroundThread *pThread = new CBackgroundThread( pMessageQueue, pThreadMessageMap, hCancelEvent );
        if (pThread)
        {
            //
            // Lock up before we create the thread
            //
            HINSTANCE hInstanceUnlock = NULL;
            if (hInstLock)
            {
                //
                // Get the module name
                //
                TCHAR szModule[MAX_PATH];
                if (GetModuleFileName( hInstLock, szModule, ARRAYSIZE(szModule)))
                {
                    //
                    // Increment the reference count
                    //
                    pThread->m_hInstanceUnlock = LoadLibrary( szModule );
                }
            }


            pThread->m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, pThread, 0, &pThread->m_dwThreadId );
            if (pThread->m_hThread)
            {
                //
                // Copy the handle to return to the caller
                //
                DuplicateHandle( GetCurrentProcess(), pThread->m_hThread, GetCurrentProcess(), &hReturnHandle, 0, FALSE, DUPLICATE_SAME_ACCESS );
            }
            else
            {
                //
                // Unlock the module
                //
                if (pThread->m_hInstanceUnlock)
                {
                    FreeLibrary( hInstanceUnlock );
                    hInstanceUnlock;
                }

                //
                // Since we can't start the thread, we have to delete the thread info to prevent a leak
                //
                delete pThread;

                WIA_ERROR((TEXT("CreateThread failed")));
            }
        }
        else
        {
            //
            // Since the background thread isn't going to free it, we have to.
            //
            delete pMessageQueue;

            WIA_ERROR((TEXT("new CBackgroundThread failed")));
        }

        return hReturnHandle;
    }
};

#endif //__BKTHREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\citemlst.h ===
#ifndef __CITEMLST_H_INCLUDED
#define __CITEMLST_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "uicommon.h"
#include "simevent.h"

class CCameraItem
{
public:
    enum CDeleteState
    {
        Delete_Visible,
        Delete_Pending,
        Delete_Deleted
    };

private:
    CSimpleString           m_strPreviewFileName;
    CComPtr<IWiaItem>       m_pIWiaItem;
    CSimpleStringWide       m_strwFullItemName;
    CCameraItem            *m_pNext;
    CCameraItem            *m_pChildren;
    CCameraItem            *m_pParent;
    int                     m_nImageListIndex;
    int                     m_nCurrentPreviewPercentage;
    DWORD                   m_dwGlobalInterfaceTableCookie;
    CSimpleEvent            m_CancelQueueEvent;
    CDeleteState            m_DeleteState;
    LONG                    m_nItemType;
    LONG                    m_nItemRights;

private:
    //
    // No implementation
    //
    CCameraItem(void);
    CCameraItem(const CCameraItem &);
    CCameraItem &operator=( const CCameraItem & );

public:
    explicit CCameraItem( IWiaItem *pIWiaItem )
      : m_pIWiaItem(pIWiaItem),
        m_pNext(NULL),
        m_pChildren(NULL),
        m_pParent(NULL),
        m_nImageListIndex(-1),
        m_nCurrentPreviewPercentage(0),
        m_dwGlobalInterfaceTableCookie(0),
        m_CancelQueueEvent(true),
        m_DeleteState(Delete_Visible),
        m_nItemType(0),
        m_nItemRights(0)
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItem::CCameraItem"));

        AddItemToGlobalInterfaceTable();
        WIA_TRACE((TEXT("Created CCameraItem(0x%08X)"),m_pIWiaItem.p));

        PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPA_FULL_ITEM_NAME, m_strwFullItemName );

        PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPA_ACCESS_RIGHTS, m_nItemRights );

    }

    HRESULT AddItemToGlobalInterfaceTable(void)
    {
        HRESULT hr = E_FAIL;
        if (Item())
        {
            CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
            hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   (void **)&pGlobalInterfaceTable);
            if (SUCCEEDED(hr))
            {
                hr = pGlobalInterfaceTable->RegisterInterfaceInGlobal( Item(), IID_IWiaItem, &m_dwGlobalInterfaceTableCookie );
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
        }
        return (hr);
    }

    HRESULT RemoveItemFromGlobalInterfaceTable(void)
    {
        HRESULT hr = E_FAIL;
        if (Item())
        {
            CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
            hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   (void **)&pGlobalInterfaceTable);
            if (SUCCEEDED(hr))
            {
                hr = pGlobalInterfaceTable->RevokeInterfaceFromGlobal( m_dwGlobalInterfaceTableCookie );
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
        }
        return (hr);
    }
    DWORD GlobalInterfaceTableCookie(void) const
    {
        return m_dwGlobalInterfaceTableCookie;
    }
    ~CCameraItem(void)
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItem::~CCameraItem"));
        WIA_TRACE((TEXT("Destroyed CCameraItem(0x%08X)"),m_pIWiaItem.p));
        RemoveItemFromGlobalInterfaceTable();
        m_pIWiaItem.Release();
        if (m_strPreviewFileName.Length())
        {
            DeleteFile( m_strPreviewFileName.String() );
            m_strPreviewFileName = TEXT("");
        }
        m_pNext = m_pChildren = m_pParent = NULL;
        m_nImageListIndex = 0;
        m_CancelQueueEvent.Signal();
        m_CancelQueueEvent.Close();
    }
    IWiaItem *Item(void)
    {
        return(m_pIWiaItem);
    }
    const IWiaItem *Item(void) const
    {
        return(m_pIWiaItem.p);
    }
    IWiaItem *Item(IWiaItem *pIWiaItem)
    {
        return(m_pIWiaItem = pIWiaItem);
    }

    CDeleteState DeleteState(void) const
    {
        return m_DeleteState;
    }
    void DeleteState( CDeleteState DeleteState )
    {
        m_DeleteState = DeleteState;
    }

    int CurrentPreviewPercentage(void) const
    {
        return m_nCurrentPreviewPercentage;
    }
    int CurrentPreviewPercentage( int nCurrentPreviewPercentage )
    {
        return (m_nCurrentPreviewPercentage = nCurrentPreviewPercentage);
    }

    bool CreateCancelEvent(void)
    {
        m_nCurrentPreviewPercentage = 0;
        return m_CancelQueueEvent.Create();
    }
    bool CloseCancelEvent(void)
    {
        m_nCurrentPreviewPercentage = 0;
        return m_CancelQueueEvent.Close();
    }
    void SetCancelEvent(void)
    {
        m_CancelQueueEvent.Signal();
    }
    void ResetCancelEvent(void)
    {
        m_CancelQueueEvent.Reset();
    }
    CSimpleEvent &CancelQueueEvent(void)
    {
        return m_CancelQueueEvent;
    }

    bool PreviewRequestPending(void) const
    {
        return (m_CancelQueueEvent.Event() != NULL);
    }

    CSimpleString PreviewFileName(void) const
    {
        return m_strPreviewFileName;
    }
    const CSimpleString &PreviewFileName( const CSimpleString &strPreviewFileName )
    {
        return (m_strPreviewFileName = strPreviewFileName);
    }

    int ImageListIndex(void) const
    {
        return(m_nImageListIndex);
    }

    int ImageListIndex( int nImageListIndex )
    {
        return (m_nImageListIndex = nImageListIndex);
    }

    LONG ItemType(void)
    {
        if (!Item())
        {
            return 0;
        }
        if (!m_nItemType)
        {
            Item()->GetItemType(&m_nItemType);
        }
        return m_nItemType;
    }

    LONG ItemRights() const
    {
        return m_nItemRights;
    }

    bool IsFolder(void)
    {
        return ((ItemType() & WiaItemTypeFolder) != 0);
    }

    bool IsImage(void)
    {
        return ((ItemType() & WiaItemTypeImage) != 0);
    }

    CSimpleStringWide FullItemName(void) const
    {
        return m_strwFullItemName;
    }

    bool operator==( const CCameraItem &other )
    {
        return(Item() == other.Item());
    }

    const CCameraItem *Next(void) const
    {
        return(m_pNext);
    }
    CCameraItem *Next(void)
    {
        return(m_pNext);
    }
    CCameraItem *Next( CCameraItem *pNext )
    {
        return(m_pNext = pNext);
    }

    const CCameraItem *Children(void) const
    {
        return(m_pChildren);
    }
    CCameraItem *Children(void)
    {
        return(m_pChildren);
    }
    CCameraItem *Children( CCameraItem *pChildren )
    {
        return(m_pChildren = pChildren);
    }

    const CCameraItem *Parent(void) const
    {
        return(m_pParent);
    }
    CCameraItem *Parent(void)
    {
        return(m_pParent);
    }
    CCameraItem *Parent( CCameraItem *pParent )
    {
        return(m_pParent = pParent);
    }
};

class CCameraItemList
{
private:
    CCameraItem *m_pRoot;
public:
    CCameraItemList(void)
    : m_pRoot(NULL)
    {
    }
    ~CCameraItemList(void)
    {
        Destroy(m_pRoot);
        m_pRoot = NULL;
    }
    void Destroy( CCameraItem *pRoot )
    {
        while (pRoot)
        {
            Destroy(pRoot->Children());
            CCameraItem *pCurr = pRoot;
            pRoot = pRoot->Next();
            delete pCurr;
        }
    }
    const CCameraItem *Root(void) const
    {
        return(m_pRoot);
    }
    CCameraItem *Root(void)
    {
        return(m_pRoot);
    }
    CCameraItem *Root( CCameraItem *pRoot )
    {
        return(m_pRoot = pRoot);
    }
    static CCameraItem *Find( CCameraItem *pRoot, const CCameraItem *pNode )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (*pCurr == *pNode)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), pNode );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( CCameraItem *pNode )
    {
        return(Find( m_pRoot, pNode ));
    }
    static CCameraItem *Find( CCameraItem *pRoot, IWiaItem *pItem )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (pCurr->Item() == pItem)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), pItem );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( IWiaItem *pItem )
    {
        return(Find( m_pRoot, pItem ));
    }
    static CCameraItem *Find( CCameraItem *pRoot, DWORD dwGlobalInterfaceTableCookie )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (pCurr->GlobalInterfaceTableCookie() == dwGlobalInterfaceTableCookie)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), dwGlobalInterfaceTableCookie );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( DWORD dwGlobalInterfaceTableCookie )
    {
        return(Find( m_pRoot, dwGlobalInterfaceTableCookie ));
    }
    CCameraItem *Find( CCameraItem *pRoot, const CSimpleBStr &bstrFullItemName )
    {
        CSimpleStringWide strwTemp;

        for (CCameraItem *pCurr = pRoot;pCurr && bstrFullItemName.BString();pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                strwTemp = pCurr->FullItemName();

                if (wcscmp(strwTemp, bstrFullItemName) == 0)
                {
                    return pCurr;
                }
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), bstrFullItemName );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return NULL;
    }
    CCameraItem *Find( const CSimpleBStr &bstrFullItemName )
    {
        return Find( m_pRoot, bstrFullItemName );
    }
    void Add( CCameraItem *pParent, CCameraItem *pNewCameraItemNode )
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItemList::Add"));
        WIA_TRACE((TEXT("Root(): 0x%08X"), Root()));
        if (pNewCameraItemNode)
        {
            if (!Root())
            {
                Root(pNewCameraItemNode);
                pNewCameraItemNode->Parent(NULL);
                pNewCameraItemNode->Children(NULL);
                pNewCameraItemNode->Next(NULL);
            }
            else
            {
                if (!pParent)
                {
                    CCameraItem *pCurr=Root();
                    while (pCurr && pCurr->Next())
                    {
                        pCurr=pCurr->Next();
                    }
                    if (pCurr)
                    {
                        pCurr->Next(pNewCameraItemNode);
                    }
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(NULL);
                }
                else if (!pParent->Children())
                {
                    pParent->Children(pNewCameraItemNode);
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(pParent);
                }
                else
                {
                    CCameraItem *pCurr=pParent->Children();
                    while (pCurr && pCurr->Next())
                    {
                        pCurr=pCurr->Next();
                    }
                    if (pCurr)
                    {
                        pCurr->Next(pNewCameraItemNode);
                    }
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(pParent);
                }
            }
        }
    }
};

#endif //__CITEMLST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\32bitdib.cpp ===
// 32BitDibWrapper.cpp: implementation of the C32BitDibWrapper class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma hdrstop

#include "32BitDib.h"

// helper functions

// sum of RGB vals
inline ULONG Intensity(ULONG value)
{
    return(value&0xff)+((value&0xff00)>>8)+((value&0xff0000)>>16);
}


// we should make a Difference Template to clean up this code

inline UCHAR Difference(UCHAR a, UCHAR b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline ULONG Difference(ULONG a, ULONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline LONG Difference(LONG a, LONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

int inline MAX(int a, int b)
{
    if (a>b) return(a);
    return(b);
}

int inline MIN(int a, int b)
{
    if (a<b) return(a);
    return(b);
}

// shadows are gray... if you aint gray... you aint a shadow
// this function hasn't yet been optimized
inline ULONG DifferenceFromGray(ULONG value)
{
    UCHAR g,b;//,r;
//  r=(UCHAR)(value& 0x0000ff);
    g=(UCHAR)((value& 0x00ff00)>>8);
    b=(UCHAR)((value& 0xff0000)>>16);
    // use this instead of the complete formula (uncomment the commented out code for the complete formula)
    // allow yellow scanner backgrounds
    return(ULONG)(Difference(b,g));//+Difference(r,g)+Difference(g,b));
}

// sets up a C32BitDibWrapper where each pixel (x,y) is the difference bettween the value of the pixel (x,y) on
// bitmap1 and the pixel (x,y) on bitmap2
int C32BitDibWrapper::CreateDifferenceBitmap(C32BitDibWrapper *pBitmap1, C32BitDibWrapper *pBitmap2)  // constructs a new dib that is the difference of the two other dibs
{                                                // image - blur(image) = detect edges.
    //
    // Destroy the old bitmap
    //
    if (m_pBits)
    {
        delete[] m_pBits;
        m_pBits = NULL;
    }
    m_nBitmapWidth=-1;
    m_nBitmapHeight=-1;

    //
    // Validate arguments
    //
    if (pBitmap1==NULL || pBitmap2==NULL)
    {
        return(FALSE);
    }

    if (pBitmap1->m_nBitmapWidth != pBitmap2->m_nBitmapWidth)
    {
        return(FALSE);
    }

    if (pBitmap1->m_nBitmapHeight != pBitmap2->m_nBitmapHeight)
    {
        return(FALSE);
    }

    if (pBitmap1->m_pBits==NULL || pBitmap2->m_pBits==NULL)
    {
        return(FALSE);
    }

    //
    // How many bytes do we need?
    //
    int nNumBytes = pBitmap1->m_nBitmapWidth * pBitmap1->m_nBitmapHeight * sizeof(ULONG);

    //
    // Allocate the bytes, return false if we weren't successful
    //
    m_pBits = new BYTE[nNumBytes];
    if (m_pBits==NULL)
    {
        return(FALSE);
    }

    //
    // Save the dimensions
    //
    m_nBitmapWidth=pBitmap1->m_nBitmapWidth;
    m_nBitmapHeight=pBitmap1->m_nBitmapHeight;

    //
    // Compute the difference
    //
    for (int i=0;i<nNumBytes;i++)
    {
        m_pBits[i]=Difference(pBitmap1->m_pBits[i],pBitmap2->m_pBits[i]);
    }
    return(TRUE);
}

// creates a C32BitDibWrapper which is identical to the C32BitDibWrapper passed as *bitmap
C32BitDibWrapper::C32BitDibWrapper(C32BitDibWrapper *pBitmap) // copy constructor
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    if (pBitmap && pBitmap->IsValid())
    {
        int nNumWords=pBitmap->m_nBitmapWidth*pBitmap->m_nBitmapHeight;
        ULONG* pBitmapCopy = new ULONG[nNumWords];
        ULONG* pSourceBitmap = (ULONG*)pBitmap->m_pBits;
        if (pBitmapCopy && pSourceBitmap)
        {
            CopyMemory( pBitmapCopy, pSourceBitmap, nNumWords*sizeof(ULONG) );
            m_pBits=(BYTE *)pBitmapCopy;
            m_nBitmapHeight=pBitmap->m_nBitmapHeight;
            m_nBitmapWidth=pBitmap->m_nBitmapWidth;
        }
    }
}

// creates a blank dib wrapper w pixels wide and h pixels high
C32BitDibWrapper::C32BitDibWrapper(int w, int h)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    int nNumWords=w*h;
    ULONG *pBitmapCopy = new ULONG[nNumWords];
    if (pBitmapCopy)
    {
        ZeroMemory(pBitmapCopy,nNumWords*sizeof(ULONG));
        m_pBits=(BYTE*)pBitmapCopy;
        m_nBitmapHeight=h;
        m_nBitmapWidth=w;
    }
}

// creates a C32BitDibWrapper given the bitmap refered to by pBitmap
C32BitDibWrapper::C32BitDibWrapper(BITMAP bm)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    BYTE* pDibBits=(BYTE*)(bm.bmBits);
    if (pDibBits!=NULL && bm.bmWidth>0 && bm.bmHeight>0 && bm.bmBitsPixel>0 && bm.bmBitsPixel<=32) // is it a valid bitmap?
    {
        int nDepth = bm.bmBitsPixel;

        m_nBitmapWidth = bm.bmWidth;
        m_nBitmapHeight = bm.bmHeight;

        //
        // convert to a 32 bit bitmap
        //
        m_pBits=ConvertBitmap(pDibBits,nDepth,32);
        if (!m_pBits)
        {
            m_nBitmapWidth=-1;
            m_nBitmapHeight=-1;
        }
    }
}

// constructor from a memory mapped file bitmap
C32BitDibWrapper::C32BitDibWrapper(BYTE* pDib)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    if (pDib)
    {
        //
        // get pointer to just the image bits:
        //
        PBITMAPINFO pBitmapInfo=(PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER));

        BYTE* pDibBits = NULL;
        switch (pBitmapInfo->bmiHeader.biBitCount)
        {
        case 24:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER);
            break;
        case 8:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER)-256*4+4;
            break;
        case 1:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER)-4;
            break;
        }

        if (pDibBits)
        {
            m_pBits=ConvertBitmap(pDibBits,pBitmapInfo->bmiHeader.biBitCount,32);// convert to a 32 bit bitmap
            if (m_pBits)
            {
                m_nBitmapWidth=pBitmapInfo->bmiHeader.biWidth;
                m_nBitmapHeight=pBitmapInfo->bmiHeader.biHeight;
            }
        }
    }
}

// create an empty wrapper
// we later expect to fill the wrapper using CreateDifferenceBitmap
C32BitDibWrapper::C32BitDibWrapper(void)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
}

C32BitDibWrapper::~C32BitDibWrapper(void)
{
    Destroy();
}


void C32BitDibWrapper::Destroy(void)
{
    if (m_pBits)
    {
        delete[] m_pBits;
        m_pBits = NULL;
    }
    m_nBitmapWidth=-1;
    m_nBitmapHeight=-1;
}

//
//  helper function which converts between 32 bit and other less worthy formats
//  32 bit dibs are stored in the following format
//  xxxxxxxxRRRRRRRRGGGGGGGGBBBBBBBB 8 blank bits followed by 8 bits for each RGB channel
//
//  not optimized for speed
//
// if we are being handed a large number of 300 dpi bitmaps, this could become an important function to
// optimize... otherwise its fine in its current form
//
BYTE* C32BitDibWrapper::ConvertBitmap( BYTE* pSource, int bitsPerSource, int bitsPerDest )
{
    BYTE* pDest = NULL;
    long x, y, nSourceLocation=0, nTargetLocation=0;
    int i, nDWordAlign;

    //
    // Compute the dword align space for each line
    //
    if (m_nBitmapWidth%4!=0)
        nDWordAlign=4-(m_nBitmapWidth*3)%4;
    else nDWordAlign=0;

    //
    // Convert from a 24 bit bitmap to a 32 bit bitmap
    // Pretty straight forward except that we have to watch out for
    // DWORD align stuff with 24 bit bitmaps
    //
    if (bitsPerSource==24 && bitsPerDest==32)
    {
        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];

        //
        // with fancy bit twiddling, we can get things done with one operation per 32
        // bit pixel instead of 3 without much trouble if this routine becomes a
        // performance bottlekneck, we should modify this code
        //
        // loop through all pixels adding 8 bits of zeroed out data at the end of
        // each pSource line.  00000000RRRRRRRRGGGGGGGGBBBBBBBB
        //
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=0;
                }
                nSourceLocation+=nDWordAlign; // skip nDWordAlign pixels... 24 bit bitmaps are DWORD alligned
            }
        }
        return(pDest);
    }

    //
    // Convert from an 8 bit bitmap to a 32 bit bitmap
    //
    else if (bitsPerSource==8 && bitsPerDest==32)
    {
        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++) // loop through all pixels (x,y)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=0;
                    nSourceLocation++;
                }
                if (m_nBitmapWidth%4!=0)
                {
                    //
                    // handle dword alignment issues for 8 bit dibs
                    //
                    nSourceLocation+=4-(m_nBitmapWidth)%4;
                }
            }
        }
        return(pDest);
    }

    //
    // Convert from a 1 bit B&W bitmap to a 32 bit bitmap
    //
    if (bitsPerSource==1 && bitsPerDest==32)
    {
        const int c_nConvertSize = 256;
        const int c_nMaskSize = 8;
        BYTE mask[c_nMaskSize];
        BYTE convert[c_nConvertSize];
        BYTE nCurrent;
        int nByte = 0,nBit = 0;
        int nLineWidth;

        //
        // mask[i] = 2^i
        //
        for (i=0;i<c_nMaskSize;i++)
        {
            mask[i]=1<<i;
        }

        //
        // all values of convert other than convert[0] are set to 0
        //
        convert[0]=0;
        for (i=1;i<c_nConvertSize;i++)
        {
            convert[i]=255;
        }

        nLineWidth=((m_nBitmapWidth+31)/32)*4;

        //
        // loop through all bitmap pixels keeping track of
        // byte which indicates the byte position of the pixel (x,y) in the pSource bitmap
        // bit which indicates the bit position of the pixel (x,y) within the byte
        // desLocation which represents the byte position of the 32 bit dib wrapper
        //
        // loop through all bitmap pixels keeping track of byte which indicates the
        // byte position of the pixel (x,y) in the pSource bitmap bit which indicates
        // the bit position of the pixel (x,y) within the byte desLocation which
        // represents the byte position of the 32 bit dib wrapper
        //

        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                nBit=0;
                nByte=y*nLineWidth;
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    if (nBit==8)
                    {
                        nBit=0;
                        nByte++;
                    }

                    nCurrent=pSource[nByte]&mask[nBit];
                    nCurrent=convert[nCurrent];
                    pDest[nTargetLocation++]=static_cast<BYTE>(nCurrent);
                    pDest[nTargetLocation++]=static_cast<BYTE>(nCurrent);
                    //
                    // hack to prevent shadow detection for 1 nBit dibs.
                    // set the blue channel to 150 so that shadow detection doesn't kick in
                    //
                    pDest[nTargetLocation++]=nCurrent&150;
                    pDest[nTargetLocation++]=0;
                    nBit++;
                }
            }
        }
        return(pDest);
    }


    //
    // Only used for debugging purposes
    // Converts a 32 bit bitmap down to 24 bits so that we can quickly display it
    //
    if (bitsPerSource==32 && bitsPerDest==24) // pretty straight forward except that we have to watch out for DWORD align stuff with 24 bit bitmaps
    {
        pDest = new BYTE[(m_nBitmapWidth*3+nDWordAlign)*m_nBitmapHeight];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    //
                    // pSource is 32 bits... ignore the first 8 bits
                    //
                    nSourceLocation++;
                }
                //
                // handle dword alignment issues for 24 bit dibs
                //
                for (i=0;i<nDWordAlign;i++)
                {
                    pDest[nTargetLocation++]=255;
                }
            }
        }
        return(pDest);
    }
    return(pDest);
}

// blurs the bitmap both horizontally and vertically
int C32BitDibWrapper::Blur(void)
{
    BYTE *pBits=pointerToBlur();
    if (m_pBits)
    {
        delete[] m_pBits;
    }
    m_pBits = pBits;
    return(TRUE);
}

// this function should only be used if the current dib wrapper is blank
int C32BitDibWrapper::CreateBlurBitmap(C32BitDibWrapper * pSource)
{
    if (pSource!=NULL && pSource->m_pBits!=NULL)
    {
        Destroy();

        m_pBits=pSource->pointerToBlur();
        //
        // the blurred bitmap will have the same dimensions as the pSource bitmap
        //
        m_nBitmapWidth=pSource->m_nBitmapWidth;
        m_nBitmapHeight=pSource->m_nBitmapHeight;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// identical to the previous function, except that we use a horizontal blur instead of blur
int C32BitDibWrapper::CreateHorizontalBlurBitmap(C32BitDibWrapper * pSource)
{
    if (pSource!=NULL && pSource->IsValid())
    {
        Destroy();

        m_pBits=pSource->pointerToHorizontalBlur();
        if (m_pBits)
        {
            m_nBitmapWidth=pSource->m_nBitmapWidth;
            m_nBitmapHeight=pSource->m_nBitmapHeight;
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

int C32BitDibWrapper::CreateVerticalBlurBitmap(C32BitDibWrapper * pSource)
{
    //
    // Nuke the old bitmap
    //
    Destroy();

    if (pSource!=NULL && pSource->IsValid())
    {
        m_pBits=pSource->pointerToVerticalBlur();
        m_nBitmapWidth=pSource->m_nBitmapWidth;
        m_nBitmapHeight=pSource->m_nBitmapHeight;
        return(TRUE);
    }
    return(FALSE);
}


// blur the bitmap
BYTE* C32BitDibWrapper::pointerToBlur(void)
{
    if (m_pBits!=NULL)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;
        numPixels=m_nBitmapWidth*m_nBitmapHeight; // calculate the total number of pixels in the bitmap
        pSource = (ULONG *)m_pBits; // we want to deal with data in 32 bit chunks
        pBlurredBitmap = new ULONG[numPixels]; // create an array to hold the blurred bitmap

        if (pBlurredBitmap==NULL) return(NULL); // unable to alloc memory

        // handle edge pixels
        // we do not blur edge pixels
        // if needed, edge pixels could be blurred here

        // blur top and bottom edge pixels
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        // position indicates the location of the pixel (x,y) in the array
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // loop through all pixels except for 1 pixel wide outside edge
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                // we wish to take the average of the pixel directly below the pixel, the pixel directly below the pixel
                // the pixel directly to the right of the pixel and the pixel directly to the left of the pixel
                // we can do this 1 dword at a time and without any bit shifting by the following algorithm

                // problem.  we cannot simply add the values of all four pixels and then divide by four
                // because or bit overflow from one RGB channel to another.  to avoid this overflow, we start by
                // eliminating the two low order bits in each of the 3 color channels
                // we use the filter 0xfafafa to remove the 2 low order bits from each of the 3 color channels
                // e.g. RRRRRRRRGGGGGGGGBBBBBBBB goes to RRRRRR00GGGGGG00BBBBBB00
                // next shift each pixel over two bits so RRRRRR00GGGGGG00BBBBBB00 --> 00RRRRRR00GGGGGG00BBBBBB
                // note: we save 3 bit shifts by adding all four filtered pixels and then bitshifting which comes out to the same thing
                // we can now add the four pixel values without channels overflowing.  the value we get is off by an error factor
                // because we eliminated the two lowest bits from each value
                // we compensate for this error factor by applying the filter 0x030303 which translates
                // RRRRRRRRGGGGGGGGBBBBBBBB to 000000RR000000GG000000BB
                // giving us the two lowest order bits for each pixel.  we can then safely add the two lowest order
                // bits for each pixel.  we then divide the result by 4 and add it
                // to the value we got by ignoring the two lowest order bits.


                pBlurredBitmap[position] =
                (((pSource[position-1]&16579836) +   // 0xfafafa
                  (pSource[position+1]&16579836) +
                  (pSource[position-m_nBitmapWidth]&16579836) +
                  (pSource[position+m_nBitmapWidth]&16579836))>>2)+

                // compensate for error factor:
                ((((pSource[position-1]&197379) + // 0x030303
                   (pSource[position+1]&197379) +
                   (pSource[position-m_nBitmapWidth]&197379) +
                   (pSource[position+m_nBitmapWidth]&197379))>>2)&197379);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}


//
// identical to pointerToBlur bitmap except that we only use the pixel to
// the left and the pixel to the right of the bitmap for detailed comments,
// see pointerToBlur
//
BYTE* C32BitDibWrapper::pointerToHorizontalBlur(void)
{
    if (m_pBits!=NULL)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;

        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        pSource = (ULONG *)m_pBits;
        pBlurredBitmap = new ULONG[numPixels];
        if (pBlurredBitmap == NULL) return(NULL);

        // handle edge pixels
        // for edge pixels we simply copy the pixel into the pSource to the destination
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // for all pixels, pSource[position] is the pixel at (x,y)
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                pBlurredBitmap[position] =
                (((pSource[position-1]&0xfefefe) +
                  (pSource[position+1]&0xfefefe))>>1)+
                ((((pSource[position-1]&0x010101) +
                   (pSource[position+1]&0x010101))>>1)&0x010101);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}

// blur vertically
// same exact method as pointerToHorizontalBlur
// useful for detecting vertical edges, etc.
BYTE* C32BitDibWrapper::pointerToVerticalBlur(void)
{
    if (m_pBits)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        pSource = (ULONG *)m_pBits;

        pBlurredBitmap = new ULONG[numPixels];
        if (pBlurredBitmap == NULL) return(NULL);

        // handle edge pixels
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // pSource[position] is the pixel at (x,y)
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                pBlurredBitmap[position] =
                (((pSource[position-m_nBitmapWidth]&0xfefefe) +
                  (pSource[position+m_nBitmapWidth]&0xfefefe))>>1)+
                ((((pSource[position-m_nBitmapWidth]&0x010101) +
                   (pSource[position+m_nBitmapWidth]&0x010101))>>1)&0x010101);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}

// cuts the intensity of each pixel in half
// useful for certain graphics effects
int C32BitDibWrapper::HalfIntensity(void)
{
    if (m_pBits)
    {
        int numPixels;
        int i;
        ULONG* pBitmapPixels;
        pBitmapPixels=(ULONG*)m_pBits;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        // loop through all pixels
        for (i=0;i<numPixels;i++)
            pBitmapPixels[i]=(pBitmapPixels[i]&0xfefefe)>>1; // half intensity by first eliminating the lowest order bit from each pixel and then shifting all pixels by 1
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// used repeatedly if the user hands us a 300 dpi image, etc.
// HalfSize compacts a h x w bitmap down to a h/2 x w/2 bitmap
int C32BitDibWrapper::HalfSize(void)
{
    if (m_pBits)
    {
        int x,y;
        ULONG position; // position in old bitmap
        ULONG halfposition; // position in half (1/4 area) sized bitmap
        int oldWidth,oldHeight;
        ULONG* pOldBitmap;
        ULONG* pNewBitmap;
        pOldBitmap=(ULONG *)m_pBits; // we speed things up by dealing with 32 bit chunks instead of 8 bit chunks

        pNewBitmap = new ULONG[(m_nBitmapWidth/2)*(m_nBitmapHeight/2)]; // create an array to store a bitmap 1/4th the size of the origional bitmap

        if (pNewBitmap == NULL) return(FALSE); // out of memory

        position=0;
        halfposition=0;

        // loop through pixels 2 pixels at a time in each direction
        // at all times we insure that pOldBitmap[position] is the pixel at (x,y)
        // and pNewBitmap[halfposition] is the pixel at (x/2,y/2)
        for (y=0;y<m_nBitmapHeight-1;y+=2)
        {
            position=m_nBitmapWidth*y;
            for (x=0;x<m_nBitmapWidth-1;x+=2)
            {
                pNewBitmap[halfposition] =  // we use the same algorithm for finding the average of four pixel values as used in pointerToBlur
                                            // see pointerToBlur for a detailed explaination
                                            (((pOldBitmap[position]&16579836) +
                                              (pOldBitmap[position+1]&16579836) +
                                              (pOldBitmap[position+m_nBitmapWidth]&16579836) +
                                              (pOldBitmap[position+m_nBitmapWidth+1]&16579836))>>2)+
                                            ((((pOldBitmap[position]&197379) +
                                               (pOldBitmap[position+1]&197379) +
                                               (pOldBitmap[position+m_nBitmapWidth]&197379) +
                                               (pOldBitmap[position+m_nBitmapWidth+1]&197379))>>2)&197379);
                position+=2;
                halfposition++;
            }
        }

        delete[] m_pBits; // destroy the old bitmap array

        m_nBitmapWidth=m_nBitmapWidth/2;
        m_nBitmapHeight=m_nBitmapHeight/2;

        m_pBits=(BYTE *)pNewBitmap;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// this function destorys regions where the edgeBitmapPixels
// edgeBitmap holds edge informat, start defines the maximum color value for a pixel to start a shadow elimination search
// maxPixel defines the maximum edge value allowed for a shadow pixel
// differenceFromGrey defines the maximum difference from grey for a shadow pixel
// enhanceEdges deals with edge enhancement

int C32BitDibWrapper::KillShadows(C32BitDibWrapper * edgeBitmap, ULONG start, ULONG maxPixel, ULONG differenceFromGrey, ULONG min_guaranteed_not_shadow, bool enhanceEdges)
{
    if (IsValid() && edgeBitmap && edgeBitmap->m_pBits)
    {
        int x,y,position, searchPosition, newPosition;
        ULONG searchEdge;
        ULONG * pEdgePixels;
        ULONG * pBitmapPixels;
        ULONG maxEdge;

        int numPixels=m_nBitmapWidth*m_nBitmapHeight;
        int *pShadowStack = new int[MAXSTACK];
        if (!pShadowStack)
        {
            //
            // we probably ran out of memory.  die gracefully.
            //
            return(FALSE);
        }
        int stackHeight = 0;

        // we first mark all the border pixels so we don't go off the edge
        // this is much faster than other ways of doing bounds checking
        pEdgePixels=(ULONG *)edgeBitmap->m_pBits;
        pBitmapPixels=(ULONG *)m_pBits;

        for (x=0;x<m_nBitmapWidth;x++)
        {
            pEdgePixels[x] = BORDER_EDGE; // top row
            pEdgePixels[numPixels-x-1] = BORDER_EDGE; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pEdgePixels[position] = BORDER_EDGE; // left edge
            pEdgePixels[position+m_nBitmapWidth-1] = BORDER_EDGE; // right edge
        }


        position=m_nBitmapWidth;
        maxEdge=maxPixel;


        for (y=1;y<m_nBitmapHeight-1;y++)
        {
            position++; // because we start at y=1 instead of y=0
            for (x=1;x<m_nBitmapWidth-1;x++)
            {

                if (pBitmapPixels[position]!=DEAD_PIXEL) // we ignore DEAD_PIXEL pixels completelly
                {

                    // check for pixels to mark as not shadows
                    if (pEdgePixels[position]!=BORDER_EDGE
                        && Intensity(pEdgePixels[position])>min_guaranteed_not_shadow
                        && enhanceEdges) // we only mark pixels as NOT_SHADOW if we are in enhanceEdges mode
                    {
                        pBitmapPixels[position]=NOT_SHADOW;
                    }
                    else             // maybe this is a shadow pixel...
                        if (pBitmapPixels[position]!=NOT_SHADOW
                            && pBitmapPixels[position]!=DEAD_PIXEL
                            && Intensity(pBitmapPixels[position])<=start
                            && Intensity(pEdgePixels[position])<=maxEdge
                            && pBitmapPixels[position]!=ERASEDSHADOW
                            && DifferenceFromGray(pBitmapPixels[position])<=differenceFromGrey)
                    { // pixel is a shadow pixel
                        stackHeight=1;
                        pShadowStack[0]=position;
                        pBitmapPixels[position]=ERASEDSHADOW; // when we have decided a pixel is a shadow pixel, set it to zero

                        // fighitng edges add extra complexity but potentially allow us greater accuracy
                        // the concept is to mark pixels which cannot possibly be shadow pixels as such
                        // fighting edges only come into effect if FIGHTING_EDGES is set to true and enhanceEdges is set to false
                        // for the current KillShadows pass

                        if (FIGHTING_EDGES)
                            if (!enhanceEdges
                                && Intensity(pEdgePixels[position])<=FIGHTING_EDGE_MAX_EDGE
                                && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                && Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                && Intensity(pBitmapPixels[position])<=FIGHTING_EDGE_MAX_MARK_PIXEL
                               )
                                pBitmapPixels[position]=DEAD_PIXEL;

                        while (stackHeight>0)
                        {
                            searchPosition=pShadowStack[--stackHeight];
                            searchEdge=Intensity(pEdgePixels[searchPosition]); // key idea: we are on a search and destroy mission for smooth gradients
                            // make sure our current edge value is similar to our last edge value

                            newPosition=searchPosition-1;

                            if ((pBitmapPixels[newPosition]!=NOT_SHADOW)
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition+1;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[position])<=FIGHTING_EDGE_MAX_MARK_PIXEL
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition-m_nBitmapWidth;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition+m_nBitmapWidth;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }
                        }
                    }
                }
                position++;
            }
            position++;
        }

        delete[] pShadowStack;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


// older simpler version... that includes comments:
/*int C32BitDibWrapper::KillShadows(C32BitDibWrapper * edgeBitmap, UINT start, UINT maxPixel, UINT differenceFromGrey)
{
    int x,y,position, searchPosition, newPosition;
    ULONG searchEdge;
    ULONG * pEdgePixels;
    ULONG * pBitmapPixels;
    int * pShadowStack;
    int stackHeight;
    int numPixels;
    UINT maxEdge;

    numPixels=m_nBitmapWidth*m_nBitmapHeight;
    pShadowStack = new int[MAXSTACK]; // we use a stack as part of a depth first search for potential shadow pixels next to a shadow pixel we have found
    if (pShadowStack==NULL) return(FALSE); // we probably ran out of memory.  die gracefully.
    stackHeight=0;

    // we first change all the border edge pixels to white so we don't go off the edge
    // KillShadows avoids pixels with high shadow values so this should keep us from going off
    // the edge of the bitmap... if maxPixel were set to 0xffffff, this would crash
    // but in such a case, KillShadows would kill the whole bitmap.
    // this is much faster than other ways of doing bounds checking
    // we set all edge pixels to values such that we are gauranteed to reject them
    pEdgePixels=(ULONG *)edgeBitmap->m_pBits;
    pBitmapPixels=(ULONG *)m_pBits;

    // horizontal sides
    for (x=0;x<m_nBitmapWidth;x++)
    {
        pEdgePixels[x] = 0xffffff; // top row
        pEdgePixels[numPixels-x-1] = 0xffffff; // bottom row
    }

    // vertical sides
    for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
    {
        pEdgePixels[position] = 0xffffff; // left edge
        pEdgePixels[position+m_nBitmapWidth-1] = 0xffffff; // right edge
    }

    position=m_nBitmapWidth;
    maxEdge=maxPixel;

    for (y=1;y<m_nBitmapHeight-1;y++)
    {
        position++; // because we start at y=1 instead of y=0
        for (x=1;x<m_nBitmapWidth-1;x++)
        {

            // we only start a shadow kill search if

            if (Intensity(pBitmapPixels[position])<=start && Intensity(pEdgePixels[position])<=maxEdge && pBitmapPixels[position]!=ERASEDSHADOW && DifferenceFromGray(pBitmapPixels[position])<=differenceFromGrey)
            {
                // initialize the stack to do a DFS without recursion to find shadows
                stackHeight=1; // we are going to place the current position on the stack
                pShadowStack[0]=position;
                pBitmapPixels[position]=ERASEDSHADOW; // when we have decided a pixel is a shadow pixel, set it to zero
                while (stackHeight>0)
                {
                    searchPosition=pShadowStack[--stackHeight];
                    searchEdge=Intensity(pEdgePixels[searchPosition]); // key idea: we are on a search and destroy mission for smooth gradients
                                                                      // make sure our current edge value is similar to our last edge value

                    newPosition=searchPosition-1; // try the pixel to the left of the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey) // requirements for classifying a pixel as a shadow pixel if we have classified an adjacent pixel as a shadow pixel
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW; // delete the pixel and mark it as an erased pixel so that our search doesn't go into an infinite loop
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition+1; // try the pixel to the right of the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition-m_nBitmapWidth; // try the pixel directly above the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition+m_nBitmapWidth; // try the pixel directly below the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                }
            }
            position++;
        }
        position++;
    }

    if (pShadowStack!=NULL) delete pShadowStack;
    return(TRUE);
}
*/


// finds clumps of pixels above the minimum image threshold
// pMap is an array which indicates which chunk each pixel in the bitmap is part of
// pMap values:
// 0 indicates that a pixel is not part of a chunk
// VERTICAL_EDGE indicates that a pixel is not part of a chunk and that the pixel is very close to the vertical edge of the image
// HORIZONTAL_EDGE is the same as vertical edge, just for horizontal edges
//
int C32BitDibWrapper::FindChunks(int * pMap) // return number of chunks... color the chunks on pMap
{
    if (pMap && m_pBits)
    {
        int x,y,position, searchPosition;
        ULONG * pBitmapPixels;
        int * pChunkStack;
        int stackHeight;
        int numChunks;
        int chunkSize;
        int deltax, deltay;
        int newPosition;

        // prepare pMap
        // indicate which pixels are edge pixels
        // position represents the location of pixel (x,y)
        // we indicate which pixels are edge pixels to prevent the search routines
        // that follow from running off the edge of the bitmap
        // to save time, the search routines will not keep track of x and y coordinates
        // so it is neccessary to provide another and faster way of determining the bounds of the bitmap

        position=0;
        for (y=0;y<EDGEWIDTH;y++)
        {
            for (x=0;x<m_nBitmapWidth;x++)
                pMap[position++]=VERTICAL_EDGE;
        }

        for (;y<m_nBitmapHeight-EDGEWIDTH;y++)
        {
            for (x=0;x<EDGEWIDTH;x++)
                pMap[position++]=HORIZONTAL_EDGE;

            for (;x<m_nBitmapWidth-EDGEWIDTH;x++)  // for pixels that are not edge pixels, we set pMap to 0 to indicate
                pMap[position++]=0;               // that the pixel in question is ready to be set as part of a chunk

            for (;x<m_nBitmapWidth;x++)
                pMap[position++]=HORIZONTAL_EDGE;
        }

        for (;y<m_nBitmapHeight;y++)
        {
            for (x=0;x<m_nBitmapWidth;x++)
                pMap[position++]=VERTICAL_EDGE;
        }


        // we are now ready to search for chunks

        pChunkStack = NULL;
        pChunkStack = new int[MAXSTACK];
        if (pChunkStack == NULL) return(NULL);
        stackHeight=0;
        numChunks=0;

        pBitmapPixels=(ULONG *)m_pBits; // its more convenient for this function to deal with pixels in 32 bit chunks instead of bytes .

        // at all times we keep position set so that pBitmapPixels[position] represents the pixel at coordinates (x,y)
        position=m_nBitmapWidth*EDGEWIDTH;
        for (y=EDGEWIDTH;y<m_nBitmapHeight-EDGEWIDTH;y++) // check if we should start a floodfill search
        // at each pixel (x,y) such that we are > EDGWIDTH from the edge
        {
            position+=EDGEWIDTH;
            for (x=EDGEWIDTH;x<m_nBitmapWidth-EDGEWIDTH;x++)
            {
                // check if the pixel in question is not part of an existing chunk and that its intensity
                // is greater than the minimum intensity required to be part of chunk

                if (pMap[position]==0 && Intensity(pBitmapPixels[position])>MIN_CHUNK_INTENSITY)
                {
                    // initialize stack used for doing a DFS of adjacent pixels
                    stackHeight=1;
                    pChunkStack[0]=position;
                    numChunks++;
                    chunkSize=0; // compute how many pixels are in the chunk. not used at the moment, but useful if we want
                                 // to eliminate chunks which are too small at this stage instead of at some later point

                    pMap[position]=numChunks; // place this pixel in a chunk like it belongs

                    // continue searching for pixels while the stack is not empty

                    while (stackHeight>0)
                    {
                        searchPosition=pChunkStack[--stackHeight]; // pop the next pixel off the stack
                        chunkSize++; // increment the number of pixels in the chyunk by 1

                        // we check if we should add all pixels within EDGEWIDTH of the searchPosition pixel to the current chunk
                        // we then add any such pixels which are not edge pixels to the stack
                        for (deltay=-EDGEWIDTH*m_nBitmapWidth;deltay<=EDGEWIDTH*m_nBitmapWidth;deltay+=m_nBitmapWidth)
                            for (deltax=-EDGEWIDTH;deltax<=EDGEWIDTH;deltax++)
                            {
                                newPosition=searchPosition+deltay+deltax;
                                if (Intensity(pBitmapPixels[newPosition])>MIN_CHUNK_INTENSITY && pMap[newPosition]<=0)
                                {
                                    if (pMap[newPosition]==0) // not an edge pixel
                                    {
                                        pChunkStack[stackHeight++]=newPosition;
                                        pMap[newPosition]=numChunks; // mark the pixel as part of the chunk so that we do not go into an infinite loop
                                    }
                                    else // if a pixel is an edge pixel, we do not want to add that pixel to the stack
                                    {
                                        // (because of problems with scanners with black borders)
                                        // furthermore... we only want to add an edge pixel if the current pixel is
                                        // in a vertical or horizontal line with the edge pixel under consideration
                                        // as this further minimizes problems related to black scanner edges
                                        if (pMap[newPosition]==VERTICAL_EDGE)
                                        {
                                            if (deltax==0) // to minimize distortion due to black outside edge
                                                pMap[newPosition]=numChunks;
                                        }
                                        else // HORIZONTAL_EDGE
                                        {
                                            if (deltay==0) // to minimize distortion due to black outside edge
                                                pMap[newPosition]=numChunks;
                                        }
                                    }
                                }

                            }
                    }
                }
                position++;
            }
            position+=EDGEWIDTH;
        }
        delete[] pChunkStack;
        return(numChunks);
    }
    else
    {
        return(0);
    }
}

// for debugging purposes only
// displays where the chunks denoted by pMap are on the C32BitDibWrapper
// pMap must have the same dimensions as the current bitmap or this function will fail

void C32BitDibWrapper::ColorChunks(int *pMap)
{   // color in the bitmap given the region map... for debugging purposes;
    if (m_pBits && pMap)
    {
        ULONG* pBitmapPixels;
        ULONG mapColor;
        int x,y;
        int position;
        position=0;
        pBitmapPixels=(ULONG *)m_pBits;

        // loop through all pixels
        for (y=0;y<m_nBitmapHeight;y++)
            for (x=0;x<m_nBitmapWidth;x++)
            {
                if (pMap[position]>0) // are we part of a region?
                {
                    mapColor=(((ULONG)pMap[position])*431234894)&0xffffff; // a poor man's random number generator
                    // if we cared about speed... we should make a lookup table instead
                    // but this function is only for debugging purposes
                    pBitmapPixels[position]=((pBitmapPixels[position] & 0xfefefe)>>1)+((mapColor& 0xfefefe)>>1); // average with slight loss
                }
                if (pMap[position]<0) pBitmapPixels[position]=0xffffff; // color in vertical and horizontal edges
                position++;
            }
    }
}

// designed mainly for debugging purposes... this is a painfully slow way to draw a 32 bit dib
// because of the slow conversion step from 32 bits back to 24 bits
int C32BitDibWrapper::Draw(HDC hdc, int x, int y)
{
    if (hdc && m_pBits)
    {
        BITMAPINFO BitmapInfo;
        SetBMI(&BitmapInfo,m_nBitmapWidth, m_nBitmapHeight, 24);

        BYTE* pDibData = ConvertBitmap(m_pBits,32,24);
        if (pDibData)
        {
            StretchDIBits(hdc,
                          x,y,m_nBitmapWidth,m_nBitmapHeight,
                          0,0,m_nBitmapWidth,m_nBitmapHeight,
                          pDibData,
                          &BitmapInfo,BI_RGB,SRCCOPY);

            //
            // destroy the temp 24 bit dib
            //
            delete[] pDibData;
            return(TRUE);
        }
    }
    return(FALSE);
}

// set pixel and get pixel are completelly unoptimized
// If you wish to make them faster, create a table of values storing y*m_nBitmapWidth for all values of y
// as GetPixel is used by the line drawing functions, this could result in a signifigant speed up as
// the line drawing functions are used for region collision detection

void inline C32BitDibWrapper::SetPixel(int x, int y, ULONG color)
{
    if (m_pBits)
    {
        ULONG* pBitmapPixels=(ULONG*)m_pBits;
        pBitmapPixels[y*m_nBitmapWidth+x]=color;
    }
}

ULONG inline C32BitDibWrapper::GetPixel(int x, int y)
{
    if (m_pBits)
    {
        ULONG* pBitmapPixels=(ULONG*)m_pBits;
        return(pBitmapPixels[y*m_nBitmapWidth+x]);
    }
    return 0;
}

//
// calculates the total intensity along a line
//
// Line drawing code modified from VGA line drawing code from Michael
// Abrash's Graphics Programming Black Book
//
// this is the one function which I did not create from scratch so any bug
// questions should be directed to Michael Abrash =) why reinvent the wheel
// when Bresenham line drawing is kindof hard to beat.  particularly in this
// case when we are using lines as tracers so we couldn't care less about if
// they are antialiased or otherwise made to look less jagged.
//
// t-jacobr
//
ULONG C32BitDibWrapper::Line(int X0, int Y0,int X1, int Y1)
{
    if (m_pBits)
    {
        if (X0<0) X0=0;
        if (Y0<0) Y0=0;
        if (X1<0) X1=0;
        if (Y1<0) Y1=0;

        if (X0>=m_nBitmapWidth) X0=m_nBitmapWidth;
        if (Y0>=m_nBitmapHeight) Y0=m_nBitmapHeight;
        if (X1>=m_nBitmapWidth) X1=m_nBitmapWidth;
        if (Y1>=m_nBitmapHeight) Y1=m_nBitmapHeight;

        int DeltaX, DeltaY;
        int Temp;
        if (Y0>Y1)
        {
            Temp=Y0;
            Y0=Y1;
            Y1=Temp;
            Temp = X0;
            X0=X1;
            X1=Temp;
        }
        DeltaX=X1-X0;
        DeltaY=Y1-Y0;
        if (DeltaX>0)
        {
            if (DeltaX>DeltaY)
            {
                return(Octant0(X0,Y0,DeltaX,DeltaY,1));
            }
            else
            {
                return(Octant1(X0,Y0,DeltaX,DeltaY,1));
            }
        }
        else
        {
            DeltaX = -DeltaX;
            if (DeltaX>DeltaY)
            {
                return(Octant0(X0,Y0,DeltaX,DeltaY,-1));
            }
            else
            {
                return(Octant1(X0,Y0,DeltaX,DeltaY,-1));
            }
        }
    }
    else
    {
        return(0); // invalid bitmap
    }
}


// helper functions for line drawing
// these aint no normal nine drawing functions
// what we do is we calculate the total intensity of all of the above threshold pixels along the line

ULONG C32BitDibWrapper::Octant0(int X0, int Y0,int DeltaX,int DeltaY,int XDirection)
{
    if (IsValid())
    {
        int DeltaYx2;
        int DeltaYx2MinusDeltaXx2;
        int ErrorTerm;
        ULONG totalIntensity;
        ULONG pixelIntensity;
        totalIntensity=0;
        DeltaYx2=DeltaY*2;
        DeltaYx2MinusDeltaXx2=DeltaYx2 - (DeltaX*2);
        ErrorTerm = DeltaYx2 - DeltaX;

        // SetPixel(X0,Y0,0x0000ff);
        while (2<DeltaX--) // skip the last pixel
        {
            if (ErrorTerm >=0)
            {
                Y0++;
                ErrorTerm +=DeltaYx2MinusDeltaXx2;
            }
            else
            {
                ErrorTerm +=DeltaYx2;
            }
            X0+=XDirection;
            //SetPixel(X0,Y0,0x0000ff);
            pixelIntensity=Intensity(GetPixel(X0,Y0));
            if (pixelIntensity>MIN_CHUNK_INTENSITY && pixelIntensity<COLLISION_DETECTION_HIGHPASS_VALUE) totalIntensity+=512;//pixelIntensity;
        }
        return(totalIntensity);
    }
    return 0;
}

ULONG C32BitDibWrapper::Octant1(int X0, int Y0, int DeltaX, int DeltaY, int XDirection)
{
    if (IsValid())
    {
        int DeltaXx2;
        int DeltaXx2MinusDeltaYx2;
        int ErrorTerm;
        ULONG totalIntensity;
        ULONG pixelIntensity;
        totalIntensity=0;

        DeltaXx2 = DeltaX * 2;
        DeltaXx2MinusDeltaYx2 = DeltaXx2 - (DeltaY*2);
        ErrorTerm = DeltaXx2 - DeltaY;

        //SetPixel(X0,Y0,0x0000ff);
        while (2<DeltaY--)
        { // skip last pixel
            if (ErrorTerm >=0)
            {
                X0 +=XDirection;
                ErrorTerm +=DeltaXx2MinusDeltaYx2;
            }
            else
            {
                ErrorTerm +=DeltaXx2;
            }
            Y0++;
            pixelIntensity=Intensity(GetPixel(X0,Y0));
            if (pixelIntensity>MIN_CHUNK_INTENSITY && pixelIntensity<COLLISION_DETECTION_HIGHPASS_VALUE) totalIntensity+=512;//pixelIntensity;
        }
        return(totalIntensity);
    }
    return 0;
}


//
// Compensate for Background Color could be made more than 3 times as fast if needed by caculating each pixel
// using 1 cycle instead of 3.

void C32BitDibWrapper::CompensateForBackgroundColor(int r, int g, int b)
{
    if (IsValid())
    {
        int nNumBits=m_nBitmapWidth*m_nBitmapHeight*4;
        for (int position=0;position<nNumBits;position+=4)
        {
            if (r<m_pBits[position]) m_pBits[position]=m_pBits[position]-r;
            else m_pBits[position]=0;
            if (g<m_pBits[position+1]) m_pBits[position+1]=m_pBits[position+1]-g;
            else m_pBits[position+1]=0;
            if (b<m_pBits[position+2]) m_pBits[position+2]=m_pBits[position+2]-b;
            else m_pBits[position+2]=0;
        }
    }
}

// invert the bitmap
void C32BitDibWrapper::Invert(void)
{
    if (IsValid())
    {
        int numPixels;
        int i;
        ULONG* pBitmapPixels;
        pBitmapPixels=(ULONG*)m_pBits; // operate in 32 bit chunks instead of 8 bit chunks
        numPixels=m_nBitmapWidth*m_nBitmapHeight;

        // loop through all pixels in the bitmap
        for (i=0;i<numPixels;i++)
            pBitmapPixels[i]^=0xffffff; // flipping all bits inverts the pixel
    }
}

// note: we could get some wierd effects because despeckle edits the bitmap its examining
// but this shouldn't be a signifigant problem and often, the self referential aspect only acts to slightly increase accuracy
// this function is not the same as the standard photoshop despeckle filter.
// we only care about a small category of stray dots.
// stray dots which are surrounded by white pixels (or pixels which have been eliminated by remove shadow filters)

void C32BitDibWrapper::Despeckle(void)
{
    if (IsValid())
    {
        ULONG* pBitmapPixels;
        int numPixels;
        int position;
        int x,y;
        pBitmapPixels=(ULONG*)m_pBits;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;

        position=4*m_nBitmapWidth;

        // loop through all pixels which are not border pixels
        // pBitmapPixels[position] should be the pixel at (x,y) in all cases
        for (y=4;y<m_nBitmapHeight-4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,false);
                position++;
            }
            position+=4;
        }
    }
}

// we may want to despeckle the edges of an image more often than the rest of the image
// as image edges are often trouble spots...
// because of this, we should recommend that users place images in the center of the scanner
// when doing region detection to increase accuracy.
// the concept we are applying is that when we have to make sacrifices we make sacrifices in areas where we hurt cases that would have been very very hard anyway.

void C32BitDibWrapper::EdgeDespeckle(void)
{
    if (IsValid())
    {
        ULONG* pBitmapPixels;
        int x,y,position;
        pBitmapPixels=(ULONG*)m_pBits;

        position=m_nBitmapWidth*4;

        // top edge
        // as always, at all times we insure that pBitmapPixels[position] is the pixel at (x,y)
        for (y=4;y<DESPECKLE_BORDER_WIDTH+4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true);
                position++;
            }
            position+=4;
        }

        // side edges
        for (;y<m_nBitmapHeight-DESPECKLE_BORDER_WIDTH-4;y++)
        {
            position+=4;
            for (x=4;x<DESPECKLE_BORDER_WIDTH+4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true); // left edge
                DespecklePixel(pBitmapPixels, position+m_nBitmapWidth-DESPECKLE_BORDER_WIDTH-8,true); // right edge
                position++;
            }
            position+=m_nBitmapWidth-DESPECKLE_BORDER_WIDTH-4;
        }

        // bottom edge
        for (;y<m_nBitmapHeight-4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true);
                position++;
            }
            position+=4;
        }
    }
}

// given the pixel at position i, figure out if it meets any of the requirements for eliminating the pixel
// if it does, eliminate the pixel.  edgePixel specifies if the pixel is an edgePixel (in which case we may want
// to apply more strict requirements).
void C32BitDibWrapper::DespecklePixel(ULONG* pBitmapPixels, int i, bool edgePixel)
{
    if (IsValid())
    {
        if (Intensity(pBitmapPixels[i])>MIN_CHUNK_INTENSITY)
        {
            //  deletes:
            //
            //    xx
            //    xx
            //
            if (
               Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i+2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               )
            {
                pBitmapPixels[i]=0;
                pBitmapPixels[i+1]=0;
                pBitmapPixels[i+m_nBitmapWidth]=0;
                pBitmapPixels[i+1+m_nBitmapWidth]=0;
            }



            if (edgePixel==true)
            {

                // radius one speckle
                // horizontal despeckle
                if (Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // vertical despeckle
                if (Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle

                // radius two despeckle
                if (Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-3])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+3])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // vertical despeckle
                if (Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // despeckle to eliminate clumps like this:

                // clump:               ? ?
                //                       x
                //                      ? ?

                if (Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle

            }

            // to eliminate this clump:
            //                      ?
            //                     ?x?
            //                      ?
            //

            if (Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY)
                pBitmapPixels[i]=0; // despeckle the speckle

            // these functions are insanely slow... if they become a major speed bottlekneck, they can be made
            // 10x faster
            // radius one speckle 3 pixel search depth
            // horizontal despeckle
            if (
               Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               )
                pBitmapPixels[i]=0; // despeckle the speckle
            // vertical despeckle
            if (
               Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth+1])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth-1])<MIN_CHUNK_INTENSITY
               )
                pBitmapPixels[i]=0; // despeckle the speckle
        }
    }
}

// its easy to correct for if the user adjusted brightness contrast
// or worse... if the scanners gamma settings are off
// not unlikely if they have a really old or really cheap scanner
void C32BitDibWrapper::CorrectBrightness(void)
{
    if (IsValid())
    {
        int r,g,b;
        int position;
        int nNumBits;
        r=255;
        g=255;
        b=255;
        nNumBits=m_nBitmapWidth*(m_nBitmapHeight-4)*4;
        // find the minimum, r, g, and b values;
        for (position=m_nBitmapWidth*4;position<nNumBits;position+=4)
        {
            if (r>m_pBits[position]) r=m_pBits[position];
            if (g>m_pBits[position+1]) g=m_pBits[position+1];
            if (b>m_pBits[position+2]) b=m_pBits[position+2];
        }

        if (r!=0 || g!=0 || b!=0) // if the r, g, or b vals are off, correct them
            CompensateForBackgroundColor(r,g,b);
    }
}

//
// stretch out the color spectrum if the darn user adjusted brightness so that no parts of the image are black anymore
// otherwise we can get embarassing failures if the user simply tweaks brightness and contrast too much
//
// stretches upwards... if you need to compensate downwards, call correctBrightness first
void C32BitDibWrapper::MaxContrast(UINT numPixelsRequired)
{
    if (IsValid())
    {
        int position;
        int nNumBits;
        int max;
        int i;
        int temp;
        BYTE pConversionTable[256];
        ULONG pNum[256];

        for (i=0;i<256;i++)
            pNum[i]=0;

        nNumBits=m_nBitmapWidth*m_nBitmapHeight*4;

        // compute the number of pixels of each intensity level
        for (position=0;position<nNumBits;position+=4)
        {
            pNum[m_pBits[position]]++;
            pNum[m_pBits[position+1]]++;
            pNum[m_pBits[position+2]]++;
        }

        max=1;
        // find max intensity which has at least numPixelsRequired of that intensity
        for (i=1;i<256;i++)
            if (pNum[i]>numPixelsRequired) max=i;

            // create conversion table
        for (i=0;i<256;i++)
        {
            temp=(255*i)/max;
            if (temp>255) temp=255; // high pass
            pConversionTable[i]=(BYTE)temp;
        }

        // now apply the conversion table to all pixels in the image
        for (position=0;position<nNumBits;position+=4)
        {
            m_pBits[position]=pConversionTable[m_pBits[position]];
            m_pBits[position+1]=pConversionTable[m_pBits[position+1]];
            m_pBits[position+2]=pConversionTable[m_pBits[position+2]];
        }
    }
}







/// we don't want to use intensity here
// because this is a function used for detecting text regions
// and text regions are more likely to have grey background than yellow backgrounds
// hence doing a chan by chan test is more effective
// IMPORTANT NOTE: this function is designed for use with a non-inverted bitmap unlike most of the other functions in this library
int C32BitDibWrapper::PixelsBelowThreshold(C32BitDibWrapper* pProccessedBitmap, C32BitDibWrapper * pEdgesBitmap, RECT region)
{
    if (IsValid() && pProccessedBitmap && pEdgesBitmap && pProccessedBitmap->IsValid() && pEdgesBitmap->IsValid())
    {
        int x,y;
        int position;
        int numPixels;
        ULONG* pBitmapPixels;
        ULONG* pEdgePixels;
        ULONG* pProccessedPixels; // bitmap with shadows removed, etc
        // we assume that the edge bitmap has the same width and height as this bitmap to shave a couple of 1/1000ths of a second... and cause we are lazy
        numPixels=0;
        pBitmapPixels=(ULONG *)m_pBits;
        pEdgePixels=(ULONG *)(pEdgesBitmap->m_pBits);
        pProccessedPixels=(ULONG *)(pProccessedBitmap->m_pBits);
        position=region.top*m_nBitmapWidth;
        // search through all pixels in the region
        // at all times, pBitmapPixels[position] is the pixel at point (x,y)
        for (y=region.top;y<=region.bottom;y++)
        {
            position+=region.left;
            for (x=region.left;x<=region.right;x++)
            {
                if ((
                    (pBitmapPixels[position]&0xff)    > TEXT_REGION_BACKGROUND_THRESHOLD
                    && (pBitmapPixels[position]&0xff00)  > (TEXT_REGION_BACKGROUND_THRESHOLD<<8)
                    && (pBitmapPixels[position]&0xff0000)> (TEXT_REGION_BACKGROUND_THRESHOLD<<16) // below threshold
                    && Intensity(pEdgePixels[position])  > MIN_TEXT_REGION_BACKGROUND_EDGE)             // does it have the requisite edge val?
                    || (pProccessedPixels[position]==0
                        && Intensity(pEdgePixels[position])>MIN_TEXT_REGION_BACKGROUND_EDGE_CLIPPED_PIXEL
                        && (pBitmapPixels[position]&0xff)    > CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD
                        && (pBitmapPixels[position]&0xff00)  > (CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD<<8)
                        && (pBitmapPixels[position]&0xff0000)> (CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD<<16) // below threshold
                       ))     // we coulda been a dead shadow pixel too.. this is risky because depending on the settings, we may have culled plenty of deserving pixels
                {
                    // we hold pixels to much higher standards if they are clipped pixels... to avoid too much stray clipping
                    numPixels++;
                }
                position++;
            }
            position+=m_nBitmapWidth-region.right-1;
        }
        return(numPixels);
    }
    else
    {
        return(0); // invalid bitmap
    }
}

// the name of the game here is whatever works
// this function may be ugly, but its the easiest way to get rid of
// black borders without hurting overly many innocent pixels

void C32BitDibWrapper::RemoveBlackBorder(int minBlackBorderPixel, C32BitDibWrapper * outputBitmap, C32BitDibWrapper * debugBitmap)
{
    if (IsValid() && m_nBitmapWidth>100 && m_nBitmapHeight>100 && outputBitmap) // these tests are designed for reasonably large bitmaps
    {
        // bottom border
        KillBlackBorder(minBlackBorderPixel,m_nBitmapWidth*m_nBitmapHeight-m_nBitmapWidth,m_nBitmapWidth,m_nBitmapHeight,1,-m_nBitmapWidth, outputBitmap, debugBitmap);
        // top border
        KillBlackBorder(minBlackBorderPixel,0,m_nBitmapWidth,m_nBitmapHeight,1,m_nBitmapWidth, outputBitmap, debugBitmap);
        // left side
        KillBlackBorder(minBlackBorderPixel,0,m_nBitmapHeight,m_nBitmapWidth, m_nBitmapWidth,1, outputBitmap, debugBitmap);
        // right side
        KillBlackBorder(minBlackBorderPixel,m_nBitmapWidth-1,m_nBitmapHeight,m_nBitmapWidth, m_nBitmapWidth,-1, outputBitmap, debugBitmap);
    }

}

// this function encapsulates the single purpose algorithm used to
// remove particularly troublesome shadows from the sides of images
// this function is poorly tweaked and it iss very likely that we could either
// greatly improve the number of errors detected
// or the number of false errors that are unfairly zapped
// debugBitmap is edited to give a graphical representation of which shadows have been eliminated
// debugBitmap is only edited if the VISUAL_DEBUG flag is set
// as shown in RemoveBlackBorder, KillBlackBorder is called with different startPosition, width, height, dx, and dy values
// depending on whether we are working on the top border, the left border, the right border, or the bottom border.
// from the perspective of KillBlackBorder, it is working on eliminating shadows from a bitmap which is width pixels wide
// height pixels high and the location of pixel (0,0) is startPosition.  Where to move one pixel in the x direction
// you increment startPosition by dx and to move one pixel in the y direction, you increment dy by 1.

void C32BitDibWrapper::KillBlackBorder(int minBlackBorderPixel, int startPosition, int width, int height, int dx, int dy, C32BitDibWrapper *pOutputBitmap, C32BitDibWrapper * pDebugBitmap)
{
    if (IsValid() && pOutputBitmap && pOutputBitmap->IsValid() && width>100 && height>100)
    {
        int x,y,position, searchPosition, newPosition;
        ULONG * pBitmapPixels;
        int endPoint;
        int r,g,b;
        int dr,dg,db;
        int i;
        int sourceR,sourceG, sourceB;
        int errors;
        int step;
        int* pShadowDepths;
        int* pTempShadowDepths;
        int longestBackgroundPixelString;
        int borderPixels;
        int nonBackgroundPixels;
        int backgroundPixels;
        BYTE* pBlurredBits = m_pBits;
        ULONG* pDebugPixels;
        BYTE* pOutputBits;

        pOutputBits=pOutputBitmap->m_pBits;

        pShadowDepths=new int[width]; // we keep an array of how many pixels we think the black border is for each scan line
        if (pShadowDepths==NULL) return;

        pTempShadowDepths=NULL;
        pTempShadowDepths=new int[width];

        if (pTempShadowDepths==NULL)
        {
            delete[] pShadowDepths;
            return;
        }

        int numPixels=height*width; // total pixels in the image

        pBitmapPixels=(ULONG *)(pOutputBitmap->m_pBits);
        if (pBitmapPixels)
        {
            pDebugPixels=(ULONG *)(pDebugBitmap->m_pBits);

            step=dy*4; // when dealing with data in 8 bit chunks instead of 32 bit chunks, we need to multiply the dy step by 4


            // reset all vals to 0
            for (i=0;i<width;i++)
            {
                pShadowDepths[i]=0;
                pTempShadowDepths[i]=0;
            }

            position=startPosition*4;
            for (x=0;x<width;x++) // loop through all pixels on the top row of the image
            {
                r=pBlurredBits[position];
                g=pBlurredBits[position+1];
                b=pBlurredBits[position+2];


                if (r>minBlackBorderPixel&&g>minBlackBorderPixel&&b>minBlackBorderPixel) // if the pixel is dark enough
                {
                    // start a kill shadows search
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    for (y=1;y<SHADOW_HEIGHT;y++)  // we don't expect a shadow to be more than SHADOW_HEIGHT pixels high
                    {
                        dr=(int)pBlurredBits[searchPosition]-r;
                        dg=(int)pBlurredBits[searchPosition+1]-g;
                        db=(int)pBlurredBits[searchPosition+2]-b;

                        r=(int)pBlurredBits[searchPosition];
                        g=(int)pBlurredBits[searchPosition+1];
                        b=(int)pBlurredBits[searchPosition+2];

                        if (dr<MAX_BLACK_BORDER_DELTA && dg<MAX_BLACK_BORDER_DELTA &&db<MAX_BLACK_BORDER_DELTA)
                        // only requirement is the intensity in each pixel must be less than the intensity of the previous pixel
                        // a shadow should be darkest at the edge of the image, not hte other way round
                        {
                            borderPixels++;
                            if (borderPixels>5)
                                break;   // if we have found five pixels which meet the borderPixel specs, break;
                        }

                        else
                        {
                            errors++;
                            if (errors>3)
                                break;          // if we recieve more than 3 errors, break
                        }

                        searchPosition+=step;
                    }
                    endPoint=y+5; // because of edge enhancement, we set the shadow width to be a bit more than it actually is
                    searchPosition+=2*step; // skip a couple of pixels because we may have missed the last couple of pixels of the shadow

                    nonBackgroundPixels=0;
                    backgroundPixels=0;

                    for (;y<20;y++) // we expect the next few pixels to be background pixels
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];


                        if (r < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            && g < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            && b < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            // WARNING: commenting out the following 3 lines may greatly increases the number of innocent pixels that are deleted
                            && sourceR < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                            && sourceG < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                            && sourceB < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                           )
                            backgroundPixels++;
                        else
                        {
                            nonBackgroundPixels++;
                        }

                        if ((nonBackgroundPixels)>(backgroundPixels+4))
                        {  // no way this is actually a shadow we are deleting
                            y=0;
                            break;
                        }
                        if (backgroundPixels>7) break;

                        searchPosition+=step;
                    }

                    // we only have a shadow if we get a number of dark pixels followed by a number light pixels
                    if (nonBackgroundPixels<3 && backgroundPixels>5 && borderPixels>errors && y!=0)
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint);
                    }
                }






                // this is designed to kill a different kind of shadow, a light shadow far from any objects
                // this code can be safely eliminated
                //

                r=pBlurredBits[position];
                g=pBlurredBits[position+1];
                b=pBlurredBits[position+2];


                if (r>(minBlackBorderPixel/6)&&g>(minBlackBorderPixel/6)&&b>(minBlackBorderPixel/6))
                {
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    for (y=1;y<11;y++)
                    {
                        dr=(int)pBlurredBits[searchPosition]-r;
                        dg=(int)pBlurredBits[searchPosition+1]-g;
                        db=(int)pBlurredBits[searchPosition+2]-b;

                        r=(int)pBlurredBits[searchPosition];
                        g=(int)pBlurredBits[searchPosition+1];
                        b=(int)pBlurredBits[searchPosition+2];

                        // much looser requirements for being a shadow
                        if (r>minBlackBorderPixel/7&&g>minBlackBorderPixel/7&&b>minBlackBorderPixel/7)
                        {
                            borderPixels++;
                        }

                        else
                        {
                            errors++;
                        }

                        searchPosition+=step;
                    }
                    endPoint=y-3;
                    searchPosition+=5*step;

                    nonBackgroundPixels=0;
                    backgroundPixels=0;

                    for (;y<35;y++)
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];

                        // much stricter requirements for being a background pixel
                        // with these stricter requirements, we are almost guaranteed not to eliminate any
                        // valid pixels while searching for black borders
                        // the idea is balancing looser requirements in one area with stricter requirements in another
                        if (r < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && g < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && b < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && sourceR < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                            && sourceG < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                            && sourceB < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                           )
                            backgroundPixels++;
                        else
                        {
                            nonBackgroundPixels++;
                            break;
                        }
                        searchPosition+=step;
                    }

                    if (nonBackgroundPixels==0) // the pixel isn't a shadow pixel unless all of the backgroundPixels tested were background pixels
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint); // update the shadowDepth for the pixel
                        // corners can be very problematic
                        // because this algorithm will by definition fail on any corner line
                        // so we cheat...

                        if (x<CORNER_WIDTH)
                        {
                            for (i=0;i<CORNER_WIDTH;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                        if (x+CORNER_WIDTH>width)
                        {
                            for (i=width-CORNER_WIDTH;i<width;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                    }
                }






                // this is designed to kill a different kind of shadow, a small light shadow close to objects
                // this code can be safely eliminated
                // it was mainly written simply to explore the problem space of border elimination
                //
                // if this code is saved beyond a couple of test runs, we will need to turn some of its constants into real constants
                // it seems from prelim tests that this code may be preferable to the previous test function

                {
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    nonBackgroundPixels=0;
                    backgroundPixels=0;
                    longestBackgroundPixelString=0;
                    endPoint=0;

                    // we don't bother with looking for a string of black pixels in this case
                    // which is probably more intelegent than the previous code blocks
                    // instead we simply look for long strings of background pixels
                    // while at the same time, terminating the search of we come across too many non-background pixels

                    for (y=0;y<16;y++)
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];


                        if (r < 24
                            && g < 24
                            && b < 24
                            && sourceR < 12
                            && sourceG < 12
                            && sourceB < 12
                           )
                            backgroundPixels++;
                        else
                        {
                            if (y>5) nonBackgroundPixels++;
                            if (backgroundPixels>longestBackgroundPixelString)
                            {
                                endPoint=y;
                                longestBackgroundPixelString=backgroundPixels;
                            }
                            backgroundPixels=0;
                            if (nonBackgroundPixels>1) break;
                        }
                        searchPosition+=step;
                    }

                    if (backgroundPixels>longestBackgroundPixelString)  // was the longestBackgroundPixelString the last?
                    {
                        longestBackgroundPixelString=backgroundPixels;
                        endPoint=16;
                    }

                    if (longestBackgroundPixelString>6)
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint-4);
                        // corners can be problematic
                        // because this algorithm will by definition fail on a black corner
                        // so we cheat...

                        if (x<CORNER_WIDTH)
                        {
                            for (i=0;i<CORNER_WIDTH;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                        if (x+CORNER_WIDTH>width)
                        {
                            for (i=width-CORNER_WIDTH;i<width;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }
                    }
                }


                position+=dx*4; // increment the position by 1 unit to go to the next row
            }

            for (x=0;x<width;x++)
            {
                pTempShadowDepths[x]=pShadowDepths[x];
            }

            if (SMOOTH_BORDER) // shadows don't just come out of nowhere, if row x has a depth 20 shadow, its likely that we made a mistake and pixel x-1 also has a depth 20 shadow
            {
                for (x=2;x<width-2;x++)
                {
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x-1]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x+1]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x-2]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x+2]);
                }
            }

            // now remove the black border
            // we loop through all rows x and then eliminate the first pTempShadowDepths[x] pixels in that row
            position=startPosition;
            step=dy;
            for (x=0;x<width;x++)
            {
                newPosition=position;
                for (y=0;y<pTempShadowDepths[x];y++)
                {
                    pBitmapPixels[newPosition]=DEAD_PIXEL; // set each shadow to be a dead pixel
                    // dead pixels are the only pixels not vulnerable to edge enhancements...
                    // important if we do any KillShadows edge enhancement passes after calling kill black border

                    if (VISUAL_DEBUG)
                        pDebugPixels[newPosition]=((pDebugPixels[newPosition] & 0xfefefe)>>1)+((DEBUGCOLOR& 0xfefefe)>>1);

                    newPosition+=step;
                }
                position+=dx;
            }
        }

        // clean up our memory
        delete[] pTempShadowDepths;
        delete[] pShadowDepths;
    }
}


// dib manipulation functions
// the following are dib wrapper functions stolen and then modified... from utils.cpp
// these functions are now obsolete and only used in region debug mode
// where we need to load bitmaps from files
/*******************************************************************************
*
*  SetBMI
*
*  DESCRIPTION:
*   Setup bitmap info.
*
*  PARAMETERS:
*
*******************************************************************************/


void SetBMI( PBITMAPINFO pbmi, LONG width, LONG height, LONG depth)
{
    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = width;
    pbmi->bmiHeader.biHeight          = height;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = (WORD) depth;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;
}

/*******************************************************************************
*
*  AllocDibFileFromBits
*
*  DESCRIPTION:
*   Given an unaligned bits buffer, allocate a buffer lager enough to hold the
*   DWORD aligned DIB file and fill it in.
*
*  PARAMETERS:
*
*******************************************************************************/

PBYTE AllocDibFileFromBits( PBYTE pBits, UINT width, UINT height, UINT depth)
{
    PBYTE pdib;
    UINT  uiScanLineWidth, uiSrcScanLineWidth, cbDibSize;
    int bitsSize;
    // Align scanline to ULONG boundary
    uiSrcScanLineWidth = (width * depth) / 8;
    uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

    // DEBUG:
//   uiSrcScanLineWidth=uiScanLineWidth;
    // Calculate DIB size and allocate memory for the DIB.
    bitsSize=height * uiScanLineWidth;
    cbDibSize = bitsSize+sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFO);
    pdib = (PBYTE) LocalAlloc(LMEM_FIXED, cbDibSize);
    if (pdib)
    {
        PBITMAPFILEHEADER pbmfh = (PBITMAPFILEHEADER)pdib;
        PBITMAPINFO       pbmi  = (PBITMAPINFO)(pdib + sizeof(BITMAPFILEHEADER));
        PBYTE             pb    = (PBYTE)pbmi+ sizeof(BITMAPINFO);

        // Setup bitmap file header.
        pbmfh->bfType = 'MB';
        pbmfh->bfSize = cbDibSize;
        pbmfh->bfOffBits = static_cast<DWORD>(pb - pdib);

        // Setup bitmap info.
        SetBMI(pbmi,width, height, depth);

//      WIA_TRACE(("AllocDibFileFromBits, uiScanLineWidth: %d, pdib: 0x%08X, pbmi: 0x%08X, pbits: 0x%08X", uiScanLineWidth, pdib, pbmi, pb));

        // Copy the bits.
        pb-=3;
        pBits-=3; // BUG FIX BECAUSE THE PERSON WHO WROTE THIS COULDN'T KEEP THEIR BITS STRAIGHT
        memcpy(pb, pBits, bitsSize);
    }
    else
    {
        //    WIA_ERROR(("AllocDibFileFromBits, LocalAlloc of %d bytes failed", cbDibSize));
    }
    return(pdib);
}

/*******************************************************************************
*
*  DIBBufferToBMP
*
*  DESCRIPTION:
*   Make a BMP object from a DWORD aligned DIB file memory buffer
*
*  PARAMETERS:
*
*******************************************************************************/

HBITMAP DIBBufferToBMP(HDC hDC, PBYTE pDib, BOOLEAN bFlip)
{
    HBITMAP     hBmp  = NULL;
    PBITMAPINFO pbmi  = (BITMAPINFO*)(pDib);
    PBYTE       pBits = pDib + GetBmiSize(pbmi);

    if (bFlip)
    {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }
    hBmp = CreateDIBitmap(hDC, &pbmi->bmiHeader, CBM_INIT, pBits, pbmi, DIB_RGB_COLORS);
    if (!hBmp)
    {
        ;//WIA_ERROR(("DIBBufferToBMP, CreateDIBitmap failed %d", GetLastError(void)));
    }
    return(hBmp);
}

/*******************************************************************************
*
*  ReadDIBFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT ReadDIBFile(LPTSTR pszFileName, PBYTE *ppDib)
{
    HRESULT  hr = S_FALSE;
    HANDLE   hFile, hMap;
    PBYTE    pFile, pBits;

    *ppDib = NULL;
    hFile = CreateFile(pszFileName,
                       GENERIC_WRITE | GENERIC_READ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        //WIA_ERROR(("ReadDIBFile, unable to open %s", pszFileName));
        return(hr);
    }

    hMap = CreateFileMapping(hFile,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             0,
                             NULL);
    if (!hMap)
    {
        //WIA_ERROR(("ReadDIBFile, CreateFileMapping failed"));
        goto close_hfile_exit;
    }

    pFile = (PBYTE)MapViewOfFileEx(hMap,
                                   FILE_MAP_READ | FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0,
                                   NULL);
    if (pFile)
    {
        PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile + sizeof(BITMAPFILEHEADER));

        // validate bitmap
        if (pbmFile->bfType == 'MB')
        {
            // Calculate color table size.
            LONG bmiSize, ColorMapSize = 0;

            if (pbmi->bmiHeader.biBitCount == 1)
            {
                ColorMapSize = 2 - 1;
            }
            else if (pbmi->bmiHeader.biBitCount == 4)
            {
                ColorMapSize = 16 - 1;
            }
            else if (pbmi->bmiHeader.biBitCount == 8)
            {
                ColorMapSize = 256 - 1;
            }
            bmiSize = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * ColorMapSize;
            pBits = pFile + sizeof(BITMAPFILEHEADER) + bmiSize;

            *ppDib = AllocDibFileFromBits(pBits,
                                          pbmi->bmiHeader.biWidth,
                                          pbmi->bmiHeader.biHeight,
                                          pbmi->bmiHeader.biBitCount);
            if (*ppDib)
            {
                hr = S_OK;
            }
        }
        else
        {
            //WIA_ERROR(("ReadDIBFile, %s is not a valid bitmap file", pszFileName));
        }
    }
    else
    {
        //WIA_ERROR(("ReadDIBFile, MapViewOfFileEx failed"));
        goto close_hmap_exit;
    }

    UnmapViewOfFile(pFile);
    close_hmap_exit:
    CloseHandle(hMap);
    close_hfile_exit:
    CloseHandle(hFile);
    return(hr);
}

/*******************************************************************************
*
*  GetBmiSize
*
*  DESCRIPTION:
*   Should never get biCompression == BI_RLE.
*
*  PARAMETERS:
*
*******************************************************************************/

LONG GetBmiSize(PBITMAPINFO pbmi)
{
    // determine the size of bitmapinfo
    LONG lSize = pbmi->bmiHeader.biSize;

    // no color table cases
    if (
       (pbmi->bmiHeader.biBitCount == 24) ||
       ((pbmi->bmiHeader.biBitCount == 32) &&
        (pbmi->bmiHeader.biCompression == BI_RGB)))
    {

        // no colors unless stated
        lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;
        return(lSize);
    }

    // bitfields cases
    if (((pbmi->bmiHeader.biBitCount == 32) &&
         (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
        (pbmi->bmiHeader.biBitCount == 16))
    {

        lSize += 3 * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 1)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 2))
        {
            lPal = 2;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 4)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 16))
        {
            lPal = 16;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 8)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 256))
        {
            lPal = 256;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // error
    return(0);
}

INT GetColorTableSize (UINT uBitCount, UINT uCompression)
{
    INT nSize;


    switch (uBitCount)
    {
    case 32:
        if (uCompression != BI_BITFIELDS)
        {
            nSize = 0;
            break;
        }
        // fall through
    case 16:
        nSize = 3 * sizeof(DWORD);
        break;

    case 24:
        nSize = 0;
        break;

    default:
        nSize = ((UINT)1 << uBitCount) * sizeof(RGBQUAD);
        break;
    }

    return(nSize);
}

DWORD CalcBitsSize (UINT uWidth, UINT uHeight, UINT uBitCount, UINT uPlanes, int nAlign)
{
    int    nAWidth,nHeight,nABits;
    DWORD  dwSize;


    nABits  = (nAlign << 3);
    nAWidth = nABits-1;


    //
    // Determine the size of the bitmap based on the (nAlign) size.  Convert
    // this to size-in-bytes.
    //
    nHeight = uHeight * uPlanes;
    dwSize  = (DWORD)(((uWidth * uBitCount) + nAWidth) / nABits) * nHeight;
    dwSize  = dwSize * nAlign;

    return(dwSize);
}

//
// Converts hBitmap to a DIB
//
HGLOBAL BitmapToDIB (HDC hdc, HBITMAP hBitmap)
{
    BITMAP bm = {0};
    HANDLE hDib;
    PBYTE  lpDib,lpBits;
    DWORD  dwLength;
    DWORD  dwBits;
    UINT   uColorTable;
    INT    iNeedMore;
    BOOL   bDone;
    INT    nBitCount;
    //
    // Get the size of the bitmap.  These values are used to setup the memory
    // requirements for the DIB.
    //
    if (GetObject(hBitmap,sizeof(BITMAP),reinterpret_cast<PVOID>(&bm)))
    {
        nBitCount = bm.bmBitsPixel * bm.bmPlanes;
        uColorTable  = GetColorTableSize((UINT)nBitCount, BI_RGB);
        dwBits       = CalcBitsSize(bm.bmWidth,bm.bmHeight,nBitCount,1,sizeof(DWORD));

        do
        {
            bDone = TRUE;

            dwLength     = dwBits + sizeof(BITMAPINFOHEADER) + uColorTable;


            // Create the DIB.  First, to the size of the bitmap.
            //
            if (hDib = GlobalAlloc(GHND,dwLength))
            {
                if (lpDib = reinterpret_cast<PBYTE>(GlobalLock(hDib)))
                {
                    ((LPBITMAPINFOHEADER)lpDib)->biSize          = sizeof(BITMAPINFOHEADER);
                    ((LPBITMAPINFOHEADER)lpDib)->biWidth         = (DWORD)bm.bmWidth;
                    ((LPBITMAPINFOHEADER)lpDib)->biHeight        = (DWORD)bm.bmHeight;
                    ((LPBITMAPINFOHEADER)lpDib)->biPlanes        = 1;
                    ((LPBITMAPINFOHEADER)lpDib)->biBitCount      = (WORD)nBitCount;
                    ((LPBITMAPINFOHEADER)lpDib)->biCompression   = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biSizeImage     = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biXPelsPerMeter = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biYPelsPerMeter = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biClrUsed       = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biClrImportant  = 0;


                    // Get the size of the bitmap.
                    // The biSizeImage contains the bytes
                    // necessary to store the DIB.
                    //
                    GetDIBits(hdc,hBitmap,0,bm.bmHeight,NULL,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                    iNeedMore = ((LPBITMAPINFOHEADER)lpDib)->biSizeImage - dwBits;

                    if (iNeedMore > 0)
                    {
                        dwBits = dwBits + (((iNeedMore + 3) / 4)*4);
                        bDone = FALSE;
                    }
                    else
                    {
                        lpBits = lpDib+sizeof(BITMAPINFOHEADER)+uColorTable;
                        GetDIBits(hdc,hBitmap,0,bm.bmHeight,lpBits,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                        GlobalUnlock(hDib);

                        return(hDib);
                    }

                    GlobalUnlock(hDib);
                }

                GlobalFree(hDib);
            }
        }
        while (!bDone);
    }
    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\32bitdib.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       32BITDIB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      t-JacobR
 *
 *  DATE:        1/11/2000
 *
 *  DESCRIPTION:
 *
 *  C32BitDibWrapper provides support for a number of common graphics special
 *  effects for this class, 32 bit dibs are stored in the following format: 8
 *  ignored high order bits followed by 8 bits per RGB chan.  warning: many
 *  functions in this class will reset the 8 high order bits so it is not
 *  practical to add additional functions which use an 8 bit alpha chan
 *
 *  Notes:
 *
 *  The blur function is designed so that it can be combined with the
 *  difference function to create an edge detection filter More specifically,
 *  the blur function takes the average of only the four pixels around the
 *  current pixel instead of including the current pixel in the average.
 *
 *******************************************************************************/

#ifndef __32BITDIB_H_INCLUDED
#define __32BITDIB_H_INCLUDED

//
// Constants used for Region Detection
//
#define MERGE_REGIONS            TRUE
#define MAXREGIONS               10000
#define PHOTOGRAPH_REGION        1
#define TEXT_REGION              2

//
// We don't want lowlife text regions which are probably stray dots merging with
// photograph regions this id certifies that a text region is big enough to merge
// with a photograph
//
#define MERGABLE_WITH_PHOTOGRAPH 16

//
// how many pixels before you are too big to even imagine that you are a stray blot
//
#define LARGEREGION_THRESHOLD 10000

//
// pixels
//
#define MINREGIONSIZE 10

//
// how far down should we sample the the image?
// goal to sample down the image to
//
#define GOALX 300
#define GOALY 400

//
// borderline in function between text regions and photo regions
//
#define MIN_BORDERLINE_TEXTPHOTO 10

//
// If in borderline, we apply extra functions to determine if its really
// a text region or not
//
#define TEXTPHOTO_THRESHOLD        15
#define MAX_BORDERLINE_TEXTPHOTO   1500


//
// Note... we won't consider merging two photo regions if both regions
// are greater than MAX_MERGABLE_PHOTOGRAPH_SIZE
//
#define MAX_MERGE_PHOTO_REGIONS                  2
#define MAX_NO_EDGE_PIXEL_REGION_PENALTY         16


//
// Maximum merge radius for regions where one region is text and one is a photo region
//
#define MAX_MERGE_DIFFERENT_REGIONS              13

//
// If you are close to the edge after this long you very well might be a stray blot
//
#define BORDER_EXTREME_EDGE_PIXEL_REGION_PENALTY 45

//
// maximum merging radius for text regions merged with text regions
// note: no merging takes place between photo regions and photo regions
//
#define MAXBORDER 65

//
// maximum border width where we can look the other way when it comes to
// collision detection collsion detection is somewhat expensive so only use
// it when we are dealing with signifigant spacings.  we only want to use
// collision detection to make sure that we don't create regions through
// previously deleted shadows, etc.  constants for deciding if a region is a
// valid region
//
// NOTE: we never do collision detection for merging photo regions...  for
// obvious reasons...  we only want to merge photo regions which are part of
// the same region...  hence we would actually only want to merge photograph
// regions where there was a pretty high collision factor
//
#define MERGABLE_WITHOUT_COLLISIONDETECTION 668

//
// minimum region width
//
#define MINWIDTH 5
#define MINPHOTOWIDTH 5

//
// maximum ratio between height and width
//
#define MAXREGIONRATIO 81
#define MAXPHOTORATIO 81
#define MINSIZE 30

//
// if you are more than 6 pixels wide, you are ok.  we don't care what your aspect ratio is
//
#define IGNORE_RATIO_WIDTH 6

//
// number of pixels required before we throw a region out as being just a
// stray dot (10 x 10 so it isn't a huge requirement)
//
#define MINREGIONPIXELS 20

//
// very conservative
//
#define MINPPHOTOSELECTEDFACTOR 5

//
// conservative.. its unlikely that many regions will have edge factors this low
//
#define MINEDGEFACTOR 5

//
// allow a couple of black pixels without going crazy
//
#define MAX_RESISTANCE_ALLOWED_TO_UNION 1024

#define DONE_WITH_BORDER_CHECKING -1
#define MIN_FINAL_REGION_SIZE 38

#define CLOSE_TO_EDGE_PENALTY_WIDTH 3

//
// the following are designed to weed out speckles.  these are only applied
// after we have increased the border past MAX_MERGE_DIFFERENT_REGIONS.  so
// all that should be left is small text regions and long and narrow
// speckles.
//

//
// no close to edge penalty factor
//
#define CLOSE_TO_EDGE_PENALTY_FACTOR 1

#define UNKNOWN -1

#define EDGE_PENALTY_WIDTH 2

//
// 2x all requirements if region is within EDGE_PENALTY_WIDTH from the edge
// of the image.  some requirements may be multiplied by EDGE_PENALTY_FACTOR
// squared...  i.e.  for 2D requirments like num of pixels
//
#define EDGE_PENALTY_FACTOR 1

#define COMPARISON_ERROR_RADIUS 2

//
// constants used for findchunk filters so that we aren't lead astray by the
// possible black ring around the image
//
#define VERTICAL_EDGE -1
#define HORIZONTAL_EDGE -2

//
// a nice massive stack which is large enough that we are gauranteed never to exceed it
//
#define MAXSTACK (GOALX*GOALY)

//
// we do two remove shadow passes.
// one pass is intended to only remove shadows
// the other is designed to handle scanners which have yellow lids, etc.
//

//
// maximum intensity allowed for first pixel of a shadow..  we used to
// think that we should only let shadows start at 0...  that was before we
// saw the light
//
#define MAXSHADOWSTART 800

//
// maximum edge value permitted for a shadow pixel
//
#define MAXSHADOWPIXEL 3

//
// if we are near the edge, we want to kill anything that is remotely like a shadow
//
#define MAXEDGESHADOWPIXEL 20

#define MAX_DIFFERENCE_FROM_GRAY 690

//
// border where we do tougher despeckle & edge filters...
//
#define DESPECKLE_BORDER_WIDTH 6

//
// the background color remove shadows algorithm pass is at the moment the
// same as the first pass.  we may later want to optumize it to better do its
// specific task..  for example...  for this filter, we could care less about
// if a pixel isn't grey
//

//
// accept all pixels
//
#define FIX_BACKGROUND_MAXSHADOWSTART 800
#define FIX_BACKGROUND_MAXSHADOWPIXEL 2

//
// maximum intensity to be considered a bonified text region background pixel
//
#define TEXT_REGION_BACKGROUND_THRESHOLD 31

//
// this if for use with Pixels below Threshold which should be called using
// the origional image...  not an inverted image
//

//
// minimum edge value to earn the distinguished title of being a text region edge pixel
//
#define MIN_TEXT_REGION_BACKGROUND_EDGE 32

//
// minimum edge value to earn the distinguished title of being a text region edge pixel
//
#define MIN_TEXT_REGION_BACKGROUND_EDGE_CLIPPED_PIXEL 120

#define CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD 180

//
// not implemented yet
//
#define TEXT_REGION_BACKGROUND_PIXEL_MAX_CLIPPED_DIFFERENCE_FROM_GREY 32

//
// minimum intensity to select a pixel
//
#define MIN_CHUNK_INTENSITY 48

//
// should be 0, but different values are useful for debugging...  although
// extreme values will potentially mess up region detection its the color we
// set erased shadow bits
//
#define ERASEDSHADOW 0

// beta constants:
//
// idea: inverted images... and constant color image potential problems
//
#define COLLISION_DETECTION_HIGHPASS_VALUE 600

//
// if a photograph gets fragmented we will see a bunch of closely spaced and
// relatively small regions only one of the two regions has to be bellow this
// size requirement to merge them as part way through the merge proccess we
// will be definition have a larger region than this const or the const isn't
// fullfilling its purpose
//
#define MAX_MERGABLE_PHOTOGRAPH_SIZE 30000

#define NOT_SHADOW 0x800ff09

//
// a pixel which we are sure is bad and that we will no
// rejuvinate no matter that edge val it may have
//
#define DEAD_PIXEL  0x8000002

//
// minimum edge intensity to classify a pixel as NOT_SHADOW
//
#define NOT_SHADOW_INTENSITY 28

#define MIN_WALL_INTENSITY 200

#define MIN_BLACK_SCANNER_EDGE_CHAN_VALUE 110

#define MAX_BLACK_BORDER_DELTA 12

#define MAX_KILL_SHADOW_BACKGROUND_APROXIMATION 64
#define MAX_KILL_SHADOW_BACKGROUND_UNEDITED 200

//
// further ideas: to eliminate the possibility of embarassing errors: count
// the number of background pixels if the num of background pixels is above a
// threshold use weaker shadow and edge filters as we probably have a good
// scanner something like if half the page is defined as background pixels
// dangers: white page on a horrible scanner
//


//
// MORE IMPORTANTLY: also the select region search radius TIP: if you are
// running multiple region selection, an EDGEWIDTH of 3 or more could limit
// your options considerably as nearby regions may get merged together
// particularly when using edge enhancement and when GOALX is set at 300 or
// less
//
#define EDGEWIDTH 2

//
// color used to highlight clipped pixels while debugging the code for eliminating black borders
//
#define DEBUGCOLOR  0xff0000

#define FIGHTING_EDGES FALSE

//
// you better be darn close to grey to get marked as NOT_SHADOW fighting
// edges involve pixeled being marked as not possibly being edges as well as
// pixels
//
#define FIGHTING_EDGES_DIFF_FROM_GREY 10

//
// being marked as definite edges
//
#define FIGHTING_EDGE_MIN_MARK_PIXEL 10
#define FIGHTING_EDGE_MAX_MARK_PIXEL 210

#define FIGHTING_EDGE_MAX_EDGE 1

#define BORDER_EDGE 0xfffffff

//
// used for killing the black border around the page
//
#define CORNER_WIDTH 5

//
// used for black border removal
//
#define SHADOW_HEIGHT 10
#define VISUAL_DEBUG FALSE
#define SMOOTH_BORDER FALSE

//
// amount to increase border while unioning together regions for single region
// region detection
//
#define SINGLE_REGION_BORDER_INCREMENT 4


class C32BitDibWrapper
{
private:
    //
    // No implementation
    //
    C32BitDibWrapper &operator=( const C32BitDibWrapper & );
    C32BitDibWrapper( const C32BitDibWrapper & );

public:
    explicit C32BitDibWrapper(BITMAP pBitmap);

    //
    // Copy constructor... create a new dib wrapper with a copy of all the data in the other dib wrapper
    //
    explicit C32BitDibWrapper(C32BitDibWrapper *pBitmap);

    //
    // construct wrapper from a dib
    //
    explicit C32BitDibWrapper(BYTE* pDib);

    //
    // creates an uninitialized dib wrapper
    //
    C32BitDibWrapper(void);

    //
    // creates a blank dib
    //
    C32BitDibWrapper(int w, int h);

    virtual ~C32BitDibWrapper(void);

    void Destroy(void);

    //
    // functions for common graphics effects
    //
    int Blur(void);
    BYTE* pointerToBlur(void);
    BYTE* pointerToHorizontalBlur(void);
    BYTE* pointerToVerticalBlur(void);
    int CreateBlurBitmap(C32BitDibWrapper * pSource);
    int CreateHorizontalBlurBitmap(C32BitDibWrapper * pSource);
    int CreateVerticalBlurBitmap(C32BitDibWrapper * pSource);

    //
    // Creates a new dib where each pixel is equal to the difference
    // of the pixel values for the other two dibs
    //
    int CreateDifferenceBitmap (C32BitDibWrapper *pBitmap1, C32BitDibWrapper *pBitmap2);

    int KillShadows(C32BitDibWrapper * pEdgeBitmap, ULONG start, ULONG maxPixel, ULONG differenceFromGrey, ULONG min_guaranteed_not_shadow, bool enhanceEdges);
    void RemoveBlackBorder(int minBlackBorderPixel, C32BitDibWrapper * outputBitmap,C32BitDibWrapper * debugBitmap);

    //
    // resample image down to half size
    //
    int HalfSize(void);

    //
    // resample image down to half intensity
    //
    int HalfIntensity(void);
    void Invert(void);

    //
    // less common graphics filters:
    //
    void Despeckle(void);

    //
    // only despeckle the outer edge of pixels in the image
    //
    void EdgeDespeckle(void);

    //
    // despeckles the ith pixel in a bitmap
    //
    void DespecklePixel(ULONG* bitmapPixels, int i, bool edgePixel);

    void CorrectBrightness(void);
    void MaxContrast(UINT numPixelsRequired);

    void AdjustForBadScannerBedColor(C32BitDibWrapper * edgeBitmap);

    //
    // Similar to a photoshop magic wand.. just we try to run our magic wand starting from ever possible pixel
    //
    int FindChunks(int * pMap);

    //
    // display selected chunks... for debugging purposes mostly
    //
    void ColorChunks(int * pMap);

    int PixelsBelowThreshold(C32BitDibWrapper* pProccessed, C32BitDibWrapper * pEdges, RECT region);

    BYTE* ConvertBitmap(BYTE* pSource, int bitsPerSource, int bitsPerDest);

    //
    // for debugging purposes only
    // MyBitBlt is horribly slow as we manually convert the
    // bitmap to a 24 bit dib before displaying
    //
    int Draw(HDC hdc, int x, int y);

    inline void SetPixel(int x, int y, ULONG color);
    inline ULONG GetPixel(int x, int y);

    //
    // calculates the total color intensity of a line
    //
    ULONG Line(int x1, int y1, int x2, int y2);

private:
    //
    // line drawing helper functions
    //
    ULONG Octant0(int X0, int Y0,int DeltaX,int DeltaY,int XDirection);
    ULONG Octant1(int X0, int Y0,int DeltaX,int DeltaY,int XDirection);

    //
    // kill borders helper function:
    //
    void KillBlackBorder(int minBlackBorderPixel, int startPosition, int width, int height, int dx, int dy, C32BitDibWrapper *pOutputBitmap, C32BitDibWrapper * pDebugBitmap);

public:
    void CompensateForBackgroundColor(int r, int g, int b);
    ULONG CalculateBackgroundColor(void);

    bool IsValid(void)
    {
        return (m_pBits && m_nBitmapWidth != -1 && m_nBitmapHeight != -1);
    }

public:
    BYTE *m_pBits;
    int m_nBitmapWidth;
    int m_nBitmapHeight;
};

//
// dib manipulation functions
//
void    SetBMI( PBITMAPINFO pbmi, LONG width, LONG height, LONG depth );
PBYTE   AllocDibFileFromBits( PBYTE pBits, UINT width, UINT height, UINT depth );
HBITMAP DIBBufferToBMP( HDC hDC, PBYTE pDib, BOOLEAN bFlip );
HRESULT ReadDIBFile( LPTSTR pszFileName, PBYTE *ppDib );
LONG    GetBmiSize( PBITMAPINFO pbmi );
INT     GetColorTableSize( UINT uBitCount, UINT uCompression );
DWORD   CalcBitsSize( UINT uWidth, UINT uHeight, UINT uBitCount, UINT uPlanes, int nAlign );
HGLOBAL BitmapToDIB( HDC hdc, HBITMAP hBitmap );

#endif // __32BITDIB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\createtb.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CREATETB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/22/2000
 *
 *  DESCRIPTION: Toolbar helpers
 *
 *******************************************************************************/
#ifndef __CREATETB_H_INCLUDED
#define __CREATETB_H_INCLUDED

#include <windows.h>
#include <commctrl.h>

namespace ToolbarHelper
{
    class CToolbarBitmapInfo
    {
    private:
        HBITMAP   m_hBitmap;
        HWND      m_hWndToolbar;
        HINSTANCE m_hToolbarInstance;
        UINT_PTR  m_nBitmapResId;
        int       m_nButtonCount;

    private:
        CToolbarBitmapInfo();

    public:
        CToolbarBitmapInfo( HINSTANCE hToolbarInstance, UINT_PTR nBitmapResId )
          : m_hToolbarInstance(hToolbarInstance),
            m_nBitmapResId(nBitmapResId),
            m_nButtonCount(0),
            m_hBitmap(NULL),
            m_hWndToolbar(NULL)
        {
        }
        CToolbarBitmapInfo( const CToolbarBitmapInfo &other )
          : m_hToolbarInstance(other.ToolbarInstance()),
            m_nBitmapResId(other.BitmapResId()),
            m_nButtonCount(other.ButtonCount()),
            m_hBitmap(other.Bitmap()),
            m_hWndToolbar(other.Toolbar())
        {
        }
        CToolbarBitmapInfo &operator=( const CToolbarBitmapInfo &other )
        {
            if (this != &other)
            {
                m_hToolbarInstance = other.ToolbarInstance();
                m_nBitmapResId = other.BitmapResId();
                m_nButtonCount = other.ButtonCount();
                m_hBitmap = other.Bitmap();
                m_hWndToolbar = other.Toolbar();
            }
            return *this;
        }
        HBITMAP Bitmap() const
        {
            return m_hBitmap;
        }
        void Bitmap( HBITMAP hBitmap )
        {
            WIA_PUSH_FUNCTION((TEXT("CToolbarBitmapInfo::Bitmap: 0x%p"), hBitmap ));
            m_hBitmap = hBitmap;
        }
        HWND Toolbar() const
        {
            return m_hWndToolbar;
        }
        void Toolbar( HWND hWndToolbar )
        {
            m_hWndToolbar = hWndToolbar;
        }
        HINSTANCE ToolbarInstance() const
        {
            return m_hToolbarInstance;
        }
        UINT_PTR BitmapResId() const
        {
            return m_nBitmapResId;
        }
        int ButtonCount() const
        {
            return m_nButtonCount;
        }
        void ButtonCount( int nButtonCount )
        {
            m_nButtonCount = nButtonCount;
        }
        bool ReloadAndReplaceBitmap()
        {
            WIA_PUSH_FUNCTION((TEXT("CToolbarBitmapInfoReloadAndReplaceBitmap( m_hWndToolbar: 0x%p, m_hBitmap: 0x%p, m_hToolbarInstance: 0x%p, m_nBitmapResId: %d )"), m_hWndToolbar, m_hBitmap, m_hToolbarInstance, m_nBitmapResId ));
            bool bResult = false;
            if (m_hWndToolbar && m_hBitmap && m_hToolbarInstance && m_nBitmapResId)
            {
                HBITMAP hNewBitmap = CreateMappedBitmap( m_hToolbarInstance, m_nBitmapResId, 0, NULL, 0 );
                if (hNewBitmap)
                {
                    TBREPLACEBITMAP TbReplaceBitmap = {0};
                    TbReplaceBitmap.nIDOld = reinterpret_cast<UINT_PTR>(m_hBitmap);
                    TbReplaceBitmap.nIDNew = reinterpret_cast<UINT_PTR>(hNewBitmap);
                    TbReplaceBitmap.nButtons = m_nButtonCount;
                    if (SendMessage( m_hWndToolbar, TB_REPLACEBITMAP,0,reinterpret_cast<LPARAM>(&TbReplaceBitmap)))
                    {
                        m_hBitmap = hNewBitmap;
                        bResult = true;

                        //
                        // Ensure that we don't free this bitmap
                        //
                        hNewBitmap = NULL;
                    }
                    else
                    {
                        WIA_TRACE((TEXT("TB_REPLACEBITMAP failed!")));
                    }
                }
                else
                {
                    WIA_TRACE((TEXT("Unable to load bitmap!")));
                }

                //
                // Prevent GDI leak
                //
                if (hNewBitmap)
                {
                    DeleteObject( hNewBitmap );
                }
            }
            else
            {
                WIA_TRACE((TEXT("Validation error: m_hWndToolbar: 0x%p, m_hBitmap: 0x%p, m_hToolbarInstance: 0x%p, m_nBitmapResId: %d"), m_hWndToolbar, m_hBitmap, m_hToolbarInstance, m_nBitmapResId ));
            }
            return bResult;
        }
    };

    struct CButtonDescriptor
    {
        int   iBitmap;
        int   idCommand;
        BYTE  fsState;
        BYTE  fsStyle;
        bool  bFollowingSeparator;
        bool *pbControllingVariable;
        int   nStringResId;
    };
    
    enum
    {
        AlignLeft     = 0x00000000,
        AlignHCenter  = 0x00000001,
        AlignRight    = 0x00000002,
        AlignTop      = 0x00000000,
        AlignVCenter  = 0x00000004,
        AlignBottom   = 0x00000008
    };
    
    HWND CreateToolbar( 
        HWND hWndParent, 
        HWND hWndPrevious,
        HWND hWndAlign,
        int Alignment,
        UINT nToolbarId,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        CButtonDescriptor *pButtonDescriptors, 
        UINT nDescriptorCount );
    void SetToolbarButtonState( HWND hWndToolbar, int nButtonId, int nState );
    void EnableToolbarButton( HWND hWndToolbar, int nButtonId, bool bEnable );
    void CheckToolbarButton( HWND hWndToolbar, int nButtonId, bool bChecked );
    UINT GetButtonBarAccelerators( HWND hWndToolbar, ACCEL *pAccelerators, UINT nMaxCount );
}

#endif // __CREATETB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\createtb.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CREATETB.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/22/2000
 *
 *  DESCRIPTION: Toolbar helpers
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "createtb.h"
#include <windowsx.h>
#include <simstr.h>
#include <psutil.h>
#include <simrect.h>

namespace ToolbarHelper
{
    //
    // This is a replacement for CreateToolbarEx (in comctl32.dll) that uses CreateMappedBitmap
    // so we can get the benefit of having buttons that work ok in high contrast mode.
    //
    HWND CreateToolbar(
        HWND hwndParent, 
        DWORD dwStyle, 
        UINT_PTR nID,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        LPCTBBUTTON pButtons,
        int nButtonCount,
        int nButtonWidth, 
        int nButtonHeight,
        int nBitmapWidth, 
        int nBitmapHeight, 
        UINT nButtonStructSize )
    {
        HWND hwndToolbar = CreateWindow( TOOLBARCLASSNAME, NULL, WS_CHILD | dwStyle, 0, 0, 100, 30, hwndParent, reinterpret_cast<HMENU>(nID), NULL, NULL );
        if (hwndToolbar)
        {
            ToolbarBitmapInfo.Toolbar(hwndToolbar);
            SendMessage( hwndToolbar, TB_BUTTONSTRUCTSIZE, nButtonStructSize, 0 );
            if (nBitmapWidth && nBitmapHeight)
            {
                SendMessage( hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG(nBitmapWidth,nBitmapHeight) );
            }
            if (nButtonWidth && nButtonHeight)
            {
                SendMessage( hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(nButtonWidth,nButtonHeight) );
            }
            HBITMAP hBitmap = CreateMappedBitmap( ToolbarBitmapInfo.ToolbarInstance(), ToolbarBitmapInfo.BitmapResId(), 0, NULL, 0 );
            if (hBitmap)
            {
                TBADDBITMAP TbAddBitmap = {0};
                TbAddBitmap.hInst = NULL;
                TbAddBitmap.nID = reinterpret_cast<UINT_PTR>(hBitmap);
                if (-1 != SendMessage( hwndToolbar, TB_ADDBITMAP, ToolbarBitmapInfo.ButtonCount(), reinterpret_cast<LPARAM>(&TbAddBitmap) ) )
                {
                    ToolbarBitmapInfo.Bitmap(hBitmap);
                }
            }
            SendMessage( hwndToolbar, TB_ADDBUTTONS, nButtonCount, reinterpret_cast<LPARAM>(pButtons) );
        }
        return hwndToolbar;
    }
        
    HWND CreateToolbar( 
        HWND hWndParent, 
        HWND hWndPrevious,
        HWND hWndAlign,
        int Alignment,
        UINT nToolbarId,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        CButtonDescriptor *pButtonDescriptors, 
        UINT nDescriptorCount )
    {
        HWND hWndToolbar = NULL;
    
        //
        // Make sure we have valid data
        //
        if (!hWndParent || !ToolbarBitmapInfo.ToolbarInstance() || !ToolbarBitmapInfo.BitmapResId() || !pButtonDescriptors || !nDescriptorCount)
        {
            return NULL;
        }
        //
        // Load the bitmap, so we can figure out how many buttons are in the supplied bitmap,
        // and their size.  We assume that the buttons are the same height and width.
        //
        HBITMAP hBitmap = reinterpret_cast<HBITMAP>(LoadImage( ToolbarBitmapInfo.ToolbarInstance(), MAKEINTRESOURCE(ToolbarBitmapInfo.BitmapResId()), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR|LR_CREATEDIBSECTION ));
        if (hBitmap)
        {
            //
            // Get the size of the bitmap
            //
            SIZE sizeBitmap = {0};
            PrintScanUtil::GetBitmapSize(hBitmap,sizeBitmap);
    
            //
            // If the sizes are valid, continue
            //
            if (sizeBitmap.cx && sizeBitmap.cy)
            {
                //
                // Figure out the count and dimensions of the buttons
                // Note the ridiculous size supplied for nButtonSizeX.  This is a 
                // workaround for a BTNS_AUTOSIZE bug
                //
                int nToolbarButtonCount = sizeBitmap.cx / sizeBitmap.cy;
                int nButtonBitmapSizeX = sizeBitmap.cy;
                int nButtonBitmapSizeY = sizeBitmap.cy;
                int nButtonSizeX = 1000;
                int nButtonSizeY = sizeBitmap.cy;
                
                //
                // Figure out which buttons to actually add
                //
                CSimpleDynamicArray<TBBUTTON> aActualButtons;
                for (UINT i=0;i<nDescriptorCount;i++)
                {
                    //
                    // If there is no controlling variable, or if it is true, add the button
                    //
                    if (!pButtonDescriptors[i].pbControllingVariable || *(pButtonDescriptors[i].pbControllingVariable))
                    {
                        TBBUTTON ToolbarButton = {0};
                        ToolbarButton.iBitmap = pButtonDescriptors[i].iBitmap >= 0 ? pButtonDescriptors[i].iBitmap : I_IMAGENONE;
                        ToolbarButton.idCommand = pButtonDescriptors[i].idCommand;
                        ToolbarButton.fsState = pButtonDescriptors[i].fsState;
                        ToolbarButton.fsStyle = pButtonDescriptors[i].fsStyle | BTNS_AUTOSIZE;
                        aActualButtons.Append(ToolbarButton);
                        
                        //
                        // Add the separator, if requested
                        //
                        if (pButtonDescriptors[i].bFollowingSeparator)
                        {
                            TBBUTTON ToolbarButtonSeparator = {0};
                            ToolbarButton.fsStyle = BTNS_SEP;
                            aActualButtons.Append(ToolbarButton);
                        }
                    }
                }
    
                //
                // Make sure we have at least one button
                //
                ToolbarBitmapInfo.ButtonCount(nToolbarButtonCount);
                if (aActualButtons.Size())
                {
                    //
                    // Create the toolbar
                    //
                    hWndToolbar = CreateToolbar( 
                        hWndParent, 
                        WS_CHILD|WS_GROUP|WS_VISIBLE|TBSTYLE_FLAT|WS_TABSTOP|CCS_NODIVIDER|TBSTYLE_LIST|CCS_NORESIZE|TBSTYLE_TOOLTIPS, 
                        nToolbarId, 
                        ToolbarBitmapInfo, 
                        aActualButtons.Array(), 
                        aActualButtons.Size(), 
                        nButtonSizeX, 
                        nButtonSizeY, 
                        nButtonBitmapSizeX, 
                        nButtonBitmapSizeY, 
                        sizeof(TBBUTTON) );
                    if (hWndToolbar)
                    {
                        //
                        // Set the font for the toolbar to be the same as the font for its parent
                        //
                        LRESULT lFontResult = SendMessage( hWndParent, WM_GETFONT, 0, 0 );
                        if (lFontResult)
                        {
                            SendMessage( hWndToolbar, WM_SETFONT, lFontResult, 0 );
                        }

                        //
                        // Loop through all of the actual buttons, to find their string resource ID
                        //
                        for (int i=0;i<aActualButtons.Size();i++)
                        {
                            //
                            // Look for the matching record, to find the string resource ID
                            //
                            for (UINT j=0;j<nDescriptorCount;j++)
                            {
                                //
                                // If this is the original record
                                //
                                if (aActualButtons[i].idCommand == pButtonDescriptors[j].idCommand)
                                {
                                    //
                                    // If this button has a resource ID
                                    //
                                    if (pButtonDescriptors[j].nStringResId)
                                    {
                                        //
                                        // Load the string resource and check to make sure it has a length
                                        //
                                        CSimpleString strText( pButtonDescriptors[j].nStringResId, ToolbarBitmapInfo.ToolbarInstance() );
                                        if (strText.Length())
                                        {
                                            //
                                            // Add the text
                                            //
                                            TBBUTTONINFO ToolBarButtonInfo = {0};
                                            ToolBarButtonInfo.cbSize = sizeof(ToolBarButtonInfo);
                                            ToolBarButtonInfo.dwMask = TBIF_TEXT;
                                            ToolBarButtonInfo.pszText = const_cast<LPTSTR>(strText.String());
                                            SendMessage( hWndToolbar, TB_SETBUTTONINFO, pButtonDescriptors[j].idCommand, reinterpret_cast<LPARAM>(&ToolBarButtonInfo) );
                                        }
                                    }
    
                                    //
                                    // Exit the inner loop, since we've found a match
                                    //
                                    break;
                                }
                            }
                        }

                        //
                        // Tell the toolbar to resize itself
                        //
                        SendMessage( hWndToolbar, TB_AUTOSIZE, 0, 0 );
                    }
                }
            }
    
            //
            // Free the bitmap
            //
            DeleteBitmap(hBitmap);
        }
    
        //
        // Resize and place the toolbar as needed
        //
        if (hWndToolbar && hWndAlign)
        {
            //
            // Get the size of the toolbar
            //
            SIZE sizeToolbar = {0};
            if (SendMessage( hWndToolbar, TB_GETMAXSIZE, 0, reinterpret_cast<LPARAM>(&sizeToolbar)))
            {
                //
                // Get the size of the placement window
                //
                CSimpleRect rcFrameWnd = CSimpleRect( hWndAlign, CSimpleRect::WindowRect ).ScreenToClient(hWndParent);
    
                //
                // Determine how to align horizontally
                //
                int nOriginX = rcFrameWnd.left;
                if (Alignment & AlignHCenter)
                {
                    nOriginX = rcFrameWnd.left + (rcFrameWnd.Width() - sizeToolbar.cx) / 2;
                }
                else if (Alignment & AlignRight)
                {
                    nOriginX = rcFrameWnd.right - sizeToolbar.cx;
                }
    
                int nOriginY = rcFrameWnd.top;
                if (Alignment & AlignVCenter)
                {
                    nOriginY = rcFrameWnd.top + (rcFrameWnd.Height() - sizeToolbar.cy) / 2;
                }
                else if (Alignment & AlignBottom)
                {
                    nOriginY = rcFrameWnd.bottom - sizeToolbar.cy;
                }
                
                //
                // Move and size the toolbar
                //
                SetWindowPos( hWndToolbar, NULL, nOriginX, nOriginY, sizeToolbar.cx, sizeToolbar.cy, SWP_NOZORDER|SWP_NOACTIVATE );
            }
        }
    
        if (hWndToolbar && hWndPrevious)
        {
            SetWindowPos( hWndToolbar, hWndPrevious, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE );
        }
    
        return hWndToolbar;
    }
    
    void SetToolbarButtonState( HWND hWndToolbar, int nButtonId, int nState )
    {
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (nCurrentState ^ nState)
            {
                SendMessage(hWndToolbar,TB_SETSTATE,nButtonId,MAKELONG(nState,0));
            }
        }
    }
    
    void EnableToolbarButton( HWND hWndToolbar, int nButtonId, bool bEnable )
    {
        WIA_PUSH_FUNCTION((TEXT("EnableToolbarButton")));
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (bEnable)
            {
                nCurrentState |= TBSTATE_ENABLED;
            }
            else
            {
                nCurrentState &= ~TBSTATE_ENABLED;
            }
            SetToolbarButtonState( hWndToolbar, nButtonId, nCurrentState );
        }

        //
        // If there are no enabled buttons, remove the WS_TABSTOP bit.  If there are,
        // make sure we add it back in.
        //

        //
        // Assume we don't need the WS_TABSTOP style
        //
        bool bTabStop = false;

        //
        // Loop through all of the buttons in the control
        //
        for (int i=0;i<SendMessage(hWndToolbar,TB_BUTTONCOUNT,0,0);++i)
        {
            //
            // Get the button info for each button
            //
            TBBUTTON TbButton = {0};
            if (SendMessage(hWndToolbar,TB_GETBUTTON,i,reinterpret_cast<LPARAM>(&TbButton)))
            {
                WIA_TRACE((TEXT("TbButton: %d, %d, %04X, %04X, %08X, %p"), TbButton.iBitmap, TbButton.idCommand, TbButton.fsState, TbButton.fsStyle, TbButton.dwData, TbButton.iString ));
                //
                // If this button is enabled, set bTabStop to true and pop out of the loop
                if (!(TbButton.fsStyle & BTNS_SEP) && TbButton.fsState & TBSTATE_ENABLED)
                {
                    bTabStop = true;
                    break;
                }
            }
        }

        //
        // Get the current window style and save a copy, so we don't
        // call SetWindowLong for no reason.
        //
        LONG nStyle = GetWindowLong( hWndToolbar, GWL_STYLE );
        LONG nCurrent = nStyle;

        //
        // Calculate the new style
        //
        if (bTabStop)
        {
            nStyle |= WS_TABSTOP;
        }
        else
        {
            nStyle &= ~WS_TABSTOP;
        }

        //
        // If the new style doesn't match the old one, set the style
        //
        if (nStyle != nCurrent)
        {
            SetWindowLong( hWndToolbar, GWL_STYLE, nStyle );
        }
    }

    bool GetAccelerator( LPCTSTR pszString, TCHAR &chAccel )
    {
        //
        // & marks an accelerator
        //
        const TCHAR c_chAccelFlag = TEXT('&');
        
        //
        // Assume we won't find an accelerator
        //
        chAccel = 0;

        //
        // Loop through the string
        //
        LPCTSTR pszCurr = pszString; 
        while (pszString && *pszString)
        {
            //
            // If this is the marker character
            //
            if (c_chAccelFlag == *pszCurr)
            {
                //
                // Get the next character.
                //
                pszCurr = CharNext(pszCurr);

                //
                // Make sure this isn't a && situation.  If it isn't, save the accelerator and break out.
                //
                if (c_chAccelFlag != *pszCurr)
                {
                    chAccel = reinterpret_cast<TCHAR>(CharUpper(reinterpret_cast<LPTSTR>(*pszCurr)));
                    break;
                }
            }

            //
            // It is OK to call this even if we are on the end of the string already
            //
            pszCurr = CharNext(pszCurr);
        }

        return (0 != chAccel);
    }

    UINT GetButtonBarAccelerators( HWND hWndToolbar, ACCEL *pAccelerators, UINT nMaxCount )
    {
        WIA_PUSH_FUNCTION((TEXT("GetButtonBarAccelerators")));
        
        //
        // We can't exceed the maximum number of buttons
        //
        UINT nCurrAccel=0;
        
        //
        // Loop through all of the buttons in the control
        //
        for (LRESULT i=0;i<SendMessage(hWndToolbar,TB_BUTTONCOUNT,0,0) && nCurrAccel < nMaxCount;++i)
        {
            //
            // Get the button info for each button, so we can get the ID
            //
            TBBUTTON TbButton = {0};
            if (SendMessage(hWndToolbar,TB_GETBUTTON,i,reinterpret_cast<LPARAM>(&TbButton)))
            {
                WIA_TRACE((TEXT("TbButton: %d, %d, %04X, %04X, %08X, %p"), TbButton.iBitmap, TbButton.idCommand, TbButton.fsState, TbButton.fsStyle, TbButton.dwData, TbButton.iString ));
                
                //
                // Ignore separators
                //
                if (!(TbButton.fsStyle & BTNS_SEP))
                {
                    //
                    // Get the button text.
                    //
                    TCHAR szButtonText[MAX_PATH]={0};
                    if (-1 != SendMessage(hWndToolbar,TB_GETBUTTONTEXT,TbButton.idCommand,reinterpret_cast<LPARAM>(szButtonText)))
                    {
                        //
                        // Get the accelerator (if any)
                        //
                        TCHAR chAccel = 0;
                        if (GetAccelerator( szButtonText, chAccel ))
                        {
                            //
                            // Create an ACCEL record
                            //
                            pAccelerators[nCurrAccel].cmd = static_cast<WORD>(TbButton.idCommand);
                            pAccelerators[nCurrAccel].fVirt = FALT|FVIRTKEY;
                            pAccelerators[nCurrAccel].key = chAccel;

                            //
                            // One more accelerator
                            //
                            nCurrAccel++;
                        }
                    }
                }
            }
        }

#if defined(DBG)
        for (UINT i=0;i<nCurrAccel;i++)
        {
            WIA_TRACE((TEXT("pAccelerators[%d].fVirt = 0x%02X, 0x%04X (%c), 0x%04X"), i, pAccelerators[i].fVirt, pAccelerators[i].key, pAccelerators[i].key, pAccelerators[i].cmd ));
        }
#endif
        return nCurrAccel;
    }
    
    void CheckToolbarButton( HWND hWndToolbar, int nButtonId, bool bChecked )
    {
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (bChecked)
            {
                nCurrentState |= TBSTATE_CHECKED;
            }
            else
            {
                nCurrentState &= ~TBSTATE_CHECKED;
            }
            SetToolbarButtonState( hWndToolbar, nButtonId, nCurrentState );
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\dbllbox.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       DBLLBOX.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        3/25/1999
 *
 *  DESCRIPTION: Owner drawn listbox and combobox that do an icon plus a title and subtitle
 *
 *******************************************************************************/
#ifndef __DBLLBOX_H_INCLUDED
#define __DBLLBOX_H_INCLUDED

#include "simstr.h"

template <class T>
class CDoubleLineListBoxItem
{
private:
    CSimpleString m_strTitle;
    CSimpleString m_strSubTitle;
    HICON         m_hIcon;
    T             m_Data;
public:
    CDoubleLineListBoxItem( const T &data, LPCTSTR pszTitle = NULL, LPCTSTR pszSubTitle = NULL, HICON hIcon = NULL );
    CDoubleLineListBoxItem( const CDoubleLineListBoxItem &other );
    CDoubleLineListBoxItem &operator=( const CDoubleLineListBoxItem &other );
    CDoubleLineListBoxItem &Assign( const CSimpleString &strTitle, const CSimpleString &strSubTitle, HICON hIcon, const T &data );
    ~CDoubleLineListBoxItem(void);
    CSimpleString Title(void) const;
    CSimpleString SubTitle(void) const;
    T Data(void) const;
    HICON Icon(void) const;
    HICON CopyIcon(void) const;
};

template <class T>
CDoubleLineListBoxItem<T>::CDoubleLineListBoxItem( const T &data, LPCTSTR pszTitle, LPCTSTR pszSubTitle, HICON hIcon )
: m_strTitle(),
  m_strSubTitle(),
  m_hIcon(NULL)
{
    Assign( pszTitle, pszSubTitle, hIcon, data );
}

template <class T>
CDoubleLineListBoxItem<T>::CDoubleLineListBoxItem( const CDoubleLineListBoxItem &other )
 : m_strTitle(),
   m_strSubTitle(),
   m_hIcon(NULL)
{
    Assign( other.Title(), other.SubTitle(), other.CopyIcon(), other.Data() );
}


template <class T>
CDoubleLineListBoxItem<T> &CDoubleLineListBoxItem<T>::operator=( const CDoubleLineListBoxItem &other )
{
    return( Assign( other.Title(), other.SubTitle(), other.CopyIcon(), other.Data() ));
}


template <class T>
CDoubleLineListBoxItem<T> &CDoubleLineListBoxItem<T>::Assign( const CSimpleString &strTitle, const CSimpleString &strSubTitle, HICON hIcon, const T &Data )
{
    if (m_hIcon)
    {
        DestroyIcon( m_hIcon );
    }
    m_hIcon = hIcon;
    m_strTitle = strTitle;
    m_strSubTitle = strSubTitle;
    m_Data = Data;
    return(*this);
}


template <class T>
CDoubleLineListBoxItem<T>::~CDoubleLineListBoxItem(void)
{
    if (m_hIcon)
    {
        DestroyIcon( m_hIcon );
        m_hIcon = NULL;
        m_strTitle = m_strSubTitle = TEXT("");
    }
}

template <class T>
CSimpleString CDoubleLineListBoxItem<T>::Title(void) const
{
    return(m_strTitle);
}

template <class T>
CSimpleString CDoubleLineListBoxItem<T>::SubTitle(void) const
{
    return(m_strSubTitle);
}


template <class T>
T CDoubleLineListBoxItem<T>::Data(void) const
{
    return(m_Data);
}

template <class T>
HICON CDoubleLineListBoxItem<T>::Icon(void) const
{
    return(m_hIcon);
}


template <class T>
HICON CDoubleLineListBoxItem<T>::CopyIcon(void) const
{
    return(m_hIcon ? ::CopyIcon(m_hIcon) : NULL );
}


template <class T>
class CDoubleLineListBox
{
private:
    HWND  m_hWnd;
    HFONT m_hFontTitle;
    HFONT m_hFontSubTitle;
    SIZE  m_sizeIcon;
    BOOL  m_bIsComboBox;
    int   m_nTitleTextHeight;
    int   m_nSubTitleTextHeight;

    enum
    {
        c_AdditionalIconBorder = 3 // Additional border around icons
    };

private:
    // No implementation
    CDoubleLineListBox( const CDoubleLineListBox & );
    CDoubleLineListBox &operator=( const CDoubleLineListBox & );

public:
    CDoubleLineListBox(void);
    ~CDoubleLineListBox(void);
    void Destroy(void);
    void AssignFonts( HFONT hFontTitle, HFONT hFontSubTitle );
    void CreateDefaultFonts(void);
    CDoubleLineListBox &Assign( HWND hWnd );
    HWND Handle(void) const;
    void Handle( HWND hWnd );
    CDoubleLineListBox &operator=( HWND hWnd );
    LRESULT AddItem( CDoubleLineListBoxItem<T> *pNewItem );
    CDoubleLineListBoxItem<T> *GetItem( int nIndex );
    void HandleDeleteItem( LPDELETEITEMSTRUCT pDeleteItem );
    void HandleMeasureItem( LPMEASUREITEMSTRUCT pMeasureItem );
    void HandleDrawItem( LPDRAWITEMSTRUCT pDrawItem );
    int SetHorizontalExtent(void);
    SIZE MeasureItem( int nIndex );
};


template <class T>
CDoubleLineListBox<T>::CDoubleLineListBox(void)
: m_hWnd(NULL),
  m_hFontTitle(NULL),
  m_hFontSubTitle(NULL),
  m_bIsComboBox(false),
  m_nTitleTextHeight(0),
  m_nSubTitleTextHeight(0)
{
}


template <class T>
CDoubleLineListBox<T>::~CDoubleLineListBox(void)
{
    Destroy();
}


template <class T>
void CDoubleLineListBox<T>::Destroy(void)
{
    m_hWnd = NULL;
    if (m_hFontTitle)
    {
        DeleteObject(m_hFontTitle);
        m_hFontTitle = NULL;
    }
    if (m_hFontSubTitle)
    {
        DeleteObject(m_hFontSubTitle);
        m_hFontSubTitle = NULL;
    }
}


template <class T>
void CDoubleLineListBox<T>::AssignFonts( HFONT hFontTitle, HFONT hFontSubTitle )
{
    if (m_hFontTitle)
    {
        DeleteObject(m_hFontTitle);
        m_hFontTitle = NULL;
    }
    if (m_hFontSubTitle)
    {
        DeleteObject(m_hFontSubTitle);
        m_hFontSubTitle = NULL;
    }

    m_hFontTitle = hFontTitle;
    m_hFontSubTitle = hFontSubTitle;

    HDC hDC = GetDC(NULL);
    if (hDC)
    {
        HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(hDC,m_hFontTitle));

        TEXTMETRIC TextMetric;
        GetTextMetrics( hDC, &TextMetric );
        m_nTitleTextHeight = TextMetric.tmHeight + TextMetric.tmExternalLeading;

        SelectObject(hDC,m_hFontSubTitle);
        GetTextMetrics( hDC, &TextMetric );
        m_nSubTitleTextHeight = TextMetric.tmHeight + TextMetric.tmExternalLeading;

        SelectObject( hDC, hOldFont );
        ReleaseDC( NULL, hDC );
    }
}


template <class T>
void CDoubleLineListBox<T>::CreateDefaultFonts(void)
{
    HFONT hCurrFont = NULL, hFontTitle = NULL, hFontSubTitle = NULL;
    if (m_hWnd && IsWindow(m_hWnd))
    {
        hCurrFont = reinterpret_cast<HFONT>(SendMessage(m_hWnd,WM_GETFONT,0,0));
    }
    if (!hCurrFont)
    {
        hCurrFont = reinterpret_cast<HFONT>(GetStockObject(ANSI_VAR_FONT));
    }
    if (hCurrFont)
    {
        LOGFONT lf;
        if (GetObject( hCurrFont, sizeof(lf), &lf ))
        {
            lf.lfWeight = FW_BOLD;
            hFontTitle = CreateFontIndirect(&lf);
            lf.lfWeight = FW_NORMAL;
            hFontSubTitle = CreateFontIndirect(&lf);
        }
    }
    AssignFonts( hFontTitle, hFontSubTitle );
}


template <class T>
CDoubleLineListBox<T> &CDoubleLineListBox<T>::Assign( HWND hWnd )
{
    Destroy();
    m_hWnd = hWnd;
    CreateDefaultFonts();
    if (m_hWnd && IsWindow(m_hWnd))
    {
        TCHAR szClassName[MAX_PATH];
        if (GetClassName( m_hWnd, szClassName, sizeof(szClassName)/sizeof(szClassName[0])))
        {
            m_bIsComboBox = (lstrcmpi( szClassName, TEXT("combobox") ) == 0);
        }
    }
    return(*this);
}


template <class T>
HWND CDoubleLineListBox<T>::Handle(void) const
{
    return(m_hWnd);
}


template <class T>
void CDoubleLineListBox<T>::Handle( HWND hWnd )
{
    Assign(hWnd);
}


template <class T>
CDoubleLineListBox<T> &CDoubleLineListBox<T>::operator=( HWND hWnd )
{
    return(Assign(hWnd));
}


template <class T>
LRESULT CDoubleLineListBox<T>::AddItem( CDoubleLineListBoxItem<T> *pNewItem )
{
    LRESULT lResult = -1;
    if (IsWindow(m_hWnd) && pNewItem)
    {
        lResult = SendMessage( m_hWnd, m_bIsComboBox ? CB_ADDSTRING : LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pNewItem->Title().String()) );
        if (lResult >= 0)
        {
            SendMessage( m_hWnd, m_bIsComboBox ? CB_SETITEMDATA : LB_SETITEMDATA, lResult, reinterpret_cast<LPARAM>(pNewItem) );
        }
        SetHorizontalExtent();
    }
    return(lResult);
}


template <class T>
CDoubleLineListBoxItem<T> *CDoubleLineListBox<T>::GetItem( int nIndex )
{
    LRESULT lResult = 0;
    if (IsWindow(m_hWnd))
    {
        lResult = SendMessage( m_hWnd, m_bIsComboBox ? CB_GETITEMDATA : LB_GETITEMDATA, nIndex, 0 );
        if (lResult == CB_ERR || lResult == LB_ERR)
            lResult = 0;
    }
    return(reinterpret_cast<CDoubleLineListBoxItem<T> *>(lResult));
}


// This must be called in response to WM_DELETEITEM
template <class T>
void CDoubleLineListBox<T>::HandleDeleteItem( LPDELETEITEMSTRUCT pDeleteItem )
{
    if (pDeleteItem && IsWindow(m_hWnd) && pDeleteItem->hwndItem == m_hWnd)
    {
        CDoubleLineListBoxItem *pItem = reinterpret_cast<CDoubleLineListBoxItem *>(pDeleteItem->itemData);
        if (pItem)
            delete pItem;
    }
}

// This must be called in response to WM_MEASUREITEM
template <class T>
void CDoubleLineListBox<T>::HandleMeasureItem( LPMEASUREITEMSTRUCT pMeasureItem )
{
    if (pMeasureItem)
    {
        SIZE sizeItem = MeasureItem( pMeasureItem->itemID );
        pMeasureItem->itemHeight = sizeItem.cy;
    }
}

template <class T>
int CDoubleLineListBox<T>::SetHorizontalExtent(void)
{
    if (IsWindow(m_hWnd))
    {
        int nMaxLength = 0;
        LRESULT lCount = SendMessage( m_hWnd, m_bIsComboBox ? CB_GETCOUNT : LB_GETCOUNT, 0, 0 );
        for (int i=0;i<(int)lCount;i++)
        {
            SIZE sizeItem = MeasureItem(i);
            nMaxLength = (sizeItem.cx > nMaxLength) ? sizeItem.cx : nMaxLength;
        }
        SendMessage( m_hWnd, m_bIsComboBox ? CB_SETHORIZONTALEXTENT : LB_SETHORIZONTALEXTENT, nMaxLength, 0 );
        return nMaxLength;
    }
    return 0;
}

// Return the width and height, in pixels, of an item
template <class T>
SIZE CDoubleLineListBox<T>::MeasureItem( int nIndex )
{
    SIZE sizeItem =
    {
        GetSystemMetrics(SM_CXICON) + c_AdditionalIconBorder * 3 + 2,
        GetSystemMetrics(SM_CYICON) + c_AdditionalIconBorder * 2 + 2
    };
    if (IsWindow(m_hWnd))
    {
        // Make sure we have valid fonts
        if (!m_hFontTitle || !m_hFontSubTitle)
            CreateDefaultFonts();
        CDoubleLineListBoxItem<T> *pItem = GetItem(nIndex);
        if (pItem)
        {
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(hDC,m_hFontTitle));

                // Calculate the size of the text rectangle for the title
                RECT rcText;
                ZeroMemory(&rcText,sizeof(rcText));
                DrawTextEx( hDC, const_cast<LPTSTR>(pItem->Title().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_CALCRECT, NULL );
                int nTitleWidth = rcText.right - rcText.left;

                // Calculate the size of the text rectangle for the sub title
                ZeroMemory(&rcText,sizeof(rcText));
                SelectObject(hDC,m_hFontSubTitle);
                DrawTextEx( hDC, const_cast<LPTSTR>(pItem->SubTitle().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_CALCRECT, NULL );
                int nSubTitleWidth = rcText.right - rcText.left;

                sizeItem.cx += (nTitleWidth > nSubTitleWidth) ? nTitleWidth : nSubTitleWidth;

                SelectObject( hDC, hOldFont );
                ReleaseDC( m_hWnd, hDC );
            }
        }
    }
    return(sizeItem);
}

// This must be called in response to WM_DRAWITEM
template <class T>
void CDoubleLineListBox<T>::HandleDrawItem( LPDRAWITEMSTRUCT pDrawItem )
{
    if (pDrawItem && IsWindow(m_hWnd) && pDrawItem->hwndItem == m_hWnd)
    {
        // Make sure we have valid fonts
        if (!m_hFontTitle || !m_hFontSubTitle)
            CreateDefaultFonts();

        RECT rcItem = pDrawItem->rcItem;
        // Paint the background
        if (ODS_SELECTED & pDrawItem->itemState)
        {
            if (IsWindowEnabled(pDrawItem->hwndItem))
            {
                FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
            }
            else
            {
                FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_INACTIVECAPTION));
            }
        }
        else
        {
            FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_WINDOW));
        }

        // Paint the focus rectangle
        if (ODS_FOCUS & pDrawItem->itemState)
        {
            DrawFocusRect( pDrawItem->hDC, &rcItem );
        }

        // Shrink by one pixel, so we don't overwrite the focus rect
        InflateRect( &rcItem, -1, -1 );

        if (pDrawItem->itemData != -1)
        {
            CDoubleLineListBoxItem<T> *pItem = reinterpret_cast<CDoubleLineListBoxItem<T> *>(pDrawItem->itemData);
            if (pItem)
            {
                // Draw the icon
                DrawIconEx( pDrawItem->hDC, pDrawItem->rcItem.left+c_AdditionalIconBorder, pDrawItem->rcItem.top+c_AdditionalIconBorder, pItem->Icon(), GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0, NULL, DI_NORMAL );

                // Move the left margin over to make room for the text
                rcItem.left += GetSystemMetrics(SM_CXICON) + c_AdditionalIconBorder * 2;

                // Set up the dc
                COLORREF crOldTextColor;
                if (IsWindowEnabled(pDrawItem->hwndItem))
                {
                    if (ODS_SELECTED & pDrawItem->itemState)
                        crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
                    else crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT) );
                }
                else
                {
                    if (ODS_SELECTED & pDrawItem->itemState)
                        crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
                    else crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_GRAYTEXT) );
                }

                int nOldBkMode = SetBkMode( pDrawItem->hDC, TRANSPARENT );
                HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(pDrawItem->hDC,m_hFontTitle));

                // Calculate the text rectangle
                RECT rcText = rcItem;
                rcText.top += (((rcText.bottom - rcText.top)) - (m_nTitleTextHeight + m_nSubTitleTextHeight)) / 2;
                rcText.bottom = rcText.top + m_nTitleTextHeight + m_nSubTitleTextHeight;

                DrawTextEx( pDrawItem->hDC, const_cast<LPTSTR>(pItem->Title().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX, NULL );

                // Get ready for the sub-title
                SelectObject(pDrawItem->hDC,m_hFontSubTitle);

                // Get the coords for the bottom text rect
                rcText.top += m_nTitleTextHeight;

                // Draw the text
                DrawTextEx( pDrawItem->hDC, const_cast<LPTSTR>(pItem->SubTitle().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX, NULL );

                // Restore the dc
                SelectObject(pDrawItem->hDC,hOldFont);
                SetBkMode( pDrawItem->hDC, nOldBkMode );
                SetTextColor( pDrawItem->hDC, crOldTextColor );
            }
        }
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\devlist.h ===
#ifndef __DEVLIST_H_INCLUDED
#define __DEVLIST_H_INCLUDED

#include <windows.h>
#include <sti.h>
#include "pshelper.h"

typedef CComPtr<IWiaPropertyStorage> CDeviceListType;

class CDeviceList : public CSimpleDynamicArray<CDeviceListType>
{
public:
    CDeviceList( IWiaDevMgr *pIWiaDevMgr=NULL, LONG nDeviceTypes=StiDeviceTypeDefault, LONG nFlags=0 )
    {
        Initialize( pIWiaDevMgr, nDeviceTypes, nFlags );
    }
    CDeviceList( const CDeviceList &other )
    {
        Append(other);
    }
    const CDeviceList &operator=( const CDeviceList &other )
    {
        Destroy();
        Append(other);
        return *this;
    }
    virtual ~CDeviceList(void)
    {
    }
    bool Initialize( IWiaDevMgr *pIWiaDevMgr, LONG nDeviceTypes, LONG nFlags=0 )
    {
        Destroy();
        if (!pIWiaDevMgr)
            return false;

        CComPtr<IEnumWIA_DEV_INFO> pIEnumWIA_DEV_INFO;
        HRESULT hr = pIWiaDevMgr->EnumDeviceInfo( nFlags, &pIEnumWIA_DEV_INFO );
        if (SUCCEEDED(hr))
        {
            ULONG ulFetched;
            CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
            while ((hr = pIEnumWIA_DEV_INFO->Next(1,&pIWiaPropertyStorage,&ulFetched)) == S_OK)
            {
                LONG nDeviceType;
                if (!PropStorageHelpers::GetProperty( pIWiaPropertyStorage, WIA_DIP_DEV_TYPE, nDeviceType ))
                {
                    // An error occurred
                    return false;
                }
                if (nDeviceTypes == StiDeviceTypeDefault || (nDeviceTypes == GET_STIDEVICE_TYPE(nDeviceType)))
                {
                    Append(pIWiaPropertyStorage);
                }
                pIWiaPropertyStorage.Release();
            }
        }
        else
        {
           return false;
        }
        return true;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\delimstr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       DELIMSTR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Simple string tokenizer class.  Stores the strings parsed from
 *               another string as an array of strings.  Pass the legal delimiters
 *               as the second argument to the second constructor.  Whitespace is
 *               preserved.  To eliminate whitespace, use CSimpleStringBase::Trim()
 *
 *******************************************************************************/
#ifndef __DELIMSTR_H_INCLUDED
#define __DELIMSTR_H_INCLUDED

#include "simarray.h"
#include "simstr.h"
#include "simtok.h"

template <class T>
class CDelimitedStringBase : public CSimpleDynamicArray<T>
{
private:
    T m_strOriginal;
    T m_strDelimiters;
public:
    CDelimitedStringBase(void)
    {
    }
    CDelimitedStringBase( const T &strOriginal, const T &strDelimiters )
    : m_strOriginal(strOriginal),m_strDelimiters(strDelimiters)
    {
        Parse();
    }
    CDelimitedStringBase( const CDelimitedStringBase &other )
    : m_strOriginal(other.Original()),m_strDelimiters(other.Delimiters())
    {
        Parse();
    }
    CDelimitedStringBase &operator=( const CDelimitedStringBase &other )
    {
        if (this != &other)
        {
            m_strOriginal = other.Original();
            m_strDelimiters = other.Delimiters();
            Parse();
        }
        return *this;
    }
    T Original(void) const
    {
        return m_strOriginal;
    }
    T Delimiters(void) const
    {
        return m_strDelimiters;
    }
    void Parse(void)
    {
        Destroy();
        CSimpleStringToken<T> Token( m_strOriginal );
        while (true)
        {
            T strCurrToken = Token.Tokenize(m_strDelimiters);
            if (!strCurrToken.Length())
                break;
            Append(strCurrToken);
        }
    }
};

typedef CDelimitedStringBase<CSimpleStringWide> CDelimitedStringWide;
typedef CDelimitedStringBase<CSimpleStringAnsi> CDelimitedStringAnsi;
typedef CDelimitedStringBase<CSimpleString> CDelimitedString;

#endif //__DELIMSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\devprop.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DEVPROP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/31/2000
 *
 *  DESCRIPTION: Identify a scanner's characteristics
 *
 *******************************************************************************/
#include <wia.h>
#include <uicommon.h>

namespace ScannerProperties
{
    enum
    {
        HasFlatBed             = 0x00000001,
        HasDocumentFeeder      = 0x00000002,
        SupportsPreview        = 0x00000008,
        SupportsPageSize       = 0x00000010,
    };

    LONG GetDeviceProps( IWiaItem *pWiaRootItem )
    {
        WIA_PUSHFUNCTION(TEXT("ScannerProperties::GetDeviceProps()"));
        LONG lResult = 0;

        //
        // If the scanner has document handling and supports FEEDER, it has an ADF.
        //
        LONG nDocumentHandlingSelect = 0;
        if (PropStorageHelpers::GetPropertyFlags( pWiaRootItem, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelect) && (nDocumentHandlingSelect & FEEDER))
        {
            //
            // If the device has a feeder with no maximum length, it is a sheet feeder.
            //
            LONG nVerticalFeederSize = 0;
            if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, nVerticalFeederSize ) && (nVerticalFeederSize != 0))
            {
                lResult |= HasDocumentFeeder;
                lResult |= SupportsPageSize;
            }
            else
            {
                lResult |= HasDocumentFeeder;
            }
        }

        //
        // If the scanner has a vertical bed size, it has a flatbed
        //
        LONG nVerticalBedSize = 0;
        if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_VERTICAL_BED_SIZE, nVerticalBedSize ) && (nVerticalBedSize != 0))
        {
            lResult |= HasFlatBed;
            lResult |= SupportsPreview;
        }

        //
        // If the driver specifically tells us it doesn't support previewing, turn it off
        //
        LONG nShowPreview = 0;
        if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_SHOW_PREVIEW_CONTROL, nShowPreview ) && (WIA_DONT_SHOW_PREVIEW_CONTROL == nShowPreview))
        {
            lResult &= ~SupportsPreview;
        }

        //
        // debug print an English string describing the properties
        //
#if defined(DBG)

#define ENTRY(x) { x, #x }

        static struct
        {
            LONG  nFlag;
            CHAR *strName;
        } dbgFlags[] =
        {
            ENTRY(HasFlatBed),
            ENTRY(HasDocumentFeeder),
            ENTRY(SupportsPreview),
            ENTRY(SupportsPageSize)
        };
        CSimpleStringAnsi strProps;
        for (int i=0;i<ARRAYSIZE(dbgFlags);i++)
        {
            if (lResult & dbgFlags[i].nFlag)
            {
                if (strProps.Length())
                {
                    strProps.Concat("|");
                }
                strProps.Concat(dbgFlags[i].strName);
            }
        }
        WIA_TRACE((TEXT("Device Properties: %hs"), strProps.String() ));
#endif

        return lResult;
    }
    inline IsAScrollFedScanner( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasDocumentFeeder) && !(nDeviceProps & SupportsPageSize));
    }

    inline IsAFlatbedScanner( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasFlatBed) && (nDeviceProps & SupportsPreview));
    }

    inline IsAnADFAndFlatbed( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasFlatBed) && (nDeviceProps & HasDocumentFeeder));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\dlgunits.h ===
#ifndef __DLGUNITS_H_INCLUDED
#define __DLGUNITS_H_INCLUDED

#include <windows.h>

class CDialogUnits
{
private:
    HWND m_hWnd;

private:
    CDialogUnits(void);
    CDialogUnits( const CDialogUnits &other );
    CDialogUnits &operator=( const CDialogUnits & );

public:
    CDialogUnits( HWND hWnd )
    : m_hWnd(hWnd)
    {
    }
    int X( INT nDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = nDialogUnits;
        MapDialogRect( m_hWnd, &rc );
        return(rc.left);
    }
    int Y( INT nDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.bottom = nDialogUnits;
        MapDialogRect( m_hWnd, &rc );
        return(rc.bottom);
    }
    POINT DialogUnitsToPixels( const POINT &ptDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = ptDialogUnits.x;
        rc.top = ptDialogUnits.y;
        MapDialogRect( m_hWnd, &rc );
        POINT ptReturnValue;
        ptReturnValue.x = rc.left;
        ptReturnValue.y = rc.top;
        return(ptReturnValue);
    }
    SIZE DialogUnitsToPixels( const SIZE &sizeDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = sizeDialogUnits.cx;
        rc.top = sizeDialogUnits.cy;
        MapDialogRect( m_hWnd, &rc );
        SIZE sizeReturnValue;
        sizeReturnValue.cx = rc.left;
        sizeReturnValue.cy = rc.top;
        return(sizeReturnValue);
    }
    RECT DialogUnitsToPixels( const RECT &rcDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = rcDialogUnits.left;
        rc.top = rcDialogUnits.top;
        rc.right = rcDialogUnits.right;
        rc.bottom = rcDialogUnits.bottom;
        MapDialogRect( m_hWnd, &rc );
        return(rc);
    }
    SIZE StandardButtonSize(void)
    {
        SIZE sizeRes = { 50, 14 };
        return DialogUnitsToPixels( sizeRes );
    }
    SIZE StandardMargin(void)
    {
        SIZE sizeRes = { 7, 7 };
        return DialogUnitsToPixels( sizeRes );
    }
    SIZE StandardButtonMargin(void)
    {
        SIZE sizeRes = { 4, 7 };
        return DialogUnitsToPixels( sizeRes );
    }
};

#endif __DLGUNITS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\dumpprop.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
         *  TITLE:       DUMPPROP.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/2000
 *
 *  DESCRIPTION: Display the properties associated with a IWiaItem, either to the
 *               debugger, or to a log file.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "dumpprop.h"

//
// Change this to limit the width of individual strings (for avoiding ugliness)
//
#define MAX_DUMP_STRING 160

CWiaDebugDump::CWiaDebugDump(void)
{
}

CWiaDebugDump::~CWiaDebugDump(void)
{
}

CWiaDebugDumpToFileHandle::CWiaDebugDumpToFileHandle( HANDLE hFile )
  : m_hFile(hFile)
{
}

CWiaDebugDumpToFileHandle::~CWiaDebugDumpToFileHandle(void)
{
}

void CWiaDebugDumpToFileHandle::Print( LPCTSTR pszString )
{
    if (m_hFile && pszString)
    {
        DWORD dwWritten;
        WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR), &dwWritten, NULL );
        WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
    }
}


CWiaDebugDumpToFile::CWiaDebugDumpToFile( LPCTSTR pszFilename, bool bOverwrite )
  : m_hFile(INVALID_HANDLE_VALUE)
{
    if (pszFilename && lstrlen(pszFilename))
    {
        m_hFile = CreateFile( pszFilename, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, bOverwrite ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if (!bOverwrite && m_hFile)
        {
            SetFilePointer( m_hFile, 0, NULL, FILE_END );
        }
    }
}

CWiaDebugDumpToFile::~CWiaDebugDumpToFile(void)
{
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

void CWiaDebugDumpToFile::Print( LPCTSTR pszString )
{
    if (m_hFile && pszString)
    {
        DWORD dwWritten;
        WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR), &dwWritten, NULL );
        WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
    }
}


CSimpleString CWiaDebugDump::GetTymedString( LONG tymed )
{
    switch (tymed)
    {
    case TYMED_CALLBACK:
        return TEXT("TYMED_CALLBACK");

    case TYMED_FILE:
        return TEXT("TYMED_FILE");

    case TYMED_MULTIPAGE_CALLBACK:
        return TEXT("TYMED_MULTIPAGE_CALLBACK");

    case TYMED_MULTIPAGE_FILE:
        return TEXT("TYMED_MULTIPAGE_FILE");
    }
    return CSimpleString().Format( TEXT("0x%08X"), tymed );
}

CSimpleString CWiaDebugDump::GetPropVariantTypeString( VARTYPE vt )
{
    CSimpleString strResult;

    static const struct
    {
        VARTYPE vt;
        LPCTSTR pszName;
    }
    s_VarTypes[] =
    {
        { VT_I2, TEXT("VT_I2") },
        { VT_I4, TEXT("VT_I4") },
        { VT_R4, TEXT("VT_R4") },
        { VT_R8, TEXT("VT_R8") },
        { VT_CY, TEXT("VT_CY") },
        { VT_DATE, TEXT("VT_DATE") },
        { VT_BSTR, TEXT("VT_BSTR") },
        { VT_DISPATCH, TEXT("VT_DISPATCH") },
        { VT_ERROR, TEXT("VT_ERROR") },
        { VT_BOOL, TEXT("VT_BOOL") },
        { VT_VARIANT, TEXT("VT_VARIANT") },
        { VT_UNKNOWN, TEXT("VT_UNKNOWN") },
        { VT_DECIMAL, TEXT("VT_DECIMAL") },
        { VT_I1, TEXT("VT_I1") },
        { VT_UI1, TEXT("VT_UI1") },
        { VT_UI2, TEXT("VT_UI2") },
        { VT_UI4, TEXT("VT_UI4") },
        { VT_I8, TEXT("VT_I8") },
        { VT_UI8, TEXT("VT_UI8") },
        { VT_INT, TEXT("VT_INT") },
        { VT_UINT, TEXT("VT_UINT") },
        { VT_VOID, TEXT("VT_VOID") },
        { VT_HRESULT, TEXT("VT_HRESULT") },
        { VT_PTR, TEXT("VT_PTR") },
        { VT_SAFEARRAY, TEXT("VT_SAFEARRAY") },
        { VT_CARRAY, TEXT("VT_CARRAY") },
        { VT_USERDEFINED, TEXT("VT_USERDEFINED") },
        { VT_LPSTR, TEXT("VT_LPSTR") },
        { VT_LPWSTR, TEXT("VT_LPWSTR") },
        { VT_RECORD, TEXT("VT_RECORD") },
        { VT_INT_PTR, TEXT("VT_INT_PTR") },
        { VT_UINT_PTR, TEXT("VT_UINT_PTR") },
        { VT_FILETIME, TEXT("VT_FILETIME") },
        { VT_BLOB, TEXT("VT_BLOB") },
        { VT_STREAM, TEXT("VT_STREAM") },
        { VT_STORAGE, TEXT("VT_STORAGE") },
        { VT_STREAMED_OBJECT, TEXT("VT_STREAMED_OBJECT") },
        { VT_STORED_OBJECT, TEXT("VT_STORED_OBJECT") },
        { VT_BLOB_OBJECT, TEXT("VT_BLOB_OBJECT") },
        { VT_CF, TEXT("VT_CF") },
        { VT_CLSID, TEXT("VT_CLSID") },
        { VT_VERSIONED_STREAM, TEXT("VT_VERSIONED_STREAM") }
    },
    s_ExtendedTypes[] =
    {
        { VT_VECTOR, TEXT("VT_VECTOR") },
        { VT_ARRAY, TEXT("VT_ARRAY") },
        { VT_BYREF, TEXT("VT_BYREF") },
        { VT_RESERVED, TEXT("VT_RESERVED") }
    };
    for (int i=0;i<ARRAYSIZE(s_ExtendedTypes);i++)
    {
        if (vt & s_ExtendedTypes[i].vt)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_ExtendedTypes[i].pszName;
        }
    }
    for (int i=0;i<ARRAYSIZE(s_VarTypes);i++)
    {
        if ((vt & VT_TYPEMASK) == s_VarTypes[i].vt)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_VarTypes[i].pszName;
        }
    }
    if (!strResult.Length())
    {
        strResult.Format( TEXT("Unknown variant type: 0x%04X"), vt );
    }
    return strResult;
}


CSimpleString CWiaDebugDump::GetPrintableValue( PROPVARIANT &PropVariant )
{
    TCHAR szValue[1024] = TEXT("");
    switch (PropVariant.vt)
    {
    case VT_I1:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),PropVariant.cVal,PropVariant.cVal);
        break;

    case VT_UI1:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),PropVariant.bVal,PropVariant.bVal);
        break;

    case VT_I2:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),PropVariant.iVal,PropVariant.iVal);
        break;

    case VT_UI2:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),PropVariant.uiVal,PropVariant.uiVal);
        break;

    case VT_I4:
        wsprintf(szValue,TEXT("%ld, (0x%08X)"),PropVariant.lVal,PropVariant.lVal);
        break;

    case VT_UI4:
        wsprintf(szValue,TEXT("%lu, (0x%08X)"),PropVariant.ulVal,PropVariant.ulVal);
        break;

    case VT_BSTR:
        lstrcpyn( szValue, CSimpleStringConvert::NaturalString(CSimpleStringWide(PropVariant.bstrVal)), ARRAYSIZE(szValue));
        break;

    case VT_LPWSTR:
        lstrcpyn( szValue, CSimpleStringConvert::NaturalString(CSimpleStringWide(PropVariant.pwszVal)), ARRAYSIZE(szValue));
        break;

    case VT_CLSID:
        lstrcpyn( szValue, PropVariant.puuid ? GetStringFromGuid(*PropVariant.puuid).String() : TEXT("NULL"), ARRAYSIZE(szValue));
        break;

    case VT_VECTOR|VT_I1:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cac.cElems );
            for (int i=0;i<(int)PropVariant.cac.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }
                wsprintf(szValue+lstrlen(szValue), TEXT("%02X"), (ULONG)PropVariant.cac.pElems[i] );
                if (i < (int)PropVariant.cal.cElems-1 && i % 4 == 3)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI1:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caub.cElems );
            for (int i=0;i<(int)PropVariant.caub.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue), TEXT("%02X"), (ULONG)PropVariant.caub.pElems[i] );
                if (i < (int)PropVariant.cal.cElems-1 && i % 4 == 3)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_I2:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cai.cElems );
            for (int i=0;i<(int)PropVariant.cai.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%04X"),(ULONG)PropVariant.cai.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI2:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caui.cElems );
            for (int i=0;i<(int)PropVariant.caui.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%04X"),(ULONG)PropVariant.caui.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_I4:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cal.cElems );
            for (int i=0;i<(int)PropVariant.cal.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%08X"),(ULONG)PropVariant.cal.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI4:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caul.cElems );
            for (int i=0;i<(int)PropVariant.caul.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%08X"),(ULONG)PropVariant.caul.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    default:
        wsprintf(szValue,TEXT("Unknown Type %d (0x%08X)"),PropVariant.vt,PropVariant.vt);
    }

    return szValue;
}

CSimpleString CWiaDebugDump::GetPrintableValue( VARIANT &Variant )
{
    TCHAR szValue[1024] = TEXT("");
    switch (Variant.vt)
    {
    case VT_I1:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),Variant.cVal,Variant.cVal);
        break;

    case VT_UI1:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),Variant.bVal,Variant.bVal);
        break;

    case VT_I2:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),Variant.iVal,Variant.iVal);
        break;

    case VT_UI2:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),Variant.uiVal,Variant.uiVal);
        break;

    case VT_I4:
        wsprintf(szValue,TEXT("%ld, (0x%08X)"),Variant.lVal,Variant.lVal);
        break;

    case VT_UI4:
        wsprintf(szValue,TEXT("%lu, (0x%08X)"),Variant.ulVal,Variant.ulVal);
        break;

    case VT_BSTR:
        lstrcpyn( szValue, CSimpleStringConvert::NaturalString(CSimpleStringWide(Variant.bstrVal)), ARRAYSIZE(szValue));
        break;


    default:
        wsprintf(szValue,TEXT("Unknown Type %d (0x%08X)"),Variant.vt,Variant.vt);
    }

    return szValue;
}


CSimpleString CWiaDebugDump::GetPrintableName( const STATPROPSTG &StatPropStg )
{
    CSimpleString strResult;

    //
    // Get the name
    //
    strResult += TEXT("[");
    if (StatPropStg.lpwstrName)
    {
        strResult += CSimpleStringConvert::NaturalString(CSimpleStringWide(StatPropStg.lpwstrName));
    }
    else
    {
        strResult += TEXT("*No Property Name*");
    }

    //
    // Get the propid
    //
    strResult += CSimpleString().Format( TEXT("], propid: %d"), StatPropStg.propid );
    return strResult;
}

CSimpleString CWiaDebugDump::GetPrintableAccessFlags( ULONG nAccessFlags )
{
    CSimpleString strResult;
    static const struct
    {
        ULONG nFlag;
        LPCTSTR pszName;
    }
    s_Flags[] =
    {
        { WIA_PROP_READ, TEXT("WIA_PROP_READ") },
        { WIA_PROP_WRITE, TEXT("WIA_PROP_WRITE") },
        { WIA_PROP_SYNC_REQUIRED, TEXT("WIA_PROP_SYNC_REQUIRED") },
        { WIA_PROP_NONE, TEXT("WIA_PROP_NONE") },
        { WIA_PROP_RANGE, TEXT("WIA_PROP_RANGE") },
        { WIA_PROP_LIST, TEXT("WIA_PROP_LIST") },
        { WIA_PROP_FLAG, TEXT("WIA_PROP_FLAG") },
        { WIA_PROP_CACHEABLE, TEXT("WIA_PROP_CACHEABLE") }
    };
    for (int i=0;i<ARRAYSIZE(s_Flags);i++)
    {
        if (nAccessFlags & s_Flags[i].nFlag)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_Flags[i].pszName;
        }
    }
    if (!strResult.Length())
    {
        strResult = TEXT("*none*");
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetPrintableLegalValues( ULONG nAccessFlags, const PROPVARIANT &PropVariantAttributes )
{
    CSimpleString strResult;
    if ((nAccessFlags & WIA_PROP_RANGE) && (PropVariantAttributes.vt & VT_VECTOR))
    {
        CSimpleString strMin, strMax, strStep;
        switch (PropVariantAttributes.vt & VT_TYPEMASK)
        {
        case VT_I1:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI1:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I2:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI2:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I4:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI4:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I8:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_MIN].LowPart );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_MAX].LowPart );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_STEP].LowPart );
            break;

        case VT_UI8:
            strMin.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_MIN].LowPart );
            strMax.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_MAX].LowPart );
            strStep.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_STEP].LowPart );
            break;
        }
        strResult.Format( TEXT("%s...%s, Step: %s"), strMin.String(), strMax.String(), strStep.String() );
    }
    else if (nAccessFlags & WIA_PROP_LIST && (PropVariantAttributes.vt & VT_VECTOR))
    {
        if (((PropVariantAttributes.vt & VT_TYPEMASK) == VT_I4) || ((PropVariantAttributes.vt & VT_TYPEMASK) == VT_UI4))
        {
            for (ULONG i=0;i<PropVariantAttributes.cal.cElems - WIA_LIST_VALUES;i++)
            {
                if (strResult.Length())
                {
                    strResult += TEXT(",");
                }
                if (strResult.Length() >= MAX_DUMP_STRING)
                {
                    strResult += TEXT("...");
                    break;
                }
                strResult += CSimpleString().Format( TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_LIST_VALUES + i] );
            }
        }
        else if ((PropVariantAttributes.vt & VT_TYPEMASK) == VT_CLSID)
        {
            for (ULONG i=0;i<PropVariantAttributes.cauuid.cElems - WIA_LIST_VALUES;i++)
            {
                if (strResult.Length())
                {
                    strResult += TEXT(",");
                }
                if (strResult.Length() >= MAX_DUMP_STRING)
                {
                    strResult += TEXT("...");
                    break;
                }
                strResult += CSimpleString().Format( TEXT("%s"), GetStringFromGuid(PropVariantAttributes.cauuid.pElems[WIA_LIST_VALUES + i]).String() );
            }
        }
    }
    else if (nAccessFlags & WIA_PROP_FLAG)
    {
        strResult.Format( TEXT("0x%08X"), PropVariantAttributes.caul.pElems[WIA_FLAG_VALUES] );
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetWiaItemTypeFlags( IUnknown *pUnknown )
{
    CSimpleString strResult;
    if (pUnknown)
    {
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            LONG nItemType = 0;
            hr = pWiaItem->GetItemType(&nItemType);
            if (SUCCEEDED(hr))
            {
                static const struct
                {
                    ULONG nFlag;
                    LPCTSTR pszName;
                }
                s_Flags[] =
                {
                    { WiaItemTypeFree, TEXT("WiaItemTypeFree") },
                    { WiaItemTypeImage, TEXT("WiaItemTypeImage") },
                    { WiaItemTypeFile, TEXT("WiaItemTypeFile") },
                    { WiaItemTypeFolder, TEXT("WiaItemTypeFolder") },
                    { WiaItemTypeRoot, TEXT("WiaItemTypeRoot") },
                    { WiaItemTypeAnalyze, TEXT("WiaItemTypeAnalyze") },
                    { WiaItemTypeAudio, TEXT("WiaItemTypeAudio") },
                    { WiaItemTypeDevice, TEXT("WiaItemTypeDevice") },
                    { WiaItemTypeDeleted, TEXT("WiaItemTypeDeleted") },
                    { WiaItemTypeDisconnected, TEXT("WiaItemTypeDisconnected") },
                    { WiaItemTypeHPanorama, TEXT("WiaItemTypeHPanorama") },
                    { WiaItemTypeVPanorama, TEXT("WiaItemTypeVPanorama") },
                    { WiaItemTypeBurst, TEXT("WiaItemTypeBurst") },
                    { WiaItemTypeStorage, TEXT("WiaItemTypeStorage") },
                    { WiaItemTypeTransfer, TEXT("WiaItemTypeTransfer") },
                    { WiaItemTypeGenerated, TEXT("WiaItemTypeGenerated") },
                    { WiaItemTypeHasAttachments, TEXT("WiaItemTypeHasAttachments") },
                    { WiaItemTypeVideo, TEXT("WiaItemTypeVideo") }
                };
                for (int i=0;i<ARRAYSIZE(s_Flags);i++)
                {
                    if (nItemType & s_Flags[i].nFlag)
                    {
                        if (strResult.Length())
                        {
                            strResult += TEXT(" | ");
                        }
                        strResult += s_Flags[i].pszName;
                    }
                }
            }
        }
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetStringFromGuid( const GUID &guid )
{
    static HINSTANCE s_WiaDebugInstance = NULL;
    static GetStringFromGuidProc s_pfnGetStringFromGuid = NULL;

    if (!s_pfnGetStringFromGuid)
    {
        if (!s_WiaDebugInstance)
        {
            s_WiaDebugInstance = LoadLibrary(TEXT("wiadebug.dll"));
        }

        if (s_WiaDebugInstance)
        {
            s_pfnGetStringFromGuid = reinterpret_cast<GetStringFromGuidProc>(GetProcAddress( s_WiaDebugInstance, GET_STRING_FROM_GUID_NAME ));
        }
    }

    if (s_pfnGetStringFromGuid)
    {
        TCHAR szString[MAX_PATH];
        s_pfnGetStringFromGuid( &guid, szString, ARRAYSIZE(szString) );
        return szString;
    }
    else
    {
        CSimpleString strResult;

        LPOLESTR pszGuid = NULL;
        HRESULT hr = StringFromCLSID( guid, &pszGuid );
        if (SUCCEEDED(hr) && pszGuid)
        {
            strResult = CSimpleStringConvert::NaturalString(CSimpleStringWide(pszGuid));
            CoTaskMemFree(pszGuid);
        }
        return strResult;
    }
}

void CWiaDebugDump::DumpWiaPropertyStorage( IUnknown *pUnknown )
{
    if (OK())
    {
        //
        // Make sure we have a non-NULL interface pointer
        //
        if (pUnknown)
        {
            //
            // Get the proper interface
            //
            CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
            HRESULT hr = pUnknown->QueryInterface( IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage );
            if (SUCCEEDED(hr))
            {
                //
                // Get information about this property storage
                //
                CComPtr<IEnumSTATPROPSTG> pEnumStatPropStorage;
                hr = pWiaPropertyStorage->Enum(&pEnumStatPropStorage);
                if (SUCCEEDED(hr))
                {
                    //
                    // Enumerate the properties
                    //
                    STATPROPSTG StatPropStg = {0};
                    while ((hr = pEnumStatPropStorage->Next(1,&StatPropStg,NULL)) == S_OK)
                    {
                        //
                        // Prepare the propspec
                        //
                        PROPSPEC PropSpec = {0};
                        PropSpec.ulKind = PRSPEC_PROPID;
                        PropSpec.propid = StatPropStg.propid;

                        //
                        // Prepare the propvariant
                        //
                        PROPVARIANT PropVariant = {0};

                        //
                        // Get the property
                        //
                        hr = pWiaPropertyStorage->ReadMultiple( 1, &PropSpec, &PropVariant );
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Get the property attributes
                            //
                            ULONG nAccessFlags = 0;
                            PROPVARIANT PropVariantAttributes = {0};
                            hr = pWiaPropertyStorage->GetPropertyAttributes( 1, &PropSpec, &nAccessFlags, &PropVariantAttributes );
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Print out the properties
                                //
                                CSimpleString strName = GetPrintableName( StatPropStg );
                                Print( CSimpleString().Format(TEXT("  %s"), strName.String() ));

                                CSimpleString strType = GetPropVariantTypeString( PropVariant.vt );
                                Print( CSimpleString().Format(TEXT("    Type:   %s"), strType.String()) );

                                CSimpleString strAccess = GetPrintableAccessFlags( nAccessFlags );
                                Print( CSimpleString().Format(TEXT("    Access: %s"), strAccess.String()) );

                                CSimpleString strValue = GetPrintableValue( PropVariant );
                                Print( CSimpleString().Format(TEXT("    Curr:   %s"), strValue.String()) );

                                CSimpleString strLegalValues = GetPrintableLegalValues( nAccessFlags, PropVariantAttributes );
                                if (strLegalValues.Length())
                                {
                                    Print( CSimpleString().Format(TEXT("    Legal:  %s"), strLegalValues.String()) );
                                }

                                //
                                // Free the attributes
                                //
                                PropVariantClear(&PropVariantAttributes);
                            }

                            //
                            // Free the property
                            //
                            PropVariantClear(&PropVariant);
                        }


                        //
                        // Clean up the STATPROPSTG
                        //
                        if (StatPropStg.lpwstrName)
                        {
                            CoTaskMemFree(StatPropStg.lpwstrName);
                        }
                        ZeroMemory(&StatPropStg,sizeof(StatPropStg));
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::Print( LPCTSTR pszString )
{
    WIA_TRACE((TEXT("%s"), pszString ));
}

void CWiaDebugDump::PrintAndDestroyWiaDevCap( WIA_DEV_CAP &WiaDevCap, LPCTSTR pszType )
{
    if (OK())
    {
        Print( CSimpleString().Format(TEXT("  %s: %s"), pszType, GetStringFromGuid( WiaDevCap.guid ).String()));
        Print( CSimpleString().Format(TEXT("    Flags: %08X"), WiaDevCap.ulFlags) );
        if (WiaDevCap.bstrName)
        {
            Print( CSimpleString().Format(TEXT("    Name: %ws"), WiaDevCap.bstrName) );
            SysFreeString(WiaDevCap.bstrName);
            WiaDevCap.bstrName = NULL;
        }
        if (WiaDevCap.bstrDescription)
        {
            Print( CSimpleString().Format(TEXT("    Description: %ws"), WiaDevCap.bstrDescription) );
            SysFreeString(WiaDevCap.bstrDescription);
            WiaDevCap.bstrDescription = NULL;
        }
        if (WiaDevCap.bstrIcon)
        {
            Print( CSimpleString().Format(TEXT("    Icon: %ws"), WiaDevCap.bstrIcon));
            SysFreeString(WiaDevCap.bstrIcon);
            WiaDevCap.bstrIcon = NULL;
        }
        if (WiaDevCap.bstrCommandline)
        {
            Print( CSimpleString().Format(TEXT("    bstrCommandline: %ws"), WiaDevCap.bstrCommandline));
            SysFreeString(WiaDevCap.bstrCommandline);
            WiaDevCap.bstrCommandline = NULL;
        }
    }
}

void CWiaDebugDump::DumpCaps( IUnknown *pUnknown )
{
    if (pUnknown)
    {
        //
        // Get the item
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;
            hr = pWiaItem->EnumDeviceCapabilities(WIA_DEVICE_COMMANDS,&pEnumWIA_DEV_CAPS);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumWIA_DEV_CAPS->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    WIA_DEV_CAP WiaDevCap = {0};
                    hr = pEnumWIA_DEV_CAPS->Next(1, &WiaDevCap, NULL);
                    if (hr == S_OK)
                    {
                        PrintAndDestroyWiaDevCap( WiaDevCap, TEXT("Capability") );
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::DumpEvents( IUnknown *pUnknown )
{
    if (pUnknown)
    {
        //
        // Get the item
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;
            hr = pWiaItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,&pEnumWIA_DEV_CAPS);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumWIA_DEV_CAPS->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    WIA_DEV_CAP WiaDevCap = {0};
                    hr = pEnumWIA_DEV_CAPS->Next(1, &WiaDevCap, NULL);
                    if (hr == S_OK)
                    {
                        PrintAndDestroyWiaDevCap( WiaDevCap, TEXT("Event") );
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::DumpFormatInfo( IUnknown *pUnknown )
{
    if (OK())
    {
        if (pUnknown)
        {
            //
            // Get the data transfer interface
            //
            CComPtr<IWiaDataTransfer> pWiaDataTransfer;
            HRESULT hr = pUnknown->QueryInterface( IID_IWiaDataTransfer, (void**)&pWiaDataTransfer );
            if (SUCCEEDED(hr))
            {
                //
                // Get the format enumerator
                //
                CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;
                hr = pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO);
                if (SUCCEEDED(hr))
                {
                    //
                    // Start at the beginning
                    //
                    hr = pEnumWIA_FORMAT_INFO->Reset();
                    while (hr == S_OK)
                    {
                        //
                        // Get the next item
                        //
                        WIA_FORMAT_INFO WiaFormatInfo = {0};
                        hr = pEnumWIA_FORMAT_INFO->Next(1, &WiaFormatInfo, NULL);
                        if (hr == S_OK)
                        {
                            Print(CSimpleString().Format( TEXT("  Supported format: %s, TYMED: %s"), GetStringFromGuid( WiaFormatInfo.guidFormatID ).String(), GetTymedString( WiaFormatInfo.lTymed ).String() ));
                        }
                    }

                }
            }
        }
    }
}

void CWiaDebugDump::DumpWiaItem( IUnknown *pUnknown )
{
    if (OK() && pUnknown)
    {
        CSimpleStringWide strFullItemName;
        PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FULL_ITEM_NAME, strFullItemName );
        Print( CSimpleString().Format( TEXT("[Dumping %ws]"), strFullItemName.String() ) );
        CSimpleString strItemType = GetWiaItemTypeFlags( pUnknown );
        Print( CSimpleString().Format(TEXT("  Item Type: %s"), strItemType.String()) );
        DumpFormatInfo( pUnknown );
        DumpCaps( pUnknown );
        DumpEvents( pUnknown );
        DumpWiaPropertyStorage( pUnknown );
        Print( TEXT("") );
    }
}

void CWiaDebugDump::DumpRecursive( IUnknown *pUnknown )
{
    if (OK() && pUnknown)
    {
        //
        // Get an item pointer
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Dump this one
            //
            DumpWiaItem(pWiaItem);

            //
            // Recurse into this item's children
            //
            CComPtr <IEnumWiaItem> pEnumChildItem;
            hr = pWiaItem->EnumChildItems(&pEnumChildItem);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumChildItem->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    CComPtr<IWiaItem> pChildItem;
                    hr = pEnumChildItem->Next(1, &pChildItem, NULL);
                    if (hr == S_OK)
                    {
                        DumpRecursive( pChildItem );
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\errors.cpp ===
#include "precomp.h"
#pragma hdrstop

namespace UIErrors
{
     /**************************************
         UIErrors::ReportResult

         Given an HRESULT, map it to a user friendly message (when possible).
         If we don't have a mapping, defer to FormatMessage (ugh!)
         This function should be a last resort.

     ***************************************/

     VOID
     ReportResult (HWND hwndParent, HINSTANCE hInst, HRESULT hr)
     {
        switch (hr)
        {
            case RPC_E_CALL_REJECTED:
            case RPC_E_RETRY:
            case RPC_E_TIMEOUT:
                ReportError (hwndParent, hInst, ErrStiBusy);
                break;

            case RPC_E_SERVER_DIED:
            case RPC_E_SERVER_DIED_DNE:
            case RPC_E_DISCONNECTED:
                ReportError (hwndParent, hInst, ErrStiCrashed);
                break;

            default:
                LPTSTR szErrMsg = NULL;
                FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               hr,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               reinterpret_cast<LPTSTR>(&szErrMsg),
                               0,
                               NULL
                              );
                if (szErrMsg)
                {
                    CSimpleString strTitle;
                    strTitle.LoadString (IDS_ERRTITLE_HRESULT, hInst);
                    ReportMessage (hwndParent, hInst, NULL, strTitle, szErrMsg);
                }
                else
                {
                    ReportMessage (hwndParent, hInst, NULL, MAKEINTRESOURCE(IDS_ERRTITLE_UNKNOWNERR), MAKEINTRESOURCE(IDS_ERROR_UNKNOWNERR));
                }
                break;
        }
     }

     /**************************************
         UIErrors::ReportMessage

         These functions wrap MessageBoxIndirect to
         display given strings.

     ***************************************/



     VOID
     ReportMessage (HWND hwndParent,
                    HINSTANCE hInst,
                    LPCTSTR idIcon,
                    LPCTSTR idTitle,
                    LPCTSTR idMessage,
                    DWORD   dwStyle)
     {
         MSGBOXPARAMS mbp = {0};

         mbp.cbSize = sizeof(MSGBOXPARAMS);
         mbp.hwndOwner = hwndParent;
         mbp.hInstance = hInst;
         mbp.lpszText = idMessage;
         mbp.lpszCaption = idTitle;
         mbp.dwStyle = MB_OK | dwStyle;
         if (idIcon)
         {
             mbp.dwStyle |= MB_USERICON;
             mbp.lpszIcon = idIcon;
         }
         else
         {
             mbp.lpszIcon = NULL;
         }
         mbp.dwContextHelpId = 0;
         mbp.lpfnMsgBoxCallback = 0;
         mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
         MessageBoxIndirect (&mbp);
     }

     // build an array of message ids indexed by the WiaError enum

     struct MsgMap
     {
         INT      idTitle;
         INT      idMessage;
     } ErrorCodes [] =
     {
        {IDS_ERRTITLE_DISCONNECTED, IDS_ERROR_DISCONNECTED},
        {IDS_ERRTITLE_COMMFAILURE, IDS_ERROR_COMMFAILURE},
        {IDS_ERRTITLE_STICRASH, IDS_ERROR_STICRASH},
        {IDS_ERRTITLE_STIBUSY, IDS_ERROR_STIBUSY},
        {IDS_ERRTITLE_SCANFAIL, IDS_ERROR_SCANFAIL},
     };


     VOID
     ReportError (HWND hwndParent,
                  HINSTANCE hInst,
                  WiaError err)
     {


         ReportMessage (hwndParent, hInst, NULL, MAKEINTRESOURCE(ErrorCodes[err].idTitle), MAKEINTRESOURCE(ErrorCodes[err].idMessage));
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\dumpprop.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DUMPPROP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/25/2000
 *
 *  DESCRIPTION: Display the properties associated with a IWiaItem, either to the
 *               debugger, or to a log file.
 *
 *******************************************************************************/
#ifndef __DUMPPROP_H_INCLUDED
#define __DUMPPROP_H_INCLUDED

#include <simstr.h>
#include <wia.h>
#include <wiadebug.h>

class CWiaDebugDump
{
private:
    //
    // No implementation
    //
    CWiaDebugDump( const CWiaDebugDump & );
    CWiaDebugDump &operator=( const CWiaDebugDump & );

public:
    //
    // Static helper functions
    //
    static CSimpleString GetPropVariantTypeString( VARTYPE vt );
    static CSimpleString GetPrintableValue( PROPVARIANT &PropVariant );
    static CSimpleString GetPrintableValue( VARIANT &Variant );
    static CSimpleString GetPrintableName( const STATPROPSTG &StatPropStg );
    static CSimpleString GetPrintableAccessFlags( ULONG nAccessFlags );
    static CSimpleString GetPrintableLegalValues( ULONG nAccessFlags, const PROPVARIANT &PropVariantAttributes );
    static CSimpleString GetWiaItemTypeFlags( IUnknown *pUnknown );
    static CSimpleString GetStringFromGuid( const GUID &guid );
    static CSimpleString GetTymedString( LONG tymed );
    virtual void Print( LPCTSTR pszString );

protected:
    void PrintAndDestroyWiaDevCap( WIA_DEV_CAP &WiaDevCap, LPCTSTR pszType );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDump(void);
    virtual ~CWiaDebugDump(void);

    //
    // Helpers
    //
    void DumpFormatInfo( IUnknown *pUnknown );
    void DumpCaps( IUnknown *pUnknown );
    void DumpEvents( IUnknown *pUnknown );

    virtual bool OK(void) { return true; }

    //
    // These are the most generally useful functions
    //
    void DumpWiaPropertyStorage( IUnknown *pUnknown );
    void DumpWiaItem( IUnknown *pUnknown );
    void DumpRecursive( IUnknown *pUnknown );
};

class CWiaDebugDumpToFile : public CWiaDebugDump
{
private:
    HANDLE m_hFile;

private:
    CWiaDebugDumpToFile(void);
    CWiaDebugDumpToFile( const CWiaDebugDumpToFile & );
    CWiaDebugDumpToFile &operator=( const CWiaDebugDumpToFile & );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDumpToFile( LPCTSTR pszFilename, bool bOverwrite );
    virtual ~CWiaDebugDumpToFile(void);

    virtual bool OK(void) { return (m_hFile != INVALID_HANDLE_VALUE); }
    virtual void Print( LPCTSTR pszString );
};

class CWiaDebugDumpToFileHandle : public CWiaDebugDump
{
private:
    HANDLE m_hFile;

private:
    CWiaDebugDumpToFileHandle(void);
    CWiaDebugDumpToFileHandle( const CWiaDebugDumpToFileHandle & );
    CWiaDebugDumpToFileHandle &operator=( const CWiaDebugDumpToFileHandle & );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDumpToFileHandle( HANDLE hFile );
    virtual ~CWiaDebugDumpToFileHandle(void);

    virtual bool OK(void) { return (m_hFile != INVALID_HANDLE_VALUE); }
    virtual void Print( LPCTSTR pszString );
};

//
// This small helper function checks a registry entry, and saves the item or tree to the log file stored in that entry.  If
// one is not stored in that registry entry, nothing will be saved
//
inline void SaveItemTreeLog( HKEY hKey, LPCTSTR pszRegKey, LPCTSTR pszRegValue, bool bOverwrite, IWiaItem *pWiaItem, bool bRecurse )
{
    CSimpleString strFilename = CSimpleReg(hKey,pszRegKey,false,KEY_READ).Query(pszRegValue,TEXT(""));
    if (strFilename.Length())
    {
        if (bRecurse)
        {
            CWiaDebugDumpToFile(strFilename,bOverwrite).DumpRecursive(pWiaItem);
        }
        else
        {
            CWiaDebugDumpToFile(strFilename,bOverwrite).DumpWiaItem(pWiaItem);
        }
    }
}


//
// Debug-only macros
//
#if defined(DBG) || defined(DEBUG) || defined(_DEBUG)

//
// Save the whole tree to a log file, from this item down
//
#define WIA_SAVEITEMTREELOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem) SaveItemTreeLog( hKey, pszRegKey, pszRegValue, bOverwrite, pWiaItem, true )

//
// Save this item to a log file
//
#define WIA_SAVEITEMLOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)     SaveItemTreeLog( hKey, pszRegKey, pszRegValue, bOverwrite, pWiaItem, false )

//
// Print this item in the debugger
//
#define WIA_DUMPWIAITEM(pWiaItem)                                           CWiaDebugDump().DumpWiaItem(pWiaItem);

#else

#define WIA_SAVEITEMTREELOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)
#define WIA_SAVEITEMLOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)
#define WIA_DUMPWIAITEM(pWiaItem)

#endif


#endif // __DUMPPROP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\errors.h ===
#ifndef _ERRORS_H_
#define _ERRORS_H_

namespace UIErrors
{
    // If you add to this list you must update the ErrorCodes[] array in errors.cpp
    enum WiaError
    {
        ErrDisconnected=0,
        ErrCommunicationsFailure,
        ErrStiCrashed,
        ErrStiBusy,
        ErrScanFailed
    };


    VOID ReportResult (HWND hwndParent, HINSTANCE hInst, HRESULT hr);
    VOID ReportMessage (HWND hwndParent, HINSTANCE hInst, LPCTSTR idIcon, LPCTSTR idTitle,  LPCTSTR idMessage, DWORD dwStyle = 0);
    VOID ReportError (HWND hwndParent, HINSTANCE hInst, WiaError err);


};

// string resource identifiers
// If you include this file, make sure these don't collide with your resource IDs

#define UI_ERROR_MIN_ID                          23000

#define IDS_ERRTITLE_DISCONNECTED                UI_ERROR_MIN_ID
#define IDS_ERROR_DISCONNECTED                   UI_ERROR_MIN_ID+1
#define IDS_ERRTITLE_COMMFAILURE                 UI_ERROR_MIN_ID+2
#define IDS_ERROR_COMMFAILURE                    UI_ERROR_MIN_ID+3
#define IDS_ERRTITLE_STICRASH                    UI_ERROR_MIN_ID+4
#define IDS_ERROR_STICRASH                       UI_ERROR_MIN_ID+5
#define IDS_ERRTITLE_STIBUSY                     UI_ERROR_MIN_ID+6
#define IDS_ERROR_STIBUSY                        UI_ERROR_MIN_ID+7
#define IDS_ERRTITLE_SCANFAIL                    UI_ERROR_MIN_ID+8
#define IDS_ERROR_SCANFAIL                       UI_ERROR_MIN_ID+9
#define IDS_ERRTITLE_HRESULT                     UI_ERROR_MIN_ID+10
#define IDS_ERRTITLE_UNKNOWNERR                  UI_ERROR_MIN_ID+11
#define IDS_ERROR_UNKNOWNERR                     UI_ERROR_MIN_ID+12

//
// Straight mapping between WIA errors and strings
//
#define IDS_WIA_ERROR_GENERAL_ERROR              UI_ERROR_MIN_ID+32
#define IDS_WIA_ERROR_PAPER_JAM                  UI_ERROR_MIN_ID+33
#define IDS_WIA_ERROR_PAPER_EMPTY                UI_ERROR_MIN_ID+34
#define IDS_WIA_ERROR_PAPER_PROBLEM              UI_ERROR_MIN_ID+35
#define IDS_WIA_ERROR_OFFLINE                    UI_ERROR_MIN_ID+36
#define IDS_WIA_ERROR_BUSY                       UI_ERROR_MIN_ID+37
#define IDS_WIA_ERROR_WARMING_UP                 UI_ERROR_MIN_ID+38
#define IDS_WIA_ERROR_USER_INTERVENTION          UI_ERROR_MIN_ID+39
#define IDS_WIA_ERROR_ITEM_DELETED               UI_ERROR_MIN_ID+40
#define IDS_WIA_ERROR_DEVICE_COMMUNICATION       UI_ERROR_MIN_ID+41
#define IDS_WIA_ERROR_INVALID_COMMAND            UI_ERROR_MIN_ID+42
#define IDS_WIA_ERROR_INCORRECT_HARDWARE_SETTING UI_ERROR_MIN_ID+43
#define IDS_WIA_ERROR_DEVICE_LOCKED              UI_ERROR_MIN_ID+44

#define UI_ERROR_MAX_ID                          UI_ERROR_MIN_ID+44

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\gdbgdata.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "wiadebug.h"

CSystemGlobalData *CGlobalDebugState::Lock(void)
{
    CSystemGlobalData *pSystemGlobalData = NULL;
    if (IsValid())
    {
        DWORD dwWait = WaitForSingleObject(m_hSystemDataMutex,10000);
        if (WAIT_OBJECT_0 == dwWait)
        {
            pSystemGlobalData = m_pSystemGlobalData;
        }
    }
    return pSystemGlobalData;
}

void CGlobalDebugState::Release(void)
{
    ReleaseMutex(m_hSystemDataMutex);
}

CGlobalDebugState::CGlobalDebugState(void)
  : m_hSystemDataMutex(NULL),
    m_hMemoryMappedFile(NULL),
    m_pSystemGlobalData(NULL)
{
    //
    // Create the mutex that protects the system global data
    //
    m_hSystemDataMutex = CreateMutex( NULL, FALSE, WIADEBUG_MEMORYMAPPED_MUTEXNAME );
    if (m_hSystemDataMutex)
    {
        //
        // Grab the mutex that protects the system global data
        //
        DWORD dwWait = WaitForSingleObject( m_hSystemDataMutex, 10000 );
        if (WAIT_OBJECT_0 == dwWait)
        {
            //
            // First try to open the memory mapped file.
            //
            m_hMemoryMappedFile = OpenFileMapping( FILE_MAP_WRITE, FALSE, WIADEBUG_MEMORYMAPPED_FILENAME );
            if (m_hMemoryMappedFile)
            {
                m_pSystemGlobalData = reinterpret_cast<CSystemGlobalData*>(MapViewOfFile( m_hMemoryMappedFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 ));
            }
            else
            {
                //
                // Create the memory mapped file
                //
                m_hMemoryMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(CSystemGlobalData), WIADEBUG_MEMORYMAPPED_FILENAME );
                if (m_hMemoryMappedFile)
                {
                    m_pSystemGlobalData = reinterpret_cast<CSystemGlobalData*>(MapViewOfFile( m_hMemoryMappedFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 ));
                    if (m_pSystemGlobalData)
                    {
                        //
                        // Start off with everything zeroed out.
                        //
                        ZeroMemory( m_pSystemGlobalData, sizeof( CSystemGlobalData ) );

                        //
                        // Get the initial global debug settings from the registry
                        //
                        m_pSystemGlobalData->nAllowDebugMessages = CSimpleReg( HKEY_CLASSES_ROOT, DEBUG_REGISTRY_PATH, false, KEY_READ ).Query( DEBUG_REGISTRY_ENABLE_DBG, 0 );

                        //
                        // No window is registered initially
                        //
                        m_pSystemGlobalData->hwndDebug = NULL;

                        //
                        // Initialize color table data
                        //
                        static const COLORREF crColors[NUMBER_OF_DEBUG_COLORS] =
                        {
                            RGB(0x00,0x00,0x00),
                            RGB(0x00,0x00,0x7F),
                            RGB(0x00,0x7F,0x00),
                            RGB(0x00,0x7F,0x7F),
                            RGB(0x7F,0x00,0x00),
                            RGB(0x7F,0x00,0x7F),
                            RGB(0x7F,0x00,0x7F),
                            RGB(0x7F,0x7F,0x7F)
                        };
                        for (int i=0;i<NUMBER_OF_DEBUG_COLORS;i++)
                        {
                            m_pSystemGlobalData->crDebugColors[i] = crColors[i];
                        }
                        m_pSystemGlobalData->nCurrentColor = 0;
                    }
                }
            }
            ReleaseMutex(m_hSystemDataMutex);
        }
    }

    //
    // If everything didn't work out, destroy the object completely
    //
    if (!IsValid())
    {
        Destroy();
    }
}

void CGlobalDebugState::Destroy(void)
{
    if (m_pSystemGlobalData)
    {
        UnmapViewOfFile(m_pSystemGlobalData);
        m_pSystemGlobalData = NULL;
    }
    if (m_hMemoryMappedFile)
    {
        CloseHandle(m_hMemoryMappedFile);
        m_hMemoryMappedFile = NULL;
    }
    if (m_hSystemDataMutex)
    {
        CloseHandle(m_hSystemDataMutex);
        m_hSystemDataMutex = NULL;
    }
}

CGlobalDebugState::~CGlobalDebugState(void)
{
    Destroy();
}

bool CGlobalDebugState::IsValid(void) const
{
    return (m_hSystemDataMutex && m_hMemoryMappedFile && m_pSystemGlobalData);
}

DWORD CGlobalDebugState::AllowDebugMessages(void)
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nAllowDebugMessages;
        Release();
    }
    return nResult;
}


DWORD CGlobalDebugState::AllowDebugMessages( DWORD nAllowDebugMessages )
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nAllowDebugMessages;
        m_pSystemGlobalData->nAllowDebugMessages = nAllowDebugMessages;
        Release();
    }
    return nResult;
}

DWORD CGlobalDebugState::AllocateNextColorIndex(void)
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nCurrentColor++;
        Release();
    }
    return nResult;
}

COLORREF CGlobalDebugState::GetColorFromIndex( DWORD nIndex )
{
    COLORREF crResult = RGB(0,0,0);
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        crResult = m_pSystemGlobalData->crDebugColors[nIndex % NUMBER_OF_DEBUG_COLORS];
        Release();
    }
    return crResult;
}

bool CGlobalDebugState::DebugWindow( HWND hWnd )
{
    bool bResult = false;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        m_pSystemGlobalData->hwndDebug = static_cast<DWORD>(reinterpret_cast<UINT_PTR>(hWnd));
        bResult = true;
        Release();
    }
    return bResult;
}

HWND CGlobalDebugState::DebugWindow(void)
{
    HWND hWndResult = NULL;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        hWndResult = reinterpret_cast<HWND>(static_cast<UINT_PTR>(m_pSystemGlobalData->hwndDebug));
        Release();
    }
    return hWndResult;
}

bool CGlobalDebugState::SendDebugWindowMessage( UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    bool bResult = false;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        HWND hWndDebug = reinterpret_cast<HWND>(static_cast<UINT_PTR>(m_pSystemGlobalData->hwndDebug));
        if (IsWindow(hWndDebug))
        {
            SendMessage( hWndDebug, nMsg, wParam, lParam );
            bResult = true;
        }
        Release();
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\gwiaevnt.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GWIAEVNT.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/29/1999
 *
 *  DESCRIPTION: Generic reusable WIA event handler that posts the specified
 *  message to the specified window.
 *
 *  The message will be sent with the following arguments:
 *
 *
 *  WPARAM = NULL
 *  LPARAM = CGenericWiaEventHandler::CEventMessage *pEventMessage
 *
 *  pEventMessage MUST be freed in the message handler using delete
 *
 *  pEventMessage is allocated using an overloaded new operator, to ensure that
 *  the same allocator and de-allocator are used.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "gwiaevnt.h"

CGenericWiaEventHandler::CGenericWiaEventHandler(void)
  : m_hWnd(NULL),
    m_nWiaEventMessage(0),
    m_cRef(0)
{
}

STDMETHODIMP CGenericWiaEventHandler::Initialize( HWND hWnd, UINT nWiaEventMessage )
{
    m_hWnd = hWnd;
    m_nWiaEventMessage = nWiaEventMessage;
    return S_OK;
}

STDMETHODIMP CGenericWiaEventHandler::QueryInterface( REFIID riid, LPVOID *ppvObject )
{
    WIA_PUSHFUNCTION(TEXT("CWiaDefaultUI::QueryInterface"));
    if (IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaEventCallback ))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else
    {
        *ppvObject = NULL;
        return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    return(S_OK);
}


STDMETHODIMP_(ULONG) CGenericWiaEventHandler::AddRef(void)
{
    DllAddRef();
    return(InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) CGenericWiaEventHandler::Release(void)
{
    DllRelease();
    LONG nRefCount = InterlockedDecrement(&m_cRef);
    if (!nRefCount)
    {
        delete this;
    }
    return(nRefCount);
}

STDMETHODIMP CGenericWiaEventHandler::ImageEventCallback( const GUID *pEventGUID, BSTR bstrEventDescription, BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType, BSTR bstrFullItemName, ULONG *pulEventType, ULONG ulReserved )
{
    WIA_PUSHFUNCTION(TEXT("CGenericWiaEventHandler::ImageEventCallback"));

    //
    // Make sure (as best we can) that everything is OK before we allocate any memory
    //
    if (m_hWnd && m_nWiaEventMessage && IsWindow(m_hWnd))
    {
        //
        // Allocate the new message
        //
        CEventMessage *pEventMessage = new CEventMessage( *pEventGUID, bstrEventDescription, bstrDeviceID, bstrDeviceDescription, dwDeviceType, bstrFullItemName );
        if (pEventMessage)
        {
            //
            // Send the message to the notify window
            //
            LRESULT lRes = SendMessage( m_hWnd, m_nWiaEventMessage, NULL, reinterpret_cast<LPARAM>(pEventMessage) );

            //
            // If the callee didn't handle the message, delete it
            //
            if (HANDLED_EVENT_MESSAGE != lRes)
            {
                delete pEventMessage;
            }
        }
    }
    return S_OK;
}

HRESULT CGenericWiaEventHandler::RegisterForWiaEvent( LPCWSTR pwszDeviceId, const GUID &guidEvent, IUnknown **ppUnknown, HWND hWnd, UINT nMsg )
{
    WIA_PUSHFUNCTION(TEXT("CGenericWiaEventHandler::RegisterForWiaEvent"));

    //
    // Create the device manager
    //
    CComPtr<IWiaDevMgr> pWiaDevMgr;
    HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
    if (SUCCEEDED(hr) && pWiaDevMgr)
    {
        //
        // Create our event handler
        //
        CGenericWiaEventHandler *pEventHandler = new CGenericWiaEventHandler();
        if (pEventHandler)
        {
            //
            // Initialize it with the window handle and message we will be sending
            //
            hr = pEventHandler->Initialize( hWnd, nMsg );
            if (SUCCEEDED(hr))
            {
                //
                // Get the callback interface pointer
                //
                CComPtr<IWiaEventCallback> pWiaEventCallback;
                hr = pEventHandler->QueryInterface( IID_IWiaEventCallback, (void**)&pWiaEventCallback );
                if (SUCCEEDED(hr) && pWiaEventCallback)
                {
                    //
                    // Register for the event
                    //
                    hr = pWiaDevMgr->RegisterEventCallbackInterface( 0, pwszDeviceId ? CSimpleBStr(pwszDeviceId).BString() : NULL, &guidEvent, pWiaEventCallback, ppUnknown );
                    if (!SUCCEEDED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("pWiaDevMgr->RegisterEventCallbackInterface failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("pEventHandler->QueryInterface( IID_IWiaEventCallback, ... ) failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pEventHandler->Initialize failed")));
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            WIA_PRINTHRESULT((hr,TEXT("Unable to allocate pEventHandler")));
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("CoCreateInstance of dev mgr failed")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\isuppfmt.h ===
#ifndef __ISUPPFMT_H_INCLUDED
#define __ISUPPFMT_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

#undef  INTERFACE
#define INTERFACE IWiaSupportedFormats
DECLARE_INTERFACE_(IWiaSupportedFormats, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaSupportedFormats methods ***
    STDMETHOD(Initialize)( THIS_
                    IWiaItem *pWiaItem,
                    LONG nMediaType
                    ) PURE;
    STDMETHOD(GetFormatCount)( THIS_
                    OUT LONG    *pnCount
                    ) PURE;
    STDMETHOD(GetFormatType)( THIS_
                    IN  LONG       nFormat,
                    OUT GUID *pcfClipFormat
                    ) PURE;
    STDMETHOD(GetFormatExtension)( THIS_
                    IN  LONG    nFormat,
                    OUT LPWSTR  pszExtension,
                    IN  int     nMaxLen
                    ) PURE;
    STDMETHOD(GetFormatDescription)( THIS_
                    IN  LONG   nFormat,
                    OUT LPWSTR pszDescription,
                    IN  int    nMaxLen
                    ) PURE;
    STDMETHOD(GetDefaultClipboardFileFormat)( THIS_
                    OUT GUID   *pcfFormat
                    ) PURE;
    STDMETHOD(GetDefaultClipboardFileFormatIndex)( THIS_
                    OUT LONG    *pnFormat
                    ) PURE;
    STDMETHOD(GetClipboardFileExtension)( THIS_
                    IN  GUID cfFormat,
                    OUT LPWSTR pszExt,
                    IN  DWORD nMaxLen
                    ) PURE;
    STDMETHOD(ChangeClipboardFileExtension)( THIS_
                    IN GUID cfFormat,         // IN.       File type
                    IN OUT LPWSTR pszFilename,          // IN, OUT.  Filename, with or without extension.  It will be corrected to have the proper extension
                    IN DWORD nMaxLen                // IN.       Maximum buffer length
                    ) PURE;
    STDMETHOD(ConstructFileOpenDialogStyleString)( THIS_
                    OUT BSTR   *pbstrString
                    ) PURE;

};

// {57F5D4A3-41D8-4BD3-9452-6E3026E63D1E}
DEFINE_GUID(IID_IWiaSupportedFormats, 0x57F5D4A3, 0x41D8, 0x4BD3, 0x94, 0x52, 0x6E, 0x30, 0x26, 0xE6, 0x3D, 0x1E);

#endif //__ISUPPFMT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\itranspl.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ITRANSPL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        3/1/2000
 *
 *  DESCRIPTION: Image transfer plugin declarations for the scanner and camera wizard
 *
 *  1.  Implemented as an inproc, apartment-threaded COM component.
 *
 *  2.  Component to display UI *only* during IImageTransferPlugin::OpenConnection.
 *
 *  3.  UI displayed during IImageTransferPlugin::OpenConnection should be a modal dialog
 *      using hwndParent as the parent window.  This window may be NULL.
 *
 *  4.  The icon returned from IImageTransferPlugin::GetPluginIcon must be
 *      copied to a new icon using CopyIcon.
 *
 *******************************************************************************/

#ifndef __ITRANSPL_H_INCLUDED
#define __ITRANSPL_H_INCLUDED

#undef  INTERFACE
#define INTERFACE IImageTransferPluginProgressCallback
DECLARE_INTERFACE_(IImageTransferPluginProgressCallback, IUnknown)
{
    //
    // *** IUnknown methods ***
    //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //
    // *** IImageTransferPluginProgressCallback methods ***
    //
    STDMETHOD(SetProgressMessage)( THIS_ BSTR bstrMessage );
    STDMETHOD(SetCurrentFile)( THIS_ UINT nIndex );
    STDMETHOD(SetOverallPercent)( THIS_ UINT nPercent );
    STDMETHOD(SetFilePercent)( THIS_ UINT nPercent );
    STDMETHOD(Cancelled)( THIS_ UINT *bCancelled );
};

//
// {EC749A35-CE66-483a-B661-A22269F2B375}
//
DEFINE_GUID(IID_IImageTransferPluginProgressCallback, 0xEC749A35, 0xCE66, 0x483A, 0xB6, 0x61, 0xA2, 0x22, 0x69, 0xF2, 0xB3, 0x75);


#undef  INTERFACE
#define INTERFACE IImageTransferPlugin
DECLARE_INTERFACE_(IImageTransferPlugin, IUnknown)
{
    //
    // *** IUnknown methods ***
    //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //
    // *** IImageTransferPlugin methods ***
    //
    STDMETHOD(GetPluginCount)( THIS_ ULONG *pnCount );
    STDMETHOD(GetPluginName)( THIS_ ULONG nPluginId, BSTR *pbstrName );
    STDMETHOD(GetPluginDescription)( THIS_ ULONG nPluginId, BSTR *pbstrDescription );
    STDMETHOD(GetPluginIcon)( THIS_ ULONG nPluginId, HICON *phIcon, int nWidth, int nHeight );
    STDMETHOD(OpenConnection)( THIS_ HWND hwndParent, ULONG nPluginId, IImageTransferPluginProgressCallback *pImageTransferPluginProgressCallback );
    STDMETHOD(AddFile)( THIS_ BSTR bstrFilename, BSTR bstrDescription, const GUID &guidImageFormat, BOOL bDelete );
    STDMETHOD(TransferFiles)( THIS_ BSTR bstrGlobalDescription );
    STDMETHOD(OpenDestination)( THIS_ );
    STDMETHOD(CloseConnection)( THIS_ );
};

//
// {2AC44F64-7156-46ef-B9BF-2A6D70ABC4BC}
//
DEFINE_GUID(IID_IImageTransferPlugin, 0x2AC44F64, 0x7156, 0x46EF, 0xB9, 0xBF, 0x2A, 0x6D, 0x70, 0xAB, 0xC4, 0xBC);

#endif __ITRANSPL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\itranhlp.h ===
#ifndef __ITRANHLP_H_INCLUDED
#define __ITRANHLP_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>


#define WIA_TRANSFERHELPER_NOPROGRESS         0x00000001  // Don't show progress dialog
#define WIA_TRANSFERHELPER_NOCANCEL           0x00000002  // Don't allow the user to cancel using the system provided progress dialog
#define WIA_TRANSFERHELPER_PRESERVEFAILEDFILE 0x00000004  // If the transfer results in a valid file, even if there is an error, preserve it.  Otherwise, it will be deleted.

#undef  INTERFACE
#define INTERFACE IWiaTransferHelper
DECLARE_INTERFACE_(IWiaTransferHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaTransferHelper methods ***
    STDMETHOD(TransferItemFile)( THIS_
                        IWiaItem *pWiaItem,          // IN.       Transfer Item
                        HWND hwndParent,             // IN.       Parent window for status dialog.  NULL ok.
                        DWORD dwFlags,               // IN.       Flags
                        GUID cfFormat,               // IN.       WiaImgFmt_BMP, etc.  Pass 0 for the default file type
                        LPCWSTR pszFilename,         // IN.       File to which this data will be stored.
                        IWiaDataCallback *pCallback, // IN.       Optional callback.  May specify NULL
                        LONG nMediaType              // IN.       Either TYMED_FILE or TYMED_MULTIPAGE_FILE
                        ) PURE;
    STDMETHOD(TransferItemBanded)( THIS_
                        IWiaItem *pWiaItem,          // IN.       Transfer Item
                        HWND hwndParent,             // IN.       Parent window for status dialog.  NULL ok.
                        DWORD dwFlags,               // IN.       Flags
                        GUID cfFormat,               // IN.       WiaImgFmt_BMP, etc.  Pass 0 for the default file type
                        ULONG ulBufferSize,          // IN.       Size of transfer buffer.  Pass 0 to use the minimum.
                        IWiaDataCallback *pCallback  // IN.       Required callback
                        ) PURE;
};

// {74569BD2-877A-4677-A1E5-ADDA5A09BDBF}
DEFINE_GUID(IID_IWiaTransferHelper, 0x74569BD2, 0x877A, 0x4677, 0xA1, 0xE5, 0xAD, 0xDA, 0x5A, 0x09, 0xBD, 0xBF);

#undef  INTERFACE
#define INTERFACE IWiaMiscellaneousHelpers
DECLARE_INTERFACE_(IWiaMiscellaneousHelpers, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaMiscellaneousHelper methods ***
    STDMETHOD(GetDeviceIcon)( THIS_
                        LONG nDeviceType,
                        HICON *phIcon,
                        int nSize
                        ) PURE;
};

// {DFF1EE6C-9A4F-4652-990B-315775D42A96}
DEFINE_GUID(IID_IWiaMiscellaneousHelpers, 0xDFF1EE6C, 0x9A4F, 0x4652, 0x99, 0xB, 0x31, 0x57, 0x75, 0xD4, 0x2A, 0x96);

enum CAnnotationType
{
    AnnotationNone     = 0x00000000,
    AnnotationUnknown  = 0x00000001,
    AnnotationAudio    = 0x00000002
};

#undef  INTERFACE
#define INTERFACE IWiaAnnotationHelpers
DECLARE_INTERFACE_(IWiaAnnotationHelpers, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaAnnotationHelpers methods ***
    STDMETHOD(GetAnnotationOverlayIcon)( THIS_
                        CAnnotationType AnnotationType,
                        HICON *phIcon,
                        int nSize
                        ) PURE;
    STDMETHOD(GetAnnotationType)( THIS_
                        IUnknown *pUnknown,
                        CAnnotationType &AnnotationType
                        ) PURE;
    STDMETHOD(GetAnnotationFormat)( THIS_
                        IUnknown *pUnknown,
                        GUID &guidFormat
                        ) PURE;
    STDMETHOD(GetAnnotationSize)( THIS_
                        IUnknown *pUnknown,
                        LONG &nSize,
                        LONG nMediaType
                        ) PURE;
    STDMETHOD(TransferAttachmentToMemory)( THIS_
                        IUnknown *pUnknown,
                        GUID &guidFormat,
                        HWND hWndProgressParent,
                        PBYTE *pBuffer,
                        DWORD *pdwSize
                        ) PURE;

};

// {30F6E8E8-850C-4241-8440-561EBC221A5E}
DEFINE_GUID( IID_IWiaAnnotationHelpers, 0x30f6e8e8, 0x850c, 0x4241, 0x84, 0x40, 0x56, 0x1e, 0xbc, 0x22, 0x1a, 0x5e );


struct CWiaPaperSize
{
    LPWSTR  pszName;
    ULONG   nWidth;
    ULONG   nHeight;
};

#undef  INTERFACE
#define INTERFACE IWiaScannerPaperSizes
DECLARE_INTERFACE_(IWiaScannerPaperSizes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaScannerPaperSizes methods ***
    STDMETHOD(GetPaperSizes)( THIS_
                        CWiaPaperSize **ppPaperSizes,
                        UINT *pnCount
                        ) PURE;
    STDMETHOD(FreePaperSizes)( THIS_
                        CWiaPaperSize **ppPaperSizes,
                        UINT *pnCount
                        ) PURE;
};

// {E3F1175E-BA5D-445c-8E44-F1D9BD29580D}
DEFINE_GUID(IID_IWiaScannerPaperSizes, 0xe3f1175e, 0xba5d, 0x445c, 0x8e, 0x44, 0xf1, 0xd9, 0xbd, 0x29, 0x58, 0xd);



#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif //__ITRANHLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\gwiaevnt.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GWIAEVNT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/29/1999
 *
 *  DESCRIPTION: Generic reusable WIA event handler that posts the specified
 *  message to the specified window.
 *
 *  The message will be sent with the following arguments:
 *
 *
 *  WPARAM = NULL
 *  LPARAM = CGenericWiaEventHandler::CEventMessage *pEventMessage
 *
 *  pEventMessage MUST be freed in the message handler using delete
 *
 *  pEventMessage is allocated using an overloaded new operator, to ensure that
 *  the same allocator and de-allocator are used.
 *
 *******************************************************************************/
#ifndef __GWIAEVNT_H_INCLUDED
#define __GWIAEVNT_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "simstr.h"
#include "wiadebug.h"
#include "modlock.h"

//
// If the callee doesn't return this value, we delete the message data ourselves.
//
#define HANDLED_EVENT_MESSAGE 1002

class CGenericWiaEventHandler : public IWiaEventCallback
{
public:

    class CEventMessage
    {
    private:
        GUID              m_guidEventId;
        CSimpleStringWide m_wstrEventDescription;
        CSimpleStringWide m_wstrDeviceId;
        CSimpleStringWide m_wstrDeviceDescription;
        DWORD             m_dwDeviceType;
        CSimpleStringWide m_wstrFullItemName;

    private:
        // No implementation
        CEventMessage(void);
        CEventMessage( const CEventMessage & );
        CEventMessage &operator=( const CEventMessage & );

    public:
        CEventMessage( const GUID &guidEventId, LPCWSTR pwszEventDescription, LPCWSTR pwszDeviceId, LPCWSTR pwszDeviceDescription, DWORD dwDeviceType, LPCWSTR pwszFullItemName )
          : m_guidEventId(guidEventId),
            m_wstrEventDescription(pwszEventDescription),
            m_wstrDeviceId(pwszDeviceId),
            m_wstrDeviceDescription(pwszDeviceDescription),
            m_dwDeviceType(dwDeviceType),
            m_wstrFullItemName(pwszFullItemName)
        {
        }
        GUID EventId(void) const
        {
            return m_guidEventId;
        }
        CSimpleStringWide EventDescription(void) const
        {
            return m_wstrEventDescription;
        }
        CSimpleStringWide DeviceId(void) const
        {
            return m_wstrDeviceId;
        }
        CSimpleStringWide DeviceDescription(void) const
        {
            return m_wstrDeviceDescription;
        }
        DWORD DeviceType(void) const
        {
            return m_dwDeviceType;
        }
        CSimpleStringWide FullItemName(void) const
        {
            return m_wstrFullItemName;
        }
        void *operator new( size_t nSize )
        {
            if (nSize)
            {
                return reinterpret_cast<void*>(LocalAlloc(LPTR,nSize));
            }
            return NULL;
        }
        void operator delete( void *pVoid )
        {
            if (pVoid)
            {
                LocalFree( pVoid );
            }
        }
    };

private:
   HWND m_hWnd;
   UINT m_nWiaEventMessage;
   LONG m_cRef;

public:
    CGenericWiaEventHandler(void);
    ~CGenericWiaEventHandler(void) {}

    STDMETHODIMP Initialize( HWND hWnd, UINT nWiaEventMessage );

    // IUnknown
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObject );
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWiaEventCallback
    STDMETHODIMP ImageEventCallback( const GUID *pEventGUID, BSTR bstrEventDescription, BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType, BSTR bstrFullItemName, ULONG *pulEventType, ULONG ulReserved );

public:
    static HRESULT RegisterForWiaEvent( LPCWSTR pwszDeviceId, const GUID &guidEvent, IUnknown **ppUnknown, HWND hWnd, UINT nMsg );
};

#endif //__GWIAEVNT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\mboxex.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MBOXEX.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/13/2000
 *
 *  DESCRIPTION: Super duper message box
 *
 *******************************************************************************/
#ifndef __MBOXEX_H_INCLUDED
#define __MBOXEX_H_INCLUDED

#include <windows.h>
#include <simstr.h>

class CMessageBoxEx
{
public:

    enum
    {
        //
        // Greatest number of buttons allowed
        //
        MaxButtons = 4
    };

    enum
    {
        //
        // Button formats
        //
        MBEX_OK                      = 0x00000000,
        MBEX_OKCANCEL                = 0x00000001,
        MBEX_YESNO                   = 0x00000002,
        MBEX_CANCELRETRY             = 0x00000010,
        MBEX_CANCELRETRYSKIPSKIPALL  = 0x00000020,
        MBEX_YESYESTOALLNONOTOALL    = 0x00000040,

        //
        // Default button flags
        //
        MBEX_DEFBUTTON1              = 0x00000000,
        MBEX_DEFBUTTON2              = 0x00100000,
        MBEX_DEFBUTTON3              = 0x00200000,
        MBEX_DEFBUTTON4              = 0x00400000,

        //
        // Icons
        //
        MBEX_ICONWARNING             = 0x00000100,
        MBEX_ICONINFORMATION         = 0x00000000,
        MBEX_ICONQUESTION            = 0x00000400,
        MBEX_ICONERROR               = 0x00000800,

        //
        // Advanced flags
        //
        MBEX_HIDEFUTUREMESSAGES      = 0x00010000,

        //
        // Return values
        //
        IDMBEX_OK                    = 0x00000001,
        IDMBEX_CANCEL                = 0x00000002,
        IDMBEX_RETRY                 = 0x00000004,
        IDMBEX_SKIP                  = 0x00000005,
        IDMBEX_YES                   = 0x00000006,
        IDMBEX_NO                    = 0x00000007,
        IDMBEX_SKIPALL               = 0x00000012,
        IDMBEX_YESTOALL              = 0x00000013,
        IDMBEX_NOTOALL               = 0x00000014
    };

public:
    class CData
    {
    public:
        UINT          m_Buttons[MaxButtons];
        CSimpleString m_strTitle;
        CSimpleString m_strMessage;
        UINT          m_nButtonCount;
        UINT          m_nFlags;
        HICON         m_hIcon;
        LPARAM        m_lParam;
        UINT          m_nDefault;
        bool          m_bHideMessageInFuture;

    private:
        CData( const CData & );
        CData &operator=( const CData & );

    public:
        CData(void)
          : m_strTitle(TEXT("")),
            m_strMessage(TEXT("")),
            m_nButtonCount(0),
            m_nFlags(0),
            m_hIcon(NULL),
            m_lParam(0),
            m_nDefault(0),
            m_bHideMessageInFuture(FALSE)
        {
            ZeroMemory( m_Buttons, ARRAYSIZE(m_Buttons) );
        }
    };

private:
    HWND   m_hWnd;
    CData *m_pData;

private:
    CMessageBoxEx(void);
    CMessageBoxEx( const CMessageBoxEx & );
    CMessageBoxEx &operator=( const CMessageBoxEx & );

private:
    explicit CMessageBoxEx( HWND hWnd );
    LRESULT OnInitDialog( WPARAM, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

public:
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool *pbHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags );
    static UINT MessageBox( LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags );
    static UINT MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nMessageId, UINT nTitleId, UINT nFlags, bool &bHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, LPCTSTR pszFormat, ... );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages, LPCTSTR pszFormat, ... );
    static UINT MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nTitleId, UINT nFlags, UINT nFormatId, ... );
};

#endif // __MBOXEX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\mboxex.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MBOXEX.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/13/2000
 *
 *  DESCRIPTION: Super duper message box
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <simcrack.h>
#include <movewnd.h>
#include <dlgunits.h>
#include <simrect.h>
#include <shlwapi.h>
#include "mboxex.rh"
#include "mboxex.h"

extern HINSTANCE g_hInstance;

CMessageBoxEx::CMessageBoxEx( HWND hWnd )
  : m_hWnd(hWnd),
    m_pData(NULL)
{
}


LRESULT CMessageBoxEx::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CMessageBoxEx::OnInitDialog"));
    //
    // Actual button ids
    //
    const UINT nButtonIds[MaxButtons] = { IDC_MESSAGEBOX_BUTTON_1, IDC_MESSAGEBOX_BUTTON_2, IDC_MESSAGEBOX_BUTTON_3, IDC_MESSAGEBOX_BUTTON_4 };

    //
    // Get the data, and return and error if it is invalid
    //
    m_pData = reinterpret_cast<CData*>(lParam);
    if (!m_pData)
    {
        EndDialog( m_hWnd, -1 );
        return 0;
    }

    //
    // Set the button text for the used buttons
    //
    for (UINT i=0,nStart=MaxButtons-m_pData->m_nButtonCount;i<m_pData->m_nButtonCount;i++)
    {
        SetWindowLongPtr( GetDlgItem( m_hWnd, nButtonIds[nStart+i] ), GWLP_USERDATA, nButtonIds[nStart+i] );
    }

    //
    // Set the default for the "Hide future messages" button
    //
    if (m_pData->m_bHideMessageInFuture)
    {
        SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE, BM_SETCHECK, BST_CHECKED, 0 );
    }

    int nDeltaY = 0;

    HDC hDC = GetDC( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ) );
    if (hDC)
    {
        //
        // Get the window rect of the message control
        //
        CSimpleRect rcMessage( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), CSimpleRect::WindowRect );
        rcMessage.ScreenToClient(m_hWnd);

        //
        // Get the correct font
        //
        HFONT hFont = reinterpret_cast<HFONT>(SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_MESSAGE, WM_GETFONT, 0, 0 ));
        if (!hFont)
        {
            hFont = reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT));
        }

        if (hFont)
        {
            //
            // Calculate the height of the text
            //
            CSimpleRect rcText = rcMessage;
            HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject( hDC, hFont ));
            int nHeight = DrawText( hDC, m_pData->m_strMessage, m_pData->m_strMessage.Length(), &rcText, DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX|DT_WORDBREAK );

            //
            // Only resize the control if it needs to be larger.  Don't do it if the control needs to be smaller.
            //
            if (nHeight > rcMessage.Height())
            {
                nDeltaY += (rcMessage.Height() - nHeight);
                CMoveWindow().Size( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), 0, nHeight, CMoveWindow::NO_SIZEX );
            }

            SelectObject( hDC, hOldFont );
        }
        ReleaseDC( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), hDC );
    }

    //
    // If we are not supposed to show the "Hide future messages" button, hide it
    // and move all of the controls up by its height and vertical margin.
    //
    if ((m_pData->m_nFlags & MBEX_HIDEFUTUREMESSAGES) == 0)
    {
        EnableWindow( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), FALSE );
        ShowWindow( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), SW_HIDE );

        //
        // Figure out how much to move the controls up
        //
        nDeltaY += CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), CSimpleRect::WindowRect ).Height() + CDialogUnits(m_hWnd).Y(7);
    }

    if (nDeltaY)
    {
        CMoveWindow mw;

        //
        // Move the "Hide future messages" button
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), 0, CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top - nDeltaY, CMoveWindow::NO_MOVEX );

        //
        // Figure out what the top row is
        //
        int nButtonTopRow = CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_4 ), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top - nDeltaY;

        //
        // Move all of the buttons
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_1 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_2 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_3 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_4 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Apply();

        //
        // Resize the dialog
        //
        CSimpleRect rcDialog( m_hWnd, CSimpleRect::WindowRect );
        SetWindowPos( m_hWnd, NULL, 0, 0, rcDialog.Width(), rcDialog.Height()-nDeltaY, SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE );
    }

    //
    // Hide and disable the unused buttons
    //
    for (i=0;i<MaxButtons-m_pData->m_nButtonCount;i++)
    {
        EnableWindow( GetDlgItem( m_hWnd, nButtonIds[i] ), FALSE );
        ShowWindow( GetDlgItem( m_hWnd, nButtonIds[i] ), SW_HIDE );
    }


    //
    // Set the button IDs.  Do this last, so we can use constants until then
    //
    for (UINT i=0,nStart=MaxButtons-m_pData->m_nButtonCount;i<m_pData->m_nButtonCount;i++)
    {
        WIA_TRACE((TEXT("SetWindowLongPtr( GetDlgItem( m_hWnd, %d ), GWLP_ID, %d );"), nButtonIds[nStart+i], m_pData->m_Buttons[i] ));
        SetWindowLongPtr( GetDlgItem( m_hWnd, nButtonIds[nStart+i] ), GWLP_ID, m_pData->m_Buttons[i] );
    }

    //
    // Set the focus and default button
    //
    if (m_pData->m_nDefault)
    {
        SetFocus( GetDlgItem( m_hWnd,  m_pData->m_nDefault) );
        SendDlgItemMessage( GetParent(m_hWnd), m_pData->m_nDefault, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0) );
        SendMessage( m_hWnd, DM_SETDEFID, m_pData->m_nDefault, 0 );
    }

    //
    // Set the icon
    //
    SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_ICON, STM_SETICON, reinterpret_cast<WPARAM>(m_pData->m_hIcon), 0 );

    //
    // Set the message text
    //
    m_pData->m_strMessage.SetWindowText( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ) );

    //
    // Set the window text
    //
    m_pData->m_strTitle.SetWindowText( m_hWnd );

    SetForegroundWindow( m_hWnd );

    return TRUE;
}


LRESULT CMessageBoxEx::OnCommand( WPARAM wParam, LPARAM lParam )
{
    //
    // First, check to see if this message pertains to one of our buttons
    //
    for (UINT i=0;i<m_pData->m_nButtonCount;i++)
    {
        if ((LOWORD(wParam) == m_pData->m_Buttons[i]) == (HIWORD(wParam) == BN_CLICKED))
        {
            //
            // Store the "Hide this message in the future" value
            //
            m_pData->m_bHideMessageInFuture = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE, BM_GETCHECK, 0, 0 ));

            //
            // Close the dialog
            //
            EndDialog( m_hWnd, LOWORD(wParam) );
            return 0;
        }
    }
    if (LOWORD(wParam) == IDCANCEL)
    {
        EndDialog( m_hWnd, IDCANCEL );
        return 0;
    }
    SC_BEGIN_COMMAND_HANDLERS()
    {
    }
    SC_END_COMMAND_HANDLERS();
}



INT_PTR CALLBACK CMessageBoxEx::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CMessageBoxEx)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}



UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool *pbHideFutureMessages )
{
    CData Data;
    Data.m_nFlags = nFlags;
    Data.m_strMessage = pszMessage;
    Data.m_strTitle = pszTitle;

    //
    // Figure out which set of buttons to use
    //
    int nDialogResource = 0;
    if (nFlags & MBEX_OKCANCEL)
    {
        nDialogResource = IDD_MESSAGEBOX_OKCANCEL;
        Data.m_Buttons[0] = IDMBEX_OK;
        Data.m_Buttons[1] = IDMBEX_CANCEL;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_YESNO)
    {
        nDialogResource = IDD_MESSAGEBOX_YESNO;
        Data.m_Buttons[0] = IDMBEX_YES;
        Data.m_Buttons[1] = IDMBEX_NO;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_CANCELRETRYSKIPSKIPALL)
    {
        nDialogResource = IDD_MESSAGEBOX_CANCELRETRYSKIPSKIPALL;
        Data.m_Buttons[0] = IDMBEX_CANCEL;
        Data.m_Buttons[1] = IDMBEX_RETRY;
        Data.m_Buttons[2] = IDMBEX_SKIP;
        Data.m_Buttons[3] = IDMBEX_SKIPALL;
        Data.m_nButtonCount = 4;
    }
    else if (nFlags & MBEX_CANCELRETRY)
    {
        nDialogResource = IDD_MESSAGEBOX_CANCELRETRY;
        Data.m_Buttons[0] = IDMBEX_CANCEL;
        Data.m_Buttons[1] = IDMBEX_RETRY;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_YESYESTOALLNONOTOALL)
    {
        nDialogResource = IDD_MESSAGEBOX_YESYESTOALLNONOTOALL;
        Data.m_Buttons[0] = IDMBEX_YES;
        Data.m_Buttons[1] = IDMBEX_YESTOALL;
        Data.m_Buttons[2] = IDMBEX_NO;
        Data.m_Buttons[3] = IDMBEX_NOTOALL;
        Data.m_nButtonCount = 4;
    }
    else
    {
        nDialogResource = IDD_MESSAGEBOX_OK;
        Data.m_Buttons[0] = IDMBEX_OK;
        Data.m_nButtonCount = 1;
    }

    //
    // Figure out which icon to use
    //
    if (nFlags & MBEX_ICONWARNING)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_WARNING );
        MessageBeep( MB_ICONWARNING );
    }
    else if (nFlags & MBEX_ICONERROR)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_ERROR );
        MessageBeep( MB_ICONERROR );
    }
    else if (nFlags & MBEX_ICONQUESTION)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_QUESTION );
        MessageBeep( MB_ICONQUESTION );
    }
    else
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_INFORMATION );
        MessageBeep( MB_ICONINFORMATION );
    }

    //
    // Figure out which button should be the default
    //
    if (nFlags & MBEX_DEFBUTTON2)
    {
        Data.m_nDefault = Data.m_Buttons[1];
    }
    else if (nFlags & MBEX_DEFBUTTON3)
    {
        Data.m_nDefault = Data.m_Buttons[2];
    }
    else if (nFlags & MBEX_DEFBUTTON4)
    {
        Data.m_nDefault = Data.m_Buttons[3];
    }
    else
    {
        Data.m_nDefault = Data.m_Buttons[0];
    }

    if (pbHideFutureMessages)
    {
        Data.m_bHideMessageInFuture = *pbHideFutureMessages;
    }

    INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(nDialogResource), hWndParent, DialogProc, reinterpret_cast<LPARAM>(&Data) );

    if (pbHideFutureMessages)
    {
        *pbHideFutureMessages = Data.m_bHideMessageInFuture;
    }

    return static_cast<UINT>(nResult);
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages )
{
    return MessageBox( hWndParent, pszMessage, pszTitle, nFlags|MBEX_HIDEFUTUREMESSAGES, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags )
{
    return MessageBox( hWndParent, pszMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags )
{
    return MessageBox( NULL, pszMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nMessageId, UINT nTitleId, UINT nFlags, bool &bHideFutureMessages )
{
    return MessageBox( hWndParent, CSimpleString(nMessageId,hInstance), CSimpleString(nTitleId,hInstance), nFlags|MBEX_HIDEFUTUREMESSAGES, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, LPCTSTR pszFormat, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFormat );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), pszFormat, arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages, LPCTSTR pszFormat, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFormat );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), pszFormat, arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, pszTitle, nFlags, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nTitleId, UINT nFlags, UINT nFormatId, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, nFormatId );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), CSimpleString(nFormatId,hInstance), arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, CSimpleString(nTitleId,hInstance), nFlags, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\memdib.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MEMDIB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/14/1998
 *
 *  DESCRIPTION: This class allows you to construct a bitmap from raw bitmap data.
 *               IMPORTANT: All source data is assumed to be TOP-DOWN!!!!!!
 *
 *******************************************************************************/
#ifndef __MEMDIB_H_INCLUDED
#define __MEMDIB_H_INCLUDED

#include <windows.h>
#include "miscutil.h"
#include "wiadebug.h"

class CMemoryDib
{
private:
    PBYTE      m_pBitmapBits;
    HBITMAP    m_hBitmap;
    UINT       m_nHeaderLength;

private:
    // No implementation
    int operator=( const CMemoryDib & );
    CMemoryDib( const CMemoryDib & );

public:
    CMemoryDib(void)
    :   m_hBitmap(NULL),
        m_pBitmapBits(NULL),
        m_nHeaderLength(0)
    {
    }
    virtual ~CMemoryDib(void)
    {
        Destroy();
    }

    void Destroy(void)
    {
        if (m_hBitmap)
        {
            DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }
        m_nHeaderLength = 0;
        m_pBitmapBits = NULL;
    }
    bool IsValid(void) const
    {
        bool bResult = (m_hBitmap && m_pBitmapBits && m_nHeaderLength);
        return bResult;
    }
    PBYTE GetBitmapBits(void)
    {
        if (!IsValid())
        {
            return NULL;
        }
        return (m_pBitmapBits);
    }
    bool GetDibSection( DIBSECTION &ds )
    {
        if (IsValid() && GetObject( m_hBitmap, sizeof(DIBSECTION), &ds ))
        {
            return true;
        }
        return false;
    }
    LONG GetBitsPerPixel(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biBitCount;
        }
        return 0;
    }
    LONG GetWidthInPixels(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biWidth;
        }
        return 0;
    }
    LONG GetPackedWidthInBytes(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetWidthInPixels() * GetBitsPerPixel()) / 8;
    }

    LONG GetUnpackedWidthInBytes(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (WiaUiUtil::Align(GetWidthInPixels() * GetBitsPerPixel(), sizeof(DWORD)*8)/8);
    }
    LONG GetHeight(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biHeight;
        }
        return 0;
    }
    UINT GetHeaderLength(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        return m_nHeaderLength;
    }
    LONG GetUnpackedBitmapDataSize(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetUnpackedWidthInBytes() * GetHeight());
    }
    LONG GetPackedBitmapDataSize(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetPackedWidthInBytes() * GetHeight());
    }
    HBITMAP Bitmap(void)
    {
        if (!IsValid())
        {
            return NULL;
        }
        return m_hBitmap;
    }
    HBITMAP DetachBitmap(void)
    {
        HBITMAP hBitmap = m_hBitmap;
        m_hBitmap = NULL;
        m_pBitmapBits = NULL;
        return hBitmap;
    }
    static void DumpBitmap( PBITMAPINFO pBitmapInfo )
    {
        WIA_TRACE((TEXT("pBitmapInfo: %08X"), pBitmapInfo ));
        WIA_TRACE((TEXT("biSize: %d\nbiWidth: %d\nbiHeight: %d\nbiPlanes: %d\nbiBitCount: %d\nbiCompression: %d\nbiSizeImage: %d\nbiXPelsPerMeter: %d\nbiYPelsPerMeter: %d\nbiClrUsed: %d\nbiClrImportant: %d"),
                   pBitmapInfo->bmiHeader.biSize,
                   pBitmapInfo->bmiHeader.biWidth,
                   pBitmapInfo->bmiHeader.biHeight,
                   pBitmapInfo->bmiHeader.biPlanes,
                   pBitmapInfo->bmiHeader.biBitCount,
                   pBitmapInfo->bmiHeader.biCompression,
                   pBitmapInfo->bmiHeader.biSizeImage,
                   pBitmapInfo->bmiHeader.biXPelsPerMeter,
                   pBitmapInfo->bmiHeader.biYPelsPerMeter,
                   pBitmapInfo->bmiHeader.biClrUsed,
                   pBitmapInfo->bmiHeader.biClrImportant));
    }
    bool Initialize( PBITMAPINFO pBitmapInfo )
    {
        //
        // Clear everything
        //
        Destroy();

        if (pBitmapInfo)
        {
            //
            // What kind of bitmap is this?
            //
            DumpBitmap(pBitmapInfo);

            //
            // Get the header size.  We'll need it later
            //
            m_nHeaderLength = WiaUiUtil::GetBmiSize(pBitmapInfo);
            if (m_nHeaderLength)
            {
                //
                // Allocate a new BITMAPINFOHEADER + palette
                //
                BITMAPINFO *pNewBitmapInfo = reinterpret_cast<BITMAPINFO*>( new BYTE[m_nHeaderLength] );
                if (pNewBitmapInfo)
                {
                    //
                    // Copy the header and palette
                    //
                    CopyMemory( pNewBitmapInfo, pBitmapInfo, m_nHeaderLength );

                    //
                    // Make sure we have a positive height
                    //
                    pNewBitmapInfo->bmiHeader.biHeight = WiaUiUtil::Absolute( pNewBitmapInfo->bmiHeader.biHeight );

                    //
                    // If this is one of those "unknown length" bitmaps, normalize it to be 8.5 x 11
                    //
                    if (!pNewBitmapInfo->bmiHeader.biHeight)
                    {
                        pNewBitmapInfo->bmiHeader.biHeight = WiaUiUtil::MulDivNoRound(pNewBitmapInfo->bmiHeader.biWidth,1100,850);
                    }

                    m_hBitmap = CreateDIBSection( NULL, pNewBitmapInfo, DIB_RGB_COLORS, (void**)&m_pBitmapBits, 0, 0 );

                    if (m_hBitmap)
                    {
                        //
                        // Initialize it to white.  We hope.  It will depend on the palette.
                        //
                        FillMemory( m_pBitmapBits, GetUnpackedBitmapDataSize(), 0xFF );
                    }
                    else
                    {
                        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateDIBSection FAILED")));
                    }

                    //
                    // Free up our temporary header
                    //
                    delete[] reinterpret_cast<BYTE*>(pNewBitmapInfo);
                }
                else
                {
                    WIA_ERROR((TEXT("pNewBitmapInfo is NULL")));
                }

            }
            else
            {
                WIA_ERROR((TEXT("m_nHeaderLength was 0")));
            }

            //
            // Make sure there are no turds left over
            //
            if (!IsValid())
            {
                WIA_ERROR((TEXT("IsValid() was FALSE")));
                Destroy();
            }

        }
        else
        {
            WIA_ERROR((TEXT("pBitmapInfo is NULL")));
        }
        return IsValid();

    }
    bool SetPackedData( PBYTE pData, int nStartLine, int nLineCount )
    {
        if (!IsValid())
        {
            return false;
        }
        nStartLine = WiaUiUtil::Absolute(nStartLine);
        nLineCount = WiaUiUtil::Absolute(nLineCount);
        for (int i=0;i<nLineCount;i++)
        {
            if (nStartLine + i >= 0 && nStartLine + i < GetHeight())
            {
                PBYTE pDest = GetBitmapBits() + (GetHeight()-nStartLine-i-1) * GetUnpackedWidthInBytes();
                CopyMemory( pDest, pData + GetPackedWidthInBytes() * i, GetPackedWidthInBytes() );
            }
            else
            {
                WIA_ERROR((TEXT("CMemoryDib::SetPackedData: Ignoring out-of-range data: nStartLine: %d, nLineCount: %d"), nStartLine, nLineCount ));
            }
        }
        return true;
    }
    bool ScrollDataUp( int nScrollCount )
    {
        if (!IsValid())
        {
            return false;
        }
        if (nScrollCount > GetHeight())
        {
            nScrollCount = GetHeight();
        }
        PBYTE pSourceLine = GetBitmapBits() + (GetHeight() - nScrollCount - 1) * GetUnpackedWidthInBytes();
        PBYTE pTargetLine = GetBitmapBits() + (GetHeight() - 1) * GetUnpackedWidthInBytes();
        for (int i=0;i < GetHeight() - nScrollCount;i++)
        {
            CopyMemory(pTargetLine,pSourceLine,GetUnpackedWidthInBytes());
            pSourceLine -= GetUnpackedWidthInBytes();
            pTargetLine -= GetUnpackedWidthInBytes();
        }
        return true;
    }
    bool SetUnpackedData( PBYTE pData, int nStartLine, int nLineCount )
    {
        if (!IsValid())
        {
            return false;
        }
        nStartLine = WiaUiUtil::Absolute(nStartLine);
        nLineCount = WiaUiUtil::Absolute(nLineCount);
        for (int i=0;i<nLineCount;i++)
        {
            if (nStartLine + i >= 0 && nStartLine + i < GetHeight())
            {
                PBYTE pDest = GetBitmapBits() + (GetHeight()-nStartLine-i-1) * GetUnpackedWidthInBytes();
                CopyMemory( pDest, pData + GetUnpackedWidthInBytes() * i, GetUnpackedWidthInBytes() );
            }
            else
            {
                WIA_ERROR((TEXT("CMemoryDib::SetPackedData: Ignoring out-of-range data: nStartLine: %d, nLineCount: %d"), nStartLine, nLineCount ));
            }
        }
        return true;
    }
};

#endif // __MEMDIB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\modlock.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999, 2000
 *
 *  TITLE:       MODLOCK.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/9/1999
 *
 *  DESCRIPTION: Helpers to allow passing lock functions around
 *
 *******************************************************************************/
#ifndef __MODLOCK_H_INCLUDED
#define __MODLOCK_H_INCLUDED

typedef void (__stdcall *ModuleLockFunction)(void);
typedef void (__stdcall *ModuleUnlockFunction)(void);

extern void DllAddRef(void);
extern void DllRelease(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\miscutil.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISCUTIL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/
#ifndef __MISCUTIL_H_INCLUDED
#define __MISCUTIL_H_INCLUDED

#include <windows.h>
#include "simstr.h"
#include "wia.h"
#include "resid.h"

#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif

#if !defined(SETFormatEtc)
#define SETFormatEtc(fe, cf, asp, td, med, li)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=asp;\
    (fe).ptd=td;\
    (fe).tymed=med;\
    (fe).lindex=li;\
    };
#endif

#if !defined(SETDefFormatEtc)
#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };
#endif


#define PROP_SHEET_ERROR_NO_PAGES MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL,1)

namespace WiaUiUtil
{
    template <class T>
    T Absolute( const T &m )
    {
        return((m < 0) ? -m : m);
    }

    template <class T>
    T Max( const T &m, const T &n )
    {
        return((m > n) ? m : n);
    }

    template <class T>
    T Min( const T &m, const T &n )
    {
        return((m < n) ? m : n);
    }

    template <class T>
    T GetMinimum( const T& nDesired, const T& nMin, const T& nStep )
    {
        T nResult = Max<T>( nMin, nDesired );
        if (nStep)
            nResult = nResult + (nResult - nMin) % nStep;
        return nResult;
    }

    inline bool ScreenToClient( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ClientToScreen( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( hwnd, NULL, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return ScreenToClient( hwnd, &rc );
    }

    inline bool ClientToScreen( HWND hwnd, RECT &rc )
    {
        return ClientToScreen( hwnd, &rc );
    }

    inline int RectWidth( const RECT &rc )
    {
        return (rc.right - rc.left);
    }

    inline int RectHeight( const RECT &rc )
    {
        return (rc.bottom - rc.top);
    }

    inline LONGLONG PowerOfTwo( int nCount )
    {
        return(LONGLONG)1 << nCount;
    }

    inline int MulDivNoRound( int nNumber, int nNumerator, int nDenominator )
    {
        return(int)(((LONGLONG)nNumber * nNumerator) / nDenominator);
    }

    inline SIZE ScalePreserveAspectRatio( int nAvailX, int nAvailY, int nItemX, int nItemY )
    {
        SIZE sizeResult = { nAvailX, nAvailY };
        if (nItemX && nItemY)
        {
            //
            // Width is greater than height.  X is the constraining factor
            //
            if (nAvailY*nItemX > nAvailX*nItemY)
            {
                sizeResult.cy = MulDivNoRound(nItemY,nAvailX,nItemX);
            }

            //
            // Height is greater than width.  Y is the constraining factor
            //
            else
            {
                sizeResult.cx = MulDivNoRound(nItemX,nAvailY,nItemY);
            }
        }
        return sizeResult;
    }

    inline void Enable( HWND hWnd, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            if (!IsWindowEnabled(hWnd) && bEnable)
            {
                ::EnableWindow( hWnd, TRUE );
            }
            else if (IsWindowEnabled(hWnd) && !bEnable)
            {
                ::EnableWindow( hWnd, FALSE );
            }

        }
    }

    inline void Enable( HWND hWnd, int nChildId, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            Enable(GetDlgItem(hWnd,nChildId),bEnable);
        }
    }

    inline UINT GetDisplayColorDepth()
    {
        UINT nColorDepth = 0;
        HDC hDC = GetDC( NULL );
        if (hDC)
        {
            nColorDepth = GetDeviceCaps( hDC, BITSPIXEL ) * GetDeviceCaps( hDC, PLANES );
            ReleaseDC( NULL, hDC );
        }
        return nColorDepth;
    }

    LONG          Align( LONG n , LONG m );
    LONG          StringToLong( LPCTSTR pszStr );
    SIZE          MapDialogSize( HWND hwnd, const SIZE &size );
    LONG          GetBmiSize(PBITMAPINFO pbmi);
    bool          MsgWaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds = INFINITE );
    void          CenterWindow( HWND hWnd, HWND hWndParent=NULL );
    bool          FlipImage( PBYTE pBits, LONG nWidth, LONG nHeight, LONG nBitDepth );
    HRESULT       InstallInfFromResource( HINSTANCE hInstance, LPCSTR pszSectionName );
    HRESULT       DeleteItemAndChildren (IWiaItem *pItem);
    LONG          ItemAndChildrenCount(IWiaItem *pItem );
    HRESULT       WriteDIBToFile( HBITMAP hDib, HANDLE hFile );
    HFONT         CreateFontWithPointSizeFromWindow( HWND hWnd, int nPointSize, bool bBold, bool bItalic );
    HFONT         ChangeFontFromWindow( HWND hWnd, int nPointSizeDelta );
    HFONT         GetFontFromWindow( HWND hWnd );
    HRESULT       SystemPropertySheet( HINSTANCE hInstance, HWND hwndParent, IWiaItem *pWiaItem, LPCTSTR pszCaption );
    int           FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMask, int nCount=1, int nMax=65545 );
    int           FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMaskPrefix, LPCTSTR pszFormatString, LPCTSTR pszFileAndPathnameMaskSuffix, int nCount=1, int nMax=65535 );
    HRESULT       GetDeviceTypeFromId( LPCWSTR pwszDeviceId, LONG *pnDeviceType );
    HRESULT       GetDeviceInfoFromId( LPCWSTR pwszDeviceId, IWiaPropertyStorage **ppWiaPropertyStorage );
    HRESULT       GetDefaultEventHandler (IWiaItem *pItem, const GUID &guidEvent, WIA_EVENT_HANDLER *pwehHandler);
    CSimpleString FitTextInStaticWithEllipsis( LPCTSTR pszString, HWND hWndStatic, UINT nDrawTextStyle );
    CSimpleString TruncateTextToFitInRect( HWND hFontWnd, LPCTSTR pszString, RECT rectTarget, UINT nDrawTextFormat );
    SIZE          GetTextExtentFromWindow( HWND hFontWnd, LPCTSTR pszString );
    bool          GetIconSize( HICON hIcon, SIZE &sizeIcon );
    HBITMAP       CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HICON hIcon, LPCTSTR pszText );
    HBITMAP       CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HINSTANCE hIconInstance, const CResId &resIconId, LPCTSTR pszText );
    HRESULT       MoveOrCopyFile( LPCTSTR pszSrc, LPCTSTR pszTgt );
    CSimpleString CreateTempFileName( UINT nId = 0 );
    HRESULT       StampItemTimeOnFile( IWiaItem *pWiaItem, LPCTSTR pszFilename );
    HRESULT       SaveWiaItemAudio( IWiaItem *pWiaItem, LPCTSTR pszBaseFilename, CSimpleString &strAudioFilename );
    bool          IsDeviceCommandSupported( IWiaItem *pWiaItem, const GUID &guidCommand );
    void          PreparePropertyPageForFusion( PROPSHEETPAGE *pPropSheetPage );
    bool          CanWiaImageBeSafelyRotated( const GUID &guidFormat, LONG nImageWidth, LONG nImageHeight );
    HRESULT       ExploreWiaDevice( LPCWSTR pszDeviceId );
    BOOL          ModifyComboBoxDropWidth( HWND hwndControl );
    void          SubclassComboBoxEx( HWND hWnd );
    HRESULT       IssueWiaCancelIO( IUnknown *pUnknown );
    HRESULT       VerifyScannerProperties( IUnknown *pUnknown );
    CSimpleString GetErrorTextFromHResult( HRESULT hr );
//
// End namespace WiaUiUtil
//
}


#endif // __MISCUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\miscutil.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISCUTIL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <advpub.h>  // For RegInstall and related data structures
#include <windowsx.h>  // For RegInstall and related data structures
#include "wiaffmt.h"
#include "shellext.h"

namespace WiaUiUtil
{

    LONG Align( LONG n , LONG m )
    {
        return(n % m) ? (((n/m)+1)*m) : (n);
    }

    /*
     * StringToLong: Convert a string to a long. ASCII Arabic numerals only
     */
    LONG StringToLong( LPCTSTR pszStr )
    {
        LPTSTR pstr = (LPTSTR)pszStr;
        bool bNeg = (*pstr == TEXT('-'));
        if (bNeg)
            pstr++;
        LONG nTotal = 0;
        while (*pstr && *pstr >= TEXT('0') && *pstr <= TEXT('9'))
        {
            nTotal *= 10;
            nTotal += *pstr - TEXT('0');
            ++pstr;
        }
        return(bNeg ? -nTotal : nTotal);
    }

    SIZE MapDialogSize( HWND hwnd, const SIZE &size )
    {
        RECT rcTmp;
        rcTmp.left = rcTmp.top = 0;
        rcTmp.right = size.cx;
        rcTmp.bottom = size.cy;
        MapDialogRect( hwnd, &rcTmp );
        SIZE sizeTmp;
        sizeTmp.cx = rcTmp.right;
        sizeTmp.cy = rcTmp.bottom;
        return (sizeTmp);
    }

    /*******************************************************************************
    *
    *  GetBmiSize
    *
    *  DESCRIPTION:
    *   Should never get biCompression == BI_RLE.
    *
    *  PARAMETERS:
    *
    *******************************************************************************/
    LONG GetBmiSize(PBITMAPINFO pbmi)
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::GetBmiSize(0x%p)"), pbmi ));
        // determine the size of bitmapinfo
        LONG lSize = pbmi->bmiHeader.biSize;

        // no color table cases
        if (
           (pbmi->bmiHeader.biBitCount == 24) ||
           ((pbmi->bmiHeader.biBitCount == 32) &&
            (pbmi->bmiHeader.biCompression == BI_RGB)))
        {

            // no colors unless stated
            lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;
            return(lSize);
        }

        // bitfields cases
        if (((pbmi->bmiHeader.biBitCount == 32) &&
             (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
            (pbmi->bmiHeader.biBitCount == 16))
        {

            lSize += 3 * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 1)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 2))
            {
                lPal = 2;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 4)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 16))
            {
                lPal = 16;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 8)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 256))
            {
                lPal = 256;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // error
        return(0);
    }

    // Simple wrapper for MsgWaitForMultipleObjects
    bool MsgWaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds )
    {
        bool bEventOccurred = false;
        const int nCount = 1;
        while (true)
        {
            DWORD dwRes = MsgWaitForMultipleObjects(nCount,&hHandle,FALSE,dwMilliseconds,QS_ALLINPUT|QS_ALLPOSTMESSAGE);
            if (WAIT_OBJECT_0==dwRes)
            {
                // The handle was signalled, so we can break out of our loop, returning true
                bEventOccurred = true;
                break;
            }
            else if (WAIT_OBJECT_0+nCount==dwRes)
            {
                // pull all of the messages out of the queue and process them
                MSG msg;
                while (PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
                {
                    if (msg.message == WM_QUIT)
                        break;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else
            {
                // The handle either timed out, or the mutex was abandoned, so we can break out of our loop, returning false
                break;
            }
        }
        return bEventOccurred;
    }

    void CenterWindow( HWND hWnd, HWND hWndParent )
    {
        if (IsWindow(hWnd))
        {

            if (!hWndParent)
            {
                //
                // If the window to be centered on is NULL, use the desktop window
                //
                hWndParent = GetDesktopWindow();
            }
            else
            {
                //
                // If the window to be centered on is minimized, use the desktop window
                //
                DWORD dwStyle = GetWindowLong(hWndParent, GWL_STYLE);
                if (dwStyle & WS_MINIMIZE)
                {
                    hWndParent = GetDesktopWindow();
                }
            }

            //
            // Get the window rects
            //
            RECT rcParent, rcCurrent;
            GetWindowRect( hWndParent, &rcParent );
            GetWindowRect( hWnd, &rcCurrent );

            //
            // Get the desired coordinates for the upper-left hand corner
            //
            RECT rcFinal;
            rcFinal.left = rcParent.left + (RectWidth(rcParent) - RectWidth(rcCurrent))/2;
            rcFinal.top = rcParent.top + (RectHeight(rcParent) - RectHeight(rcCurrent))/2;
            rcFinal.right = rcFinal.left + RectWidth(rcCurrent);
            rcFinal.bottom = rcFinal.top + RectHeight(rcCurrent);

            //
            // Make sure we're not off the screen
            //
            HMONITOR hMonitor = MonitorFromRect( &rcFinal, MONITOR_DEFAULTTONEAREST );
            if (hMonitor)
            {
                MONITORINFO MonitorInfo = {0};
                MonitorInfo.cbSize = sizeof(MonitorInfo);
                //
                // Get the screen coordinates of this monitor
                //
                if (GetMonitorInfo(hMonitor, &MonitorInfo))
                {
                    //
                    // Ensure the window is in the working area's region
                    //
                    rcFinal.left = Max<int>(MonitorInfo.rcWork.left, Min<int>( MonitorInfo.rcWork.right - RectWidth(rcCurrent), rcFinal.left ));
                    rcFinal.top = Max<int>(MonitorInfo.rcWork.top, Min<int>( MonitorInfo.rcWork.bottom - RectHeight(rcCurrent), rcFinal.top ));
                }
            }

            // Move it
            SetWindowPos( hWnd, NULL, rcFinal.left, rcFinal.top, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER );
        }
    }


    // Flip an image horizontally
    bool FlipImage( PBYTE pBits, LONG nWidth, LONG nHeight, LONG nBitDepth )
    {
        bool bResult = false;
        if (pBits && nWidth>=0 && nHeight>=0 && nBitDepth>=0)
        {
            LONG nLineWidthInBytes = WiaUiUtil::Align(nWidth*nBitDepth,sizeof(DWORD)*8)/8;
            PBYTE pTempLine = new BYTE[nLineWidthInBytes];
            if (pTempLine)
            {
                for (int i=0;i<nHeight/2;i++)
                {
                    PBYTE pSrc = pBits + (i * nLineWidthInBytes);
                    PBYTE pDst = pBits + ((nHeight-i-1) * nLineWidthInBytes);
                    CopyMemory( pTempLine, pSrc, nLineWidthInBytes );
                    CopyMemory( pSrc, pDst, nLineWidthInBytes );
                    CopyMemory( pDst, pTempLine, nLineWidthInBytes );
                }
                bResult = true;
            }
            delete[] pTempLine;
        }
        return bResult;
    }

    HRESULT InstallInfFromResource( HINSTANCE hInstance, LPCSTR pszSectionName )
    {
        HRESULT hr;
        HINSTANCE hInstAdvPackDll = LoadLibrary(TEXT("ADVPACK.DLL"));
        if (hInstAdvPackDll)
        {
            REGINSTALL pfnRegInstall = reinterpret_cast<REGINSTALL>(GetProcAddress( hInstAdvPackDll, "RegInstall" ));
            if (pfnRegInstall)
            {
#if defined(WINNT)
                STRENTRY astrEntry[] =
                {
                    { "25", "%SystemRoot%"           },
                    { "11", "%SystemRoot%\\system32" }
                };
                STRTABLE strTable = { sizeof(astrEntry)/sizeof(astrEntry[0]), astrEntry };
                hr = pfnRegInstall(hInstance, pszSectionName, &strTable);
#else
                hr = pfnRegInstall(hInstance, pszSectionName, NULL);
#endif
            } else hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary(hInstAdvPackDll);
        } else hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }


    /******************************************************************************

    WriteDIBToFile

    Writes a DIB to a file.

    ******************************************************************************/
    HRESULT
    WriteDIBToFile( HBITMAP hDib, HANDLE hFile )
    {
        if (!hDib)
        {
            return E_INVALIDARG;
        }

        // Make sure this is a valid DIB and get this useful info.
        DIBSECTION ds;
        if (!GetObject( hDib, sizeof(DIBSECTION), &ds ))
        {
            return E_INVALIDARG;
        }

        // We only deal with DIBs
        if (ds.dsBm.bmPlanes != 1)
        {
            return E_INVALIDARG;
        }

        // Calculate some color table sizes
        int nColors = ds.dsBmih.biBitCount <= 8 ? 1 << ds.dsBmih.biBitCount : 0;
        int nBitfields = ds.dsBmih.biCompression == BI_BITFIELDS ? 3 : 0;

        // Calculate the data size
        int nImageDataSize = ds.dsBmih.biSizeImage ? ds.dsBmih.biSizeImage : ds.dsBm.bmWidthBytes * ds.dsBm.bmHeight;

        // Get the color table (if needed)
        RGBQUAD rgbqaColorTable[256] = {0};
        if (nColors)
        {
            HDC hDC = CreateCompatibleDC(NULL);
            if (hDC)
            {
                HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hDC,hDib));
                GetDIBColorTable( hDC, 0, nColors, rgbqaColorTable );
                SelectObject(hDC,hOldBitmap);
                DeleteDC( hDC );
            }
        }

        // Create the file header
        BITMAPFILEHEADER bmfh;
        bmfh.bfType = 'MB';
        bmfh.bfSize = 0;
        bmfh.bfReserved1 = 0;
        bmfh.bfReserved2 = 0;
        bmfh.bfOffBits = sizeof(bmfh) + sizeof(ds.dsBmih) + nBitfields*sizeof(DWORD) + nColors*sizeof(RGBQUAD);

        // Start writing!  Note that we write out the bitfields and the color table.  Only one,
        // at most, will actually result in data being written
        DWORD dwBytesWritten;
        if (!WriteFile( hFile, &bmfh, sizeof(bmfh), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, &ds.dsBmih, sizeof(ds.dsBmih), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, &ds.dsBitfields, nBitfields*sizeof(DWORD), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, rgbqaColorTable, nColors*sizeof(RGBQUAD), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, ds.dsBm.bmBits, nImageDataSize, &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        return S_OK;
    }


    HFONT ChangeFontFromWindow( HWND hWnd, int nPointSizeDelta )
    {
        HFONT hFontResult = NULL;

        //
        // Get the window's font
        //
        HFONT hFont = GetFontFromWindow(hWnd);
        if (hFont)
        {
            LOGFONT LogFont = {0};
            if (GetObject( hFont, sizeof(LogFont), &LogFont ))
            {
                HDC hDC = GetDC(hWnd);
                if (hDC)
                {
                    HFONT hOldFont = SelectFont(hDC,hFont);
                    TEXTMETRIC TextMetric = {0};
                    if (GetTextMetrics( hDC, &TextMetric ))
                    {
                        //
                        // Get the current font's point size
                        //
                        int nPointSize = MulDiv( TextMetric.tmHeight-TextMetric.tmInternalLeading, 72, GetDeviceCaps(hDC, LOGPIXELSY) ) + nPointSizeDelta;

                        //
                        // Calculate the height of the new font
                        //
                        LogFont.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

                        //
                        // Create the font
                        //
                        hFontResult = CreateFontIndirect( &LogFont );
                    }

                    if (hOldFont)
                    {
                        SelectFont( hDC, hOldFont );
                    }

                    ReleaseDC( hWnd, hDC );
                }
            }
        }
        return hFontResult;
    }

    HFONT GetFontFromWindow( HWND hWnd )
    {
        //
        // Get the window's font
        //
        HFONT hFontResult = reinterpret_cast<HFONT>(SendMessage(hWnd,WM_GETFONT,0,0));
        if (!hFontResult)
        {
            hFontResult = reinterpret_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        }
        return hFontResult;
    }



    HFONT CreateFontWithPointSizeFromWindow( HWND hWnd, int nPointSize, bool bBold, bool bItalic )
    {
        HFONT hFontResult = NULL;
        HFONT hFont = GetFontFromWindow(hWnd);
        if (hFont)
        {
            LOGFONT LogFont = {0};
            if (GetObject( hFont, sizeof(LogFont), &LogFont ))
            {
                HDC hDC = GetDC(NULL);
                if (hDC)
                {
                    if (nPointSize)
                    {
                        LogFont.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
                    }
                    if (bBold)
                    {
                        LogFont.lfWeight = FW_BOLD;
                    }
                    if (bItalic)
                    {
                        LogFont.lfItalic = TRUE;
                    }
                    hFontResult = CreateFontIndirect( &LogFont );
                    ReleaseDC( NULL, hDC );
                }
            }
        }
        return hFontResult;
    }

    SIZE GetTextExtentFromWindow( HWND hFontWnd, LPCTSTR pszString )
    {
        SIZE sizeResult = {0,0};
        HDC hDC = GetDC( hFontWnd );
        if (hDC)
        {
            HFONT hFont = GetFontFromWindow(hFontWnd);
            if (hFont)
            {
                HFONT hOldFont = SelectFont( hDC, hFont );

                SIZE sizeExtent = {0,0};
                if (GetTextExtentPoint32( hDC, pszString, lstrlen(pszString), &sizeExtent ))
                {
                    sizeResult = sizeExtent;
                }
                //
                // Restore the DC
                //
                if (hOldFont)
                {
                    SelectFont( hDC, hOldFont );
                }
            }
            ReleaseDC( hFontWnd, hDC );
        }
        return sizeResult;
    }

    CSimpleString TruncateTextToFitInRect( HWND hFontWnd, LPCTSTR pszString, RECT rectTarget, UINT nDrawTextFormat )
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::TruncateTextToFitInRect( 0x%p, %s, (%d,%d,%d,%d), 0x%08X"), hFontWnd, pszString, rectTarget.left, rectTarget.top, rectTarget.right, rectTarget.bottom, nDrawTextFormat ));
        CSimpleString strResult = pszString;

        //
        // Make sure we have valid parameters
        //
        if (IsWindow(hFontWnd) && hFontWnd && pszString && lstrlen(pszString))
        {
            //
            // Make a copy of the string.  If it fails, we will just return the original string.
            //
            LPTSTR pszTemp = new TCHAR[lstrlen(pszString)+1];
            if (pszTemp)
            {
                lstrcpy( pszTemp, pszString );

                //
                // Get a client DC for the window
                //
                HDC hDC = GetDC( hFontWnd );
                if (hDC)
                {
                    //
                    // Create a memory DC
                    //
                    HDC hMemDC = CreateCompatibleDC( hDC );
                    if (hMemDC)
                    {
                        //
                        // Get the font the window is using and select it into our client dc
                        //
                        HFONT hFont = GetFontFromWindow(hFontWnd);
                        if (hFont)
                        {
                            //
                            // Select the font
                            //
                            HFONT hOldFont = SelectFont( hMemDC, hFont );

                            //
                            // Modify the string using DrawText
                            //
                            if (DrawText( hMemDC, pszTemp, lstrlen(pszTemp), &rectTarget, nDrawTextFormat|DT_MODIFYSTRING|DT_SINGLELINE ))
                            {
                                strResult = pszTemp;
                            }
                            else
                            {
                                WIA_ERROR((TEXT("DrawText failed")));
                            }
                            //
                            // Restore the DC
                            //
                            if (hOldFont)
                            {
                                SelectFont( hMemDC, hOldFont );
                            }

                        }

                        //
                        // Clean up the memory DC
                        //
                        DeleteDC( hMemDC );
                    }
                    else
                    {
                        WIA_ERROR((TEXT("Unable to create the compatible DC")));
                    }

                    //
                    // Release the DC
                    //
                    ReleaseDC( hFontWnd, hDC );
                }
                else
                {
                    WIA_ERROR((TEXT("Unable to get the DC")));
                }

                //
                // Clean up our temp buffer
                //
                delete[] pszTemp;
            }
            else
            {
                WIA_ERROR((TEXT("Unable to allocate the temp buffer")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("Argument validation failed")));
        }
        return strResult;
    }


    CSimpleString FitTextInStaticWithEllipsis( LPCTSTR pszString, HWND hWndStatic, UINT nDrawTextStyle )
    {
        //
        // Make sure we have valid parameters
        //
        if (!hWndStatic || !pszString || !IsWindow(hWndStatic))
        {
            return pszString;
        }

        //
        // Hide prefix characters?
        //
        if (GetWindowLong( hWndStatic, GWL_STYLE ) & SS_NOPREFIX)
        {
            nDrawTextStyle |= DT_NOPREFIX;
        }

        //
        // How big is the area we are trying to fit this in?
        //
        RECT rcClient;
        GetClientRect( hWndStatic, &rcClient );

        //
        // Calculate the result and return it
        //
        return TruncateTextToFitInRect( hWndStatic, pszString, rcClient, nDrawTextStyle );
    }

    //
    // Get the size of an icon
    //
    bool GetIconSize( HICON hIcon, SIZE &sizeIcon )
    {
        //
        // Assume failure
        //
        bool bSuccess = false;

        //
        // Get the icon information
        //
        ICONINFO IconInfo = {0};
        if (GetIconInfo( hIcon, &IconInfo ))
        {
            //
            // Get one of the bitmaps
            //
            BITMAP bm;
            if (GetObject( IconInfo.hbmColor, sizeof(bm), &bm ))
            {
                //
                // Save the size of the icon
                //
                sizeIcon.cx = bm.bmWidth;
                sizeIcon.cy = bm.bmHeight;

                //
                // Everything worked
                //
                bSuccess = true;
            }

            //
            // Free the bitmaps
            //
            DeleteObject(IconInfo.hbmMask);
            DeleteObject(IconInfo.hbmColor);
        }
        else
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("GetIconInfo failed")));
        }

        return bSuccess;
    }

    HBITMAP CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HICON hIcon, LPCTSTR pszText )
    {
        WIA_PUSH_FUNCTION((TEXT("CreateIconThumbnail( hWnd: 0x%p, nWidth: %d, nHeight: %d, hIcon: 0x%p, pszText: \"%s\" )"), hWnd, nWidth, nHeight, hIcon, pszText ? pszText : TEXT("") ));

        //
        // Initialize return value to NULL
        //
        HBITMAP hBmp = NULL;

        //
        // This will be set to true if all steps succeed.
        //
        bool bSuccess = false;

        //
        // The minimum whitespace around the icon and the text border
        //
        const int nIconBorder = 2;

        //
        // Get the DC to the window
        //
        HDC hDC = GetDC(hWnd);
        if (hDC)
        {
            //
            // Get a halftone palette
            //
            HPALETTE hHalftonePalette = CreateHalftonePalette(hDC);
            if (hHalftonePalette)
            {
                //
                // Initialize the bitmap information
                //
                BITMAPINFO BitmapInfo = {0};
                BitmapInfo.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                BitmapInfo.bmiHeader.biWidth           = nWidth;
                BitmapInfo.bmiHeader.biHeight          = nHeight;
                BitmapInfo.bmiHeader.biPlanes          = 1;
                BitmapInfo.bmiHeader.biBitCount        = 24;
                BitmapInfo.bmiHeader.biCompression     = BI_RGB;

                //
                // Create the DIB section
                //
                PBYTE pBitmapData = NULL;
                hBmp = CreateDIBSection( hDC, &BitmapInfo, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
                if (hBmp)
                {
                    //
                    // Create the source dc
                    //
                    HDC hMemoryDC = CreateCompatibleDC( hDC );
                    if (hMemoryDC)
                    {
                        //
                        // Set up the palette
                        //
                        HPALETTE hOldPalette = SelectPalette( hMemoryDC, hHalftonePalette , 0 );
                        RealizePalette( hMemoryDC );
                        SetBrushOrgEx( hMemoryDC, 0,0, NULL );

                        //
                        // Set up the DC
                        //
                        int nOldBkMode = SetBkMode( hMemoryDC, TRANSPARENT );
                        COLORREF crOldTextColor = SetTextColor( hMemoryDC, GetSysColor(COLOR_WINDOWTEXT) );
                        DWORD dwOldLayout = SetLayout( hMemoryDC, LAYOUT_BITMAPORIENTATIONPRESERVED );

                        //
                        // Select the bitmap into the memory DC
                        //
                        HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject( hMemoryDC, hBmp ));

                        //
                        // Get the font to use
                        //
                        HFONT hFont = GetFontFromWindow(hWnd);

                        //
                        // Select the font
                        //
                        HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject( hMemoryDC, hFont ) );

                        //
                        // Ensure we have a valid icon
                        //
                        if (hIcon)
                        {
                            //
                            // Try to get the size of the icon
                            //
                            SIZE sizeIcon;
                            if (GetIconSize( hIcon, sizeIcon ))
                            {
                                //
                                // Fill the bitmap with the window color
                                //
                                RECT rc = { 0, 0, nWidth, nHeight };
                                FillRect( hMemoryDC, &rc, GetSysColorBrush( COLOR_WINDOW ) );

                                //
                                // Get the text height for one line of text
                                //
                                SIZE sizeText = {0};
                                if (pszText)
                                {
                                    GetTextExtentPoint32( hMemoryDC, TEXT("X"), 1, &sizeText );
                                }

                                //
                                // Center the icon + 1 line of text + margin in the thumbnail
                                // We are assuming this bitmap can actually hold an icon + text
                                //
                                int nIconTop = rc.top + (RectHeight(rc) - ( sizeIcon.cy + sizeText.cy + nIconBorder )) / 2;

                                //
                                // Draw the icon
                                //
                                DrawIconEx( hMemoryDC, (nWidth - sizeIcon.cx)/2, nIconTop, hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, DI_NORMAL );

                                //
                                // Only compute text things if there's text to draw
                                //
                                if (pszText && *pszText)
                                {
                                    //
                                    // Decrease the rectangle's width by the icon border
                                    //
                                    InflateRect( &rc, -nIconBorder, 0 );

                                    //
                                    // Set the top of the text to the bottom of icon + the icon border
                                    //
                                    rc.top = nIconTop + sizeIcon.cy + nIconBorder;

                                    //
                                    // Draw the text
                                    //
                                    DrawTextEx( hMemoryDC, const_cast<LPTSTR>(pszText), -1, &rc, DT_CENTER|DT_END_ELLIPSIS|DT_NOPREFIX|DT_WORDBREAK, NULL );
                                }

                                //
                                // Everything worked OK
                                //
                                bSuccess = true;
                            }
                            else
                            {
                                WIA_ERROR((TEXT("Couldn't get an icon size")));
                            }

                        }
                        else
                        {
                            WIA_ERROR((TEXT("Didn't have a valid icon")));
                        }

                        //
                        // Restore the dc's state
                        //
                        SelectObject( hMemoryDC, hOldFont );
                        SelectObject( hMemoryDC, hOldBitmap );
                        SelectPalette( hMemoryDC, hOldPalette , 0 );
                        SetBkMode( hMemoryDC, nOldBkMode );
                        SetTextColor( hMemoryDC, crOldTextColor );
                        SetLayout( hMemoryDC, dwOldLayout );

                        //
                        // Delete the compatible DC
                        //
                        DeleteDC( hMemoryDC );

                    }
                    else
                    {
                        WIA_ERROR((TEXT("Unable to create a memory DC")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("Unable to create a DIB section")));
                }

                //
                // Delete the halftone palette
                //
                if (hHalftonePalette)
                {
                    DeleteObject( hHalftonePalette );
                }
            }
            else
            {
                WIA_ERROR((TEXT("Unable to get a halftone palette")));
            }

            //
            // Release the client DC
            //
            ReleaseDC( hWnd, hDC );
        }
        else
        {
            WIA_ERROR((TEXT("Unable to get a DC")));
        }

        //
        // Clean up in the event of failure
        //
        if (!bSuccess)
        {
            if (hBmp)
            {
                DeleteObject(hBmp);
                hBmp = NULL;
            }
        }
        return hBmp;
    }
    //
    // Create a bitmap with an icon and optional text
    //
    HBITMAP CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HINSTANCE hIconInstance, const CResId &resIconId, LPCTSTR pszText )
    {
        //
        // Assume failure
        //
        HBITMAP hBmp = NULL;

        //
        // Load the specified icon
        //
        HICON hIcon = (HICON)LoadImage( hIconInstance, resIconId.ResourceName(), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR );
        if (hIcon)
        {
            //
            // Create the thumbnail
            //
            hBmp = CreateIconThumbnail( hWnd, nWidth, nHeight, hIcon, pszText );

            //
            // Free the icon (even though MSDN doesn't mention this, it will result in a leak if you don't)
            //
            DestroyIcon(hIcon);
        }

        return hBmp;
    }

    HRESULT SaveWiaItemAudio( IWiaItem *pWiaItem, LPCTSTR pszBaseFilename, CSimpleString &strAudioFilename )
    {
        //
        // Check the arguments
        //
        if (!pWiaItem || !pszBaseFilename || !lstrlen(pszBaseFilename))
        {
            return E_INVALIDARG;
        }

        //
        // Get the audio data property, if present
        //
        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)(&pWiaPropertyStorage) );
        if (SUCCEEDED(hr))
        {
            PROPVARIANT PropVar[3] = {0};
            PROPSPEC    PropSpec[3] = {0};

            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = WIA_IPC_AUDIO_DATA;

            PropSpec[1].ulKind = PRSPEC_PROPID;
            PropSpec[1].propid = WIA_IPC_AUDIO_AVAILABLE;

            PropSpec[2].ulKind = PRSPEC_PROPID;
            PropSpec[2].propid = WIA_IPC_AUDIO_DATA_FORMAT;

            hr = pWiaPropertyStorage->ReadMultiple( ARRAYSIZE(PropSpec), PropSpec, PropVar );
            if (SUCCEEDED(hr))
            {
                if (PropVar[1].lVal && PropVar[0].caub.cElems)
                {
                    TCHAR szFile[MAX_PATH + 4] = {0};
                    lstrcpyn( szFile, pszBaseFilename, ARRAYSIZE(szFile) );

                    //
                    // Figure out where the extension should go.
                    //
                    LPTSTR pszExtensionPoint = PathFindExtension(szFile);

                    //
                    // Replace the extension.  If the item specifies the clsid, use it.  Otherwise assume WAV
                    //
                    if (PropVar[2].vt == VT_CLSID && PropVar[2].puuid)
                    {
                        _sntprintf( pszExtensionPoint, ARRAYSIZE(szFile) - (pszExtensionPoint - szFile) - 1, TEXT(".%s"), CWiaFileFormat::GetExtension(*PropVar[2].puuid).String() );
                    }
                    else
                    {
                        lstrcpyn( pszExtensionPoint, TEXT(".wav"), static_cast<int>( ARRAYSIZE(szFile) - (pszExtensionPoint - szFile) ) );
                    }

                    //
                    // Save the filename for the caller
                    //
                    strAudioFilename = szFile;

                    //
                    // Open the file and save the data to the file
                    //
                    HANDLE hFile = CreateFile( szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
                    if (INVALID_HANDLE_VALUE != hFile)
                    {
                        DWORD dwBytesWritten;
                        if (WriteFile( hFile, PropVar[0].caub.pElems, PropVar[0].caub.cElems, &dwBytesWritten, NULL ))
                        {
                            // Success
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CloseHandle(hFile);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_PRINTHRESULT((hr,TEXT("There is no audio data")));
                }
                
                FreePropVariantArray( ARRAYSIZE(PropVar), PropVar );
            }
        }
        return hr;
    }

    bool IsDeviceCommandSupported( IWiaItem *pWiaItem, const GUID &guidCommand )
    {
        //
        // Assume failure
        //
        bool bResult = false;

        //
        // Make sure we have a valid item
        //
        if (pWiaItem)
        {
            //
            // Get the device capabilities enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pDeviceCapabilities;
            HRESULT hr = pWiaItem->EnumDeviceCapabilities( WIA_DEVICE_COMMANDS, &pDeviceCapabilities );
            if (SUCCEEDED(hr))
            {
                //
                // Enumerate the capabilities
                //
                WIA_DEV_CAP WiaDeviceCapability;
                while (!bResult && S_OK == pDeviceCapabilities->Next(1, &WiaDeviceCapability, NULL))
                {
                    //
                    // If we have a match, set the return value to true
                    //
                    if (guidCommand == WiaDeviceCapability.guid)
                    {
                        bResult = true;
                    }

                    //
                    // Clean up the allocated data in the dev caps structure
                    //
                    if (WiaDeviceCapability.bstrName)
                    {
                        SysFreeString(WiaDeviceCapability.bstrName);
                    }
                    if (WiaDeviceCapability.bstrDescription)
                    {
                        SysFreeString(WiaDeviceCapability.bstrDescription);
                    }
                    if (WiaDeviceCapability.bstrIcon)
                    {
                        SysFreeString(WiaDeviceCapability.bstrIcon);
                    }
                    if (WiaDeviceCapability.bstrCommandline)
                    {
                        SysFreeString(WiaDeviceCapability.bstrCommandline);
                    }
                }
            }
        }

        return bResult;
    }

    HRESULT StampItemTimeOnFile( IWiaItem *pWiaItem, LPCTSTR pszFilename )
    {
        if (!pWiaItem || !pszFilename || !lstrlen(pszFilename))
        {
            return E_INVALIDARG;
        }
        //
        // All this, just to set the stinking file time...
        // Allows for the possibility of using a VT_FILETIME
        // just in case we ever make the intelligent decision
        // to support VT_FILETIME
        //
        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void **)&pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            //
            // Get the file time
            //
            PROPSPEC PropSpec[1] = {0};
            PROPVARIANT PropVar[1] = {0};

            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = WIA_IPA_ITEM_TIME;
            hr = pWiaPropertyStorage->ReadMultiple( ARRAYSIZE(PropSpec), PropSpec, PropVar );
            if (SUCCEEDED(hr))
            {
                //
                // Check to see if we are using a SYSTEMTIME structure
                //
                if (PropVar[0].vt > VT_NULL &&  PropVar[0].caub.pElems && PropVar[0].caub.cElems >= (sizeof(SYSTEMTIME)>>1))
                {
                    //
                    // Convert the systemtime to a local filetime
                    //
                    FILETIME FileTimeLocal;
                    if (SystemTimeToFileTime( reinterpret_cast<SYSTEMTIME*>(PropVar[0].caub.pElems), &FileTimeLocal ))
                    {
                        //
                        // Convert the local filetime to a UTC filetime
                        //
                        FILETIME FileTimeUTC;
                        if (LocalFileTimeToFileTime( &FileTimeLocal, &FileTimeUTC ))
                        {
                            //
                            // Open the file handle
                            //
                            HANDLE hFile = CreateFile( pszFilename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                            if (INVALID_HANDLE_VALUE != hFile)
                            {
                                //
                                // Set the file creation time
                                //
                                if (!SetFileTime( hFile, &FileTimeUTC, NULL, NULL ))
                                {
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                    WIA_PRINTHRESULT((hr,TEXT("SetFileTime failed")));
                                }
                                CloseHandle( hFile );
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                WIA_PRINTHRESULT((hr,TEXT("CreateFile failed")));
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            WIA_PRINTHRESULT((hr,TEXT("FileTimeToLocalFileTime failed")));
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        WIA_PRINTHRESULT((hr,TEXT("SystemTimeToFileTime failed")));
                    }
                }
                else if (VT_FILETIME == PropVar[0].vt)
                {
                    //
                    // Convert the local filetime to a UTC filetime
                    //
                    FILETIME FileTimeUTC;
                    if (LocalFileTimeToFileTime( &PropVar[0].filetime, &FileTimeUTC ))
                    {
                        //
                        // Open the file handle
                        //
                        HANDLE hFile = CreateFile( pszFilename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                        if (INVALID_HANDLE_VALUE != hFile)
                        {
                            //
                            // Set the file creation time
                            //
                            if (!SetFileTime( hFile, &FileTimeUTC, NULL, NULL ))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                WIA_PRINTHRESULT((hr,TEXT("SetFileTime failed")));
                            }
                            CloseHandle( hFile );
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            WIA_PRINTHRESULT((hr,TEXT("CreateFile failed")));
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        WIA_PRINTHRESULT((hr,TEXT("FileTimeToLocalFileTime failed")));
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_PRINTHRESULT((hr,TEXT("The time property is invalid")));
                }

                //
                // Free the propvariant
                //
                FreePropVariantArray( ARRAYSIZE(PropVar), PropVar );
            }
            else
            {
                WIA_ERROR((TEXT("ReadMultiple on WIA_IPA_ITEM_TIME failed")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("QueryInterface on IWiaPropertyStorage failed")));
        }
        return hr;
    }


    HRESULT MoveOrCopyFile( LPCTSTR pszSrc, LPCTSTR pszTgt )
    {
        WIA_PUSH_FUNCTION((TEXT("CDownloadImagesThreadMessage::MoveOrCopyFile( %s, %s )"), pszSrc, pszTgt ));
        //
        // Verify the arguments
        //
        if (!pszSrc || !pszTgt || !lstrlen(pszSrc) || !lstrlen(pszTgt))
        {
            return E_INVALIDARG;
        }

        //
        // Assume everything worked ok
        //
        HRESULT hr = S_OK;

        //
        // First try to move the file, since that will be lots faster
        //
        if (!MoveFile( pszSrc, pszTgt ))
        {
            //
            // If moving the file failed, try to copy it and the delete it
            //
            if (CopyFile( pszSrc, pszTgt, FALSE ))
            {
                //
                // We are going to ignore failures from DeleteFile.  It is possible the file is legitimately in
                // use, and there is probably no need to fail the entire operation because of this.
                //
                if (!DeleteFile( pszSrc ))
                {
                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("DeleteFile failed.  Ignoring failure.")));
                }
                //
                // Everything worked OK
                //
                hr = S_OK;
            }
            else
            {
                //
                // This is where we catch the main errors
                //
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        return hr;
    }

    CSimpleString CreateTempFileName( UINT nId )
    {
        //
        // Initialize the return value to an empty string
        //
        CSimpleString strResult(TEXT(""));

        //
        // Get the temp folder path
        //
        TCHAR szTempDirectory[MAX_PATH] = {0};
        DWORD dwResult = GetTempPath( ARRAYSIZE(szTempDirectory), szTempDirectory );
        if (dwResult)
        {
            //
            // Make sure the path length didn't exceed the buffer we allocated on the stack
            //
            if (ARRAYSIZE(szTempDirectory) >= dwResult)
            {
                //
                // Get the temp file name
                //
                TCHAR szFileName[MAX_PATH] = {0};
                if (GetTempFileName( szTempDirectory, TEXT("scw"), nId, szFileName ))
                {
                    //
                    // Save the filename
                    //
                    strResult = szFileName;
                }
            }
        }

        //
        // Return the result.  An e mpty string denotes an error.
        //
        return strResult;
    }

    bool CanWiaImageBeSafelyRotated( const GUID &guidFormat, LONG nImageWidth, LONG nImageHeight )
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::CanWiaImageBeSafelyRotated( guidFormat, %d, %d )"), nImageWidth, nImageHeight ));
        WIA_PRINTGUID((guidFormat,TEXT("guidFormat")));

        //
        // These are the image types we can possibly rotate (there may be exceptions below)
        //
        static const GUID *guidSafeFormats[] = { &WiaImgFmt_BMP, &WiaImgFmt_JPEG, &WiaImgFmt_PNG, &WiaImgFmt_GIF };

        //
        // Search for this image type
        //
        for (int i=0;i<ARRAYSIZE(guidSafeFormats);i++)
        {
            //
            // If we've found it
            //
            if (*guidSafeFormats[i] == guidFormat)
            {
                //
                // Handle exceptions to the rule
                //
                if (guidFormat == WiaImgFmt_JPEG)
                {
                    //
                    // We can't do lossless rotation on JPG images that are not even multiples of 16 in size
                    //
                    if ((nImageWidth % 16) || (nImageHeight % 16))
                    {
                        WIA_TRACE((TEXT("This image is not valid for rotation because it is not an even multiple of 16")));
                        return false;
                    }
                }

                //
                // If none of the exceptions applied, return TRUE
                //
                WIA_TRACE((TEXT("Returning true")));
                return true;
            }
        }

        //
        // If it is not known that we CAN rotate, we report false
        //
        WIA_TRACE((TEXT("Format type not found in safe list")));
        return false;
    }

    HRESULT ExploreWiaDevice( LPCWSTR pszDeviceId )
    {
        HRESULT hr;

        //
        // Make sure we have a valid device id
        //
        if (!pszDeviceId || !lstrlenW(pszDeviceId))
        {
            return E_INVALIDARG;
        }

        //
        // Load the shell extension's dll
        //
        HINSTANCE hInstWiaShellDll = LoadLibrary(TEXT("WIASHEXT.DLL"));
        if (hInstWiaShellDll)
        {
            //
            // Get the function that creates pidls
            //
            WIAMAKEFULLPIDLFORDEVICE pfnMakeFullPidlForDevice = reinterpret_cast<WIAMAKEFULLPIDLFORDEVICE>(GetProcAddress(hInstWiaShellDll, "MakeFullPidlForDevice"));
            if (pfnMakeFullPidlForDevice)
            {
                //
                // Get the device PIDL
                //
                LPITEMIDLIST pidlDevice = NULL;
                hr = pfnMakeFullPidlForDevice( const_cast<LPWSTR>(pszDeviceId), &pidlDevice );
                if (SUCCEEDED(hr))
                {
                    //
                    // First, ask the shell to refresh any active views
                    //
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlDevice, 0);

                    //
                    // Now show the folder
                    //
                    SHELLEXECUTEINFO ShellExecuteInfo = {0};
                    ShellExecuteInfo.cbSize   = sizeof(ShellExecuteInfo);
                    ShellExecuteInfo.fMask    = SEE_MASK_IDLIST;
                    ShellExecuteInfo.nShow    = SW_SHOW;
                    ShellExecuteInfo.lpIDList = pidlDevice;
                    if (ShellExecuteEx( &ShellExecuteInfo ))
                    {
                        hr = S_OK;
                    }

                    //
                    // Free the pidl
                    //
                    LPMALLOC pMalloc = NULL;
                    if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
                    {
                        pMalloc->Free(pidlDevice);
                        pMalloc->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }

            //
            // Unload the DLL
            //
            FreeLibrary( hInstWiaShellDll );
        }
        else
        {
            //
            // Can't load the DLL
            //
            hr = E_FAIL;
        }

        return hr;
    }

    //
    // Modify a combo box's drop down list so that it is
    // long enough to store the longest string in the list
    // Taken from TaoYuan's code in photowiz.dll and modified
    // to handle ComboBoxEx32 controls
    //
    BOOL ModifyComboBoxDropWidth( HWND hWndCombobox )
    {
        //
        // Make sure we have a valid window
        //
        if (!hWndCombobox)
        {
            return FALSE;
        }

        //
        // Find out how many items are in the combobox.  If there are none, don't bother resizing.
        //
        LRESULT lRes = SendMessage( hWndCombobox, CB_GETCOUNT, 0, 0 );
        if (lRes <= 0)
        {
            return FALSE;
        }
        UINT nCount = static_cast<UINT>(lRes);

        //
        // We only work with fixed-height comboboxes
        //
        lRes = SendMessage( hWndCombobox, CB_GETITEMHEIGHT, 0, 0 );
        if (lRes < 0)
        {
            return FALSE;
        }
        UINT nItemHeight = static_cast<UINT>(lRes);

        //
        // We will be going through to figure out the desired size of the drop down list
        //
        UINT nDesiredWidth = 0;

        //
        // Add the size of the scrollbar to the desired witdth, of there is one
        //
        RECT rcDropped = {0};
        SendMessage( hWndCombobox, CB_GETDROPPEDCONTROLRECT, 0, reinterpret_cast<LPARAM>(&rcDropped) );

        //
        // Get the size of the control's window
        //
        RECT rcWnd = {0};
        GetWindowRect( hWndCombobox, &rcWnd );


        //
        // If not all of the items will fit in the dropped list,
        // we have to account for a vertical scrollbar
        //
        if (((WiaUiUtil::RectHeight(rcDropped) - GetSystemMetrics(SM_CYEDGE)*2) / nItemHeight) < nCount)
        {
            nDesiredWidth += GetSystemMetrics(SM_CXEDGE)*2 + GetSystemMetrics( SM_CXVSCROLL );
        }

        //
        // Find the widest string
        //
        LONG nMaxStringLen = 0;
        HDC hDC = GetDC( hWndCombobox );
        if (hDC)
        {
            //
            // Use the control's font
            //
            HFONT hOldFont = NULL, hFont = reinterpret_cast<HFONT>(SendMessage(hWndCombobox,WM_GETFONT,0,0));
            if (hFont)
            {
                hOldFont = SelectFont( hDC, hFont );
            }

            for (UINT i = 0; i < nCount; i++ )
            {
                //
                // Get the length of this item's text
                //
                LRESULT nLen = SendMessage( hWndCombobox, CB_GETLBTEXTLEN, i, 0 );
                if (nLen > 0)
                {
                    //
                    // Allocate a buffer for the string
                    //
                    LPTSTR pszItem = new TCHAR[nLen+1];
                    if (pszItem)
                    {
                        //
                        // Get the string
                        //
                        pszItem[0] = TEXT('\0');
                        if (SendMessage( hWndCombobox, CB_GETLBTEXT, i, reinterpret_cast<LPARAM>(pszItem) ) > 0)
                        {
                            //
                            // Measure it
                            //
                            SIZE sizeText = {0};
                            if (GetTextExtentPoint32( hDC, pszItem, lstrlen( pszItem ), &sizeText ))
                            {
                                //
                                // If this is the longest one, save its length
                                //
                                if (sizeText.cx > nMaxStringLen)
                                {
                                    nMaxStringLen = sizeText.cx;
                                }
                            }
                        }

                        //
                        // Free the string
                        //
                        delete[] pszItem;
                    }
                }
            }

            //
            // Restore and release the DC
            //
            if (hOldFont)
            {
                SelectFont( hDC, hOldFont );
            }
            ReleaseDC( hWndCombobox, hDC );
        }
        //
        // Add in the longest string's length
        //
        nDesiredWidth += nMaxStringLen;


        //
        // If this is a ComboBoxEx32, add in the width of the icon
        //
        TCHAR szClassName[MAX_PATH] = {0};
        if (GetClassName( hWndCombobox, szClassName, ARRAYSIZE(szClassName)))
        {
            //
            // Compare the classname with ComboBoxEx32
            //
            if (!lstrcmp(szClassName,WC_COMBOBOXEX))
            {
                //
                // Get the image list from the control
                //
                HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendMessage( hWndCombobox, CBEM_GETIMAGELIST, 0, 0 ));
                if (hImageList)
                {
                    //
                    // Get the width and add it to the desired size
                    //
                    INT nWidth=0, nHeight=0;
                    if (ImageList_GetIconSize( hImageList, &nWidth, &nHeight ))
                    {
                        //
                        // I don't know what the margin should be, but nWidth*2
                        // should account for the width of icon and its margin
                        //
                        nDesiredWidth += nWidth * 2;
                    }
                }
            }
        }

        //
        // Add in the border of the control
        //
        nDesiredWidth += GetSystemMetrics(SM_CXFIXEDFRAME)*2;

        //
        // Make sure our drop down is no wider than the current monitor
        //
        HMONITOR hMonitor = MonitorFromWindow( hWndCombobox, MONITOR_DEFAULTTONEAREST );
        if (hMonitor)
        {
            MONITORINFO MonitorInfo = {0};
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            //
            // Get the screen coordinates of this monitor
            //
            if (GetMonitorInfo(hMonitor, &MonitorInfo))
            {
                //
                // If the desired width is larger than the monitor, shorten it
                //
                if (nDesiredWidth > static_cast<UINT>(WiaUiUtil::RectWidth(MonitorInfo.rcMonitor)))
                {
                    nDesiredWidth = RectWidth(MonitorInfo.rcMonitor);
                }
            }
        }


        //
        // If our size is smaller than the control's current size, grow it
        //
        if (static_cast<UINT>(WiaUiUtil::RectWidth(rcDropped)) < nDesiredWidth)
        {
            //
            // Disable redrawing
            //
            SendMessage( hWndCombobox, WM_SETREDRAW, FALSE, 0 );


            SendMessage( hWndCombobox, CB_SETDROPPEDWIDTH, static_cast<WPARAM>(nDesiredWidth), 0 );

            //
            // Allow redrawing
            //
            SendMessage( hWndCombobox, WM_SETREDRAW, TRUE, 0 );

            //
            // Force a repaint
            //
            InvalidateRect( hWndCombobox, NULL, FALSE );
            UpdateWindow( hWndCombobox );

            //
            // TRUE means we actually changed it
            //
            return TRUE;
        }

        return FALSE;
    }

    static LPCTSTR s_pszComboBoxExWndProcPropName = TEXT("WiaComboBoxExWndProcPropName");

    static LRESULT WINAPI ComboBoxExWndProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        static WNDPROC s_pfnDefProc = NULL;

        WNDPROC pfnWndProc = reinterpret_cast<WNDPROC>(GetProp( hWnd, s_pszComboBoxExWndProcPropName ));

        if (!s_pfnDefProc)
        {
            WNDCLASS wc = {0};
            GetClassInfo( GetModuleHandle(TEXT("user32.dll")), TEXT("ComboBox"), &wc );
            s_pfnDefProc = wc.lpfnWndProc;
        }
        if (nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN)
        {
            if (s_pfnDefProc)
            {
                return CallWindowProc( s_pfnDefProc, hWnd, nMsg, wParam, lParam );
            }
        }
        if (nMsg == WM_DESTROY)
        {
            RemoveProp( hWnd, s_pszComboBoxExWndProcPropName );
        }
        if (pfnWndProc)
        {
            return CallWindowProc( pfnWndProc, hWnd, nMsg, wParam, lParam );
        }
        else
        {
            return CallWindowProc( DefWindowProc, hWnd, nMsg, wParam, lParam );
        }
    }

    //
    // This subclasses the ComboBoxEx32 to work around a bug
    // that causes the list to drop down at bad times.
    // Uses a window property to store the previous wndproc.
    // Taken from DavidShi's code in wiashext.dll
    //
    void SubclassComboBoxEx( HWND hWnd )
    {
        HWND hComboBox = FindWindowEx( hWnd, NULL, TEXT("ComboBox"), NULL );
        if (hComboBox)
        {
            LONG_PTR pfnOldWndProc = SetWindowLongPtr( hComboBox, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(ComboBoxExWndProc));
            SetProp( hComboBox, s_pszComboBoxExWndProcPropName, reinterpret_cast<HANDLE>(pfnOldWndProc) );
        }
    }

    HRESULT IssueWiaCancelIO( IUnknown *pUnknown )
    {
        if (!pUnknown)
        {
            return E_POINTER;
        }

        CComPtr<IWiaItemExtras> pWiaItemExtras;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItemExtras, (void**)&pWiaItemExtras );
        if (SUCCEEDED(hr))
        {
            hr = pWiaItemExtras->CancelPendingIO();
        }
        return hr;
    }


    HRESULT VerifyScannerProperties( IUnknown *pUnknown )
    {
        HRESULT hr = E_FAIL;

        //
        // Table of required properties
        //
        static const PROPID s_RequiredProperties[] =
        {
            WIA_IPS_CUR_INTENT
        };

        //
        // Make sure we have a valid item
        //
        if (pUnknown)
        {
            //
            // Assume success at this point
            //
            hr = S_OK;

            //
            // Get the IWiaPropertyStorage interface
            //
            CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
            hr = pUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage);
            if (SUCCEEDED(hr))
            {
                //
                // Loop through each property and make sure it exists
                // Break out if hr != S_OK
                //
                for (int i=0;i<ARRAYSIZE(s_RequiredProperties) && S_OK==hr;i++)
                {
                    //
                    // Prepare the propspec
                    //
                    PROPSPEC PropSpec = {0};
                    PropSpec.ulKind = PRSPEC_PROPID;
                    PropSpec.propid = s_RequiredProperties[i];

                    //
                    // Attempt to get the property attributes
                    //
                    ULONG nAccessFlags = 0;
                    PROPVARIANT PropVariant = {0};
                    hr = pWiaPropertyStorage->GetPropertyAttributes( 1, &PropSpec, &nAccessFlags, &PropVariant );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Prevent a leak
                        //
                        PropVariantClear(&PropVariant);

                        //
                        // If everything is OK so far
                        //
                        if (S_OK == hr)
                        {
                            //
                            // Zero out the structure
                            //
                            PropVariantInit(&PropVariant);

                            //
                            // Attempt to read the actual value
                            //
                            hr = pWiaPropertyStorage->ReadMultiple( 1, &PropSpec, &PropVariant );
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Free the actual value
                                //
                                PropVariantClear(&PropVariant);
                            }
                        }
                    }
                }
            }
        }

        //
        // S_FALSE means a property doesn't exist, so change this to an error
        //
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        //
        // All done
        //
        return hr;
    }

    CSimpleString GetErrorTextFromHResult( HRESULT hr )
    {
        CSimpleString strResult;
        LPTSTR szErrMsg = NULL;
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       reinterpret_cast<LPTSTR>(&szErrMsg),
                       0,
                       NULL
                      );
        if (szErrMsg)
        {
            strResult = szErrMsg;
            LocalFree( szErrMsg );
        }
        return strResult;
    }

} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for common UI library
 *
 *****************************************************************************/

#ifndef _pch_h
#define _pch_h


#include <windows.h>
#include <sti.h>
#include <commctrl.h>
#include <atlbase.h>
#include <propidl.h>
#include "wia.h"
#include "uicommon.h"
#include "simcrack.h"
#include "simarray.h"
#include "simreg.h"
#include "wiadebug.h"
#include "miscutil.h"
#include "pshelper.h"
#include "rescale.h"
#include "resid.h"
#include <shfusion.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\multistr.h ===
#ifndef __MULTISTR_H
#define __MULTISTR_H

#include "simarray.h"
#include "simstr.h"

// Must be instantiated with an instance of CSimpleStringBase
template <class T, class M>
class CMultiStringBase : public CSimpleDynamicArray<M>
{
public:
    CMultiStringBase( const CMultiStringBase &other )
    {
        Append(other);
    }
    CMultiStringBase( const T *pstrMultiString = NULL )
    {
        for (T *pstrCurrent = const_cast<T*>(pstrMultiString); pstrCurrent && *pstrCurrent; pstrCurrent += M(pstrCurrent).Length() + 1)
            Append(pstrCurrent);
    }
    virtual ~CMultiStringBase(void)
    {
    }
    CMultiStringBase &operator=( const CMultiStringBase &other )
    {
        Destroy();
        Append(other);
        return (*this);
    }
};

typedef CMultiStringBase<TCHAR,CSimpleString> CMultiString;
typedef CMultiStringBase<WCHAR,CSimpleStringWide> CMultiStringWide;
typedef CMultiStringBase<CHAR,CSimpleStringAnsi> CMultiStringAnsi;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\movewnd.h ===
#ifndef __MOVEWND_H_INCLUDED
#define __MOVEWND_H_INCLUDED

/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MOVEWND.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/31/1999
 *
 *  DESCRIPTION: Simplified Wrapper for DeferWindowPos, plus a couple helpers
 *
 *  To use:
 *
 *  CMoveWindow mw;
 *  mw.MoveWindow( hWnd1, x1, y1, w1, h1, flags1 );
 *  mw.MoveWindow( hWnd2, x2, y2, w2, h2, flags2 );
 *  mw.Apply();  // Optional, the destructor will do this if necessary.
 *
 *******************************************************************************/

#include <windows.h>

class CMoveWindow
{
public:

    // Move/Size Flags
    enum
    {
        NO_MOVEX = 0x00000001,
        NO_MOVEY = 0x00000002,
        NO_MOVE  = (NO_MOVEX|NO_MOVEY),
        NO_SIZEX = 0x00000004,
        NO_SIZEY = 0x00000008,
        NO_SIZE  = (NO_SIZEX|NO_SIZEY)
    };

private:
    // Not implemented
    CMoveWindow( const CMoveWindow & );
    CMoveWindow &operator=( const CMoveWindow & );

private:
    HDWP m_hDeferWindowPos;
    bool m_bNeedApply;

public:
    CMoveWindow( int nNumWindows = 10 )
    : m_bNeedApply(false)
    {
        Initialize(nNumWindows);
    }
    bool Initialize( int nNumWindows = 10 )
    {
        m_hDeferWindowPos = BeginDeferWindowPos(nNumWindows);
        return(m_hDeferWindowPos != NULL);
    }
    static bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return (MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    void Move( HWND hWnd, int x, int y, DWORD nFlags = 0 )
    {
        SizeMove( hWnd, x, y, 0, 0, NO_SIZE|nFlags );
    }
    void Size( HWND hWnd, int w, int h, DWORD nFlags = 0 )
    {
        SizeMove( hWnd, 0, 0, w, h, NO_MOVE|nFlags );
    }
    void SizeMove( HWND hWnd, int x, int y, int w, int h, DWORD nFlags = 0 )
    {
        m_bNeedApply = true;

        RECT rcWndInScreenCoords, rcWndInParentCoords;
        GetWindowRect( hWnd, &rcWndInScreenCoords );

        rcWndInParentCoords = rcWndInScreenCoords;
        HWND hWndParent = GetParent(hWnd);
        if (hWndParent)
        {
            ScreenToClient( hWndParent, rcWndInParentCoords );
        }

        if (m_hDeferWindowPos)
        {
            DeferWindowPos( m_hDeferWindowPos, hWnd, NULL,
                            nFlags&NO_MOVEX ? rcWndInParentCoords.left : x,
                            nFlags&NO_MOVEY ? rcWndInParentCoords.top : y,
                            nFlags&NO_SIZEX ? rcWndInParentCoords.right - rcWndInParentCoords.left : w,
                            nFlags&NO_SIZEY ? rcWndInParentCoords.bottom - rcWndInParentCoords.top : h,
                            SWP_NOACTIVATE|SWP_NOZORDER
                          );
        }
    }
    void Hide( HWND hWnd )
    {
        if (IsWindowVisible(hWnd))
        {
            ShowWindow( hWnd, SW_HIDE );
        }
    }
    void Show( HWND hWnd )
    {
        if (!IsWindowVisible(hWnd))
        {
            ShowWindow( hWnd, SW_SHOW );
        }
    }
    void Enable( HWND hWnd )
    {
        if (!IsWindowEnabled(hWnd))
        {
            ShowWindow( hWnd, TRUE );
        }
    }
    void Disable( HWND hWnd )
    {
        if (IsWindowEnabled(hWnd))
        {
            ShowWindow( hWnd, FALSE );
        }
    }
    void Apply(void)
    {
        if (m_bNeedApply && m_hDeferWindowPos)
        {
            EndDeferWindowPos(m_hDeferWindowPos);
            m_hDeferWindowPos = NULL;
        }
    }
    ~CMoveWindow(void)
    {
        Apply();
    }
};


#endif // __MOVEWND_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\propstrm.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPSTRM.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Property Stream Wrapper
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "propstrm.h"
#include "simreg.h"

CPropertyStream::CPropertyStream(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream(void)"));
}


CPropertyStream::CPropertyStream( IStream *pIStream )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( IStream *pIStream )"));
    CopyFromStream( pIStream );
}


CPropertyStream::CPropertyStream( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( IWiaItem *pIWiaItem )"));
    AssignFromWiaItem( pIWiaItem );
}


CPropertyStream::CPropertyStream( const CPropertyStream &other )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( const CPropertyStream &other )"));
    CopyFromStream( other.Stream() );
}

CPropertyStream::~CPropertyStream()
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::~CPropertyStream"));
    Destroy();
}


CPropertyStream &CPropertyStream::operator=( const CPropertyStream &other )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::operator="));
    if (this != &other)
    {
        CopyFromStream( other.Stream() );
    }
    return (*this);
}

bool CPropertyStream::IsValid(void) const
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::IsValid"));
    return (m_pIStreamPropertyStream.p != NULL);
}


void CPropertyStream::Destroy(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Destroy"));
    m_pIStreamPropertyStream = NULL;
}


HRESULT CPropertyStream::CopyFromMemoryBlock( PBYTE pbSource, UINT_PTR nSize )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CopyFromMemoryBlock"));
    Destroy();
    HRESULT hr = S_OK;

    if (pbSource)
    {
        if (nSize)
        {
            // Allocate memory to back the new stream.
            HGLOBAL hTarget = GlobalAlloc(GMEM_MOVEABLE, nSize);
            if (hTarget)
            {
                PBYTE pbTarget = (PBYTE)GlobalLock(hTarget);
                if (pbTarget)
                {
                    CopyMemory( pbTarget, pbSource, nSize );
                    GlobalUnlock( hTarget );
                    hr = CreateStreamOnHGlobal(hTarget, TRUE, &m_pIStreamPropertyStream );
                }
                else
                {
                    WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, GlobalLock failed"));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, GlobalAlloc failed, size: %d", nSize));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, nSize == 0"));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, Invalid source buffer"));
        hr = E_INVALIDARG;
    }
    return(hr);
}

HRESULT CPropertyStream::CopyFromStream( IStream *pIStream )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CopyFromStream"));
    Destroy();
    HRESULT hr = S_OK;

    if (pIStream)
    {
        HGLOBAL hSource;
        hr = GetHGlobalFromStream(pIStream, &hSource);
        if (SUCCEEDED(hr))
        {
            // Get the size of the stream.
            UINT_PTR nSize = GlobalSize(hSource);
            if (nSize)
            {
                PBYTE pbSource = (PBYTE)GlobalLock(hSource);
                if (pbSource)
                {
                    hr = CopyFromMemoryBlock( pbSource, nSize );
                    GlobalUnlock(hSource);
                }
                else
                {
                    WIA_ERROR(("CPropertyStream::CopyFromStream, GlobalLock failed"));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                WIA_ERROR(("CPropertyStream::CopyFromStream, GlobalSize failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            WIA_ERROR(("CPropertyStream::CopyFromStream, GetHGlobalFromStream failed"));
        }
    }
    else
    {
        WIA_ERROR(("CPropertyStream::CopyFromStream, Invalid source stream"));
        hr = E_INVALIDARG;
    }
    if (FAILED(hr))
    {
        WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::CopyFromStream failed")));
    }
    return(hr);
}


HRESULT CPropertyStream::AssignFromWiaItem( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::AssignFromWiaItem"));
    Destroy();
    
    HRESULT hr;
    if (pIWiaItem)
    {
        IWiaPropertyStorage *pIWiaPropertyStorage;
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            GUID    guidCompatibilityId;
            hr = pIWiaPropertyStorage->GetPropertyStream(&guidCompatibilityId, &m_pIStreamPropertyStream);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::AssignFromWiaItem, GetPropertyStream failed")));
            }

            pIWiaPropertyStorage->Release();
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::AssignFromWiaItem, QI of IID_IWiaPropertyStorage failed")));
        }
    }
    else
    {
        hr = E_INVALIDARG;
        WIA_ERROR(("CPropertyStream::AssignFromWiaItem, Invalid IWiaItem *"));
    }

    if (!SUCCEEDED(hr))
    {
        WIA_PRINTHRESULT((hr,"CPropertyStream::AssignFromWiaItem failed"));
    }
    return(hr);
}


HRESULT CPropertyStream::ApplyToWiaItem( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::ApplyToWiaItem"));
    HRESULT hr;
    if (pIWiaItem && m_pIStreamPropertyStream)
    {
        IWiaPropertyStorage *pIWiaPropertyStorage;
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            hr = pIWiaPropertyStorage->SetPropertyStream((GUID*) &GUID_NULL, m_pIStreamPropertyStream);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::ApplyToWiaItem, SetPropertyStream failed")));
            }

            pIWiaPropertyStorage->Release();
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::ApplyToWiaItem, QI of IID_IWiaPropertyStorage failed")));
        }
    }
    else
    {
        hr = E_INVALIDARG;
        WIA_ERROR(("CPropertyStream::ApplyToWiaItem, Invalid IWiaItem *"));
    }
    if (!SUCCEEDED(hr))
    {
        WIA_PRINTHRESULT((hr,"CPropertyStream::ApplyToWiaItem failed"));
    }
    return(hr);
}


IStream *CPropertyStream::Stream(void)
{
    WIA_PUSHFUNCTION(TEXT("*CPropertyStream::Stream(void)"));
    return(m_pIStreamPropertyStream);
}


IStream *CPropertyStream::Stream(void) const
{
    WIA_PUSHFUNCTION(TEXT("*CPropertyStream::Stream(void) const"));
    return(m_pIStreamPropertyStream);
}


UINT_PTR CPropertyStream::Size(void) const
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Size"));
    UINT_PTR nSize = 0;

    if (m_pIStreamPropertyStream)
    {
        STATSTG StatStg;
        if (SUCCEEDED(m_pIStreamPropertyStream->Stat(&StatStg,STATFLAG_NONAME)))
            nSize = StatStg.cbSize.LowPart;
    }
    return(nSize);
}


PBYTE CPropertyStream::Lock(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Lock"));
    PBYTE pBytes = NULL;

    if (m_pIStreamPropertyStream)
    {
        HGLOBAL hSource;
        HRESULT hr = GetHGlobalFromStream(m_pIStreamPropertyStream, &hSource);
        if (SUCCEEDED(hr))
        {
            pBytes = reinterpret_cast<PBYTE>(GlobalLock( hSource ));
        }
    }
    return(pBytes);
}


void CPropertyStream::Unlock(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Unlock"));
    PBYTE pBytes = NULL;

    if (m_pIStreamPropertyStream)
    {
        HGLOBAL hSource;
        HRESULT hr = GetHGlobalFromStream(m_pIStreamPropertyStream, &hSource);
        if (SUCCEEDED(hr))
        {
            GlobalUnlock( hSource );
        }
    }
}

bool ConstructRegistryPath( IWiaItem *pWiaItem, LPCTSTR pszSubKey, CSimpleString &strKeyName )
{
    if (pWiaItem)
    {
        strKeyName = pszSubKey;
        if (strKeyName.Length())
        {
            // Append a backslash
            if (strKeyName[(int)(strKeyName.Length())] != TEXT('\\'))
                strKeyName += TEXT("\\");

            CSimpleStringWide strwItemName;
            if (PropStorageHelpers::GetProperty( pWiaItem, WIA_IPA_FULL_ITEM_NAME, strwItemName ))
            {
                strKeyName += CSimpleStringConvert::NaturalString( strwItemName );
                return true;
            }
        }
    }
    return false;
}

bool CPropertyStream::GetBytes( PBYTE &pByte, UINT_PTR &nSize )
{
    bool bSuccess = false;
    if (m_pIStreamPropertyStream)
    {
        nSize = Size();
        if (nSize)
        {
            pByte = new BYTE[nSize];
            if (pByte)
            {
                LARGE_INTEGER li = {0,0};
                if (SUCCEEDED(m_pIStreamPropertyStream->Seek(li,STREAM_SEEK_SET,NULL)))
                {
                    DWORD dwBytesRead = 0;
                    if (SUCCEEDED(m_pIStreamPropertyStream->Read( pByte, static_cast<DWORD>(nSize), &dwBytesRead )))
                    {
                        if (static_cast<DWORD>(dwBytesRead) == nSize)
                        {
                            bSuccess = true;
                        }
                    }
                }
                if (!bSuccess)
                {
                    delete[] pByte;
                    pByte = NULL;
                    nSize = 0;
                }
            }
        }
    }
    return bSuccess;
}

bool CPropertyStream::WriteToRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName )
{
    bool bResult = false;
    CSimpleString strKeyName;
    if (ConstructRegistryPath( pWiaItem, pszSubKey, strKeyName ))
    {
        CSimpleReg reg( hKeyRoot, strKeyName, true, KEY_WRITE );
        if (reg.OK())
        {
            UINT_PTR nSize = 0;
            PBYTE pData = NULL;
            if (GetBytes(pData,nSize) && nSize && pData)
            {
                bResult = reg.SetBin( pszValueName, pData, static_cast<DWORD>(nSize), REG_BINARY );
                delete[] pData;
            }
            else
            {
                reg.Delete( pszValueName );
            }
        }
    }
    return bResult;
}


bool CPropertyStream::ReadFromRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName )
{
    bool bResult = false;
    Destroy();
    CSimpleString strKeyName;
    if (ConstructRegistryPath( pWiaItem, pszSubKey, strKeyName ))
    {
        CSimpleReg reg( hKeyRoot, strKeyName, false, KEY_READ );
        if (reg.OK())
        {
            UINT_PTR nStreamSize = reg.Size(pszValueName);
            if (nStreamSize)
            {
                BYTE *pData = new BYTE[nStreamSize];
                if (pData)
                {
                    if (reg.QueryBin( pszValueName, pData, static_cast<DWORD>(nStreamSize) ))
                    {
                        if (SUCCEEDED(CopyFromMemoryBlock( pData, nStreamSize )))
                        {
                            bResult = true;
                        }
                    }
                    delete[] pData;
                }
            }
        }
    }
    return bResult;
}

CAutoRestorePropertyStream::CAutoRestorePropertyStream( IWiaItem *pItem )
{
    m_hr = m_PropertyStream.AssignFromWiaItem(pItem);
    m_pWiaItem = pItem;
}

CAutoRestorePropertyStream::~CAutoRestorePropertyStream()
{
    if (SUCCEEDED(m_hr))
    {
        m_PropertyStream.ApplyToWiaItem(m_pWiaItem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\propstrm.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPSTRM.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Property stream wrapper
 *
 *******************************************************************************/
#ifndef __PROPSTRM_H_INCLUDED
#define __PROPSTRM_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include "simreg.h"
#include "simstr.h"

class CPropertyStream
{
private:
    CComPtr<IStream> m_pIStreamPropertyStream;

public:
    CPropertyStream(void);
    CPropertyStream( IStream *pIStream );
    CPropertyStream( IWiaItem *pIWiaItem );
    CPropertyStream( const CPropertyStream &other );
    ~CPropertyStream();
    CPropertyStream &operator=( const CPropertyStream &other );
    bool IsValid(void) const;
    void Destroy(void);
    HRESULT CopyFromStream( IStream *pIStream );
    HRESULT CopyFromMemoryBlock( PBYTE pbSource, UINT_PTR nSize );
    HRESULT AssignFromWiaItem( IWiaItem *pIWiaItem );
    HRESULT ApplyToWiaItem( IWiaItem *pIWiaItem );
    IStream *Stream(void);
    IStream *Stream(void) const;
    UINT_PTR Size(void) const;
    PBYTE Lock(void);
    void Unlock(void);
    bool GetBytes( PBYTE &pByte, UINT_PTR &nSize );
    bool WriteToRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName );
    bool ReadFromRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName );
};

class CAutoRestorePropertyStream
{
private:
    CPropertyStream m_PropertyStream;
    HRESULT m_hr;
    CComPtr<IWiaItem> m_pWiaItem;

public:
    CAutoRestorePropertyStream( IWiaItem *pWiaItem );
    ~CAutoRestorePropertyStream(void);
};

#endif //__PROPSTRM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\regionde.cpp ===
// RegionDetector.cpp: implementation of the CRegionDetector class.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#pragma hdrstop

#include "regionde.h"


inline ULONG Intensity(ULONG value);
inline ULONG DifferenceFromGray(ULONG value);
inline UCHAR Difference(UCHAR a, UCHAR b);
inline ULONG Difference(ULONG a, ULONG b);
int inline MAX(int a, int b);
int inline MIN(int a, int b);

// helper functions

// sum of RGB vals
inline ULONG Intensity(ULONG value)
{
    return(value&0xff)+((value&0xff00)>>8)+((value&0xff0000)>>16);
}

// shadows are gray... if you aint gray... you aint a shadow
inline ULONG DifferenceFromGray(ULONG value)
{
    UCHAR g,b;//,b;
    //  r=(UCHAR)(value& 0x0000ff);
    g=(UCHAR)((value& 0x00ff00)>>8);
    b=(UCHAR)((value& 0xff0000)>>16);
    // use this instead of the complete formula (uncomment the commented out code for the complete formula)
    // allow yellow scanner backgrounds
    return(ULONG)(Difference(b,g));//+Difference(r,g)+Difference(g,b));
}

// we should make a Difference Template to clean up this code

inline UCHAR Difference(UCHAR a, UCHAR b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline ULONG Difference(ULONG a, ULONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline LONG Difference(LONG a, LONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

int inline MAX(int a, int b)
{
    if (a>b) return(a);
    return(b);
}

int inline MIN(int a, int b)
{
    if (a<b) return(a);
    return(b);
}

// if we have resampled the image, we may want to convert back to the origional coordinate system
bool CRegionDetector::ConvertToOrigionalCoordinates()
{
    if (m_pRegions!=NULL)
    {
        int i;
        for (i=0;i<m_pRegions->m_numRects;i++)
        {
            m_pRegions->m_pRects[i].left=m_pRegions->m_pRects[i].left*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].right=m_pRegions->m_pRects[i].right*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].top=m_pRegions->m_pRects[i].top*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].bottom=m_pRegions->m_pRects[i].bottom*m_resampleFactor+m_resampleFactor/2;
        }
        return(true);
    }
    return(false);
}

// simplified Region detection code for single region detection
// Faster and about as accurate
// FindSingleRegion encapsulates a subset of FindRegions.  at the moment, for code documentation of FindSingleRegion, see FindRegions
bool CRegionDetector::FindSingleRegion()
{
    // cast the pointers
    // S = Scan, B = blank background, V = virtual screen... new image
    int x,y;
    int a,b; // loop vars used for merging regions
    int border; // for aggregation on a rectangle by rectangle basis
    ULONG position;
    int numChunks;
    bool unionOperationInLastPass;
    ULONG* pImagePixels;
    ULONG* pEdgePixels;
    int requiredPixels;

    // if the bitmap is too large we can use halfsize to resample it down to a more reasonable size...
    // on a fast proccessor, current performance tests show that for most preview images this won't be needed
    // but if the user scans an image at 300 dpi, this will come in handy.

    //    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // for FingSingleRegion we plan on doing one resample before image proccessing
    // with an expected image size of 200x300 pixels which greatly reduces the proccessor load
    m_resampleFactor=1;
    while (m_pScan->m_nBitmapWidth>GOALX || m_pScan->m_nBitmapHeight>GOALY)
    {
        m_pScan->HalfSize();
        m_resampleFactor*=2;
    }

    m_pScan->Invert(); // filters operate on inverted images

    m_pScan->CorrectBrightness();

    requiredPixels=m_pScan->m_nBitmapWidth*m_pScan->m_nBitmapHeight/256/10;
    if (requiredPixels==0) requiredPixels=1; // special case for a particularly small preview scan

    m_pScan->MaxContrast(requiredPixels); // spread the images color spectrum out... concept: balance color spectra between different scans

    m_pScanBlurred->CreateBlurBitmap(m_pScan);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanDoubleBlurred->CreateBlurBitmap(m_pScanBlurred);
    m_pScanTripleBlurred->CreateBlurBitmap(m_pScanDoubleBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScan);
    m_pScanVerticalBlurred->CreateVerticalBlurBitmap(m_pScan);

    m_pScanEdges->CreateDifferenceBitmap(m_pScan,m_pScanBlurred); // think about how you create an edge bitmap and you will understand
    m_pScanDoubleEdges->CreateDifferenceBitmap(m_pScanBlurred,m_pScanDoubleBlurred); // we will get a huge accuracy boost from this simple step
    m_pScanTripleEdges->CreateDifferenceBitmap(m_pScanDoubleBlurred,m_pScanTripleBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanHorizontalEdges->CreateDifferenceBitmap(m_pScan,m_pScanHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanVerticalEdges->CreateDifferenceBitmap(m_pScan,m_pScanVerticalBlurred); // we will get a huge accuracy boost from this simple step

    // free memory as soon as it isn't needed
    if (m_pScanVerticalBlurred!=NULL)
    {
        delete m_pScanVerticalBlurred;
        m_pScanVerticalBlurred=NULL;
    }
    if (m_pScanHorizontalBlurred!=NULL)
    {
        delete m_pScanHorizontalBlurred;
        m_pScanHorizontalBlurred=NULL;
    }

    if (m_pScanDoubleBlurred!=NULL)
    {
        delete m_pScanDoubleBlurred;
        m_pScanDoubleBlurred=NULL;
    }

    if (m_pScanTripleBlurred!=NULL)
    {
        delete m_pScanTripleBlurred;
        m_pScanTripleBlurred=NULL;
    }

    // these 5 calls to killShadows make up the real meat of the region detection work done by the program.
    // KillShadows now performs more tasks than simply killing shadows. Killshadows also enhances edges
    // and removes background colors
    // the doubleBlur and tripleBlur edge maps are needed so that we can distinguish between an uneven background scanner color and a real image.
    // see KillShadows for more documentation.
    // m_pScanBlurred is the bitmap we will use to determine where regions are
    // these calls to KillShadows act to enhance pixels which are part of regions and inhibit pixels which are not part of regions

    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);

    m_pScanBlurred->KillShadows(m_pScanEdges, MAXSHADOWSTART,MAXSHADOWPIXEL-1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);

    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,MAXSHADOWSTART,MAXSHADOWPIXEL+2,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);
    m_pScanBlurred->KillShadows(m_pScanTripleEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);

    // RemoveBlackBorder removes questionable pixels around the outside edge of an image.
    // RemoveBlackBorder has only very limited utility for region detection on images that were not aquired from a scanner
    m_pScan->RemoveBlackBorder(MIN_BLACK_SCANNER_EDGE_CHAN_VALUE,m_pScanBlurred,m_pScan);

    // despeckle removes small clumps of pixels which are probably stray static
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // pMap will hold information on which region each pixel on the screen is part of
    int *pMap=new int[m_pScanBlurred->m_nBitmapHeight*m_pScanBlurred->m_nBitmapWidth];
    if (pMap)
    {
        numChunks=m_pScanBlurred->FindChunks(pMap); // maps chunks on m_pScanBlurred to pMap

        if (m_pRegions!=NULL) delete m_pRegions;
        m_pRegions = new CRegionList(numChunks); // create a CRegionList to map the chunks onto.

        if (m_pRegions)
        {

            m_pRegions->m_nBitmapWidth=m_pScan->m_nBitmapWidth;
            m_pRegions->m_nBitmapHeight=m_pScan->m_nBitmapHeight;
            // now turn region map into region rectangles
            // it could be argued that this routine should be placed in C32BitDibWrapper
            // but we don't want to make C32BitDibWrapper encompas too much functionality which
            // would only be useful for imagedetection

            pImagePixels=(ULONG *)(m_pScanBlurred->m_pBits); // we want to use 32 bit chunks instead of 8 bit chunks
            pEdgePixels=(ULONG *)(m_pScanEdges->m_pBits);

            // add all the bitmap pixels to the m_pRegions list
            position=0;
            for (y=0;y<m_pScan->m_nBitmapHeight;y++)
            {
                for (x=0;x<m_pScan->m_nBitmapWidth;x++)
                {
                    if (pMap[position]>0)
                    {
                        m_pRegions->AddPixel(pMap[position]-1, pImagePixels[position],pEdgePixels[position], x, y); // pMap values start at 1, let region values start at 0
                    }                                                // we start pMap at 1 so that 0 can indicate a pixel that is not assigned to any region
                    position++;                                      // we may want to make pMap start at 0 at some later date
                }
            }

            m_pRegions->m_numRects=numChunks;
            m_pRegions->m_validRects=numChunks;

            // free bitmaps as soon as they will no longer be used
            if (m_pScanHorizontalEdges!=NULL)
            {
                delete m_pScanHorizontalEdges;
                m_pScanHorizontalEdges=NULL;
            }
            if (m_pScanVerticalEdges!=NULL)
            {
                delete m_pScanVerticalEdges;
                m_pScanVerticalEdges=NULL;
            }

            // merge together regions
            // this routine is pretty much a waste when performing single region detection
            // the only advantage of it over simply calling unionRegions is that
            // we can merge together small close together regions, but kill small regions that are far from other regions (probably static)

            for (border=0;border<MAXBORDER;border+=SINGLE_REGION_BORDER_INCREMENT) // when detecting a single region detection,
            {
                // we don't need to inch along one border pixel width increment at a time
                // as we know we want to compact down to a single region in the end
                unionOperationInLastPass=true;

                for (a=0;a<m_pRegions->m_numRects;a++) // overkill, we could be cleverer about when we check for valid regions
                {
                    m_pRegions->checkIfValidRegion(a, border); // sets m_valid params
                }

                m_pRegions->CompactDown(m_pRegions->m_validRects); // remove all invalid rects to save search time


                while (unionOperationInLastPass==true)
                {
                    unionOperationInLastPass=false;
                    for (a=0;a<m_pRegions->m_numRects;a++)
                    {
                        if (m_pRegions->m_valid[a]==true)
                        {
                            for (b=a+1;b<m_pRegions->m_numRects;b++)
                            {
                                if (m_pRegions->m_valid[b]==true)
                                {
                                    if (m_pRegions->CheckIntersect(a,b,border)==true)
                                    {
                                        m_pRegions->UnionRegions(a,b);
                                        m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                        unionOperationInLastPass=true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // m_pScanBlurred->ColorChunks(pMap); // for debugging purposes... so we know where exactly chunks are


            m_pRegions->CompactDown(m_pRegions->m_validRects); // remove all invalid rects to save search time
        }
        delete[] pMap;
    }

    return(TRUE);
}


// detect regions
// makes heavy use of C32BitWrapper helper functions
// WARNING: this function has not been updated to include the latest changes
// to compensate for poor image quality
//
int CRegionDetector::FindRegions()
{
    // cast the pointers
    // S = Scan, B = blank background, V = virtual screen... new image
    int x,y;
    int a,b;
    int i;
    bool done, weird;
    char* pWall; // 2d array keeping track of which regions have walls between them and other regions
    // wall vals... TRUE, FALSE, UNKNOWN
    int border; // for aggregation on a rectangle by rectangle basis
    ULONG position;
    int numChunks;
    bool unionOperationInLastPass;
    ULONG* pImagePixels;
    ULONG* pEdgePixels;
    int requiredPixels;

    // if the bitmap is too large we can use halfsize to resample it down to a more reasonable size...
    // on a fast proccessor, current performance tests show that for most preview images this won't be needed
    // but if the user scans an image at 300 dpi, this will come in handy.
    while (m_pScan->m_nBitmapWidth>GOALX || m_pScan->m_nBitmapHeight>GOALY)
    {
        m_pScan->HalfSize();
    }

    m_pScanBlurred->CreateBlurBitmap(m_pScan);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanDoubleBlurred->CreateBlurBitmap(m_pScanBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanTripleBlurred->CreateBlurBitmap(m_pScanDoubleBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScan);
    m_pScanVerticalBlurred->CreateVerticalBlurBitmap(m_pScan);

    m_pScanDoubleHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScanHorizontalBlurred);
    m_pScanDoubleVerticalBlurred->CreateVerticalBlurBitmap(m_pScanVerticalBlurred);


    m_pScanEdges->CreateDifferenceBitmap(m_pScan,m_pScanBlurred); // think about how you create an edge bitmap and you will understand
    m_pScanDoubleEdges->CreateDifferenceBitmap(m_pScanBlurred,m_pScanDoubleBlurred); // we will get a huge accuracy boost from this simple step
    m_pScanTripleEdges->CreateDifferenceBitmap(m_pScanDoubleBlurred,m_pScanTripleBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanHorizontalEdges->CreateDifferenceBitmap(m_pScan,m_pScanHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanVerticalEdges->CreateDifferenceBitmap(m_pScan,m_pScanVerticalBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanDoubleHorizontalEdges->CreateDifferenceBitmap(m_pScanHorizontalBlurred,m_pScanDoubleHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanDoubleVerticalEdges->CreateDifferenceBitmap(m_pScanVerticalBlurred,m_pScanDoubleVerticalBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanBlurred->Invert(); // filters operate on inverted images

    requiredPixels=m_pScanBlurred->m_nBitmapWidth*m_pScanBlurred->m_nBitmapHeight/256/10;
    if (requiredPixels==0) requiredPixels=1; // special case for a particularly small preview scan

    m_pScanBlurred->CorrectBrightness();
    m_pScanBlurred->MaxContrast(requiredPixels);


    // free memory as soon as it isn't needed
    if (m_pScanVerticalBlurred!=NULL)
    {
        delete m_pScanVerticalBlurred;
        m_pScanVerticalBlurred=NULL;
    }
    if (m_pScanHorizontalBlurred!=NULL)
    {
        delete m_pScanHorizontalBlurred;
        m_pScanHorizontalBlurred=NULL;
    }

    if (m_pScanDoubleBlurred!=NULL)
    {
        delete m_pScanDoubleBlurred;
        m_pScanDoubleBlurred=NULL;
    }

    if (m_pScanTripleBlurred!=NULL)
    {
        delete m_pScanTripleBlurred;
        m_pScanTripleBlurred=NULL;
    }


    m_pScanWithShadows = new C32BitDibWrapper(m_pScanBlurred); // copy scanBlurred

    // eliminate shadows
    m_pScanBlurred->KillShadows(m_pScanTripleEdges, MAXSHADOWSTART,MAXSHADOWPIXEL-2,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,MAXSHADOWSTART,MAXSHADOWPIXEL-1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);

    // compensate for background color
    // the average background color pixel will probably have a smaller edge factor than the average shadow,
    // but will have a larger difference from grey
    // hence to eliminate background color we ignore difference from grey... as accomplished by the (256*3) term

    m_pScanBlurred->KillShadows(m_pScanTripleEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);

    // pure economics... edge pixels are much more likely to be junk
    // so economically, its worth it to risk
    // killing good edge pixels to get rid of the bad
    m_pScanBlurred->EdgeDespeckle();
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // prepare to find chunks

    int *pMap=new int[m_pScanBlurred->m_nBitmapHeight*m_pScanBlurred->m_nBitmapWidth];
    if (pMap)
    {
        done=false;
        weird=false;
        while (done==false) // we may have to repeat FindChunks if we find that we did not eliminate enough pixels and ended up with all pixels being determined to be part of the same region
        {
            done=true;
            numChunks=m_pScanBlurred->FindChunks(pMap); // fills the pMap array with chunks

            if (m_pRegions!=NULL) delete m_pRegions;
            m_pRegions = new CRegionList(numChunks);

            if (m_pRegions)
            {
                m_pRegions->m_nBitmapWidth=m_pScan->m_nBitmapWidth;
                m_pRegions->m_nBitmapHeight=m_pScan->m_nBitmapHeight;

                // now turn the pMap region map into region rectangles
                // it could be argued that this routine should be placed in C32BitDibWrapper
                // but we don't want to make C32BitDibWrapper encompas too much functionality which
                // clearly is directly connected with imagedetection

                pImagePixels=(ULONG *)(m_pScanBlurred->m_pBits); // we want to use 32 bit chunks instead of 8 bit chunks
                pEdgePixels=(ULONG *)(m_pScanEdges->m_pBits);


                position=0;
                for (y=0;y<m_pScan->m_nBitmapHeight;y++)
                {
                    for (x=0;x<m_pScan->m_nBitmapWidth;x++)
                    {
                        if (pMap[position]>0)
                        {
                            m_pRegions->AddPixel(pMap[position]-1, pImagePixels[position],pEdgePixels[position], x, y); // pMap values start at 1, let region values start at 0
                        }                                                // we start pMap at 1 so that 0 can indicate a pixel that is not assigned to any region
                        position++;                                      // we may want to make pMap start at 0 at some later date
                    }
                }

                m_pRegions->m_numRects=numChunks;
                m_pRegions->m_validRects=numChunks;
                // check for invalid regions
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    m_pRegions->checkIfValidRegion(a); // sets m_valid params
                    m_pRegions->m_backgroundColorPixels[a]=m_pScan->PixelsBelowThreshold(m_pScanBlurred,m_pScanEdges,m_pRegions->m_pRects[a]);
                    m_pRegions->RegionType(a); // clasify regions... text or photo
                }


                m_pRegions->CompactDown(m_pRegions->m_validRects);
                if (m_pRegions->m_validRects==0) break; // if there aren't any regions, no sense in proceeding

                unionOperationInLastPass=true;
                while (unionOperationInLastPass==true)
                {
                    unionOperationInLastPass=false;
                    for (a=0;a<m_pRegions->m_numRects;a++)
                    {
                        if (m_pRegions->m_valid[a]==true)
                        {
                            for (b=a+1;b<m_pRegions->m_numRects;b++)
                            {
                                if (m_pRegions->m_valid[b]==true)
                                {
                                    // we are paranoid... we repeatedly check if two regions intersect each other.
                                    if (m_pRegions->CheckIntersect(a,b,0)==true)
                                    {
                                        m_pRegions->UnionRegions(a,b);
                                        m_pRegions->checkIfValidRegion(a, 0); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                        m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                        unionOperationInLastPass=true;
                                    }

                                }
                            }
                        }
                    }
                }

                if (weird==false &&
                    ((m_pRegions->m_pRects[0].right-m_pRegions->m_pRects[0].left)
                     *(m_pRegions->m_pRects[0].bottom-m_pRegions->m_pRects[0].top))
                    >
                    ((m_pScanBlurred->m_nBitmapWidth-DESPECKLE_BORDER_WIDTH*2)*(m_pScanBlurred->m_nBitmapWidth-DESPECKLE_BORDER_WIDTH*2)))
                {
                    weird=true;
                    done=false;

                    // you better not be grey or you are in trouble
                    // some seriously nasty shadow elimination
                    // we will probably eliminate too many good pixels
                    // but at least the poor user will get something more than just finding that the whole screen was selected
                    m_pScanBlurred->KillShadows(m_pScanTripleEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanEdges, 256,MAXSHADOWPIXEL+5,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);


                    m_pScanBlurred->KillShadows(m_pScanDoubleHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanDoubleVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);


                    m_pScanBlurred->EdgeDespeckle();
                    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
                    //          m_pScanBlurred->EdgeDespeckle();
                    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

                }
            }
        }

        if (m_pRegions)
        {
            m_pRegions->CompactDown(m_pRegions->m_validRects); // compact down the CRegionList so that it nolonger includes invalidated regions

            // we store an array indicating which pairs of regions have walls between them
            // used for unioning together large text regions... for example, scanning
            // in two pages with a shadow between them

            pWall=new char[m_pRegions->m_numRects*m_pRegions->m_numRects];
            if (pWall)
            {
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    if (m_pRegions->m_valid[a]==true)
                    {
                        for (b=a+1;b<m_pRegions->m_numRects;b++)
                        {
                            if (m_pRegions->m_valid[b]==true)
                            {
                                pWall[a*m_pRegions->m_numRects+b]=UNKNOWN;
                            }
                        }
                    }
                }

                // key ideas.  we need to (potentially) merge a large number of fragmented text regions and we need to avoid merging large photo regions
                // we also want to keep memory usage within reason...so we should delete stuff after we know we will nolonger use it.
                if (m_pScanHorizontalEdges!=NULL)
                {
                    delete m_pScanHorizontalEdges;
                    m_pScanHorizontalEdges=NULL;
                }
                if (m_pScanVerticalEdges!=NULL)
                {
                    delete m_pScanVerticalEdges;
                    m_pScanVerticalEdges=NULL;
                }

                for (border=0;border<MAXBORDER;border++) // loop through each possible border with consecutivelly
                {
                    unionOperationInLastPass=true;
                    while (unionOperationInLastPass==true)
                    {
                        unionOperationInLastPass=false;
                        for (a=0;a<m_pRegions->m_numRects;a++)
                        {
                            if (m_pRegions->m_valid[a]==true)
                            {
                                for (b=a+1;b<m_pRegions->m_numRects;b++)
                                {
                                    if (m_pRegions->m_valid[b]==true)
                                    {
                                        // we are paranoid... we repeatedly check if two regions intersect each other.
                                        if (m_pRegions->CheckIntersect(a,b,0)==true)
                                        {
                                            m_pRegions->UnionRegions(a,b);
                                            m_pRegions->checkIfValidRegion(a, 0); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                            m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                            for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                if (m_pRegions->m_valid[i]==TRUE)
                                                    pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                            for (i=0;i<a;i++)
                                                if (m_pRegions->m_valid[i]==TRUE)
                                                    pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;


                                            unionOperationInLastPass=true;
                                        }

                                        // now the complex part.  check for intersections after growing borders around regions
                                        // but only if we don't have two photo regions
                                        if (MERGE_REGIONS)
                                        {
                                            if ((m_pRegions->m_type[a]&TEXT_REGION && m_pRegions->m_type[b]&TEXT_REGION)
                                                ||(((m_pRegions->m_type[a]|m_pRegions->m_type[b])&MERGABLE_WITH_PHOTOGRAPH)&&border<MERGABLE_WITH_PHOTOGRAPH)
                                                ||(border<MAX_MERGE_PHOTO_REGIONS && (m_pRegions->Size(a)<MAX_MERGABLE_PHOTOGRAPH_SIZE || m_pRegions->Size(b)<MAX_MERGABLE_PHOTOGRAPH_SIZE)))
                                            {
                                                if (m_pRegions->CheckIntersect(a,b,border)==true)
                                                {
                                                    if (border<MERGABLE_WITHOUT_COLLISIONDETECTION)
                                                    {
                                                        m_pRegions->UnionRegions(a,b);
                                                        m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                                        m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                                        for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                            if (m_pRegions->m_valid[i]==TRUE)
                                                                pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                                        for (i=0;i<a;i++)
                                                            if (m_pRegions->m_valid[i]==TRUE)
                                                                pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;


                                                        unionOperationInLastPass=true;
                                                    }

                                                    else
                                                    {
                                                        if (pWall[a*m_pRegions->m_numRects+b]==UNKNOWN)
                                                            pWall[a*m_pRegions->m_numRects+b]=CollisionDetection(m_pRegions->m_pRects[a],m_pRegions->m_pRects[b],m_pScanWithShadows);

                                                        if (pWall[a*m_pRegions->m_numRects+b]==TRUE || (m_pRegions->m_type[a]&PHOTOGRAPH_REGION) || (m_pRegions->m_type[b]&PHOTOGRAPH_REGION))
                                                        {
                                                            if (!m_pRegions->MergerIntersectsPhoto(a,b))
                                                            {
                                                                m_pRegions->UnionRegions(a,b);
                                                                m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                                                m_pRegions->RegionType(a); // figure out what type of region the combined region should be
                                                                unionOperationInLastPass=true;
                                                                // region a has changed so reset collision flags

                                                                for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                                    if (m_pRegions->m_valid[i]==TRUE)
                                                                        pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                                                for (i=0;i<a;i++)
                                                                    if (m_pRegions->m_valid[i]==TRUE)
                                                                        pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;

                                                                if (border>=MERGABLE_WITHOUT_COLLISIONDETECTION) border=MERGABLE_WITHOUT_COLLISIONDETECTION-2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // we have stricter requirements for region validity after we have done the border search.
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    m_pRegions->checkIfValidRegion(a,DONE_WITH_BORDER_CHECKING);
                }

                //  m_pScanBlurred->ColorChunks(pMap); // for debugging purposes... so we know where exactly chunks are
                m_pRegions->CompactDown(m_pRegions->m_validRects+10); // we don't want to hand the user a list which includes invalidated regions

                //
                // free pWall
                //
                delete[] pWall;
            }
        }
        delete[] pMap;
    }
    return(TRUE);
}

bool CRegionDetector::CollisionDetection(RECT r1, RECT r2, C32BitDibWrapper* pImage)
{
    // use tracer lines to determine if there is an obstical between the two regions... be it possibly a photograph region or a speckle which we were wise enough to delete
    // we should cache collision results, but we are lazy and compared with the time taken by all of the filters which edited every single bitmap pixel, time spent here is trivial
    // first we need to determine how the regions are located with respect to each other
    // we do three tracer rays (top edge to top edge, median to median, and bottom to bottom)
    // throw out the edge with the highest collsion value... maybe we were unlucky and hit a stray speckle
    //
    // Diagram
    //  .____ 253
    //  ._
    //  . \*
    //   \  \ 43531 <-- hit speckle, throw out value
    //    \
    //     \ 215
    //  average intensity value: aprox 230 so its safe to merge the two regions
    ULONG resistance[3];
    //  ULONG totalResistance;
    ULONG maxResistance,minResistance,i;

    if (r1.right < r2.left)  // region 1 is to the left of region 2
    {
        resistance[0]=pImage->Line(r1.right,r1.top,r2.left,r2.top);
        resistance[1]=pImage->Line(r1.right,r1.bottom,r2.left,r2.bottom);
        resistance[2]=pImage->Line(r1.right,(r1.bottom+r1.top)/2,r2.left,(r2.bottom+r2.top)/2);
    }
    else
        if (r2.right < r1.left)  //region 2 is to the left of region 1
    {
        resistance[0]=pImage->Line(r2.right,r2.top,r1.left,r1.top);
        resistance[1]=pImage->Line(r2.right,r2.bottom,r1.left,r1.bottom);
        resistance[2]=pImage->Line(r2.right,(r2.bottom+r2.top)/2,r1.left,(r1.bottom+r1.top)/2);
    }
    else
        if (r1.bottom < r2.top)  // region 1 is above region 2
    {
        resistance[0]=pImage->Line(r1.right,r1.bottom,r2.right,r2.top);
        resistance[1]=pImage->Line(r1.left,r1.bottom,r2.left,r2.top);
        resistance[2]=pImage->Line((r1.left+r1.right)/2,r1.bottom,(r2.left+r2.right)/2,r2.top);
    }
    else
        if (r2.bottom < r1.top)  // region 2 is above region 1
    {
        resistance[0]=pImage->Line(r2.right,r2.bottom,r1.right,r1.top);
        resistance[1]=pImage->Line(r2.left,r2.bottom,r1.left,r1.top);
        resistance[2]=pImage->Line((r2.left+r2.right)/2,r2.bottom,(r1.left+r1.right)/2,r1.top);
    }

    // we used to have a more complex scheme where we took the average of the lower two values
    // hence some of the following code is legacy code from that experiment
    maxResistance=0;
    minResistance=MAX_RESISTANCE_ALLOWED_TO_UNION+1;
    for (i=0;i<3;i++)
    {
        if (resistance[i]>maxResistance) maxResistance=resistance[i];
        if (resistance[i]<minResistance) minResistance=resistance[i];
    }

    //totalResistance=resistance[0]+resistance[1]+resistance[2]-maxResistance;
    if (minResistance>MAX_RESISTANCE_ALLOWED_TO_UNION)
    {
        return(false);
    }
    else
    {
        return(true);
    }
}




// CRegionList member functions:

CRegionList::CRegionList(int num)
{
    int i;
    m_numRects=0;
    m_maxRects=num;
    m_nBitmapWidth=0;
    m_nBitmapHeight=0;
    m_pRects = new RECT[num];
    m_pixelsFilled = new ULONG[num];
    m_valid= new bool[num];
    m_type = new int[num];
    m_totalColored= new ULONG[num];
    m_totalIntensity= new ULONG[num];
    m_totalEdge= new ULONG[num];
    m_backgroundColorPixels = new int[num];
    //
    // Make sure all of the memory allocations succeeded
    //
    if (m_pRects && m_pixelsFilled && m_valid && m_type && m_totalColored && m_totalIntensity && m_totalEdge && m_backgroundColorPixels)
    {
        for (i=0;i<num;i++)
        {
            m_pixelsFilled[i]=0;
            m_totalColored[i]=0;
            m_totalIntensity[i]=0;
            m_totalEdge[i]=0;
            m_valid[i]=true;
            m_backgroundColorPixels[i] = -1;
            m_type[i]=PHOTOGRAPH_REGION;
        }
    }
    else
    {
        //
        // If all of the memory allocations didn't succeed, free all allocated memory
        //
        delete[] m_pRects;
        delete[] m_pixelsFilled;
        delete[] m_valid;
        delete[] m_type;
        delete[] m_totalColored;
        delete[] m_totalIntensity;
        delete[] m_totalEdge;
        delete[] m_backgroundColorPixels;
        m_pRects = NULL;
        m_pixelsFilled = NULL;
        m_valid = NULL;
        m_type = NULL;
        m_totalColored = NULL;
        m_totalIntensity = NULL;
        m_totalEdge = NULL;
        m_backgroundColorPixels = NULL;
    }
}


int CRegionList::UnionIntersectingRegions()
{
    bool unionOperationInLastPass;
    int numUnionOperations;
    int a,b;
    numUnionOperations=0;
    unionOperationInLastPass=true;
    while (unionOperationInLastPass==true)
    {
        unionOperationInLastPass=false;
        for (a=0;a<m_numRects;a++)
        {
            if (m_valid[a]==true)
                for (b=a+1;b<m_numRects;b++)
                    if (m_valid[b]==true)
                    {
                        // we are paranoid... we repeatedly check if two regions intersect each other.
                        if (CheckIntersect(a,b,0)==true)
                        {
                            UnionRegions(a,b);
                            unionOperationInLastPass=true;
                            numUnionOperations++;
                        }

                    }
        }
    }
    return(numUnionOperations);
}


RECT CRegionList::unionAll()
{
    int i,j;

    for (i=0;i<m_numRects;i++)
    {
        if (m_valid[i]==true)
        {
            for (j=i+1;j<m_numRects;j++)
            {
                if (m_valid[j]==true)
                {
                    UnionRegions(i,j);
                }

            }
            return(m_pRects[i]);
        }
    }
    RECT invalidRect;
    invalidRect.left=0;invalidRect.top=0;invalidRect.right=0;invalidRect.bottom=0;
    return(invalidRect);
}

RECT CRegionList::nthRegion(int num)
{
    int i;
    int n;

    for (i=0,n=0;i<m_maxRects;i++)
    {
        if (m_valid[i]==true)
        {
            if (num==n) return(m_pRects[i]);
            n++;
        }
    }
    RECT invalidRect;
    invalidRect.left=0;invalidRect.top=0;invalidRect.right=0;invalidRect.bottom=0;
    return(invalidRect);
}

int CRegionList::RegionType(int region)
{

    if (ClassifyRegion(region)>TEXTPHOTO_THRESHOLD)
    {
        m_type[region]=PHOTOGRAPH_REGION; // regions which we are very confident with
    }
    else
    {
        m_type[region]=TEXT_REGION; /// regions we don't have a darn clue about
        if (largeRegion(region)==true) m_type[region]=TEXT_REGION|MERGABLE_WITH_PHOTOGRAPH;
    }
    return(m_type[region]);
}


bool CRegionList::largeRegion(int region)
{
    int width, height, size;
    width=(m_pRects[region].right-m_pRects[region].left);
    height=(m_pRects[region].bottom-m_pRects[region].top);
    size=width*height;
    if (size>LARGEREGION_THRESHOLD) return(true);
    return(false);
}

double CRegionList::ClassifyRegion(int region) // determine if the region is a text or a graphics region
{   // higher numbers are photo regions
    // low numbers are text regions
    // this function is not been written for speed
    // its been written so that it is still almost understandable
    // concept: use a bunch of tests that are accurate about 75% of the time
    // to get a test that is accurate 99.9% of the time
    double edgeFactor; // shadows and stray smudges should have real low edge factors... but
    // dots should have high edge factors
    double intensityFactor; // if a region has a very high intensity factor, forget about worrying if it is valid or not
    double colorFactor; // a region with a lot of color is unlikely to be a stray speckle
    double aspectRatioFactor;
    double width,height;
    double size;
    double textRegionStylePixelsFactor;
    double classificationValue;
    width=(double)(m_pRects[region].right-m_pRects[region].left)+.01; // avoid divide by zero
    height=(double)(m_pRects[region].bottom-m_pRects[region].top)+.01; // avoid divide by zero
    size=width*height;
    if (width>height) aspectRatioFactor=height/width;
    else aspectRatioFactor=width/height;
    //if(m_pixelsFilled<MINREGIONPIXELS) sizeFactor=-100;
    edgeFactor = (double)m_totalEdge[region]/(double)m_pixelsFilled[region]+.01; // avoid divide by zero
    colorFactor= ((double)m_totalColored[region]/(double)m_pixelsFilled[region]);
    colorFactor=(colorFactor+110)/2; // otherwise we kill all black and white photos
    intensityFactor = (double)m_totalIntensity[region]/(double)m_pixelsFilled[region];

    textRegionStylePixelsFactor=(double)m_backgroundColorPixels[region]/size*100;
    if (textRegionStylePixelsFactor<2) textRegionStylePixelsFactor=2;

    classificationValue=colorFactor/intensityFactor/edgeFactor*aspectRatioFactor/textRegionStylePixelsFactor/textRegionStylePixelsFactor*30000;  // square text region factor because its the most accurate test we have so we don't want some other tests distorting its results

    // get rid of annoying stray speckles which the computer thinks are photographs
    /*      if(classificationValue>=MIN_BORDERLINE_TEXTPHOTO && classificationValue <=MAX_BORDERLINE_TEXTPHOTO)
            {
                classificationValue*=size/REASONABLE_PHOTO_SIZE; // big images are usually pictures.. and big images which are text blocks should have had very low color vals
                // add more tests here
                // potentially add more time intensive tests such as count num colors
            }*/

    //          classificationValue=textRegionStylePixelsFactor; // debug
    return(classificationValue);
}

bool CRegionList::checkIfValidRegion(int region, int border) // syncs whether a region is valid or not
{
    if (m_valid[region]==true) // ignore already invalidated regions
    {
        m_valid[region]=ValidRegion(region, border);
        if (m_valid[region]==false) m_validRects--;
    }
    return(m_valid[region]);
}

bool CRegionList::ValidRegion(int region, int border) // determines if a region is likely a worthless speck of dust or shadow or if we should care about the region
{
    double aspectRatioFactor;
    double width,height;
    double size;
    int edgePenaltyFactor;
    // check if the region crosses the EDGE_PENALTY_WIDTH outer pixels of the image
    width=(double)(m_pRects[region].right-m_pRects[region].left)+.01; // just to be safe to avoid divide by zero
    height=(double)(m_pRects[region].bottom-m_pRects[region].top)+.01; // just to be safe to avoid divide by zero

    edgePenaltyFactor=1;
    // disable penalty factor calculations
    /*        if(    m_pRects[region].left<EDGE_PENALTY_WIDTH
                || m_pRects[region].top<EDGE_PENALTY_WIDTH
                || m_nBitmapHeight-m_pRects[region].bottom<EDGE_PENALTY_WIDTH
                || m_nBitmapWidth-m_pRects[region].right<EDGE_PENALTY_WIDTH)
            {
                if(border>MAX_MERGE_DIFFERENT_REGIONS) edgePenaltyFactor=EDGE_PENALTY_FACTOR;
                else edgePenaltyFactor=CLOSE_TO_EDGE_PENALTY_FACTOR;
            }
            else
            if(    m_pRects[region].left<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_pRects[region].top<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_nBitmapHeight-m_pRects[region].bottom<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_nBitmapWidth-m_pRects[region].right<CLOSE_TO_EDGE_PENALTY_WIDTH)
            {
                edgePenaltyFactor=CLOSE_TO_EDGE_PENALTY_FACTOR;
            }*/

    if (border<MAX_NO_EDGE_PIXEL_REGION_PENALTY) edgePenaltyFactor=1;
    if (border>MAX_MERGE_DIFFERENT_REGIONS) edgePenaltyFactor=edgePenaltyFactor*2;
    //        if(border>BORDER_EXTREME_EDGE_PIXEL_REGION_PENALTY) edgePenaltyFactor=edgePenaltyFactor*2;



    size=width*height; // the problem child text regions are small ones... so we use the size of the image as a factor
    if (width>height) aspectRatioFactor=height/width;
    else aspectRatioFactor=width/height;

    // its too small
    if ((int)m_pixelsFilled[region]<MINREGIONPIXELS*edgePenaltyFactor) return(false);
    if (size<MINSIZE*edgePenaltyFactor) return(false);

    if (border == DONE_WITH_BORDER_CHECKING)
    {
        if (size<MIN_FINAL_REGION_SIZE*edgePenaltyFactor) return(false);
    }

    // its too narrow
    if (width<MINWIDTH*edgePenaltyFactor || height<MINWIDTH*edgePenaltyFactor) return(false);

    if ((1/aspectRatioFactor)*edgePenaltyFactor>MAXREGIONRATIO && (width*edgePenaltyFactor<IGNORE_RATIO_WIDTH || height<IGNORE_RATIO_WIDTH)) return(false);

    return(true);
}

bool CRegionList::InsideRegion(int region, int x, int y, int border) // border is the amount of border space to place around the outside of the region
{
    if (x>=(m_pRects[region].left-border)
        &&  x<=(m_pRects[region].right+border)
        &&  y>=(m_pRects[region].top-border)
        &&  y<=(m_pRects[region].bottom+border))
        return(true);
    return(false);
}

void CRegionList::AddPixel(int region, ULONG pixel,ULONG edge, int x, int y)
{
    if (m_pixelsFilled[region]!=0)
    {
        if (x<m_pRects[region].left) m_pRects[region].left=x;
        if (x>m_pRects[region].right) m_pRects[region].right=x;
        if (y<m_pRects[region].top) m_pRects[region].top=y;
        if (y>m_pRects[region].bottom) m_pRects[region].bottom=y;
    }
    else // init region
    {
        m_pixelsFilled[region]=0;
        m_totalColored[region]=0;
        m_totalIntensity[region]=0;
        m_pRects[region].left=x;
        m_pRects[region].right=x;
        m_pRects[region].top=y;
        m_pRects[region].bottom=y;
        m_numRects++;
        m_validRects++;
    }
    m_pixelsFilled[region]++;
    m_totalColored[region]+=DifferenceFromGray(pixel);
    m_totalIntensity[region]+=Intensity(pixel);
    m_totalEdge[region]+=Intensity(edge);

}

// unions two regions together... region b is invalidated
bool CRegionList::UnionRegions(int a, int b)
{
    if (m_valid[a]!=true || m_valid[b]!=true) return(false); // the user tried to union an invalidated region
    m_valid[b]=false;
    m_pRects[a].left=MIN(m_pRects[a].left,m_pRects[b].left);
    m_pRects[a].top=MIN(m_pRects[a].top,m_pRects[b].top);
    m_pRects[a].right=MAX(m_pRects[a].right,m_pRects[b].right);
    m_pRects[a].bottom=MAX(m_pRects[a].bottom,m_pRects[b].bottom);
    m_pixelsFilled[a]+=m_pixelsFilled[b];
    m_totalColored[a]+=m_totalColored[b];
    m_totalIntensity[a]+=m_totalIntensity[b];
    m_totalEdge[a]+=m_totalEdge[b];
    m_backgroundColorPixels[a]+=m_backgroundColorPixels[b];

    m_validRects--;
    return(true);
}

RECT CRegionList::UnionRects(RECT a, RECT b)
{
    RECT result;
    result.left=MIN(a.left,b.left);
    result.top=MIN(a.top,b.top);
    result.right=MAX(a.right,b.right);
    result.bottom=MAX(a.bottom,b.bottom);
    return(result);
}

bool CRegionList::MergerIntersectsPhoto(int a, int b) // if we merge these two regions, will we also be merging with a photo region (a taboo)
{
    RECT mergedRect;
    int i;
    mergedRect=UnionRects(m_pRects[a],m_pRects[b]);
    for (i=0;i<m_numRects;i++)
        if (m_valid[i]==true && (m_type[i]&PHOTOGRAPH_REGION) && a!=i && b!=i)
        {
            if (CheckIntersect(mergedRect,m_pRects[i])) return(true);
        }
    return(false);
}

// see InsideRegion for an explaination of what border is
bool CRegionList::CheckIntersect(int a, int b, int border) // do regions a and b intersect?
{
    return(CheckIntersect(m_pRects[a],m_pRects[b],border));
}

bool CRegionList::CheckIntersect(RECT r1, RECT r2, int border) // do regions a and b intersect?
{
    RECT intersect;
    // grow r1 by border
    // note: it shouldn't make any difference which rectangle we choose to grow
    r1.left-=border;
    r1.right+=border;
    r1.top-=border;
    r1.bottom+=border;

    intersect = Intersect(r1,r2);
    if (intersect.left<intersect.right && intersect.bottom>intersect.top)
        return(true);
    else
        return(false);
    /* // old buggy code for checking if two regions intersected

            if(InsideRegion(r1,r2.left,r2.top,border)    ||  // check if any of the four corner pixels are inside the other region
               InsideRegion(r1,r2.left,r2.bottom,border) ||
               InsideRegion(r1,r2.right,r2.top,border)   ||  // b inside a
               InsideRegion(r1,r2.right,r2.bottom,border)||

               InsideRegion(r2,r1.left,r1.top,border)    ||  // a inside b
               InsideRegion(r2,r1.left,r1.bottom,border) ||
               InsideRegion(r2,r1.right,r1.top,border)   ||
               InsideRegion(r2,r1.right,r1.bottom,border)
               )
                return true;
            else
                return false;*/
}

RECT CRegionList::Intersect(RECT r1, RECT r2)
{
    RECT intersect;
    intersect.left=MAX(r1.left,r2.left);
    intersect.right=MIN(r1.right,r2.right);
    intersect.top=MAX(r1.top,r2.top);
    intersect.bottom=MIN(r1.bottom,r2.bottom);
    if (intersect.left<=intersect.right && intersect.top<=intersect.bottom)
        return(intersect);
    else
    {
        intersect.left=-1;
        intersect.right=-1;
        intersect.top=-1;
        intersect.bottom=-1;
        return(intersect);
    }
}

bool CRegionList::InsideRegion(RECT region, int x, int y, int border) // border is the amount of border space to place around the outside of the region
{
    if (x>=(region.left-border)
        &&  x<=(region.right+border)
        &&  y>=(region.top-border)
        &&  y<=(region.bottom+border))
        return(true);
    return(false);
}

// compact down ignores all other info aside from rect location
// leads to faster access
void CRegionList::CompactDown(int size)
{
    int i;
    int j = 0;
    RECT * compactedRects = new RECT[size];
    bool * compactedValid = new bool[size];
    int * compactedType = new int[size];
    int * compactedBackgroundColorPixels = new int[size];
    ULONG * compactedPixelsFilled = new ULONG[size]; // how many of the pixels in the region were actually selected?
    ULONG * compactedTotalColored = new ULONG[size]; // accumulated color difference indicator
    ULONG * compactedTotalIntensity = new ULONG[size]; // accumulated intensity indicator
    ULONG * compactedTotalEdge = new ULONG[size]; // accumulated edge values

    //
    // Make sure all of the memory allocations succeeded
    //
    if (compactedRects && compactedValid && compactedType && compactedBackgroundColorPixels && compactedPixelsFilled && compactedTotalColored && compactedTotalIntensity && compactedTotalEdge)
    {
        for (i=0;i<m_numRects;i++)
        {
            if (m_valid[i])
            {
                compactedRects[j]=m_pRects[i];
                compactedValid[j]=true;
                compactedType[j]=m_type[i];
                compactedPixelsFilled[j]=m_pixelsFilled[i];
                compactedTotalColored[j]=m_totalColored[i];
                compactedTotalIntensity[j]=m_totalIntensity[i];
                compactedTotalEdge[j]=m_totalEdge[i];
                compactedBackgroundColorPixels[j]=m_backgroundColorPixels[i];
                j++;
            }
        }

        // fill out the rest of the list
        for (i=m_validRects;i<size;i++)
        {
            compactedValid[i]=false;
        }

        delete m_pRects;
        delete m_valid;
        delete m_type;
        delete m_pixelsFilled;
        delete m_totalColored;
        delete m_totalIntensity;
        delete m_totalEdge;
        delete m_backgroundColorPixels;

        m_pRects=compactedRects;
        m_valid=compactedValid;
        m_type=compactedType;
        m_pixelsFilled=compactedPixelsFilled;
        m_totalColored=compactedTotalColored;
        m_totalIntensity=compactedTotalIntensity;
        m_totalEdge=compactedTotalEdge;
        m_backgroundColorPixels=compactedBackgroundColorPixels;

        m_numRects=size;
    }
    else
    {
        //
        // Otherwise, just release all of the memory we allocated
        //
        delete[] compactedRects;
        delete[] compactedValid;
        delete[] compactedType;
        delete[] compactedBackgroundColorPixels;
        delete[] compactedPixelsFilled;
        delete[] compactedTotalColored;
        delete[] compactedTotalIntensity;
        delete[] compactedTotalEdge;
    }
    // we could delete all of the other region list info right here
}

// dibs are stored upside down from normal screen coords
// so apps will often want to flip the bitmap first
void CRegionList::FlipVertically()
{
    int i;
    int temp;
    for (i=0;i<m_numRects;i++)
    {
        temp=m_nBitmapHeight-m_pRects[i].top-1;
        m_pRects[i].top=m_nBitmapHeight-m_pRects[i].bottom-1;
        m_pRects[i].bottom=temp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\rescale.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RESCALE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/15/1998
 *
 *  DESCRIPTION: Scale HBITMAPs using StretchBlt
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * ScaleImage: Scale hBmpSrc and store the scaled dib in hBmpTgt
 */
HRESULT ScaleImage( HDC hDC, HBITMAP hBmpSrc, HBITMAP &hBmpTgt, const SIZE &sizeTgt )
{
    WIA_PUSH_FUNCTION((TEXT("ScaleImage( sizeTgt = [%d,%d] )"), sizeTgt.cx, sizeTgt.cy ));
    BITMAPINFO bmi;
    BITMAP bm;
    HRESULT hr = E_FAIL;
    HBITMAP hBmp = NULL;

    hBmpTgt = NULL;

    GetObject( hBmpSrc, sizeof(BITMAP), &bm );

    ZeroMemory( &bmi, sizeof(BITMAPINFO) );
    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth           = sizeTgt.cx;
    bmi.bmiHeader.biHeight          = sizeTgt.cy;
    bmi.bmiHeader.biPlanes          = 1;
    bmi.bmiHeader.biBitCount        = 24;
    bmi.bmiHeader.biCompression     = BI_RGB;

    HPALETTE hHalftonePalette = CreateHalftonePalette(hDC);
    if (hHalftonePalette)
    {
        PBYTE pBitmapData = NULL;
        hBmp = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
        if (hBmp)
        {
            // Create the source dc
            HDC hMemoryDC = CreateCompatibleDC( hDC );
            if (hMemoryDC)
            {
                HPALETTE hOldMemDCPalette = SelectPalette( hMemoryDC, hHalftonePalette , 0 );
                RealizePalette( hMemoryDC );
                SetBrushOrgEx( hMemoryDC, 0,0, NULL );
                HBITMAP hOldMemDCBitmap = (HBITMAP)SelectObject( hMemoryDC, hBmpSrc );

                // Create the target dc
                HDC hStretchDC = CreateCompatibleDC( hDC );
                if (hStretchDC)
                {
                    HPALETTE hOldStretchDCPalette = SelectPalette( hStretchDC, hHalftonePalette , 0 );
                    RealizePalette( hStretchDC );
                    SetBrushOrgEx( hStretchDC, 0,0, NULL );
                    HBITMAP hOldStretchDCBitmap = (HBITMAP)SelectObject( hStretchDC, hBmp );
                    INT nOldStretchMode = SetStretchBltMode( hStretchDC, STRETCH_HALFTONE );

                    SIZE sizeScaled;
                    // Width is constraining factor
                    if (sizeTgt.cy*bm.bmWidth > sizeTgt.cx*bm.bmHeight)
                    {
                        sizeScaled.cx = sizeTgt.cx;
                        sizeScaled.cy = WiaUiUtil::MulDivNoRound(bm.bmHeight,sizeTgt.cx,bm.bmWidth);
                    }
                    // Height is constraining factor
                    else
                    {
                        sizeScaled.cx = WiaUiUtil::MulDivNoRound(bm.bmWidth,sizeTgt.cy,bm.bmHeight);
                        sizeScaled.cy = sizeTgt.cy;
                    }
                    // Fill the background
                    RECT rc;
                    rc.left = rc.top = 0;
                    rc.right = sizeTgt.cx;
                    rc.bottom = sizeTgt.cy;
                    FillRect( hStretchDC, &rc, GetSysColorBrush(COLOR_WINDOW) );

                    // Paint the image
                    StretchBlt( hStretchDC, (sizeTgt.cx - sizeScaled.cx) / 2, (sizeTgt.cy - sizeScaled.cy) / 2, sizeScaled.cx, sizeScaled.cy, hMemoryDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );

                    // Everything is OK
                    hBmpTgt = hBmp;
                    hr = S_OK;

                    // Restore the dc's state and delete it
                    SetStretchBltMode( hStretchDC, nOldStretchMode );
                    SelectObject( hStretchDC, hOldStretchDCBitmap );
                    SelectPalette( hStretchDC, hOldStretchDCPalette , 0 );
                    DeleteDC( hStretchDC );
                }
                // Restore the dc's state
                SelectObject( hMemoryDC, hOldMemDCBitmap );
                SelectPalette( hMemoryDC, hOldMemDCPalette , 0 );
                DeleteDC( hMemoryDC );
            }
        }
        if (hHalftonePalette)
        {
            DeleteObject( hHalftonePalette );
        }
    }
    // Clean up the new bitmap if there was an error
    if (!SUCCEEDED(hr) && hBmp)
        DeleteObject( hBmp );

    WIA_TRACE((TEXT("hBmpTgt = %p")));
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\rescale.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RESCALE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/15/1998
 *
 *  DESCRIPTION: Scale HBITMAPs using StretchBlt
 *
 *******************************************************************************/
#ifndef _RESCALE_H_INCLUDED
#define _RESCALE_H_INCLUDED

#include <windows.h>

HRESULT ScaleImage( HDC hDC, HBITMAP hBmpSrc, HBITMAP &hBmpTgt, const SIZE &sizeTgt );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\pshelper.h ===
#ifndef __PSHELPER_H_INCLUDED
#define __PSHELPER_H_INCLUDED

#include <windows.h>
#include "simstr.h"
#include "simarray.h"

namespace PropStorageHelpers
{
    struct CPropertyRange
    {
        LONG nMin;
        LONG nMax;
        LONG nStep;
    };

    class CPropertyId
    {
    private:
        CSimpleStringWide m_strPropId;
        PROPID m_nPropId;
        bool m_bIsStringPropId;
    public:
        CPropertyId(void);
        CPropertyId( const CSimpleStringWide &strPropId );
        CPropertyId( PROPID propId );
        CPropertyId( const CPropertyId &other );
        ~CPropertyId(void);
        CPropertyId &operator=( const CPropertyId &other );
        CSimpleStringWide PropIdString(void) const;
        PROPID PropIdNumber(void) const;
        bool IsString(void) const;
    };

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleStringWide &strPropertyValue );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, GUID &guidValue );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nValue );

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar, PROPID nNameFirst=2 );
    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG nValue, PROPID nNameFirst=2 );
    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, const GUID &guidValue, PROPID nNameFirst=2 );

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags, PROPVARIANT &pvAttributes );
    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pvAttributes );
    bool GetPropertyAccessFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags );
    bool GetPropertyRange( IUnknown *pIUnknown, const CPropertyId &propertyName, CPropertyRange &propertyRange );
    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<LONG> &aProp );
    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<GUID> &aProp );
    bool GetPropertyFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nFlags );
    bool IsReadOnlyProperty( IUnknown *pIUnknown, const CPropertyId &propertyName );
}

#endif //__PSHELPER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\pshelper.cpp ===
#include "precomp.h"
#pragma hdrstop

#if defined(DBG)

WIA_PROPID_TO_NAME g_wiaPropIdToName[] =
{
    { WIA_DIP_DEV_ID, WIA_DIP_DEV_ID_STR },
    { WIA_DIP_VEND_DESC, WIA_DIP_VEND_DESC_STR },
    { WIA_DIP_DEV_DESC, WIA_DIP_DEV_DESC_STR },
    { WIA_DIP_DEV_TYPE, WIA_DIP_DEV_TYPE_STR },
    { WIA_DIP_PORT_NAME, WIA_DIP_PORT_NAME_STR },
    { WIA_DIP_DEV_NAME, WIA_DIP_DEV_NAME_STR },
    { WIA_DIP_SERVER_NAME, WIA_DIP_SERVER_NAME_STR },
    { WIA_DIP_REMOTE_DEV_ID, WIA_DIP_REMOTE_DEV_ID_STR },
    { WIA_DIP_UI_CLSID, WIA_DIP_UI_CLSID_STR },
    { WIA_DIP_HW_CONFIG, WIA_DIP_HW_CONFIG_STR },
    { WIA_DIP_BAUDRATE, WIA_DIP_BAUDRATE_STR },
    { WIA_DIP_STI_GEN_CAPABILITIES, WIA_DIP_STI_GEN_CAPABILITIES_STR },
    { WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR },
    { WIA_DPA_CONNECT_STATUS, WIA_DPA_CONNECT_STATUS_STR },
    { WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR },
    { WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR },
    { WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR },
    { WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR },
    { WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR },
    { WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR },
    { WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR },
    { WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR },
    { WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR },
    { WIA_DPC_FOCUS_MANUAL_DIST, WIA_DPC_FOCUS_MANUAL_DIST_STR },
    { WIA_DPC_ZOOM_POSITION, WIA_DPC_ZOOM_POSITION_STR },
    { WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR },
    { WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR },
    { WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR },
    { WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR },
    { WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR },
    { WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR },
    { WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR },
    { WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR },
    { WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR },
    { WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR },
    { WIA_DPC_DIMENSION, WIA_DPC_DIMENSION_STR },
    { WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR },
    { WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR },
    { WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR },
    { WIA_DPC_TIMELAPSE_NUMBER, WIA_DPC_TIMELAPSE_NUMBER_STR },
    { WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR },
    { WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR },
    { WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR },
    { WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR },
    { WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR },
    { WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR },
    { WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR },
    { WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR },
    { WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR },
    { WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR },
    { WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR },
    { WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR },
    { WIA_DPC_RGB_GAIN, WIA_DPC_RGB_GAIN_STR },
    { WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR },
    { WIA_DPC_UPLOAD_URL, WIA_DPC_UPLOAD_URL_STR },
    { WIA_DPC_ARTIST, WIA_DPC_ARTIST_STR },
    { WIA_DPC_COPYRIGHT_INFO, WIA_DPC_COPYRIGHT_INFO_STR },
    { WIA_DPS_HORIZONTAL_BED_SIZE, WIA_DPS_HORIZONTAL_BED_SIZE_STR },
    { WIA_DPS_VERTICAL_BED_SIZE, WIA_DPS_VERTICAL_BED_SIZE_STR },
    { WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_VERTICAL_SHEET_FEED_SIZE, WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_SHEET_FEEDER_REGISTRATION, WIA_DPS_SHEET_FEEDER_REGISTRATION_STR },
    { WIA_DPS_HORIZONTAL_BED_REGISTRATION, WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR },
    { WIA_DPS_VERTICAL_BED_REGISTRATION, WIA_DPS_VERTICAL_BED_REGISTRATION_STR },
    { WIA_DPS_PLATEN_COLOR, WIA_DPS_PLATEN_COLOR_STR },
    { WIA_DPS_PAD_COLOR, WIA_DPS_PAD_COLOR_STR },
    { WIA_DPS_FILTER_SELECT, WIA_DPS_FILTER_SELECT_STR },
    { WIA_DPS_DITHER_SELECT, WIA_DPS_DITHER_SELECT_STR },
    { WIA_DPS_DITHER_PATTERN_DATA, WIA_DPS_DITHER_PATTERN_DATA_STR },
    { WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES, WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR },
    { WIA_DPS_DOCUMENT_HANDLING_STATUS, WIA_DPS_DOCUMENT_HANDLING_STATUS_STR },
    { WIA_DPS_DOCUMENT_HANDLING_SELECT, WIA_DPS_DOCUMENT_HANDLING_SELECT_STR },
    { WIA_DPS_DOCUMENT_HANDLING_CAPACITY, WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR },
    { WIA_DPS_OPTICAL_XRES, WIA_DPS_OPTICAL_XRES_STR },
    { WIA_DPS_OPTICAL_YRES, WIA_DPS_OPTICAL_YRES_STR },
    { WIA_DPS_ENDORSER_CHARACTERS, WIA_DPS_ENDORSER_CHARACTERS_STR },
    { WIA_DPS_ENDORSER_STRING, WIA_DPS_ENDORSER_STRING_STR },
    { WIA_DPS_SCAN_AHEAD_PAGES, WIA_DPS_SCAN_AHEAD_PAGES_STR },
    { WIA_DPS_MAX_SCAN_TIME, WIA_DPS_MAX_SCAN_TIME_STR },
    { WIA_DPS_PAGES, WIA_DPS_PAGES_STR },
    { WIA_DPS_PAGE_SIZE, WIA_DPS_PAGE_SIZE_STR },
    { WIA_DPS_PAGE_WIDTH, WIA_DPS_PAGE_WIDTH_STR },
    { WIA_DPS_PAGE_HEIGHT, WIA_DPS_PAGE_HEIGHT_STR },
    { WIA_DPS_PREVIEW, WIA_DPS_PREVIEW_STR },
    { WIA_DPS_TRANSPARENCY, WIA_DPS_TRANSPARENCY_STR },
    { WIA_DPS_TRANSPARENCY_SELECT, WIA_DPS_TRANSPARENCY_SELECT_STR },
    { WIA_DPS_SHOW_PREVIEW_CONTROL, WIA_DPS_SHOW_PREVIEW_CONTROL_STR },
    { WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE, WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE, WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR },
    { WIA_DPF_MOUNT_POINT, WIA_DPF_MOUNT_POINT_STR },
    { WIA_DPV_LAST_PICTURE_TAKEN, WIA_DPV_LAST_PICTURE_TAKEN_STR },
    { WIA_DPV_IMAGES_DIRECTORY, WIA_DPV_IMAGES_DIRECTORY_STR },
    { WIA_DPV_DSHOW_DEVICE_PATH, WIA_DPV_DSHOW_DEVICE_PATH_STR },
    { WIA_IPA_ITEM_NAME, WIA_IPA_ITEM_NAME_STR },
    { WIA_IPA_FULL_ITEM_NAME, WIA_IPA_FULL_ITEM_NAME_STR },
    { WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR },
    { WIA_IPA_ITEM_FLAGS, WIA_IPA_ITEM_FLAGS_STR },
    { WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR },
    { WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR },
    { WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR },
    { WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR },
    { WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR },
    { WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR },
    { WIA_IPA_TYMED, WIA_IPA_TYMED_STR },
    { WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR },
    { WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR },
    { WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR },
    { WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR },
    { WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR },
    { WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR },
    { WIA_IPA_GAMMA_CURVES, WIA_IPA_GAMMA_CURVES_STR },
    { WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR },
    { WIA_IPA_COLOR_PROFILE, WIA_IPA_COLOR_PROFILE_STR },
    { WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR },
    { WIA_IPA_REGION_TYPE, WIA_IPA_REGION_TYPE_STR },
    { WIA_IPA_ICM_PROFILE_NAME, WIA_IPA_ICM_PROFILE_NAME_STR },
    { WIA_IPA_APP_COLOR_MAPPING, WIA_IPA_APP_COLOR_MAPPING_STR },
    { WIA_IPA_PROP_STREAM_COMPAT_ID, WIA_IPA_PROP_STREAM_COMPAT_ID_STR },
    { WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR },
    { WIA_IPA_SUPPRESS_PROPERTY_PAGE, WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR },
    { WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR },
    { WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR },
    { WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR },
    { WIA_IPC_AUDIO_AVAILABLE, WIA_IPC_AUDIO_AVAILABLE_STR },
    { WIA_IPC_AUDIO_DATA_FORMAT, WIA_IPC_AUDIO_DATA_FORMAT_STR },
    { WIA_IPC_AUDIO_DATA, WIA_IPC_AUDIO_DATA_STR },
    { WIA_IPC_NUM_PICT_PER_ROW, WIA_IPC_NUM_PICT_PER_ROW_STR },
    { WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR },
    { WIA_IPC_TIMEDELAY, WIA_IPC_TIMEDELAY_STR },
    { WIA_IPS_CUR_INTENT, WIA_IPS_CUR_INTENT_STR },
    { WIA_IPS_XRES, WIA_IPS_XRES_STR },
    { WIA_IPS_YRES, WIA_IPS_YRES_STR },
    { WIA_IPS_XPOS, WIA_IPS_XPOS_STR },
    { WIA_IPS_YPOS, WIA_IPS_YPOS_STR },
    { WIA_IPS_XEXTENT, WIA_IPS_XEXTENT_STR },
    { WIA_IPS_YEXTENT, WIA_IPS_YEXTENT_STR },
    { WIA_IPS_PHOTOMETRIC_INTERP, WIA_IPS_PHOTOMETRIC_INTERP_STR },
    { WIA_IPS_BRIGHTNESS, WIA_IPS_BRIGHTNESS_STR },
    { WIA_IPS_CONTRAST, WIA_IPS_CONTRAST_STR },
    { WIA_IPS_ORIENTATION, WIA_IPS_ORIENTATION_STR },
    { WIA_IPS_ROTATION, WIA_IPS_ROTATION_STR },
    { WIA_IPS_MIRROR, WIA_IPS_MIRROR_STR },
    { WIA_IPS_THRESHOLD, WIA_IPS_THRESHOLD_STR },
    { WIA_IPS_INVERT, WIA_IPS_INVERT_STR },
    { WIA_IPS_WARM_UP_TIME, WIA_IPS_WARM_UP_TIME_STR },
    {0,                                       L"Not a WIA property"}
};

#endif

namespace PropStorageHelpers
{
    CPropertyId::CPropertyId(void)
    : m_strPropId(L""), m_nPropId(0), m_bIsStringPropId(false)
    {
    }

    CPropertyId::CPropertyId( const CSimpleStringWide &strPropId )
    : m_strPropId(strPropId), m_nPropId(0), m_bIsStringPropId(true)
    {
    }


    CPropertyId::CPropertyId( PROPID propId )
    : m_strPropId(L""), m_nPropId(propId), m_bIsStringPropId(false)
    {
    }


    CPropertyId::CPropertyId( const CPropertyId &other )
    : m_strPropId(other.PropIdString()), m_nPropId(other.PropIdNumber()), m_bIsStringPropId(other.IsString())
    {
    }

    CPropertyId::~CPropertyId(void)
    {
    }


    CPropertyId &CPropertyId::operator=( const CPropertyId &other )
    {
        if (this != &other)
        {
            m_strPropId = other.PropIdString();
            m_nPropId = other.PropIdNumber();
            m_bIsStringPropId = other.IsString();
        }
        return(*this);
    }


    CSimpleStringWide CPropertyId::PropIdString(void) const
    {
        return(m_strPropId);
    }

    PROPID CPropertyId::PropIdNumber(void) const
    {
        return(m_nPropId);
    }

    bool CPropertyId::IsString(void) const
    {
        return(m_bIsStringPropId);
    }

    CSimpleString PropertyName( const CPropertyId &propertyName )
    {
#if defined(DBG)
        if (propertyName.IsString())
        {
            return CSimpleStringConvert::NaturalString(propertyName.PropIdString());
        }
        for (int i=0;g_wiaPropIdToName[i].propid;i++)
        {
            if (propertyName.PropIdNumber() == g_wiaPropIdToName[i].propid)
            {
                return CSimpleStringConvert::NaturalString(CSimpleStringWide(g_wiaPropIdToName[i].pszName));
            }
        }
        return CSimpleString().Format( TEXT("Unknown property %d"), propertyName.PropIdNumber() );
#endif
        return TEXT("");
    }


    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pv, PROPID nNameFirst )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::SetProperty(\"%s\")"), PropertyName(propertyName).String() ));
        PROPSPEC ps = {0};
        if (propertyName.IsString())
        {
            ps.ulKind = PRSPEC_LPWSTR;
            ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
        }
        else
        {
            ps.ulKind = PRSPEC_PROPID;
            ps.propid = propertyName.PropIdNumber();
        }
        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (FAILED(hr))
        {
            return(false);
        }
        hr = pIWiaPropertyStorage->WriteMultiple( 1, &ps, &pv, nNameFirst );
        return(SUCCEEDED(hr));
    }

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG nValue, PROPID nNameFirst )
    {
        PROPVARIANT pv = {0};
        pv.vt = VT_I4;
        pv.lVal = nValue;
        return(SetProperty( pIUnknown, propertyName, pv, nNameFirst ));
    }

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, const GUID &guidValue, PROPID nNameFirst )
    {
        PROPVARIANT pv = {0};
        pv.vt = VT_CLSID;
        pv.puuid = const_cast<GUID*>(&guidValue);
        return(SetProperty( pIUnknown, propertyName, pv, nNameFirst ));
    }

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetProperty(\"%s\")"), PropertyName(propertyName).String() ));
        ZeroMemory(&pPropVar,sizeof(pPropVar));
        if (pIUnknown)
        {
            PROPSPEC ps = {0};
            if (propertyName.IsString())
            {
                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
            }
            else
            {
                ps.ulKind = PRSPEC_PROPID;
                ps.propid = propertyName.PropIdNumber();
            }
            CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
            HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("GetProperty: pIUnknown->QueryInterface failed:")));
                return(false);
            }
            hr = pIWiaPropertyStorage->ReadMultiple( 1, &ps, &pPropVar );
            if (FAILED(hr) || S_FALSE==hr)
            {
                WIA_PRINTHRESULT((hr,TEXT("GetProperty: pIUnknown->ReadMultiple failed:")));
                return(false);
            }
            return(SUCCEEDED(hr));
        }
        else
        {
            WIA_ERROR((TEXT("GetProperty: pIUnknown is NULL")));
            return(false);
        }
    }


    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleStringWide &strPropertyValue )
    {
        strPropertyValue = L"";
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_LPWSTR != pvPropValue.vt && VT_BSTR != pvPropValue.vt)
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        strPropertyValue = pvPropValue.pwszVal;
        PropVariantClear(&pvPropValue);
        return(true);
    }


    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nValue )
    {
        nValue = 0;
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_I4 != pvPropValue.vt && VT_UI4 != pvPropValue.vt)
        {
            WIA_ERROR((TEXT("GetProperty: Property value type must be VT_I4 or VT_UI4 and it was 0x%08X (%d)"),pvPropValue.vt,pvPropValue.vt));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        nValue = pvPropValue.lVal;
        PropVariantClear(&pvPropValue);
        return(true);
    }

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, GUID &guidValue )
    {
        guidValue = IID_NULL;
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_CLSID != pvPropValue.vt)
        {
            WIA_ERROR((TEXT("GetProperty: Property value type must be VT_I4 or VT_UI4 and it was 0x%08X (%d)"),pvPropValue.vt,pvPropValue.vt));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (!pvPropValue.puuid)
        {
            WIA_ERROR((TEXT("GetProperty: NULL pvPropValue.puuid")));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        guidValue = *(pvPropValue.puuid);
        PropVariantClear(&pvPropValue);
        return(true);
    }

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags, PROPVARIANT &pvAttributes )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetPropertyAttributes(\"%s\")"), PropertyName(propertyName).String() ));
        ZeroMemory( &pvAttributes, sizeof(pvAttributes) );
        if (!pIUnknown)
        {
            WIA_ERROR((TEXT("pIUnknown is NULL")));
            return false;
        }

        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            PROPSPEC ps;
            if (propertyName.IsString())
            {
                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
            }
            else
            {
                ps.ulKind = PRSPEC_PROPID;
                ps.propid = propertyName.PropIdNumber();
            }

            hr = pIWiaPropertyStorage->GetPropertyAttributes( 1, &ps, &nAccessFlags, &pvAttributes );

            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pIWiaPropertyStorage->GetPropertyAttributes failed")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("pIUnknown->QueryInterface failed")));
        }
        WIA_PRINTHRESULT((hr,TEXT("PropStorageHelpers::GetPropertyAttributes is returning")));
        return (SUCCEEDED(hr) != FALSE);
    }

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pvAttributes )
    {
        ULONG nAccessFlags;
        bool bResult = GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes );
        return (bResult);
    }

    bool GetPropertyAccessFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags )
    {
        PROPVARIANT pvAttributes;
        bool bResult = GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes );
        if (bResult)
            PropVariantClear(&pvAttributes);
        return (bResult);
    }

    bool IsReadOnlyProperty( IUnknown *pIUnknown, const CPropertyId &propertyName )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::IsReadOnlyProperty")));
        bool bResult = true;
        ULONG nAccessFlags = 0;
        if (GetPropertyAccessFlags(pIUnknown,propertyName,nAccessFlags))
        {
            WIA_TRACE((TEXT("nAccessFlags = %08X"),nAccessFlags));
            bResult = ((nAccessFlags & WIA_PROP_WRITE) == 0);
            WIA_TRACE((TEXT("bResult = %d"),bResult));
        }
        return bResult;
    }

    bool GetPropertyRange( IUnknown *pIUnknown, const CPropertyId &propertyName, CPropertyRange &propertyRange )
    {
        ZeroMemory( &propertyRange, sizeof(propertyRange) );
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_RANGE & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                ((pvAttributes.vt & VT_I4) || (pvAttributes.vt & VT_UI4)))
            {
                propertyRange.nMin = (LONG)pvAttributes.caul.pElems[WIA_RANGE_MIN];
                propertyRange.nMax = (LONG)pvAttributes.caul.pElems[WIA_RANGE_MAX];
                propertyRange.nStep = (LONG)pvAttributes.caul.pElems[WIA_RANGE_STEP];
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_RANGE value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<LONG> &aProp )
    {
        aProp.Destroy();
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_LIST & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                ((pvAttributes.vt & VT_I4) || (pvAttributes.vt & VT_UI4)))
            {
                for (ULONG i=0;i<pvAttributes.cal.cElems - WIA_LIST_VALUES;i++)
                    aProp.Append((LONG)pvAttributes.cal.pElems[WIA_LIST_VALUES + i]);
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_LIST value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<GUID> &aProp )
    {
        aProp.Destroy();
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_LIST & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                (pvAttributes.vt & VT_CLSID))
            {
                for (ULONG i=0;i<pvAttributes.cal.cElems - WIA_LIST_VALUES;i++)
                    aProp.Append(pvAttributes.cauuid.pElems[WIA_LIST_VALUES + i]);
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_LIST value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nFlags )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetPropertyFlags(\"%s\")"), PropertyName(propertyName).String() ));
        nFlags = 0;
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if (WIA_PROP_FLAG & nAccessFlags)
            {
                nFlags = pvAttributes.caul.pElems[WIA_FLAG_VALUES];
                WIA_TRACE((TEXT("nFlags = %08X"), nFlags ));
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_FLAG value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        else
        {
            WIA_ERROR((TEXT("GetPropertyAttributes failed")));
        }
        return bResult;
    }
} // Namespace PropStorageHelpers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\regionde.h ===
// RegionDetector.h: interface for the CRegionDetector class.
//
//////////////////////////////////////////////////////////////////////

#include "32BitDib.h"

struct CRegionList
{
    private:
        CRegionList( const CRegionList & );
        CRegionList &operator=( const CRegionList & );
    public:
    CRegionList(int num);
    virtual ~CRegionList()
    {
        delete m_pRects;
        delete m_pixelsFilled;
        delete m_valid;
        delete m_type;
        delete m_totalColored;
        delete m_totalIntensity;
        delete m_totalEdge;
        delete m_backgroundColorPixels;
    }

    // public... number of valid rects
    int Size(int r)
    {
        return (m_pRects[r].right-m_pRects[r].left)*(m_pRects[r].bottom-m_pRects[r].top);
    }


    // public
    RECT operator[](int num)
    {
        return nthRegion(num);
    }

    // public

    int UnionIntersectingRegions();

    // public
    RECT unionAll();

    // private
    RECT nthRegion(int num);

    int RegionType(int region);

    bool largeRegion(int region);

    double ClassifyRegion(int region); // determine if the region is a text or a graphics region

    bool checkIfValidRegion(int region, int border = 0); // syncs whether a region is valid or not

    bool ValidRegion(int region, int border = 0); // determines if a region is likely a worthless speck of dust or shadow or if we should care about the region

    bool InsideRegion(int region, int x, int y, int border=0); // border is the amount of border space to place around the outside of the region

    void AddPixel(int region, ULONG pixel,ULONG edge, int x, int y);
    // unions two regions together... region b is invalidated
    bool UnionRegions(int a, int b);
    RECT UnionRects(RECT a, RECT b);
    bool MergerIntersectsPhoto(int a, int b); // if we merge these two regions, will we also be merging with a photo region (a taboo)
    // see InsideRegion for an explaination of what border is
    bool CheckIntersect(int a, int b, int border=0); // do regions a and b intersect?
    bool CheckIntersect(RECT r1, RECT r2, int border=0); // do regions a and b intersect?

    static RECT Intersect(RECT r1, RECT r2);

    static bool InsideRegion(RECT region, int x, int y, int border=0); // border is the amount of border space to place around the outside of the region

    // compact down ignores all other info aside from rect location
    // leads to faster access
    void CompactDown(int size);

    // dibs are stored upside down from normal screen coords
    // so apps will often want to flip the bitmap first
    void FlipVertically();


    int m_numRects;
    int m_validRects;
    int m_nBitmapWidth;
    int m_nBitmapHeight;
    RECT * m_pRects;
    bool * m_valid; // is the rectangle a valid rectangle or has it been sent to the region graveyard in the sky
    int * m_type; // is this region a text region or a photograph? PHOTOGRAPH_REGION TEXT_REGION

    // the following indicators are used to determine if a region is a valid region

    ULONG * m_pixelsFilled;  // how many of the pixels in the region were actually selected?
    ULONG * m_totalColored; // accumulated color difference indicator
    ULONG * m_totalIntensity; // accumulated intensity indicator
    ULONG * m_totalEdge; // accumulated edge values
    int *m_backgroundColorPixels; // number of pixels which are very close to the background color (used for determining text region status... particularly useful in cases where part of a text region may have a shadow which could lead the program to think it was a photo region
    int m_maxRects;
};

class CRegionDetector
{
private:
    // Not implemented
    CRegionDetector( const CRegionDetector & );
    CRegionDetector &operator=( const CRegionDetector & );

public: // will be made private when we are done debugging
    C32BitDibWrapper * m_pScan;
    C32BitDibWrapper * m_pScanBlurred;
    C32BitDibWrapper * m_pScanDoubleBlurred;
    C32BitDibWrapper * m_pScanTripleBlurred;

    C32BitDibWrapper * m_pScanHorizontalBlurred;
    C32BitDibWrapper * m_pScanVerticalBlurred;
    C32BitDibWrapper * m_pScanDoubleHorizontalBlurred;
    C32BitDibWrapper * m_pScanDoubleVerticalBlurred;

    C32BitDibWrapper * m_pScanEdges;
    C32BitDibWrapper * m_pScanDoubleEdges;
    C32BitDibWrapper * m_pScanTripleEdges;
    C32BitDibWrapper * m_pScanHorizontalEdges;
    C32BitDibWrapper * m_pScanDoubleHorizontalEdges;
    C32BitDibWrapper * m_pScanVerticalEdges;
    C32BitDibWrapper * m_pScanDoubleVerticalEdges;
    C32BitDibWrapper * m_pScanWithShadows;

    CRegionList * m_pRegions;
    int m_resampleFactor; // ratio between imageDimensions and origional image dimensions
    int m_intent; // either try to avoid deciding stray dots are images or try to avoid deciding real images aren't images
    // not used as yet


public:
    CRegionDetector(BYTE* dib)
    {
        m_pScan = new C32BitDibWrapper(dib);
        m_pScanBlurred = new C32BitDibWrapper(); // create an empty wrapper
        m_pScanDoubleBlurred = new C32BitDibWrapper();
        m_pScanTripleBlurred = new C32BitDibWrapper();

        m_pScanHorizontalBlurred = new C32BitDibWrapper();
        m_pScanVerticalBlurred = new C32BitDibWrapper();

        m_pScanDoubleHorizontalBlurred = new C32BitDibWrapper();
        m_pScanDoubleVerticalBlurred = new C32BitDibWrapper();

        m_pScanEdges = new C32BitDibWrapper();
        m_pScanDoubleEdges = new C32BitDibWrapper();
        m_pScanTripleEdges = new C32BitDibWrapper();

        m_pScanHorizontalEdges = new C32BitDibWrapper();
        m_pScanVerticalEdges = new C32BitDibWrapper();

        m_pScanDoubleHorizontalEdges = new C32BitDibWrapper();
        m_pScanDoubleVerticalEdges = new C32BitDibWrapper();

        m_resampleFactor=1;
        m_pScanWithShadows = NULL;
        m_pRegions=NULL;
        m_intent=TRUE; // m_intent isn't yet implemented
    }

    CRegionDetector(BITMAP pBitmap)
    {
        m_pScan = new C32BitDibWrapper(pBitmap);
        m_pScanBlurred = new C32BitDibWrapper(); // create an empty wrapper
        m_pScanDoubleBlurred = new C32BitDibWrapper();
        m_pScanTripleBlurred = new C32BitDibWrapper();

        m_pScanHorizontalBlurred = new C32BitDibWrapper();
        m_pScanVerticalBlurred = new C32BitDibWrapper();

        m_pScanDoubleHorizontalBlurred = new C32BitDibWrapper();
        m_pScanDoubleVerticalBlurred = new C32BitDibWrapper();

        m_pScanEdges = new C32BitDibWrapper();
        m_pScanDoubleEdges = new C32BitDibWrapper();
        m_pScanTripleEdges = new C32BitDibWrapper();

        m_pScanHorizontalEdges = new C32BitDibWrapper();
        m_pScanVerticalEdges = new C32BitDibWrapper();

        m_pScanDoubleHorizontalEdges = new C32BitDibWrapper();
        m_pScanDoubleVerticalEdges = new C32BitDibWrapper();

        m_resampleFactor=1;
        m_pScanWithShadows = NULL;
        m_pRegions=NULL;
        m_intent=TRUE; // m_intent isn't yet implemented
    }

    virtual ~CRegionDetector()
    {
        if (m_pScan) delete m_pScan;
        if (m_pScanBlurred) delete m_pScanBlurred;
        if (m_pScanDoubleBlurred) delete m_pScanDoubleBlurred;
        if (m_pScanTripleBlurred) delete m_pScanTripleBlurred;

        if (m_pScanHorizontalBlurred) delete m_pScanHorizontalBlurred;
        if (m_pScanVerticalBlurred) delete m_pScanVerticalBlurred;

        if (m_pScanDoubleHorizontalBlurred) delete m_pScanDoubleHorizontalBlurred;
        if (m_pScanDoubleVerticalBlurred) delete m_pScanDoubleVerticalBlurred;

        if (m_pScanEdges) delete m_pScanEdges;
        if (m_pScanDoubleEdges) delete m_pScanDoubleEdges;
        if (m_pScanTripleEdges) delete m_pScanTripleEdges;

        if (m_pScanHorizontalEdges) delete m_pScanHorizontalEdges;
        if (m_pScanVerticalEdges) delete m_pScanVerticalEdges;

        if (m_pScanDoubleHorizontalEdges) delete m_pScanDoubleHorizontalEdges;
        if (m_pScanDoubleVerticalEdges) delete m_pScanDoubleVerticalEdges;

        if (m_pScanWithShadows) delete m_pScanWithShadows;
        if(m_pRegions!=NULL) delete m_pRegions;
    }
public:
    int FindRegions();
    bool FindSingleRegion();
    bool CollisionDetection(RECT r1, RECT r2, C32BitDibWrapper* pImage);
    bool ConvertToOrigionalCoordinates();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\resid.h ===
#ifndef __RESID_H_INCLUDED
#define __RESID_H_INCLUDED

#include <windows.h>

class CResId
{
private:
    LPTSTR m_pszRes;
    int m_nRes;
    bool m_bIsString;
public:
    CResId( LPTSTR pszRes = NULL );
    CResId( int nRes );
    CResId( const CResId &other );
    virtual ~CResId(void);
    const CResId &operator=( const CResId &other );
    LPCTSTR ResourceName(void) const;
    LPCTSTR StringRes(void) const;
    LPCTSTR StringRes( LPCTSTR pszRes );
    int NumberRes(void) const;
    int NumberRes( int nRes );
    bool IsString(void) const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\resid.cpp ===
#include "precomp.h"
#pragma hdrstop

CResId::CResId( LPTSTR pszRes )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    StringRes(pszRes);
}

CResId::CResId( int nRes )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    NumberRes(nRes);
}

CResId::CResId( const CResId &other )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    if (other.IsString())
        StringRes(other.StringRes());
    else NumberRes(other.NumberRes());
}

CResId::~CResId(void)
{
    if (m_pszRes)
    {
        delete[] m_pszRes;
        m_pszRes = NULL;
    }
}

const CResId &CResId::operator=( const CResId &other )
{
    if (other.IsString())
        StringRes(other.StringRes());
    else NumberRes(other.NumberRes());
    return *this;
}

LPCTSTR CResId::ResourceName(void) const
{
    if (IsString())
        return StringRes();
    else return MAKEINTRESOURCE(NumberRes());
}

LPCTSTR CResId::StringRes(void) const
{
    return m_pszRes;
}

int CResId::NumberRes(void) const
{
    return m_nRes;
}

bool CResId::IsString(void) const
{
    return m_bIsString;
}

LPCTSTR CResId::StringRes( LPCTSTR pszRes )
{
    if (m_pszRes)
    {
        delete[] m_pszRes;
        m_pszRes = NULL;
    }
    if (pszRes)
    {
        m_pszRes = new TCHAR[lstrlen(pszRes)+1];
        if (m_pszRes)
        {
            lstrcpy( m_pszRes, pszRes );
        }
    }
    m_bIsString = true;
    return m_pszRes;
}

int CResId::NumberRes( int nRes )
{
    m_nRes = nRes;
    m_bIsString = false;
    return m_nRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\runnpwiz.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNNPWIZ.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/15/2000
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __RUNNPWIZ_H_INCLUDED
#define __RUNNPWIZ_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <simarray.h>

namespace NetPublishingWizard
{
    HRESULT GetClassIdOfPublishingWizard( CLSID &clsidWizard );
    HRESULT RunNetPublishingWizard( const CSimpleDynamicArray<CSimpleString> &strFiles );
    HRESULT CreateDataObjectFromFileList( const CSimpleDynamicArray<CSimpleString> &strFiles, IDataObject **ppDataObject );
}

#endif // __RUNNPWIZ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\runwiz.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNWIZ.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/14/2000
 *
 *  DESCRIPTION: Present the device selection dialog and allow the user to select
 *               a device, then cocreate the server and generate the connection
 *               event.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "simstr.h"
#include "simbstr.h"
#include "runwiz.h"
#include "shmemsec.h"


namespace RunWiaWizard
{
    static const GUID CLSID_AcquisitionManager = { 0xD13E3F25,0x1688,0x45A0,{ 0x97,0x43,0x75,0x9E,0xB3, 0x5C,0xDF,0x9A} };

    HRESULT RunWizard( LPCTSTR pszDeviceId, HWND hWndParent, LPCTSTR pszUniqueIdentifier )
    {
        //
        // Assume failure
        //
        HRESULT hr = E_FAIL;

        //
        // Get the device ID if one was not provided
        //
        CSimpleStringWide strwDeviceId;
        if (!pszDeviceId || !lstrlen(pszDeviceId))
        {
            //
            // Assume we will be asking for the device
            //
            bool bAskForDevice = true;

            //
            // This will automatically be cleaned up when we exit this scope
            //
            CSharedMemorySection<HWND> SelectionDialogSharedMemory;

            //
            // We only want to enforce uniqueness if we have a unique ID for this instance of the UI
            //
            if (pszUniqueIdentifier && *pszUniqueIdentifier)
            {
                //
                // First, try to open it.  If it exists, that means there is another instance running already.
                //
                CSharedMemorySection<HWND>::COpenResult OpenResult = SelectionDialogSharedMemory.Open( pszUniqueIdentifier, true );
                if (CSharedMemorySection<HWND>::SmsOpened == OpenResult)
                {
                    //
                    // We don't want to display the selection dialog
                    //
                    bAskForDevice = false;

                    //
                    // Tell the caller we cancelled
                    //
                    hr = S_FALSE;

                    //
                    // If we were able to open the shared memory section, there is already one running.
                    // so get a mutex'ed pointer to the shared memory.
                    //
                    HWND *pHwnd = SelectionDialogSharedMemory.Lock();
                    if (pHwnd)
                    {
                        //
                        // If we were able to get the pointer, get the window handle stored in it.
                        // Set bRun to false, so we don't start up a new wizard
                        //
                        if (*pHwnd && IsWindow(*pHwnd))
                        {
                            //
                            // Try to get any active windows
                            //
                            HWND hWndPopup = GetLastActivePopup(*pHwnd);

                            //
                            // If it is a valid window, bring it to the foreground.
                            //
                            SetForegroundWindow(hWndPopup);

                        }
                        //
                        // Release the mutex
                        //
                        SelectionDialogSharedMemory.Release();
                    }
                }
                else if (CSharedMemorySection<HWND>::SmsCreated == OpenResult)
                {
                    //
                    // If we couldn't open it, we are the first instance, so store the parent window handle
                    //
                    HWND *phWnd = SelectionDialogSharedMemory.Lock();
                    if (phWnd)
                    {
                        *phWnd = hWndParent;
                        SelectionDialogSharedMemory.Release();
                    }
                }
            }

            if (bAskForDevice)
            {
                //
                // Create the device manager
                //
                CComPtr<IWiaDevMgr> pWiaDevMgr;
                hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the device ID
                    //
                    BSTR bstrDeviceId = NULL;
                    hr = pWiaDevMgr->SelectDeviceDlgID( hWndParent, 0, 0, &bstrDeviceId );
                    if (hr == S_OK && bstrDeviceId != NULL)
                    {
                        //
                        // Save the device ID and free the bstring
                        //
                        strwDeviceId = bstrDeviceId;
                        SysFreeString(bstrDeviceId);
                    }
                }
            }
        }
        else
        {
            //
            // Save the provided device ID
            //
            strwDeviceId = CSimpleStringConvert::WideString(CSimpleString(pszDeviceId));
        }

        //
        // If we have a valid device ID, continue
        //
        if (strwDeviceId.Length())
        {
            //
            // Create the wizard
            //
            CComPtr<IWiaEventCallback> pWiaEventCallback;
            hr = CoCreateInstance( CLSID_AcquisitionManager, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaEventCallback, (void**)&pWiaEventCallback );
            if (SUCCEEDED(hr))
            {
                //
                // Convert the parent window handle to a string, which we will pass as the event description
                // The wizard will only use it this way if the event GUID is IID_NULL
                //
                CSimpleBStr bstrParentWindow( CSimpleString().Format( TEXT("%d"), hWndParent ) );

                //
                // Allow this process to set the foreground window
                //
                CoAllowSetForegroundWindow( pWiaEventCallback, NULL );

                //
                // Call the callback function
                //
                ULONG ulEventType = 0;
                hr = pWiaEventCallback->ImageEventCallback( &IID_NULL,
                                                            bstrParentWindow.BString(),
                                                            CSimpleBStr(strwDeviceId),
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            &ulEventType,
                                                            0);
            }
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\runnpwiz.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNNPWIZ.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/15/2000
 *
 *  DESCRIPTION: Runs the Web Publishing Wizard
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <atlbase.h>
#include "runnpwiz.h"
#include <simidlst.h>
#include <shellext.h>
#include <shlobj.h>
#include <shlguid.h>
#include <shlwapi.h>
#include <wiadebug.h>
#include <simreg.h>

namespace NetPublishingWizard
{
    static const TCHAR *c_pszPublishWizardSuffix = TEXT(".publishwizard");
    static const TCHAR *c_pszClassIdPrefix       = TEXT("CLSID\\");

    HRESULT GetClassIdOfPublishingWizard( CLSID &clsidWizard )
    {
        WIA_PUSH_FUNCTION((TEXT("GetClassIdOfPublishingWizard")));
        //
        // Assume failure
        //
        HRESULT hr = E_FAIL;

        //
        // Try to get the class id from the registry
        //
        CSimpleString strWizardClsid = CSimpleReg( HKEY_CLASSES_ROOT, c_pszPublishWizardSuffix, false, KEY_READ ).Query( TEXT(""), TEXT("") );
        WIA_TRACE((TEXT("strWizardClsid = %s"), strWizardClsid.String()));

        //
        // Make sure we have a string, and make sure the CLSID\ prefix is there
        //
        if (strWizardClsid.Length() && strWizardClsid.Left(lstrlen(c_pszClassIdPrefix)).ToUpper() == CSimpleString(c_pszClassIdPrefix))
        {
            //
            // Convert the string, minus the CLSID\, to a CLSID
            //
            hr = CLSIDFromString( const_cast<LPOLESTR>(CSimpleStringConvert::WideString(strWizardClsid.Right(strWizardClsid.Length()-6)).String()), &clsidWizard );
        }
        return hr;
    }


    HRESULT RunNetPublishingWizard( const CSimpleDynamicArray<CSimpleString> &strFiles )
    {
        WIA_PUSH_FUNCTION((TEXT("RunNetPublishingWizard")));

        HRESULT hr;

        //
        // Make sure there are some files in the list
        //
        if (strFiles.Size())
        {
            //
            // Get the CLSID of the publishing wizard from the registry
            //
            CLSID clsidWizard = IID_NULL;
            hr = GetClassIdOfPublishingWizard(clsidWizard);
            if (SUCCEEDED(hr))
            {
                WIA_PRINTGUID((clsidWizard,TEXT("Wizard class ID")));
                //
                // Get the data object for this list of files
                //
                CComPtr<IDataObject> pDataObject;
                hr = CreateDataObjectFromFileList( strFiles, &pDataObject );
                if (SUCCEEDED(hr))
                {
                    //
                    // Create the wizard
                    //
                    CComPtr<IDropTarget> pDropTarget;
                    hr = CoCreateInstance( clsidWizard, NULL, CLSCTX_INPROC_SERVER, IID_IDropTarget, (void**)&pDropTarget );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Perform the drop
                        //
                        DWORD dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
                        POINTL pt = { 0, 0 };
                        hr = pDropTarget->Drop( pDataObject, 0, pt, &dwEffect );
                    }
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("RunNetPublishingWizard is returning")));
        }
        return hr;
    }

    HRESULT CreateDataObjectFromFileList( const CSimpleDynamicArray<CSimpleString> &strFiles, IDataObject **ppDataObject )
    {
        WIA_PUSH_FUNCTION((TEXT("CreateDataObjectFromFileList")));

        HRESULT hr;

        //
        // Make sure there are some files in the list
        //
        if (strFiles.Size())
        {
            //
            // Get the desktop folder
            //
            CComPtr<IShellFolder> pDesktopFolder;
            hr = SHGetDesktopFolder( &pDesktopFolder );
            if (SUCCEEDED(hr) && pDesktopFolder.p)
            {
                //
                // Allocate memory to hold the source folder name
                //
                LPTSTR pszPath = new TCHAR[strFiles[0].Length()+1];
                if (pszPath)
                {
                    //
                    // Copy the first filename to the folder name, and remove all but the directory
                    //
                    lstrcpy( pszPath, strFiles[0] );
                    if (PathRemoveFileSpec(pszPath))
                    {
                        //
                        // Get the pidl for the source folder
                        //
                        LPITEMIDLIST pidlFolder;
                        hr = pDesktopFolder->ParseDisplayName( NULL, NULL, const_cast<LPWSTR>(CSimpleStringConvert::WideString(CSimpleString(pszPath)).String()), NULL, &pidlFolder, NULL );
                        if (SUCCEEDED(hr))
                        {
                            WIA_TRACE((TEXT("pidlFolder: %s"), CSimpleIdList(pidlFolder).Name().String()));

                            //
                            // Get an IShellFolder for the source folder
                            //
                            CComPtr<IShellFolder> pSourceFolder;
                            hr = pDesktopFolder->BindToObject( pidlFolder, NULL, IID_IShellFolder, (void**)&pSourceFolder );
                            ILFree(pidlFolder);
                            if (SUCCEEDED(hr) && pSourceFolder.p)
                            {                               
                                //
                                // Create an array of pidls to hold the files
                                //
                                LPITEMIDLIST *pidlItems = new LPITEMIDLIST[strFiles.Size()];
                                if (pidlItems)
                                {
                                    //
                                    // Make sure we start out with NULL pidls
                                    //
                                    ZeroMemory( pidlItems, sizeof(LPITEMIDLIST)*strFiles.Size() );

                                    //
                                    // Get the pidls for the files
                                    //
                                    for (int i=0;i<strFiles.Size();i++)
                                    {
                                        //
                                        // Get the filename alone.  We want relative pidls.
                                        //
                                        CSimpleString strFilename = PathFindFileName(strFiles[i]);
                                        WIA_TRACE((TEXT("strFilename = %s"), strFilename.String()));

                                        //
                                        // Create the relative pidl
                                        //
                                        hr = pSourceFolder->ParseDisplayName( NULL, NULL, const_cast<LPWSTR>(CSimpleStringConvert::WideString(strFilename).String()), NULL, pidlItems+i, NULL );
                                        if (FAILED(hr))
                                        {
                                            WIA_PRINTHRESULT((hr,TEXT("pSourceFolder->ParseDisplayName returned")));
                                            break;
                                        }
                                    }

                                    //
                                    // Make sure everything is still going OK
                                    //
                                    if (SUCCEEDED(hr))
                                    {
                                        //
                                        // Get the IDataObject for the source folder, and give it the list of file pidls
                                        //
                                        hr = pSourceFolder->GetUIObjectOf( NULL, strFiles.Size(), const_cast<LPCITEMIDLIST*>(pidlItems), IID_IDataObject, NULL, reinterpret_cast<LPVOID*>(ppDataObject) );
                                    }
                                    for (int i=0;i<strFiles.Size();i++)
                                    {
                                        if (pidlItems[i])
                                        {
                                            ILFree(pidlItems[i]);
                                        }
                                    }
                                    delete [] pidlItems;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                    //
                    // Free the folder name
                    //
                    delete[] pszPath;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("CreateDataObjectFromFileList is returning")));
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\runwiz.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RUNWIZ.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/14/2000
 *
 *  DESCRIPTION: Present the device selection dialog and allow the user to select
 *               a device, then cocreate the server and generate the connection
 *               event.
 *
 *******************************************************************************/

#include <windows.h>

namespace RunWiaWizard
{
    HRESULT RunWizard( LPCTSTR pszDeviceId=NULL, HWND hWndParent=NULL, LPCTSTR pszUniqueIdentifier=NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\shmemsec.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SHMEMSEC.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/30/1999
 *
 *  DESCRIPTION: Simple shared memory section template.  Don't use it for classes!
 *               Basically, simple objects only.  structs are ok.  Nothing with a
 *               vtable.
 *
 *******************************************************************************/
#ifndef __SHMEMSEC_H_INCLUDED
#define __SHMEMSEC_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <miscutil.h>

template <class T>
class CSharedMemorySection
{
public:
    enum COpenResult
    {
        SmsFailed,
        SmsCreated,
        SmsOpened
    };

private:
    HANDLE  m_hMutex;
    HANDLE  m_hFileMapping;
    T      *m_pMappedSection;

private:
    //
    // Not implemented
    //
    CSharedMemorySection( const CSharedMemorySection & );
    CSharedMemorySection &operator=( const CSharedMemorySection & );

public:
    CSharedMemorySection( LPCTSTR pszName=NULL, bool bAllowCreate=true )
      : m_hFileMapping(NULL),
        m_pMappedSection(NULL),
        m_hMutex(NULL)
    {
        WIA_PUSHFUNCTION(TEXT("CSharedMemorySection::CSharedMemorySection"));
        Open(pszName,bAllowCreate);
    }
    ~CSharedMemorySection(void)
    {
        WIA_PUSHFUNCTION(TEXT("CSharedMemorySection::~CSharedMemorySection"));
        Close();
    }
    bool OK(void)
    {
        return(m_pMappedSection != NULL);
    }
    T *Lock(void)
    {
        T *pResult = NULL;
        if (OK())
        {
            if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
            {
                pResult = m_pMappedSection;
            }
        }
        return pResult;
    }
    void Release(void)
    {
        if (OK())
        {
            ReleaseMutex(m_hMutex);
        }
    }
    COpenResult Open( LPCTSTR pszName, bool bAllowCreate=true )
    {
        //
        // Close any previous instances
        //
        Close();

        //
        // Assume failure
        //
        COpenResult orResult = SmsFailed;

        //
        // Make sure we have a valid name
        //
        if (pszName && *pszName)
        {
            //
            // Save the name
            //
            CSimpleString strSectionName = pszName;

            //
            // Replace any invalid characters
            //
            for (int i=0;i<(int)strSectionName.Length();i++)
            {
                if (strSectionName[i] == TEXT('\\'))
                {
                    strSectionName[i] = TEXT('-');
                }
            }

            //
            // Create the mutex name
            //
            CSimpleString strMutex(strSectionName);
            strMutex += TEXT("-Mutex");

            //
            // Try to create the mutex
            //
            m_hMutex = CreateMutex( NULL, FALSE, strMutex );
            if (m_hMutex)
            {
                //
                // Take ownership of the mutex
                //
                if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
                {
                    //
                    // If this file mapping already exists, open it.
                    //
                    m_hFileMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS, FALSE, strSectionName );
                    if (m_hFileMapping)
                    {
                        m_pMappedSection = reinterpret_cast<T*>(MapViewOfFile( m_hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(T) ));
                        orResult = SmsOpened;
                    }
                    else if (bAllowCreate)
                    {
                        //
                        // Create the file mapping
                        //
                        m_hFileMapping = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(T), strSectionName );
                        if (m_hFileMapping)
                        {
                            //
                            // Try to acquire the file mapping
                            //
                            m_pMappedSection = reinterpret_cast<T*>(MapViewOfFile( m_hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(T) ));
                            if (m_pMappedSection)
                            {
                                //
                                // Initialize the data
                                //
                                ZeroMemory( m_pMappedSection, sizeof(T) );
                                orResult = SmsCreated;
                            }
                        }
                    }
                    //
                    // Release the mutex
                    //
                    ReleaseMutex(m_hMutex);
                }
            }
        }
        //
        // If we weren't able to map the file mapping section, we need to clean up
        //
        if (!m_pMappedSection)
        {
            Close();
        }
        return(orResult);
    }
    void Close(void)
    {
        //
        // First, try to delete it safely.
        //
        if (m_hMutex)
        {
            if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
            {
                if (m_pMappedSection)
                {
                    UnmapViewOfFile(m_pMappedSection);
                    m_pMappedSection = NULL;
                }
                if (m_hFileMapping)
                {
                    CloseHandle(m_hFileMapping);
                    m_hFileMapping = NULL;
                }
                ReleaseMutex(m_hMutex);
            }
        }

        //
        // Then, just clean up
        //
        if (m_pMappedSection)
        {
            UnmapViewOfFile(m_pMappedSection);
            m_pMappedSection = NULL;
        }
        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
            m_hMutex = NULL;
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\simidlst.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMIDLST.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/28/1999
 *
 *  DESCRIPTION: Simple PIDL Wrapper Class
 *
 *******************************************************************************/
#ifndef __SIMIDLST_H_INCLUDED
#define __SIMIDLST_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <simstr.h>

class CSimpleIdList
{
private:
    LPITEMIDLIST m_pIdl;
public:
    CSimpleIdList(void)
    : m_pIdl(NULL)
    {
    }
    CSimpleIdList( PBYTE pData, UINT nSize )
    : m_pIdl(NULL)
    {
        m_pIdl = NULL;
        IMalloc *pMalloc = NULL;
        if (SUCCEEDED(SHGetMalloc(&pMalloc)))
        {
            m_pIdl = reinterpret_cast<LPITEMIDLIST>(pMalloc->Alloc( nSize ));
            if (m_pIdl)
            {
                CopyMemory( m_pIdl, pData, nSize );
            }
            pMalloc->Release();
        }
    }
    CSimpleIdList( LPCITEMIDLIST pIdl )
    : m_pIdl(NULL)
    {
        Assign(pIdl);
    }
    CSimpleIdList( const CSimpleIdList &other )
    : m_pIdl(NULL)
    {
        Assign(other.IdList());
    }
    CSimpleIdList( HWND hWnd, int nFolder )
    : m_pIdl(NULL)
    {
        GetSpecialFolder( hWnd, nFolder );
    }
    ~CSimpleIdList(void)
    {
        Destroy();
    }
    bool IsValid(void) const
    {
        return (m_pIdl != NULL);
    }
    CSimpleIdList &operator=( const CSimpleIdList &other )
    {
        if (this != &other)
        {
            Destroy();
            Assign(other.IdList());
        }
        return *this;
    }
    LPITEMIDLIST IdList(void)
    {
        return m_pIdl;
    }
    LPCITEMIDLIST IdList(void) const
    {
        return m_pIdl;
    }
    UINT Size(void) const
    {
        if (!IsValid())
            return 0;
        return ILGetSize(m_pIdl);
    }
    void Release(void)
    {
        m_pIdl = NULL;
    }
    CSimpleIdList &Assign( LPCITEMIDLIST pIdl )
    {
        if (pIdl != m_pIdl)
        {
            Destroy();
            if (pIdl)
            {
                m_pIdl = ILClone(pIdl);
            }
        }
        return *this;
    }
    void Destroy(void)
    {
        if (m_pIdl)
        {
            IMalloc *pMalloc = NULL;
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free( m_pIdl );
                pMalloc->Release();
            }
            m_pIdl = NULL;
        }
    }
    CSimpleIdList &GetSpecialFolder( HWND hWnd, int nFolder )
    {
        Destroy();
        if (S_OK!=SHGetSpecialFolderLocation(hWnd,nFolder,&m_pIdl))
        {
            // Make sure it is nuked
            Destroy();
        }
        return *this;
    }
    CSimpleString Name(void) const
    {
        CSimpleString strRet;
        if (IsValid())
        {
            TCHAR szPath[MAX_PATH];
            SHGetPathFromIDList( m_pIdl, szPath );
            strRet = szPath;
        }
        return strRet;
    }
    bool operator==( const CSimpleIdList &other )
    {
        return (Name() == other.Name());
    }
    bool operator!=( const CSimpleIdList &other )
    {
        return (Name() != other.Name());
    }
};

#endif // __SIMIDLST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\simevent.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMEVENT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Simple win32 event wrapper class
 *
 *******************************************************************************/
#ifndef __SIMEVENT_H_INCLUDED
#define __SIMEVENT_H_INCLUDED

#include "simstr.h"

class CSimpleEvent
{
private:
    CSimpleString m_strEventName;
    HANDLE m_hEvent;
public:
    CSimpleEvent( bool bNoCreate = false )
    :  m_hEvent(NULL)
    {
        if (!bNoCreate)
            Assign( CSimpleString(TEXT("")), NULL );
    }
    explicit CSimpleEvent( LPCTSTR pszEventName )
    :  m_hEvent(NULL)
    {
        Assign( pszEventName, NULL );
    }
    explicit CSimpleEvent( const CSimpleString &strEventName )
    :  m_hEvent(NULL)
    {
        Assign( strEventName, NULL );
    }
    CSimpleEvent( HANDLE hEvent )
    :  m_hEvent(NULL)
    {
        Assign( CSimpleString(TEXT("")), hEvent );
    }
    CSimpleEvent( const CSimpleEvent &other )
    :  m_hEvent(NULL)
    {
        Assign( other.EventName(), other.Event() );
    }
    CSimpleEvent &operator=( const CSimpleEvent &other )
    {
        return Assign( other.EventName(), other.Event() );
    }
    CSimpleEvent &operator=( HANDLE hEvent )
    {
        return Assign( TEXT(""), hEvent );
    }
    virtual ~CSimpleEvent(void)
    {
        Close();
    }
    bool Create( const CSimpleString &strEventName = TEXT("") )
    {
        Assign( strEventName, NULL );
        return (m_hEvent != NULL);
    }
    CSimpleEvent &Assign( const CSimpleString &strEventName, const HANDLE hEvent )
    {
        Close();
        if (!strEventName.Length() && !hEvent)
        {
            m_hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        }
        else if (strEventName.Length())
        {
            m_strEventName = strEventName;
            m_hEvent = CreateEvent( NULL, TRUE, FALSE, m_strEventName.String() );
        }
        else if (hEvent)
        {
            if (!DuplicateHandle( GetCurrentProcess(), hEvent, GetCurrentProcess(), &m_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS ))
                m_hEvent = NULL;
        }
        return *this;
    }
    bool Close(void)
    {
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }
        m_strEventName = TEXT("");
        return true;
    }
    void Reset(void)
    {
        if (!m_hEvent)
            return;
        ResetEvent(m_hEvent);
    }
    bool Signalled(void) const
    {
        if (!m_hEvent)
            return (false);
        DWORD dwRes = WaitForSingleObject(m_hEvent,0);
        return(WAIT_OBJECT_0 == dwRes);
    }
    void Signal(void) const
    {
        if (!m_hEvent)
            return;
        SetEvent(m_hEvent);
    }
    CSimpleString EventName(void) const
    {
        return (m_strEventName);
    }
    HANDLE Event(void) const
    {
        return (m_hEvent);
    }
};

#endif // #ifndef __SIMEVENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\sources.inc ===
#
# Builds the ImageIn common ui library, COMMON.LIB
#

!include $(PROJECT_ROOT)\ui\uienv.inc


TARGETPATH=$(UI_DIR)\lib\$(PLATFORM_SUFFIX)\$(_OBJ_DIR)

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETNAME=uicommon
TARGETTYPE=LIBRARY

SOURCES=\
        ..\uiexthlp.cpp   \
        ..\miscutil.cpp   \
        ..\createtb.cpp   \
        ..\pshelper.cpp   \
        ..\rescale.cpp    \
        ..\dumpprop.cpp   \
        ..\resid.cpp      \
        ..\errors.cpp     \
        ..\32BitDib.cpp   \
        ..\sysprops.cpp   \
        ..\gdbgdata.cpp   \
        ..\propstrm.cpp   \
        ..\svselfil.cpp   \
        ..\gwiaevnt.cpp   \
        ..\wiacsh.cpp     \
        ..\runwiz.cpp     \
        ..\runnpwiz.cpp   \
        ..\regionde.cpp   \
        ..\mboxex.cpp     \
        ..\wiacrc32.cpp   \
        ..\wiafusion.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\svselfil.h ===
#ifndef __SVSELFIL_H_INCLUDED
#define __SVSELFIL_H_INCLUDED

#include <windows.h>
#include "simarray.h"

namespace OpenShellFolder
{
    HRESULT OpenShellFolderAndSelectFile( HWND hWnd, const CSimpleDynamicArray<CSimpleString> &Filenames );
}

#endif // __SVSELFIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\simtok.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SIMTOK.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        5/12/1998
*
*  DESCRIPTION: String tokenizer template class
*
*******************************************************************************/
#ifndef _SIMTOK_H_INCLUDED
#define _SIMTOK_H_INCLUDED

#include "simstr.h"

template <class T>
class CSimpleStringToken
{
private:
    T m_strStr;
    int m_nIndex;
public:
    CSimpleStringToken(void);
    CSimpleStringToken( const T &str );
    CSimpleStringToken( const CSimpleStringToken &other );
    CSimpleStringToken &operator=( const CSimpleStringToken &other );
    virtual ~CSimpleStringToken(void);
    void Reset(void);
    T Tokenize( const T &strDelim );
    T String(void) const;
    int Index(void) const;
};

template <class T>
CSimpleStringToken<T>::CSimpleStringToken(void)
:m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const T &str )
: m_strStr(str), m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const CSimpleStringToken &other )
: m_strStr(other.String()), m_nIndex(other.Index())
{
}

template <class T>
CSimpleStringToken<T> &CSimpleStringToken<T>::operator=( const CSimpleStringToken &other )
{
    m_strStr = other.String();
    m_nIndex = other.Index();
    return *this;
}

template <class T>
CSimpleStringToken<T>::~CSimpleStringToken(void)
{
}

template <class T>
void CSimpleStringToken<T>::Reset(void)
{
    m_nIndex = 0;
}

template <class T>
T CSimpleStringToken<T>::Tokenize( const T &strDelim )
{
    T strToken(TEXT(""));
    // Throw away the leading delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    // Copy the string until we reach a delimiter
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) >= 0)
            break;
        strToken += m_strStr[m_nIndex];
        ++m_nIndex;
    }
    // Throw away the trailing delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    return strToken;
}

template <class T>
T CSimpleStringToken<T>::String(void) const
{
    return m_strStr;
}

template <class T>
int CSimpleStringToken<T>::Index(void) const
{
    return m_nIndex;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\svselfil.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "svselfil.h"
#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>


HRESULT OpenShellFolder::OpenShellFolderAndSelectFile( HWND hWnd, const CSimpleDynamicArray<CSimpleString> &Filenames )
{
    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Make sure we have some files
    //
    if (Filenames.Size())
    {
        //
        // Save the path name from the first file
        //
        TCHAR szPath[MAX_PATH];
        StrCpyN( szPath, Filenames[0], ARRAYSIZE(szPath));

        //
        // Remove the filename and extension
        //
        if (PathRemoveFileSpec( szPath ))
        {
            //
            // Create the path's IDLIST
            //
            LPITEMIDLIST pidlFolder = NULL;
            if (SUCCEEDED(SHParseDisplayName( szPath, NULL, &pidlFolder, NULL, NULL )) && pidlFolder)
            if (pidlFolder)
            {
                //
                // Create an array to contain the list of filenames
                //
                LPCITEMIDLIST *ppidlFullyQualified = new LPCITEMIDLIST[Filenames.Size()];
                if (ppidlFullyQualified)
                {
                    //
                    // Make sure the array doesn't contain any wild pointers
                    //
                    ZeroMemory(ppidlFullyQualified,sizeof(LPCITEMIDLIST) * Filenames.Size() );

                    //
                    // Create the list of relative pidls
                    //
                    LPCITEMIDLIST *ppidlRelative = new LPCITEMIDLIST[Filenames.Size()];
                    if (ppidlRelative)
                    {
                        //
                        // Make sure the array doesn't contain any wild pointers
                        //
                        ZeroMemory(ppidlRelative,sizeof(LPCITEMIDLIST) * Filenames.Size() );

                        //
                        // Create the list of fully qualified pidls
                        //
                        int nFileCount = 0;
                        for (int i=0;i<Filenames.Size();i++)
                        {
                            //
                            // Get the fully qualified PIDL for this file
                            //
                            LPITEMIDLIST pidlFullyQualified = NULL;
                            if (SUCCEEDED(SHParseDisplayName( Filenames[i], NULL, &pidlFullyQualified, NULL, NULL )) && pidlFullyQualified)
                            {
                                //
                                // Get the last part of the PIDL
                                //
                                LPITEMIDLIST pidlRelative = ILFindLastID(pidlFullyQualified);
                                if (pidlRelative)
                                {
                                    //
                                    // Save the pidl in our list of fully qualified PIDLs and relative PIDLs
                                    //
                                    ppidlFullyQualified[nFileCount] = pidlFullyQualified;
                                    ppidlRelative[nFileCount] = pidlRelative;

                                    //
                                    // Increment the file count
                                    //
                                    nFileCount++;

                                    //
                                    // Set the fully qualified PIDL to NULL so we don't free it
                                    //
                                    pidlFullyQualified = NULL;
                                }

                                //
                                // If the PIDL is non-NULL here, free it.  Otherwise, it will get freed below.
                                //
                                if (pidlFullyQualified)
                                {
                                    ILFree(pidlFullyQualified);
                                }
                            }
                        }

                        //
                        // If we have a file count, open the folder and select the items
                        //
                        if (nFileCount)
                        {
                            hr = SHOpenFolderAndSelectItems( pidlFolder, nFileCount, ppidlRelative, 0 );
                        }

                        //
                        // Free all of the fully qualified PIDLs
                        //
                        for (int i=0;i<Filenames.Size();i++)
                        {
                            if (ppidlFullyQualified[i])
                            {
                                ILFree(const_cast<LPITEMIDLIST>(ppidlFullyQualified[i]));
                            }
                        }

                        //
                        // Free the PIDL array containing the relative pidls
                        //
                        delete[] ppidlRelative;
                    }

                    //
                    // Free the PIDL array containing the fully qualified pidls
                    //
                    delete[] ppidlFullyQualified;
                }

                //
                // Free the folder PIDL
                //
                ILFree(pidlFolder);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\simrect.h ===
#ifndef __SIMRECT_H_INCLUDED
#define __SIMRECT_H_INCLUDED

/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMRECT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/31/1999
 *
 *  DESCRIPTION: Simple rect derived class.  Especially handy for window coords.
 *
 *******************************************************************************/

#include <windows.h>

class CSimpleRect : public RECT
{
public:
    enum CWndRectType
    {
        ClientRect,
        WindowRect
    };

    CSimpleRect(void)
    {
        Assign(0,0,0,0);
    }

    CSimpleRect( const CSimpleRect &other )
    {
        Assign(other);
    }

    CSimpleRect( HWND hWnd, CWndRectType type = ClientRect )
    {
        Assign(0,0,0,0);
        if (ClientRect == type)
            GetClientRect(hWnd);
        else GetWindowRect(hWnd);
    }
    CSimpleRect( int nLeft, int nTop, int nRight, int nBottom )
    {
        Assign(nLeft,nTop,nRight,nBottom);
    }
    CSimpleRect &Assign( const CSimpleRect &other )
    {
        return(Assign(other.left,other.top,other.right,other.bottom));
    }
    CSimpleRect &Assign( int nLeft, int nTop, int nRight, int nBottom )
    {
        left = nLeft;
        top = nTop;
        right = nRight;
        bottom = nBottom;
        return(*this);
    }
    CSimpleRect &operator=( const CSimpleRect &other )
    {
        if (this == &other)
            return(*this);
        return(Assign(other));
    }
    static bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return (::MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    static bool ClientToScreen( HWND hwnd, RECT &rc )
    {
        return (::MapWindowPoints( hwnd, NULL, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    CSimpleRect ScreenToClient( HWND hWnd ) const
    {
        CSimpleRect rc(*this);
        ScreenToClient( hWnd, rc );
        return(rc);
    }
    CSimpleRect ClientToScreen( HWND hWnd ) const
    {
        CSimpleRect rc(*this);
        ClientToScreen( hWnd, rc );
        return(rc);
    }
    CSimpleRect &GetWindowRect( HWND hWnd )
    {
        ::GetWindowRect( hWnd, this );
        return(*this);
    }
    CSimpleRect &GetClientRect( HWND hWnd )
    {
        ::GetClientRect( hWnd, this );
        return(*this);
    }
    int Width(void) const
    {
        return(right - left);
    }
    int Height(void) const
    {
        return(bottom - top);
    }
    CSimpleRect &Inflate( int cx, int cy )
    {
        InflateRect( this, cx, cy );
        return *this;
    }
    CSimpleRect &Offset( int cx, int cy )
    {
        OffsetRect( this, cx, cy );
        return *this;
    }
};

#endif //__SIMRECT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\uicommon.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UICOMMON.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        4/19/1999
 *
 *  DESCRIPTION: Common include file for the UI library
 *
 *******************************************************************************/
#ifndef __UICOMMON_H_INCLUDED
#define __UICOMMON_H_INCLUDED

// Global new, delete handlers.  Use LocalAlloc.
#include "wianew.h"

// Various macros and helper functions that are in the WiaUiUtil namespace
#include "miscutil.h"

// Quick and dirty way to get a single string or long property from an IUnknown *
#include "pshelper.h"

// Function to create a scaled DIB (good for thumbnails)
#include "rescale.h"

// A handy class for passing around resource ids that can be either numeric or string
#include "resid.h"

// Dynamically sized array class
#include "simarray.h"

// BSTR wrapper
#include "simbstr.h"

// Simple critical section wrapper with extremely handy auto critical sections
#include "simcrit.h"

// Dynamic singly linked list template class, and derivatives: queue and stack
#include "simlist.h"

// A class for setting and getting registry variables
#include "simreg.h"

// String classes
#include "simstr.h"

// String tokenizer
#include "simtok.h"

#include "waitcurs.h"
#include "errors.h"


// Delimited string tokenizer class
#include "delimstr.h"

#endif // __UICOMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\tspqueue.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       TSPQUEUE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Thread Safe Priority Queue template class
 *
 *******************************************************************************/
#ifndef __TSPQUEUE_H_INCLUDED
#define __TSPQUEUE_H_INCLUDED

#include "simevent.h"
#include "simcrit.h"
#include "miscutil.h"

template <class T>
class CThreadSafePriorityQueue
{
public:
    enum
    {
        PriorityLow    = 1,
        PriorityNormal = 2,
        PriorityHigh   = 3,
        PriorityUrgent = 4
    };

private:
    class CQueueNode
    {
    private:
        T          *m_pData;
        int         m_nPriority;
        CQueueNode *m_pNext;
    public:
        CQueueNode( T *pData, int nPriority=PriorityNormal )
            : m_pData(NULL), m_nPriority(nPriority), m_pNext(NULL)
        {
            m_pData = pData;
        }
        virtual ~CQueueNode(void)
        {
            if (m_pData)
            {
                delete m_pData;
                m_pData = NULL;
            }
            m_pNext = NULL;
        }
        const CQueueNode *Next(void) const
        {
            return m_pNext;
        }
        CQueueNode *Next(void)
        {
            return m_pNext;
        }
        CQueueNode *Next( CQueueNode *pNext )
        {
            return (m_pNext=pNext);
        }

        T *DetachData()
        {
            T *pResult = m_pData;
            m_pData = NULL;
            return pResult;
        }

        const T *Data(void) const
        {
            return m_pData;
        }
        T *Data(void)
        {
            return m_pData;
        }

        int Priority(void) const
        {
            return m_nPriority;
        }
        int Priority( int nPriority )
        {
            return (m_nPriority=nPriority);
        }
    };

private:
    CQueueNode *m_pHead;
    mutable CSimpleCriticalSection m_CriticalSection;
    CSimpleEvent m_QueueEvent;
    CSimpleEvent m_PauseEvent;

private:
    // No implementation
    CThreadSafePriorityQueue( const CThreadSafePriorityQueue & );
    CThreadSafePriorityQueue &operator=( const CThreadSafePriorityQueue & );

public:
    CThreadSafePriorityQueue(void)
      : m_pHead(NULL)
    {
        m_QueueEvent.Reset();
        m_PauseEvent.Signal();
    }
    ~CThreadSafePriorityQueue(void)
    {
        CAutoCriticalSection cs(m_CriticalSection);
        while (m_pHead)
        {
            CQueueNode *pCurr = m_pHead;
            m_pHead = m_pHead->Next();
            delete pCurr;
        }
    }

    bool Empty( void ) const
    {
        CAutoCriticalSection cs(m_CriticalSection);
        return (NULL == m_pHead);
    }

    CQueueNode *Enqueue( T *pData, int nPriority=PriorityNormal )
    {
        //
        // Grab the critical section
        //
        CAutoCriticalSection cs(m_CriticalSection);

        //
        // Assume we will not be able to add a new item to the queue
        //
        CQueueNode *pResult = NULL;

        //
        // Make sure we have a valid data item
        //
        if (pData)
        {

            //
            // Try to allocate a new queue node
            //
            pResult  = new CQueueNode(pData,nPriority);
            if (pResult)
            {
                //
                // This might be the first item in the queue
                //
                bool bMaybeSignal = Empty();

                //
                // If this is an empty queue or we need to do it right away, put it at the head of the queue
                //
                if (!m_pHead || pResult->Priority() >= PriorityUrgent)
                {
                    pResult->Next(m_pHead);
                    m_pHead = pResult;
                }
                else
                {
                    //
                    // Find the right place to put it
                    //
                    CQueueNode *pCurr = m_pHead;
                    CQueueNode *pPrev = NULL;
                    while (pCurr && pCurr->Priority() >= pResult->Priority())
                    {
                        pPrev = pCurr;
                        pCurr = pCurr->Next();
                    }

                    //
                    // Insert it in the proper place
                    //
                    if (pPrev)
                    {
                        pResult->Next(pCurr);
                        pPrev->Next(pResult);
                    }
                    else
                    {
                        pResult->Next(m_pHead);
                        m_pHead = pResult;
                    }
                }

                //
                // If we were able to allocate the item, and the list isn't empty, signal the queue
                //
                if (bMaybeSignal && !Empty())
                {
                    //
                    // Got one!
                    //
                    Signal();

                    //
                    // Force a yield if this is a high priority message
                    //
                    if (pResult->Priority() >= PriorityHigh)
                    {
                        Sleep(0);
                    }
                }
            }

        }
        return pResult;
    }

    T *Dequeue(void)
    {
        //
        // Grab the critical section
        //
        CAutoCriticalSection cs(m_CriticalSection);

        //
        // Wait until we are not paused
        //
        WiaUiUtil::MsgWaitForSingleObject( m_PauseEvent.Event(), INFINITE );

        //
        // If there are no items, return
        //
        if (Empty())
        {
            return NULL;
        }

        //
        // Grab the first item
        //
        CQueueNode *pFront = m_pHead;

        //
        // Advance to the next item
        //
        m_pHead = m_pHead->Next();

        //
        // Get the data
        //
        T *pResult = pFront->DetachData();

        //
        // Delete the queue item
        //
        delete pFront;

        //
        // If the queue is now empty, reset the event
        //
        if (Empty())
        {
            m_QueueEvent.Reset();
        }

        //
        // Return any data we got
        //
        return pResult;
    }

    void Pause(void)
    {
        m_PauseEvent.Reset();
    }
    void Resume(void)
    {                               
        m_PauseEvent.Signal();
    }


    void Signal(void)
    {
        m_QueueEvent.Signal();
    }

    HANDLE QueueEvent(void)
    {
        return m_QueueEvent.Event();
    }
};

#endif //__TSPQUEUE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\sysprops.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       sysprops.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/24/1999
 *
 *  DESCRIPTION: Implementation of property sheet helpers.  Removed from miscutil,
 *               because it required clients to link to comctl32.dll
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <shellext.h> // for property page functions
#include "devlist.h" // for property page functions
#include <initguid.h>
#include "wiapropui.h"
DEFINE_GUID (CLSID_WiaPropHelp, 0x83bbcbf3,0xb28a,0x4919,0xa5, 0xaa, 0x73, 0x02, 0x74, 0x45, 0xd6, 0x72);

DEFINE_GUID (IID_IWiaPropUI,  /* 7eed2e9b-acda-11d2-8080-00805f6596d2 */
    0x7eed2e9b,
    0xacda,
    0x11d2,
    0x80, 0x80, 0x00, 0x80, 0x5f, 0x65, 0x96, 0xd2
  );

namespace WiaUiUtil
{
    HRESULT SystemPropertySheet( HINSTANCE hInstance, HWND hwndParent, IWiaItem *pWiaItem, LPCTSTR pszCaption )
    {
        CWaitCursor wc;

        CComPtr<IWiaPropUI> pWiaPropUI;
        HRESULT hr = CoCreateInstance (CLSID_WiaPropHelp, NULL, CLSCTX_INPROC_SERVER, IID_IWiaPropUI, reinterpret_cast<LPVOID*>(&pWiaPropUI));
        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADER PropSheetHeader = {0};
            PropSheetHeader.dwSize = sizeof(PropSheetHeader);
            PropSheetHeader.hwndParent = hwndParent;
            PropSheetHeader.hInstance = hInstance;
            PropSheetHeader.pszCaption = pszCaption;
            hr = pWiaPropUI->GetItemPropertyPages( pWiaItem, &PropSheetHeader );
            if (SUCCEEDED(hr))
            {
                if (PropSheetHeader.nPages)
                {
                    //
                    // Modal property sheets really don't need an apply button...
                    //
                    PropSheetHeader.dwFlags |= PSH_NOAPPLYNOW;

                    INT_PTR nResult = PropertySheet(&PropSheetHeader);

                    if (PropSheetHeader.phpage)
                    {
                        LocalFree(PropSheetHeader.phpage);
                    }

                    if (nResult < 0)
                    {
                        hr = E_FAIL;
                    }
                    else if (IDOK == nResult)
                    {
                        hr = S_OK;
                    }
                    else hr = S_FALSE;
                }
                else
                {
                    hr = PROP_SHEET_ERROR_NO_PAGES;
                }
            }
        }
        return hr;
    }

    // Be careful calling this function.  It is hideously slow...
    HRESULT GetDeviceInfoFromId( LPCWSTR pwszDeviceId, IWiaPropertyStorage **ppWiaPropertyStorage )
    {
        // Check parameters
        if (!pwszDeviceId || !*pwszDeviceId)
        {
            return E_INVALIDARG;
        }
        if (!ppWiaPropertyStorage)
        {
            return E_POINTER;
        }

        // Initialize the return value
        *ppWiaPropertyStorage = NULL;

        CSimpleString strDeviceId = CSimpleStringConvert::NaturalString(CSimpleStringWide(pwszDeviceId));

        CComPtr<IWiaDevMgr> pWiaDevMgr;
        HRESULT hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            // Assume we are going to fail.  This will also cover the case where there are no devices.
            hr = E_FAIL;
            CDeviceList deviceList( pWiaDevMgr );
            for (int i=0;i<deviceList.Size();i++)
            {
                CSimpleStringWide strwCurrDeviceId;
                if (PropStorageHelpers::GetProperty(deviceList[i],WIA_DIP_DEV_ID,strwCurrDeviceId))
                {
                    CSimpleString strCurrDeviceId = CSimpleStringConvert::NaturalString(strwCurrDeviceId);
                    if (strCurrDeviceId == strDeviceId)
                    {
                        *ppWiaPropertyStorage = deviceList[i];
                        if (*ppWiaPropertyStorage)
                            (*ppWiaPropertyStorage)->AddRef();
                        hr = S_OK;
                        break;
                    }
                }
            }
        }
        return hr;
    }

    // Be careful calling this function.  It is hideously slow...
    HRESULT GetDeviceTypeFromId( LPCWSTR pwszDeviceId, LONG *pnDeviceType )
    {
        // Check parameters
        if (!pwszDeviceId || !*pwszDeviceId)
        {
            return E_INVALIDARG;
        }
        if (!pnDeviceType)
        {
            return E_POINTER;
        }

        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = GetDeviceInfoFromId( pwszDeviceId, &pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            LONG nDeviceType;
            if (PropStorageHelpers::GetProperty(pWiaPropertyStorage,WIA_DIP_DEV_TYPE,nDeviceType))
            {
                *pnDeviceType = nDeviceType;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        return hr;
    }

    // Ask WIA for the default event handler for the device
    HRESULT GetDefaultEventHandler (IWiaItem *pItem, const GUID &guidEvent, WIA_EVENT_HANDLER *pwehHandler)
    {
        HRESULT hr;
        IEnumWIA_DEV_CAPS *pEnum;
        WIA_EVENT_HANDLER weh;
        ZeroMemory (pwehHandler, sizeof(WIA_EVENT_HANDLER));
        hr = pItem->EnumRegisterEventInfo (0,
                                           &guidEvent,
                                           &pEnum);
        if (SUCCEEDED(hr))
        {
            ULONG ul;
            bool bFound = false;
            while (!bFound && NOERROR == pEnum->Next (1, &weh, &ul))
            {
                if (weh.ulFlags & WIA_IS_DEFAULT_HANDLER)
                {
                    bFound = true;
                    CopyMemory (pwehHandler, &weh, sizeof(weh));
                }
                else
                {
                    if (weh.bstrDescription)
                    {
                        SysFreeString (weh.bstrDescription);
                    }
                    if (weh.bstrIcon)
                    {
                        SysFreeString (weh.bstrIcon);
                    }
                    if (weh.bstrName)
                    {
                        SysFreeString (weh.bstrName);
                    }
                }

            }
            if (!bFound)
            {
                hr = E_FAIL;
            }
            pEnum->Release ();
        }
        return hr;
    }


    /******************************************************************************

    ItemAndChildrenCount

    Returns the number of items, including root + children

    ******************************************************************************/

    LONG
    ItemAndChildrenCount (IWiaItem *pRoot)
    {
        LONG count = 0;
        HRESULT hr = S_OK;
        IEnumWiaItem *pEnum;
        LONG lType;

        if (pRoot)
        {

            if (SUCCEEDED(pRoot->EnumChildItems(&pEnum)))
            {
                IWiaItem *pChild;

                while (NOERROR == pEnum->Next(1, &pChild, NULL))
                {
                    count++;
                    pChild->Release ();
                }
                pEnum->Release ();

            }

            //
            // See if we should count the root item
            //

            pRoot->GetItemType(&lType);
            if (!(lType & WiaItemTypeRoot))
            {
                count++;
            }


        }

        return count;
    }


    /******************************************************************************

    DeleteItemAndChildren

    Deletes all items in the tree under pRoot

    ******************************************************************************/

    HRESULT
    DeleteItemAndChildren (IWiaItem *pRoot)
    {
        HRESULT hr = S_OK;
        IEnumWiaItem *pEnum;

        if (pRoot)
        {
            // Recurse down til we reach a leaf item
            if (SUCCEEDED(pRoot->EnumChildItems(&pEnum)))
            {
                IWiaItem *pChild;

                while (SUCCEEDED(hr) && NOERROR == pEnum->Next(1, &pChild, NULL))
                {
                    hr = DeleteItemAndChildren (pChild);
                    pChild->Release ();
                }
                pEnum->Release ();
            }
            // now delete the item itself
            // if a delete on a child item failed, stop trying
            // to delete because chances are any subsequent delete
            // is going to fail as well.
            if (SUCCEEDED(hr))
            {
                // don't delete the very root item
                LONG lType;
                pRoot->GetItemType(&lType);
                if (!(lType & WiaItemTypeRoot))
                {
                    hr = pRoot->DeleteItem(0);

                }
            }
        }
        return hr;
    }

} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\uiexthlp.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UIEXTHLP.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/8/1999
 *
 *  DESCRIPTION: Helper functions for loading UI extensions for WIA devices
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <initguid.h>
#include "uiexthlp.h"
#include "wiadevd.h"
#include "wiadevdp.h"
#include "itranhlp.h"
#include "isuppfmt.h"
#include "wiaffmt.h"

namespace WiaUiExtensionHelper
{
    /*
     * Get the clsid of the DLL that implements the interface in the given category
     * Example: GetDeviceExtensionClassID( L"{5d8ef5a3-ac13-11d2-a093-00c04f72dc3c}", TEXT("WiaDialogExtensionHandlers"), iid );
     * where:
     *     L"{5d8ef5a3-ac13-11d2-a093-00c04f72dc3c}" is the GUID stored in the WIA property WIA_DIP_UI_CLSID
     *     TEXT("WiaDialogExtensionHandlers") is the category of extension
     *     iid is a reference to the CLSID of the in process COM object
     */
    HRESULT GetDeviceExtensionClassID( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, IID &iidClassID )
    {
        TCHAR szRootKeyName[1024];
        HRESULT hr = E_FAIL;
        // Make sure all of the parameters are valid
        if (pwszUiClassId && pszCategory && lstrlenW(pwszUiClassId) && lstrlen(pszCategory))
        {
            // construct the key name
            wnsprintf( szRootKeyName, ARRAYSIZE(szRootKeyName), TEXT("CLSID\\%ws\\shellex\\%s"), pwszUiClassId, pszCategory );
            HKEY hKeyRoot;
            // open the reg key
            DWORD dwResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, szRootKeyName, 0, KEY_READ, &hKeyRoot );
            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szClassID[MAX_PATH];
                DWORD dwLength = ARRAYSIZE(szClassID);
                // Note that we only take the first one
                dwResult = RegEnumKeyEx( hKeyRoot, 0, szClassID, &dwLength, NULL, NULL, NULL, NULL );
                if (ERROR_SUCCESS == dwResult)
                {
#if defined(UNICODE)
                    hr = CLSIDFromString(szClassID, &iidClassID);
#else
                    WCHAR wszClassID[MAX_PATH];
                    MultiByteToWideChar (CP_ACP, 0, szClassID, -1, wszClassID, MAX_PATH );
                    hr = CLSIDFromString (wszClassID, &iidClassID);
#endif
                }
                else hr = HRESULT_FROM_WIN32(dwResult);
                RegCloseKey(hKeyRoot);
            }
            else hr = HRESULT_FROM_WIN32(dwResult);
        }
        else hr = E_INVALIDARG;
        return hr;
    }

    HRESULT CreateDeviceExtension( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
    {
        IID iidClassID;
        HRESULT hr = GetDeviceExtensionClassID( pwszUiClassId, pszCategory, iidClassID );
        if (SUCCEEDED(hr))
        {
            WIA_PRINTGUID((iidClassID,TEXT("Calling CoCreateInstance on")));
            WIA_PRINTGUID((iid,TEXT("Attempting to get an interface pointer for")));
            hr = CoCreateInstance( iidClassID, NULL, CLSCTX_INPROC_SERVER, iid, ppvObject );
        }
        return hr;
    }

    HRESULT GetUiGuidFromWiaItem( IWiaItem *pWiaItem, LPWSTR pwszGuid )
    {
        IWiaPropertyStorage *pPropertyStorage = NULL;
        HRESULT hr;
        if (pWiaItem && pwszGuid)
        {
            hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)&pPropertyStorage );
            if (SUCCEEDED(hr))
            {
                PROPSPEC ps[1];
                PROPVARIANT  pv[1];
                ps[0].ulKind = PRSPEC_PROPID;
                ps[0].propid = WIA_DIP_UI_CLSID;
                hr = pPropertyStorage->ReadMultiple(sizeof(ps)/sizeof(ps[0]), ps, pv);
                if (SUCCEEDED(hr))
                {
                    if (VT_LPWSTR == pv[0].vt || VT_BSTR == pv[0].vt)
                    {
                        lstrcpyW( pwszGuid, pv[0].bstrVal );
                        hr = S_OK;
                    }
                    FreePropVariantArray( sizeof(pv)/sizeof(pv[0]), pv );
                }
                pPropertyStorage->Release();
            }
        }
        else hr = E_INVALIDARG;
        return hr;
    }

    HRESULT GetDeviceExtensionClassID( IWiaItem *pWiaItem, LPCTSTR pszCategory, IID &iidClassID )
    {
        WCHAR wszGuid[MAX_PATH];
        HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid);
        if (SUCCEEDED(hr))
        {
            hr = GetDeviceExtensionClassID( wszGuid, pszCategory, iidClassID );
        }
        return hr;
    }

    HRESULT CreateDeviceExtension( IWiaItem *pWiaItem, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
    {

        WCHAR wszGuid[MAX_PATH];
        HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid);
        if (SUCCEEDED(hr))
        {
            hr = CreateDeviceExtension( wszGuid, pszCategory, iid, ppvObject );
        }
        return hr;
    }

    HRESULT GetDeviceIcons( IWiaUIExtension *pWiaUIExtension, BSTR bstrDeviceId, HICON *phIconSmall, HICON *phIconLarge, UINT nIconSize )
    {
        if (!pWiaUIExtension || !bstrDeviceId || !lstrlenW(bstrDeviceId))
            return E_INVALIDARG;

        // Assume success
        HRESULT hr = S_OK;

        // Get the small icon, if requested.  Return on failure
        if (phIconSmall)
        {
            hr = pWiaUIExtension->GetDeviceIcon(bstrDeviceId,phIconSmall,HIWORD(nIconSize));
            if (FAILED(hr))
            {
                return hr;
            }
        }

        // Get the large icon, if requested.  Return on failure
        if (phIconLarge)
        {
            hr = pWiaUIExtension->GetDeviceIcon(bstrDeviceId,phIconLarge,LOWORD(nIconSize));
            if (FAILED(hr))
            {
                return hr;
            }
        }
        return hr;
    }

    HRESULT GetDeviceIcons( BSTR bstrDeviceId, LONG nDeviceType, HICON *phIconSmall, HICON *phIconLarge, UINT nIconSize )
    {
        WIA_PUSH_FUNCTION((TEXT("GetDeviceIcons( %ws, %08X, %p, %p, %d )"), bstrDeviceId, nDeviceType, phIconSmall, phIconLarge, nIconSize ));

        // Check args
        if (!bstrDeviceId || !lstrlenW(bstrDeviceId))
        {
            return E_INVALIDARG;
        }

        // Initialize the icons, if necessary
        if (phIconSmall)
        {
            *phIconSmall = NULL;
        }
        if (phIconLarge)
        {
            *phIconLarge = NULL;
        }

        if (!nIconSize)
        {
            int iLarge = GetSystemMetrics(SM_CXICON);
            int iSmall = GetSystemMetrics(SM_CXSMICON);
            nIconSize = (UINT)MAKELONG(iLarge, iSmall);
        }

        // Assume we'll use our own icons
        bool bUseDefaultUI = true;

        // Try to load device ui extension
        CComPtr<IWiaUIExtension> pWiaUIExtension;
        HRESULT hr = WiaUiExtensionHelper::CreateDeviceExtension( bstrDeviceId, SHELLEX_WIAUIEXTENSION_NAME, IID_IWiaUIExtension, (void **)&pWiaUIExtension );
        if (SUCCEEDED(hr))
        {
            hr = GetDeviceIcons( pWiaUIExtension, bstrDeviceId, phIconSmall, phIconLarge, nIconSize );
            if (SUCCEEDED(hr) || hr != E_NOTIMPL)
            {
                bUseDefaultUI = false;
            }
            WIA_PRINTHRESULT((hr,TEXT("GetDeviceIcons returned")));
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("WiaUiExtensionHelper::CreateDeviceExtension failed")));
        }

        WIA_TRACE((TEXT("bUseDefaultUI: %d"), bUseDefaultUI ));
        // Use our own extensions (the default UI).   We use IWiaMiscellaneousHelpers::GetDeviceIcon, because
        // finding the device type given only a device id is horribly slow, since we have to create a device
        // manager AND enumerate devices until we find a match.  Ugh.
        if (bUseDefaultUI)
        {
            CComPtr<IWiaMiscellaneousHelpers> pWiaMiscellaneousHelpers;
            hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaMiscellaneousHelpers, (void**)(&pWiaMiscellaneousHelpers) );
            if (SUCCEEDED(hr) && phIconSmall)
            {
                hr = pWiaMiscellaneousHelpers->GetDeviceIcon( nDeviceType, phIconSmall, HIWORD(nIconSize));
            }
            if (SUCCEEDED(hr) && phIconLarge)
            {
                hr = pWiaMiscellaneousHelpers->GetDeviceIcon( nDeviceType, phIconLarge, LOWORD(nIconSize) );
            }
            if (FAILED(hr))
            {
                if (phIconSmall && *phIconSmall)
                {
                    DestroyIcon(*phIconSmall);
                }
                if (phIconLarge && *phIconLarge)
                {
                    DestroyIcon(*phIconLarge);
                }
            }
        }
        return hr;
    }

    CSimpleString GetExtensionFromGuid( IWiaItem *pWiaItem, const GUID &guidFormat )
    {
        //
        // Use the supplied format to get the extension
        //
        GUID guidFormatToUse = guidFormat;

        //
        // If we don't have a supplied format, get the default format and use that
        //
        if (IID_NULL == guidFormatToUse)
        {
            //
            // Get the IWiaSupportedFormats interface
            //
            CComPtr<IWiaSupportedFormats> pWiaSupportedFormats;
            HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaSupportedFormats, (void**)&pWiaSupportedFormats );
            if (SUCCEEDED(hr))
            {
                //
                // Tell it we want file information for pWiaItem
                //
                hr = pWiaSupportedFormats->Initialize( pWiaItem, TYMED_FILE );
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the default format
                    //
                    GUID guidDefFormat;
                    hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &guidDefFormat );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Save this format and use it.
                        //
                        guidFormatToUse = guidDefFormat;
                    }
                }
            }
        }
        
        return CWiaFileFormat::GetExtension( guidFormatToUse, TYMED_FILE, pWiaItem );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiacrc32.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CRC32.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/7/2000
 *
 *  DESCRIPTION: Generate a 32bit CRC.
 *
 *               This code was taken from \nt\base\ntos\rtl\checksum.c and modified.
 *
 *               A verified test case for this algorithm is that "123456789"
 *               should return 0xCBF43926.
 *
 *******************************************************************************/
#ifndef __WIACRC32_H_INCLUDED
#define __WIACRC32_H_INCLUDED

#include <windows.h>

namespace WiaCrc32
{
    DWORD GenerateCrc32( DWORD cbBuffer, PVOID pvBuffer );
    DWORD GenerateCrc32Handle( HANDLE hFile );
    DWORD GenerateCrc32File( LPCTSTR pszFilename );
}


#endif // __WIACRC32_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\uiexthlp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UIEXTHLP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/8/1999
 *
 *  DESCRIPTION: Helper functions for loading UI extensions for WIA devices
 *
 *******************************************************************************/
#ifndef __UIEXTHLP_H_INCLUDED
#define __UIEXTHLP_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

namespace WiaUiExtensionHelper
{
    HRESULT GetDeviceExtensionClassID(
        LPCWSTR pszID,
        LPCTSTR pszCategory,
        IID &iidClassID
        );
    HRESULT CreateDeviceExtension(
        LPCWSTR pszID,
        LPCTSTR pszCategory,
        const IID &iid,
        void **ppvObject
        );
    HRESULT GetUiGuidFromWiaItem(
        IWiaItem *pWiaItem,
        LPWSTR pszGuid
        );
    HRESULT GetDeviceExtensionClassID(
        IWiaItem *pWiaItem,
        LPCTSTR pszCategory,
        IID &iidClassID
        );
    HRESULT CreateDeviceExtension(
        IWiaItem *pWiaItem,
        LPCTSTR pszCategory,
        const IID &iid,
        void **ppvObject
        );
    HRESULT GetDeviceIcons(
        BSTR bstrDeviceId,
        LONG nDeviceType,
        HICON *phIconSmall,
        HICON *phIconLarge,
        UINT nIconSize = 0 // 0 means default sizes
        );
    CSimpleString GetExtensionFromGuid(
        IWiaItem *pWiaItem,
        const GUID &guidFormat
        );
}

#endif //__UIEXTHLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiacrc32.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WIACRC32.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/7/2000
 *
 *  DESCRIPTION: Generate a 32bit CRC.
 *
 *               This code was taken from \nt\base\ntos\rtl\checksum.c and modified.
 *
 *               A verified test case for this algorithm is that "123456789"
 *               should return 0xCBF43926.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "wiacrc32.h"

namespace WiaCrc32
{
    /*
    This is the precomputed data table for the CRC32 algorithm as specified in
    IS0 3309.  See RFC-1662 and RFC-1952 for implementation details and
    references.

    To calculate this table, use the following function:

    void PrintCrcTable (void)
    {
        DWORD Val;
        ULONG i, k;

        for (i = 0; i < 256; i++)
        {
            Val = (ULONG) i;
            for (k = 0; k < 8; k++)
            {
                if (Val & 1)
                {
                    Val = 0xedb88320L ^ (Val >> 1);
                }
                else
                {
                    Val = Val >> 1;
                }
            }

            printf( "0x%08X, ", Val);

            if ((i+1) % 6 == 0)
            {
                printf("\n");
            }
        }
    }
    */


    static const DWORD s_CrcTable[256] =
    {
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
        0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
        0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
        0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
        0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
        0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
        0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
        0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
        0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
        0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
        0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
        0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
        0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
        0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
        0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
        0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
        0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
        0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
        0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
        0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
        0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
        0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
        0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
        0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
        0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
        0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
        0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
        0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
        0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
        0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
        0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
        0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
        0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
        0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
        0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
        0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
        0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
        0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
        0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
        0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
        0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };


    DWORD GenerateCrc32( DWORD cbBuffer, PVOID pvBuffer )
    {
        DWORD dwResult = 0xFFFFFFFF;
        PBYTE pbBuffer = reinterpret_cast<PBYTE>(pvBuffer);
        if (pbBuffer)
        {
            for (DWORD i=0;i<cbBuffer;i++)
            {
                dwResult = (dwResult >> 8) ^ s_CrcTable[static_cast<BYTE>(dwResult ^ static_cast<DWORD>(pbBuffer[i]))];
            }
        }
        return dwResult ^ 0xFFFFFFFF;
    }

    DWORD GenerateCrc32Handle( HANDLE hFile )
    {
        DWORD dwResult = 0;
        DWORD dwSize = GetFileSize( hFile, NULL );
        if (dwSize != static_cast<DWORD>(-1))
        {
            HANDLE hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, dwSize, NULL );
            if (hFileMapping)
            {
                PBYTE pData = reinterpret_cast<PBYTE>(MapViewOfFile( hFileMapping, FILE_MAP_READ, 0, 0, dwSize ));
                if (pData)
                {
                    __try
                    {
                        dwResult = GenerateCrc32( dwSize, pData );
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        dwResult = 0;
                    }
                    UnmapViewOfFile( pData );
                }
                CloseHandle(hFileMapping);
            }
        }
        return dwResult;
    }

    DWORD GenerateCrc32File( LPCTSTR pszFilename )
    {
        DWORD dwResult = 0;
        HANDLE hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if (INVALID_HANDLE_VALUE != hFile)
        {
            dwResult = GenerateCrc32Handle( hFile );
            CloseHandle(hFile);
        }
        return dwResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiacsh.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIACSH.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/20/2000
 *
 *  DESCRIPTION: Helper functions for context sensitive help
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "wiacsh.h"

//
// If the help ID is >= this number, it must be an item that lives in windows.hlp,
// otherwise, it lives in whatever the WIA help file is called (currently camera.hlp)
//
#define MAX_WIA_HELP_ID 20000

namespace WiaHelp
{
    static LPCTSTR DetermineHelpFileName( HWND hWnd, const DWORD *pdwContextIds )
    {
        //
        // Can't happen, but still...
        //
        if (!pdwContextIds)
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        //
        // If it isn't a window, it isn't a standard id
        //
        if (!hWnd || !IsWindow(hWnd))
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        //
        // If it doesn't have a window id, it isn't a standard id either
        //
        LONG nWindowId = GetWindowLong( hWnd, GWL_ID );
        if (!nWindowId)
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        for (const DWORD *pdwCurr = pdwContextIds;*pdwCurr;pdwCurr+=2)
        {
            //
            // If this is the window ID we are looking for...
            //
            if (nWindowId == static_cast<LONG>(pdwCurr[0]))
            {
                //
                // return true if its help id is greater than or equal to the max legal id number for wia
                //
                return (pdwCurr[1] >= MAX_WIA_HELP_ID ? WIA_STANDARD_HELP_FILE : WIA_SPECIFIC_HELP_FILE);
            }
        }

        //
        // Not found
        //
        return WIA_SPECIFIC_HELP_FILE;
    }

    LRESULT HandleWmHelp( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds )
    {
        if (pdwContextIds)
        {
            LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
            if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                //
                // Call WinHelp
                //
                WinHelp(
                    reinterpret_cast<HWND>(pHelpInfo->hItemHandle),
                    DetermineHelpFileName( reinterpret_cast<HWND>(pHelpInfo->hItemHandle), pdwContextIds ),
                    HELP_WM_HELP,
                    reinterpret_cast<ULONG_PTR>(pdwContextIds)
                );
            }
        }
        return 0;
    }

    LRESULT HandleWmContextMenu( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds )
    {
        if (pdwContextIds)
        {
            HWND hWnd = reinterpret_cast<HWND>(wParam);
            if (hWnd)
            {
                //
                // Call WinHelp
                //
                WinHelp(
                    hWnd,
                    DetermineHelpFileName( hWnd, pdwContextIds ),
                    HELP_CONTEXTMENU,
                    reinterpret_cast<ULONG_PTR>(pdwContextIds)
                );
            }
        }
        return 0;
    }

} // End namespace WiaHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\vwiaset.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       VWIASET.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/10/2000
 *
 *  DESCRIPTION: Encapsulate the differences between LIST and RANGE properties
 *
 *******************************************************************************/

#ifndef __VWIASET_H_INCLUDED
#define __VWIASET_H_INCLUDED

#include <windows.h>
#include "pshelper.h"

class CValidWiaSettings
{
private:
    //
    // Indices into array for range values
    //
    enum
    {
        MinValue = 0,
        MaxValue = 1,
        StepValue = 2
    };

private:
    CSimpleDynamicArray<LONG> m_ValueList;
    LONG                      m_nInitialValue;
    LONG                      m_nType;

public:
    CValidWiaSettings(void)
      : m_nType(0),
        m_nInitialValue(0)
    {
    }
    CValidWiaSettings( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName )
      : m_nType(0),
        m_nInitialValue(0)
    {
        Read( pUnknown, propertyName );
    }
    CValidWiaSettings( const CValidWiaSettings &other )
      : m_nType(0),
        m_nInitialValue(0)
    {
        Assign(other);
    }
    CValidWiaSettings &operator=( const CValidWiaSettings &other )
    {
        if (&other != this)
        {
            Assign(other);
        }
        return *this;
    }
    CValidWiaSettings &Assign( const CValidWiaSettings &other )
    {
        Destroy();
        m_nType = other.Type();
        m_ValueList = other.ValueList();
        m_nInitialValue = other.InitialValue();
        if (!IsValid())
        {
            Destroy();
        }
        return *this;
    }
    LONG Type(void) const
    {
        return m_nType;
    }
    LONG InitialValue(void) const
    {
        return m_nInitialValue;
    }
    const CSimpleDynamicArray<LONG> &ValueList(void) const
    {
        return m_ValueList;
    }
    CSimpleDynamicArray<LONG> &ValueList(void)
    {
        return m_ValueList;
    }
    void Destroy(void)
    {
        m_nType = 0;
        m_nInitialValue = 0;
        m_ValueList.Destroy();
    }
    bool IsValid(void) const
    {
        if (IsList())
        {
            return (m_ValueList.Size() != 0);
        }
        else if (IsRange())
        {
            return (m_ValueList.Size() == 3);
        }
        else return false;
    }
    bool Read( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName )
    {
        bool bSuccess = false;
        Destroy();
        m_nType = 0;

        //
        // If we can't read this value, we're done
        //
        if (!PropStorageHelpers::GetProperty( pUnknown, propertyName, m_nInitialValue ))
        {
            return false;
        }

        ULONG nAccessFlags;
        if (PropStorageHelpers::GetPropertyAccessFlags( pUnknown, propertyName, nAccessFlags ))
        {
            if (nAccessFlags & WIA_PROP_LIST)
            {
                if (PropStorageHelpers::GetPropertyList( pUnknown, propertyName, m_ValueList ))
                {
                    m_nType = WIA_PROP_LIST;
                    bSuccess = (m_ValueList.Size() != 0);
                }
            }
            else if (nAccessFlags & WIA_PROP_RANGE)
            {
                PropStorageHelpers::CPropertyRange PropertyRange;
                if (PropStorageHelpers::GetPropertyRange( pUnknown, propertyName, PropertyRange ))
                {
                    m_nType = WIA_PROP_RANGE;
                    m_ValueList.Append( PropertyRange.nMin );
                    m_ValueList.Append( PropertyRange.nMax );
                    m_ValueList.Append( PropertyRange.nStep );
                    bSuccess = (m_ValueList.Size() == 3);
                }
            }
        }
        if (!bSuccess)
        {
            Destroy();
        }
        return bSuccess;
    }
    bool FindClosestValueByRoundingDown( LONG &nValue ) const
    {
        //
        // Make sure we have a valid item
        //
        if (!IsValid())
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Make sure we are in the legal range
            //
            nValue = WiaUiUtil::Min( WiaUiUtil::Max( m_ValueList[MinValue], nValue ), m_ValueList[MaxValue] );

            //
            // Divide the difference between nValue and min by nStep, then multiply by nStep to
            // get rid of the remainder to round down to the nearest value
            //
            nValue = m_ValueList[MinValue] + (((nValue - m_ValueList[MinValue]) / m_ValueList[StepValue]) * m_ValueList[StepValue]);
            return true;
        }
        else if (IsList() && m_ValueList.Size())
        {
            //
            // Assume the list is sorted, so we can take the first item and assume it is the minimum value
            //
            LONG nResult = m_ValueList[0];
            for (int i=0;i<m_ValueList.Size();i++)
            {
                if (m_ValueList[i] > nValue)
                {
                    break;
                }
                nResult = m_ValueList[i];
            }
            nValue = nResult;
            return true;
        }
        return false;
    }
    bool FindClosestValue( LONG &nValue ) const
    {
        LONG nFloor=nValue;
        if (FindClosestValueByRoundingDown(nFloor))
        {
            LONG nCeiling=nFloor;
            if (Increment(nCeiling))
            {
                if (nValue - nFloor < nCeiling - nValue)
                {
                    nValue = nFloor;
                    return true;
                }
                else
                {
                    nValue = nCeiling;
                    return true;
                }
            }
        }
        return false;
    }
    bool IsLegalValue( LONG nValue ) const
    {
        LONG nTestValue = nValue;
        if (FindClosestValueByRoundingDown(nTestValue))
        {
            return (nTestValue == nValue);
        }
        return false;
    }
    int FindIndexOfItem( LONG nCurrentValue ) const
    {
        if (IsRange())
        {
            //
            // Make sure we are in the legal range
            //
            nCurrentValue = WiaUiUtil::Min( WiaUiUtil::Max( m_ValueList[MinValue], nCurrentValue ), m_ValueList[MaxValue] );

            return (nCurrentValue - m_ValueList[MinValue]) / m_ValueList[StepValue];
        }
        else if (IsList() && m_ValueList.Size())
        {
            //
            // Assume the list is sorted, so we can take the first item and assume it is the minimum value
            //
            for (int i=0;i<m_ValueList.Size();i++)
            {
                if (m_ValueList[i] == nCurrentValue)
                {
                    return i;
                }
            }
        }
        //
        // returns -1 to indicate failure
        //
        return -1;
    }
    bool Increment( LONG &nCurrentValue ) const
    {
        //
        // Round us off.  This will also take care of validation.
        //
        if (!FindClosestValueByRoundingDown( nCurrentValue ))
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Let FindClosestValueByRoundingDown take care of making sure that we don't exceed the maximum
            //
            nCurrentValue += m_ValueList[StepValue];
            return FindClosestValueByRoundingDown( nCurrentValue );
        }
        else if (IsList() && m_ValueList.Size())
        {
            int nIndex = FindIndexOfItem( nCurrentValue );

            //
            // Make sure we are in the list
            //
            if (nIndex < 0)
            {
                return false;
            }

            //
            // Get the next value
            //
            nIndex++;

            //
            // Make sure we aren't off the end of the list
            //
            if (nIndex >= m_ValueList.Size())
            {
                nIndex = m_ValueList.Size() - 1;
            }

            //
            // Return it
            //
            nCurrentValue = m_ValueList[nIndex];

            //
            // Everything is OK
            //
            return true;
        }
        return false;
    }
    bool Decrement( LONG &nCurrentValue ) const
    {
        //
        // Round us off.  This will also take care of validation.
        //
        if (!FindClosestValueByRoundingDown( nCurrentValue ))
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Let FindClosestValueByRoundingDown take care of making sure that we don't go under the minimum
            //
            nCurrentValue -= m_ValueList[StepValue];
            return FindClosestValueByRoundingDown( nCurrentValue );
        }
        else if (IsList() && m_ValueList.Size())
        {
            int nIndex = FindIndexOfItem( nCurrentValue );

            //
            // Make sure we are in the list
            //
            if (nIndex < 0)
            {
                return false;
            }

            //
            // Get the previous value
            //
            nIndex--;

            //
            // Make sure we aren't before the beginning of the list
            //
            if (nIndex < 0)
            {
                nIndex = 0;
            }

            //
            // Return it
            //
            nCurrentValue = m_ValueList[nIndex];

            //
            // Everything is OK
            //
            return true;
        }
        return false;
    }
    LONG GetItemCount(void) const
    {
        if (IsList())
        {
            return m_ValueList.Size();
        }
        else if (IsRange())
        {
            //
            // Calculate the number of steps between the minimum and maximum
            //
            return ((m_ValueList[MaxValue] - m_ValueList[MinValue]) / m_ValueList[StepValue]) + 1;
        }
        return 0;
    }
    bool GetItemAtIndex( int nIndex, LONG &nItem ) const
    {
        if (!IsValid())
        {
            return false;
        }
        if (IsList() && nIndex >= 0 && nIndex < m_ValueList.Size())
        {
            nItem = m_ValueList[nIndex];
            return true;
        }
        else if (IsRange() && nIndex < GetItemCount())
        {
            //
            // Return the minimum + nIndex * stepvalue
            //
            nItem = m_ValueList[MinValue] + (m_ValueList[StepValue] * nIndex);
            return true;
        }
        return false;
    }
    bool FindIntersection( const CValidWiaSettings &Set1, const CValidWiaSettings &Set2 )
    {
        //
        // We are modifying ourselves, so clear all of our data
        //
        Destroy();

        //
        // If either set is invalid, no intersection
        //
        if (!Set1.IsValid() || !Set2.IsValid())
        {
            return false;
        }

        //
        // If either a or b is a set (or both), just add all of the items
        // that are legal in both to ourself and set the type to a LIST
        //
        if (Set1.IsList())
        {
            m_nType = WIA_PROP_LIST;
            for (int i=0;i<Set1.GetItemCount();i++)
            {
                LONG nItem;
                if (Set1.GetItemAtIndex(i,nItem))
                {
                    if (Set2.IsLegalValue(nItem))
                    {
                        m_ValueList.Append(nItem);
                    }
                }
            }

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() != 0);
        }
        else if (Set2.IsList())
        {
            m_nType = WIA_PROP_LIST;
            for (int i=0;i<Set2.GetItemCount();i++)
            {
                LONG nItem;
                if (Set2.GetItemAtIndex(i,nItem))
                {
                    if (Set1.IsLegalValue(nItem))
                    {
                        m_ValueList.Append(nItem);
                    }
                }
            }

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() != 0);
        }
        //
        // Both are ranges.
        // BUGBUG: I may have to actually figure out how to do this in a more sophisticated
        // way.  Basically, I am taking the minimum of the two maximums and the maximum of the
        // two minimums if and only if the at least one of the minimums is in the set of the
        // other items and they have the same step value
        //
        else if (Set1.IsLegalValue(Set2.Min()) || Set2.IsLegalValue(Set1.Min()) && Set1.Step() == Set2.Step())
        {
            m_nType = WIA_PROP_RANGE;

            //
            //  Minimum, Maximum, Step
            //
            m_ValueList.Append(WiaUiUtil::Max(Set1.Min(),Set2.Min()));
            m_ValueList.Append(WiaUiUtil::Min(Set1.Max(),Set2.Max()));
            m_ValueList.Append(Set1.Step());

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() == 3);
        }
        return true;
    }
    LONG Min(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        if (IsList())
        {
            return (m_ValueList[0]);
        }
        else if (IsRange())
        {
            return (m_ValueList[MinValue]);
        }
        return 0;
    }
    LONG Max(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        if (IsList())
        {
            return (m_ValueList[m_ValueList.Size()-1]);
        }
        else if (IsRange())
        {
            return (m_ValueList[MaxValue]);
        }
        return 0;
    }
    LONG Step(void) const
    {
        if (IsRange())
        {
            return (m_ValueList[StepValue]);
        }
        return 0;
    }
    bool IsRange(void) const
    {
        return (m_nType == WIA_PROP_RANGE);
    }
    bool IsList(void) const
    {
        return (m_nType == WIA_PROP_LIST);
    }
    
    static bool SetNumericPropertyOnBoundary( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName, LONG nValue )
    {
        CValidWiaSettings ValidWiaSettings;
        if (!ValidWiaSettings.Read( pUnknown, propertyName ))
        {
            return false;
        }
        if (!ValidWiaSettings.FindClosestValueByRoundingDown(nValue))
        {
            return false;
        }
        if (!PropStorageHelpers::SetProperty( pUnknown, propertyName, nValue ))
        {
            return false;
        }
        return true;
    }
    
    
};

#endif //__VWIASET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiacsh.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIACSH.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/20/2000
 *
 *  DESCRIPTION: Context-sensitive help for dialogs
 *
 *******************************************************************************/
#ifndef __WIACSH_H_INCLUDED
#define __WIACSH_H_INCLUDED

//
// Context sensitive help helper functions
// They are meant to be called from WM_HELP and WM_CONTEXTMENU handlers, respectively
//
namespace WiaHelp
{
    LRESULT HandleWmHelp( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds );
    LRESULT HandleWmContextMenu( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds );
}

//
// Help file names
//
#define WIA_SPECIFIC_HELP_FILE TEXT("camera.hlp")
#define WIA_STANDARD_HELP_FILE TEXT("windows.hlp")


//
// WIA Help IDs found in camera.hlp
//

//
// Select dialog
//
#define IDH_WIA_MAKER              1000
#define IDH_WIA_DESCRIBE           1001
#define IDH_WIA_DEVICE_LIST        1002
#define IDH_WIA_BUTTON_PROP        1004

//
// Camera device property page
//
#define IDH_WIA_CONNECTED          1010
#define IDH_WIA_PICS_TAKEN         1011
#define IDH_WIA_PICS_LEFT          1012
#define IDH_WIA_BATTERY_STATUS     1013
#define IDH_WIA_IMAGE_SETTINGS     1014
#define IDH_WIA_TEST_BUTTON        1015
#define IDH_WIA_PORT_NAME          1016

//
// Events property page
//
#define IDH_WIA_EVENT_LIST         1020
#define IDH_WIA_APP_LIST           1021
#define IDH_WIA_START_PROG         1022
#define IDH_WIA_PROMPT_PROG        1023
#define IDH_WIA_NO_ACTION          1024
#define IDH_WIA_DELETE_IMAGES      1026
#define IDH_WIA_SAVE_TO            1027  //(radio button)
#define IDH_WIA_SAVE_TO_FOLDER     1028  //(Folder text box)
#define IDH_WIA_CREATE_SUBFLDR     1029  //(Create subfolder check box)
//
// Color management property page
//
#define IDH_WIA_COLOR_PROFILES     1030
#define IDH_WIA_ADD_PROFILE        1031
#define IDH_WIA_REMOVE_PROFILE     1032

//
// Scanner device property page
//
#define IDH_WIA_FRIENDLY           1040
#define IDH_WIA_STATUS             1041

//
// Scanner and camera wizard
//
#define IDH_WIA_PUT_SUBFOLD        1050
#define IDH_WIA_SUBFOLD_DATE       1051
#define IDH_WIA_SUBFOLD_NAME       1052
#define IDH_WIA_CLOSE_WIZARD       1053

//
// Screensaver
//
#define IDH_WIA_CHANGE_PICS        1060
#define IDH_WIA_PIC_SIZE           1061
#define IDH_WIA_PICTURE_FOLDER     1062
#define IDH_WIA_STRETCH_PICS       1063
#define IDH_WIA_SHOW_FILE_NAMES    1064
#define IDH_WIA_TRANSITION_EFFECTS 1065
#define IDH_WIA_ALLOW_SCROLL       1066
#define IDH_WIA_BROWSE             1067

//
// Scanner item property page
//
#define IDH_WIA_BRIGHTNESS         1070
#define IDH_WIA_CONTRAST           1071
#define IDH_WIA_PIC_RESOLUTION     1072
#define IDH_WIA_CUSTOM_PREVIEW     1073
#define IDH_WIA_RESTORE_DEFAULT    1074
#define IDH_WIA_IMAGE_TYPE         1075

//
// Camera item property page
//
#define IDH_WIA_PIC_NAME           1080
#define IDH_WIA_DATE_TAKEN         1081
#define IDH_WIA_TIME_TAKEN         1082
#define IDH_WIA_IMAGE_FORMAT       1083
#define IDH_WIA_PICTURE_SIZE       1084

//
// Scan dialog
//
#define IDH_WIA_PIC_TYPE           1090
#define IDH_WIA_PAPER_SOURCE       1091
#define IDH_WIA_PAGE_SIZE          1092
#define IDH_WIA_CUSTOM_SETTINGS    1093
#define IDH_WIA_PREVIEW_BUTTON     1094
#define IDH_WIA_SCAN_BUTTON        1095
#define IDH_WIA_IMAGE_PREVIEW      1096

//
// Camera common dialog
//
#define IDH_WIA_BUTTONS            1100
#define IDH_WIA_GET_PICS           1101
#define IDH_WIA_PIC_LIST           1102
#define IDH_WIA_VIEW_PIC_INFO      1103
#define IDH_WIA_PREVIEW_DETAIL     1104

//
// Video common dialog
//
#define IDH_WIA_VIDEO               1110
#define IDH_WIA_CAPTURED_IMAGES     1111
#define IDH_WIA_CAPTURE             1112
#define IDH_WIA_VIDEO_GET_PICTURE   1113

//Prompt to start dialog
//When you select Prompt to Start for a specific event (on Events tab)
//and then initiate the Event
#define IDH_WIA_EVENT_OCCURRED      1120
#define IDH_WIA_PROGRAM_LIST        1121
#define IDH_WIA_ALWAYS_USE          1122

#define IDH_WIA_BAUD_RATE           1130
#define IDH_WIA_CAMERA_TIME_STATIC  1133
#define IDH_WIA_FLASH_MODE          1134
#define IDH_WIA_FLASH_MODE_LIST     1135
#define IDH_WIA_IMAGE_SIZE_SLIDER   1136
#define IDH_WIA_CAMERA_TIME_BUTTON  1137
#define IDH_WIA_PORT_SPEED          1138
#define IDH_WIA_IMAGE_SIZE_STATIC   1140

//
// Standard help IDs, found in windows.hlp
//
#define IDH_OK                     28443
#define IDH_CANCEL                 28444
#define IDH_BROWSE                 28496

#endif // __WIACSH_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiafusion.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIAFUSION.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <commctrl.h>

namespace WiaUiUtil
{
    void PreparePropertyPageForFusion( PROPSHEETPAGE *pPropSheetPage )
    {
#if defined(PSP_USEFUSIONCONTEXT)
        if (pPropSheetPage)
        {
            pPropSheetPage->hActCtx  = g_hActCtx;
            pPropSheetPage->dwFlags |= PSP_USEFUSIONCONTEXT;
        }
#endif
    }
} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiaffmt.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WIAFFMT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/24/2000
 *
 *  DESCRIPTION: Helper class which encapsulates WIA image file formats
 *
 *******************************************************************************/
#ifndef __WIAFFMT_H_INCLUDED
#define __WIAFFMT_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <wia.h>
#include <pshelper.h>

class CWiaFileFormat
{
private:
    GUID          m_guidFormat;
    CSimpleString m_strExtension;
    CSimpleString m_strDescription;
    HICON         m_hIcon;

public:
    CWiaFileFormat( const GUID &guidFormat=IID_NULL, const CSimpleString &strExtension=TEXT(""), const CSimpleString &strDescription=TEXT(""), const HICON hIcon=NULL )
      : m_guidFormat(guidFormat),
        m_strExtension(strExtension),
        m_strDescription(strDescription),
        m_hIcon(NULL)
    {
        if (hIcon)
        {
            m_hIcon = CopyIcon(hIcon);
        }
    }
    CWiaFileFormat( const CWiaFileFormat &other )
      : m_guidFormat(other.Format()),
        m_strExtension(other.Extension()),
        m_strDescription(other.Description()),
        m_hIcon(NULL)
    {
        if (other.Icon())
        {
            m_hIcon = CopyIcon(other.Icon());
        }
    }
    CWiaFileFormat( const GUID &guidFormat, const HICON hDefaultIcon )
      : m_guidFormat(guidFormat),
        m_strExtension(GetExtension(guidFormat)),
        m_strDescription(TEXT("")),
        m_hIcon(NULL)
    {
        if (m_strExtension.Length())
        {
            AcquireDescription();
            AcquireIcon(hDefaultIcon);
        }
    }
    ~CWiaFileFormat(void)
    {
        Destroy();
    }
    CWiaFileFormat &operator=( const CWiaFileFormat &other )
    {
        if (this != &other)
        {
            m_guidFormat = other.Format();
            m_strExtension = other.Extension();
            m_strDescription = other.Description();
            if (other.Icon())
            {
                m_hIcon = CopyIcon(other.Icon());
            }
        }
        return *this;
    }
    void Destroy(void)
    {
        m_guidFormat = IID_NULL;
        m_strExtension = TEXT("");
        m_strDescription = TEXT("");
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
    }
    bool IsValid(void) const
    {
        return (m_guidFormat != IID_NULL && m_strExtension.Length());
    }
    HICON AcquireIcon( const HICON hDefaultIcon, bool bSmall=true )
    {
        if (!IsValid())
        {
            return false;
        }

        //
        // If we've already gotten the icon, return it
        //
        if (m_hIcon)
        {
            return m_hIcon;
        }

        //
        // Use the extension to get the icon
        //
        CSimpleString strExtension(m_strExtension.ToUpper());
        SHFILEINFO SHFileInfo = {0};
        if (SHGetFileInfo( CSimpleString(TEXT(".")) + strExtension, 0, &SHFileInfo, sizeof(SHFileInfo), bSmall ? SHGFI_SMALLICON|SHGFI_ICON|SHGFI_USEFILEATTRIBUTES : SHGFI_ICON|SHGFI_USEFILEATTRIBUTES ))
        {
            //
            // We will take ownership of this icon
            //
            if (SHFileInfo.hIcon)
            {
                m_hIcon = SHFileInfo.hIcon;
            }
        }

        //
        // If we haven't gotten the icon, use the default icon
        //
        if (!m_hIcon && hDefaultIcon)
        {
            m_hIcon = CopyIcon(hDefaultIcon);
        }

        return m_hIcon;
    }
    CSimpleString AcquireDescription(void)
    {
        if (!IsValid())
        {
            return TEXT("");
        }

        //
        // If we've already gotten the description, return it
        //
        if (m_strDescription.Length())
        {
            return m_strDescription;
        }

        //
        // Use the extension to get the description
        //
        CSimpleString strExtension(m_strExtension.ToUpper());
        SHFILEINFO SHFileInfo = {0};
        if (SHGetFileInfo( CSimpleString(TEXT(".")) + strExtension, 0, &SHFileInfo, sizeof(SHFileInfo), SHGFI_USEFILEATTRIBUTES|SHGFI_TYPENAME ))
        {
            //
            // We will take ownership of this icon
            //
            if (lstrlen(SHFileInfo.szTypeName))
            {
                m_strDescription = SHFileInfo.szTypeName;
            }
        }
        return m_strDescription;
    }
    static CSimpleString GetExtension( const GUID &guidFormat )
    {
        static const struct
        {
            const GUID *guidFormat;
            LPCTSTR pszExtension;
        }
        cs_WiaFormatExtensions[] =
        {
            { &WiaImgFmt_BMP,          TEXT("bmp")},
            { &WiaImgFmt_MEMORYBMP,    TEXT("bmp")},
            { &WiaImgFmt_JPEG,         TEXT("jpg")},
            { &WiaImgFmt_TIFF,         TEXT("tif")},
            { &WiaImgFmt_FLASHPIX,     TEXT("fpx")},
            { &WiaImgFmt_GIF,          TEXT("gif")},
            { &WiaImgFmt_EXIF,         TEXT("jpg")},
            { &WiaImgFmt_WMF,          TEXT("wmf")},
            { &WiaImgFmt_PNG,          TEXT("png")},
            { &WiaImgFmt_PHOTOCD,      TEXT("pcd")},
            { &WiaImgFmt_EMF,          TEXT("emf")},
            { &WiaImgFmt_ICO,          TEXT("ico")},

            { &WiaAudFmt_WAV,          TEXT("wav")},
            { &WiaAudFmt_MP3,          TEXT("mp3")},
            { &WiaAudFmt_AIFF,         TEXT("aif")},
            { &WiaAudFmt_WMA,          TEXT("wma")},

            { &WiaImgFmt_RTF,          TEXT("rtf")},
            { &WiaImgFmt_XML,          TEXT("xml")},
            { &WiaImgFmt_HTML,         TEXT("htm")},
            { &WiaImgFmt_TXT,          TEXT("txt")},
            { &WiaImgFmt_MPG,          TEXT("mpg")},
            { &WiaImgFmt_AVI,          TEXT("avi")}
        };
        for (int i=0;i<ARRAYSIZE(cs_WiaFormatExtensions);i++)
        {
            if (*cs_WiaFormatExtensions[i].guidFormat == guidFormat)
            {
                return cs_WiaFormatExtensions[i].pszExtension;
            }
        }
        return TEXT("");
    }
    static CSimpleString GetExtension( const GUID &guidFormat, LONG nMediaType, IUnknown *pUnknown )
    {
        //
        // First, try to get the extension from the static table above
        //
        CSimpleString strResult = GetExtension( guidFormat );
        if (!strResult.Length())
        {
            //
            // Save the current media type and format, because (unfortunately), there is no way to
            // get the preferred extension for a given format without setting it.
            //
            LONG nOldMediaType = 0;
            if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_TYMED, nOldMediaType ))
            {
                //
                // Save the current format
                //
                GUID guidOldFormat = IID_NULL;
                if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FORMAT, guidOldFormat ))
                {
                    //
                    // Set the format and media type to the ones chosen
                    //
                    if (PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_FORMAT, guidFormat ) &&
                        PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_TYMED, nMediaType ))
                    {
                        //
                        // Try to read the extension property
                        //
                        CSimpleStringWide strwExtension;
                        if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FILENAME_EXTENSION, strwExtension ))
                        {
                            //
                            // If we got an extension, save it as the result
                            //
                            strResult = CSimpleStringConvert::NaturalString(strwExtension);
                        }
                    }
                    
                    //
                    // Restore the original format property
                    //
                    PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_FORMAT, guidOldFormat );
                }
                
                //
                // Restore the original media type property
                //
                PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_TYMED, nOldMediaType );
            }
        }
        return strResult;
    }
    static bool IsKnownAudioFormat( const GUID &guidFormat )
    {
        static const GUID *cs_WiaAudioFormats[] =
        {
            &WiaAudFmt_WAV,
            &WiaAudFmt_MP3,
            &WiaAudFmt_AIFF,
            &WiaAudFmt_WMA
        };
        for (int i=0;i<ARRAYSIZE(cs_WiaAudioFormats);i++)
        {
            if (*cs_WiaAudioFormats[i] == guidFormat)
            {
                return true;
            }
        }
        return false;
    }
    GUID Format(void) const
    {
        return m_guidFormat;
    }
    CSimpleString Extension(void) const
    {
        return m_strExtension;
    }
    CSimpleString Description(void) const
    {
        return m_strDescription;
    }
    HICON Icon(void) const
    {
        return m_hIcon;
    }
    void Format( const GUID &guidFormat )
    {
        m_guidFormat = guidFormat;
    }
    void Extension( const CSimpleString &strExtension )
    {
        m_strExtension = strExtension;
    }
    void Description( const CSimpleString &strDescription )
    {
        m_strDescription = strDescription;
    }
    void Icon( const HICON hIcon )
    {
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (hIcon)
        {
            m_hIcon = CopyIcon(m_hIcon);
        }
    }
    bool operator==( const CWiaFileFormat &other )
    {
        return ((other.Format() == Format()) != 0);
    }
    bool operator==( const GUID &guidFormat )
    {
        return ((guidFormat == Format()) != 0);
    }
    void Dump(void)
    {
        WIA_PUSHFUNCTION(TEXT("CWiaFileFormat::Dump()"));
        WIA_PRINTGUID((m_guidFormat,TEXT("  m_guidFormat")));
        WIA_TRACE((TEXT("  m_strExtension: %s"), m_strExtension.String()));
        WIA_TRACE((TEXT("  m_strDescription: %s"), m_strDescription.String()));
        WIA_TRACE((TEXT("  m_strDescription: %p"), m_hIcon));
    }
};


class CWiaFileFormatList
{
private:
    CSimpleDynamicArray<CWiaFileFormat> m_FormatList;

private:
    CWiaFileFormatList( const CWiaFileFormatList & );
    CWiaFileFormatList &operator=( const CWiaFileFormatList & );

public:
    CWiaFileFormatList(void);
    CWiaFileFormatList( const GUID **pguidFormats, UINT nFormatCount, HICON hDefaultIcon )
    {
        if (pguidFormats)
        {
            for (UINT i=0;i<nFormatCount;i++)
            {
                m_FormatList.Append( CWiaFileFormat( *pguidFormats[i], hDefaultIcon ) );
            }
        }
    }
    CWiaFileFormatList( IWiaItem *pWiaItem, HICON hDefaultIcon )
    {
        //
        // Get the data transfer interface
        //
        CComPtr<IWiaDataTransfer> pWiaDataTransfer;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaDataTransfer, (void**)&pWiaDataTransfer );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format info enumerator
            //
            CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;
            hr = pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO);
            if (SUCCEEDED(hr))
            {
                //
                // Enumerate the formats
                //
                ULONG ulFetched = 0;
                WIA_FORMAT_INFO WiaFormatInfo;
                while (pEnumWIA_FORMAT_INFO->Next(1,&WiaFormatInfo,&ulFetched) == S_OK)
                {
                    if (WiaFormatInfo.lTymed == TYMED_FILE)
                    {
                        CWiaFileFormat newFormat(WiaFormatInfo.guidFormatID,hDefaultIcon);
                        if (newFormat.IsValid())
                        {
                            m_FormatList.Append(newFormat);
                        }
                    }
                }
            }
        }
    }

    const CSimpleDynamicArray<CWiaFileFormat> &FormatList(void) const
    {
        return m_FormatList;
    }

    CWiaFileFormatList &Union( const CWiaFileFormatList &other )
    {
        for (int nSource=0;nSource<other.FormatList().Size();nSource++)
        {
            int nFindResult = m_FormatList.Find(other.FormatList()[nSource]);
            if (nFindResult < 0)
            {
                m_FormatList.Append(other.FormatList()[nSource]);
            }
        }
        return *this;
    }
    void Dump(void)
    {
        for (int i=0;i<m_FormatList.Size();i++)
        {
            m_FormatList[i].Dump();
        }
    }
};

#endif // __WIAFFMT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wianew.h ===
#ifndef __IINEW_H_INCLUDED
#define __IINEW_H_INCLUDED

#if defined(__cplusplus)

#include "wiadebug.h"

inline void * __cdecl operator new(size_t size)
{
    if (0 == size)
    {
        return NULL;
    }

    PBYTE pBuf = size ? (PBYTE)LocalAlloc(LPTR, size) : NULL;

    #if !defined(WIA_DONT_DO_LEAK_CHECKS)
    WIA_RECORD_ALLOC(pBuf,size);
    #endif

    return (void *)pBuf;
}

inline void __cdecl operator delete(void *ptr)
{
    if (ptr)
    {
        #if !defined(WIA_DONT_DO_LEAK_CHECKS)
        WIA_RECORD_FREE(ptr);
        #endif

        LocalFree(ptr);
    }
}

extern "C" inline __cdecl _purecall(void)
{
    return 0;
}



#endif  // __cplusplus


#endif // __IINEW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\uicommon\wiatextc.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIATEXTC.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/30/1999
 *
 *  DESCRIPTION: Highlighted static control.  Like a static, but acts like a
 *               hyperlink
 *
 *
 * Use the following values in the dialog resource editor to put it in a dialog:
 *
 *     Style:
 *        Hyperlink:  0x50010000     (WS_CHILD|WS_VISIBLE|WS_TABSTOP)
 *        IconStatic: 0x50010008     (WS_CHILD|WS_VISIBLE|0x00000008)
 *     Class:   WiaTextControl
 *     ExStyle: 0x00000000
 *
 * Register before use using:
 *     CWiaTextControl::RegisterClass(g_hInstance);
 *
 *******************************************************************************/

#ifndef __WIATEXTC_H_INCLUDED
#define __WIATEXTC_H_INCLUDED

#include <windows.h>
#include <windowsx.h>
#include "simcrack.h"
#include "miscutil.h"

#define WIATEXT_STATIC_CLASSNAMEW L"WiaTextControl"
#define WIATEXT_STATIC_CLASSNAMEA  "WiaTextControl"

#ifdef UNICODE
#define WIATEXT_STATIC_CLASSNAME  WIATEXT_STATIC_CLASSNAMEW
#else
#define WIATEXT_STATIC_CLASSNAME  WIATEXT_STATIC_CLASSNAMEA
#endif

// Styles
#define WTS_SINGLELINE   0x00000001 // Single line
#define WTS_PATHELLIPSIS 0x00000002 // Use to truncate string in the middle
#define WTS_ENDELLIPSIS  0x00000004 // Use to truncate string at the end
#define WTS_ICONSTATIC   0x00000008 // Static control with an icon
#define WTS_RIGHT        0x00000010 // Right aligned

// Undefined in VC6 SDK
#ifndef COLOR_HOTLIGHT
#define COLOR_HOTLIGHT 26
#endif

// Undefined in VC6 SDK
#ifndef IDC_HAND
#define IDC_HAND MAKEINTRESOURCE(32649)
#endif

#define DEFAULT_ICON_STATIC_BACKGROUND_COLOR GetSysColor(COLOR_3DFACE)
#define DEFAULT_ICON_STATIC_FOREGROUND_COLOR GetSysColor(COLOR_WINDOWTEXT)

#define WM_WIA_STATIC_SETICON (WM_USER+1)

class CWiaTextControl
{
private:
    enum
    {
        StateNormal   = 0,
        StateHover    = 1,
        StateFocus    = 2,
        StateDisabled = 4
    };

    // Timer IDs
    enum
    {
        IDT_MOUSEPOS = 1
    };

    enum
    {
        IconMargin = 0
    };

private:
    HWND         m_hWnd;
    COLORREF     m_crColorNormal;
    COLORREF     m_crColorHover;
    COLORREF     m_crColorFocus;
    COLORREF     m_crColorDisabled;
    COLORREF     m_crForegroundColor;
    RECT         m_rcTextWidth;
    HFONT        m_hFont;
    int          m_CurrentState;
    RECT         m_rcHighlight;
    HCURSOR      m_hHandCursor;
    HBITMAP      m_hBitmap;
    SIZE         m_sizeWindow;
    bool         m_bIconStaticMode;
    HBRUSH       m_hBackgroundBrush;
    HICON        m_hIcon;

private:
    CWiaTextControl(void);
    CWiaTextControl( const CWiaTextControl & );
    CWiaTextControl &operator=( const CWiaTextControl & );

private:
    CWiaTextControl( HWND hWnd )
    : m_hWnd(hWnd),
      m_crColorNormal(GetSysColor(COLOR_HOTLIGHT)),
      m_crColorHover(RGB(255,0,0)),
      m_crColorFocus(GetSysColor(COLOR_HOTLIGHT)),
      m_crColorDisabled(GetSysColor(COLOR_GRAYTEXT)),
      m_crForegroundColor(DEFAULT_ICON_STATIC_FOREGROUND_COLOR),
      m_hFont(NULL),
      m_hHandCursor(NULL),
      m_hBitmap(NULL),
      m_hBackgroundBrush(NULL),
      m_hIcon(NULL),
      m_CurrentState(StateNormal),
      m_bIconStaticMode(false)
    {
        CreateNewFont(reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT)));
    }
    ~CWiaTextControl(void)
    {
        m_hWnd = NULL;
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (m_hHandCursor)
        {
            m_hHandCursor = NULL;
        }
        if (m_hFont)
        {
            DeleteObject(m_hFont);
            m_hFont = NULL;
        }
        if (m_hBitmap)
        {
            DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }
        if (m_hBackgroundBrush)
        {
            DeleteObject(m_hBackgroundBrush);
            m_hBackgroundBrush = NULL;
        }
    }

    COLORREF GetCurrentColor(void)
    {
        if (StateDisabled & m_CurrentState)
            return m_crColorDisabled;
        if (StateHover & m_CurrentState)
            return m_crColorHover;
        if (StateFocus & m_CurrentState)
            return m_crColorFocus;
        else return m_crColorNormal;
    }
    void CreateNewFont( HFONT hFont )
    {
        if (m_hFont)
        {
            DeleteObject(m_hFont);
            m_hFont = NULL;
        }
        if (hFont)
        {
            LOGFONT lf;
            if (GetObject( hFont, sizeof(LOGFONT), &lf ))
            {
                lf.lfUnderline = TRUE;
                m_hFont = CreateFontIndirect( &lf );
            }
        }
    }

private:
    LRESULT OnEraseBkgnd( WPARAM wParam, LPARAM lParam )
    {
        RedrawBitmap(false);
        return TRUE;
    }

    LRESULT OnSetIcon( WPARAM, LPARAM lParam )
    {
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        m_hIcon = reinterpret_cast<HICON>(lParam);
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnSetFocus( WPARAM, LPARAM )
    {
        m_CurrentState |= StateFocus;
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnKillFocus( WPARAM, LPARAM )
    {
        m_CurrentState &= ~StateFocus;
        RedrawBitmap(true);
        return 0;
    }

    void DrawHyperlinkControl( HDC hDC )
    {
        RECT rcClient;
        GetClientRect(m_hWnd,&rcClient);


        // Make sure we start with a fresh rect
        ZeroMemory( &m_rcHighlight, sizeof(m_rcHighlight) );
        HBRUSH hbrBackground = NULL;

        HWND hWndParent = GetParent(m_hWnd);
        if (hWndParent)
            hbrBackground = reinterpret_cast<HBRUSH>(SendMessage(hWndParent,WM_CTLCOLORSTATIC,reinterpret_cast<WPARAM>(hDC),reinterpret_cast<LPARAM>(m_hWnd)));

        if (!hbrBackground)
            hbrBackground = reinterpret_cast<HBRUSH>(GetSysColorBrush(COLOR_WINDOW));

        FillRect( hDC, &rcClient, hbrBackground );

        LRESULT nWindowTextLength = SendMessage(m_hWnd,WM_GETTEXTLENGTH,0,0);

        LPTSTR pszWindowText = new TCHAR[nWindowTextLength+1];
        if (pszWindowText)
        {
            if (SendMessage( m_hWnd, WM_GETTEXT, nWindowTextLength+1, reinterpret_cast<LPARAM>(pszWindowText) ) )
            {
                int nDrawTextFlags = DT_WORDBREAK|DT_TOP|DT_NOPREFIX;

                INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
                if (nStyle & WTS_SINGLELINE)
                    nDrawTextFlags |= DT_SINGLELINE;

                if (nStyle & WTS_RIGHT)
                    nDrawTextFlags |= DT_RIGHT;
                else nDrawTextFlags |= DT_LEFT;

                if (nStyle & WTS_PATHELLIPSIS)
                    nDrawTextFlags |= DT_PATH_ELLIPSIS | DT_SINGLELINE;

                if (nStyle & WTS_ENDELLIPSIS)
                    nDrawTextFlags |= DT_END_ELLIPSIS | DT_SINGLELINE;

                m_rcHighlight = rcClient;

                int nOldBkMode = SetBkMode( hDC, TRANSPARENT );
                HFONT hOldFont = NULL;
                if (m_hFont)
                   hOldFont = reinterpret_cast<HFONT>(SelectObject( hDC, m_hFont ));
                COLORREF crOldColor = SetTextColor( hDC, GetCurrentColor() );

                InflateRect(&m_rcHighlight,-1,-1);
                DrawTextEx( hDC, pszWindowText, -1, &m_rcHighlight, nDrawTextFlags, NULL );

                SetTextColor( hDC, crOldColor );
                SetBkMode( hDC, nOldBkMode );

                DrawTextEx( hDC, pszWindowText, -1, &m_rcHighlight, DT_CALCRECT|nDrawTextFlags , NULL );
                InflateRect(&m_rcHighlight,1,1);

                if (nStyle & WTS_RIGHT)
                {
                    m_rcHighlight.left = rcClient.right - WiaUiUtil::Min<int>(rcClient.right,m_rcHighlight.right);
                    m_rcHighlight.right = rcClient.right;
                    m_rcHighlight.bottom = WiaUiUtil::Min<int>(rcClient.bottom,m_rcHighlight.bottom);
                }
                else
                {
                    m_rcHighlight.right = WiaUiUtil::Min<int>(rcClient.right,m_rcHighlight.right);
                    m_rcHighlight.bottom = WiaUiUtil::Min<int>(rcClient.bottom,m_rcHighlight.bottom);
                }

                if (m_CurrentState & StateFocus)
                    DrawFocusRect( hDC, &m_rcHighlight );

                if (m_hFont)
                    SelectObject( hDC, hOldFont );
            }
            delete[] pszWindowText;
        }
    }

    void DrawIconStatic( HDC hDC )
    {
        RECT rcClient;
        GetClientRect( m_hWnd, &rcClient );

        FrameRect( hDC, &rcClient, GetSysColorBrush( COLOR_WINDOWFRAME ) );

        InflateRect( &rcClient, -1, -1 );
        FillRect( hDC, &rcClient, m_hBackgroundBrush );
        InflateRect( &rcClient, -1, -1 );

        CSimpleString str;
        str.GetWindowText(m_hWnd);
        if (str.Length())
        {
            int nDrawTextFlags = DT_WORDBREAK|DT_TOP|DT_LEFT|DT_NOPREFIX;

            INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
            if (nStyle & WTS_SINGLELINE)
                nDrawTextFlags |= DT_SINGLELINE | DT_VCENTER;

            if (nStyle & WTS_PATHELLIPSIS)
                nDrawTextFlags |= DT_PATH_ELLIPSIS | DT_SINGLELINE;

            if (nStyle & WTS_ENDELLIPSIS)
                nDrawTextFlags |= DT_END_ELLIPSIS | DT_SINGLELINE;

            if (m_hIcon)
            {
                int nIconMargin;
                // Center the icon vertically
                if (nStyle & WTS_SINGLELINE)
                {
                    nIconMargin = (WiaUiUtil::RectHeight(rcClient) - GetSystemMetrics(SM_CYSMICON)) / 2;
                }
                else
                {
                    nIconMargin = IconMargin;
                }
                DrawIconEx( hDC, rcClient.left+nIconMargin, rcClient.top+nIconMargin, m_hIcon, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0, NULL, DI_NORMAL );
                rcClient.left += rcClient.left + GetSystemMetrics(SM_CXSMICON) + nIconMargin*2;
            }

            int nOldBkMode = SetBkMode( hDC, TRANSPARENT );
            HFONT hOldFont = NULL, hFont = (HFONT)SendMessage( m_hWnd, WM_GETFONT, 0, 0 );
            if (!hFont)
                hFont = (HFONT)SendMessage( GetParent(m_hWnd), WM_GETFONT, 0, 0 );
            if (hFont)
                hOldFont = SelectFont( hDC, hFont );

            COLORREF crOldColor = SetTextColor( hDC, m_crForegroundColor );
            DrawTextEx( hDC, const_cast<LPTSTR>(str.String()), str.Length(), &rcClient, nDrawTextFlags, NULL );
            SetTextColor( hDC, crOldColor );
            if (hOldFont)
                SelectFont( hDC, hOldFont );
            SetBkMode( hDC, nOldBkMode );
        }
    }

    void RedrawBitmap( bool bRedraw )
    {
        if (m_hBitmap)
        {
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                HDC hMemDC = CreateCompatibleDC(hDC);
                if (hMemDC)
                {
                    HBITMAP hOldBitmap = SelectBitmap( hMemDC, m_hBitmap );

                    if (!m_bIconStaticMode)
                        DrawHyperlinkControl( hMemDC );
                    else DrawIconStatic( hMemDC );
                    SelectBitmap( hMemDC, hOldBitmap );
                    DeleteDC(hMemDC);
                }
                ReleaseDC(m_hWnd, hDC);
            }
        }
        if (bRedraw)
        {
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }
    void CheckMousePos(void)
    {
        POINT pt;
        GetCursorPos(&pt);
        MapWindowPoints( NULL, m_hWnd, &pt, 1 );
        if (PtInRect( &m_rcHighlight, pt ))
        {
            if ((m_CurrentState & StateHover)==0)
            {
                m_CurrentState |= StateHover;
                RedrawBitmap(true);
            }
        }
        else
        {
            if (m_CurrentState & StateHover)
            {
                m_CurrentState &= ~StateHover;
                RedrawBitmap(true);
            }
        }
    }

    LRESULT OnTimer( WPARAM wParam, LPARAM lParam )
    {
        if (wParam == IDT_MOUSEPOS)
        {
            CheckMousePos();
            return 0;
        }
        return DefWindowProc( m_hWnd, WM_TIMER, wParam, lParam );
    }

    LRESULT OnMove( WPARAM wParam, LPARAM lParam )
    {
        CheckMousePos();
        return 0;
    }

    LRESULT OnSize( WPARAM wParam, LPARAM lParam )
    {
        if (SIZE_RESTORED == wParam || SIZE_MAXIMIZED == wParam)
        {
            if (m_hBitmap)
            {
                DeleteBitmap(m_hBitmap);
                m_hBitmap = NULL;
            }
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                m_sizeWindow.cx = LOWORD(lParam);
                m_sizeWindow.cy = HIWORD(lParam);
                m_hBitmap = CreateCompatibleBitmap( hDC, LOWORD(lParam), HIWORD(lParam) );
                ReleaseDC(m_hWnd,hDC);
            }
        }
        RedrawBitmap(true);
        CheckMousePos();
        return 0;
    }

    LRESULT OnCreate( WPARAM, LPARAM )
    {
        if (!IsWindowEnabled(m_hWnd))
            m_CurrentState |= StateDisabled;
        INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
        if (nStyle & WTS_ICONSTATIC)
            m_bIconStaticMode = true;

        SetTimer( m_hWnd, IDT_MOUSEPOS, 56, NULL );

        m_hHandCursor = LoadCursor( NULL, IDC_HAND );

        m_hBackgroundBrush = CreateSolidBrush(DEFAULT_ICON_STATIC_BACKGROUND_COLOR);

        return 0;
    }

    LRESULT OnSetFont( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lRes = DefWindowProc( m_hWnd, WM_SETFONT, wParam, lParam );
        CreateNewFont(reinterpret_cast<HFONT>(wParam));
        RedrawBitmap(LOWORD(lParam) != 0);
        return lRes;
    }

    LRESULT OnSetText( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lRes = DefWindowProc( m_hWnd, WM_SETTEXT, wParam, lParam );
        RedrawBitmap(true);
        return lRes;
    }

    LRESULT OnGetDlgCode( WPARAM, LPARAM )
    {
        if (!m_bIconStaticMode)
            return DLGC_BUTTON;
        return  DLGC_STATIC;
    }

    void FireNotification( int nCode )
    {
        HWND hwndParent = GetParent(m_hWnd);
        if (hwndParent)
        {
            SendNotifyMessage( hwndParent, WM_COMMAND, MAKEWPARAM(GetWindowLongPtr(m_hWnd,GWLP_ID),nCode), reinterpret_cast<LPARAM>(m_hWnd) );
        }
    }

    LRESULT OnKeyDown( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            if (wParam == VK_SPACE)
                FireNotification(BN_CLICKED);
            else if (wParam == VK_RETURN)
                FireNotification(BN_CLICKED);
        }
        return 0;
    }

    LRESULT OnNcHitTest( WPARAM, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            MapWindowPoints( NULL, m_hWnd, &pt, 1 );
            if (PtInRect( &m_rcHighlight, pt ))
            {
                return HTCLIENT;
            }
        }
        return HTTRANSPARENT;
    }

    LRESULT OnEnable( WPARAM wParam, LPARAM lParam )
    {
        if (wParam)
        {
            m_CurrentState &= ~StateDisabled;
        }
        else
        {
            m_CurrentState |= StateDisabled;
        }
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            if (PtInRect(&m_rcHighlight,pt))
            {
                SetFocus(m_hWnd);
                SetCapture(m_hWnd);
            }
        }
        return 0;
    }

    LRESULT OnLButtonUp( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            if (GetCapture() == m_hWnd)
            {
                ReleaseCapture();
                POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
                if (PtInRect(&m_rcHighlight,pt))
                {
                    FireNotification(BN_CLICKED);
                }
            }
        }
        return 0;
    }

    LRESULT OnSetCursor( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt;
            GetCursorPos(&pt);
            MapWindowPoints( NULL, m_hWnd, &pt, 1 );
            if (PtInRect( &m_rcHighlight, pt ))
            {
                SetCursor( m_hHandCursor );
                return 0;
            }
        }
        return DefWindowProc( m_hWnd, WM_SETCURSOR, wParam, lParam );
    }

    LRESULT OnStyleChanged( WPARAM wParam, LPARAM lParam )
    {
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnSysColorChange( WPARAM wParam, LPARAM lParam )
    {
        m_crColorNormal = GetSysColor(COLOR_HOTLIGHT);
        m_crColorHover = RGB(255,0,0);
        m_crColorFocus = GetSysColor(COLOR_HOTLIGHT);
        m_crColorDisabled = GetSysColor(COLOR_GRAYTEXT);
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnPaint( WPARAM wParam, LPARAM lParam )
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint( m_hWnd, &ps );
        if (hDC)
        {
            if (ps.fErase)
            {
                RedrawBitmap(false);
            }
            if (m_hBitmap)
            {
                HDC hMemDC = CreateCompatibleDC(hDC);
                if (hMemDC)
                {
                    HBITMAP hOldBitmap = SelectBitmap(hMemDC,m_hBitmap);
                    BitBlt( hDC, ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right-ps.rcPaint.left, ps.rcPaint.bottom-ps.rcPaint.top, hMemDC, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY );
                    SelectBitmap(hMemDC,hOldBitmap);
                    DeleteDC(hMemDC);
                }
            }
            EndPaint( m_hWnd, &ps );
        }
        return 0;
    }


public:
    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CWiaTextControl)
        {
            SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
            SC_HANDLE_MESSAGE( WM_SETFONT, OnSetFont );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );
            SC_HANDLE_MESSAGE( WM_KILLFOCUS, OnKillFocus );
            SC_HANDLE_MESSAGE( WM_SETTEXT, OnSetText );
            SC_HANDLE_MESSAGE( WM_GETDLGCODE, OnGetDlgCode );
            SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkgnd );
            SC_HANDLE_MESSAGE( WM_TIMER, OnTimer );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_MOVE, OnMove );
            SC_HANDLE_MESSAGE( WM_KEYDOWN, OnKeyDown );
            SC_HANDLE_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
            SC_HANDLE_MESSAGE( WM_LBUTTONUP, OnLButtonUp );
            SC_HANDLE_MESSAGE( WM_SETCURSOR, OnSetCursor );
            SC_HANDLE_MESSAGE( WM_ENABLE, OnEnable );
            SC_HANDLE_MESSAGE( WM_NCHITTEST, OnNcHitTest );
            SC_HANDLE_MESSAGE( WM_STYLECHANGED, OnStyleChanged );
            SC_HANDLE_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
            SC_HANDLE_MESSAGE( WM_WIA_STATIC_SETICON, OnSetIcon );
        }
        SC_END_MESSAGE_HANDLERS();
    }
    static BOOL RegisterClass( HINSTANCE hInstance )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_DBLCLKS;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInstance;
        wcex.lpszClassName = WIATEXT_STATIC_CLASSNAME;
        return ::RegisterClassEx( &wcex );
    }
};

#endif //__WIATEXTC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\dbgcdraw.h ===
#ifndef __DBGCDRAW_H_INCLUDED
#define __DBGCDRAW_H_INCLUDED

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#define MKFLAG(x) { (x), TEXT(#x) }

struct FlagString
{
    DWORD dwFlag;
    LPCTSTR pszString;
};

inline LPCTSTR GetString( LPTSTR szString, FlagString *pFlagStrings, size_t nSize, DWORD dwValue, bool bFlag )
{
    TCHAR szFlag[200] = TEXT("");
    wsprintf( szFlag, TEXT("(0x%08X)"), dwValue );

    TCHAR szText[256] = TEXT("");

    lstrcpy( szString, TEXT("") );

    if (bFlag)
    {
        
        for (size_t i=0;i<nSize;i++)
        {
            if (dwValue & pFlagStrings[i].dwFlag)
            {
                if (lstrlen(szText))
                {
                    lstrcat(szText,TEXT("|"));
                }
                lstrcat( szText, pFlagStrings[i].pszString );
            }
        }
    }
    else
    {
        for (size_t i=0;i<nSize;i++)
        {
            if (dwValue == pFlagStrings[i].dwFlag)
            {
                lstrcpy( szText, pFlagStrings[i].pszString );
                break;
            }
        }
    }
    lstrcpy( szString, szText );
    if (lstrlen(szString))
    {
        lstrcat( szString, TEXT(" ") );
    }
    lstrcat( szString, szFlag );
    return szString;
}

inline void DumpCustomDraw( LPARAM lParam, LPCTSTR pszControlType=NULL, DWORD dwDrawStage=0 )
{
    FlagString DrawStages[] =
    {
        MKFLAG(CDDS_PREPAINT),
        MKFLAG(CDDS_POSTPAINT),
        MKFLAG(CDDS_PREERASE),
        MKFLAG(CDDS_POSTERASE),
        MKFLAG(CDDS_ITEMPREPAINT),
        MKFLAG(CDDS_ITEMPOSTPAINT),
        MKFLAG(CDDS_ITEMPREERASE),
        MKFLAG(CDDS_ITEMPOSTERASE)
    };
    FlagString ItemStates[] =
    {
        MKFLAG(CDIS_CHECKED),
        MKFLAG(CDIS_DEFAULT),
        MKFLAG(CDIS_DISABLED),
        MKFLAG(CDIS_FOCUS),
        MKFLAG(CDIS_GRAYED),
        MKFLAG(CDIS_HOT),
        MKFLAG(CDIS_INDETERMINATE),
        MKFLAG(CDIS_MARKED),
        MKFLAG(CDIS_SELECTED),
        MKFLAG(CDIS_SHOWKEYBOARDCUES)
    };
    TCHAR szClassName[MAX_PATH];

    if (GetClassName( reinterpret_cast<NMHDR*>(lParam)->hwndFrom, szClassName, sizeof(szClassName)/sizeof(szClassName[0]) ))
    {
        if (!pszControlType || !lstrcmp(pszControlType,szClassName))
        {
            if (!dwDrawStage || dwDrawStage == reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwDrawStage)
            {
                TCHAR szBuffer[MAX_PATH];
                WIA_TRACE((TEXT("Dumping Custom Draw for control: [%s]"), szClassName ));
#if 0
                WIA_TRACE((TEXT("   hwndFrom: 0x%p"),reinterpret_cast<NMHDR*>(lParam)->hwndFrom ));
                WIA_TRACE((TEXT("   idFrom: %d"),reinterpret_cast<NMHDR*>(lParam)->idFrom ));
                WIA_TRACE((TEXT("   code: %d"),reinterpret_cast<NMHDR*>(lParam)->code ));
#endif
                WIA_TRACE((TEXT("   dwDrawStage: %s"),GetString(szBuffer,DrawStages,ARRAYSIZE(DrawStages),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwDrawStage,false)));
                WIA_TRACE((TEXT("   hdc: %p"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->hdc ));
                WIA_TRACE((TEXT("   rc: (%d,%d), (%d,%d)"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.left, reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.top,reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.right,reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.bottom ));
                WIA_TRACE((TEXT("   dwItemSpec: %d"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwItemSpec ));
                WIA_TRACE((TEXT("   uItemState: %s"),GetString(szBuffer,ItemStates,ARRAYSIZE(ItemStates),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->uItemState,true)));
                WIA_TRACE((TEXT("   lItemlParam: 0x%p"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->lItemlParam ));
                if (!lstrcmp(TEXT("SysListView32"),szClassName))
                {
                    WIA_TRACE((TEXT("   clrText: RGB(0x%02X,0x%02X,0x%02X)"),GetRValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText),GetGValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText),GetBValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText) ));
                    WIA_TRACE((TEXT("   clrTextBk: RGB(0x%02X,0x%02X,0x%02X)"),GetRValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk),GetGValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk),GetBValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk) ));
                    WIA_TRACE((TEXT("   iSubItem: %d"),reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->iSubItem ));
                }
                WIA_TRACE((TEXT("")));
            }
        }
    }
}

#endif //__DBGCDRAW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\clvtest.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <objbase.h>
#include <wiadebug.h>
#include <simcrack.h>
#include "resource.h"
#include "dbgcdraw.h"
#include "chklistv.h"
#include "lvprops.h"

static HINSTANCE g_hInstance;

static const int c_nMaxImages         = 20;

static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 10;

class CListviewTestDialog
{
private:
    HWND                    m_hWnd;
    CCheckedListviewHandler m_CheckedListviewHandler;
    SIZE                    m_sizeImage;
    SIZE                    m_sizeMargin;

private:
    CListviewTestDialog(void);
    CListviewTestDialog( const CListviewTestDialog & );
    CListviewTestDialog &operator=( const CListviewTestDialog & );

private:
    
    explicit CListviewTestDialog( HWND hWnd )
      : m_hWnd(hWnd)
    {
        ZeroMemory(&m_sizeImage,sizeof(SIZE));
        m_sizeMargin.cx = c_nAdditionalMarginX;
        m_sizeMargin.cy = c_nAdditionalMarginY;
    }
    ~CListviewTestDialog(void)
    {
    }

    LRESULT OnListClick( WPARAM wParam, LPARAM lParam )
    {
        m_CheckedListviewHandler.HandleListClick( wParam, lParam );
        return 0;
    }

    LRESULT OnListDblClk( WPARAM wParam, LPARAM lParam )
    {
        m_CheckedListviewHandler.HandleListDblClk( wParam, lParam );
        return 0;
    }

    LRESULT OnGetCheckState( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = 0;
        NMGETCHECKSTATE *pNmGetCheckState = reinterpret_cast<NMGETCHECKSTATE*>(lParam);
        if (pNmGetCheckState)
        {
            LVITEM LvItem = {0};
            LvItem.iItem = pNmGetCheckState->nItem;
            LvItem.mask = LVIF_PARAM;
            if (ListView_GetItem( pNmGetCheckState->hdr.hwndFrom, &LvItem ))
            {
                if (LvItem.lParam)
                {
                    lResult = LVCHECKSTATE_CHECKED;
                }
                else
                {
                    lResult = LVCHECKSTATE_UNCHECKED;
                }
            }
        }
        return lResult;
    }

    LRESULT OnSetCheckState( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = 0;
        NMSETCHECKSTATE *pNmSetCheckState = reinterpret_cast<NMSETCHECKSTATE*>(lParam);
        if (pNmSetCheckState)
        {
            LVITEM LvItem = {0};
            LvItem.mask = LVIF_PARAM;
            LvItem.iItem = pNmSetCheckState->nItem;
            LvItem.lParam = (pNmSetCheckState->nCheck == LVCHECKSTATE_CHECKED) ? 1 : 0;
            ListView_SetItem( pNmSetCheckState->hdr.hwndFrom, &LvItem );
        }
        return 0;
    }

    LRESULT OnListCustomDraw( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = CDRF_DODEFAULT;
        m_CheckedListviewHandler.HandleListCustomDraw( wParam, lParam, lResult );
        return lResult;
    }

    LRESULT OnListKeyDown( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = FALSE;
        m_CheckedListviewHandler.HandleListKeyDown( wParam, lParam, lResult );
        return lResult;
    }


    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_LIST );
        if (hwndList)
        {
            //
            // Attach this control to the checkbox handler
            //
            m_CheckedListviewHandler.Attach(hwndList);

            //
            // Load an image for the image list
            //
            struct
            {
                UINT    nResId;
                HBITMAP hBitmap;
                int     nImageIndex;
            } Images[] =
            {
                { IDB_IMAGE1, NULL, 0 },
                { IDB_IMAGE2, NULL, 0 },
                { IDB_IMAGE3, NULL, 0 },
                { IDB_IMAGE4, NULL, 0 },
                { IDB_IMAGE5, NULL, 0 }
            };

            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
            bool bSuccess = true;
            for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
            {
                Images[i].hBitmap = reinterpret_cast<HBITMAP>(LoadImage(g_hInstance,MAKEINTRESOURCE(Images[i].nResId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));
                if (!Images[i].hBitmap)
                {
                    bSuccess = false;
                }
            }
            
            if (bSuccess)
            {
                //
                // Get the image's dimensions
                //
                BITMAP bm = {0};
                if (GetObject( Images[0].hBitmap, sizeof(BITMAP), &bm ))
                {
                    m_sizeImage.cx = bm.bmWidth;
                    m_sizeImage.cy = bm.bmHeight;
                    //
                    // Create the image list
                    //
                    HIMAGELIST hImageList = ImageList_Create( m_sizeImage.cx, m_sizeImage.cy, ILC_COLOR24, 1, 1 );
                    if (hImageList)
                    {
                        //
                        // Set the image list
                        //
                        ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );
                        
                        //
                        // Add the image to the image list
                        //
                        bSuccess = true;
                        for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
                        {
                            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
                            Images[i].nImageIndex = ImageList_Add( hImageList, Images[i].hBitmap, NULL );
                            if (-1 == Images[i].nImageIndex)
                            {
                                bSuccess = false;
                            }
                        }
                        
                        if (bSuccess)
                        {
                            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
                            //
                            // Tell the listview we don't want labels, and want border selection
                            //
                            
                            ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES );
                            ListView_SetIconSpacing( hwndList, m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
                            
                            //
                            // Insert a few items
                            //
                            for (int i=0;i<c_nMaxImages;i++)
                            {
                                LVITEM LvItem = {0};
                                LvItem.mask = LVIF_IMAGE;
                                LvItem.iImage = Images[i%ARRAYSIZE(Images)].nImageIndex;
                                LvItem.iItem = i;
                                ListView_InsertItem( hwndList, &LvItem );
                            }

                            //
                            // Select the first item
                            //
                            ListView_SetItemState( hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED );
                        }
                    }
                }
            }
        }
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnSelectCurr( WPARAM, LPARAM )
    {
        int nCurrItem = -1;
        while (true)
        {
            nCurrItem = ListView_GetNextItem( GetDlgItem(m_hWnd,IDC_LIST), nCurrItem, LVNI_SELECTED );
            if (nCurrItem < 0)
            {
                break;
            }
            m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), nCurrItem, LVCHECKSTATE_CHECKED );
        }
    }
    void OnSelectAll( WPARAM, LPARAM )
    {
        m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), -1, LVCHECKSTATE_CHECKED );
    }
    void OnSelectNone( WPARAM, LPARAM )
    {
        m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), -1, LVCHECKSTATE_UNCHECKED );
    }

    void OnProperties( WPARAM, LPARAM )
    {
        CListviewPropsDialog::CData Data;
        Data.bFullItemSelect = m_CheckedListviewHandler.FullImageHit();
        Data.sizeItemSpacing.cx = m_sizeMargin.cx;
        Data.sizeItemSpacing.cy = m_sizeMargin.cy;
        INT_PTR nRes = DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_PROPS_DIALOG), NULL, CListviewPropsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data) );
        if (IDOK == nRes)
        {
            m_CheckedListviewHandler.FullImageHit(Data.bFullItemSelect);
            m_sizeMargin.cx = Data.sizeItemSpacing.cx;
            m_sizeMargin.cy = Data.sizeItemSpacing.cy;
            if (Data.bCustomIcon)
            {
                m_CheckedListviewHandler.SetCheckboxImages( (HICON)LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_CHECKED), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR ), (HICON)LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_UNCHECKED), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR ) );
            }
            else
            {
                m_CheckedListviewHandler.CreateDefaultCheckBitmaps();
            }
            ListView_SetIconSpacing( GetDlgItem(m_hWnd,IDC_LIST), m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
            InvalidateRect( GetDlgItem(m_hWnd,IDC_LIST), NULL, TRUE );
            UpdateWindow( GetDlgItem(m_hWnd,IDC_LIST) );
        }
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
       {
       }
       SC_END_NOTIFY_MESSAGE_HANDLERS();
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
           SC_HANDLE_COMMAND(IDC_SELECTCURR,OnSelectCurr);
           SC_HANDLE_COMMAND(IDC_SELECTALL,OnSelectAll);
           SC_HANDLE_COMMAND(IDC_SELECTNONE,OnSelectNone);
           SC_HANDLE_COMMAND(IDC_PROPERTIES,OnProperties);
       }
       SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CListviewTestDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
    
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBox(hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_TEST_DIALOG), NULL, CListviewTestDialog::DialogProc );
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\lvprops.h ===
#ifndef __LVPROPS_H_INCLUDED
#define __LVPROPS_H_INCLUDED

#include <windows.h>

class CListviewPropsDialog
{
public:
    class CData
    {
    public:
        bool bFullItemSelect;
        bool bCustomIcon;
        SIZE sizeItemSpacing;
    };

private:
    HWND   m_hWnd;
    CData *m_pData;

private:
    CListviewPropsDialog(void);
    CListviewPropsDialog( const CListviewPropsDialog & );
    CListviewPropsDialog &operator=( const CListviewPropsDialog & );

private:
    
    explicit CListviewPropsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }
    ~CListviewPropsDialog(void)
    {
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (!m_pData)
        {
            EndDialog(m_hWnd,IDCANCEL);
            return 0;
        }
        if (m_pData->bFullItemSelect)
        {
            SendDlgItemMessage( m_hWnd, IDC_FULLSELECT, BM_SETCHECK, BST_CHECKED, 0 );
        }
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_SETRANGE, 0, MAKELONG(50,4) );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_SETPOS, 0, m_pData->sizeItemSpacing.cx );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_SETRANGE, 0, MAKELONG(50,4) );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_SETPOS, 0, m_pData->sizeItemSpacing.cy );
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        m_pData->sizeItemSpacing.cx = static_cast<LONG>(SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_GETPOS, 0, 0 ));
        m_pData->sizeItemSpacing.cy = static_cast<LONG>(SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_GETPOS, 0, 0 ));
        m_pData->bFullItemSelect = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_FULLSELECT, BM_GETCHECK, 0, 0 ) );
        m_pData->bCustomIcon = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_CUSTOMICON, BM_GETCHECK, 0, 0 ) );
        EndDialog(m_hWnd,IDOK);
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
       {
       }
       SC_END_NOTIFY_MESSAGE_HANDLERS();
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
       }
       SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CListviewPropsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
    
};

#endif // __LVPROPS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\chklistv.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CHKLISTV.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        11/13/2000
 *
 *  DESCRIPTION: Listview with checkmarks
 *
 *******************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <simarray.h>
#include <psutil.h>
#include <wiadebug.h>
#include "chklistv.h"

CCheckedListviewHandler::CCheckedListviewHandler(void)
  : m_bFullImageHit(false),
    m_hImageList(NULL),
    m_nCheckedImageIndex(-1),
    m_nUncheckedImageIndex(-1)
{
    ZeroMemory(&m_sizeCheck,sizeof(m_sizeCheck));
    CreateDefaultCheckBitmaps();
}


CCheckedListviewHandler::~CCheckedListviewHandler(void)
{
    //
    // Free all allocated memory
    //
    DestroyImageList();
}

HBITMAP CCheckedListviewHandler::CreateBitmap( int nWidth, int nHeight )
{
    //
    // Create a 24bit RGB DIB section of a given size
    //
    HBITMAP hBitmap = NULL;
    HDC hDC = GetDC( NULL );
    if (hDC)
    {
        BITMAPINFO BitmapInfo = {0};
        BitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        BitmapInfo.bmiHeader.biWidth = nWidth;
        BitmapInfo.bmiHeader.biHeight = nHeight;
        BitmapInfo.bmiHeader.biPlanes = 1;
        BitmapInfo.bmiHeader.biBitCount = 24;
        BitmapInfo.bmiHeader.biCompression = BI_RGB;

        PBYTE *pBits = NULL;
        hBitmap = CreateDIBSection( hDC, &BitmapInfo, DIB_RGB_COLORS, (void**)&pBits, NULL, 0 );
        ReleaseDC( NULL, hDC );
    }
    return hBitmap;
}

void CCheckedListviewHandler::DestroyImageList(void)
{
    //
    // Destroy the image list and initialize related variables
    //
    if (m_hImageList)
    {
        ImageList_Destroy( m_hImageList );
        m_hImageList = NULL;
    }
    m_nCheckedImageIndex = m_nUncheckedImageIndex = -1;
    m_sizeCheck.cx = m_sizeCheck.cy = 0;
}


bool CCheckedListviewHandler::ImagesValid(void)
{
    //
    // Make sure the images in the image list are valid
    //
    return (m_hImageList && m_nCheckedImageIndex >= 0 && m_nUncheckedImageIndex >= 0 && m_sizeCheck.cx && m_sizeCheck.cy);
}

void CCheckedListviewHandler::Attach( HWND hWnd )
{
    if (m_WindowList.Find(hWnd) < 0)
    {
        m_WindowList.Append(hWnd);
    }
}

void CCheckedListviewHandler::Detach( HWND hWnd )
{
    int nIndex = m_WindowList.Find(hWnd);
    if (nIndex >= 0)
    {
        m_WindowList.Delete( nIndex );
    }
}

bool CCheckedListviewHandler::WindowInList( HWND hWnd )
{
    return (m_WindowList.Find(hWnd) >= 0);
}

//
// Private helpers
//
BOOL CCheckedListviewHandler::InCheckBox( HWND hwndList, int nItem, const POINT &pt )
{
    BOOL bResult = FALSE;
    if (WindowInList(hwndList))
    {
#if defined(DBG)
        WIA_TRACE((TEXT("nItem: %d"), nItem ));
        LVHITTESTINFO LvHitTestInfo = {0};
        LvHitTestInfo.pt = pt;
        ListView_SubItemHitTest( hwndList, &LvHitTestInfo );
        WIA_TRACE((TEXT("LvHitTestInfo.iItem: %d"), LvHitTestInfo.iItem ));
#endif
        RECT rcItem = {0};
        if (ListView_GetItemRect( hwndList, nItem, &rcItem, LVIR_ICON ))
        {
            WIA_TRACE((TEXT("pt: (%d, %d)"), pt.x, pt.y ));
            WIA_TRACE((TEXT("rcItem: (%d, %d), (%d, %d)"), rcItem.left, rcItem.top, rcItem.right, rcItem.bottom ));
            rcItem.right -= c_sizeCheckMarginX;
            rcItem.top += c_sizeCheckMarginY;
            rcItem.left = rcItem.right - m_sizeCheck.cx;
            rcItem.bottom = rcItem.top + m_sizeCheck.cy;
            
            bResult = PtInRect( &rcItem, pt );
        }
    }
    return bResult;
}


UINT CCheckedListviewHandler::GetItemCheckState( HWND hwndList, int nIndex )
{
    UINT nResult = LVCHECKSTATE_NOCHECK;
    
    NMGETCHECKSTATE NmGetCheckState = {0};
    NmGetCheckState.hdr.hwndFrom = hwndList;
    NmGetCheckState.hdr.idFrom = GetWindowLong( hwndList, GWL_ID );
    NmGetCheckState.hdr.code = NM_GETCHECKSTATE;
    NmGetCheckState.nItem = nIndex;

    nResult = static_cast<UINT>(SendMessage( reinterpret_cast<HWND>(GetWindowLongPtr(hwndList,GWLP_HWNDPARENT)), WM_NOTIFY, GetWindowLong( hwndList, GWL_ID ), reinterpret_cast<LPARAM>(&NmGetCheckState) ) );
    return nResult;
}


UINT CCheckedListviewHandler::SetItemCheckState( HWND hwndList, int nIndex, UINT nCheck )
{
    UINT nResult = GetItemCheckState( hwndList, nIndex );
    
    NMSETCHECKSTATE NmSetCheckState = {0};
    NmSetCheckState.hdr.hwndFrom = hwndList;
    NmSetCheckState.hdr.idFrom = GetWindowLong( hwndList, GWL_ID );
    NmSetCheckState.hdr.code = NM_SETCHECKSTATE;
    NmSetCheckState.nItem = nIndex;
    NmSetCheckState.nCheck = nCheck;

    SendMessage( reinterpret_cast<HWND>(GetWindowLongPtr(hwndList,GWLP_HWNDPARENT)), WM_NOTIFY, GetWindowLong( hwndList, GWL_ID ), reinterpret_cast<LPARAM>(&NmSetCheckState) );
    return nResult;
}


int CCheckedListviewHandler::GetItemCheckBitmap( HWND hwndList, int nIndex )
{
    int nResult = -1;
    if (WindowInList(hwndList))
    {
        UINT nCheck = GetItemCheckState( hwndList, nIndex );
        switch (nCheck)
        {
        case LVCHECKSTATE_CHECKED:
            nResult = m_nCheckedImageIndex;
            break;

        case LVCHECKSTATE_UNCHECKED:
            nResult = m_nUncheckedImageIndex;
            break;
        }
    }
    return nResult;
}


BOOL CCheckedListviewHandler::RealHandleListClick( WPARAM wParam, LPARAM lParam, bool bIgnoreHitArea )
{
    BOOL bResult = FALSE;
    NMITEMACTIVATE *pNmItemActivate = reinterpret_cast<NMITEMACTIVATE*>(lParam);
    if (pNmItemActivate)
    {
        if (WindowInList(pNmItemActivate->hdr.hwndFrom))
        {
            if (bIgnoreHitArea || InCheckBox(pNmItemActivate->hdr.hwndFrom,pNmItemActivate->iItem,pNmItemActivate->ptAction))
            {
                UINT nCheck = GetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem );
                switch (nCheck)
                {
                case LVCHECKSTATE_UNCHECKED:
                    SetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem, LVCHECKSTATE_CHECKED );
                    break;

                case LVCHECKSTATE_CHECKED:
                    SetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem, LVCHECKSTATE_UNCHECKED );
                    break;
                }
            }
            bResult = TRUE;
        }
    }
    return 0;
}


//
// Message handlers
//
BOOL CCheckedListviewHandler::HandleListClick( WPARAM wParam, LPARAM lParam )
{
    return RealHandleListClick( wParam, lParam, m_bFullImageHit );
}

BOOL CCheckedListviewHandler::HandleListDblClk( WPARAM wParam, LPARAM lParam )
{
    return RealHandleListClick( wParam, lParam, true );
}

BOOL CCheckedListviewHandler::HandleListKeyDown( WPARAM wParam, LPARAM lParam, LRESULT &lResult )
{
    BOOL bHandled = FALSE;
    NMLVKEYDOWN *pNmLvKeyDown = reinterpret_cast<NMLVKEYDOWN*>(lParam);
    if (WindowInList(pNmLvKeyDown->hdr.hwndFrom))
    {
        lResult = 0;
        bool bControl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
        bool bShift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
        bool bAlt = (GetKeyState(VK_MENU) & 0x8000) != 0;
        if (pNmLvKeyDown->wVKey == VK_SPACE && !bControl && !bShift && !bAlt)
        {
            int nFocusedItem = ListView_GetNextItem( pNmLvKeyDown->hdr.hwndFrom, -1, LVNI_FOCUSED );
            if (nFocusedItem >= 0)
            {
                UINT nCheckState = GetItemCheckState( pNmLvKeyDown->hdr.hwndFrom, nFocusedItem );
                if (LVCHECKSTATE_CHECKED == nCheckState)
                {
                    nCheckState = LVCHECKSTATE_UNCHECKED;
                }
                else if (LVCHECKSTATE_UNCHECKED == nCheckState)
                {
                    nCheckState = LVCHECKSTATE_CHECKED;
                }
                if (nCheckState != LVCHECKSTATE_NOCHECK)
                {
                    int nCurrItem = -1;
                    while (true)
                    {
                        nCurrItem = ListView_GetNextItem( pNmLvKeyDown->hdr.hwndFrom, nCurrItem, LVNI_SELECTED );
                        if (nCurrItem < 0)
                        {
                            break;
                        }
                        SetItemCheckState( pNmLvKeyDown->hdr.hwndFrom, nCurrItem, nCheckState );
                    }
                }
            }
            lResult = TRUE;
            bHandled = TRUE;
            InvalidateRect( pNmLvKeyDown->hdr.hwndFrom, NULL, FALSE );
            UpdateWindow( pNmLvKeyDown->hdr.hwndFrom );
        }
    }
    return bHandled;
}


BOOL CCheckedListviewHandler::HandleListCustomDraw( WPARAM wParam, LPARAM lParam, LRESULT &lResult )
{
    BOOL bHandled = FALSE; 
    NMLVCUSTOMDRAW *pNmCustomDraw = reinterpret_cast<NMLVCUSTOMDRAW*>(lParam);
    if (pNmCustomDraw)
    {
        if (WindowInList(pNmCustomDraw->nmcd.hdr.hwndFrom))
        {
            lResult = CDRF_DODEFAULT;
#if defined(DUMP_NM_CUSTOMDRAW_MESSAGES)
            DumpCustomDraw(lParam,TEXT("SysListView32"),CDDS_ITEMPOSTPAINT);
#endif
            if (CDDS_PREPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                lResult = CDRF_NOTIFYITEMDRAW;
            }
            else if (CDDS_ITEMPREPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                lResult = CDRF_NOTIFYPOSTPAINT|CDRF_NOTIFYSUBITEMDRAW;
            }
            else if (CDDS_ITEMPOSTPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                int nImageListIndex = GetItemCheckBitmap( pNmCustomDraw->nmcd.hdr.hwndFrom, static_cast<int>(pNmCustomDraw->nmcd.dwItemSpec) );
                if (nImageListIndex >= 0)
                {
                    RECT rcItem = {0};
                    if (ListView_GetItemRect( pNmCustomDraw->nmcd.hdr.hwndFrom, pNmCustomDraw->nmcd.dwItemSpec, &rcItem, LVIR_ICON ))
                    {
                        ImageList_Draw( m_hImageList, nImageListIndex, pNmCustomDraw->nmcd.hdc, rcItem.right - m_sizeCheck.cx - c_sizeCheckMarginX, rcItem.top + c_sizeCheckMarginY, ILD_NORMAL );
                        lResult = CDRF_SKIPDEFAULT;
                    }
                }
            }
            bHandled = TRUE;
        }
    }
    return bHandled;
}

void CCheckedListviewHandler::Select( HWND hwndList, int nIndex, UINT nSelect )
{
    if (WindowInList(hwndList))
    {
        //
        // -1 means all images
        //
        if (nIndex < 0)
        {
            for (int i=0;i<ListView_GetItemCount(hwndList);i++)
            {
                SetItemCheckState(hwndList,i,nSelect);
            }
        }
        else
        {
            SetItemCheckState(hwndList,nIndex,nSelect);
        }
    }
}


bool CCheckedListviewHandler::FullImageHit(void) const
{
    return m_bFullImageHit;
}

void CCheckedListviewHandler::FullImageHit( bool bFullImageHit )
{
    m_bFullImageHit = bFullImageHit;
}


bool CCheckedListviewHandler::CreateDefaultCheckBitmaps(void)
{
    bool bResult = false;
    
    //
    // Get the proper size for the checkmarks
    //
    int nWidth = GetSystemMetrics( SM_CXMENUCHECK );
    int nHeight = GetSystemMetrics( SM_CXMENUCHECK );

    //
    // Make sure they are valid sizes
    //
    if (nWidth && nHeight)
    {
        //
        // Create the bitmaps and make sure they are valid
        //
        HBITMAP hBitmapChecked = CreateBitmap( nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2 );
        HBITMAP hBitmapUnchecked = CreateBitmap( nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2 );
        if (hBitmapChecked && hBitmapUnchecked)
        {
            //
            // Get the desktop DC
            //
            HDC hDC = GetDC( NULL );
            if (hDC)
            {
                //
                // Create a memory DC
                //
                HDC hMemDC = CreateCompatibleDC( hDC );
                if (hMemDC)
                {
                    //
                    // This is the rect that contains the image + the margin
                    //
                    RECT rcEntireBitmap = {0,0,nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2};
                    
                    //
                    // This is the rect that contains only the image
                    //
                    RECT rcControlBitmap = {c_nCheckmarkBorder,c_nCheckmarkBorder,nWidth+c_nCheckmarkBorder, nHeight+c_nCheckmarkBorder};
                    
                    //
                    // Paint the checked bitmap
                    //
                    HBITMAP hOldBitmap = SelectBitmap( hMemDC, hBitmapChecked );
                    FillRect( hMemDC, &rcEntireBitmap, GetSysColorBrush( COLOR_WINDOW ) );
                    DrawFrameControl( hMemDC, &rcControlBitmap, DFC_BUTTON, DFCS_BUTTONCHECK|DFCS_CHECKED|DFCS_FLAT );

                    //
                    // Paint the unchecked bitmap
                    //
                    SelectBitmap( hMemDC, hBitmapUnchecked );
                    FillRect( hMemDC, &rcEntireBitmap, GetSysColorBrush( COLOR_WINDOW ) );
                    DrawFrameControl( hMemDC, &rcControlBitmap, DFC_BUTTON, DFCS_BUTTONCHECK|DFCS_FLAT );

                    //
                    // Restore and delete the memory DC
                    //
                    SelectBitmap( hMemDC, hOldBitmap );
                    DeleteDC( hMemDC );

                    //
                    // Save the images
                    //
                    bResult = SetCheckboxImages( hBitmapChecked, hBitmapUnchecked );

                    //
                    // The images are in the image list now, so discard them
                    //
                    DeleteBitmap(hBitmapChecked);
                    DeleteBitmap(hBitmapUnchecked);
                }
                ReleaseDC( NULL, hDC );
            }
        }
    }
    return bResult;
}


bool CCheckedListviewHandler::SetCheckboxImages( HBITMAP hChecked, HBITMAP hUnchecked )
{
    DestroyImageList();

    //
    // Find out the size of the bitmaps and make sure they are the same.
    //
    SIZE sizeChecked = {0};
    if (PrintScanUtil::GetBitmapSize( hChecked, sizeChecked ))
    {
        SIZE sizeUnchecked = {0};
        if (PrintScanUtil::GetBitmapSize( hUnchecked, sizeUnchecked ))
        {
            if (sizeChecked.cx == sizeUnchecked.cx && sizeChecked.cy == sizeUnchecked.cy)
            {
                //
                // Save the size
                //
                m_sizeCheck.cx = sizeChecked.cx;
                m_sizeCheck.cy = sizeChecked.cy;
                
                //
                // Create the image list to hold the checkboxes
                //
                m_hImageList = ImageList_Create( m_sizeCheck.cx, m_sizeCheck.cy, ILC_COLOR24, 2, 2 );
                if (m_hImageList)
                {
                    //
                    // Save the indices of the images
                    //
                    m_nCheckedImageIndex = ImageList_Add( m_hImageList, hChecked, NULL );
                    m_nUncheckedImageIndex = ImageList_Add( m_hImageList, hUnchecked, NULL );
                }
            }
        }
    }
    
    //
    // If the images aren't valid, clean up
    //
    bool bResult = ImagesValid();
    if (!bResult)
    {
        DestroyImageList();
    }
    return bResult;
}

bool CCheckedListviewHandler::SetCheckboxImages( HICON hChecked, HICON hUnchecked )
{
    DestroyImageList();

    //
    // Find out the size of the icons and make sure they are the same.
    //
    SIZE sizeChecked = {0};
    if (PrintScanUtil::GetIconSize( hChecked, sizeChecked ))
    {
        SIZE sizeUnchecked = {0};
        if (PrintScanUtil::GetIconSize( hUnchecked, sizeUnchecked ))
        {
            if (sizeChecked.cx == sizeUnchecked.cx && sizeChecked.cy == sizeUnchecked.cy)
            {
                //
                // Save the size
                //
                m_sizeCheck.cx = sizeChecked.cx;
                m_sizeCheck.cy = sizeChecked.cy;

                //
                // Create the image list to hold the checkboxes
                //
                m_hImageList = ImageList_Create( m_sizeCheck.cx, m_sizeCheck.cy, ILC_COLOR24|ILC_MASK, 2, 2 );
                if (m_hImageList)
                {
                    //
                    // Save the indices of the images
                    //
                    m_nCheckedImageIndex = ImageList_AddIcon( m_hImageList, hChecked );
                    m_nUncheckedImageIndex = ImageList_AddIcon( m_hImageList, hUnchecked );
                }
            }
        }
    }
    
    //
    // If the images aren't valid, clean up
    //
    bool bResult = ImagesValid();
    if (!bResult)
    {
        DestroyImageList();
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\chklistv.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CHKLISTV.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        11/13/2000
 *
 *  DESCRIPTION: Listview with checkmarks
 *
 *******************************************************************************/
#ifndef __CHKLISTV_H_INCLUDED
#define __CHKLISTV_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <simarray.h>

//
// The WM_NOTIFY messages are sent to get and set the check state, which is maintained by the application
//
#define NM_GETCHECKSTATE (WM_USER+1)
#define NM_SETCHECKSTATE (WM_USER+2)

//
// These are the valid check states
//
#define LVCHECKSTATE_NOCHECK    0
#define LVCHECKSTATE_UNCHECKED  1
#define LVCHECKSTATE_CHECKED    2

//
// These are the WM_NOTIFY structs sent with NM_SETCHECKSTATE and NM_GETCHECKSTATE
//
struct NMGETCHECKSTATE
{
    NMHDR  hdr;
    int    nItem;
};

struct NMSETCHECKSTATE
{
    NMHDR  hdr;
    int    nItem;
    UINT   nCheck;
};


class CCheckedListviewHandler
{
private:
    
    //
    // Private constants
    //
    enum
    {
        c_nCheckmarkBorder = 1,
        c_sizeCheckMarginX = 5,
        c_sizeCheckMarginY = 5
    };

private:
    CSimpleDynamicArray<HWND> m_WindowList;            // The list of windows we are registered to handle
    bool                      m_bFullImageHit;         // If 'true', activating the image toggles the selection
    HIMAGELIST                m_hImageList;            // Image list for holding the checkmarks
    int                       m_nCheckedImageIndex;    // Index of the checked image
    int                       m_nUncheckedImageIndex;  // Index of the unchecked image
    SIZE                      m_sizeCheck;             // Size of the images in the image list

private:
    //
    // No implementation
    //
    CCheckedListviewHandler( const CCheckedListviewHandler & );
    CCheckedListviewHandler &operator=( const CCheckedListviewHandler & );

public:
    //
    // Sole constructor and destructor
    //
    CCheckedListviewHandler(void);
    ~CCheckedListviewHandler(void);

private:
    
    //
    // Private helpers
    //
    HBITMAP CreateBitmap( int nWidth, int nHeight );
    BOOL InCheckBox( HWND hwndList, int nItem, const POINT &pt );
    UINT GetItemCheckState( HWND hwndList, int nIndex );
    UINT SetItemCheckState( HWND hwndList, int nIndex, UINT nCheck );
    int GetItemCheckBitmap( HWND hwndList, int nIndex );
    BOOL RealHandleListClick( WPARAM wParam, LPARAM lParam, bool bIgnoreHitArea );
    void DestroyImageList(void);
    bool WindowInList( HWND hWnd );

public:
    //
    // Message handlers.  They return true if the message is handled.
    //
    BOOL HandleListClick( WPARAM wParam, LPARAM lParam );
    BOOL HandleListDblClk( WPARAM wParam, LPARAM lParam );
    BOOL HandleListKeyDown( WPARAM wParam, LPARAM lParam, LRESULT &lResult );
    BOOL HandleListCustomDraw( WPARAM wParam, LPARAM lParam, LRESULT &lResult );

    //
    // Public helper functions
    //
    void Select( HWND hwndList, int nIndex, UINT nSelect );
    bool FullImageHit(void) const;
    void FullImageHit( bool bFullImageHit );
    bool CreateDefaultCheckBitmaps(void);
    bool SetCheckboxImages( HBITMAP hChecked, HBITMAP hUnchecked );
    bool SetCheckboxImages( HICON hChecked, HICON hUnchecked );
    bool ImagesValid(void);
    void Attach( HWND hWnd );
    void Detach( HWND hWnd );
};

#endif // __CHKLISTV_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clvtest.rc
//
#define IDD_LISTVIEW_TEST_DIALOG        101
#define IDB_IMAGE                       103
#define IDB_IMAGE1                      103
#define IDD_LISTVIEW_PROPS_DIALOG       106
#define IDB_IMAGE4                      107
#define IDB_IMAGE3                      108
#define IDB_IMAGE2                      109
#define IDB_IMAGE5                      110
#define IDI_CHECKED                     111
#define IDI_UNCHECKED                   112
#define IDC_LIST                        1000
#define IDC_SELECTALL                   1003
#define IDC_SELECTNONE                  1004
#define IDC_FULLSELECT                  1004
#define IDC_SELECTCURR                  1005
#define IDC_ICONSPACING_X_EDIT          1005
#define IDC_ICONSPACING_X_SPIN          1006
#define IDC_ICONSPACING_Y_EDIT          1007
#define IDC_PROPERTIES                  1007
#define IDC_ICONSPACING_Y_SPIN          1008
#define IDC_CUSTOMICON                  1009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clvtest2.rc
//
#define IDD_LISTVIEW_TEST_DIALOG        101
#define IDB_IMAGE1                      103
#define IDB_IMAGE4                      107
#define IDB_IMAGE3                      108
#define IDB_IMAGE2                      109
#define IDB_IMAGE5                      110
#define IDC_LIST                        1000
#define IDC_SELECTALL                   1003
#define IDC_SELECTNONE                  1004
#define IDC_SELECTCURR                  1005
#define IDC_PROPERTIES                  1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\clvtest2\clvtest2.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>
#include "resource.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

static HINSTANCE g_hInstance;

static const int c_nMaxImages         = 20;

static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 10;

class CListviewTestDialog
{
private:
    HWND                    m_hWnd;
    SIZE                    m_sizeImage;
    SIZE                    m_sizeMargin;

private:
    CListviewTestDialog(void);
    CListviewTestDialog( const CListviewTestDialog & );
    CListviewTestDialog &operator=( const CListviewTestDialog & );

private:
    
    explicit CListviewTestDialog( HWND hWnd )
      : m_hWnd(hWnd)
    {
        ZeroMemory(&m_sizeImage,sizeof(SIZE));
        m_sizeMargin.cx = c_nAdditionalMarginX;
        m_sizeMargin.cy = c_nAdditionalMarginY;
    }
    ~CListviewTestDialog(void)
    {
    }


    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_LIST );
        if (hwndList)
        {
            //
            // Load some images for the image list
            //
            struct
            {
                UINT    nResId;
                HBITMAP hBitmap;
                int     nImageIndex;
            } Images[] =
            {
                { IDB_IMAGE1, NULL, 0 },
                { IDB_IMAGE2, NULL, 0 },
                { IDB_IMAGE3, NULL, 0 },
                { IDB_IMAGE4, NULL, 0 },
                { IDB_IMAGE5, NULL, 0 }
            };

            bool bSuccess = true;
            for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
            {
                Images[i].hBitmap = reinterpret_cast<HBITMAP>(LoadImage(g_hInstance,MAKEINTRESOURCE(Images[i].nResId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));
                if (!Images[i].hBitmap)
                {
                    bSuccess = false;
                }
            }

            
            if (bSuccess)
            {
                //
                // Tell the listview we don't want labels, and want border selection
                //
                ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES );
                
                BITMAP bm = {0};
                if (GetObject( Images[0].hBitmap, sizeof(BITMAP), &bm ))
                {
                    m_sizeImage.cx = bm.bmWidth;
                    m_sizeImage.cy = bm.bmHeight;
                }
                ListView_SetIconSpacing( hwndList, m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
                
                //
                // Create the image list
                //
                HIMAGELIST hImageList = ImageList_Create( m_sizeImage.cx, m_sizeImage.cy, ILC_COLOR24|ILC_MASK, 1, 1 );
                if (hImageList)
                {
                    //
                    // Add the image to the image list
                    //
                    bSuccess = true;
                    for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
                    {
                        Images[i].nImageIndex = ImageList_Add( hImageList, Images[i].hBitmap, NULL );
                        if (-1 == Images[i].nImageIndex)
                        {
                            bSuccess = false;
                        }
                    }

                    //
                    // Set the image list
                    //
                    ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );
                    
                    //
                    // Insert a few items
                    //
                    int nGroupId = 0;
                    for (int i=0;i<c_nMaxImages;i++)
                    {
                        if (i % 5 == 0)
                        {
                            WCHAR szGroupName[MAX_PATH];
                            wsprintfW( szGroupName, L"This is group %d", (i/5)+1 );
                            LVGROUP LvGroup = {0};
                            LvGroup.cbSize = sizeof(LvGroup);
                            LvGroup.pszHeader = szGroupName;
                            LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                            LvGroup.uAlign = LVGA_HEADER_LEFT;
                            LvGroup.iGroupId = i/5;
                            LvGroup.state = LVGS_NORMAL;
                            nGroupId = static_cast<int>(ListView_InsertGroup( hwndList, i/5, &LvGroup ));
                        }
                        LVITEM LvItem = {0};
                        LvItem.mask = LVIF_IMAGE|LVIF_GROUPID;
                        LvItem.iImage = Images[i%ARRAYSIZE(Images)].nImageIndex;
                        LvItem.iItem = i;
                        LvItem.iGroupId = nGroupId;
                        ListView_InsertItem( hwndList, &LvItem );
                    }
    
                    //
                    // Select the first item
                    //
                    ListView_SetItemState( hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED );
                    ListView_EnableGroupView( hwndList, TRUE );
                }
            }
        }
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnSelectAll( WPARAM, LPARAM )
    {
        ListView_SetCheckState( GetDlgItem( m_hWnd, IDC_LIST ), -1, TRUE );
    }
    void OnSelectNone( WPARAM, LPARAM )
    {
        ListView_SetCheckState( GetDlgItem( m_hWnd, IDC_LIST ), -1, FALSE );
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
        return 0;
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        switch (LOWORD(wParam))
        {
        case IDOK:
            OnOK(wParam,lParam);
            break;

        case IDCANCEL:
            OnCancel(wParam,lParam);
            break;

        case IDC_SELECTALL:
            OnSelectAll(wParam,lParam);
            break;

        case IDC_SELECTNONE:
            OnSelectNone(wParam,lParam);
            break;
        }
        return 0;
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        INT_PTR bResult = FALSE;
        switch (uMsg)
        {
        case WM_INITDIALOG:
            {
                CListviewTestDialog *pListviewTestDialog = new CListviewTestDialog(hWnd);
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_USER, reinterpret_cast<LONG_PTR>(pListviewTestDialog) );
                    bResult = pListviewTestDialog->OnInitDialog( wParam, lParam );
                }
            }
            break;

        case WM_COMMAND:
            {
                CListviewTestDialog *pListviewTestDialog = reinterpret_cast<CListviewTestDialog*>(GetWindowLongPtr( hWnd, DWLP_USER ));
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_MSGRESULT, pListviewTestDialog->OnCommand( wParam, lParam ) );
                }
                bResult = TRUE;
            }
            break;
        
        case WM_NOTIFY:
            {
                CListviewTestDialog *pListviewTestDialog = reinterpret_cast<CListviewTestDialog*>(GetWindowLongPtr( hWnd, DWLP_USER ));
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_MSGRESULT, pListviewTestDialog->OnNotify( wParam, lParam ) );
                }
                bResult = TRUE;
            }
            break;
        }
        return bResult;
    }
    
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBox(hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_TEST_DIALOG), NULL, CListviewTestDialog::DialogProc );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\dbgtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dbgtest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\dbgtest\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

#
# include the WIA global build settings
#

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

TARGETNAME=dbgtest
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES= \
          ..\dbgtest.cpp     \
          ..\dbgtest.rc

TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\dumpdevs\dumpdevs.cpp ===
#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <wianew.h>
#include <simreg.h>
#include <dumpprop.h>
#include <devlist.h>
#include <simbstr.h>
#include <stdio.h>

void DumpDevice( IWiaDevMgr *pWiaDevMgr, HANDLE hFile, const CSimpleStringWide &strDeviceID )
{
    //
    // Create the device manager
    //
    fprintf( stderr, "Creating [%ls]\n", strDeviceID.String() );
    CComPtr<IWiaItem> pWiaItem;
    HRESULT hr = pWiaDevMgr->CreateDevice( CSimpleBStr(strDeviceID), &pWiaItem );
    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strDeviceName;
        PropStorageHelpers::GetProperty( pWiaItem, WIA_DIP_DEV_NAME, strDeviceName );
        CWiaDebugDumpToFileHandle DebugDump( hFile );
        DebugDump.Print( TEXT("") );
        DebugDump.Print( CSimpleString().Format( TEXT("Device: %ws"), strDeviceName.String() ) );
        DebugDump.Print( TEXT("===============================================") );
        DebugDump.DumpRecursive(pWiaItem);
    }
}

bool GetStringArgument( int argc, wchar_t *argv[], CSimpleString &strArgument, int &nCurrArg )
{
    bool bResult = true;
    if (lstrlenW(argv[nCurrArg]) > 2)
    {
        if (argv[nCurrArg][2] == L':')
        {
            strArgument = argv[nCurrArg] + 3;
        }
        else
        {
            strArgument = argv[nCurrArg] + 2;
        }
    }
    else if (nCurrArg < argc-1)
    {
        strArgument = argv[++nCurrArg];
    }
    else bResult = false;
    return bResult;
}

bool ParseArguments( int argc, wchar_t *argv[], CSimpleDynamicArray<CSimpleString> &DeviceIDs, CSimpleString &strOutputFile, bool &bHidden )
{
    int nCurrArg = 1;
    while (nCurrArg < argc)
    {
        if (argv[nCurrArg][0] == L'-')
        {
            switch (argv[nCurrArg][1])
            {
            case 'd':
                {
                    CSimpleString strArg;
                    if (GetStringArgument( argc, argv, strArg, nCurrArg ))
                    {
                        DeviceIDs.Append(strArg);
                    }
                }
                break;

            case 'o':
                {
                    CSimpleString strArg;
                    if (GetStringArgument( argc, argv, strArg, nCurrArg ))
                    {
                        strOutputFile = strArg;
                    }
                }
                break;

            case 'h':
                {
                    bHidden = true;
                }
                break;
            }
        }
        nCurrArg++;
    }

    return true;
}

class CCoInitialize
{
private:
    HRESULT m_hr;

private:
    CCoInitialize( const CCoInitialize & );
    CCoInitialize &operator=( const CCoInitialize & );

public:
    CCoInitialize()
    {
        m_hr = CoInitialize(NULL);
    }
    ~CCoInitialize()
    {
        if (SUCCEEDED(m_hr))
        {
            CoUninitialize();
        }
    }
    HRESULT Result(void) const
    {
        return m_hr;
    }
};

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    CSimpleDynamicArray<CSimpleString> DeviceIDs;
    CSimpleString strOutputFile;
    bool bHidden = false;

    if (ParseArguments(argc,argv,DeviceIDs,strOutputFile,bHidden))
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        if (strOutputFile.Length())
        {
            hFile = CreateFile( strOutputFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        }
        else
        {
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
        }

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Initialize COM
            //
            CCoInitialize coinit;
            if (SUCCEEDED(coinit.Result()))
            {
                //
                // Create the device manager
                //
                CComPtr<IWiaDevMgr> pWiaDevMgr;
                HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
                if (SUCCEEDED(hr))
                {
                    if (DeviceIDs.Size())
                    {
                        for (int i=0;i<DeviceIDs.Size();i++)
                        {
                            DumpDevice( pWiaDevMgr, hFile, CSimpleStringConvert::WideString(DeviceIDs[i]) );
                        }
                    }
                    else
                    {
                        CDeviceList DeviceList(pWiaDevMgr,StiDeviceTypeDefault,bHidden ? 0xFFFFFFFF : 0);
                        for (int i=0;i<DeviceList.Size();i++)
                        {
                            CSimpleStringWide strDeviceID;
                            if (PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_ID, strDeviceID ))
                            {
                                DumpDevice( pWiaDevMgr, hFile, CSimpleStringConvert::WideString(strDeviceID) );
                            }
                            else
                            {
                                fprintf( stderr, "Unable to get the device ID\n" );
                            }
                        }
                    }
                }
            }
        }
        else
        {
            fprintf( stderr, "Unable to open %ls for writing\n", strOutputFile.String() );
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\dbgtest\dbgtest.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MAIN.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/6/1999
 *
 *  DESCRIPTION: Test program for the debugging classes
 *
 *******************************************************************************/
#include <windows.h>
#define INITGUID
#include "wianew.h"
#include "wiadebug.h"
#include "simcrit.h"


void Function( int n )
{
    WIA_PUSH_FUNCTION((TEXT("Function( %d )"), n ));
}

DWORD WINAPI ThreadProc( LPVOID pVoid )
{
    WIA_PUSH_FUNCTION_MASK(( 0x00000001, TEXT("ThreadProc( %d )"), (int)(INT_PTR)pVoid ));
    //WIA_PRINTGUID((IID_IUnknown,TEXT("I am printing IID_MYTEST")));
    Function( (int)(INT_PTR)pVoid );

    for (int i=0;i<5;i++)
    {
        WIA_TRACE((TEXT("This is a test (incrementing %d)"), i));
        WIA_WARNING((TEXT("This is a warning (%d)"), i));
        WIA_ERROR((TEXT("This is an error (%d)"), i));
        WIA_PRINTHRESULT((E_NOTIMPL,TEXT("This is an HRESULT error (%d)"), i));
        Sleep(0);
    }
    return 0;
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCommandLine, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    WIA_PUSH_FUNCTION((TEXT("WinMain( %08X, %08X, \"%hs\", %d )"), hInstance, hPrevInstance, pszCommandLine, nCmdShow ));
    const int nHandles = MAXIMUM_WAIT_OBJECTS-10;
    HANDLE Handles[nHandles];
    for (int i=0;i<nHandles;i++)
    {
        DWORD dwThreadId;
        Handles[i] = CreateThread( NULL, 0, ThreadProc, (PVOID)i, 0, &dwThreadId );
    }
    WaitForMultipleObjects( nHandles, Handles, TRUE, INFINITE );
    for (i=0;i<nHandles;i++)
    {
        CloseHandle( Handles[i] );
    }

    WIA_REPORT_LEAKS();
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\forceerr.cpp ===
#include <windows.h>
#include <commctrl.h>
#include <uicommon.h>
#include "errdlg.h"
#include "resource.h"

//
// Global HINSTANCE
//
HINSTANCE g_hInstance = NULL;


int __stdcall WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE(hInstance);
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBoxParam( hInstance, MAKEINTRESOURCE(IDD_ERROR_DIALOG), NULL, CErrorMessageDialog::DialogProc, NULL );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\errdlg.cpp ===
#include <windows.h>
#include <uicommon.h>
#include <commctrl.h>
#include <shellext.h>
#include <simcrack.h>
#include <shlwapi.h>
#include "errdlg.h"
#include "rawerror.h"
#include "resource.h"

extern HINSTANCE g_hInstance;

//
// String constants
//
#define INI_FILE_NAME    TEXT("forceerr.ini")
#define GENERAL_SECTION  TEXT("ForceError")
#define PROGRAMS_SECTION TEXT("Programs")
#define LAST_PROGRAM     TEXT("LastProgram")

CErrorMessageDialog::CErrorMessageDialog( HWND hWnd )
  : m_hWnd(hWnd),
    m_strIniFileName(INI_FILE_NAME)
{
    //
    // Create an absolute pathname for the default INI file,
    // so it points to the same directory as the EXE
    //
    TCHAR szCurrFile[MAX_PATH];
    if (GetModuleFileName( NULL, szCurrFile, ARRAYSIZE(szCurrFile)))
    {
        if (PathRemoveFileSpec( szCurrFile ))
        {
            m_strIniFileName = CSimpleString(szCurrFile);
            if (!m_strIniFileName.MatchLastCharacter(TEXT('\\')))
            {
                m_strIniFileName += TEXT("\\");
            }
            m_strIniFileName += CSimpleString(INI_FILE_NAME);
        }
    }

    //
    // If the default INI file location has been overridden in the registry, use it instead
    //
    CSimpleString strIniFile = CSimpleReg( HKEY_FORCEERROR, REGSTR_FORCEERR_KEY ).Query( INI_FILE_NAME, TEXT("") );
    if (strIniFile.Length())
    {
        m_strIniFileName = strIniFile;
    }
}

CErrorMessageDialog::~CErrorMessageDialog()
{
}

void CErrorMessageDialog::SelectError( HRESULT hrSelect )
{
    LRESULT nSel = 0;
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETCOUNT, 0, 0 );i++)
    {
        HRESULT hr = static_cast<HRESULT>(SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETITEMDATA, i, 0 ));
        if (hrSelect == hr)
        {
            nSel = i;
            break;
        }
    }
    SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_SETCURSEL, nSel, 0 );
}

void CErrorMessageDialog::SelectErrorPoint( int nErrorPoint )
{
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_GETCOUNT, 0, 0 );i++)
    {
        int nCurrErrorPoint = GetComboBoxItemData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ), i );
        if (nErrorPoint == nCurrErrorPoint)
        {
            SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_SETCURSEL, i, 0 );
            break;
        }
    }
}


LRESULT CErrorMessageDialog::GetComboBoxItemData( HWND hWnd, LRESULT nIndex, LRESULT nDefault )
{
    LRESULT lResult = SendMessage( hWnd, CB_GETITEMDATA, nIndex, 0 );
    if (CB_ERR == lResult)
    {
        lResult = nDefault;
    }
    return lResult;
}

CSimpleString CErrorMessageDialog::GetComboBoxString( HWND hWnd, LRESULT nIndex )
{
    CSimpleString strResult;
    LRESULT nTextLen = SendMessage( hWnd, CB_GETLBTEXTLEN, nIndex, 0 );
    if (nTextLen)
    {
        LPTSTR pszText = new TCHAR[nTextLen+1];
        if (pszText)
        {
            if (SendMessage( hWnd, CB_GETLBTEXT, nIndex, reinterpret_cast<LPARAM>(pszText)))
            {
                strResult = pszText;
            }
            delete[] pszText;
        }
    }
    return strResult;
}

CSimpleString CErrorMessageDialog::GetCurrentlySelectedComboBoxString( HWND hWnd )
{
    CSimpleString strResult;
    LRESULT nIndex = SendMessage( hWnd, CB_GETCURSEL, 0, 0 );
    if (CB_ERR != nIndex)
    {
        strResult = GetComboBoxString( hWnd, nIndex );
    }
    return strResult;
}

LRESULT CErrorMessageDialog::GetCurrentComboBoxSelection( HWND hWnd )
{
    return SendMessage( hWnd, CB_GETCURSEL, 0, 0 );
}

LRESULT CErrorMessageDialog::GetCurrentComboBoxSelectionData( HWND hWnd, LRESULT nDefault )
{
    LRESULT lResult = nDefault;

    LRESULT nCurIndex = GetCurrentComboBoxSelection( hWnd );
    if (CB_ERR != nCurIndex)
    {
        lResult = GetComboBoxItemData( hWnd, nCurIndex, nDefault );
    }
    return lResult;
}

CSimpleString CErrorMessageDialog::GetIniString( LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault )
{
    CSimpleString strResult(pszDefault);

    TCHAR szString[1024];

    if (GetPrivateProfileString( pszSection, pszKey, pszDefault, szString, ARRAYSIZE(szString), m_strIniFileName ))
    {
        strResult = szString;
    }

    return strResult;
}

UINT CErrorMessageDialog::GetIniInt( LPCTSTR pszSection, LPCTSTR pszKey, UINT nDefault )
{
    return GetPrivateProfileInt( pszSection, pszKey, nDefault, m_strIniFileName );
}

void CErrorMessageDialog::PopulateProgramComboBox()
{
    WIA_PUSH_FUNCTION((TEXT("PopulateProgramComboBox")));
    SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_RESETCONTENT, 0, 0 );

    const int c_nSize = 24000;
    LPTSTR pszSections = new TCHAR[c_nSize];
    if (pszSections)
    {
        if (GetPrivateProfileString( PROGRAMS_SECTION, NULL, TEXT(""), pszSections, c_nSize, m_strIniFileName ))
        {
            for (LPTSTR pszCurr=pszSections;pszCurr && *pszCurr;pszCurr += lstrlen(pszCurr)+1 )
            {
                TCHAR szAppName[MAX_PATH] = {0};
                if (GetPrivateProfileString( PROGRAMS_SECTION, pszCurr, TEXT(""), szAppName, ARRAYSIZE(szAppName), m_strIniFileName ))
                {
                    if (lstrlen(szAppName))
                    {
                        SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(szAppName) );
                    }
                }
            }
        }
        delete[] pszSections;
    }
    
    LRESULT nSelectedItem = 0;
    CSimpleString strLastSelectedProgram = GetIniString( GENERAL_SECTION, LAST_PROGRAM );
    if (strLastSelectedProgram.Length())
    {
        nSelectedItem = SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_FINDSTRINGEXACT, -1, reinterpret_cast<LPARAM>(strLastSelectedProgram.String()));
        if (nSelectedItem < 0)
        {
            nSelectedItem = 0;
        }
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ) );
    SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_SETCURSEL, nSelectedItem, 0 );
}


CSimpleString CErrorMessageDialog::GetCurrentlySelectedProgram()
{
    return GetCurrentlySelectedComboBoxString( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ) );
}

void CErrorMessageDialog::PopulateErrorPointComboBox()
{
    WIA_PUSH_FUNCTION((TEXT("PopulateProgramComboBox")));
    SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_RESETCONTENT, 0, 0 );
    
    if (CB_ERR != SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(CSimpleString( IDS_NO_ERROR, g_hInstance ).String() ) ) )
    {
        CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
        if (strCurrentProgram.Length())
        {
            const int c_nSize = 24000;
            LPTSTR pszErrors = new TCHAR[c_nSize];
            if (pszErrors)
            {
                if (GetPrivateProfileString( strCurrentProgram, NULL, TEXT(""), pszErrors, c_nSize, m_strIniFileName ))
                {
                    for (LPTSTR pszCurr=pszErrors;pszCurr && *pszCurr;pszCurr += lstrlen(pszCurr)+1 )
                    {
                        if (lstrlen(pszCurr))
                        {
                            UINT nFlag = GetIniInt( strCurrentProgram, pszCurr);
                            if (nFlag)
                            {
                                LRESULT nIndex = SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pszCurr) );
                                if (CB_ERR != nIndex)
                                {
                                    SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_SETITEMDATA, nIndex, nFlag );
                                }
                            }
                        }
                    }
                }
                delete[] pszErrors;
            }
        }
        SelectErrorPoint( CWiaDebugClient::GetForceFailurePoint(strCurrentProgram) );
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) );
}

void CErrorMessageDialog::PopulateErrorsComboBox()
{
    SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_RESETCONTENT, 0, 0 );
    for (int i=0;i<g_ErrorMessageCount;i++)
    {
        LRESULT nIndex = SendMessage( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(g_ErrorMessages[i].pszName));
        if (nIndex != CB_ERR)
        {
            SendMessage( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), CB_SETITEMDATA, nIndex, g_ErrorMessages[i].hr );
        }
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ) );
}

void CErrorMessageDialog::InitializeAllFields()
{
    PopulateErrorsComboBox();
    HandleErrorSelectionChange();
    PopulateProgramComboBox();
    HandleProgramsSelectionChange();
}

void CErrorMessageDialog::HandleErrorSelectionChange()
{
    CSimpleString strErrorDescription;
    LRESULT nCurIndex = SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETCURSEL, 0, 0 );
    if (CB_ERR != nCurIndex)
    {
        HRESULT hr = static_cast<HRESULT>(SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETITEMDATA, nCurIndex, 0 ));
        strErrorDescription = WiaUiUtil::GetErrorTextFromHResult( hr );
    }
    if (!strErrorDescription.Length())
    {
        m_bErrorStringProvided = false;
        strErrorDescription.LoadString( IDS_NO_SYSTEM_ERROR_MESSAGE, g_hInstance );
    }
    else
    {
        m_bErrorStringProvided = true;
    }
    strErrorDescription.SetWindowText( GetDlgItem( m_hWnd, IDC_ERROR_DESCRIPTION ) );
}


void CErrorMessageDialog::HandleProgramsSelectionChange()
{
    PopulateErrorPointComboBox();
    HandlePointSelectionChange();
    SelectError( CWiaDebugClient::GetForceFailureValue(GetCurrentlySelectedProgram() ) );
    HandleErrorSelectionChange();
}


void CErrorMessageDialog::HandlePointSelectionChange()
{
    BOOL bEnable = (0 != GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) ) );
    EnableWindow( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), bEnable );
    EnableWindow( GetDlgItem( m_hWnd, IDC_ERROR_VALUE_PROMPT ), bEnable );
}


void CErrorMessageDialog::OnSetError( WPARAM, LPARAM )
{
    CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
    if (strCurrentProgram.Length())
    {
        LRESULT nErrorPoint = GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) );

        CWiaDebugClient::SetForceFailurePoint(strCurrentProgram,nErrorPoint);
        if (nErrorPoint)
        {
            LRESULT nErrorValue = GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ) );
            CWiaDebugClient::SetForceFailureValue(strCurrentProgram,nErrorValue);
        }
        
    }
}


void CErrorMessageDialog::OnCancel( WPARAM, LPARAM )
{
    CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
    WritePrivateProfileString( GENERAL_SECTION, LAST_PROGRAM, strCurrentProgram, m_strIniFileName );
    EndDialog( m_hWnd, IDCANCEL );
}


void CErrorMessageDialog::OnErrorsSelChange( WPARAM, LPARAM )
{
    HandleErrorSelectionChange();
}


void CErrorMessageDialog::OnPointSelChange( WPARAM, LPARAM )
{
    HandlePointSelectionChange();
}


void CErrorMessageDialog::OnProgramsSelChange( WPARAM, LPARAM )
{
    HandleProgramsSelectionChange();

}


void CErrorMessageDialog::OnClearAll( WPARAM, LPARAM )
{
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_GETCOUNT, 0, 0 );i++)
    {
        CSimpleString strCurrProgram = GetComboBoxString( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ), i );
        if (strCurrProgram.Length())
        {
            CWiaDebugClient::SetForceFailurePoint(strCurrProgram,0);
            CWiaDebugClient::SetForceFailureValue(strCurrProgram,0);
        }
    }
    InitializeAllFields();
}


void CErrorMessageDialog::OnRefresh( WPARAM, LPARAM )
{
    InitializeAllFields();
}


LRESULT CErrorMessageDialog::OnInitDialog( WPARAM, LPARAM )
{
    SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_FORCEERR), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) ));
    SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_FORCEERR), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) ));
    InitializeAllFields();
    return TRUE;
}

LRESULT CErrorMessageDialog::OnDestroy( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CErrorMessageDialog::OnCtlColorStatic( WPARAM wParam, LPARAM lParam )
{
    LRESULT lRes = DefWindowProc( m_hWnd, WM_CTLCOLORSTATIC, wParam, lParam );
    if (reinterpret_cast<HWND>(lParam) == GetDlgItem( m_hWnd, IDC_ERROR_DESCRIPTION ))
    {
        if (!m_bErrorStringProvided)
        {
            SetTextColor( reinterpret_cast<HDC>(wParam), RGB(255,0,0) );
        }
    }
    return lRes;
}


LRESULT CErrorMessageDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
        SC_HANDLE_COMMAND(IDC_SET_ERROR,OnSetError);
        SC_HANDLE_COMMAND(IDC_REFRESH,OnRefresh);
        SC_HANDLE_COMMAND(IDC_CLEAR_ALL,OnClearAll);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_POINT,OnPointSelChange);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_VALUE,OnErrorsSelChange);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_PROGRAMS,OnProgramsSelChange);
    }
    SC_END_COMMAND_HANDLERS();
}


INT_PTR __stdcall CErrorMessageDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CErrorMessageDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_CTLCOLORSTATIC, OnCtlColorStatic );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\rawerror.h ===
#ifndef __RAWERROR_H_INCLUDED
#define __RAWERROR_H_INCLUDED

#include <windows.h>

struct CRawError
{
    HRESULT hr;
    LPCTSTR pszName;
};

extern const CRawError g_ErrorMessages[];
extern const int       g_ErrorMessageCount;

#endif // __RAWERROR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\errdlg.h ===
#ifndef __ERRDLG_H_INCLUDED
#define __ERRDLG_H_INCLUDED

#include <windows.h>
#include <simstr.h>

//
// String constants
//
#define INI_FILE_NAME    TEXT("forceerr.ini")
#define GENERAL_SECTION  TEXT("ForceError")
#define PROGRAMS_SECTION TEXT("Programs")
#define LAST_PROGRAM     TEXT("LastProgram")

class CErrorMessageDialog
{
private:
    HWND           m_hWnd;
    bool           m_bErrorStringProvided;
    CSimpleString  m_strIniFileName;

private:
    CErrorMessageDialog();
    CErrorMessageDialog( const CErrorMessageDialog & );
    CErrorMessageDialog &operator=( const CErrorMessageDialog & );

private:
    explicit CErrorMessageDialog( HWND hWnd );
    ~CErrorMessageDialog();

private:    
    void SelectError( HRESULT hrSelect );
    void SelectErrorPoint( int nErrorPoint );
    
    LRESULT GetComboBoxItemData( HWND hWnd, LRESULT nIndex, LRESULT nDefault=0 );
    CSimpleString GetComboBoxString( HWND hWnd, LRESULT nIndex );
    CSimpleString GetCurrentlySelectedComboBoxString( HWND hWnd );
    LRESULT GetCurrentComboBoxSelection( HWND hWnd );
    LRESULT GetCurrentComboBoxSelectionData( HWND hWnd, LRESULT nDefault = 0 );
    CSimpleString GetCurrentlySelectedProgram();
    
    CSimpleString GetIniString( LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault=TEXT("") );
    UINT GetIniInt( LPCTSTR pszSection, LPCTSTR pszKey, UINT nDefault=0 );
    
    void HandleErrorSelectionChange();
    void HandleProgramsSelectionChange();
    void HandlePointSelectionChange();
    
    void PopulateProgramComboBox();
    void PopulateErrorPointComboBox();
    void PopulateErrorsComboBox();
    void InitializeAllFields();
    
    void OnSetError( WPARAM, LPARAM );
    void OnRefresh( WPARAM, LPARAM );
    void OnCancel( WPARAM, LPARAM );
    void OnErrorsSelChange( WPARAM, LPARAM );
    void OnPointSelChange( WPARAM, LPARAM );
    void OnProgramsSelChange( WPARAM, LPARAM );
    void OnClearAll( WPARAM, LPARAM );
    
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnCtlColorStatic( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

public:
    static INT_PTR __stdcall DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
};


#endif // __ERRDLG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by forceerr.rc
//
#define IDS_NO_SYSTEM_ERROR_MESSAGE     1
#define IDS_NO_ERROR                    2
#define IDD_ERROR_DIALOG                101
#define IDI_FORCEERR                    102
#define IDC_ERROR_VALUE                 1000
#define IDC_ERROR_DESCRIPTION           1001
#define IDC_SET_ERROR                   1002
#define IDC_CLEAR_ALL                   1003
#define IDC_ERROR_POINT                 1004
#define IDC_ERROR_PROGRAMS              1005
#define IDC_ERROR_VALUE_PROMPT          1006
#define IDC_REFRESH                     1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\prevtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prevtest.rc
//
#define IDB_COLOR                       1
#define IDD_TESTDLG                     102
#define IDB_GRAY                        103
#define IDB_BW                          104
#define IDD_GETXYDLG                    105
#define IDC_PREVIEW                     1000
#define IDC_BW                          1001
#define IDC_GRAY                        1002
#define IDC_COLOR                       1003
#define IDC_BORDER                      1004
#define IDC_SIZINGHANDLESTEXT           1005
#define IDC_SIZINGHANDLES               1006
#define IDC_ALPHAVALUE                  1007
#define IDC_ALPHAVALUETEXT              1008
#define IDC_BORDERTEXT                  1009
#define IDC_DISABLED                    1010
#define IDC_ROUNDHANDLES                1011
#define IDC_ORIGIN                      1012
#define IDC_EXTENT                      1013
#define IDC_NOIMAGE                     1014
#define IDC_PREVIEWMODE                 1015
#define IDC_NULLSELECTION               1016
#define IDC_DISABLESELECTION            1017
#define IDC_INNERCOLOR                  1019
#define IDC_OUTERCOLOR                  1020
#define IDC_SOLIDSELECTION              1021
#define IDC_SELECTEDBORDERCOLOR         1022
#define IDC_UNSELECTEDBORDERCOLOR       1023
#define IDC_DISABLEBORDERCOLOR          1024
#define IDC_HOLLOWHANDLE                1025
#define IDC_SELECTEDHANDLECOLOR         1026
#define IDC_UNSELECTEDHANDLECOLOR       1027
#define IDC_DISABLEHANDLECOLOR          1028
#define IDC_DOUBLEWIDTH                 1029
#define IDC_SETORIGIN                   1030
#define IDC_SETEXTENT                   1031
#define IDC_X                           1031
#define IDC_Y                           1032
#define IDC_SETPROGRESS                 1032
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\forceerr\rawerror.cpp ===
#include <windows.h>
#include <wia.h>
#include "rawerror.h"

#define MAKE_ERROR(x) { x, TEXT(#x) }

const CRawError g_ErrorMessages[] =
{
    MAKE_ERROR(CACHE_E_NOCACHE_UPDATED),
    MAKE_ERROR(CACHE_S_FORMATETC_NOTSUPPORTED),
    MAKE_ERROR(CACHE_S_SAMECACHE),
    MAKE_ERROR(CACHE_S_SOMECACHES_NOTUPDATED),
    MAKE_ERROR(CAT_E_CATIDNOEXIST),
    MAKE_ERROR(CAT_E_NODESCRIPTION),
    MAKE_ERROR(CERTSRV_E_BAD_REQUESTSTATUS),
    MAKE_ERROR(CERTSRV_E_BAD_REQUESTSUBJECT),
    MAKE_ERROR(CERTSRV_E_NO_REQUEST),
    MAKE_ERROR(CERTSRV_E_PROPERTY_EMPTY),
    MAKE_ERROR(CERT_E_CHAINING),
    MAKE_ERROR(CERT_E_CN_NO_MATCH),
    MAKE_ERROR(CERT_E_CRITICAL),
    MAKE_ERROR(CERT_E_EXPIRED),
    MAKE_ERROR(CERT_E_ISSUERCHAINING),
    MAKE_ERROR(CERT_E_MALFORMED),
    MAKE_ERROR(CERT_E_PATHLENCONST),
    MAKE_ERROR(CERT_E_PURPOSE),
    MAKE_ERROR(CERT_E_REVOCATION_FAILURE),
    MAKE_ERROR(CERT_E_REVOKED),
    MAKE_ERROR(CERT_E_ROLE),
    MAKE_ERROR(CERT_E_UNTRUSTEDROOT),
    MAKE_ERROR(CERT_E_UNTRUSTEDTESTROOT),
    MAKE_ERROR(CERT_E_VALIDITYPERIODNESTING),
    MAKE_ERROR(CERT_E_WRONG_USAGE),
    MAKE_ERROR(CLASS_E_CLASSNOTAVAILABLE),
    MAKE_ERROR(CLASS_E_NOAGGREGATION),
    MAKE_ERROR(CLASS_E_NOTLICENSED),
    MAKE_ERROR(CLIPBRD_E_BAD_DATA),
    MAKE_ERROR(CLIPBRD_E_CANT_CLOSE),
    MAKE_ERROR(CLIPBRD_E_CANT_EMPTY),
    MAKE_ERROR(CLIPBRD_E_CANT_OPEN),
    MAKE_ERROR(CLIPBRD_E_CANT_SET),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_FMT),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_GET),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_PUT),
    MAKE_ERROR(CONVERT10_E_STG_DIB_TO_BITMAP),
    MAKE_ERROR(CONVERT10_E_STG_FMT),
    MAKE_ERROR(CONVERT10_E_STG_NO_STD_STREAM),
    MAKE_ERROR(CONVERT10_S_NO_PRESENTATION),
    MAKE_ERROR(CO_E_ACCESSCHECKFAILED),
    MAKE_ERROR(CO_E_ACESINWRONGORDER),
    MAKE_ERROR(CO_E_ACNOTINITIALIZED),
    MAKE_ERROR(CO_E_ALREADYINITIALIZED),
    MAKE_ERROR(CO_E_APPDIDNTREG),
    MAKE_ERROR(CO_E_APPNOTFOUND),
    MAKE_ERROR(CO_E_APPSINGLEUSE),
    MAKE_ERROR(CO_E_BAD_PATH),
    MAKE_ERROR(CO_E_BAD_SERVER_NAME),
    MAKE_ERROR(CO_E_CANTDETERMINECLASS),
    MAKE_ERROR(CO_E_CANT_REMOTE),
    MAKE_ERROR(CO_E_CLASSSTRING),
    MAKE_ERROR(CO_E_CLASS_CREATE_FAILED),
    MAKE_ERROR(CO_E_CLSREG_INCONSISTENT),
    MAKE_ERROR(CO_E_CONVERSIONFAILED),
    MAKE_ERROR(CO_E_CREATEPROCESS_FAILURE),
    MAKE_ERROR(CO_E_DECODEFAILED),
    MAKE_ERROR(CO_E_DLLNOTFOUND),
    MAKE_ERROR(CO_E_ERRORINAPP),
    MAKE_ERROR(CO_E_ERRORINDLL),
    MAKE_ERROR(CO_E_EXCEEDSYSACLLIMIT),
    MAKE_ERROR(CO_E_FAILEDTOCLOSEHANDLE),
    MAKE_ERROR(CO_E_FAILEDTOCREATEFILE),
    MAKE_ERROR(CO_E_FAILEDTOGENUUID),
    MAKE_ERROR(CO_E_FAILEDTOGETSECCTX),
    MAKE_ERROR(CO_E_FAILEDTOGETTOKENINFO),
    MAKE_ERROR(CO_E_FAILEDTOGETWINDIR),
    MAKE_ERROR(CO_E_FAILEDTOIMPERSONATE),
    MAKE_ERROR(CO_E_FAILEDTOOPENPROCESSTOKEN),
    MAKE_ERROR(CO_E_FAILEDTOOPENTHREADTOKEN),
    MAKE_ERROR(CO_E_FAILEDTOQUERYCLIENTBLANKET),
    MAKE_ERROR(CO_E_FAILEDTOSETDACL),
    MAKE_ERROR(CO_E_IIDREG_INCONSISTENT),
    MAKE_ERROR(CO_E_IIDSTRING),
    MAKE_ERROR(CO_E_INCOMPATIBLESTREAMVERSION),
    MAKE_ERROR(CO_E_INIT_CLASS_CACHE),
    MAKE_ERROR(CO_E_INIT_MEMORY_ALLOCATOR),
    MAKE_ERROR(CO_E_INIT_ONLY_SINGLE_THREADED),
    MAKE_ERROR(CO_E_INIT_RPC_CHANNEL),
    MAKE_ERROR(CO_E_INIT_SCM_EXEC_FAILURE),
    MAKE_ERROR(CO_E_INIT_SCM_FILE_MAPPING_EXISTS),
    MAKE_ERROR(CO_E_INIT_SCM_MAP_VIEW_OF_FILE),
    MAKE_ERROR(CO_E_INIT_SCM_MUTEX_EXISTS),
    MAKE_ERROR(CO_E_INIT_SHARED_ALLOCATOR),
    MAKE_ERROR(CO_E_INIT_TLS),
    MAKE_ERROR(CO_E_INIT_TLS_CHANNEL_CONTROL),
    MAKE_ERROR(CO_E_INIT_TLS_SET_CHANNEL_CONTROL),
    MAKE_ERROR(CO_E_INIT_UNACCEPTED_USER_ALLOCATOR),
    MAKE_ERROR(CO_E_INVALIDSID),
    MAKE_ERROR(CO_E_LAUNCH_PERMSSION_DENIED),
    MAKE_ERROR(CO_E_LOOKUPACCNAMEFAILED),
    MAKE_ERROR(CO_E_LOOKUPACCSIDFAILED),
    MAKE_ERROR(CO_E_MSI_ERROR),
    MAKE_ERROR(CO_E_NETACCESSAPIFAILED),
    MAKE_ERROR(CO_E_NOMATCHINGNAMEFOUND),
    MAKE_ERROR(CO_E_NOMATCHINGSIDFOUND),
    MAKE_ERROR(CO_E_NOTINITIALIZED),
    MAKE_ERROR(CO_E_NOT_SUPPORTED),
    MAKE_ERROR(CO_E_OBJISREG),
    MAKE_ERROR(CO_E_OBJNOTCONNECTED),
    MAKE_ERROR(CO_E_OBJNOTREG),
    MAKE_ERROR(CO_E_OBJSRV_RPC_FAILURE),
    MAKE_ERROR(CO_E_OLE1DDE_DISABLED),
    MAKE_ERROR(CO_E_PATHTOOLONG),
    MAKE_ERROR(CO_E_RELEASED),
    MAKE_ERROR(CO_E_RELOAD_DLL),
    MAKE_ERROR(CO_E_REMOTE_COMMUNICATION_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_CREATEPROCESS_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_LOGON_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_SYNTAX),
    MAKE_ERROR(CO_E_SCM_ERROR),
    MAKE_ERROR(CO_E_SCM_RPC_FAILURE),
    MAKE_ERROR(CO_E_SERVER_EXEC_FAILURE),
    MAKE_ERROR(CO_E_SERVER_START_TIMEOUT),
    MAKE_ERROR(CO_E_SERVER_STOPPING),
    MAKE_ERROR(CO_E_SETSERLHNDLFAILED),
    MAKE_ERROR(CO_E_START_SERVICE_FAILURE),
    MAKE_ERROR(CO_E_TRUSTEEDOESNTMATCHCLIENT),
    MAKE_ERROR(CO_E_WRONGOSFORAPP),
    MAKE_ERROR(CO_E_WRONGTRUSTEENAMESYNTAX),
    MAKE_ERROR(CO_E_WRONG_SERVER_IDENTITY),
    MAKE_ERROR(CO_S_NOTALLINTERFACES),
    MAKE_ERROR(CRYPT_E_ALREADY_DECRYPTED),
    MAKE_ERROR(CRYPT_E_ATTRIBUTES_MISSING),
    MAKE_ERROR(CRYPT_E_AUTH_ATTR_MISSING),
    MAKE_ERROR(CRYPT_E_BAD_ENCODE),
    MAKE_ERROR(CRYPT_E_BAD_LEN),
    MAKE_ERROR(CRYPT_E_BAD_MSG),
    MAKE_ERROR(CRYPT_E_CONTROL_TYPE),
    MAKE_ERROR(CRYPT_E_DELETED_PREV),
    MAKE_ERROR(CRYPT_E_EXISTS),
    MAKE_ERROR(CRYPT_E_FILERESIZED),
    MAKE_ERROR(CRYPT_E_FILE_ERROR),
    MAKE_ERROR(CRYPT_E_HASH_VALUE),
    MAKE_ERROR(CRYPT_E_INVALID_IA5_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_INDEX),
    MAKE_ERROR(CRYPT_E_INVALID_MSG_TYPE),
    MAKE_ERROR(CRYPT_E_INVALID_NUMERIC_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_PRINTABLE_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_X500_STRING),
    MAKE_ERROR(CRYPT_E_ISSUER_SERIALNUMBER),
    MAKE_ERROR(CRYPT_E_MSG_ERROR),
    MAKE_ERROR(CRYPT_E_NOT_CHAR_STRING),
    MAKE_ERROR(CRYPT_E_NOT_DECRYPTED),
    MAKE_ERROR(CRYPT_E_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_NOT_IN_CTL),
    MAKE_ERROR(CRYPT_E_NOT_IN_REVOCATION_DATABASE),
    MAKE_ERROR(CRYPT_E_NO_DECRYPT_CERT),
    MAKE_ERROR(CRYPT_E_NO_KEY_PROPERTY),
    MAKE_ERROR(CRYPT_E_NO_MATCH),
    MAKE_ERROR(CRYPT_E_NO_PROVIDER),
    MAKE_ERROR(CRYPT_E_NO_REVOCATION_CHECK),
    MAKE_ERROR(CRYPT_E_NO_REVOCATION_DLL),
    MAKE_ERROR(CRYPT_E_NO_SIGNER),
    MAKE_ERROR(CRYPT_E_NO_TRUSTED_SIGNER),
    MAKE_ERROR(CRYPT_E_NO_VERIFY_USAGE_CHECK),
    MAKE_ERROR(CRYPT_E_NO_VERIFY_USAGE_DLL),
    MAKE_ERROR(CRYPT_E_OID_FORMAT),
    MAKE_ERROR(CRYPT_E_OSS_ERROR),
    MAKE_ERROR(CRYPT_E_PENDING_CLOSE),
    MAKE_ERROR(CRYPT_E_RECIPIENT_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_REVOCATION_OFFLINE),
    MAKE_ERROR(CRYPT_E_REVOKED),
    MAKE_ERROR(CRYPT_E_SECURITY_SETTINGS),
    MAKE_ERROR(CRYPT_E_SELF_SIGNED),
    MAKE_ERROR(CRYPT_E_SIGNER_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_STREAM_INSUFFICIENT_DATA),
    MAKE_ERROR(CRYPT_E_STREAM_MSG_NOT_READY),
    MAKE_ERROR(CRYPT_E_UNEXPECTED_ENCODING),
    MAKE_ERROR(CRYPT_E_UNEXPECTED_MSG_TYPE),
    MAKE_ERROR(CRYPT_E_UNKNOWN_ALGO),
    MAKE_ERROR(CRYPT_E_VERIFY_USAGE_OFFLINE),
    MAKE_ERROR(CS_E_CLASS_NOTFOUND),
    MAKE_ERROR(CS_E_INVALID_VERSION),
    MAKE_ERROR(CS_E_NOT_DELETABLE),
    MAKE_ERROR(CS_E_NO_CLASSSTORE),
    MAKE_ERROR(CS_E_PACKAGE_NOTFOUND),
    MAKE_ERROR(DATA_S_SAMEFORMATETC),
    MAKE_ERROR(DIGSIG_E_CRYPTO),
    MAKE_ERROR(DIGSIG_E_DECODE),
    MAKE_ERROR(DIGSIG_E_ENCODE),
    MAKE_ERROR(DIGSIG_E_EXTENSIBILITY),
    MAKE_ERROR(DISP_E_ARRAYISLOCKED),
    MAKE_ERROR(DISP_E_BADCALLEE),
    MAKE_ERROR(DISP_E_BADINDEX),
    MAKE_ERROR(DISP_E_BADPARAMCOUNT),
    MAKE_ERROR(DISP_E_BADVARTYPE),
    MAKE_ERROR(DISP_E_DIVBYZERO),
    MAKE_ERROR(DISP_E_EXCEPTION),
    MAKE_ERROR(DISP_E_MEMBERNOTFOUND),
    MAKE_ERROR(DISP_E_NONAMEDARGS),
    MAKE_ERROR(DISP_E_NOTACOLLECTION),
    MAKE_ERROR(DISP_E_OVERFLOW),
    MAKE_ERROR(DISP_E_PARAMNOTFOUND),
    MAKE_ERROR(DISP_E_PARAMNOTOPTIONAL),
    MAKE_ERROR(DISP_E_TYPEMISMATCH),
    MAKE_ERROR(DISP_E_UNKNOWNINTERFACE),
    MAKE_ERROR(DISP_E_UNKNOWNLCID),
    MAKE_ERROR(DISP_E_UNKNOWNNAME),
    MAKE_ERROR(DRAGDROP_E_ALREADYREGISTERED),
    MAKE_ERROR(DRAGDROP_E_INVALIDHWND),
    MAKE_ERROR(DRAGDROP_E_NOTREGISTERED),
    MAKE_ERROR(DRAGDROP_S_CANCEL),
    MAKE_ERROR(DRAGDROP_S_DROP),
    MAKE_ERROR(DRAGDROP_S_USEDEFAULTCURSORS),
    MAKE_ERROR(DV_E_CLIPFORMAT),
    MAKE_ERROR(DV_E_DVASPECT),
    MAKE_ERROR(DV_E_DVTARGETDEVICE),
    MAKE_ERROR(DV_E_DVTARGETDEVICE_SIZE),
    MAKE_ERROR(DV_E_FORMATETC),
    MAKE_ERROR(DV_E_LINDEX),
    MAKE_ERROR(DV_E_NOIVIEWOBJECT),
    MAKE_ERROR(DV_E_STATDATA),
    MAKE_ERROR(DV_E_STGMEDIUM),
    MAKE_ERROR(DV_E_TYMED),
    MAKE_ERROR(EPT_S_CANT_CREATE),
    MAKE_ERROR(EPT_S_CANT_PERFORM_OP),
    MAKE_ERROR(EPT_S_INVALID_ENTRY),
    MAKE_ERROR(EPT_S_NOT_REGISTERED),
    MAKE_ERROR(ERROR_ACCESS_DENIED),
    MAKE_ERROR(ERROR_ACCOUNT_DISABLED),
    MAKE_ERROR(ERROR_ACCOUNT_EXPIRED),
    MAKE_ERROR(ERROR_ACCOUNT_LOCKED_OUT),
    MAKE_ERROR(ERROR_ACCOUNT_RESTRICTION),
    MAKE_ERROR(ERROR_ACTIVE_CONNECTIONS),
    MAKE_ERROR(ERROR_ADAP_HDW_ERR),
    MAKE_ERROR(ERROR_ADDRESS_ALREADY_ASSOCIATED),
    MAKE_ERROR(ERROR_ADDRESS_NOT_ASSOCIATED),
    MAKE_ERROR(ERROR_ALIAS_EXISTS),
    MAKE_ERROR(ERROR_ALLOTTED_SPACE_EXCEEDED),
    MAKE_ERROR(ERROR_ALREADY_ASSIGNED),
    MAKE_ERROR(ERROR_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_ALREADY_INITIALIZED),
    MAKE_ERROR(ERROR_ALREADY_REGISTERED),
    MAKE_ERROR(ERROR_ALREADY_RUNNING_LKG),
    MAKE_ERROR(ERROR_ALREADY_WAITING),
    MAKE_ERROR(ERROR_APP_WRONG_OS),
    MAKE_ERROR(ERROR_ARENA_TRASHED),
    MAKE_ERROR(ERROR_ARITHMETIC_OVERFLOW),
    MAKE_ERROR(ERROR_ATOMIC_LOCKS_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_AUTODATASEG_EXCEEDS_64k),
    MAKE_ERROR(ERROR_BADDB),
    MAKE_ERROR(ERROR_BADKEY),
    MAKE_ERROR(ERROR_BAD_ARGUMENTS),
    MAKE_ERROR(ERROR_BAD_COMMAND),
    MAKE_ERROR(ERROR_BAD_CONFIGURATION),
    MAKE_ERROR(ERROR_BAD_DESCRIPTOR_FORMAT),
    MAKE_ERROR(ERROR_BAD_DEVICE),
    MAKE_ERROR(ERROR_BAD_DEV_TYPE),
    MAKE_ERROR(ERROR_BAD_DRIVER),
    MAKE_ERROR(ERROR_BAD_DRIVER_LEVEL),
    MAKE_ERROR(ERROR_BAD_ENVIRONMENT),
    MAKE_ERROR(ERROR_BAD_EXE_FORMAT),
    MAKE_ERROR(ERROR_BAD_FORMAT),
    MAKE_ERROR(ERROR_BAD_IMPERSONATION_LEVEL),
    MAKE_ERROR(ERROR_BAD_INHERITANCE_ACL),
    MAKE_ERROR(ERROR_BAD_LENGTH),
    MAKE_ERROR(ERROR_BAD_LOGON_SESSION_STATE),
    MAKE_ERROR(ERROR_BAD_NETPATH),
    MAKE_ERROR(ERROR_BAD_NET_NAME),
    MAKE_ERROR(ERROR_BAD_NET_RESP),
    MAKE_ERROR(ERROR_BAD_PATHNAME),
    MAKE_ERROR(ERROR_BAD_PIPE),
    MAKE_ERROR(ERROR_BAD_PROFILE),
    MAKE_ERROR(ERROR_BAD_PROVIDER),
    MAKE_ERROR(ERROR_BAD_QUERY_SYNTAX),
    MAKE_ERROR(ERROR_BAD_REM_ADAP),
    MAKE_ERROR(ERROR_BAD_THREADID_ADDR),
    MAKE_ERROR(ERROR_BAD_TOKEN_TYPE),
    MAKE_ERROR(ERROR_BAD_UNIT),
    MAKE_ERROR(ERROR_BAD_USERNAME),
    MAKE_ERROR(ERROR_BAD_VALIDATION_CLASS),
    MAKE_ERROR(ERROR_BEGINNING_OF_MEDIA),
    MAKE_ERROR(ERROR_BOOT_ALREADY_ACCEPTED),
    MAKE_ERROR(ERROR_BROKEN_PIPE),
    MAKE_ERROR(ERROR_BUFFER_OVERFLOW),
    MAKE_ERROR(ERROR_BUSY),
    MAKE_ERROR(ERROR_BUSY_DRIVE),
    MAKE_ERROR(ERROR_BUS_RESET),
    MAKE_ERROR(ERROR_CALL_NOT_IMPLEMENTED),
    MAKE_ERROR(ERROR_CANCELLED),
    MAKE_ERROR(ERROR_CANCEL_VIOLATION),
    MAKE_ERROR(ERROR_CANNOT_COPY),
    MAKE_ERROR(ERROR_CANNOT_DETECT_DRIVER_FAILURE),
    MAKE_ERROR(ERROR_CANNOT_DETECT_PROCESS_ABORT),
    MAKE_ERROR(ERROR_CANNOT_FIND_WND_CLASS),
    MAKE_ERROR(ERROR_CANNOT_IMPERSONATE),
    MAKE_ERROR(ERROR_CANNOT_MAKE),
    MAKE_ERROR(ERROR_CANNOT_OPEN_PROFILE),
    MAKE_ERROR(ERROR_CANTOPEN),
    MAKE_ERROR(ERROR_CANTREAD),
    MAKE_ERROR(ERROR_CANTWRITE),
    MAKE_ERROR(ERROR_CANT_ACCESS_DOMAIN_INFO),
    MAKE_ERROR(ERROR_CANT_ACCESS_FILE),
    MAKE_ERROR(ERROR_CANT_DISABLE_MANDATORY),
    MAKE_ERROR(ERROR_CANT_EVICT_ACTIVE_NODE),
    MAKE_ERROR(ERROR_CANT_OPEN_ANONYMOUS),
    MAKE_ERROR(ERROR_CANT_RESOLVE_FILENAME),
    MAKE_ERROR(ERROR_CAN_NOT_COMPLETE),
    MAKE_ERROR(ERROR_CAN_NOT_DEL_LOCAL_WINS),
    MAKE_ERROR(ERROR_CHILD_MUST_BE_VOLATILE),
    MAKE_ERROR(ERROR_CHILD_NOT_COMPLETE),
    MAKE_ERROR(ERROR_CHILD_WINDOW_MENU),
    MAKE_ERROR(ERROR_CIRCULAR_DEPENDENCY),
    MAKE_ERROR(ERROR_CLASS_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_CLASS_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_CLASS_HAS_WINDOWS),
    MAKE_ERROR(ERROR_CLIPBOARD_NOT_OPEN),
    MAKE_ERROR(ERROR_CLIPPING_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND),
    MAKE_ERROR(ERROR_CLUSTERLOG_CORRUPT),
    MAKE_ERROR(ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE),
    MAKE_ERROR(ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE),
    MAKE_ERROR(ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE),
    MAKE_ERROR(ERROR_CLUSTER_SHUTTING_DOWN),
    MAKE_ERROR(ERROR_COMMITMENT_LIMIT),
    MAKE_ERROR(ERROR_CONNECTED_OTHER_PASSWORD),
    MAKE_ERROR(ERROR_CONNECTION_ABORTED),
    MAKE_ERROR(ERROR_CONNECTION_ACTIVE),
    MAKE_ERROR(ERROR_CONNECTION_COUNT_LIMIT),
    MAKE_ERROR(ERROR_CONNECTION_INVALID),
    MAKE_ERROR(ERROR_CONNECTION_REFUSED),
    MAKE_ERROR(ERROR_CONNECTION_UNAVAIL),
    MAKE_ERROR(ERROR_CONTINUE),
    MAKE_ERROR(ERROR_CONTROL_ID_NOT_FOUND),
    MAKE_ERROR(ERROR_CORE_RESOURCE),
    MAKE_ERROR(ERROR_COUNTER_TIMEOUT),
    MAKE_ERROR(ERROR_CRC),
    MAKE_ERROR(ERROR_CURRENT_DIRECTORY),
    MAKE_ERROR(ERROR_DATABASE_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_DATABASE_FAILURE),
    MAKE_ERROR(ERROR_DATABASE_FULL),
    MAKE_ERROR(ERROR_DC_NOT_FOUND),
    MAKE_ERROR(ERROR_DDE_FAIL),
    MAKE_ERROR(ERROR_DECRYPTION_FAILED),
    MAKE_ERROR(ERROR_DELETING_ICM_XFORM),
    MAKE_ERROR(ERROR_DEPENDENCY_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_DEPENDENCY_NOT_FOUND),
    MAKE_ERROR(ERROR_DEPENDENT_RESOURCE_EXISTS),
    MAKE_ERROR(ERROR_DEPENDENT_SERVICES_RUNNING),
    MAKE_ERROR(ERROR_DESTINATION_ELEMENT_FULL),
    MAKE_ERROR(ERROR_DESTROY_OBJECT_OF_OTHER_THREAD),
    MAKE_ERROR(ERROR_DEVICE_ALREADY_REMEMBERED),
    MAKE_ERROR(ERROR_DEVICE_DOOR_OPEN),
    MAKE_ERROR(ERROR_DEVICE_IN_USE),
    MAKE_ERROR(ERROR_DEVICE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_DEVICE_NOT_CONNECTED),
    MAKE_ERROR(ERROR_DEVICE_NOT_PARTITIONED),
    MAKE_ERROR(ERROR_DEVICE_REINITIALIZATION_NEEDED),
    MAKE_ERROR(ERROR_DEVICE_REQUIRES_CLEANING),
    MAKE_ERROR(ERROR_DEV_NOT_EXIST),
    MAKE_ERROR(ERROR_DHCP_ADDRESS_CONFLICT),
    MAKE_ERROR(ERROR_DIFFERENT_SERVICE_ACCOUNT),
    MAKE_ERROR(ERROR_DIRECTORY),
    MAKE_ERROR(ERROR_DIRECT_ACCESS_HANDLE),
    MAKE_ERROR(ERROR_DIR_NOT_EMPTY),
    MAKE_ERROR(ERROR_DIR_NOT_ROOT),
    MAKE_ERROR(ERROR_DISCARDED),
    MAKE_ERROR(ERROR_DISK_CHANGE),
    MAKE_ERROR(ERROR_DISK_CORRUPT),
    MAKE_ERROR(ERROR_DISK_FULL),
    MAKE_ERROR(ERROR_DISK_OPERATION_FAILED),
    MAKE_ERROR(ERROR_DISK_RECALIBRATE_FAILED),
    MAKE_ERROR(ERROR_DISK_RESET_FAILED),
    MAKE_ERROR(ERROR_DLL_INIT_FAILED),
    MAKE_ERROR(ERROR_DLL_NOT_FOUND),
    MAKE_ERROR(ERROR_DOMAIN_CONTROLLER_EXISTS),
    MAKE_ERROR(ERROR_DOMAIN_CONTROLLER_NOT_FOUND),
    MAKE_ERROR(ERROR_DOMAIN_EXISTS),
    MAKE_ERROR(ERROR_DOMAIN_LIMIT_EXCEEDED),
    MAKE_ERROR(ERROR_DOMAIN_TRUST_INCONSISTENT),
    MAKE_ERROR(ERROR_DRIVE_LOCKED),
    MAKE_ERROR(ERROR_DRIVE_MEDIA_MISMATCH),
    MAKE_ERROR(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS),
    MAKE_ERROR(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED),
    MAKE_ERROR(ERROR_DS_BUSY),
    MAKE_ERROR(ERROR_DS_CANT_MOD_OBJ_CLASS),
    MAKE_ERROR(ERROR_DS_CANT_ON_NON_LEAF),
    MAKE_ERROR(ERROR_DS_CANT_ON_RDN),
    MAKE_ERROR(ERROR_DS_CROSS_DOM_MOVE_ERROR),
    MAKE_ERROR(ERROR_DS_GC_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_DS_INCORRECT_ROLE_OWNER),
    MAKE_ERROR(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX),
    MAKE_ERROR(ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY),
    MAKE_ERROR(ERROR_DS_NOT_INSTALLED),
    MAKE_ERROR(ERROR_DS_NO_ATTRIBUTE_OR_VALUE),
    MAKE_ERROR(ERROR_DS_NO_MORE_RIDS),
    MAKE_ERROR(ERROR_DS_NO_RIDS_ALLOCATED),
    MAKE_ERROR(ERROR_DS_OBJ_CLASS_VIOLATION),
    MAKE_ERROR(ERROR_DS_RIDMGR_INIT_ERROR),
    MAKE_ERROR(ERROR_DS_UNAVAILABLE),
    MAKE_ERROR(ERROR_DUPLICATE_SERVICE_NAME),
    MAKE_ERROR(ERROR_DUPLICATE_TAG),
    MAKE_ERROR(ERROR_DUP_DOMAINNAME),
    MAKE_ERROR(ERROR_DUP_NAME),
    MAKE_ERROR(ERROR_DYNLINK_FROM_INVALID_RING),
    MAKE_ERROR(ERROR_EAS_DIDNT_FIT),
    MAKE_ERROR(ERROR_EAS_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_EA_ACCESS_DENIED),
    MAKE_ERROR(ERROR_EA_FILE_CORRUPT),
    MAKE_ERROR(ERROR_EA_LIST_INCONSISTENT),
    MAKE_ERROR(ERROR_EA_TABLE_FULL),
    MAKE_ERROR(ERROR_EMPTY),
    MAKE_ERROR(ERROR_ENCRYPTION_FAILED),
    MAKE_ERROR(ERROR_END_OF_MEDIA),
    MAKE_ERROR(ERROR_ENVVAR_NOT_FOUND),
    MAKE_ERROR(ERROR_EOM_OVERFLOW),
    MAKE_ERROR(ERROR_EVENTLOG_CANT_START),
    MAKE_ERROR(ERROR_EVENTLOG_FILE_CHANGED),
    MAKE_ERROR(ERROR_EVENTLOG_FILE_CORRUPT),
    MAKE_ERROR(ERROR_EXCEPTION_IN_SERVICE),
    MAKE_ERROR(ERROR_EXCL_SEM_ALREADY_OWNED),
    MAKE_ERROR(ERROR_EXE_MACHINE_TYPE_MISMATCH),
    MAKE_ERROR(ERROR_EXE_MARKED_INVALID),
    MAKE_ERROR(ERROR_EXTENDED_ERROR),
    MAKE_ERROR(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT),
    MAKE_ERROR(ERROR_FAIL_I24),
    MAKE_ERROR(ERROR_FILEMARK_DETECTED),
    MAKE_ERROR(ERROR_FILENAME_EXCED_RANGE),
    MAKE_ERROR(ERROR_FILE_CORRUPT),
    MAKE_ERROR(ERROR_FILE_ENCRYPTED),
    MAKE_ERROR(ERROR_FILE_EXISTS),
    MAKE_ERROR(ERROR_FILE_INVALID),
    MAKE_ERROR(ERROR_FILE_NOT_ENCRYPTED),
    MAKE_ERROR(ERROR_FILE_NOT_FOUND),
    MAKE_ERROR(ERROR_FILE_OFFLINE),
    MAKE_ERROR(ERROR_FLOPPY_BAD_REGISTERS),
    MAKE_ERROR(ERROR_FLOPPY_ID_MARK_NOT_FOUND),
    MAKE_ERROR(ERROR_FLOPPY_UNKNOWN_ERROR),
    MAKE_ERROR(ERROR_FLOPPY_WRONG_CYLINDER),
    MAKE_ERROR(ERROR_FULLSCREEN_MODE),
    MAKE_ERROR(ERROR_FULL_BACKUP),
    MAKE_ERROR(ERROR_GENERIC_NOT_MAPPED),
    MAKE_ERROR(ERROR_GEN_FAILURE),
    MAKE_ERROR(ERROR_GLOBAL_ONLY_HOOK),
    MAKE_ERROR(ERROR_GRACEFUL_DISCONNECT),
    MAKE_ERROR(ERROR_GROUP_EXISTS),
    MAKE_ERROR(ERROR_GROUP_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_GROUP_NOT_FOUND),
    MAKE_ERROR(ERROR_GROUP_NOT_ONLINE),
    MAKE_ERROR(ERROR_HANDLE_DISK_FULL),
    MAKE_ERROR(ERROR_HANDLE_EOF),
    MAKE_ERROR(ERROR_HOOK_NEEDS_HMOD),
    MAKE_ERROR(ERROR_HOOK_NOT_INSTALLED),
    MAKE_ERROR(ERROR_HOOK_TYPE_NOT_ALLOWED),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_GROUP_OWNER),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_RESOURCE_OWNER),
    MAKE_ERROR(ERROR_HOST_UNREACHABLE),
    MAKE_ERROR(ERROR_HOTKEY_ALREADY_REGISTERED),
    MAKE_ERROR(ERROR_HOTKEY_NOT_REGISTERED),
    MAKE_ERROR(ERROR_HWNDS_HAVE_DIFF_PARENT),
    MAKE_ERROR(ERROR_ICM_NOT_ENABLED),
    MAKE_ERROR(ERROR_ILLEGAL_ELEMENT_ADDRESS),
    MAKE_ERROR(ERROR_ILL_FORMED_PASSWORD),
    MAKE_ERROR(ERROR_INCORRECT_ADDRESS),
    MAKE_ERROR(ERROR_INC_BACKUP),
    MAKE_ERROR(ERROR_INDEX_ABSENT),
    MAKE_ERROR(ERROR_INFLOOP_IN_RELOC_CHAIN),
    MAKE_ERROR(ERROR_INSTALL_FAILURE),
    MAKE_ERROR(ERROR_INSTALL_SOURCE_ABSENT),
    MAKE_ERROR(ERROR_INSTALL_SUSPEND),
    MAKE_ERROR(ERROR_INSTALL_USEREXIT),
    MAKE_ERROR(ERROR_INSUFFICIENT_BUFFER),
    MAKE_ERROR(ERROR_INTERNAL_DB_CORRUPTION),
    MAKE_ERROR(ERROR_INTERNAL_DB_ERROR),
    MAKE_ERROR(ERROR_INTERNAL_ERROR),
    MAKE_ERROR(ERROR_INVALID_ACCEL_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ACCESS),
    MAKE_ERROR(ERROR_INVALID_ACCOUNT_NAME),
    MAKE_ERROR(ERROR_INVALID_ACL),
    MAKE_ERROR(ERROR_INVALID_ADDRESS),
    MAKE_ERROR(ERROR_INVALID_AT_INTERRUPT_TIME),
    MAKE_ERROR(ERROR_INVALID_BLOCK),
    MAKE_ERROR(ERROR_INVALID_BLOCK_LENGTH),
    MAKE_ERROR(ERROR_INVALID_CATEGORY),
    MAKE_ERROR(ERROR_INVALID_CLEANER),
    MAKE_ERROR(ERROR_INVALID_CMM),
    MAKE_ERROR(ERROR_INVALID_COLORSPACE),
    MAKE_ERROR(ERROR_INVALID_COMBOBOX_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_COMPUTERNAME),
    MAKE_ERROR(ERROR_INVALID_CURSOR_HANDLE),
    MAKE_ERROR(ERROR_INVALID_DATA),
    MAKE_ERROR(ERROR_INVALID_DATATYPE),
    MAKE_ERROR(ERROR_INVALID_DLL),
    MAKE_ERROR(ERROR_INVALID_DOMAINNAME),
    MAKE_ERROR(ERROR_INVALID_DOMAIN_ROLE),
    MAKE_ERROR(ERROR_INVALID_DOMAIN_STATE),
    MAKE_ERROR(ERROR_INVALID_DRIVE),
    MAKE_ERROR(ERROR_INVALID_DWP_HANDLE),
    MAKE_ERROR(ERROR_INVALID_EA_HANDLE),
    MAKE_ERROR(ERROR_INVALID_EA_NAME),
    MAKE_ERROR(ERROR_INVALID_EDIT_HEIGHT),
    MAKE_ERROR(ERROR_INVALID_ENVIRONMENT),
    MAKE_ERROR(ERROR_INVALID_EVENTNAME),
    MAKE_ERROR(ERROR_INVALID_EVENT_COUNT),
    MAKE_ERROR(ERROR_INVALID_EXE_SIGNATURE),
    MAKE_ERROR(ERROR_INVALID_FIELD),
    MAKE_ERROR(ERROR_INVALID_FILTER_PROC),
    MAKE_ERROR(ERROR_INVALID_FLAGS),
    MAKE_ERROR(ERROR_INVALID_FLAG_NUMBER),
    MAKE_ERROR(ERROR_INVALID_FORM_NAME),
    MAKE_ERROR(ERROR_INVALID_FORM_SIZE),
    MAKE_ERROR(ERROR_INVALID_FUNCTION),
    MAKE_ERROR(ERROR_INVALID_GROUPNAME),
    MAKE_ERROR(ERROR_INVALID_GROUP_ATTRIBUTES),
    MAKE_ERROR(ERROR_INVALID_GW_COMMAND),
    MAKE_ERROR(ERROR_INVALID_HANDLE),
    MAKE_ERROR(ERROR_INVALID_HANDLE_STATE),
    MAKE_ERROR(ERROR_INVALID_HOOK_FILTER),
    MAKE_ERROR(ERROR_INVALID_HOOK_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ICON_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ID_AUTHORITY),
    MAKE_ERROR(ERROR_INVALID_INDEX),
    MAKE_ERROR(ERROR_INVALID_KEYBOARD_HANDLE),
    MAKE_ERROR(ERROR_INVALID_LB_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_LEVEL),
    MAKE_ERROR(ERROR_INVALID_LIBRARY),
    MAKE_ERROR(ERROR_INVALID_LIST_FORMAT),
    MAKE_ERROR(ERROR_INVALID_LOGON_HOURS),
    MAKE_ERROR(ERROR_INVALID_LOGON_TYPE),
    MAKE_ERROR(ERROR_INVALID_MEDIA),
    MAKE_ERROR(ERROR_INVALID_MEDIA_POOL),
    MAKE_ERROR(ERROR_INVALID_MEMBER),
    MAKE_ERROR(ERROR_INVALID_MENU_HANDLE),
    MAKE_ERROR(ERROR_INVALID_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_MESSAGEDEST),
    MAKE_ERROR(ERROR_INVALID_MESSAGENAME),
    MAKE_ERROR(ERROR_INVALID_MINALLOCSIZE),
    MAKE_ERROR(ERROR_INVALID_MODULETYPE),
    MAKE_ERROR(ERROR_INVALID_MONITOR_HANDLE),
    MAKE_ERROR(ERROR_INVALID_MSGBOX_STYLE),
    MAKE_ERROR(ERROR_INVALID_NAME),
    MAKE_ERROR(ERROR_INVALID_NETNAME),
    MAKE_ERROR(ERROR_INVALID_OPERATION),
    MAKE_ERROR(ERROR_INVALID_OPLOCK_PROTOCOL),
    MAKE_ERROR(ERROR_INVALID_ORDINAL),
    MAKE_ERROR(ERROR_INVALID_OWNER),
    MAKE_ERROR(ERROR_INVALID_PARAMETER),
    MAKE_ERROR(ERROR_INVALID_PASSWORD),
    MAKE_ERROR(ERROR_INVALID_PASSWORDNAME),
    MAKE_ERROR(ERROR_INVALID_PIXEL_FORMAT),
    MAKE_ERROR(ERROR_INVALID_PRIMARY_GROUP),
    MAKE_ERROR(ERROR_INVALID_PRINTER_COMMAND),
    MAKE_ERROR(ERROR_INVALID_PRINTER_NAME),
    MAKE_ERROR(ERROR_INVALID_PRINTER_STATE),
    MAKE_ERROR(ERROR_INVALID_PRINT_MONITOR),
    MAKE_ERROR(ERROR_INVALID_PRIORITY),
    MAKE_ERROR(ERROR_INVALID_PROFILE),
    MAKE_ERROR(ERROR_INVALID_SCROLLBAR_RANGE),
    MAKE_ERROR(ERROR_INVALID_SECURITY_DESCR),
    MAKE_ERROR(ERROR_INVALID_SEGDPL),
    MAKE_ERROR(ERROR_INVALID_SEGMENT_NUMBER),
    MAKE_ERROR(ERROR_INVALID_SEPARATOR_FILE),
    MAKE_ERROR(ERROR_INVALID_SERVER_STATE),
    MAKE_ERROR(ERROR_INVALID_SERVICENAME),
    MAKE_ERROR(ERROR_INVALID_SERVICE_ACCOUNT),
    MAKE_ERROR(ERROR_INVALID_SERVICE_CONTROL),
    MAKE_ERROR(ERROR_INVALID_SERVICE_LOCK),
    MAKE_ERROR(ERROR_INVALID_SHARENAME),
    MAKE_ERROR(ERROR_INVALID_SHOWWIN_COMMAND),
    MAKE_ERROR(ERROR_INVALID_SID),
    MAKE_ERROR(ERROR_INVALID_SIGNAL_NUMBER),
    MAKE_ERROR(ERROR_INVALID_SPI_VALUE),
    MAKE_ERROR(ERROR_INVALID_STACKSEG),
    MAKE_ERROR(ERROR_INVALID_STARTING_CODESEG),
    MAKE_ERROR(ERROR_INVALID_STATE),
    MAKE_ERROR(ERROR_INVALID_SUB_AUTHORITY),
    MAKE_ERROR(ERROR_INVALID_TARGET_HANDLE),
    MAKE_ERROR(ERROR_INVALID_THREAD_ID),
    MAKE_ERROR(ERROR_INVALID_TIME),
    MAKE_ERROR(ERROR_INVALID_TRANSFORM),
    MAKE_ERROR(ERROR_INVALID_USER_BUFFER),
    MAKE_ERROR(ERROR_INVALID_VERIFY_SWITCH),
    MAKE_ERROR(ERROR_INVALID_WINDOW_HANDLE),
    MAKE_ERROR(ERROR_INVALID_WINDOW_STYLE),
    MAKE_ERROR(ERROR_INVALID_WORKSTATION),
    MAKE_ERROR(ERROR_IOPL_NOT_ENABLED),
    MAKE_ERROR(ERROR_IO_DEVICE),
    MAKE_ERROR(ERROR_IO_INCOMPLETE),
    MAKE_ERROR(ERROR_IO_PENDING),
    MAKE_ERROR(ERROR_IRQ_BUSY),
    MAKE_ERROR(ERROR_IS_JOINED),
    MAKE_ERROR(ERROR_IS_JOIN_PATH),
    MAKE_ERROR(ERROR_IS_JOIN_TARGET),
    MAKE_ERROR(ERROR_IS_SUBSTED),
    MAKE_ERROR(ERROR_IS_SUBST_PATH),
    MAKE_ERROR(ERROR_IS_SUBST_TARGET),
    MAKE_ERROR(ERROR_ITERATED_DATA_EXCEEDS_64k),
    MAKE_ERROR(ERROR_JOIN_TO_JOIN),
    MAKE_ERROR(ERROR_JOIN_TO_SUBST),
    MAKE_ERROR(ERROR_JOURNAL_HOOK_SET),
    MAKE_ERROR(ERROR_KEY_DELETED),
    MAKE_ERROR(ERROR_KEY_HAS_CHILDREN),
    MAKE_ERROR(ERROR_LABEL_TOO_LONG),
    MAKE_ERROR(ERROR_LAST_ADMIN),
    MAKE_ERROR(ERROR_LB_WITHOUT_TABSTOPS),
    MAKE_ERROR(ERROR_LIBRARY_OFFLINE),
    MAKE_ERROR(ERROR_LICENSE_QUOTA_EXCEEDED),
    MAKE_ERROR(ERROR_LISTBOX_ID_NOT_FOUND),
    MAKE_ERROR(ERROR_LM_CROSS_ENCRYPTION_REQUIRED),
    MAKE_ERROR(ERROR_LOCAL_USER_SESSION_KEY),
    MAKE_ERROR(ERROR_LOCKED),
    MAKE_ERROR(ERROR_LOCK_FAILED),
    MAKE_ERROR(ERROR_LOCK_VIOLATION),
    MAKE_ERROR(ERROR_LOGIN_TIME_RESTRICTION),
    MAKE_ERROR(ERROR_LOGIN_WKSTA_RESTRICTION),
    MAKE_ERROR(ERROR_LOGON_FAILURE),
    MAKE_ERROR(ERROR_LOGON_NOT_GRANTED),
    MAKE_ERROR(ERROR_LOGON_SESSION_COLLISION),
    MAKE_ERROR(ERROR_LOGON_SESSION_EXISTS),
    MAKE_ERROR(ERROR_LOGON_TYPE_NOT_GRANTED),
    MAKE_ERROR(ERROR_LOG_FILE_FULL),
    MAKE_ERROR(ERROR_LUIDS_EXHAUSTED),
    MAKE_ERROR(ERROR_MAGAZINE_NOT_PRESENT),
    MAKE_ERROR(ERROR_MAPPED_ALIGNMENT),
    MAKE_ERROR(ERROR_MAX_THRDS_REACHED),
    MAKE_ERROR(ERROR_MEDIA_CHANGED),
    MAKE_ERROR(ERROR_MEDIA_INCOMPATIBLE),
    MAKE_ERROR(ERROR_MEDIA_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_MEDIA_OFFLINE),
    MAKE_ERROR(ERROR_MEDIA_UNAVAILABLE),
    MAKE_ERROR(ERROR_MEMBERS_PRIMARY_GROUP),
    MAKE_ERROR(ERROR_MEMBER_IN_ALIAS),
    MAKE_ERROR(ERROR_MEMBER_IN_GROUP),
    MAKE_ERROR(ERROR_MEMBER_NOT_IN_ALIAS),
    MAKE_ERROR(ERROR_MEMBER_NOT_IN_GROUP),
    MAKE_ERROR(ERROR_MENU_ITEM_NOT_FOUND),
    MAKE_ERROR(ERROR_MESSAGE_SYNC_ONLY),
    MAKE_ERROR(ERROR_METAFILE_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_META_EXPANSION_TOO_LONG),
    MAKE_ERROR(ERROR_MOD_NOT_FOUND),
    MAKE_ERROR(ERROR_MORE_DATA),
    MAKE_ERROR(ERROR_MORE_WRITES),
    MAKE_ERROR(ERROR_MR_MID_NOT_FOUND),
    MAKE_ERROR(ERROR_NEGATIVE_SEEK),
    MAKE_ERROR(ERROR_NESTING_NOT_ALLOWED),
    MAKE_ERROR(ERROR_NETLOGON_NOT_STARTED),
    MAKE_ERROR(ERROR_NETNAME_DELETED),
    MAKE_ERROR(ERROR_NETWORK_ACCESS_DENIED),
    MAKE_ERROR(ERROR_NETWORK_BUSY),
    MAKE_ERROR(ERROR_NETWORK_UNREACHABLE),
    MAKE_ERROR(ERROR_NET_WRITE_FAULT),
    MAKE_ERROR(ERROR_NOACCESS),
    MAKE_ERROR(ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NOLOGON_SERVER_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NONE_MAPPED),
    MAKE_ERROR(ERROR_NONPAGED_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_NON_MDICHILD_WINDOW),
    MAKE_ERROR(ERROR_NOTIFY_ENUM_DIR),
    MAKE_ERROR(ERROR_NOT_ALL_ASSIGNED),
    MAKE_ERROR(ERROR_NOT_AUTHENTICATED),
    MAKE_ERROR(ERROR_NOT_A_REPARSE_POINT),
    MAKE_ERROR(ERROR_NOT_CHILD_WINDOW),
    MAKE_ERROR(ERROR_NOT_CONNECTED),
    MAKE_ERROR(ERROR_NOT_CONTAINER),
    MAKE_ERROR(ERROR_NOT_DOS_DISK),
    MAKE_ERROR(ERROR_NOT_EMPTY),
    MAKE_ERROR(ERROR_NOT_ENOUGH_MEMORY),
    MAKE_ERROR(ERROR_NOT_ENOUGH_QUOTA),
    MAKE_ERROR(ERROR_NOT_ENOUGH_SERVER_MEMORY),
    MAKE_ERROR(ERROR_NOT_EXPORT_FORMAT),
    MAKE_ERROR(ERROR_NOT_FOUND),
    MAKE_ERROR(ERROR_NOT_JOINED),
    MAKE_ERROR(ERROR_NOT_LOCKED),
    MAKE_ERROR(ERROR_NOT_LOGGED_ON),
    MAKE_ERROR(ERROR_NOT_LOGON_PROCESS),
    MAKE_ERROR(ERROR_NOT_OWNER),
    MAKE_ERROR(ERROR_NOT_QUORUM_CAPABLE),
    MAKE_ERROR(ERROR_NOT_QUORUM_CLASS),
    MAKE_ERROR(ERROR_NOT_READY),
    MAKE_ERROR(ERROR_NOT_REGISTRY_FILE),
    MAKE_ERROR(ERROR_NOT_SAME_DEVICE),
    MAKE_ERROR(ERROR_NOT_SUBSTED),
    MAKE_ERROR(ERROR_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_NO_ASSOCIATION),
    MAKE_ERROR(ERROR_NO_BROWSER_SERVERS_FOUND),
    MAKE_ERROR(ERROR_NO_DATA),
    MAKE_ERROR(ERROR_NO_DATA_DETECTED),
    MAKE_ERROR(ERROR_NO_EFS),
    MAKE_ERROR(ERROR_NO_IMPERSONATION_TOKEN),
    MAKE_ERROR(ERROR_NO_INHERITANCE),
    MAKE_ERROR(ERROR_NO_LOGON_SERVERS),
    MAKE_ERROR(ERROR_NO_LOG_SPACE),
    MAKE_ERROR(ERROR_NO_MATCH),
    MAKE_ERROR(ERROR_NO_MEDIA_IN_DRIVE),
    MAKE_ERROR(ERROR_NO_MORE_DEVICES),
    MAKE_ERROR(ERROR_NO_MORE_FILES),
    MAKE_ERROR(ERROR_NO_MORE_ITEMS),
    MAKE_ERROR(ERROR_NO_MORE_SEARCH_HANDLES),
    MAKE_ERROR(ERROR_NO_MORE_USER_HANDLES),
    MAKE_ERROR(ERROR_NO_NETWORK),
    MAKE_ERROR(ERROR_NO_NET_OR_BAD_PATH),
    MAKE_ERROR(ERROR_NO_PROC_SLOTS),
    MAKE_ERROR(ERROR_NO_QUOTAS_FOR_ACCOUNT),
    MAKE_ERROR(ERROR_NO_RECOVERY_POLICY),
    MAKE_ERROR(ERROR_NO_RECOVERY_PROGRAM),
    MAKE_ERROR(ERROR_NO_SCROLLBARS),
    MAKE_ERROR(ERROR_NO_SECURITY_ON_OBJECT),
    MAKE_ERROR(ERROR_NO_SHUTDOWN_IN_PROGRESS),
    MAKE_ERROR(ERROR_NO_SIGNAL_SENT),
    MAKE_ERROR(ERROR_NO_SITENAME),
    MAKE_ERROR(ERROR_NO_SPOOL_SPACE),
    MAKE_ERROR(ERROR_NO_SUCH_ALIAS),
    MAKE_ERROR(ERROR_NO_SUCH_DOMAIN),
    MAKE_ERROR(ERROR_NO_SUCH_GROUP),
    MAKE_ERROR(ERROR_NO_SUCH_LOGON_SESSION),
    MAKE_ERROR(ERROR_NO_SUCH_MEMBER),
    MAKE_ERROR(ERROR_NO_SUCH_PACKAGE),
    MAKE_ERROR(ERROR_NO_SUCH_PRIVILEGE),
    MAKE_ERROR(ERROR_NO_SUCH_SITE),
    MAKE_ERROR(ERROR_NO_SUCH_USER),
    MAKE_ERROR(ERROR_NO_SYSTEM_MENU),
    MAKE_ERROR(ERROR_NO_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_NO_TOKEN),
    MAKE_ERROR(ERROR_NO_TRACKING_SERVICE),
    MAKE_ERROR(ERROR_NO_TRUST_LSA_SECRET),
    MAKE_ERROR(ERROR_NO_TRUST_SAM_ACCOUNT),
    MAKE_ERROR(ERROR_NO_UNICODE_TRANSLATION),
    MAKE_ERROR(ERROR_NO_USER_KEYS),
    MAKE_ERROR(ERROR_NO_USER_SESSION_KEY),
    MAKE_ERROR(ERROR_NO_VOLUME_ID),
    MAKE_ERROR(ERROR_NO_VOLUME_LABEL),
    MAKE_ERROR(ERROR_NO_WILDCARD_CHARACTERS),
    MAKE_ERROR(ERROR_NT_CROSS_ENCRYPTION_REQUIRED),
    MAKE_ERROR(ERROR_NULL_LM_PASSWORD),
    MAKE_ERROR(ERROR_OBJECT_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_OBJECT_IN_LIST),
    MAKE_ERROR(ERROR_OBJECT_NOT_FOUND),
    MAKE_ERROR(ERROR_OLD_WIN_VERSION),
    MAKE_ERROR(ERROR_OPEN_FAILED),
    MAKE_ERROR(ERROR_OPEN_FILES),
    MAKE_ERROR(ERROR_OPERATION_ABORTED),
    MAKE_ERROR(ERROR_OPLOCK_NOT_GRANTED),
    MAKE_ERROR(ERROR_OUTOFMEMORY),
    MAKE_ERROR(ERROR_OUT_OF_PAPER),
    MAKE_ERROR(ERROR_OUT_OF_STRUCTURES),
    MAKE_ERROR(ERROR_PAGED_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_PAGEFILE_QUOTA),
    MAKE_ERROR(ERROR_PARTIAL_COPY),
    MAKE_ERROR(ERROR_PARTITION_FAILURE),
    MAKE_ERROR(ERROR_PASSWORD_EXPIRED),
    MAKE_ERROR(ERROR_PASSWORD_MUST_CHANGE),
    MAKE_ERROR(ERROR_PASSWORD_RESTRICTION),
    MAKE_ERROR(ERROR_PATH_BUSY),
    MAKE_ERROR(ERROR_PATH_NOT_FOUND),
    MAKE_ERROR(ERROR_PIPE_BUSY),
    MAKE_ERROR(ERROR_PIPE_CONNECTED),
    MAKE_ERROR(ERROR_PIPE_LISTENING),
    MAKE_ERROR(ERROR_PIPE_NOT_CONNECTED),
    MAKE_ERROR(ERROR_POINT_NOT_FOUND),
    MAKE_ERROR(ERROR_POPUP_ALREADY_ACTIVE),
    MAKE_ERROR(ERROR_PORT_UNREACHABLE),
    MAKE_ERROR(ERROR_POSSIBLE_DEADLOCK),
    MAKE_ERROR(ERROR_PRINTER_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_PRINTER_DELETED),
    MAKE_ERROR(ERROR_PRINTER_DRIVER_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRINTER_DRIVER_IN_USE),
    MAKE_ERROR(ERROR_PRINTER_HAS_JOBS_QUEUED),
    MAKE_ERROR(ERROR_PRINTQ_FULL),
    MAKE_ERROR(ERROR_PRINT_CANCELLED),
    MAKE_ERROR(ERROR_PRINT_MONITOR_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRINT_MONITOR_IN_USE),
    MAKE_ERROR(ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRIVATE_DIALOG_INDEX),
    MAKE_ERROR(ERROR_PRIVILEGE_NOT_HELD),
    MAKE_ERROR(ERROR_PROCESS_ABORTED),
    MAKE_ERROR(ERROR_PROC_NOT_FOUND),
    MAKE_ERROR(ERROR_PRODUCT_UNINSTALLED),
    MAKE_ERROR(ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE),
    MAKE_ERROR(ERROR_PROFILE_NOT_FOUND),
    MAKE_ERROR(ERROR_PROTOCOL_UNREACHABLE),
    MAKE_ERROR(ERROR_QUORUMLOG_OPEN_FAILED),
    MAKE_ERROR(ERROR_QUORUM_RESOURCE),
    MAKE_ERROR(ERROR_QUORUM_RESOURCE_ONLINE_FAILED),
    MAKE_ERROR(ERROR_READ_FAULT),
    MAKE_ERROR(ERROR_REC_NON_EXISTENT),
    MAKE_ERROR(ERROR_REDIRECTOR_HAS_OPEN_HANDLES),
    MAKE_ERROR(ERROR_REDIR_PAUSED),
    MAKE_ERROR(ERROR_REGISTRY_CORRUPT),
    MAKE_ERROR(ERROR_REGISTRY_IO_FAILED),
    MAKE_ERROR(ERROR_REGISTRY_RECOVERED),
    MAKE_ERROR(ERROR_RELOC_CHAIN_XEEDS_SEGLIM),
    MAKE_ERROR(ERROR_REMOTE_SESSION_LIMIT_EXCEEDED),
    MAKE_ERROR(ERROR_REMOTE_STORAGE_MEDIA_ERROR),
    MAKE_ERROR(ERROR_REMOTE_STORAGE_NOT_ACTIVE),
    MAKE_ERROR(ERROR_REM_NOT_LIST),
    MAKE_ERROR(ERROR_REPARSE_ATTRIBUTE_CONFLICT),
    MAKE_ERROR(ERROR_REQUEST_ABORTED),
    MAKE_ERROR(ERROR_REQUEST_REFUSED),
    MAKE_ERROR(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION),
    MAKE_ERROR(ERROR_REQ_NOT_ACCEP),
    MAKE_ERROR(ERROR_RESMON_CREATE_FAILED),
    MAKE_ERROR(ERROR_RESMON_ONLINE_FAILED),
    MAKE_ERROR(ERROR_RESOURCE_DATA_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_DISABLED),
    MAKE_ERROR(ERROR_RESOURCE_LANG_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NAME_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_RESOURCE_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NOT_ONLINE),
    MAKE_ERROR(ERROR_RESOURCE_NOT_PRESENT),
    MAKE_ERROR(ERROR_RESOURCE_ONLINE),
    MAKE_ERROR(ERROR_RESOURCE_PROPERTIES_STORED),
    MAKE_ERROR(ERROR_RESOURCE_TYPE_NOT_FOUND),
    MAKE_ERROR(ERROR_RETRY),
    MAKE_ERROR(ERROR_REVISION_MISMATCH),
    MAKE_ERROR(ERROR_RING2SEG_MUST_BE_MOVABLE),
    MAKE_ERROR(ERROR_RING2_STACK_IN_USE),
    MAKE_ERROR(ERROR_RMODE_APP),
    MAKE_ERROR(ERROR_RPL_NOT_ALLOWED),
    MAKE_ERROR(ERROR_RXACT_COMMIT_FAILURE),
    MAKE_ERROR(ERROR_RXACT_INVALID_STATE),
    MAKE_ERROR(ERROR_SAME_DRIVE),
    MAKE_ERROR(ERROR_SCREEN_ALREADY_LOCKED),
    MAKE_ERROR(ERROR_SECRET_TOO_LONG),
    MAKE_ERROR(ERROR_SECTOR_NOT_FOUND),
    MAKE_ERROR(ERROR_SEEK),
    MAKE_ERROR(ERROR_SEEK_ON_DEVICE),
    MAKE_ERROR(ERROR_SEM_IS_SET),
    MAKE_ERROR(ERROR_SEM_NOT_FOUND),
    MAKE_ERROR(ERROR_SEM_OWNER_DIED),
    MAKE_ERROR(ERROR_SEM_TIMEOUT),
    MAKE_ERROR(ERROR_SEM_USER_LIMIT),
    MAKE_ERROR(ERROR_SERIAL_NO_DEVICE),
    MAKE_ERROR(ERROR_SERVER_DISABLED),
    MAKE_ERROR(ERROR_SERVER_HAS_OPEN_HANDLES),
    MAKE_ERROR(ERROR_SERVER_NOT_DISABLED),
    MAKE_ERROR(ERROR_SERVICE_ALREADY_RUNNING),
    MAKE_ERROR(ERROR_SERVICE_CANNOT_ACCEPT_CTRL),
    MAKE_ERROR(ERROR_SERVICE_DATABASE_LOCKED),
    MAKE_ERROR(ERROR_SERVICE_DEPENDENCY_DELETED),
    MAKE_ERROR(ERROR_SERVICE_DEPENDENCY_FAIL),
    MAKE_ERROR(ERROR_SERVICE_DISABLED),
    MAKE_ERROR(ERROR_SERVICE_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_SERVICE_EXISTS),
    MAKE_ERROR(ERROR_SERVICE_LOGON_FAILED),
    MAKE_ERROR(ERROR_SERVICE_MARKED_FOR_DELETE),
    MAKE_ERROR(ERROR_SERVICE_NEVER_STARTED),
    MAKE_ERROR(ERROR_SERVICE_NOT_ACTIVE),
    MAKE_ERROR(ERROR_SERVICE_NOT_FOUND),
    MAKE_ERROR(ERROR_SERVICE_NO_THREAD),
    MAKE_ERROR(ERROR_SERVICE_REQUEST_TIMEOUT),
    MAKE_ERROR(ERROR_SERVICE_SPECIFIC_ERROR),
    MAKE_ERROR(ERROR_SERVICE_START_HANG),
    MAKE_ERROR(ERROR_SESSION_CREDENTIAL_CONFLICT),
    MAKE_ERROR(ERROR_SETCOUNT_ON_BAD_LB),
    MAKE_ERROR(ERROR_SETMARK_DETECTED),
    MAKE_ERROR(ERROR_SET_NOT_FOUND),
    MAKE_ERROR(ERROR_SET_POWER_STATE_FAILED),
    MAKE_ERROR(ERROR_SET_POWER_STATE_VETOED),
    MAKE_ERROR(ERROR_SHARING_BUFFER_EXCEEDED),
    MAKE_ERROR(ERROR_SHARING_PAUSED),
    MAKE_ERROR(ERROR_SHARING_VIOLATION),
    MAKE_ERROR(ERROR_SHUTDOWN_CLUSTER),
    MAKE_ERROR(ERROR_SHUTDOWN_IN_PROGRESS),
    MAKE_ERROR(ERROR_SIGNAL_PENDING),
    MAKE_ERROR(ERROR_SIGNAL_REFUSED),
    MAKE_ERROR(ERROR_SINGLE_INSTANCE_APP),
    MAKE_ERROR(ERROR_SOME_NOT_MAPPED),
    MAKE_ERROR(ERROR_SOURCE_ELEMENT_EMPTY),
    MAKE_ERROR(ERROR_SPECIAL_ACCOUNT),
    MAKE_ERROR(ERROR_SPECIAL_GROUP),
    MAKE_ERROR(ERROR_SPECIAL_USER),
    MAKE_ERROR(ERROR_SPL_NO_ADDJOB),
    MAKE_ERROR(ERROR_SPL_NO_STARTDOC),
    MAKE_ERROR(ERROR_SPOOL_FILE_NOT_FOUND),
    MAKE_ERROR(ERROR_STACK_OVERFLOW),
    MAKE_ERROR(ERROR_STATIC_INIT),
    MAKE_ERROR(ERROR_SUBST_TO_JOIN),
    MAKE_ERROR(ERROR_SUBST_TO_SUBST),
    MAKE_ERROR(ERROR_SUCCESS),
    MAKE_ERROR(ERROR_SUCCESS_REBOOT_REQUIRED),
    MAKE_ERROR(ERROR_SUCCESS_RESTART_REQUIRED),
    MAKE_ERROR(ERROR_SWAPERROR),
    MAKE_ERROR(ERROR_SYSTEM_TRACE),
    MAKE_ERROR(ERROR_TAG_NOT_FOUND),
    MAKE_ERROR(ERROR_TAG_NOT_PRESENT),
    MAKE_ERROR(ERROR_THREAD_1_INACTIVE),
    MAKE_ERROR(ERROR_TIMEOUT),
    MAKE_ERROR(ERROR_TLW_WITH_WSCHILD),
    MAKE_ERROR(ERROR_TOKEN_ALREADY_IN_USE),
    MAKE_ERROR(ERROR_TOO_MANY_CMDS),
    MAKE_ERROR(ERROR_TOO_MANY_CONTEXT_IDS),
    MAKE_ERROR(ERROR_TOO_MANY_LINKS),
    MAKE_ERROR(ERROR_TOO_MANY_LUIDS_REQUESTED),
    MAKE_ERROR(ERROR_TOO_MANY_MODULES),
    MAKE_ERROR(ERROR_TOO_MANY_MUXWAITERS),
    MAKE_ERROR(ERROR_TOO_MANY_NAMES),
    MAKE_ERROR(ERROR_TOO_MANY_OPEN_FILES),
    MAKE_ERROR(ERROR_TOO_MANY_POSTS),
    MAKE_ERROR(ERROR_TOO_MANY_SECRETS),
    MAKE_ERROR(ERROR_TOO_MANY_SEMAPHORES),
    MAKE_ERROR(ERROR_TOO_MANY_SEM_REQUESTS),
    MAKE_ERROR(ERROR_TOO_MANY_SESS),
    MAKE_ERROR(ERROR_TOO_MANY_SIDS),
    MAKE_ERROR(ERROR_TOO_MANY_TCBS),
    MAKE_ERROR(ERROR_TRANSFORM_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_TRUSTED_DOMAIN_FAILURE),
    MAKE_ERROR(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
    MAKE_ERROR(ERROR_TRUST_FAILURE),
    MAKE_ERROR(ERROR_UNABLE_TO_CLEAN),
    MAKE_ERROR(ERROR_UNABLE_TO_LOCK_MEDIA),
    MAKE_ERROR(ERROR_UNABLE_TO_UNLOAD_MEDIA),
    MAKE_ERROR(ERROR_UNEXP_NET_ERR),
    MAKE_ERROR(ERROR_UNKNOWN_COMPONENT),
    MAKE_ERROR(ERROR_UNKNOWN_FEATURE),
    MAKE_ERROR(ERROR_UNKNOWN_PORT),
    MAKE_ERROR(ERROR_UNKNOWN_PRINTER_DRIVER),
    MAKE_ERROR(ERROR_UNKNOWN_PRINTPROCESSOR),
    MAKE_ERROR(ERROR_UNKNOWN_PRINT_MONITOR),
    MAKE_ERROR(ERROR_UNKNOWN_PRODUCT),
    MAKE_ERROR(ERROR_UNKNOWN_PROPERTY),
    MAKE_ERROR(ERROR_UNKNOWN_REVISION),
    MAKE_ERROR(ERROR_UNRECOGNIZED_MEDIA),
    MAKE_ERROR(ERROR_UNRECOGNIZED_VOLUME),
    MAKE_ERROR(ERROR_USER_EXISTS),
    MAKE_ERROR(ERROR_USER_MAPPED_FILE),
    MAKE_ERROR(ERROR_VC_DISCONNECTED),
    MAKE_ERROR(ERROR_WAIT_NO_CHILDREN),
    MAKE_ERROR(ERROR_WINDOW_NOT_COMBOBOX),
    MAKE_ERROR(ERROR_WINDOW_NOT_DIALOG),
    MAKE_ERROR(ERROR_WINDOW_OF_OTHER_THREAD),
    MAKE_ERROR(ERROR_WINS_INTERNAL),
    MAKE_ERROR(ERROR_WMI_ALREADY_ENABLED),
    MAKE_ERROR(ERROR_WMI_DP_FAILED),
    MAKE_ERROR(ERROR_WMI_DP_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_GUID_DISCONNECTED),
    MAKE_ERROR(ERROR_WMI_GUID_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_INSTANCE_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_INVALID_MOF),
    MAKE_ERROR(ERROR_WMI_INVALID_REGINFO),
    MAKE_ERROR(ERROR_WMI_ITEMID_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_SERVER_UNAVAILABLE),
    MAKE_ERROR(ERROR_WMI_TRY_AGAIN),
    MAKE_ERROR(ERROR_WMI_UNRESOLVED_INSTANCE_REF),
    MAKE_ERROR(ERROR_WORKING_SET_QUOTA),
    MAKE_ERROR(ERROR_WRITE_FAULT),
    MAKE_ERROR(ERROR_WRITE_PROTECT),
    MAKE_ERROR(ERROR_WRONG_DISK),
    MAKE_ERROR(ERROR_WRONG_EFS),
    MAKE_ERROR(ERROR_WRONG_PASSWORD),
    MAKE_ERROR(E_ABORT),
    MAKE_ERROR(E_ACCESSDENIED),
    MAKE_ERROR(E_FAIL),
    MAKE_ERROR(E_HANDLE),
    MAKE_ERROR(E_INVALIDARG),
    MAKE_ERROR(E_NOINTERFACE),
    MAKE_ERROR(E_NOTIMPL),
    MAKE_ERROR(E_OUTOFMEMORY),
    MAKE_ERROR(E_PENDING),
    MAKE_ERROR(E_POINTER),
    MAKE_ERROR(E_UNEXPECTED),
    MAKE_ERROR(INPLACE_E_NOTOOLSPACE),
    MAKE_ERROR(INPLACE_E_NOTUNDOABLE),
    MAKE_ERROR(INPLACE_S_TRUNCATED),
    MAKE_ERROR(MEM_E_INVALID_LINK),
    MAKE_ERROR(MEM_E_INVALID_ROOT),
    MAKE_ERROR(MEM_E_INVALID_SIZE),
    MAKE_ERROR(MK_E_CANTOPENFILE),
    MAKE_ERROR(MK_E_CONNECTMANUALLY),
    MAKE_ERROR(MK_E_ENUMERATION_FAILED),
    MAKE_ERROR(MK_E_EXCEEDEDDEADLINE),
    MAKE_ERROR(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED),
    MAKE_ERROR(MK_E_INVALIDEXTENSION),
    MAKE_ERROR(MK_E_MUSTBOTHERUSER),
    MAKE_ERROR(MK_E_NEEDGENERIC),
    MAKE_ERROR(MK_E_NOINVERSE),
    MAKE_ERROR(MK_E_NOOBJECT),
    MAKE_ERROR(MK_E_NOPREFIX),
    MAKE_ERROR(MK_E_NOSTORAGE),
    MAKE_ERROR(MK_E_NOTBINDABLE),
    MAKE_ERROR(MK_E_NOTBOUND),
    MAKE_ERROR(MK_E_NO_NORMALIZED),
    MAKE_ERROR(MK_E_SYNTAX),
    MAKE_ERROR(MK_E_UNAVAILABLE),
    MAKE_ERROR(MK_S_HIM),
    MAKE_ERROR(MK_S_ME),
    MAKE_ERROR(MK_S_MONIKERALREADYREGISTERED),
    MAKE_ERROR(MK_S_REDUCED_TO_SELF),
    MAKE_ERROR(MK_S_US),
    MAKE_ERROR(NOERROR),
    MAKE_ERROR(NO_ERROR),
    MAKE_ERROR(NTE_BAD_ALGID),
    MAKE_ERROR(NTE_BAD_DATA),
    MAKE_ERROR(NTE_BAD_FLAGS),
    MAKE_ERROR(NTE_BAD_HASH),
    MAKE_ERROR(NTE_BAD_HASH_STATE),
    MAKE_ERROR(NTE_BAD_KEY),
    MAKE_ERROR(NTE_BAD_KEYSET),
    MAKE_ERROR(NTE_BAD_KEYSET_PARAM),
    MAKE_ERROR(NTE_BAD_KEY_STATE),
    MAKE_ERROR(NTE_BAD_LEN),
    MAKE_ERROR(NTE_BAD_PROVIDER),
    MAKE_ERROR(NTE_BAD_PROV_TYPE),
    MAKE_ERROR(NTE_BAD_PUBLIC_KEY),
    MAKE_ERROR(NTE_BAD_SIGNATURE),
    MAKE_ERROR(NTE_BAD_TYPE),
    MAKE_ERROR(NTE_BAD_UID),
    MAKE_ERROR(NTE_BAD_VER),
    MAKE_ERROR(NTE_DOUBLE_ENCRYPT),
    MAKE_ERROR(NTE_EXISTS),
    MAKE_ERROR(NTE_FAIL),
    MAKE_ERROR(NTE_KEYSET_ENTRY_BAD),
    MAKE_ERROR(NTE_KEYSET_NOT_DEF),
    MAKE_ERROR(NTE_NOT_FOUND),
    MAKE_ERROR(NTE_NO_KEY),
    MAKE_ERROR(NTE_NO_MEMORY),
    MAKE_ERROR(NTE_OP_OK),
    MAKE_ERROR(NTE_PERM),
    MAKE_ERROR(NTE_PROVIDER_DLL_FAIL),
    MAKE_ERROR(NTE_PROV_DLL_NOT_FOUND),
    MAKE_ERROR(NTE_PROV_TYPE_ENTRY_BAD),
    MAKE_ERROR(NTE_PROV_TYPE_NOT_DEF),
    MAKE_ERROR(NTE_PROV_TYPE_NO_MATCH),
    MAKE_ERROR(NTE_SIGNATURE_FILE_BAD),
    MAKE_ERROR(NTE_SYS_ERR),
    MAKE_ERROR(OLEOBJ_E_INVALIDVERB),
    MAKE_ERROR(OLEOBJ_E_NOVERBS),
    MAKE_ERROR(OLEOBJ_S_CANNOT_DOVERB_NOW),
    MAKE_ERROR(OLEOBJ_S_INVALIDHWND),
    MAKE_ERROR(OLEOBJ_S_INVALIDVERB),
    MAKE_ERROR(OLE_E_ADVF),
    MAKE_ERROR(OLE_E_ADVISENOTSUPPORTED),
    MAKE_ERROR(OLE_E_BLANK),
    MAKE_ERROR(OLE_E_CANTCONVERT),
    MAKE_ERROR(OLE_E_CANT_BINDTOSOURCE),
    MAKE_ERROR(OLE_E_CANT_GETMONIKER),
    MAKE_ERROR(OLE_E_CLASSDIFF),
    MAKE_ERROR(OLE_E_ENUM_NOMORE),
    MAKE_ERROR(OLE_E_INVALIDHWND),
    MAKE_ERROR(OLE_E_INVALIDRECT),
    MAKE_ERROR(OLE_E_NOCACHE),
    MAKE_ERROR(OLE_E_NOCONNECTION),
    MAKE_ERROR(OLE_E_NOSTORAGE),
    MAKE_ERROR(OLE_E_NOTRUNNING),
    MAKE_ERROR(OLE_E_NOT_INPLACEACTIVE),
    MAKE_ERROR(OLE_E_OLEVERB),
    MAKE_ERROR(OLE_E_PROMPTSAVECANCELLED),
    MAKE_ERROR(OLE_E_STATIC),
    MAKE_ERROR(OLE_E_WRONGCOMPOBJ),
    MAKE_ERROR(OLE_S_MAC_CLIPFORMAT),
    MAKE_ERROR(OLE_S_STATIC),
    MAKE_ERROR(OLE_S_USEREG),
    MAKE_ERROR(OR_INVALID_OID),
    MAKE_ERROR(OR_INVALID_OXID),
    MAKE_ERROR(OR_INVALID_SET),
    MAKE_ERROR(PERSIST_E_NOTSELFSIZING),
    MAKE_ERROR(PERSIST_E_SIZEDEFINITE),
    MAKE_ERROR(PERSIST_E_SIZEINDEFINITE),
    MAKE_ERROR(REGDB_E_CLASSNOTREG),
    MAKE_ERROR(REGDB_E_IIDNOTREG),
    MAKE_ERROR(REGDB_E_INVALIDVALUE),
    MAKE_ERROR(REGDB_E_KEYMISSING),
    MAKE_ERROR(REGDB_E_READREGDB),
    MAKE_ERROR(REGDB_E_WRITEREGDB),
    MAKE_ERROR(RPC_E_ACCESS_DENIED),
    MAKE_ERROR(RPC_E_ATTEMPTED_MULTITHREAD),
    MAKE_ERROR(RPC_E_CALL_CANCELED),
    MAKE_ERROR(RPC_E_CALL_COMPLETE),
    MAKE_ERROR(RPC_E_CALL_REJECTED),
    MAKE_ERROR(RPC_E_CANTCALLOUT_AGAIN),
    MAKE_ERROR(RPC_E_CANTCALLOUT_INASYNCCALL),
    MAKE_ERROR(RPC_E_CANTCALLOUT_INEXTERNALCALL),
    MAKE_ERROR(RPC_E_CANTCALLOUT_ININPUTSYNCCALL),
    MAKE_ERROR(RPC_E_CANTPOST_INSENDCALL),
    MAKE_ERROR(RPC_E_CANTTRANSMIT_CALL),
    MAKE_ERROR(RPC_E_CHANGED_MODE),
    MAKE_ERROR(RPC_E_CLIENT_CANTMARSHAL_DATA),
    MAKE_ERROR(RPC_E_CLIENT_CANTUNMARSHAL_DATA),
    MAKE_ERROR(RPC_E_CLIENT_DIED),
    MAKE_ERROR(RPC_E_CONNECTION_TERMINATED),
    MAKE_ERROR(RPC_E_DISCONNECTED),
    MAKE_ERROR(RPC_E_FAULT),
    MAKE_ERROR(RPC_E_INVALIDMETHOD),
    MAKE_ERROR(RPC_E_INVALID_CALLDATA),
    MAKE_ERROR(RPC_E_INVALID_DATA),
    MAKE_ERROR(RPC_E_INVALID_DATAPACKET),
    MAKE_ERROR(RPC_E_INVALID_EXTENSION),
    MAKE_ERROR(RPC_E_INVALID_HEADER),
    MAKE_ERROR(RPC_E_INVALID_IPID),
    MAKE_ERROR(RPC_E_INVALID_OBJECT),
    MAKE_ERROR(RPC_E_INVALID_OBJREF),
    MAKE_ERROR(RPC_E_INVALID_PARAMETER),
    MAKE_ERROR(RPC_E_NOT_REGISTERED),
    MAKE_ERROR(RPC_E_NO_CONTEXT),
    MAKE_ERROR(RPC_E_NO_GOOD_SECURITY_PACKAGES),
    MAKE_ERROR(RPC_E_NO_SYNC),
    MAKE_ERROR(RPC_E_OUT_OF_RESOURCES),
    MAKE_ERROR(RPC_E_REMOTE_DISABLED),
    MAKE_ERROR(RPC_E_RETRY),
    MAKE_ERROR(RPC_E_SERVERCALL_REJECTED),
    MAKE_ERROR(RPC_E_SERVERCALL_RETRYLATER),
    MAKE_ERROR(RPC_E_SERVERFAULT),
    MAKE_ERROR(RPC_E_SERVER_CANTMARSHAL_DATA),
    MAKE_ERROR(RPC_E_SERVER_CANTUNMARSHAL_DATA),
    MAKE_ERROR(RPC_E_SERVER_DIED),
    MAKE_ERROR(RPC_E_SERVER_DIED_DNE),
    MAKE_ERROR(RPC_E_SYS_CALL_FAILED),
    MAKE_ERROR(RPC_E_THREAD_NOT_INIT),
    MAKE_ERROR(RPC_E_TIMEOUT),
    MAKE_ERROR(RPC_E_TOO_LATE),
    MAKE_ERROR(RPC_E_UNEXPECTED),
    MAKE_ERROR(RPC_E_UNSECURE_CALL),
    MAKE_ERROR(RPC_E_VERSION_MISMATCH),
    MAKE_ERROR(RPC_E_WRONG_THREAD),
    MAKE_ERROR(RPC_S_ADDRESS_ERROR),
    MAKE_ERROR(RPC_S_ALREADY_LISTENING),
    MAKE_ERROR(RPC_S_ALREADY_REGISTERED),
    MAKE_ERROR(RPC_S_BINDING_HAS_NO_AUTH),
    MAKE_ERROR(RPC_S_BINDING_INCOMPLETE),
    MAKE_ERROR(RPC_S_CALLPENDING),
    MAKE_ERROR(RPC_S_CALL_CANCELLED),
    MAKE_ERROR(RPC_S_CALL_FAILED),
    MAKE_ERROR(RPC_S_CALL_FAILED_DNE),
    MAKE_ERROR(RPC_S_CALL_IN_PROGRESS),
    MAKE_ERROR(RPC_S_CANNOT_SUPPORT),
    MAKE_ERROR(RPC_S_CANT_CREATE_ENDPOINT),
    MAKE_ERROR(RPC_S_COMM_FAILURE),
    MAKE_ERROR(RPC_S_DUPLICATE_ENDPOINT),
    MAKE_ERROR(RPC_S_ENTRY_ALREADY_EXISTS),
    MAKE_ERROR(RPC_S_ENTRY_NOT_FOUND),
    MAKE_ERROR(RPC_S_FP_DIV_ZERO),
    MAKE_ERROR(RPC_S_FP_OVERFLOW),
    MAKE_ERROR(RPC_S_FP_UNDERFLOW),
    MAKE_ERROR(RPC_S_GROUP_MEMBER_NOT_FOUND),
    MAKE_ERROR(RPC_S_INCOMPLETE_NAME),
    MAKE_ERROR(RPC_S_INTERFACE_NOT_FOUND),
    MAKE_ERROR(RPC_S_INTERNAL_ERROR),
    MAKE_ERROR(RPC_S_INVALID_ASYNC_CALL),
    MAKE_ERROR(RPC_S_INVALID_ASYNC_HANDLE),
    MAKE_ERROR(RPC_S_INVALID_AUTH_IDENTITY),
    MAKE_ERROR(RPC_S_INVALID_BINDING),
    MAKE_ERROR(RPC_S_INVALID_BOUND),
    MAKE_ERROR(RPC_S_INVALID_ENDPOINT_FORMAT),
    MAKE_ERROR(RPC_S_INVALID_NAF_ID),
    MAKE_ERROR(RPC_S_INVALID_NAME_SYNTAX),
    MAKE_ERROR(RPC_S_INVALID_NETWORK_OPTIONS),
    MAKE_ERROR(RPC_S_INVALID_NET_ADDR),
    MAKE_ERROR(RPC_S_INVALID_OBJECT),
    MAKE_ERROR(RPC_S_INVALID_RPC_PROTSEQ),
    MAKE_ERROR(RPC_S_INVALID_STRING_BINDING),
    MAKE_ERROR(RPC_S_INVALID_STRING_UUID),
    MAKE_ERROR(RPC_S_INVALID_TAG),
    MAKE_ERROR(RPC_S_INVALID_TIMEOUT),
    MAKE_ERROR(RPC_S_INVALID_VERS_OPTION),
    MAKE_ERROR(RPC_S_MAX_CALLS_TOO_SMALL),
    MAKE_ERROR(RPC_S_NAME_SERVICE_UNAVAILABLE),
    MAKE_ERROR(RPC_S_NOTHING_TO_EXPORT),
    MAKE_ERROR(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
    MAKE_ERROR(RPC_S_NOT_CANCELLED),
    MAKE_ERROR(RPC_S_NOT_LISTENING),
    MAKE_ERROR(RPC_S_NOT_RPC_ERROR),
    MAKE_ERROR(RPC_S_NO_BINDINGS),
    MAKE_ERROR(RPC_S_NO_CALL_ACTIVE),
    MAKE_ERROR(RPC_S_NO_CONTEXT_AVAILABLE),
    MAKE_ERROR(RPC_S_NO_ENDPOINT_FOUND),
    MAKE_ERROR(RPC_S_NO_ENTRY_NAME),
    MAKE_ERROR(RPC_S_NO_INTERFACES),
    MAKE_ERROR(RPC_S_NO_MORE_BINDINGS),
    MAKE_ERROR(RPC_S_NO_MORE_MEMBERS),
    MAKE_ERROR(RPC_S_NO_PRINC_NAME),
    MAKE_ERROR(RPC_S_NO_PROTSEQS),
    MAKE_ERROR(RPC_S_NO_PROTSEQS_REGISTERED),
    MAKE_ERROR(RPC_S_OBJECT_NOT_FOUND),
    MAKE_ERROR(RPC_S_OUT_OF_RESOURCES),
    MAKE_ERROR(RPC_S_PROCNUM_OUT_OF_RANGE),
    MAKE_ERROR(RPC_S_PROTOCOL_ERROR),
    MAKE_ERROR(RPC_S_PROTSEQ_NOT_FOUND),
    MAKE_ERROR(RPC_S_PROTSEQ_NOT_SUPPORTED),
    MAKE_ERROR(RPC_S_SEC_PKG_ERROR),
    MAKE_ERROR(RPC_S_SEND_INCOMPLETE),
    MAKE_ERROR(RPC_S_SERVER_TOO_BUSY),
    MAKE_ERROR(RPC_S_SERVER_UNAVAILABLE),
    MAKE_ERROR(RPC_S_STRING_TOO_LONG),
    MAKE_ERROR(RPC_S_TYPE_ALREADY_REGISTERED),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_LEVEL),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_SERVICE),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_TYPE),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHZ_SERVICE),
    MAKE_ERROR(RPC_S_UNKNOWN_IF),
    MAKE_ERROR(RPC_S_UNKNOWN_MGR_TYPE),
    MAKE_ERROR(RPC_S_UNSUPPORTED_AUTHN_LEVEL),
    MAKE_ERROR(RPC_S_UNSUPPORTED_NAME_SYNTAX),
    MAKE_ERROR(RPC_S_UNSUPPORTED_TRANS_SYN),
    MAKE_ERROR(RPC_S_UNSUPPORTED_TYPE),
    MAKE_ERROR(RPC_S_UUID_LOCAL_ONLY),
    MAKE_ERROR(RPC_S_UUID_NO_ADDRESS),
    MAKE_ERROR(RPC_S_WAITONTIMER),
    MAKE_ERROR(RPC_S_WRONG_KIND_OF_BINDING),
    MAKE_ERROR(RPC_S_ZERO_DIVIDE),
    MAKE_ERROR(RPC_X_BAD_STUB_DATA),
    MAKE_ERROR(RPC_X_BYTE_COUNT_TOO_SMALL),
    MAKE_ERROR(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
    MAKE_ERROR(RPC_X_INVALID_ES_ACTION),
    MAKE_ERROR(RPC_X_INVALID_PIPE_OBJECT),
    MAKE_ERROR(RPC_X_NO_MORE_ENTRIES),
    MAKE_ERROR(RPC_X_NULL_REF_POINTER),
    MAKE_ERROR(RPC_X_PIPE_CLOSED),
    MAKE_ERROR(RPC_X_PIPE_DISCIPLINE_ERROR),
    MAKE_ERROR(RPC_X_PIPE_EMPTY),
    MAKE_ERROR(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
    MAKE_ERROR(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
    MAKE_ERROR(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
    MAKE_ERROR(RPC_X_SS_CONTEXT_DAMAGED),
    MAKE_ERROR(RPC_X_SS_HANDLES_MISMATCH),
    MAKE_ERROR(RPC_X_SS_IN_NULL_CONTEXT),
    MAKE_ERROR(RPC_X_WRONG_ES_VERSION),
    MAKE_ERROR(RPC_X_WRONG_PIPE_ORDER),
    MAKE_ERROR(RPC_X_WRONG_PIPE_VERSION),
    MAKE_ERROR(RPC_X_WRONG_STUB_VERSION),
    MAKE_ERROR(SPAPI_E_BAD_INTERFACE_INSTALLSECT),
    MAKE_ERROR(SPAPI_E_BAD_SECTION_NAME_LINE),
    MAKE_ERROR(SPAPI_E_BAD_SERVICE_INSTALLSECT),
    MAKE_ERROR(SPAPI_E_CANT_LOAD_CLASS_ICON),
    MAKE_ERROR(SPAPI_E_CLASS_MISMATCH),
    MAKE_ERROR(SPAPI_E_DEVICE_INTERFACE_ACTIVE),
    MAKE_ERROR(SPAPI_E_DEVICE_INTERFACE_REMOVED),
    MAKE_ERROR(SPAPI_E_DEVINFO_DATA_LOCKED),
    MAKE_ERROR(SPAPI_E_DEVINFO_LIST_LOCKED),
    MAKE_ERROR(SPAPI_E_DEVINFO_NOT_REGISTERED),
    MAKE_ERROR(SPAPI_E_DEVINST_ALREADY_EXISTS),
    MAKE_ERROR(SPAPI_E_DI_BAD_PATH),
    MAKE_ERROR(SPAPI_E_DI_DONT_INSTALL),
    MAKE_ERROR(SPAPI_E_DI_DO_DEFAULT),
    MAKE_ERROR(SPAPI_E_DI_NOFILECOPY),
    MAKE_ERROR(SPAPI_E_DI_POSTPROCESSING_REQUIRED),
    MAKE_ERROR(SPAPI_E_DUPLICATE_FOUND),
    MAKE_ERROR(SPAPI_E_ERROR_NOT_INSTALLED),
    MAKE_ERROR(SPAPI_E_EXPECTED_SECTION_NAME),
    MAKE_ERROR(SPAPI_E_FILEQUEUE_LOCKED),
    MAKE_ERROR(SPAPI_E_GENERAL_SYNTAX),
    MAKE_ERROR(SPAPI_E_INVALID_CLASS),
    MAKE_ERROR(SPAPI_E_INVALID_CLASS_INSTALLER),
    MAKE_ERROR(SPAPI_E_INVALID_COINSTALLER),
    MAKE_ERROR(SPAPI_E_INVALID_DEVINST_NAME),
    MAKE_ERROR(SPAPI_E_INVALID_FILTER_DRIVER),
    MAKE_ERROR(SPAPI_E_INVALID_HWPROFILE),
    MAKE_ERROR(SPAPI_E_INVALID_INF_LOGCONFIG),
    MAKE_ERROR(SPAPI_E_INVALID_MACHINENAME),
    MAKE_ERROR(SPAPI_E_INVALID_PROPPAGE_PROVIDER),
    MAKE_ERROR(SPAPI_E_INVALID_REFERENCE_STRING),
    MAKE_ERROR(SPAPI_E_INVALID_REG_PROPERTY),
    MAKE_ERROR(SPAPI_E_KEY_DOES_NOT_EXIST),
    MAKE_ERROR(SPAPI_E_LINE_NOT_FOUND),
    MAKE_ERROR(SPAPI_E_MACHINE_UNAVAILABLE),
    MAKE_ERROR(SPAPI_E_NO_ASSOCIATED_CLASS),
    MAKE_ERROR(SPAPI_E_NO_ASSOCIATED_SERVICE),
    MAKE_ERROR(SPAPI_E_NO_CLASSINSTALL_PARAMS),
    MAKE_ERROR(SPAPI_E_NO_CLASS_DRIVER_LIST),
    MAKE_ERROR(SPAPI_E_NO_COMPAT_DRIVERS),
    MAKE_ERROR(SPAPI_E_NO_CONFIGMGR_SERVICES),
    MAKE_ERROR(SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE),
    MAKE_ERROR(SPAPI_E_NO_DEVICE_ICON),
    MAKE_ERROR(SPAPI_E_NO_DEVICE_SELECTED),
    MAKE_ERROR(SPAPI_E_NO_DRIVER_SELECTED),
    MAKE_ERROR(SPAPI_E_NO_INF),
    MAKE_ERROR(SPAPI_E_NO_SUCH_DEVICE_INTERFACE),
    MAKE_ERROR(SPAPI_E_NO_SUCH_DEVINST),
    MAKE_ERROR(SPAPI_E_NO_SUCH_INTERFACE_CLASS),
    MAKE_ERROR(SPAPI_E_REMOTE_COMM_FAILURE),
    MAKE_ERROR(SPAPI_E_SECTION_NAME_TOO_LONG),
    MAKE_ERROR(SPAPI_E_SECTION_NOT_FOUND),
    MAKE_ERROR(SPAPI_E_WRONG_INF_STYLE),
    MAKE_ERROR(STG_E_ABNORMALAPIEXIT),
    MAKE_ERROR(STG_E_ACCESSDENIED),
    MAKE_ERROR(STG_E_BADBASEADDRESS),
    MAKE_ERROR(STG_E_CANTSAVE),
    MAKE_ERROR(STG_E_DISKISWRITEPROTECTED),
    MAKE_ERROR(STG_E_DOCFILECORRUPT),
    MAKE_ERROR(STG_E_EXTANTMARSHALLINGS),
    MAKE_ERROR(STG_E_FILEALREADYEXISTS),
    MAKE_ERROR(STG_E_FILENOTFOUND),
    MAKE_ERROR(STG_E_INCOMPLETE),
    MAKE_ERROR(STG_E_INSUFFICIENTMEMORY),
    MAKE_ERROR(STG_E_INUSE),
    MAKE_ERROR(STG_E_INVALIDFLAG),
    MAKE_ERROR(STG_E_INVALIDFUNCTION),
    MAKE_ERROR(STG_E_INVALIDHANDLE),
    MAKE_ERROR(STG_E_INVALIDHEADER),
    MAKE_ERROR(STG_E_INVALIDNAME),
    MAKE_ERROR(STG_E_INVALIDPARAMETER),
    MAKE_ERROR(STG_E_INVALIDPOINTER),
    MAKE_ERROR(STG_E_LOCKVIOLATION),
    MAKE_ERROR(STG_E_MEDIUMFULL),
    MAKE_ERROR(STG_E_NOMOREFILES),
    MAKE_ERROR(STG_E_NOTCURRENT),
    MAKE_ERROR(STG_E_NOTFILEBASEDSTORAGE),
    MAKE_ERROR(STG_E_OLDDLL),
    MAKE_ERROR(STG_E_OLDFORMAT),
    MAKE_ERROR(STG_E_PATHNOTFOUND),
    MAKE_ERROR(STG_E_PROPSETMISMATCHED),
    MAKE_ERROR(STG_E_READFAULT),
    MAKE_ERROR(STG_E_REVERTED),
    MAKE_ERROR(STG_E_SEEKERROR),
    MAKE_ERROR(STG_E_SHAREREQUIRED),
    MAKE_ERROR(STG_E_SHAREVIOLATION),
    MAKE_ERROR(STG_E_TERMINATED),
    MAKE_ERROR(STG_E_TOOMANYOPENFILES),
    MAKE_ERROR(STG_E_UNIMPLEMENTEDFUNCTION),
    MAKE_ERROR(STG_E_UNKNOWN),
    MAKE_ERROR(STG_E_WRITEFAULT),
    MAKE_ERROR(STG_S_BLOCK),
    MAKE_ERROR(STG_S_CANNOTCONSOLIDATE),
    MAKE_ERROR(STG_S_CONSOLIDATIONFAILED),
    MAKE_ERROR(STG_S_CONVERTED),
    MAKE_ERROR(STG_S_MONITORING),
    MAKE_ERROR(STG_S_MULTIPLEOPENS),
    MAKE_ERROR(STG_S_RETRYNOW),
    MAKE_ERROR(S_FALSE),
    MAKE_ERROR(S_OK),
    MAKE_ERROR(TRUST_E_ACTION_UNKNOWN),
    MAKE_ERROR(TRUST_E_BAD_DIGEST),
    MAKE_ERROR(TRUST_E_BASIC_CONSTRAINTS),
    MAKE_ERROR(TRUST_E_CERT_SIGNATURE),
    MAKE_ERROR(TRUST_E_COUNTER_SIGNER),
    MAKE_ERROR(TRUST_E_FAIL),
    MAKE_ERROR(TRUST_E_FINANCIAL_CRITERIA),
    MAKE_ERROR(TRUST_E_NOSIGNATURE),
    MAKE_ERROR(TRUST_E_NO_SIGNER_CERT),
    MAKE_ERROR(TRUST_E_PROVIDER_UNKNOWN),
    MAKE_ERROR(TRUST_E_SUBJECT_FORM_UNKNOWN),
    MAKE_ERROR(TRUST_E_SUBJECT_NOT_TRUSTED),
    MAKE_ERROR(TRUST_E_SYSTEM_ERROR),
    MAKE_ERROR(TRUST_E_TIME_STAMP),
    MAKE_ERROR(TYPE_E_AMBIGUOUSNAME),
    MAKE_ERROR(TYPE_E_BADMODULEKIND),
    MAKE_ERROR(TYPE_E_BUFFERTOOSMALL),
    MAKE_ERROR(TYPE_E_CANTCREATETMPFILE),
    MAKE_ERROR(TYPE_E_CANTLOADLIBRARY),
    MAKE_ERROR(TYPE_E_CIRCULARTYPE),
    MAKE_ERROR(TYPE_E_DLLFUNCTIONNOTFOUND),
    MAKE_ERROR(TYPE_E_DUPLICATEID),
    MAKE_ERROR(TYPE_E_ELEMENTNOTFOUND),
    MAKE_ERROR(TYPE_E_FIELDNOTFOUND),
    MAKE_ERROR(TYPE_E_INCONSISTENTPROPFUNCS),
    MAKE_ERROR(TYPE_E_INVALIDID),
    MAKE_ERROR(TYPE_E_INVALIDSTATE),
    MAKE_ERROR(TYPE_E_INVDATAREAD),
    MAKE_ERROR(TYPE_E_IOERROR),
    MAKE_ERROR(TYPE_E_LIBNOTREGISTERED),
    MAKE_ERROR(TYPE_E_NAMECONFLICT),
    MAKE_ERROR(TYPE_E_OUTOFBOUNDS),
    MAKE_ERROR(TYPE_E_QUALIFIEDNAMEDISALLOWED),
    MAKE_ERROR(TYPE_E_REGISTRYACCESS),
    MAKE_ERROR(TYPE_E_SIZETOOBIG),
    MAKE_ERROR(TYPE_E_TYPEMISMATCH),
    MAKE_ERROR(TYPE_E_UNDEFINEDTYPE),
    MAKE_ERROR(TYPE_E_UNKNOWNLCID),
    MAKE_ERROR(TYPE_E_UNSUPFORMAT),
    MAKE_ERROR(TYPE_E_WRONGTYPEKIND),
    MAKE_ERROR(VIEW_E_DRAW),
    MAKE_ERROR(WIA_ERROR_GENERAL_ERROR),
    MAKE_ERROR(WIA_ERROR_PAPER_JAM),
    MAKE_ERROR(WIA_ERROR_PAPER_EMPTY),
    MAKE_ERROR(WIA_ERROR_PAPER_PROBLEM),
    MAKE_ERROR(WIA_ERROR_OFFLINE),
    MAKE_ERROR(WIA_ERROR_BUSY),
    MAKE_ERROR(WIA_ERROR_WARMING_UP),
    MAKE_ERROR(WIA_ERROR_USER_INTERVENTION),
    MAKE_ERROR(WIA_ERROR_ITEM_DELETED),
    MAKE_ERROR(WIA_ERROR_DEVICE_COMMUNICATION),
    MAKE_ERROR(WIA_ERROR_INVALID_COMMAND),
    MAKE_ERROR(WIA_ERROR_INCORRECT_HARDWARE_SETTING),
    MAKE_ERROR(WIA_ERROR_DEVICE_LOCKED),
    MAKE_ERROR(WIA_ERROR_EXCEPTION_IN_DRIVER),
    MAKE_ERROR(WIA_ERROR_INVALID_DRIVER_RESPONSE),
    MAKE_ERROR(WIA_STATUS_END_OF_MEDIA),
    MAKE_ERROR(WIA_S_NO_DEVICE_AVAILABLE),
};
const int g_ErrorMessageCount = sizeof(g_ErrorMessages)/sizeof(g_ErrorMessages[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\prevtest\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

#
# include the WIA global build settings
#


USE_SHFUSION = 1

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

TARGETNAME=prevtest
TARGETTYPE=PROGRAM
TARGETPATH=obj

USE_MSVCRT = 1

INCLUDES=\
        $(INCLUDES);                                                    \
        $(PROJECT_ROOT)\ui\prevwnd

SOURCES=\
        ..\prevtest.cpp                                                 \
        ..\prevtest.rc                                                  \


TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                                  \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\prevwnd.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\prevtest\prevtest.cpp ===
#include <windows.h>
#include <commctrl.h>
#include <shfusion.h>
#include <commdlg.h>
#include "uicommon.h"
#include "simcrack.h"
#include "pviewids.h"
#include "resource.h"

HINSTANCE g_hInstance;

class CGetXYDlg
{
public:
    class CData
    {
    private:
        TCHAR m_szTitle[MAX_PATH];
        int m_nX, m_nY;

    private:
        CData( const CData & );
        CData &operator=( const CData & );

    public:
        CData(void)
        : m_nX(0), m_nY(0)
        {
            m_szTitle[0] = TEXT('\0');
        }
        void Title( LPCTSTR pszTitle )
        {
            if (pszTitle)
                lstrcpyn( m_szTitle, pszTitle, ARRAYSIZE(m_szTitle) );
        }
        LPCTSTR Title(void) const
        {
            return m_szTitle;
        }
        void X( int nX )
        {
            m_nX = nX;
        }
        void Y( int nY )
        {
            m_nY = nY;
        }
        int X( void ) const
        {
            return m_nX;
        }
        int Y( void ) const
        {
            return m_nY;
        }
    };
private:
    HWND m_hWnd;
    CData *m_pData;

private:
    CGetXYDlg(void);
    CGetXYDlg( const CGetXYDlg & );
    CGetXYDlg &operator=( const CGetXYDlg & );
private:
    explicit CGetXYDlg( HWND hWnd )
    : m_hWnd(hWnd),
      m_pData(NULL)
    {
    }
    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (!m_pData)
        {
            EndDialog( m_hWnd, IDCANCEL );
            return 0;
        }
        if (lstrlen(m_pData->Title()))
            SetWindowText(m_hWnd,m_pData->Title());
        SetDlgItemInt( m_hWnd, IDC_X, m_pData->X(), TRUE );
        SetDlgItemInt( m_hWnd, IDC_Y, m_pData->Y(), TRUE );
        return 0;
    }
    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        m_pData->X(GetDlgItemInt( m_hWnd, IDC_X, NULL, TRUE ));
        m_pData->Y(GetDlgItemInt( m_hWnd, IDC_Y, NULL, TRUE ));
        EndDialog( m_hWnd, IDOK );
    }
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
       }
       SC_END_COMMAND_HANDLERS();
    }
public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CGetXYDlg)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};

class CPreviewDlg
{
private:
    HWND m_hWnd;
    HWND m_hWndPreview;
    SIZE m_sizeResolution;
public:
    CPreviewDlg( HWND hWnd )
    : m_hWnd(hWnd),m_hWndPreview(NULL)
    {
        m_sizeResolution.cx = 1000;
        m_sizeResolution.cy = 1000;
    }
    ~CPreviewDlg(void)
    {
    }
    void OnPreviewSelChange( WPARAM, LPARAM )
    {
        POINT ptOriginLogical, ptOriginPhysical;
        SIZE  sizeExtentLogical, sizeExtentPhysical;
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 0, &ptOriginLogical );
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 1, &ptOriginPhysical );
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 0, &sizeExtentLogical );
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 1, &sizeExtentPhysical );
        SetWindowText( m_hWndPreview, TEXT("This is the window caption") );

        TCHAR szStr[MAX_PATH];
        wsprintf( szStr, TEXT("Log: (%d,%d), Phys: (%d,%d)"), sizeExtentLogical.cx, sizeExtentLogical.cy, sizeExtentPhysical.cx, sizeExtentPhysical.cy );
        SendDlgItemMessage( m_hWnd, IDC_EXTENT, WM_SETTEXT, 0, (LPARAM)szStr );
        wsprintf( szStr, TEXT("Log: (%d,%d), Phys: (%d,%d)"), ptOriginLogical.x, ptOriginLogical.y, ptOriginPhysical.x, ptOriginPhysical.y );
        SendDlgItemMessage( m_hWnd, IDC_ORIGIN, WM_SETTEXT, 0, (LPARAM)szStr );

    }
    LRESULT OnSize( WPARAM, LPARAM lParam )
    {
        RECT rcPreview;
        GetWindowRect( m_hWndPreview, &rcPreview );
        WiaUiUtil::ScreenToClient( m_hWnd, &rcPreview );
        MoveWindow( m_hWndPreview, rcPreview.left, rcPreview.top, LOWORD(lParam)-rcPreview.left-rcPreview.top, HIWORD(lParam)-rcPreview.top-rcPreview.top, TRUE );
        return 0;
    }
    void Update(void)
    {
        TCHAR szMsg[256];
        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetBorderSize( m_hWndPreview, FALSE ) );
        SendDlgItemMessage( m_hWnd, IDC_BORDERTEXT, WM_SETTEXT, 0, (LPARAM)szMsg );

        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetHandleSize( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLESTEXT, WM_SETTEXT, 0, (LPARAM)szMsg );

        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetBgAlpha( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUETEXT, WM_SETTEXT, 0, (LPARAM)szMsg );
    }
    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        m_hWndPreview = GetDlgItem( m_hWnd, IDC_PREVIEW );
        SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_SETRANGE, TRUE, MAKELPARAM(0,25) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_SETRANGE, TRUE, MAKELPARAM(0,25) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_SETRANGE, TRUE, MAKELPARAM(0,255) );
        SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_SETPOS, TRUE, WiaPreviewControl_GetBorderSize( m_hWndPreview, FALSE ) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_SETPOS, TRUE, WiaPreviewControl_GetHandleSize( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_SETPOS, TRUE, WiaPreviewControl_GetBgAlpha( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_NOIMAGE, BM_SETCHECK, BST_CHECKED, 0 );

        WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );

        PostMessage( m_hWnd, WM_COMMAND, MAKEWPARAM( IDC_PREVIEW, PWN_SELCHANGE ), 0 );

        Update();

        return 0;
    }
    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, 0 );
    }

    void OnBitmapChange( WPARAM wParam, LPARAM )
    {
        HBITMAP hBitmap = NULL;
        switch (LOWORD(wParam))
        {
        case IDC_BW:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_BW), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        case IDC_GRAY:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_GRAY), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        case IDC_COLOR:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_COLOR), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        }
        WiaPreviewControl_SetBitmap( m_hWndPreview, TRUE, FALSE, hBitmap );
    }

    LRESULT OnScroll( WPARAM, LPARAM lParam )
    {
        if (GetDlgItem(m_hWnd,IDC_BORDER)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetBorderSize( m_hWndPreview, TRUE, FALSE, nSetting );
            WiaPreviewControl_ClearSelection( m_hWndPreview );
        }
        if (GetDlgItem(m_hWnd,IDC_SIZINGHANDLES)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetHandleSize( m_hWndPreview, TRUE, nSetting );
        }
        if (GetDlgItem(m_hWnd,IDC_ALPHAVALUE)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetBgAlpha( m_hWndPreview, TRUE, static_cast<BYTE>(nSetting) );
        }
        Update();
        return 0;
    }
    void OnDisabled( WPARAM, LPARAM )
    {
        EnableWindow( m_hWndPreview, BST_CHECKED!=SendDlgItemMessage( m_hWnd, IDC_DISABLED, BM_GETCHECK, 0, 0 ) );
    }
    void OnHandleStyle( WPARAM, LPARAM )
    {
        bool bRoundButtons = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_ROUNDHANDLES, BM_GETCHECK, 0, 0 ));
        bool bHollowHandle = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_HOLLOWHANDLE, BM_GETCHECK, 0, 0 ));

        UINT nStyle = 0;
        if (bRoundButtons)
            nStyle |= PREVIEW_WINDOW_ROUNDHANDLES;
        else nStyle |= PREVIEW_WINDOW_SQUAREHANDLES;

        if (bHollowHandle)
            nStyle |= PREVIEW_WINDOW_HOLLOWHANDLES;
        else nStyle |= PREVIEW_WINDOW_FILLEDHANDLES;

        WiaPreviewControl_SetHandleType( m_hWndPreview, TRUE, nStyle );
    }
    void OnPreviewMode( WPARAM, LPARAM )
    {
        bool bPreviewMode = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_PREVIEWMODE, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_SetPreviewMode( m_hWndPreview, bPreviewMode != FALSE );
    }
    void OnNullSelection( WPARAM, LPARAM )
    {
        bool bNullSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_NULLSELECTION, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_AllowNullSelection( m_hWndPreview, bNullSelection != FALSE );
    }
    void OnDisableSelection( WPARAM, LPARAM )
    {
        bool bDisableSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_DISABLESELECTION, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_DisableSelection( m_hWndPreview, bDisableSelection != FALSE );
    }
    void OnSolidSelection( WPARAM, LPARAM )
    {
        bool bSolidSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_SOLIDSELECTION, BM_GETCHECK, 0, 0 ));
        bool bDoubleWidth = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_DOUBLEWIDTH, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_SetBorderStyle( m_hWndPreview, TRUE, bSolidSelection ? PS_SOLID : PS_DOT, bDoubleWidth ? 2 : 0 );
    }
    BOOL GetColor( COLORREF &cr )
    {
        static COLORREF crCustom[16];
        CHOOSECOLOR cc;
        ZeroMemory(&cc,sizeof(cc));
        ZeroMemory(&crCustom,sizeof(crCustom));
        cc.lStructSize = sizeof(cc);
        cc.hwndOwner = m_hWnd;
        cc.rgbResult = cr;
        cc.lpCustColors = crCustom;
        cc.Flags = CC_ANYCOLOR|CC_RGBINIT;
        if (ChooseColor(&cc))
        {
            cr = cc.rgbResult;
            return TRUE;
        }
        return FALSE;
    }
    void OnSelectedBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_SELECTED, cr );
        }
    }
    void OnUnselectedBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_UNSELECTED, cr );
        }
    }
    void OnDisableBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_DISABLED, cr );
        }
    }
    void OnSelectedHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_SELECTED, cr );
        }
    }
    void OnUnselectedHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_UNSELECTED, cr );
        }
    }
    void OnDisableHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_DISABLED, cr );
        }
    }
    void OnInnerColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBkColor( m_hWndPreview, TRUE, FALSE, cr );
        }
    }
    void OnOuterColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBkColor( m_hWndPreview, TRUE, TRUE, cr );
        }
    }
    void OnSetOrigin( WPARAM, LPARAM )
    {
        CSimpleString strTitle;
        POINT ptOrigin;
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 0, &ptOrigin );
        strTitle.Format( TEXT("Enter Origin - Current Res: (%d,%d):"), m_sizeResolution.cx, m_sizeResolution.cy );
        CGetXYDlg::CData data;
        data.Title(strTitle);
        data.X( ptOrigin.x );
        data.Y( ptOrigin.y );
        INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_GETXYDLG), m_hWnd, CGetXYDlg::DialogProc, reinterpret_cast<LPARAM>(&data) );
        if (IDOK == nResult)
        {
            ptOrigin.x = data.X();
            ptOrigin.y = data.Y();
            WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );
            WiaPreviewControl_SetSelOrigin( m_hWndPreview, 0, 0, &ptOrigin );
        }
    }
    void OnSetExtent( WPARAM, LPARAM )
    {
        CSimpleString strTitle;
        SIZE sizeExtent;
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 0, &sizeExtent );
        strTitle.Format( TEXT("Enter Extent - Current Res: (%d,%d):"), m_sizeResolution.cx, m_sizeResolution.cy );
        CGetXYDlg::CData data;
        data.Title(strTitle);
        data.X( sizeExtent.cx );
        data.Y( sizeExtent.cy );
        INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_GETXYDLG), m_hWnd, CGetXYDlg::DialogProc, reinterpret_cast<LPARAM>(&data) );
        if (IDOK == nResult)
        {
            sizeExtent.cx = data.X();
            sizeExtent.cy = data.Y();
            WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );
            WiaPreviewControl_SetSelExtent( m_hWndPreview, 0, 0, &sizeExtent );
        }
    }
    void OnSetProgress( WPARAM, LPARAM )
    {
        WiaPreviewControl_SetProgress(m_hWndPreview,!WiaPreviewControl_GetProgress(m_hWndPreview));
    }
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND( IDC_PREVIEW, OnPreviewSelChange );
            SC_HANDLE_COMMAND( IDCANCEL, OnCancel );
            SC_HANDLE_COMMAND( IDC_BW, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_GRAY, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_COLOR, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_NOIMAGE, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_DISABLED, OnDisabled );
            SC_HANDLE_COMMAND( IDC_ROUNDHANDLES, OnHandleStyle );
            SC_HANDLE_COMMAND( IDC_HOLLOWHANDLE, OnHandleStyle );
            SC_HANDLE_COMMAND( IDC_PREVIEWMODE, OnPreviewMode );
            SC_HANDLE_COMMAND( IDC_NULLSELECTION, OnNullSelection );
            SC_HANDLE_COMMAND( IDC_DISABLESELECTION, OnDisableSelection );
            SC_HANDLE_COMMAND( IDC_INNERCOLOR, OnInnerColor );
            SC_HANDLE_COMMAND( IDC_OUTERCOLOR, OnOuterColor );
            SC_HANDLE_COMMAND( IDC_SOLIDSELECTION, OnSolidSelection );
            SC_HANDLE_COMMAND( IDC_DOUBLEWIDTH, OnSolidSelection );
            SC_HANDLE_COMMAND( IDC_SELECTEDBORDERCOLOR, OnSelectedBorderColor );
            SC_HANDLE_COMMAND( IDC_UNSELECTEDBORDERCOLOR, OnUnselectedBorderColor );
            SC_HANDLE_COMMAND( IDC_DISABLEBORDERCOLOR, OnDisableBorderColor );
            SC_HANDLE_COMMAND( IDC_SELECTEDHANDLECOLOR, OnSelectedHandleColor );
            SC_HANDLE_COMMAND( IDC_UNSELECTEDHANDLECOLOR, OnUnselectedHandleColor );
            SC_HANDLE_COMMAND( IDC_DISABLEHANDLECOLOR, OnDisableHandleColor );
            SC_HANDLE_COMMAND( IDC_SETORIGIN, OnSetOrigin );
            SC_HANDLE_COMMAND( IDC_SETEXTENT, OnSetExtent );
            SC_HANDLE_COMMAND( IDC_SETPROGRESS, OnSetProgress );
        }
        SC_END_COMMAND_HANDLERS();
    }

    LRESULT OnEnterSizeMove( WPARAM, LPARAM )
    {
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_ENTERSIZEMOVE, 0, 0 );
        return 0;
    }

    LRESULT OnExitSizeMove( WPARAM, LPARAM )
    {
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_EXITSIZEMOVE, 0, 0 );
        return 0;
    }

    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CPreviewDlg)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_DIALOG_MESSAGE( WM_HSCROLL, OnScroll );
            SC_HANDLE_DIALOG_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
            SC_HANDLE_DIALOG_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    SHFusionInitialize(NULL);
    InitCommonControls();
    RegisterWiaPreviewClasses( g_hInstance );
    if (-1==DialogBoxParam( hInstance, MAKEINTRESOURCE(IDD_TESTDLG), NULL, CPreviewDlg::DialogProc, NULL ))
    {
        DWORD dwError = GetLastError();
    }
    SHFusionUninitialize();
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\rotimg\rotimg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include "gdiplus.h"
#include <shlwapi.h>
#include <initguid.h>
//#include <shlwapip.h>
using namespace Gdiplus;
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);    // speed up PathMatchSpec calls
        
    // look at the list of decoders to see if this format is there
    for (UINT i = 0; i < cDecoders; i++)
    {
        if (PathMatchSpec(pszExt, pici[i].FilenameExtension))
            return i;
    }
    return (UINT)-1;    // not found!
}

class CEncoderInfo
{
public:
    Status GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt);
    Status GetEncoderList();
    Status GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder);
    CEncoderInfo();
    ~CEncoderInfo();

private:
    UINT _cEncoders;                    // number of encoders discovered
    ImageCodecInfo *_pici;              // array of image encoder classes
};


CEncoderInfo::CEncoderInfo()
{
    _cEncoders = 0;
    _pici = NULL;
}

CEncoderInfo::~CEncoderInfo()
{
    LocalFree (_pici);
}
Status CEncoderInfo::GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    *pguidFmt = GUID_NULL;

    Status s = GetEncoderList();
    if (Ok == s)
    {
        UINT i = FindInDecoderList(_pici, _cEncoders, pszPath);
        if (-1 != i)
        {
            *pguidFmt = _pici[i].FormatID;            
        }
        else
        {
            s = GenericError;
        }
    }
    return s;
}

Status CEncoderInfo::GetEncoderList()
{
    Status s = Ok;
    if (!_pici)
    {
        // lets pick up the list of encoders, first we get the encoder size which
        // gives us the CB and the number of encoders that are installed on the
        // machine.

        UINT cb;
        s = GetImageEncodersSize(&_cEncoders, &cb);
        if (Ok == s)
        {
            // allocate the buffer for the encoders and then fill it
            // with the encoder list.

            _pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
            if (_pici)
            {
                s = GetImageEncoders(_cEncoders, cb, _pici);
                if (Ok != s)
                {
                    LocalFree(_pici);
                    _pici = NULL;
                }
            }
            else
            {
                s = OutOfMemory;
            }
        }
    }
    return s;
}


Status CEncoderInfo::GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    Status s = GetEncoderList();
    if (Ok == s)
    {
        s = GenericError;
        for (UINT i = 0; i != _cEncoders; i++)
        {
            if (_pici[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = _pici[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                s = Ok;
                break;
            }
        }
    }
    return s;
}

void AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}

class CGraphicsInit
{
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        GdiplusStartupInput gsi;
        GdiplusStartupOutput gso;
        GdiplusStartup(&_token, &gsi, &gso);
    };
    ~CGraphicsInit()
    {
        GdiplusShutdown(_token);
    };

};



int __cdecl wmain(int argc, LPCWSTR argv[])
{
    if (argc < 2)
    {
        printf("Usage: rotimg <filename> <targetfile>\n");       
    }
    else
    {
        CGraphicsInit cgi;
        LPCWSTR szSrc = argv[1];
        LPCWSTR szSave = argc > 2 ? argv[2] : argv[1];
        Status s;
        printf("Source image: %ls, Target image: %ls\n", szSrc, szSave);
        Image *pimg = new Image(szSrc, TRUE);
        s = pimg->GetLastStatus();
        if (Ok != s)
        {
            printf("Error %d constructing Image\n", s);
        }
        UINT nPages = pimg->GetFrameCount(&FrameDimensionPage);
        Image *pimgWork = pimg->Clone();
        
        
        s = pimgWork->RotateFlip(Rotate90FlipNone);
        if (Ok != s)
        {
            printf("RotateFlip returned %d\n", s);
        }
        else
        {
            IStream *pstrm;
            SHCreateStreamOnFileEx(szSave, STGM_WRITE | STGM_CREATE, 0, TRUE, NULL, &pstrm);

            CEncoderInfo cei;
            GUID guidFmt;
            CLSID clsidEncoder;
            cei.GetDataFormatFromPath(szSave, &guidFmt);
            cei.GetEncoderFromFormat(&guidFmt, &clsidEncoder);
            EncoderParameters ep[1] = {0};
            ULONG flagValueMulti = nPages > 1 ? EncoderValueMultiFrame : EncoderValueLastFrame;
            AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueMulti);
            pimgWork->SelectActiveFrame(&FrameDimensionPage, 0);
            s = pimgWork->Save(pstrm,&clsidEncoder, ep);
            printf("first Save returned %d\n", s);
            if (Ok == s && nPages > 1)
            {
                EncoderParameters ep[2] = {0};
                ULONG flagValueDim = EncoderValueFrameDimensionPage;
                ULONG flagValueLastFrame = EncoderValueLastFrame;
                pimg->SelectActiveFrame(&FrameDimensionPage, 1);
                AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueDim);
                AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueLastFrame);
                s = pimgWork->SaveAdd(pimg, ep);
                printf("SaveAdd returned %d\n", s);
            }
            pstrm->Release();
        }
        delete pimg;
        delete pimgWork;
    }
    printf("Rotimg complete\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\tagdump\tagdump.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <gdiplus.h>

struct CStringEntry
{
    ULONG       nId;
    const wchar_t *pszString;
};

#define MKFLAG(x) { (x), L#x }

const wchar_t *GetStringFromTable( const CStringEntry *pStrings, UINT nSize, ULONG nId, wchar_t *pszUnknownBuffer )
{
    for (UINT i=0;i<nSize;i++)
    {
        if (pStrings[i].nId == nId)
        {
            return pStrings[i].pszString;
        }
    }
    wsprintfW( pszUnknownBuffer, L"Unknown value: %d (0x%X)", nId, nId );
    return pszUnknownBuffer;
}

void DumpImageProperty( Gdiplus::PropertyItem* pPropertyItem )
{
    static CStringEntry s_PropertyTypes[] =
    {
        MKFLAG(PropertyTagTypeByte),
        MKFLAG(PropertyTagTypeASCII),
        MKFLAG(PropertyTagTypeShort),
        MKFLAG(PropertyTagTypeLong),
        MKFLAG(PropertyTagTypeRational),
        MKFLAG(PropertyTagTypeUndefined),
        MKFLAG(PropertyTagTypeSLONG),
        MKFLAG(PropertyTagTypeSRational)
    };
    
    static CStringEntry s_PropertyIds[] =
    {
        MKFLAG(PropertyTagArtist),
        MKFLAG(PropertyTagBitsPerSample),
        MKFLAG(PropertyTagCellHeight),
        MKFLAG(PropertyTagCellWidth),
        MKFLAG(PropertyTagChrominanceTable),
        MKFLAG(PropertyTagColorMap),
        MKFLAG(PropertyTagColorTransferFunction),
        MKFLAG(PropertyTagCompression),
        MKFLAG(PropertyTagCopyright),
        MKFLAG(PropertyTagDateTime),
        MKFLAG(PropertyTagDocumentName),
        MKFLAG(PropertyTagDotRange),
        MKFLAG(PropertyTagEquipMake),
        MKFLAG(PropertyTagEquipModel),
        MKFLAG(PropertyTagExifAperture),
        MKFLAG(PropertyTagExifBrightness),
        MKFLAG(PropertyTagExifCfaPattern),
        MKFLAG(PropertyTagExifColorSpace),
        MKFLAG(PropertyTagExifCompBPP),
        MKFLAG(PropertyTagExifCompConfig),
        MKFLAG(PropertyTagExifDTDigSS),
        MKFLAG(PropertyTagExifDTDigitized),
        MKFLAG(PropertyTagExifDTOrig),
        MKFLAG(PropertyTagExifDTOrigSS),
        MKFLAG(PropertyTagExifDTSubsec),
        MKFLAG(PropertyTagExifExposureBias),
        MKFLAG(PropertyTagExifExposureIndex),
        MKFLAG(PropertyTagExifExposureProg),
        MKFLAG(PropertyTagExifExposureTime),
        MKFLAG(PropertyTagExifFNumber),
        MKFLAG(PropertyTagExifFPXVer),
        MKFLAG(PropertyTagExifFileSource),
        MKFLAG(PropertyTagExifFlash),
        MKFLAG(PropertyTagExifFlashEnergy),
        MKFLAG(PropertyTagExifFocalLength),
        MKFLAG(PropertyTagExifFocalResUnit),
        MKFLAG(PropertyTagExifFocalXRes),
        MKFLAG(PropertyTagExifFocalYRes),
        MKFLAG(PropertyTagExifIFD),
        MKFLAG(PropertyTagExifISOSpeed),
        MKFLAG(PropertyTagExifInterop),
        MKFLAG(PropertyTagExifLightSource),
        MKFLAG(PropertyTagExifMakerNote),
        MKFLAG(PropertyTagExifMaxAperture),
        MKFLAG(PropertyTagExifMeteringMode),
        MKFLAG(PropertyTagExifOECF),
        MKFLAG(PropertyTagExifPixXDim),
        MKFLAG(PropertyTagExifPixYDim),
        MKFLAG(PropertyTagExifRelatedWav),
        MKFLAG(PropertyTagExifSceneType),
        MKFLAG(PropertyTagExifSensingMethod),
        MKFLAG(PropertyTagExifShutterSpeed),
        MKFLAG(PropertyTagExifSpatialFR),
        MKFLAG(PropertyTagExifSpectralSense),
        MKFLAG(PropertyTagExifSubjectDist),
        MKFLAG(PropertyTagExifSubjectLoc),
        MKFLAG(PropertyTagExifUserComment),
        MKFLAG(PropertyTagExifVer),
        MKFLAG(PropertyTagExtraSamples),
        MKFLAG(PropertyTagFillOrder),
        MKFLAG(PropertyTagFrameDelay),
        MKFLAG(PropertyTagFreeByteCounts),
        MKFLAG(PropertyTagFreeOffset),
        MKFLAG(PropertyTagGamma),
        MKFLAG(PropertyTagGpsAltitude),
        MKFLAG(PropertyTagGpsAltitudeRef),
        MKFLAG(PropertyTagGpsDestBear),
        MKFLAG(PropertyTagGpsDestBearRef),
        MKFLAG(PropertyTagGpsDestDist),
        MKFLAG(PropertyTagGpsDestDistRef),
        MKFLAG(PropertyTagGpsDestLat),
        MKFLAG(PropertyTagGpsDestLatRef),
        MKFLAG(PropertyTagGpsDestLong),
        MKFLAG(PropertyTagGpsDestLongRef),
        MKFLAG(PropertyTagGpsGpsDop),
        MKFLAG(PropertyTagGpsGpsMeasureMode),
        MKFLAG(PropertyTagGpsGpsSatellites),
        MKFLAG(PropertyTagGpsGpsStatus),
        MKFLAG(PropertyTagGpsGpsTime),
        MKFLAG(PropertyTagGpsIFD),
        MKFLAG(PropertyTagGpsImgDir),
        MKFLAG(PropertyTagGpsImgDirRef),
        MKFLAG(PropertyTagGpsLatitude),
        MKFLAG(PropertyTagGpsLatitudeRef),
        MKFLAG(PropertyTagGpsLongitude),
        MKFLAG(PropertyTagGpsLongitudeRef),
        MKFLAG(PropertyTagGpsMapDatum),
        MKFLAG(PropertyTagGpsSpeed),
        MKFLAG(PropertyTagGpsSpeedRef),
        MKFLAG(PropertyTagGpsTrack),
        MKFLAG(PropertyTagGpsTrackRef),
        MKFLAG(PropertyTagGpsVer),
        MKFLAG(PropertyTagGrayResponseCurve),
        MKFLAG(PropertyTagGrayResponseUnit),
        MKFLAG(PropertyTagGridSize),
        MKFLAG(PropertyTagHalftoneDegree),
        MKFLAG(PropertyTagHalftoneHints),
        MKFLAG(PropertyTagHalftoneLPI),
        MKFLAG(PropertyTagHalftoneLPIUnit),
        MKFLAG(PropertyTagHalftoneMisc),
        MKFLAG(PropertyTagHalftoneScreen),
        MKFLAG(PropertyTagHalftoneShape),
        MKFLAG(PropertyTagHostComputer),
        MKFLAG(PropertyTagICCProfile),
        MKFLAG(PropertyTagICCProfileDescriptor),
        MKFLAG(PropertyTagImageDescription),
        MKFLAG(PropertyTagImageHeight),
        MKFLAG(PropertyTagImageTitle),
        MKFLAG(PropertyTagImageWidth),
        MKFLAG(PropertyTagInkNames),
        MKFLAG(PropertyTagInkSet),
        MKFLAG(PropertyTagJPEGACTables),
        MKFLAG(PropertyTagJPEGDCTables),
        MKFLAG(PropertyTagJPEGInterFormat),
        MKFLAG(PropertyTagJPEGInterLength),
        MKFLAG(PropertyTagJPEGLosslessPredictors),
        MKFLAG(PropertyTagJPEGPointTransforms),
        MKFLAG(PropertyTagJPEGProc),
        MKFLAG(PropertyTagJPEGQTables),
        MKFLAG(PropertyTagJPEGQuality),
        MKFLAG(PropertyTagJPEGRestartInterval),
        MKFLAG(PropertyTagLoopCount),
        MKFLAG(PropertyTagLuminanceTable),
        MKFLAG(PropertyTagMaxSampleValue),
        MKFLAG(PropertyTagMinSampleValue),
        MKFLAG(PropertyTagNewSubfileType),
        MKFLAG(PropertyTagNumberOfInks),
        MKFLAG(PropertyTagOrientation),
        MKFLAG(PropertyTagPageName),
        MKFLAG(PropertyTagPageNumber),
        MKFLAG(PropertyTagPaletteHistogram),
        MKFLAG(PropertyTagPhotometricInterp),
        MKFLAG(PropertyTagPixelPerUnitX),
        MKFLAG(PropertyTagPixelPerUnitY),
        MKFLAG(PropertyTagPixelUnit),
        MKFLAG(PropertyTagPlanarConfig),
        MKFLAG(PropertyTagPredictor),
        MKFLAG(PropertyTagPrimaryChromaticities),
        MKFLAG(PropertyTagPrintFlags),
        MKFLAG(PropertyTagPrintFlagsBleedWidth),
        MKFLAG(PropertyTagPrintFlagsBleedWidthScale),
        MKFLAG(PropertyTagPrintFlagsCrop),
        MKFLAG(PropertyTagPrintFlagsVersion),
        MKFLAG(PropertyTagREFBlackWhite),
        MKFLAG(PropertyTagResolutionUnit),
        MKFLAG(PropertyTagResolutionXLengthUnit),
        MKFLAG(PropertyTagResolutionXUnit),
        MKFLAG(PropertyTagResolutionYLengthUnit),
        MKFLAG(PropertyTagResolutionYUnit),
        MKFLAG(PropertyTagRowsPerStrip),
        MKFLAG(PropertyTagSMaxSampleValue),
        MKFLAG(PropertyTagSMinSampleValue),
        MKFLAG(PropertyTagSRGBRenderingIntent),
        MKFLAG(PropertyTagSampleFormat),
        MKFLAG(PropertyTagSamplesPerPixel),
        MKFLAG(PropertyTagSoftwareUsed),
        MKFLAG(PropertyTagStripBytesCount),
        MKFLAG(PropertyTagStripOffsets),
        MKFLAG(PropertyTagSubfileType),
        MKFLAG(PropertyTagT4Option),
        MKFLAG(PropertyTagT6Option),
        MKFLAG(PropertyTagTargetPrinter),
        MKFLAG(PropertyTagThreshHolding),
        MKFLAG(PropertyTagThumbnailArtist),
        MKFLAG(PropertyTagThumbnailBitsPerSample),
        MKFLAG(PropertyTagThumbnailColorDepth),
        MKFLAG(PropertyTagThumbnailCompressedSize),
        MKFLAG(PropertyTagThumbnailCompression),
        MKFLAG(PropertyTagThumbnailCopyRight),
        MKFLAG(PropertyTagThumbnailData),
        MKFLAG(PropertyTagThumbnailDateTime),
        MKFLAG(PropertyTagThumbnailEquipMake),
        MKFLAG(PropertyTagThumbnailEquipModel),
        MKFLAG(PropertyTagThumbnailFormat),
        MKFLAG(PropertyTagThumbnailHeight),
        MKFLAG(PropertyTagThumbnailImageDescription),
        MKFLAG(PropertyTagThumbnailImageHeight),
        MKFLAG(PropertyTagThumbnailImageWidth),
        MKFLAG(PropertyTagThumbnailOrientation),
        MKFLAG(PropertyTagThumbnailPhotometricInterp),
        MKFLAG(PropertyTagThumbnailPlanarConfig),
        MKFLAG(PropertyTagThumbnailPlanes),
        MKFLAG(PropertyTagThumbnailPrimaryChromaticities),
        MKFLAG(PropertyTagThumbnailRawBytes),
        MKFLAG(PropertyTagThumbnailRefBlackWhite),
        MKFLAG(PropertyTagThumbnailResolutionUnit),
        MKFLAG(PropertyTagThumbnailResolutionX),
        MKFLAG(PropertyTagThumbnailResolutionY),
        MKFLAG(PropertyTagThumbnailRowsPerStrip),
        MKFLAG(PropertyTagThumbnailSamplesPerPixel),
        MKFLAG(PropertyTagThumbnailSize),
        MKFLAG(PropertyTagThumbnailSoftwareUsed),
        MKFLAG(PropertyTagThumbnailStripBytesCount),
        MKFLAG(PropertyTagThumbnailStripOffsets),
        MKFLAG(PropertyTagThumbnailTransferFunction),
        MKFLAG(PropertyTagThumbnailWhitePoint),
        MKFLAG(PropertyTagThumbnailWidth),
        MKFLAG(PropertyTagThumbnailYCbCrCoefficients),
        MKFLAG(PropertyTagThumbnailYCbCrPositioning),
        MKFLAG(PropertyTagThumbnailYCbCrSubsampling),
        MKFLAG(PropertyTagTileByteCounts),
        MKFLAG(PropertyTagTileLength),
        MKFLAG(PropertyTagTileOffset),
        MKFLAG(PropertyTagTileWidth),
        MKFLAG(PropertyTagTransferFuncition),
        MKFLAG(PropertyTagTransferRange),
        MKFLAG(PropertyTagWhitePoint),
        MKFLAG(PropertyTagXPosition),
        MKFLAG(PropertyTagXResolution),
        MKFLAG(PropertyTagYCbCrCoefficients),
        MKFLAG(PropertyTagYCbCrPositioning),
        MKFLAG(PropertyTagYCbCrSubsampling),
        MKFLAG(PropertyTagYPosition),
        MKFLAG(PropertyTagYResolution)
    };

    wchar_t szUnknownBuffer[256];
    wprintf( L"Property: %ws, ", GetStringFromTable( s_PropertyIds, sizeof(s_PropertyIds)/sizeof(s_PropertyIds[0]), pPropertyItem->id, szUnknownBuffer ) );
    wprintf( L"%ws, ", GetStringFromTable( s_PropertyTypes, sizeof(s_PropertyTypes)/sizeof(s_PropertyTypes[0]), pPropertyItem->type, szUnknownBuffer ) );
    wprintf( L"%d\n", pPropertyItem->length );

    switch (pPropertyItem->type)
    {
        //
        // ASCII text
        //
    case PropertyTagTypeASCII:
        {
            wprintf( L"%S\n", pPropertyItem->value );
        }
        break;

        //
        // Unsigned 16 bit integer
        //
    case PropertyTagTypeShort:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(USHORT);i++)
            {
                if (i)
                {
                    if (!(i%14))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%04X", reinterpret_cast<PUSHORT>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Two unsigned 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(ULONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // Two signed 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeSRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(LONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // 32 bit unsigned integers
        //
    case PropertyTagTypeLong:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(ULONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PULONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;
    
        //
        // 32 bit signed integers
        //
    case PropertyTagTypeSLONG:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(LONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PLONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Buncha bytes and everything else
        //
    default:
    case PropertyTagTypeByte:
    case PropertyTagTypeUndefined:
        {
            for (UINT i=0;i<pPropertyItem->length;i++)
            {
                if (i && !(i%4))
                {
                    if (!(i%32))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%02X", reinterpret_cast<PBYTE>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

    }
    wprintf( L"\n" );
}


void DumpImageProperties( LPCWSTR pwszImage )
{
    Gdiplus::Image Image(pwszImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        UINT nPropertyCount = Image.GetPropertyCount();
        if (nPropertyCount)
        {
            PROPID* pPropIdList = new PROPID[nPropertyCount];
            if (pPropIdList)
            {
                if (Gdiplus::Ok == Image.GetPropertyIdList(nPropertyCount, pPropIdList))
                {
                    UINT nItemSize = 0;
                    if (Gdiplus::Ok == Image.GetPropertySize(&nItemSize, &nPropertyCount))
                    {
                        Gdiplus::PropertyItem *pPropertyItems = reinterpret_cast<Gdiplus::PropertyItem*>(LocalAlloc(LPTR,nItemSize));
                        if (pPropertyItems)
                        {
                            if (Gdiplus::Ok == Image.GetAllPropertyItems( nItemSize, nPropertyCount, pPropertyItems ))
                            {
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                wprintf( L"Dumping properties for %s\n", pwszImage );
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                Gdiplus::PropertyItem *pCurr = pPropertyItems;
                                for (UINT i=0;i<nPropertyCount;i++)
                                {
                                    DumpImageProperty(pCurr++);
                                }
                            }
                            LocalFree(pPropertyItems);
                        }
                    }
                }
                delete[] pPropIdList;
            }
        }
    }
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    ULONG_PTR pGdiplusToken=0;
    Gdiplus::GdiplusStartupInput StartupInput;
    if (Gdiplus::Ok == Gdiplus::GdiplusStartup(&pGdiplusToken,&StartupInput,NULL))
    {
        for (int i=1;i<argc;i++)
        {
            DumpImageProperties(argv[i]);
        }
        Gdiplus::GdiplusShutdown(pGdiplusToken);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\testacqd\sources.inc ===
#
# include the WIA global build settings
#

USE_SHFUSION = 1


!include          $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

NO_BROWSER_FILE = 1

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETNAME=testacqd
TARGETTYPE=PROGRAM
TARGETPATH=obj

USE_MSVCRT = 1

C_DEFINES=$(C_DEFINES)


INCLUDES= $(INCLUDES); \
          $(BASEDIR)\private\inc;

SOURCES= \
        ..\main.cpp \
        ..\testacqd.rc

TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\urlmon.lib \
        $(SHELL_LIB_PATH)\shfusion.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\remall\remall.cpp ===
#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <wianew.h>
#include <simreg.h>
#include <dumpprop.h>
#include <devlist.h>
#include <simbstr.h>
#include <stdio.h>


typedef HANDLE (WINAPI *WiaAddDeviceProc)();
typedef BOOL (WINAPI *WiaRemoveDeviceProc)(STI_DEVICE_INFORMATION *);

HINSTANCE g_hInstance;

bool RemoveDevice( LPCWSTR pszDeviceId )
{
    bool bResult = false;
    CComPtr<IStillImage> pStillImage;
    if (SUCCEEDED(StiCreateInstance( g_hInstance, STI_VERSION, &pStillImage, NULL)) && pStillImage)
    {
        HINSTANCE hClassInstaller = LoadLibrary(TEXT("sti_ci.dll"));
        if (hClassInstaller)
        {
            WiaRemoveDeviceProc pfnWiaRemoveDeviceProc = reinterpret_cast<WiaRemoveDeviceProc>(GetProcAddress(hClassInstaller, "WiaRemoveDevice"));
            if (pfnWiaRemoveDeviceProc)
            {
                STI_DEVICE_INFORMATION *pStiDeviceInformation = NULL;
                if (SUCCEEDED(pStillImage->GetDeviceInfo( const_cast<LPWSTR>(pszDeviceId), reinterpret_cast<LPVOID*>(&pStiDeviceInformation))) && pStiDeviceInformation )
                {
                    bResult = (pfnWiaRemoveDeviceProc( pStiDeviceInformation ) != FALSE);
                    if (!bResult)
                    {
                        wprintf( L"WiaRemoveDeviceProc failed\n"); 
                    }

                    LocalFree(pStiDeviceInformation);
                }
                else
                {
                    wprintf( L"GetDeviceInfo on %ws failed\n", pszDeviceId ); 
                }
            }
            else
            {
                wprintf( L"GetProcAddress on WiaRemoveDeviceProc failed\n"); 
            }
            FreeLibrary( hClassInstaller );
        }
        else
        {
            wprintf( L"LoadLibrary failed\n"); 
        }
    }
    else
    {
        wprintf( L"StiCreateInstance failed\n"); 
    }
    return bResult;
}


void RemoveAllDevices()
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        CComPtr<IWiaDevMgr> pWiaDevMgr;
        if (SUCCEEDED(CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr )))
        {
            CDeviceList DeviceList( pWiaDevMgr );
            for (int i=0;i<DeviceList.Size();++i)
            {
                CSimpleStringWide strwDeviceId;
                if (PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_ID, strwDeviceId ))
                {
                    CSimpleStringWide strwDeviceName;
                    PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_NAME, strwDeviceName );
                    wprintf( L"Removing %ws -- %ws\n", strwDeviceId.String(), strwDeviceName.String() );
                    wprintf( L"%ws\n", RemoveDevice( strwDeviceId ) ? L"succeeded" : L"failed" );
                }
            }
        }
    }
    CoUninitialize();
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    g_hInstance = GetModuleHandle(NULL);
    WIA_DEBUG_CREATE(g_hInstance);
    
    bool bRemove = false;
    for (int i=1;i<argc;i++)
    {
        if (L'/' == argv[i][0] || L'-' == argv[i][0])
        {
            switch (argv[i][1])
            {
            case L'y':
            case L'Y':
                bRemove = true;
                break;
            }
        }
    }

    if (!bRemove)
    {
        wprintf( L"Do you want to remove all of your WIA devices? (y/n): " );
        int chResponse = getchar();
        if (L'y' == chResponse || L'Y' == chResponse)
        {
            bRemove = true;
        }
    }

    if (bRemove)
    {
        RemoveAllDevices();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\testacqd\main.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MAIN.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/3/2000
 *
 *  DESCRIPTION: Random unit testing program for various UI components
 *
 *******************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <initguid.h>
#include <atlbase.h>
#include <objbase.h>
#include <wia.h>
#include <sti.h>
#include <simstr.h>
#include <shellext.h>
#include <upnp.h>
#include <simbstr.h>
#include <simreg.h>
#include <dumpprop.h>
#include <simrect.h>
#include "uicommon.h"
#include "wiadebug.h"
#include "resource.h"
#include "simcrack.h"
#include "wiadevdp.h"
#include "isuppfmt.h"
#include "itranhlp.h"
#include "gphelper.h"
#include "runwiz.h"
#include "runnpwiz.h"
#include "multistr.h"
#include "mboxex.h"

#define SELECT_DEVICE_TYPE StiDeviceTypeDefault

HINSTANCE g_hInstance;

#define PWM_DISPLAYNEWIMAGE (WM_USER+122)

class CWiaDataCallbackBase : public IWiaDataCallback
{
private:
    LONG    m_cRef;

public:
    CWiaDataCallbackBase()
    : m_cRef(1)
    {
    }

    ~CWiaDataCallbackBase()
    {
    }

    STDMETHODIMP QueryInterface(const IID& iid, void** ppvObject)
    {
        if ((iid==IID_IUnknown) || (iid==IID_IWiaDataCallback))
        {
            *ppvObject = static_cast<LPVOID>(this);
        }
        else
        {
            *ppvObject = NULL;
            return(E_NOINTERFACE);
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
        return(S_OK);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return(InterlockedIncrement(&m_cRef));
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&m_cRef)==0)
        {
            delete this;
            return 0;
        }
        return(m_cRef);
    }


    STDMETHODIMP BandedDataCallback(
        LONG                            lReason,
        LONG                            lStatus,
        LONG                            lPercentComplete,
        LONG                            lOffset,
        LONG                            lLength,
        LONG                            lReserved,
        LONG                            lResLength,
        PBYTE                           pbBuffer)
    {
        if (lReason == IT_MSG_STATUS)
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("IT_MSG_STATUS: Percent Done (in client callback): %d\n"), lPercentComplete );
            OutputDebugString( szMessage );
        }
        else if (lReason == IT_MSG_DATA)
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("IT_MSG_DATA: Percent Done (in client callback): %d\n"), lPercentComplete );
            OutputDebugString( szMessage );
        }
        return S_OK;
    }

    static IWiaDataCallback *CreateInstance(void)
    {
        IWiaDataCallback *pWiaDataCallback = NULL;
        CWiaDataCallbackBase *pWiaDataCallbackBase = new CWiaDataCallbackBase;
        if (pWiaDataCallbackBase)
        {
            HRESULT hr = pWiaDataCallbackBase->QueryInterface( IID_IWiaDataCallback, (void**)&pWiaDataCallback );
            pWiaDataCallbackBase->Release();
        }
        return pWiaDataCallback;
    }
};



class CProgressDialogFlagsDialog
{
public:
    struct CData
    {
        LONG lFlags;
    };

private:
    HWND m_hWnd;
    CData *m_pData;

private:
    //
    // Not implemented
    //
    CProgressDialogFlagsDialog( const CProgressDialogFlagsDialog & );
    CProgressDialogFlagsDialog(void);
    CProgressDialogFlagsDialog &operator=( const CProgressDialogFlagsDialog & );

private:
    //
    // Sole constructor
    //
    explicit CProgressDialogFlagsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }

    ~CProgressDialogFlagsDialog(void)
    {
        m_hWnd = NULL;
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (m_pData)
        {
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_PROGRESS)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_PROGRESS, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_CANCEL)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CANCEL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_ANIM)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_TITLE)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_TITLE, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            HandleAnimSettingsChange();
        }
        else
        {
            EndDialog( m_hWnd, IDCANCEL );
        }
        return 0;
    }

    void HandleAnimSettingsChange(void)
    {
        BOOL bEnable = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_GETCHECK, 0, 0 ));
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_SCAN_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT ), bEnable );
    }

    void OnAnimClicked( WPARAM, LPARAM )
    {
        HandleAnimSettingsChange();
    }

    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        if (m_pData)
        {
            m_pData->lFlags = 0;

            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_PROGRESS, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_PROGRESS;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CANCEL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_CANCEL;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_ANIM;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_TITLE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_TITLE;
            }

            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE;
            }
        }
        EndDialog( m_hWnd, IDOK );
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
            SC_HANDLE_COMMAND(IDOK,OnOK);
            SC_HANDLE_COMMAND(IDC_PROGDLG_ANIM,OnAnimClicked);
        }
        SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CProgressDialogFlagsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};


class CMessageBoxExFlagsDialog
{
public:
    struct CData
    {
        LONG lFlags;
    };

private:
    HWND m_hWnd;
    CData *m_pData;

private:
    //
    // Not implemented
    //
    CMessageBoxExFlagsDialog( const CMessageBoxExFlagsDialog & );
    CMessageBoxExFlagsDialog(void);
    CMessageBoxExFlagsDialog &operator=( const CMessageBoxExFlagsDialog & );

private:
    //
    // Sole constructor
    //
    explicit CMessageBoxExFlagsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }

    ~CMessageBoxExFlagsDialog(void)
    {
        m_hWnd = NULL;
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (m_pData)
        {
            if ((m_pData->lFlags & CMessageBoxEx::MBEX_OKCANCEL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_OKCANCEL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_YESNO) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_YESNO, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_CANCELRETRYSKIPSKIPALL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_YESYESTOALLNONOTOALL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_OK, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON2) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON2, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON3) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON3, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON4) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON4, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON1, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONERROR) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONERROR, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONWARNING) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONWARNING, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONQUESTION) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONQUESTION, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONINFORMATION, BM_SETCHECK, BST_CHECKED, 0 );
            }
        }
        else
        {
            EndDialog( m_hWnd, IDCANCEL );
        }
        return 0;
    }

    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        if (m_pData)
        {
            m_pData->lFlags = 0;

            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_OKCANCEL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_OKCANCEL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_YESNO, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_YESNO;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_CANCELRETRYSKIPSKIPALL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_YESYESTOALLNONOTOALL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_YESYESTOALLNONOTOALL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_OK, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_OK;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON2, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON2;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON3, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON3;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON4, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON4;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON1, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON1;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONINFORMATION, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONINFORMATION;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONWARNING, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONWARNING;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONQUESTION, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONQUESTION;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONERROR, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONERROR;
            }
        }
        EndDialog( m_hWnd, IDOK );
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
            SC_HANDLE_COMMAND(IDOK,OnOK);
        }
        SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CMessageBoxExFlagsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};


class CMiscUnitTestWindow : public IUPnPServiceCallback
{
private:
    HWND    m_hWnd;
    LONG    m_nProgressDialogFlags;
    LONG    m_nMessageBoxExFlags;
    HBITMAP m_hOriginalBitmap;
    HBITMAP m_hTransformedBitmap;
    BYTE    m_nThreshold;
    BYTE    m_nContrast;
    BYTE    m_nBrightness;
    CComPtr<IUPnPService> m_pUPnPService;

private:
    CMiscUnitTestWindow(void);
    CMiscUnitTestWindow( const CMiscUnitTestWindow & );
    CMiscUnitTestWindow &operator=( const CMiscUnitTestWindow & );

private:
    explicit CMiscUnitTestWindow( HWND hWnd )
      : m_hWnd(hWnd),
        m_nProgressDialogFlags(WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE),
        m_hOriginalBitmap(NULL),
        m_nMessageBoxExFlags(0),
        m_hTransformedBitmap(NULL),
        m_nThreshold(50),
        m_nContrast(50),
        m_nBrightness(50)
    {
    }
    ~CMiscUnitTestWindow(void)
    {
        if (m_hOriginalBitmap)
        {
            DeleteObject(m_hOriginalBitmap);
            m_hOriginalBitmap = NULL;
        }
        if (m_hTransformedBitmap)
        {
            DeleteObject(m_hTransformedBitmap);
            m_hTransformedBitmap = NULL;
        }
    }
    void DestroyBitmap( bool bRepaint=true )
    {
        if (m_hOriginalBitmap)
        {
            DeleteObject(m_hOriginalBitmap);
            m_hOriginalBitmap = NULL;
        }
        if (m_hTransformedBitmap)
        {
            DeleteObject(m_hTransformedBitmap);
            m_hTransformedBitmap = NULL;
        }
        if (bRepaint)
        {
            InvalidateRect( m_hWnd, NULL, TRUE );
            UpdateWindow( m_hWnd );
        }
    }
    LRESULT OnDestroy( WPARAM, LPARAM )
    {
        m_pUPnPService = NULL;
        PostQuitMessage(0);
        return(0);
    }
    LRESULT OnCreate( WPARAM, LPARAM )
    {
        SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_TESTACQD), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR )));
        SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_TESTACQD), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR )));
        m_hOriginalBitmap = reinterpret_cast<HBITMAP>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_TESTIMAGE), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));

        HWND hWnd = CreateWindow( WC_LINK, TEXT("<a>This is a link that will only show up if this application is fusionized</a>"), WS_CHILD|WS_VISIBLE, 0, 0, 200, 20, m_hWnd, reinterpret_cast<HMENU>(1), g_hInstance, NULL );
        if (!hWnd)
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateWindow returned")));
        }

        return(0);
    }
    void OnFileExit( WPARAM, LPARAM )
    {
        DestroyWindow(m_hWnd);
    }
    void OnProgressTestProgress( WPARAM, LPARAM )
    {
        WIA_PUSH_FUNCTION((TEXT("OnProgressTestProgress")));
        CComPtr<IWiaProgressDialog> pWiaProgressDialog;
        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&pWiaProgressDialog );
        if (SUCCEEDED(hr))
        {
            pWiaProgressDialog->Create( m_hWnd, m_nProgressDialogFlags );
            pWiaProgressDialog->SetTitle( L"This is the title" );
            pWiaProgressDialog->Show();
            for (int i=0;i<100;i++)
            {
                pWiaProgressDialog->SetMessage( CSimpleStringWide().Format( L"%d percent complete!", i ).String() );
                pWiaProgressDialog->SetPercentComplete(i);
                BOOL bCancelled = FALSE;
                pWiaProgressDialog->Cancelled(&bCancelled);
                if (bCancelled)
                {
                    Sleep(1000);
                    break;
                }
                Sleep(100);
            }
            pWiaProgressDialog->Destroy();
        }
        WIA_PRINTHRESULT((hr,TEXT("OnProgressTestProgress returning")));
    }
    void OnProgressSetFlags( WPARAM, LPARAM )
    {
        CProgressDialogFlagsDialog::CData Data;
        Data.lFlags = m_nProgressDialogFlags;
        if (IDOK == DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_PROGRESS_DIALOG_SETTINGS), m_hWnd, CProgressDialogFlagsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data)))
        {
            m_nProgressDialogFlags = Data.lFlags;
        }
    }
    void OnMBoxSetFlags( WPARAM, LPARAM )
    {
        CMessageBoxExFlagsDialog::CData Data;
        Data.lFlags = m_nMessageBoxExFlags;
        if (IDOK == DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_MBOXFLAGS), m_hWnd, CMessageBoxExFlagsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data)))
        {
            m_nMessageBoxExFlags = Data.lFlags;
        }
    }

    void OnWiaDeviceDlg( WPARAM, LPARAM )
    {
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            hr = pIWiaDevMgr->SelectDeviceDlg( m_hWnd, SELECT_DEVICE_TYPE, 0, NULL, &pWiaItemRoot );
            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                LONG nItemCount;
                IWiaItem **ppIWiaItems;
                hr = pWiaItemRoot->DeviceDlg( m_hWnd, 0, WIA_INTENT_MAXIMIZE_QUALITY, &nItemCount, &ppIWiaItems );
                if (SUCCEEDED(hr) && hr != S_FALSE)
                {
                    if (ppIWiaItems)
                    {
                        CComPtr<IWiaTransferHelper> pWiaTransferHelper;
                        hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaTransferHelper, (void**)&pWiaTransferHelper );
                        if (SUCCEEDED(hr))
                        {
                            for (int i=0;i<nItemCount && SUCCEEDED(hr) && hr != S_FALSE;i++)
                            {
                                IWiaDataCallback *pWiaDataCallback = CWiaDataCallbackBase::CreateInstance();
                                if (pWiaDataCallback)
                                {
                                    TCHAR szTempPath[MAX_PATH], szFilename[MAX_PATH] = TEXT("");
                                    GetTempPath( ARRAYSIZE(szTempPath), szTempPath );
                                    GetTempFileName( szTempPath, TEXT("acq"), 0, szFilename );

                                    CComPtr<IWiaSupportedFormats> pWiaSupportedFormats;
                                    hr = pWiaTransferHelper->QueryInterface( IID_IWiaSupportedFormats, (void**)&pWiaSupportedFormats );
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pWiaSupportedFormats->Initialize( ppIWiaItems[i], TYMED_FILE );
                                        if (SUCCEEDED(hr))
                                        {
                                            GUID cf;
                                            hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &cf );
                                            if (SUCCEEDED(hr))
                                            {
                                                CSimpleStringWide strTemp(CSimpleStringConvert::WideString(CSimpleString(szFilename)));
                                                WCHAR szTemp[MAX_PATH];
                                                lstrcpyW( szTemp, strTemp.String() );
                                                hr = pWiaSupportedFormats->ChangeClipboardFileExtension( cf, szTemp, ARRAYSIZE(szTemp) );
                                                if (SUCCEEDED(hr))
                                                {
                                                    lstrcpy( szFilename, CSimpleStringConvert::NaturalString(CSimpleStringWide(szTemp)));
                                                    hr = pWiaTransferHelper->TransferItemFile( ppIWiaItems[i], m_hWnd, 0, cf, CSimpleStringConvert::WideString(CSimpleString(szFilename)).String(), pWiaDataCallback, TYMED_FILE );
                                                    if (S_OK == hr)
                                                    {
                                                        CSimpleString strNaturalFilename = CSimpleStringConvert::NaturalString(CSimpleString(szFilename));
                                                        
                                                        DestroyBitmap();
                                                        CGdiPlusHelper().LoadAndScale( m_hOriginalBitmap, strNaturalFilename );
                                                        InvalidateRect( m_hWnd, NULL, TRUE );
                                                        UpdateWindow( m_hWnd );

                                                        MessageBox( m_hWnd, CSimpleString().Format( TEXT("File transfer appeared to work: %s"), strNaturalFilename.String() ), TEXT("Debug"), 0 );
                                                        DeleteFile( strNaturalFilename );

                                                        hr = pWiaSupportedFormats->Initialize( ppIWiaItems[i], TYMED_CALLBACK );
                                                        if (SUCCEEDED(hr))
                                                        {
                                                            hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &cf );
                                                            if (SUCCEEDED(hr))
                                                            {
                                                                hr = pWiaTransferHelper->TransferItemBanded( ppIWiaItems[i], m_hWnd, 0, cf, 0, pWiaDataCallback );
                                                                if (S_OK == hr)
                                                                {
                                                                    MessageBox( m_hWnd, TEXT("Banded transfer appeared to work"), TEXT("Debug"), 0 );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                ppIWiaItems[i]->Release();
                            }
                        }
                        LocalFree( ppIWiaItems );
                    }
                }
            }
        }
        if (FAILED(hr))
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("HRESULT: 0x%08X"), hr );
            MessageBox( NULL, szMessage, TEXT("Some kinda error happened"), 0 );
            WIA_PRINTHRESULT((hr,TEXT("ScannerAcquireDialog failed")));
        }
    }

    bool LoadAndScale( LPCTSTR pszImageName )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        bool bResult = false;
        CGdiPlusHelper GdiPlusHelper;
        HRESULT hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages );
        if (SUCCEEDED(hr))
        {
            if (m_hOriginalBitmap)
            {
                InvalidateRect( m_hWnd, NULL, TRUE );
                UpdateWindow(m_hWnd);
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                bResult = true;
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
        }
        return bResult;
    }

    void RotateFile( bool bJpeg )
    {
        const int cnDegrees = 90;
        const int bScaleSmallImages = true;
        TCHAR szSourceImage[MAX_PATH] = {0};
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OpenFileName);
        OpenFileName.lpstrFilter = bJpeg ? TEXT("JPEG Files\0*.jpg;*.jpe;*.jpeg\0") : TEXT("All files\0*.*\0");
        OpenFileName.lpstrFile = szSourceImage;
        OpenFileName.nMaxFile = ARRAYSIZE(szSourceImage);
        if (GetOpenFileName(&OpenFileName))
        {
            TCHAR szTempDir[MAX_PATH];
            if (GetTempPath(ARRAYSIZE(szTempDir),szTempDir))
            {
                TCHAR szTempTargetFile[MAX_PATH];
                if (GetTempFileName(szTempDir,TEXT("taq"), 0, szTempTargetFile ))
                {
                    CGdiPlusHelper GdiPlusHelper;
                    HRESULT hr = GdiPlusHelper.Rotate( CSimpleStringConvert::WideString(CSimpleString(szSourceImage)), CSimpleStringConvert::WideString(CSimpleString(szTempTargetFile)), cnDegrees, IID_NULL );
                    if (SUCCEEDED(hr))
                    {
                        if (LoadAndScale(szTempTargetFile))
                        {
                            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.Rotate(\n   szSourceImage = %s, \n   szTempTargetFile = %s, \n   cnDegrees = %d\n) succeeded"), szSourceImage, szTempTargetFile, cnDegrees ), TEXT("RotateFile"), MB_ICONINFORMATION );
                        }
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.Rotate(\n   szSourceImage = %s, \n   szTempTargetFile = %s, \n   cnDegrees = %d\n) failed with HRESULT %08X"), szSourceImage, szTempTargetFile, cnDegrees, hr ), TEXT("RotateFile"), MB_ICONHAND );
                    }
                }
            }
        }
    }

    void OnGdiRotateFileNonJpeg( WPARAM, LPARAM )
    {
        RotateFile(false);
    }
    void OnGdiRotateFileJpeg( WPARAM, LPARAM )
    {
        RotateFile(true);
    }
    void OnGdiLoadAndScaleImage( WPARAM, LPARAM )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        DestroyBitmap();
        TCHAR szSourceImage[MAX_PATH] = {0};
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OpenFileName);
        OpenFileName.lpstrFilter = TEXT("All files\0*.*\0");
        OpenFileName.lpstrFile = szSourceImage;
        OpenFileName.nMaxFile = ARRAYSIZE(szSourceImage);
        if (GetOpenFileName(&OpenFileName))
        {
            CGdiPlusHelper GdiPlusHelper;
            HRESULT hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages );
            if (SUCCEEDED(hr))
            {
                if (m_hOriginalBitmap)
                {
                    InvalidateRect( m_hWnd, NULL, TRUE );
                    UpdateWindow(m_hWnd);
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
    }
    void OnGdiLoadAndScaleStream( WPARAM, LPARAM )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        DestroyBitmap();

        CComPtr<IStream> pStream;
        
        //HRESULT hr = URLOpenBlockingStream( NULL, TEXT("http://www.ivory.org/spiders/araneus.diadematus-4.jpg"), &pStream, 0, NULL );
        HRESULT hr = URLOpenBlockingStream( NULL, TEXT("http://orenr04:2869/upnphost/ssisapi.dll?ImageFile=nature3.jpg"), &pStream, 0, NULL );
        if (SUCCEEDED(hr))
        {
            CGdiPlusHelper GdiPlusHelper;
            hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages );
            if (SUCCEEDED(hr))
            {
                if (m_hOriginalBitmap)
                {
                    InvalidateRect( m_hWnd, NULL, TRUE );
                    UpdateWindow(m_hWnd);
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("URLOpenBlockingStream failed: %08X" ), hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
        }
    }
    void OnGdiConvertFile( WPARAM, LPARAM )
    {
#if 0
        TCHAR szInputFilename[MAX_PATH];
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OPENFILENAME);
        OpenFileName.hwndOwner = m_hWnd;
        OpenFileName.hInstance = g_hInstance;
        OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
        OpenFileName.lpstrFile = szInputFilename;
        OpenFileName.nMaxFile = ARRAYSIZE(szInputFilename);
        OpenFileName.lpstrTitle = TEXT("Choose File to Convert");
        OpenFileName.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
        if (GetOpenFileName(&OpenFileName))
        {
            TCHAR szOutputFilename[MAX_PATH] = {0};
            OPENFILENAME SaveFileName = {0};
            SaveFileName.lStructSize = sizeof(OPENFILENAME);
            SaveFileName.hwndOwner = m_hWnd;
            SaveFileName.hInstance = g_hInstance;
            SaveFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            SaveFileName.lpstrFile = szOutputFilename;
            SaveFileName.nMaxFile = ARRAYSIZE(szOutputFilename);
            SaveFileName.lpstrTitle = TEXT("Choose output file and type");
            SaveFileName.Flags = OFN_ENABLESIZING|OFN_HIDEREADONLY|OFN_EXPLORER|OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST;
            if (GetSaveFileName(&SaveFileName))
            {
            }
        }
#else
        CMessageBoxEx::MessageBox( m_hWnd, TEXT("Not implemented"), TEXT("testacqd"), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );
#endif
    }

    void OnExploreWiaDevice( WPARAM, LPARAM )
    {
        CWaitCursor wc;
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            BSTR bstrDeviceId = NULL;
            hr = pIWiaDevMgr->SelectDeviceDlgID( m_hWnd, SELECT_DEVICE_TYPE, 0, &bstrDeviceId );
            if (S_OK == hr)
            {
                hr = WiaUiUtil::ExploreWiaDevice( bstrDeviceId );
            }
        }
        if (!SUCCEEDED(hr))
        {
            CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format(TEXT("Result: %08X"),hr), TEXT("testacqd"), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONINFORMATION );
        }
    }

    void OnGdiRotateHBITMAP( WPARAM, LPARAM )
    {
        if (m_hOriginalBitmap)
        {
            HBITMAP hNewBitmap;
            CGdiPlusHelper GdiPlusHelper;
            GdiPlusHelper.Rotate( m_hOriginalBitmap, hNewBitmap, 90 );
            DestroyBitmap();
            m_hOriginalBitmap = hNewBitmap;
            InvalidateRect( m_hWnd, NULL, TRUE );
            UpdateWindow(m_hWnd);
        }
    }
    void OnGdiDisplayDecoderExtensions( WPARAM, LPARAM )
    {
        CSimpleString strExtensions;
        HRESULT hr = CGdiPlusHelper().ConstructDecoderExtensionSearchStrings( strExtensions );
        if (SUCCEEDED(hr))
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructDecoderExtensionSearchStrings() succeeded and returned strExtensions = %s"), strExtensions.String() ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructDecoderExtensionSearchStrings() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
        }
    }
    void OnGdiDisplayEncoderExtensions( WPARAM, LPARAM )
    {
        CSimpleString strExtensions;
        HRESULT hr = CGdiPlusHelper().ConstructEncoderExtensionSearchStrings( strExtensions );
        if (SUCCEEDED(hr))
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructEncoderExtensionSearchStrings() succeeded and returned strExtensions = %s"), strExtensions.String() ), TEXT("OnGdiDisplayEncoderExtensions"), MB_ICONINFORMATION );
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructEncoderExtensionSearchStrings() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayEncoderExtensions"), MB_ICONINFORMATION );
        }
    }

    void OnGdiSaveMultipleImagesAsMultiPage( WPARAM, LPARAM )
    {
        LPTSTR pszFiles = new TCHAR[0xFFFF];
        if (pszFiles)
        {
            OPENFILENAME OpenFileName = {0};
            OpenFileName.lStructSize = sizeof(OPENFILENAME);
            OpenFileName.hwndOwner = m_hWnd;
            OpenFileName.hInstance = g_hInstance;
            OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            OpenFileName.lpstrFile = pszFiles;
            OpenFileName.nMaxFile = 0xFFFF;
            OpenFileName.lpstrTitle = TEXT("Choose Files to Convert to a multi-page TIFF");
            OpenFileName.Flags = OFN_ALLOWMULTISELECT|OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
            if (GetOpenFileName(&OpenFileName))
            {
                CMultiString strItems(pszFiles);

                if (strItems.Size())
                {
                    CSimpleDynamicArray<CSimpleStringWide> strFiles;
                    if (strItems.Size() == 1)
                    {
                        strFiles.Append(CSimpleStringConvert::WideString(CSimpleString(strItems[0])));
                    }
                    else
                    {
                        CSimpleString strDirectory = strItems[0];
                        if (!strDirectory.MatchLastCharacter(TEXT('\\')))
                        {
                            strDirectory += TEXT("\\");
                        }
                        for (int i=1;i<strItems.Size();i++)
                        {
                            strFiles.Append(CSimpleStringConvert::WideString(CSimpleString(strDirectory + strItems[i])));
                        }
                    }
                    for (int i=0;i<strFiles.Size();i++)
                    {
                        WIA_TRACE((TEXT("strFiles[i] = %ws"), strFiles[i].String()));
                    }
                    TCHAR szOutputFilename[MAX_PATH] = {0};
                    OPENFILENAME SaveFileName = {0};
                    SaveFileName.lStructSize = sizeof(OPENFILENAME);
                    SaveFileName.hwndOwner = m_hWnd;
                    SaveFileName.hInstance = g_hInstance;
                    SaveFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
                    SaveFileName.lpstrFile = szOutputFilename;
                    SaveFileName.nMaxFile = ARRAYSIZE(szOutputFilename);
                    SaveFileName.lpstrTitle = TEXT("Select a name for your multi-page TIFF");
                    SaveFileName.Flags = OFN_ENABLESIZING|OFN_HIDEREADONLY|OFN_EXPLORER|OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST;
                    if (GetSaveFileName(&SaveFileName))
                    {
                        HRESULT hr = CGdiPlusHelper().SaveMultipleImagesAsMultiPage( strFiles, CSimpleStringConvert::WideString(CSimpleString(szOutputFilename)), Gdiplus::ImageFormatTIFF );
                        if (SUCCEEDED(hr))
                        {
                            MessageBox( m_hWnd, TEXT("CGdiPlusHelper().SaveMultipleImagesAsMultiPage() succeeded"), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
                        }
                        else
                        {
                            MessageBox( m_hWnd, CSimpleString().Format( TEXT("CGdiPlusHelper().SaveMultipleImagesAsMultiPage() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
                        }
                    }
                }
            }
            delete[] pszFiles;
        }
    }

    void OnGdiIncreaseThreshold( WPARAM, LPARAM )
    {
        if (m_nThreshold != 100)
        {
            m_nThreshold++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetThreshold( m_hOriginalBitmap, m_hTransformedBitmap, m_nThreshold );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnGdiDecreaseThreshold( WPARAM, LPARAM )
    {
        if (m_nThreshold != 0)
        {
            m_nThreshold--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetThreshold( m_hOriginalBitmap, m_hTransformedBitmap, m_nThreshold );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnGdiIncreaseContrast( WPARAM, LPARAM )
    {
        if (m_nContrast != 100)
        {
            m_nContrast++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }


    void OnGdiDecreaseContrast( WPARAM, LPARAM )
    {
        if (m_nContrast != 0)
        {
            m_nContrast--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }
    
    void OnGdiDecreaseBrightness( WPARAM, LPARAM )
    {
        if (m_nBrightness != 0)
        {
            m_nBrightness--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }


    void OnGdiIncreaseBrightness( WPARAM, LPARAM )
    {
        if (m_nBrightness != 255)
        {
            m_nBrightness++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnTestUniversalPnpSlideshowClient( WPARAM, LPARAM )
    {
        CComPtr<IUPnPDeviceFinder> pUPnPDeviceFinder;
        HRESULT hr = CoCreateInstance( CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, (void**)&pUPnPDeviceFinder ); 
        if (SUCCEEDED(hr))
        {
            CComPtr<IUPnPDevices> pUPnPDevices;
            hr = pUPnPDeviceFinder->FindByType(CSimpleBStr(CSimpleString(TEXT("urn:schemas-upnp-org:device:SlideshowProjector:1"))),0,&pUPnPDevices);
            if (S_OK == hr)
            {
                LONG nDeviceCount=0;
                hr = pUPnPDevices->get_Count(&nDeviceCount);
                if (S_OK == hr)
                {
                    CComPtr<IUnknown> pUnknown;
                    hr = pUPnPDevices->get__NewEnum(&pUnknown);
                    if (S_OK == hr)
                    {
                        CComPtr<IEnumUnknown> pEnumUnknown;
                        hr = pUnknown->QueryInterface( IID_IEnumUnknown, (VOID **)&pEnumUnknown);
                        if (S_OK == hr)
                        {
                            ULONG nDevicesReturned=0;
                            CComPtr<IUnknown> pDeviceUnknown;
                            hr = pEnumUnknown->Next( 1, &pDeviceUnknown, &nDevicesReturned );
                            if (S_OK == hr)
                            {
                                CComPtr<IUPnPDevice> pUPnPDevice;
                                hr = pDeviceUnknown->QueryInterface( IID_IUPnPDevice, (void**)&pUPnPDevice);
                                if (S_OK == hr)
                                {
                                    CComPtr<IUPnPServices> pUPnPServices;
                                    hr= pUPnPDevice->get_Services(&pUPnPServices);
                                    if (S_OK == hr)
                                    {
                                        CComPtr<IUnknown> pUnknown;
                                        hr = pUPnPServices->get__NewEnum(&pUnknown);
                                        if (S_OK == hr)
                                        {
                                            CComPtr<IEnumUnknown> pEnumUnknown;
                                            hr = pUnknown->QueryInterface( IID_IEnumUnknown, (void**)&pEnumUnknown );
                                            if (S_OK == hr)
                                            {
                                                hr = pEnumUnknown->Reset();
                                                while (S_OK == hr)
                                                {
                                                    ULONG nNumFetched = 0;
                                                    CComPtr<IUnknown> pUnknown;
                                                    hr = pEnumUnknown->Next( 1, &pUnknown, &nNumFetched );
                                                    if (S_OK == hr)
                                                    {
                                                        CComPtr<IUPnPService> pUPnPService;
                                                        hr = pUnknown->QueryInterface(IID_IUPnPService, (void**)&pUPnPService);
                                                        if (S_OK == hr)
                                                        {
                                                        }
                                                        else
                                                        {
                                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface on IID_IUPnPService failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                        }
                                                        //
                                                        // Release it
                                                        //
                                                        pUnknown = NULL;
                                                    }
                                                    else if (FAILED(hr))
                                                    {
                                                        MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Next() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                    }
                                                }
                                                
                                                if (FAILED(hr))
                                                {
                                                    MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Reset() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                }
                                            }
                                            else
                                            {
                                                MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface on IID_IEnumUnknown failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                            }
                                        }
                                        else
                                        {
                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevice->get_Services() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                        }
                                        
                                        m_pUPnPService = NULL;
                                        hr = pUPnPServices->get_Item(CSimpleBStr(TEXT("upnp:id:SlideshowService")),&m_pUPnPService);
                                        if (S_OK == hr)
                                        {
                                            hr = m_pUPnPService->AddCallback( this );
                                            if (S_OK == hr)
                                            {
                                                WIA_TRACE((TEXT("m_pUPnPService->AddCallback SUCCEEDED!")));
                                                MessageBeep(-1);
                                            }
                                            else
                                            {
                                                MessageBox( m_hWnd, CSimpleString(TEXT("m_pUPnPService->AddCallback() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                            }
                                        }
                                        else
                                        {
                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPServices->get_Item() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                        }
                                    }
                                    else
                                    {
                                        MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevice->get_Services() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                    }
                                }
                                else
                                {
                                    MessageBox( m_hWnd, CSimpleString(TEXT("pDeviceUnknown->QueryInterface() failed on IID_IUPnPDevice\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                }
                            }
                            else
                            {
                                MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Next() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                            }
                        }
                        else
                        {
                            MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface() failed on IID_IEnumUnknown\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                        }
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevices->get__NewEnum() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                    }
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevices->get_Count() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDeviceFinder->FindByType() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString(TEXT("CoCreateInstance failed on CLSID_UPnPDeviceFinder\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
        }

    }

    void OnTestUniversalPnpSlideshowClientStop( WPARAM, LPARAM )
    {
        m_pUPnPService = NULL;
    }

    void OnPublishWizard( WPARAM, LPARAM )
    {
        LPTSTR pszFiles = new TCHAR[0xFFFF];
        if (pszFiles)
        {
            OPENFILENAME OpenFileName = {0};
            OpenFileName.lStructSize = sizeof(OPENFILENAME);
            OpenFileName.hwndOwner = m_hWnd;
            OpenFileName.hInstance = g_hInstance;
            OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            OpenFileName.lpstrFile = pszFiles;
            OpenFileName.nMaxFile = 0xFFFF;
            OpenFileName.lpstrTitle = TEXT("Choose Files to Upload");
            OpenFileName.Flags = OFN_ALLOWMULTISELECT|OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
            if (GetOpenFileName(&OpenFileName))
            {
                CMultiString strItems(pszFiles);

                if (strItems.Size())
                {
                    CSimpleDynamicArray<CSimpleString> strFiles;
                    if (strItems.Size() == 1)
                    {
                        strFiles.Append(strItems[0]);
                    }
                    else
                    {
                        CSimpleString strDirectory = strItems[0];
                        if (!strDirectory.MatchLastCharacter(TEXT('\\')))
                        {
                            strDirectory += TEXT("\\");
                        }
                        for (int i=1;i<strItems.Size();i++)
                        {
                            strFiles.Append(strDirectory + strItems[i]);
                        }
                    }
                    for (int i=0;i<strFiles.Size();i++)
                    {
                        WIA_TRACE((TEXT("strFiles[i] = %s"), strFiles[i].String()));
                    }
                    HRESULT hr = NetPublishingWizard::RunNetPublishingWizard( strFiles );
                    if (FAILED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("NetPublishingWizard::RunNetPublishingWizard returned")));
                    }
                }
            }
            delete[] pszFiles;
        }
    }

    void OnWiaSelectDeviceDlgId( WPARAM, LPARAM )
    {
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            BSTR bstrDeviceId = NULL;
            hr = pIWiaDevMgr->SelectDeviceDlgID( m_hWnd, SELECT_DEVICE_TYPE, 0, &bstrDeviceId );
            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                MessageBox( m_hWnd, CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrDeviceId)), TEXT("Device ID:"), MB_ICONINFORMATION );
            }
        }
        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("OnSelectDeviceDlgId returned")));
        }
    }

    void OnWiaWizard( WPARAM, LPARAM )
    {
        HRESULT hr = RunWiaWizard::RunWizard( NULL, m_hWnd );
        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("RunWiaWizard::RunWizard returned")));
        }
    }
    void OnMbox( WPARAM wParam, LPARAM )
    {
        LPCTSTR pszTitle = TEXT("Message Box Test Title");
        LPCTSTR pszMessage = TEXT("Message Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\n(LAST) Message Box Test Message");
        LPCTSTR pszFormat = TEXT("This is a formatted string: \"%s\", and this is a formatted number: %d");
        UINT nTitleId = IDS_MESSAGEBOXTESTTITLE;
        UINT nMessageId = IDS_MESSAGEBOXTESTMESSAGE;
        UINT nFormatId = IDS_MESSAGEBOXTESTFORMAT;
        UINT nFlags = m_nMessageBoxExFlags;
        bool bHideFutureMessages = true;
        HINSTANCE hInstance = g_hInstance;
        HWND hWndParent = m_hWnd;
        LPCTSTR pszTestString = TEXT("This is a test string");
        int nTestNumber = 1234567890;
        INT_PTR nResult = 0;
        switch (LOWORD(wParam))
        {
        case ID_MBOX_FORM1:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszMessage, pszTitle, nFlags, bHideFutureMessages );
            break;
        case ID_MBOX_FORM2:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszMessage, pszTitle, nFlags );
            break;
        case ID_MBOX_FORM3:
            nResult = CMessageBoxEx::MessageBox( pszMessage, pszTitle, nFlags );
            break;
        case ID_MBOX_FORM4:
            nResult = CMessageBoxEx::MessageBox( hWndParent, hInstance, nMessageId, nTitleId, nFlags, bHideFutureMessages );
            break;
        case ID_MBOX_FORM5:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszTitle, nFlags, pszFormat, pszTestString, nTestNumber );
            break;
        case ID_MBOX_FORM6:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszTitle, nFlags, bHideFutureMessages, pszFormat, pszTestString, nTestNumber );
            break;
        case ID_MBOX_FORM7:
            nResult = CMessageBoxEx::MessageBox( hWndParent, hInstance, nTitleId, nFlags, nFormatId, pszTestString, nTestNumber );
            break;
        }
        MessageBox( m_hWnd, CSimpleString().Format( TEXT("CMessageBoxEx::MessageBox returned %d, and the value of bHideFutureMessages is %d"), nResult, bHideFutureMessages ), TEXT("Result"), MB_ICONINFORMATION );
    }


    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(ID_PROGRAM_EXIT,OnFileExit);

            SC_HANDLE_COMMAND(ID_WIA_DEVICEDLG,OnWiaDeviceDlg);
            SC_HANDLE_COMMAND(ID_WIA_SELECTDEVICEID,OnWiaSelectDeviceDlgId);

            SC_HANDLE_COMMAND(ID_PROGRESS_TESTPROGRESS,OnProgressTestProgress);
            SC_HANDLE_COMMAND(ID_PROGRESS_SETFLAGS,OnProgressSetFlags);

            SC_HANDLE_COMMAND(ID_GDI_ROTATEFILENONJPEG,OnGdiRotateFileNonJpeg);
            SC_HANDLE_COMMAND(ID_GDI_ROTATEFILEJPEG,OnGdiRotateFileJpeg);
            SC_HANDLE_COMMAND(ID_GDI_ROTATEHBITMAP,OnGdiRotateHBITMAP);
            SC_HANDLE_COMMAND(ID_GDI_LOADANDSCALEIMAGE,OnGdiLoadAndScaleImage);
            SC_HANDLE_COMMAND(ID_GDI_LOADANDSCALESTREAM,OnGdiLoadAndScaleStream);

            SC_HANDLE_COMMAND(ID_GDI_CONVERTFILE,OnGdiConvertFile);
            SC_HANDLE_COMMAND(ID_GDI_DISPLAYDECODEREXTENSIONS,OnGdiDisplayDecoderExtensions);
            SC_HANDLE_COMMAND(ID_GDI_DISPLAYENCODEREXTENSIONS,OnGdiDisplayEncoderExtensions);
            SC_HANDLE_COMMAND(ID_GDI_SAVEMULTIPLEIMAGESASMULTIPAGE, OnGdiSaveMultipleImagesAsMultiPage);

            SC_HANDLE_COMMAND(ID_GDI_INCREASETHRESHOLD,OnGdiIncreaseThreshold);
            SC_HANDLE_COMMAND(ID_GDI_DECREASETHRESHOLD,OnGdiDecreaseThreshold);
            
            SC_HANDLE_COMMAND(ID_GDI_INCREASECONTRAST,OnGdiIncreaseContrast);
            SC_HANDLE_COMMAND(ID_GDI_DECREASECONTRAST,OnGdiDecreaseContrast);

            SC_HANDLE_COMMAND(ID_GDI_INCREASEBRIGHTNESS,OnGdiIncreaseBrightness);
            SC_HANDLE_COMMAND(ID_GDI_DECREASEBRIGHTNESS,OnGdiDecreaseBrightness);

            SC_HANDLE_COMMAND(ID_WIZARD_PUBLISH_WIZARD,OnPublishWizard);
            SC_HANDLE_COMMAND(ID_WIZARD_ACQUIRE_WIZARD,OnWiaWizard);
            SC_HANDLE_COMMAND(ID_WIZARD_EXPLOREWIADEVICE,OnExploreWiaDevice);

            SC_HANDLE_COMMAND(ID_MBOX_FORM1,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM2,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM3,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM4,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM5,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM6,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM7,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_SETFLAGS,OnMBoxSetFlags);

            SC_HANDLE_COMMAND(ID_UPNP_FINDSERVERANDREGISTER,OnTestUniversalPnpSlideshowClient);
            SC_HANDLE_COMMAND(ID_UPNP_STOP,OnTestUniversalPnpSlideshowClientStop);
        }
        SC_END_COMMAND_HANDLERS();
    }

    void FillRect( HDC hDC, int nLeft, int nTop, int nRight, int nBottom, HBRUSH hBrush )
    {
        RECT rcFill = {nLeft,nTop,nRight,nBottom};
        if (nLeft < nRight && nTop < nBottom)
        {
            ::FillRect( hDC, &rcFill, hBrush );
        }
    }

    void FillRectDifference( HDC hDC, const RECT &rcMain, const RECT &rcDiff, HBRUSH hBrush )
    {
        //
        // Top
        //
        FillRect( hDC, rcMain.left, rcMain.top, rcMain.right, rcDiff.top, hBrush );
        //
        // Bottom
        //
        FillRect( hDC, rcMain.left, rcDiff.bottom, rcMain.right, rcMain.bottom, hBrush );

        //
        // Left
        //
        FillRect( hDC, rcMain.left, rcDiff.top, rcDiff.left, rcDiff.bottom, hBrush );

        //
        // Right
        //
        FillRect( hDC, rcDiff.right, rcDiff.top, rcMain.right, rcMain.bottom, hBrush );
    }

    LRESULT OnEraseBkGnd( WPARAM, LPARAM )
    {
        return TRUE;
    }

    LRESULT OnSize( WPARAM, LPARAM )
    {
        InvalidateRect( m_hWnd, NULL, FALSE );
        UpdateWindow( m_hWnd );
        return 0;
    }

    LRESULT OnPaint( WPARAM, LPARAM )
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint( m_hWnd, &ps );
        if (hDC)
        {
            HBITMAP hBitmap = m_hOriginalBitmap;
            if (m_hTransformedBitmap)
            {
                hBitmap = m_hTransformedBitmap;
            }
            if (hBitmap)
            {
                BITMAP bm = {0};
                if (GetObject(hBitmap,sizeof(BITMAP),&bm))
                {
                    HDC hCompatDC = CreateCompatibleDC(hDC);
                    if (hCompatDC)
                    {
                        RECT rcClient;
                        GetClientRect( m_hWnd, &rcClient );

                        RECT rcImage;
                        rcImage.left = rcClient.left + (WiaUiUtil::RectWidth(rcClient)-bm.bmWidth)/2;
                        rcImage.top = rcClient.left + (WiaUiUtil::RectHeight(rcClient)-bm.bmHeight)/2;
                        rcImage.right = rcImage.left + bm.bmWidth;
                        rcImage.bottom = rcImage.top + bm.bmHeight;

                        HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hCompatDC,hBitmap));

                        BitBlt( hDC, rcImage.left, rcImage.top, bm.bmWidth, bm.bmHeight, hCompatDC, 0, 0, SRCCOPY );

                        FillRectDifference( hDC, rcClient, rcImage, GetStockBrush(BLACK_BRUSH) );

                        SelectObject(hCompatDC,hOldBitmap);

                        DeleteDC(hCompatDC);
                    }
                }
            }
            EndPaint( m_hWnd, &ps );
        }
        return 0;
    }

    LRESULT OnInitMenu( WPARAM wParam, LPARAM )
    {
        HMENU hMenu = reinterpret_cast<HMENU>(wParam);
        if (hMenu)
        {
            EnableMenuItem( hMenu, ID_UPNP_FINDSERVERANDREGISTER, m_pUPnPService ? MF_GRAYED|MF_BYCOMMAND : MF_ENABLED|MF_BYCOMMAND );
            EnableMenuItem( hMenu, ID_UPNP_STOP, m_pUPnPService ? MF_ENABLED|MF_BYCOMMAND : MF_GRAYED|MF_BYCOMMAND );
        }
        return 0;
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CMiscUnitTestWindow)
        {
            SC_HANDLE_MESSAGE( WM_DESTROY, OnDestroy );
            SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
            SC_HANDLE_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkGnd );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_INITMENU, OnInitMenu );
            SC_HANDLE_MESSAGE( PWM_DISPLAYNEWIMAGE, OnDisplayNewImage );
        }
        SC_END_MESSAGE_HANDLERS();
    }

public:
    static bool RegisterClass( HINSTANCE hInstance, LPCTSTR pszClassName )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        if (!GetClassInfoEx( hInstance, pszClassName, &wcex ))
        {
            ZeroMemory(&wcex,sizeof(wcex));
            wcex.cbSize = sizeof(wcex);
            wcex.style = 0;
            wcex.lpfnWndProc = WndProc;
            wcex.cbClsExtra = 0;
            wcex.cbWndExtra = 0;
            wcex.hInstance = hInstance;
            wcex.hIcon = 0;
            wcex.hCursor = ::LoadCursor(NULL, IDC_ARROW);
            wcex.hbrBackground = NULL;
            wcex.lpszMenuName = NULL;
            wcex.lpszClassName = pszClassName;
            wcex.hIconSm = 0;
            if (!::RegisterClassEx(&wcex))
            {
                ::MessageBox( NULL, TEXT("Unable to register Main Window"), TEXT("PLUGTEST"), 0 );
                return(false);
            }
            return(true);
        }
        return(true);
    }
    static HWND Create( DWORD dwExStyle,
                        LPCTSTR lpWindowName,
                        DWORD dwStyle,
                        int x,
                        int y,
                        int nWidth,
                        int nHeight,
                        HWND hWndParent,
                        HMENU hMenu,
                        HINSTANCE hInstance )
    {
        if (RegisterClass( hInstance, TEXT("TestAcqdWindow") ))
            return(CreateWindowEx( dwExStyle, TEXT("TestAcqdWindow"), lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, NULL ));
        return(NULL);
    }

    LRESULT OnDisplayNewImage( WPARAM, LPARAM lParam )
    {
        LPWSTR pszNewImage = reinterpret_cast<LPWSTR>(lParam);
        if (pszNewImage)
        {
            WIA_TRACE((TEXT("pszNewImage: %ws"), pszNewImage ));

            CComPtr<IStream> pStream;
            HRESULT hr = URLOpenBlockingStream( NULL, pszNewImage, &pStream, 0, NULL );
            if (SUCCEEDED(hr))
            {
                HBITMAP hNewBitmap = NULL;
                hr = CGdiPlusHelper().LoadAndScale( hNewBitmap, pStream, 800, 600, false );
                if (SUCCEEDED(hr))
                {
                    DestroyBitmap(false);
                    m_hOriginalBitmap = hNewBitmap;
                    InvalidateRect( m_hWnd, NULL, FALSE );
                    UpdateWindow(m_hWnd);
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("GdiPlusHelper.LoadAndScale failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("URLOpenBlockingStream failed")));
            }
            delete[] pszNewImage;
        }
        return 0;
    }

    STDMETHODIMP StateVariableChanged( IUPnPService * pus, LPCWSTR pcwszStateVarName, VARIANT vaValue )
    {
        WIA_TRACE((TEXT("StateVariableChanged( %p, %ws, %ws )"), pus, pcwszStateVarName, CWiaDebugDump::GetPrintableValue(vaValue).String() ));

        if (!lstrcmpW(pcwszStateVarName,L"CurrentImageURL"))
        {
            if (VT_BSTR == vaValue.vt)
            {
                if (vaValue.bstrVal)
                {
                    LPWSTR pszNewImage = new WCHAR[lstrlenW(vaValue.bstrVal)+1];
                    if (pszNewImage)
                    {
                        lstrcpyW( pszNewImage, vaValue.bstrVal );
                        WIA_TRACE((TEXT("pszNewImage: %ws"), pszNewImage ));
                        PostMessage( m_hWnd, PWM_DISPLAYNEWIMAGE, 0, reinterpret_cast<LPARAM>(pszNewImage) );
                    }
                }
            }
        }
        return S_OK;
    }

    STDMETHODIMP ServiceInstanceDied( IUPnPService* pus )
    {
        return S_OK;
    }



    STDMETHODIMP QueryInterface(const IID& iid, void** ppvObject)
    {
        if ((iid==IID_IUnknown) || (iid==IID_IUPnPServiceCallback))
        {
            *ppvObject = static_cast<LPVOID>(this);
        }
        else
        {
            *ppvObject = NULL;
            return(E_NOINTERFACE);
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
        return(S_OK);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return 1;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }

};


int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    HRESULT hr = CoInitialize(NULL);
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_LISTVIEW_CLASSES | ICC_WIN95_CLASSES |ICC_BAR_CLASSES | ICC_LINK_CLASS;
    InitCommonControlsEx(&icc);
    if (SUCCEEDED(hr))
    {
        HWND hwndMain = CMiscUnitTestWindow::Create( 0,
                                             TEXT("Random Unit Test Program"),
                                             WS_OVERLAPPEDWINDOW,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             NULL,
                                             LoadMenu( hInstance, MAKEINTRESOURCE(IDR_TESTACQDMENU) ),
                                             hInstance );
        if (!hwndMain)
        {
            MessageBox(NULL, TEXT("Unable to create plugin test window"), TEXT("TESTACQD"), MB_OK);
            return(FALSE);
        }
        ShowWindow(hwndMain, SW_SHOW);
        UpdateWindow(hwndMain);

        HACCEL hAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE(IDR_TESTACQDACCEL) );
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
        {
            if (!TranslateAccelerator( hwndMain, hAccel, &msg ))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CoUninitialize();
    }
    WIA_DEBUG_DESTROY();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\taggen\taggen.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <gdiplus.h>

struct CStringEntry
{
    ULONG       nId;
    const wchar_t *pszString;
};

#define MKFLAG(x) { (x), L#x }

const wchar_t *GetStringFromTable( const CStringEntry *pStrings, UINT nSize, ULONG nId, wchar_t *pszUnknownBuffer )
{
    for (UINT i=0;i<nSize;i++)
    {
        if (pStrings[i].nId == nId)
        {
            return pStrings[i].pszString;
        }
    }
    wsprintfW( pszUnknownBuffer, L"Unknown value: %d (0x%X)", nId, nId );
    return pszUnknownBuffer;
}

void DumpImageProperty( Gdiplus::PropertyItem* pPropertyItem )
{
    static CStringEntry s_PropertyTypes[] =
    {
        MKFLAG(PropertyTagTypeByte),
        MKFLAG(PropertyTagTypeASCII),
        MKFLAG(PropertyTagTypeShort),
        MKFLAG(PropertyTagTypeLong),
        MKFLAG(PropertyTagTypeRational),
        MKFLAG(PropertyTagTypeUndefined),
        MKFLAG(PropertyTagTypeSLONG),
        MKFLAG(PropertyTagTypeSRational)


    };
    
    static CStringEntry s_PropertyIds[] =
    {
        MKFLAG(PropertyTagArtist),
        MKFLAG(PropertyTagBitsPerSample),
        MKFLAG(PropertyTagCellHeight),
        MKFLAG(PropertyTagCellWidth),
        MKFLAG(PropertyTagChrominanceTable),
        MKFLAG(PropertyTagColorMap),
        MKFLAG(PropertyTagColorTransferFunction),
        MKFLAG(PropertyTagCompression),
        MKFLAG(PropertyTagCopyright),
        MKFLAG(PropertyTagDateTime),
        MKFLAG(PropertyTagDocumentName),
        MKFLAG(PropertyTagDotRange),
        MKFLAG(PropertyTagEquipMake),
        MKFLAG(PropertyTagEquipModel),
        MKFLAG(PropertyTagExifAperture),
        MKFLAG(PropertyTagExifBrightness),
        MKFLAG(PropertyTagExifCfaPattern),
        MKFLAG(PropertyTagExifColorSpace),
        MKFLAG(PropertyTagExifCompBPP),
        MKFLAG(PropertyTagExifCompConfig),
        MKFLAG(PropertyTagExifDTDigSS),
        MKFLAG(PropertyTagExifDTDigitized),
        MKFLAG(PropertyTagExifDTOrig),
        MKFLAG(PropertyTagExifDTOrigSS),
        MKFLAG(PropertyTagExifDTSubsec),
        MKFLAG(PropertyTagExifExposureBias),
        MKFLAG(PropertyTagExifExposureIndex),
        MKFLAG(PropertyTagExifExposureProg),
        MKFLAG(PropertyTagExifExposureTime),
        MKFLAG(PropertyTagExifFNumber),
        MKFLAG(PropertyTagExifFPXVer),
        MKFLAG(PropertyTagExifFileSource),
        MKFLAG(PropertyTagExifFlash),
        MKFLAG(PropertyTagExifFlashEnergy),
        MKFLAG(PropertyTagExifFocalLength),
        MKFLAG(PropertyTagExifFocalResUnit),
        MKFLAG(PropertyTagExifFocalXRes),
        MKFLAG(PropertyTagExifFocalYRes),
        MKFLAG(PropertyTagExifIFD),
        MKFLAG(PropertyTagExifISOSpeed),
        MKFLAG(PropertyTagExifInterop),
        MKFLAG(PropertyTagExifLightSource),
        MKFLAG(PropertyTagExifMakerNote),
        MKFLAG(PropertyTagExifMaxAperture),
        MKFLAG(PropertyTagExifMeteringMode),
        MKFLAG(PropertyTagExifOECF),
        MKFLAG(PropertyTagExifPixXDim),
        MKFLAG(PropertyTagExifPixYDim),
        MKFLAG(PropertyTagExifRelatedWav),
        MKFLAG(PropertyTagExifSceneType),
        MKFLAG(PropertyTagExifSensingMethod),
        MKFLAG(PropertyTagExifShutterSpeed),
        MKFLAG(PropertyTagExifSpatialFR),
        MKFLAG(PropertyTagExifSpectralSense),
        MKFLAG(PropertyTagExifSubjectDist),
        MKFLAG(PropertyTagExifSubjectLoc),
        MKFLAG(PropertyTagExifUserComment),
        MKFLAG(PropertyTagExifVer),
        MKFLAG(PropertyTagExtraSamples),
        MKFLAG(PropertyTagFillOrder),
        MKFLAG(PropertyTagFrameDelay),
        MKFLAG(PropertyTagFreeByteCounts),
        MKFLAG(PropertyTagFreeOffset),
        MKFLAG(PropertyTagGamma),
        MKFLAG(PropertyTagGpsAltitude),
        MKFLAG(PropertyTagGpsAltitudeRef),
        MKFLAG(PropertyTagGpsDestBear),
        MKFLAG(PropertyTagGpsDestBearRef),
        MKFLAG(PropertyTagGpsDestDist),
        MKFLAG(PropertyTagGpsDestDistRef),
        MKFLAG(PropertyTagGpsDestLat),
        MKFLAG(PropertyTagGpsDestLatRef),
        MKFLAG(PropertyTagGpsDestLong),
        MKFLAG(PropertyTagGpsDestLongRef),
        MKFLAG(PropertyTagGpsGpsDop),
        MKFLAG(PropertyTagGpsGpsMeasureMode),
        MKFLAG(PropertyTagGpsGpsSatellites),
        MKFLAG(PropertyTagGpsGpsStatus),
        MKFLAG(PropertyTagGpsGpsTime),
        MKFLAG(PropertyTagGpsIFD),
        MKFLAG(PropertyTagGpsImgDir),
        MKFLAG(PropertyTagGpsImgDirRef),
        MKFLAG(PropertyTagGpsLatitude),
        MKFLAG(PropertyTagGpsLatitudeRef),
        MKFLAG(PropertyTagGpsLongitude),
        MKFLAG(PropertyTagGpsLongitudeRef),
        MKFLAG(PropertyTagGpsMapDatum),
        MKFLAG(PropertyTagGpsSpeed),
        MKFLAG(PropertyTagGpsSpeedRef),
        MKFLAG(PropertyTagGpsTrack),
        MKFLAG(PropertyTagGpsTrackRef),
        MKFLAG(PropertyTagGpsVer),
        MKFLAG(PropertyTagGrayResponseCurve),
        MKFLAG(PropertyTagGrayResponseUnit),
        MKFLAG(PropertyTagGridSize),
        MKFLAG(PropertyTagHalftoneDegree),
        MKFLAG(PropertyTagHalftoneHints),
        MKFLAG(PropertyTagHalftoneLPI),
        MKFLAG(PropertyTagHalftoneLPIUnit),
        MKFLAG(PropertyTagHalftoneMisc),
        MKFLAG(PropertyTagHalftoneScreen),
        MKFLAG(PropertyTagHalftoneShape),
        MKFLAG(PropertyTagHostComputer),
        MKFLAG(PropertyTagICCProfile),
        MKFLAG(PropertyTagICCProfileDescriptor),
        MKFLAG(PropertyTagImageDescription),
        MKFLAG(PropertyTagImageHeight),
        MKFLAG(PropertyTagImageTitle),
        MKFLAG(PropertyTagImageWidth),
        MKFLAG(PropertyTagInkNames),
        MKFLAG(PropertyTagInkSet),
        MKFLAG(PropertyTagJPEGACTables),
        MKFLAG(PropertyTagJPEGDCTables),
        MKFLAG(PropertyTagJPEGInterFormat),
        MKFLAG(PropertyTagJPEGInterLength),
        MKFLAG(PropertyTagJPEGLosslessPredictors),
        MKFLAG(PropertyTagJPEGPointTransforms),
        MKFLAG(PropertyTagJPEGProc),
        MKFLAG(PropertyTagJPEGQTables),
        MKFLAG(PropertyTagJPEGQuality),
        MKFLAG(PropertyTagJPEGRestartInterval),
        MKFLAG(PropertyTagLoopCount),
        MKFLAG(PropertyTagLuminanceTable),
        MKFLAG(PropertyTagMaxSampleValue),
        MKFLAG(PropertyTagMinSampleValue),
        MKFLAG(PropertyTagNewSubfileType),
        MKFLAG(PropertyTagNumberOfInks),
        MKFLAG(PropertyTagOrientation),
        MKFLAG(PropertyTagPageName),
        MKFLAG(PropertyTagPageNumber),
        MKFLAG(PropertyTagPaletteHistogram),
        MKFLAG(PropertyTagPhotometricInterp),
        MKFLAG(PropertyTagPixelPerUnitX),
        MKFLAG(PropertyTagPixelPerUnitY),
        MKFLAG(PropertyTagPixelUnit),
        MKFLAG(PropertyTagPlanarConfig),
        MKFLAG(PropertyTagPredictor),
        MKFLAG(PropertyTagPrimaryChromaticities),
        MKFLAG(PropertyTagPrintFlags),
        MKFLAG(PropertyTagPrintFlagsBleedWidth),
        MKFLAG(PropertyTagPrintFlagsBleedWidthScale),
        MKFLAG(PropertyTagPrintFlagsCrop),
        MKFLAG(PropertyTagPrintFlagsVersion),
        MKFLAG(PropertyTagREFBlackWhite),
        MKFLAG(PropertyTagResolutionUnit),
        MKFLAG(PropertyTagResolutionXLengthUnit),
        MKFLAG(PropertyTagResolutionXUnit),
        MKFLAG(PropertyTagResolutionYLengthUnit),
        MKFLAG(PropertyTagResolutionYUnit),
        MKFLAG(PropertyTagRowsPerStrip),
        MKFLAG(PropertyTagSMaxSampleValue),
        MKFLAG(PropertyTagSMinSampleValue),
        MKFLAG(PropertyTagSRGBRenderingIntent),
        MKFLAG(PropertyTagSampleFormat),
        MKFLAG(PropertyTagSamplesPerPixel),
        MKFLAG(PropertyTagSoftwareUsed),
        MKFLAG(PropertyTagStripBytesCount),
        MKFLAG(PropertyTagStripOffsets),
        MKFLAG(PropertyTagSubfileType),
        MKFLAG(PropertyTagT4Option),
        MKFLAG(PropertyTagT6Option),
        MKFLAG(PropertyTagTargetPrinter),
        MKFLAG(PropertyTagThreshHolding),
        MKFLAG(PropertyTagThumbnailArtist),
        MKFLAG(PropertyTagThumbnailBitsPerSample),
        MKFLAG(PropertyTagThumbnailColorDepth),
        MKFLAG(PropertyTagThumbnailCompressedSize),
        MKFLAG(PropertyTagThumbnailCompression),
        MKFLAG(PropertyTagThumbnailCopyRight),
        MKFLAG(PropertyTagThumbnailData),
        MKFLAG(PropertyTagThumbnailDateTime),
        MKFLAG(PropertyTagThumbnailEquipMake),
        MKFLAG(PropertyTagThumbnailEquipModel),
        MKFLAG(PropertyTagThumbnailFormat),
        MKFLAG(PropertyTagThumbnailHeight),
        MKFLAG(PropertyTagThumbnailImageDescription),
        MKFLAG(PropertyTagThumbnailImageHeight),
        MKFLAG(PropertyTagThumbnailImageWidth),
        MKFLAG(PropertyTagThumbnailOrientation),
        MKFLAG(PropertyTagThumbnailPhotometricInterp),
        MKFLAG(PropertyTagThumbnailPlanarConfig),
        MKFLAG(PropertyTagThumbnailPlanes),
        MKFLAG(PropertyTagThumbnailPrimaryChromaticities),
        MKFLAG(PropertyTagThumbnailRawBytes),
        MKFLAG(PropertyTagThumbnailRefBlackWhite),
        MKFLAG(PropertyTagThumbnailResolutionUnit),
        MKFLAG(PropertyTagThumbnailResolutionX),
        MKFLAG(PropertyTagThumbnailResolutionY),
        MKFLAG(PropertyTagThumbnailRowsPerStrip),
        MKFLAG(PropertyTagThumbnailSamplesPerPixel),
        MKFLAG(PropertyTagThumbnailSize),
        MKFLAG(PropertyTagThumbnailSoftwareUsed),
        MKFLAG(PropertyTagThumbnailStripBytesCount),
        MKFLAG(PropertyTagThumbnailStripOffsets),
        MKFLAG(PropertyTagThumbnailTransferFunction),
        MKFLAG(PropertyTagThumbnailWhitePoint),
        MKFLAG(PropertyTagThumbnailWidth),
        MKFLAG(PropertyTagThumbnailYCbCrCoefficients),
        MKFLAG(PropertyTagThumbnailYCbCrPositioning),
        MKFLAG(PropertyTagThumbnailYCbCrSubsampling),
        MKFLAG(PropertyTagTileByteCounts),
        MKFLAG(PropertyTagTileLength),
        MKFLAG(PropertyTagTileOffset),
        MKFLAG(PropertyTagTileWidth),
        MKFLAG(PropertyTagTransferFuncition),
        MKFLAG(PropertyTagTransferRange),
        MKFLAG(PropertyTagWhitePoint),
        MKFLAG(PropertyTagXPosition),
        MKFLAG(PropertyTagXResolution),
        MKFLAG(PropertyTagYCbCrCoefficients),
        MKFLAG(PropertyTagYCbCrPositioning),
        MKFLAG(PropertyTagYCbCrSubsampling),
        MKFLAG(PropertyTagYPosition),
        MKFLAG(PropertyTagYResolution)
    };

    wchar_t szUnknownBuffer[256];
    wprintf( L"Property: %ws, ", GetStringFromTable( s_PropertyIds, sizeof(s_PropertyIds)/sizeof(s_PropertyIds[0]), pPropertyItem->id, szUnknownBuffer ) );
    wprintf( L"%ws, ", GetStringFromTable( s_PropertyTypes, sizeof(s_PropertyTypes)/sizeof(s_PropertyTypes[0]), pPropertyItem->type, szUnknownBuffer ) );
    wprintf( L"%d\n", pPropertyItem->length );

    switch (pPropertyItem->type)
    {
        //
        // ASCII text
        //
    case PropertyTagTypeASCII:
        {
            wprintf( L"%S\n", pPropertyItem->value );
        }
        break;

        //
        // Unsigned 16 bit integer
        //
    case PropertyTagTypeShort:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(USHORT);i++)
            {
                if (i)
                {
                    if (!(i%14))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%04X", reinterpret_cast<PUSHORT>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Two unsigned 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(ULONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // Two signed 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeSRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(LONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // 32 bit unsigned integers
        //
    case PropertyTagTypeLong:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(ULONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PULONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;
    
        //
        // 32 bit signed integers
        //
    case PropertyTagTypeSLONG:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(LONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PLONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Buncha bytes and everything else
        //
    default:
    case PropertyTagTypeByte:
    case PropertyTagTypeUndefined:
        {
            for (UINT i=0;i<pPropertyItem->length;i++)
            {
                if (i && !(i%4))
                {
                    if (!(i%32))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%02X", reinterpret_cast<PBYTE>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

    }
    wprintf( L"\n" );
}


void DumpImageProperties( LPCWSTR pwszImage )
{
    Gdiplus::Image Image(pwszImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        UINT nPropertyCount = Image.GetPropertyCount();
        if (nPropertyCount)
        {
            PROPID* pPropIdList = new PROPID[nPropertyCount];
            if (pPropIdList)
            {
                if (Gdiplus::Ok == Image.GetPropertyIdList(nPropertyCount, pPropIdList))
                {
                    UINT nItemSize = 0;
                    if (Gdiplus::Ok == Image.GetPropertySize(&nItemSize, &nPropertyCount))
                    {
                        Gdiplus::PropertyItem *pPropertyItems = reinterpret_cast<Gdiplus::PropertyItem*>(LocalAlloc(LPTR,nItemSize));
                        if (pPropertyItems)
                        {
                            if (Gdiplus::Ok == Image.GetAllPropertyItems( nItemSize, nPropertyCount, pPropertyItems ))
                            {
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                wprintf( L"Dumping properties for %s\n", pwszImage );
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                Gdiplus::PropertyItem *pCurr = pPropertyItems;
                                for (UINT i=0;i<nPropertyCount;i++)
                                {
                                    DumpImageProperty(pCurr++);
                                }
                            }
                            LocalFree(pPropertyItems);
                        }
                    }
                }
                delete[] pPropIdList;
            }
        }
    }
}

BOOL GetEncoderList(Gdiplus::ImageCodecInfo** pEncoders, UINT* pcEncoders)
{
    if (pEncoders == NULL || pcEncoders == NULL)
        return FALSE;
    
    // lets pick up the list of encoders, first we get the encoder size which
    // gives us the CB and the number of encoders that are installed on the
    // machine.

    UINT cb;
    if (Gdiplus::Ok == Gdiplus::GetImageEncodersSize(pcEncoders, &cb))
    {
        // allocate the buffer for the encoders and then fill it
        // with the encoder list.

        *pEncoders = (Gdiplus::ImageCodecInfo*)LocalAlloc(LPTR, cb);
        if (*pEncoders != NULL)
        {
            if (Gdiplus::Ok != Gdiplus::GetImageEncoders(*pcEncoders, cb, *pEncoders))
            {
                LocalFree(*pEncoders);
                *pEncoders = NULL;
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    UINT cEncoders;
    BOOL bResult = FALSE;
    Gdiplus::ImageCodecInfo* pEncoders = NULL;
    if (GetEncoderList(&pEncoders, &cEncoders))
    {
        for (UINT i = 0; i != cEncoders; i++)
        {
            if (pEncoders[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = pEncoders[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                bResult = TRUE;
                break;
            }
        }
    }
    
    if (pEncoders != NULL)
        LocalFree(pEncoders);
    
    return bResult;
}

void AddEncParameter(Gdiplus::EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}

void WriteProperty(LPCWSTR pwszSrcImage, LPCWSTR pwszDestImage, LPCWSTR pwszDesc, PROPID propid, WORD proptype, VOID* pValue, ULONG cbValue)
{
    CLSID clsidEncoder;
    int iQuality = 100;
    Gdiplus::EncoderParameters ep[2] = { 0 };
    GUID guidFmt = Gdiplus::ImageFormatJPEG;
    
    Gdiplus::Image Image(pwszSrcImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        Gdiplus::PropertyItem pi;

        pi.id = propid;
        pi.length = cbValue;
        pi.type = proptype;
        pi.value = pValue;

        if (Gdiplus::Ok == Image.SetPropertyItem(&pi))
        {
            Gdiplus::Graphics* pGraphics = Gdiplus::Graphics::FromImage(&Image);
            if (pGraphics != NULL && Gdiplus::Ok == pGraphics->GetLastStatus())
            {
                Gdiplus::Font fnt(L"Arial", 15);
                Gdiplus::Color clr(0xff, 0xff, 0xff);
                Gdiplus::SolidBrush brsh(clr);
            
                Gdiplus::RectF rect(0,0,300,300);
                Gdiplus::GpStatus nResult = pGraphics->DrawString(pwszDesc, -1, &fnt, rect, NULL, &brsh);
                if (Gdiplus::Ok == nResult)
                {
                    AddEncParameter(ep, Gdiplus::EncoderQuality, Gdiplus::EncoderParameterValueTypeLong, &iQuality);
                    if (GetEncoderFromFormat(&guidFmt, &clsidEncoder))
                    {
                        Image.Save(pwszDestImage, &clsidEncoder, ep);
                    }
                }
                delete pGraphics;
            }
        }
    }
}

BOOL CreateTempJPG(LPCWSTR pwszImage)
{
    CLSID clsidEncoder;
    int iQuality = 100;
    Gdiplus::EncoderParameters ep[2] = { 0 };
    GUID guidFmt = Gdiplus::ImageFormatJPEG;
    
    HDC hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;
    
    Gdiplus::Graphics* pGraphics = Gdiplus::Graphics::FromHDC(hdc);
    if (pGraphics == NULL || Gdiplus::Ok != pGraphics->GetLastStatus())
        return FALSE;

    Gdiplus::Bitmap Bitmap(300, 300, pGraphics);
    if (Gdiplus::Ok != Bitmap.GetLastStatus())
        goto Cleanup;

    AddEncParameter(ep, Gdiplus::EncoderQuality, Gdiplus::EncoderParameterValueTypeLong, &iQuality);

    if (!GetEncoderFromFormat(&guidFmt, &clsidEncoder))
        goto Cleanup;

    if (Gdiplus::Ok != Bitmap.Save(pwszImage, &clsidEncoder, ep))
        goto Cleanup;

    delete pGraphics;
    
    return TRUE;
Cleanup:
    if (pGraphics)
        delete pGraphics;
    return FALSE;
}

void CreateExposureTimeTests(LPCWSTR lpTemp)
{
    ULONG Rational[2];

    Rational[0] = 30; Rational[1] = 1;
    WriteProperty(lpTemp, L"et30sec.jpg", L"ExposureTime\n30 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 1;
    WriteProperty(lpTemp, L"et20sec.jpg", L"ExposureTime\n20 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 15; Rational[1] = 1;
    WriteProperty(lpTemp, L"et15sec.jpg", L"ExposureTime\n15 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10; Rational[1] = 1;
    WriteProperty(lpTemp, L"et10sec.jpg", L"ExposureTime\n10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8; Rational[1] = 1;
    WriteProperty(lpTemp, L"et08sec.jpg", L"ExposureTime\n8 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6; Rational[1] = 1;
    WriteProperty(lpTemp, L"et06sec.jpg", L"ExposureTime\n6 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4; Rational[1] = 2;
    WriteProperty(lpTemp, L"et04sec.jpg", L"ExposureTime\n4 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 1;
    WriteProperty(lpTemp, L"et03sec.jpg", L"ExposureTime\n3 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"et02sec.jpg", L"ExposureTime\n2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 2;
    WriteProperty(lpTemp, L"et3_2ndssec.jpg", L"ExposureTime\n3/2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"et1sec.jpg", L"ExposureTime\n1 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 7; Rational[1] = 10;
    WriteProperty(lpTemp, L"et7_10thssec.jpg", L"ExposureTime\n7/10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"et1_2ndsec.jpg", L"ExposureTime\n1/2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"et1_3rdsec.jpg", L"ExposureTime\n1/3 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 4;
    WriteProperty(lpTemp, L"et1_4thsec.jpg", L"ExposureTime\n1/4 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 6;
    WriteProperty(lpTemp, L"et1_6thsec.jpg", L"ExposureTime\n1/6 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 8;
    WriteProperty(lpTemp, L"et1_8thsec.jpg", L"ExposureTime\n1/8 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 10;
    WriteProperty(lpTemp, L"et1_10thsec.jpg", L"ExposureTime\n1/10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 15;
    WriteProperty(lpTemp, L"et1_15thsec.jpg", L"ExposureTime\n1/15 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 20;
    WriteProperty(lpTemp, L"et1_20thsec.jpg", L"ExposureTime\n1/20 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 30;
    WriteProperty(lpTemp, L"et1_30thsec.jpg", L"ExposureTime\n1/30 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 45;
    WriteProperty(lpTemp, L"et1_45thsec.jpg", L"ExposureTime\n1/45 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 60;
    WriteProperty(lpTemp, L"et1_60thsec.jpg", L"ExposureTime\n1/60 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 90;
    WriteProperty(lpTemp, L"et1_90thsec.jpg", L"ExposureTime\n1/90 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 125;
    WriteProperty(lpTemp, L"et1_125thsec.jpg", L"ExposureTime\n1/125 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 180;
    WriteProperty(lpTemp, L"et1_180thsec.jpg", L"ExposureTime\n1/180 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 250;
    WriteProperty(lpTemp, L"et1_250thsec.jpg", L"ExposureTime\n1/250 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 350;
    WriteProperty(lpTemp, L"et1_350thsec.jpg", L"ExposureTime\n1/350 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 500;
    WriteProperty(lpTemp, L"et1_500thsec.jpg", L"ExposureTime\n1/500 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 750;
    WriteProperty(lpTemp, L"et1_750thsec.jpg", L"ExposureTime\n1/750 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1000;
    WriteProperty(lpTemp, L"et1_1000thsec.jpg", L"ExposureTime\n1/1000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1500;
    WriteProperty(lpTemp, L"et1_1500thsec.jpg", L"ExposureTime\n1/1500 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2000;
    WriteProperty(lpTemp, L"et1_2000thsec.jpg", L"ExposureTime\n1/2000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3000;
    WriteProperty(lpTemp, L"et1_3000thsec.jpg", L"ExposureTime\n1/3000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 4000;
    WriteProperty(lpTemp, L"et1_4000thsec.jpg", L"ExposureTime\n1/4000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateShutterSpeed(LPCWSTR lpTemp)
{
    LONG Rational[2];

    Rational[0] = -4907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss30sec.jpg", L"ShutterSpeed\n-4.907 APEX =~ 30 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -4322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss20sec.jpg", L"ShutterSpeed\n-4.322 APEX =~ 20 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss15sec.jpg", L"ShutterSpeed\n-3.907 APEX =~ 15 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss10sec.jpg", L"ShutterSpeed\n-3.322 APEX =~ 10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss08sec.jpg", L"ShutterSpeed\n-3.000 APEX =~ 8 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss06sec.jpg", L"ShutterSpeed\n-2.585 APEX =~ 6 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss04sec.jpg", L"ShutterSpeed\n-2.000 APEX =~ 4 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss03sec.jpg", L"ShutterSpeed\n-1.585 APEX =~ 3 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss02sec.jpg", L"ShutterSpeed\n-1.000 APEX =~ 2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss3_2ndssec.jpg", L"ShutterSpeed\n-0.585 APEX =~ 3/2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 0; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1sec.jpg", L"ShutterSpeed\n0 APEX =~ 1 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 515; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss7_10thssec.jpg", L"ShutterSpeed\n0.515 APEX =~ 7/10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_2ndsec.jpg", L"ShutterSpeed\n1.000 APEX =~ 1/2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_3rdsec.jpg", L"ShutterSpeed\n1.585 APEX =~ 1/3 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_4thsec.jpg", L"ShutterSpeed\n2.000 APEX =~ 1/4 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_6thsec.jpg", L"ShutterSpeed\n2.585 APEX =~ 1/6 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_8thsec.jpg", L"ShutterSpeed\n3.000 APEX =~ 1/8 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_10thsec.jpg", L"ShutterSpeed\n3.322 APEX =~ 1/10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_15thsec.jpg", L"ShutterSpeed\n3.907 APEX =~ 1/15 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_20thsec.jpg", L"ShutterSpeed\n4.322 APEX =~ 1/20 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_30thsec.jpg", L"ShutterSpeed\n4.907 APEX =~ 1/30 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_45thsec.jpg", L"ShutterSpeed\n5.492 APEX =~ 1/45 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_60thsec.jpg", L"ShutterSpeed\n5.907 APEX =~ 1/60 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 6492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_90thsec.jpg", L"ShutterSpeed\n6.492 APEX =~ 1/90 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 6966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_125thsec.jpg", L"ShutterSpeed\n6.966 APEX =~ 1/125 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 7492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_180thsec.jpg", L"ShutterSpeed\n7.492 APEX =~ 1/180 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 7966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_250thsec.jpg", L"ShutterSpeed\n7.966 APEX =~ 1/250 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 8452; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_350thsec.jpg", L"ShutterSpeed\n8.452 APEX =~ 1/350 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 8966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_500thsec.jpg", L"ShutterSpeed\n8.966 APEX =~ 1/500 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 9551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_750thsec.jpg", L"ShutterSpeed\n9.551 APEX =~ 1/750 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 9966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_1000thsec.jpg", L"ShutterSpeed\n9.966 APEX =~ 1/1000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 10551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_1500thsec.jpg", L"ShutterSpeed\n10.551 APEX =~ 1/1500 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 10966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_2000thsec.jpg", L"ShutterSpeed\n10.966 APEX =~ 1/2000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 11551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_3000thsec.jpg", L"ShutterSpeed\n11.551 APEX =~ 1/3000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 11966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_4000thsec.jpg", L"ShutterSpeed\n11.966 APEX =~ 1/4000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
}

void CreateFStop(LPCWSTR lpTemp)
{
    ULONG Rational[2];

    Rational[0] = 10; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF1.jpg", L"FNumber\nF/1", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF12_10ths.jpg", L"FNumber\nF/1.2", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 14; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF14_10ths.jpg", L"FNumber\nF/1.4", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 18; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF18_10ths.jpg", L"FNumber\nF/1.8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF2.jpg", L"FNumber\nF/2", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 25; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF25_10ths.jpg", L"FNumber\nF/2.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 28; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF28_10ths.jpg", L"FNumber\nF/2.8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 35; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF35_10ths.jpg", L"FNumber\nF/3.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 40; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF4.jpg", L"FNumber\nF/4", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 45; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF45_10ths.jpg", L"FNumber\nF/4.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 56; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF56_10ths.jpg", L"FNumber\nF/5.6", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 67; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF67_10ths.jpg", L"FNumber\nF/6.7", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 80; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF8.jpg", L"FNumber\nF/8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 95; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF95_10ths.jpg", L"FNumber\nF/9.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 110; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF11.jpg", L"FNumber\nF/11", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 130; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF13.jpg", L"FNumber\nF/13", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 160; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF16.jpg", L"FNumber\nF/16", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 190; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF19.jpg", L"FNumber\nF/19", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 220; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF22.jpg", L"FNumber\nF/22", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 270; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF27.jpg", L"FNumber\nF/27", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 320; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF32.jpg", L"FNumber\nF/32", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 380; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF38.jpg", L"FNumber\nF/38", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 450; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF45.jpg", L"FNumber\nF/45", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 540; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF54.jpg", L"FNumber\nF/54", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 640; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF64.jpg", L"FNumber\nF/64", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 760; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF76.jpg", L"FNumber\nF/76", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 910; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF91.jpg", L"FNumber\nF/91", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateAperture(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 0; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF1.jpg", L"Aperture\n0 APEX =~ F/1", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 526; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF12_10ths.jpg", L"Aperture\n0.526 APEX =~ F/1.2", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF14_10ths.jpg", L"Aperture\n0.971 APEX =~ F/1.4", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1696; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF18_10ths.jpg", L"Aperture\n1.696 APEX =~ F/1.8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF2.jpg", L"Aperture\n2.000 APEX =~ F/2", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2644; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF25_10ths.jpg", L"Aperture\n2.644 APEX =~ F/2.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF28_10ths.jpg", L"Aperture\n2.971 APEX =~ F/2.8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3615; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF35_10ths.jpg", L"Aperture\n3.615 APEX =~ F/3.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF4.jpg", L"Aperture\n4.000 APEX =~ F/4", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4340; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF45_10ths.jpg", L"Aperture\n4.340 APEX =~ F/4.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF56_10ths.jpg", L"Aperture\n4.971 APEX =~ F/5.6", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 5488; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF67_10ths.jpg", L"Aperture\n5.488 APEX =~ F/6.7", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF8.jpg", L"Aperture\n6.000 APEX =~ F/8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF95_10ths.jpg", L"Aperture\n6.496 APEX =~ F/9.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6919; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF11.jpg", L"Aperture\n6.919 APEX =~ F/11", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 7401; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF13.jpg", L"Aperture\n7.401 APEX =~ F/13", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF16.jpg", L"Aperture\n8.000 APEX =~ F/16", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF19.jpg", L"Aperture\n8.496 APEX =~ F/19", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8919; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF22.jpg", L"Aperture\n8.919 APEX =~ F/22", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 9510; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF27.jpg", L"Aperture\n9.510 APEX =~ F/27", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF32.jpg", L"Aperture\n10.000 APEX =~ F/32", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF38.jpg", L"Aperture\n10.496 APEX =~ F/38", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10984; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF45.jpg", L"Aperture\n10.984 APEX =~ F/45", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 11510; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF54.jpg", L"Aperture\n11.510 APEX =~ F/54", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF64.jpg", L"Aperture\n12.000 APEX =~ F/64", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF76.jpg", L"Aperture\n12.496 APEX =~ F/76", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 13016; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF91.jpg", L"Aperture\n13.016 APEX =~ F/91", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateExposureBias(LPCWSTR lpTemp)
{
    LONG Rational[2];

    Rational[0] = -2; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb-2.jpg", L"ExposureBias\n-2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -5; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-5_3rds.jpg", L"ExposureBias\n-5/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb-3_2nds.jpg", L"ExposureBias\n-3/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -4; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-4_3rds.jpg", L"ExposureBias\n-4/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb-1.jpg", L"ExposureBias\n-1", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-2_3rds.jpg", L"ExposureBias\n-2/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb-1_2nd.jpg", L"ExposureBias\n-1/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-1_3rd.jpg", L"ExposureBias\n-1/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 0; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb0.jpg", L"ExposureBias\n0", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb1_3rd.jpg", L"ExposureBias\n1/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb1_2nd.jpg", L"ExposureBias\n1/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb2_3rds.jpg", L"ExposureBias\n2/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb1.jpg", L"ExposureBias\n1", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb4_3rds.jpg", L"ExposureBias\n4/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb3_2nds.jpg", L"ExposureBias\n3/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb5_3rds.jpg", L"ExposureBias\n5/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb2.jpg", L"ExposureBias\n2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
}

void CreateSubjectDist(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"sd1_3rd.jpg", L"SubjectDistance\n1/3 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"sd1_2nd.jpg", L"SubjectDistance\n1/2 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 3;
    WriteProperty(lpTemp, L"sd2_3rds.jpg", L"SubjectDistance\n2/3 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd1.jpg", L"SubjectDistance\n1 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd2.jpg", L"SubjectDistance\n2 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 5; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd5.jpg", L"SubjectDistance\n5 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd10.jpg", L"SubjectDistance\n01 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd20.jpg", L"SubjectDistance\n20 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 30; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd30.jpg", L"SubjectDistance\n30 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 40; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd40.jpg", L"SubjectDistance\n40 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 50; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd50.jpg", L"SubjectDistance\n50 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateMeteringMode(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"mm0.jpg", L"MeteringMode\n0 = Unknown", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"mm1.jpg", L"MeteringMode\n1 = Average", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"mm2.jpg", L"MeteringMode\n2 = CenterWeightedAverage", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"mm3.jpg", L"MeteringMode\n3 = Spot", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 4;
    WriteProperty(lpTemp, L"mm4.jpg", L"MeteringMode\n4 = MultiSpot", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"mm5.jpg", L"MeteringMode\n5 = Pattern", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 6;
    WriteProperty(lpTemp, L"mm6.jpg", L"MeteringMode\n6 = Partial", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"mm7.jpg", L"MeteringMode\n7 = reserved", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 255;
    WriteProperty(lpTemp, L"mm255.jpg", L"MeteringMode\n255 = other", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateLightSource(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"ls0.jpg", L"LightSource\n0 = Unknown", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"ls1.jpg", L"LightSource\n1 = Daylight", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"ls2.jpg", L"LightSource\n2 = Fluorescent", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"ls3.jpg", L"LightSource\n3 = Tungsten", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 17;
    WriteProperty(lpTemp, L"ls17.jpg", L"LightSource\n17 = Standard light A", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 18;
    WriteProperty(lpTemp, L"ls18.jpg", L"LightSource\n18 = Standard light B", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 19;
    WriteProperty(lpTemp, L"ls19.jpg", L"LightSource\n19 = Standard light C", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 20;
    WriteProperty(lpTemp, L"ls20.jpg", L"LightSource\n20 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 21;
    WriteProperty(lpTemp, L"ls21.jpg", L"LightSource\n21 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 22;
    WriteProperty(lpTemp, L"ls22.jpg", L"LightSource\n22 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 23;
    WriteProperty(lpTemp, L"ls23.jpg", L"LightSource\n23 = Reserved", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 255;
    WriteProperty(lpTemp, L"ls255.jpg", L"LightSource\n255 = Other", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFlash(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"f0.jpg", L"Flash\n0 = Flash did not fire", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"f1.jpg", L"Flash\n1 = Flash fired (No strobe return detection function)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"f3.jpg", L"Flash\n3 = Flash fired (reserved)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"f5.jpg", L"Flash\n5 = Flash fired (Strobe return light not detected)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"f7.jpg", L"Flash\n7 = Flash fired (Strobe return light detected)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFocalLength(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 15; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl15.jpg", L"FocalLength\n15 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 35; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl35.jpg", L"FocalLength\n35 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 50; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl50.jpg", L"FocalLength\n50 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 100; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl100.jpg", L"FocalLength\n100 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 135; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl135.jpg", L"FocalLength\n135 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 200; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl200.jpg", L"FocalLength\n200 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 300; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl300.jpg", L"FocalLength\n300 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 400; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl400.jpg", L"FocalLength\n400 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 500; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl500.jpg", L"FocalLength\n500 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 600; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl600.jpg", L"FocalLength\n600 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateExposureProgram(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"ep0.jpg", L"ExposureProg\n0 = Not Defined", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"ep1.jpg", L"ExposureProg\n1 = Manual", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"ep2.jpg", L"ExposureProg\n2 = Normal Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"ep3.jpg", L"ExposureProg\n3 = Aperture Priority", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 4;
    WriteProperty(lpTemp, L"ep4.jpg", L"ExposureProg\n4 = Shutter Priority", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"ep5.jpg", L"ExposureProg\n5 = Creative Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 6;
    WriteProperty(lpTemp, L"ep6.jpg", L"ExposureProg\n6 = Action Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"ep7.jpg", L"ExposureProg\n7 = Prtrait Mode", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 8;
    WriteProperty(lpTemp, L"ep8.jpg", L"ExposureProg\n8 = Landscape Mode", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 9;
    WriteProperty(lpTemp, L"ep9.jpg", L"ExposureProg\n9 = Reserved", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateISOSpeed(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 50;
    WriteProperty(lpTemp, L"is50.jpg", L"ISOSpeed\nISO50", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 100;
    WriteProperty(lpTemp, L"is100.jpg", L"ISOSpeed\nISO100", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 200;
    WriteProperty(lpTemp, L"is200.jpg", L"ISOSpeed\nISO200", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 400;
    WriteProperty(lpTemp, L"is400.jpg", L"ISOSpeed\nISO400", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 800;
    WriteProperty(lpTemp, L"is800.jpg", L"ISOSpeed\nISO800", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1600;
    WriteProperty(lpTemp, L"is1600.jpg", L"ISOSpeed\nISO1600", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFlashEnergy(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational [0] = 100; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe100.jpg", L"FlashEnergy\n100 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 1000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe1000.jpg", L"FlashEnergy\n1,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 10000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe10000.jpg", L"FlashEnergy\n10,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 100000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe100000.jpg", L"FlashEnergy\n100,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 1000000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe1000000.jpg", L"FlashEnergy\n1,000,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    ULONG_PTR pGdiplusToken=0;
    Gdiplus::GdiplusStartupInput StartupInput;
    if (Gdiplus::Ok == Gdiplus::GdiplusStartup(&pGdiplusToken,&StartupInput,NULL))
    {
        if (CreateTempJPG(L"temp.jpg"))
        {
            CreateExposureTimeTests(L"temp.jpg");
            CreateShutterSpeed(L"temp.jpg");
            CreateFStop(L"temp.jpg");
            CreateAperture(L"temp.jpg");
            CreateExposureBias(L"temp.jpg");
            CreateSubjectDist(L"temp.jpg");
            CreateMeteringMode(L"temp.jpg");
            CreateLightSource(L"temp.jpg");
            CreateFlash(L"temp.jpg");
            CreateFocalLength(L"temp.jpg");
            CreateExposureProgram(L"temp.jpg");
            CreateISOSpeed(L"temp.jpg");
            CreateFlashEnergy(L"temp.jpg");
        }

        Gdiplus::GdiplusShutdown(pGdiplusToken);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\unittest\testacqd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testacqd.rc
//
#define IDS_MESSAGEBOXTESTMESSAGE       1
#define IDS_MESSAGEBOXTESTTITLE         2
#define IDS_MESSAGEBOXTESTFORMAT        3
#define IDI_TESTACQD                    101
#define IDB_TESTIMAGE                   101
#define IDD_PROGRESS_DIALOG_SETTINGS    102
#define IDR_TESTACQDMENU                102
#define IDD_MBOXFLAGS                   103
#define IDR_TESTACQDACCEL               104
#define IDC_PROGDLG_TITLE               1000
#define IDC_PROGDLG_ANIM                1001
#define IDC_PROGDLG_PROGRESS            1002
#define IDC_PROGDLG_CANCEL              1003
#define IDC_PROGDLG_SCAN_CONNECT        1004
#define IDC_PROGDLG_CAMERA_CONNECT      1005
#define IDC_PROGDLG_VIDEO_CONNECT       1006
#define IDC_PROGDLG_SCAN_ACQUIRE        1007
#define IDC_PROGDLG_CAMERA_ACQUIRE      1008
#define IDC_PROGDLG_VIDEO_ACQUIRE       1009
#define IDC_PROGDLG_DEFAULT_CONNECT     1010
#define IDC_MBEX_DEFBUTTON2             1021
#define IDC_MBEX_DEFBUTTON3             1022
#define IDC_MBEX_DEFBUTTON4             1023
#define IDC_MBEX_DEFBUTTON5             1024
#define IDC_MBEX_ICONWARNING            1025
#define IDC_MBEX_ICONINFORMATION        1026
#define IDC_MBEX_ICONQUESTION           1027
#define IDC_MBEX_ICONERROR              1028
#define IDC_MBEX_OK                     1029
#define IDC_MBEX_OKCANCEL               1030
#define IDC_MBEX_YESNO                  1031
#define IDC_MBEX_YESNOCANCEL            1032
#define IDC_MBEX_CANCELRETRYSKIPSKIP    1033
#define IDC_MBEX_CANCELRETRYSKIPSKIPALL 1034
#define IDC_MBEX_DEFBUTTON1             1035
#define IDC_MBEX_YESYESTOALLNONOTOALL   1036
#define ID_PROGRAM_EXIT                 40003
#define ID_PROGRESS_TESTPROGRESS        40007
#define ID_WIA_DEVICEDLG                40008
#define ID_PROGRESS_SETFLAGS            40009
#define ID_GDI_ROTATEFILENONJPEG        40010
#define ID_GDI_ROTATEFILEJPEG           40011
#define ID_GDI_LOADANDSCALEIMAGE        40012
#define ID_GDI_CONVERTFILE              40013
#define ID_GDI_DISPLAYDECODEREXTENSIONS 40014
#define ID_GDI_ROTATEHBITMAP            40015
#define ID_WIZARD_ACQUIRE_WIZARD        40016
#define ID_WIZARD_PUBLISH_WIZARD        40017
#define ID_WIA_SELECTDEVICEID           40018
#define ID_MBOX_FORM1                   40019
#define ID_MBOX_FORM2                   40020
#define ID_MBOX_FORM3                   40021
#define ID_MBOX_FORM4                   40022
#define ID_MBOX_FORM5                   40023
#define ID_MBOX_FORM6                   40024
#define ID_MBOX_FORM7                   40025
#define ID_GDI_DISPLAYENCODEREXTENSIONS 40026
#define ID_MBOX_SETFLAGS                40027
#define ID_GDI_SAVEMULTIPLEIMAGESASMULTIPAGE 40028
#define ID_WIZARD_EXPLOREWIADEVICE      40029
#define ID_GDI_SETCONTRAST              40030
#define ID_GDI_SETBRIGHTNESS            40031
#define ID_GDI_SETTHRESHOLD             40032
#define ID_GDI_INCREASETHRESHOLD        40033
#define ID_GDI_DECREASETHRESHOLD        40034
#define ID_GDI_DECREASECONTRAST         40035
#define ID_GDI_INCREASECONTRAST         40036
#define ID_GDI_INCREASEBRIGHTNESS       40037
#define ID_GDI_DECREASEBRIGHTNESS       40038
#define ID_GDI_LOADANDSCALESTREAM       40039
#define ID_UPNP_FINDSERVERANDREGISTER   40040
#define ID_UPNP_STOP                    40041
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\camocx.cpp ===
// camocx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for camocx.idl by adding the following
//      files to the Outputs.
//          camocx_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f camocxps.mk in the project directory.

#include "precomp.h"
#pragma hdrstop

#include "wiaview_i.c"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VideoPreview, CVideoPreview)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModuleID( hInstance, 123 );
        _Module.Init(ObjectMap, hInstance /* &LIBID_WIAVIEWLib*/);
        WIA_DEBUG_CREATE( hInstance );
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
        WIA_DEBUG_DESTROY();
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\camocx.inc ===
!include $(CCSHELL_DIR)\common.inc

SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400     //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY      //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain                         PrxDllMain
#define DllRegisterServer       PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "wiaview_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_)
#define AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2001
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for preview control
 *
 *****************************************************************************/

#ifndef _pch_h
#define _pch_h


#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif


#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <initguid.h>
#include <shlguidp.h>
#include <sti.h>
#include <mshtml.h>
#include <commctrl.h>
#include <shfusion.h>


extern HINSTANCE g_hInstance;


#include "uicommon.h"
#include "stdafx.h"
#include "wiapropui.h"
#include "shellext.h"
#include "wianew.h"
#include "pviewids.h"
#include "wia.h"
#include "wiavideo.h"
#include "wiaview.h"
#include "wiadevd.h"
#include "preview.h"
#include "cunknown.h"
#include "wiadebug.h"

#include "idlist.h"
#include "util.h"
#include "resource.h"
#include "vcamprop.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\preview.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2001
 *
 *  TITLE:       preview.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/30/99
 *
 *  DESCRIPTION: Implements preview class for directshow devices in WIA
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


VOID CALLBACK PreviewTimerProc( HWND hDlg, UINT uMsg, UINT_PTR idEvent, DWORD dwTime )
{

    switch (idEvent)
    {
    case TIMER_CLOSE_DIALOG:
        WIA_TRACE((TEXT("PreviewTimerProc -- got TIMER_CLOSE_DIALOG")));
        EndDialog( hDlg, -2 );
        break;
    }
}


/*****************************************************************************

   PreviewDialogProc

   Dialog proc for preview dialog.

 *****************************************************************************/

INT_PTR CALLBACK PreviewDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            WIA_TRACE((TEXT("PreviewDialogProc -- WM_INITDIALOG")));
            SetTimer( hDlg, TIMER_CLOSE_DIALOG, 30000, PreviewTimerProc );

            PREVIEW_INFO_STRUCT * ppis = reinterpret_cast<PREVIEW_INFO_STRUCT *>(lParam);

            if (ppis)
            {
                ppis->hDlg = hDlg;

                if (ppis->hEvent)
                {
                    SetEvent( ppis->hEvent );
                }

            }
        }
        return TRUE;

    case PM_GOAWAY:
        WIA_TRACE((TEXT("PreviewDialogProc -- PM_GOAWAY")));
        EndDialog( hDlg, 0 );
        return TRUE;


    }

    return FALSE;
}


/*****************************************************************************

   PreviewThreadProc

   We spin a thread to put up the status dialog

 *****************************************************************************/

DWORD WINAPI PreviewThreadProc( LPVOID lpv )
{
    INT_PTR iRes;

    WIA_TRACE((TEXT("PreviewThreadProc enter")));

    iRes = DialogBoxParam( _Module.m_hInst,
                           MAKEINTRESOURCE(IDD_INIT_DEVICE),
                           NULL,
                           PreviewDialogProc,
                           reinterpret_cast<LPARAM>(lpv)
                          );

    WIA_TRACE((TEXT("IDD_INIT_DEVICE dialog returned %d"),iRes));

#ifdef DEBUG
    if (iRes==-1)
    {
        WIA_ERROR((TEXT("DialogBoxParam failed w/GLE = %d"),GetLastError()));
    }
#endif

    if (iRes < 0)
    {
        PREVIEW_INFO_STRUCT * ppis = reinterpret_cast<PREVIEW_INFO_STRUCT *>(lpv);

        if (ppis && ppis->hEvent)
        {
            SetEvent( ppis->hEvent );
        }
    }

    WIA_TRACE((TEXT("PreviewThreadProc exit")));

    return 0;

}


/*****************************************************************************

   CVideoPreview::Device

   Hand us a device pointer for the camera (or DS device) we're connected to.

 *****************************************************************************/

STDMETHODIMP
CVideoPreview::Device(IUnknown * pDevice)
{
    HRESULT hr = S_OK;

    WIA_PUSHFUNCTION((TEXT("CVideoPreview::Device")));

    // Create the WiaVideo object
     hr = CoCreateInstance(CLSID_WiaVideo, NULL, CLSCTX_INPROC_SERVER, 
                           IID_IWiaVideo, (LPVOID *)&m_pWiaVideo);

    WIA_CHECK_HR(hr,"CoCreateInstance( WiaVideo )");
    
    m_pDevice = pDevice;
    // if we've already been created, redo everything
    if (m_bCreated)
    {
        BOOL bDummy;
        OnCreate(WM_CREATE, 0, 0, bDummy);
    }
    return hr;
}


/*****************************************************************************

   CVideoPreview::InPlaceDeactivate

   Trap in place deactivate so we can unhook the dshow preview window from
   ours before both are destroyed.

 *****************************************************************************/

STDMETHODIMP
CVideoPreview::InPlaceDeactivate()
{
    HRESULT hr = E_FAIL;

    WIA_PUSHFUNCTION((TEXT("CVideoPreview::InPlaceDeactivate")));

    //
    // Make sure we have a pointer to the device...
    //

    if (m_pWiaVideo.p)
    {
        //
        // Tell the device to close the graph
        //
        m_pWiaVideo->DestroyVideo();        
        m_pWiaVideo = NULL;
    }
    else
    {
        WIA_ERROR((TEXT("m_pWiaVideo is NULL")));
    }

    //
    // Always return S_OK so that InPlaceDeactivate happens.
    //

    return S_OK;

}


/*****************************************************************************

   CVideoPreview::OnSize

   Called when our window is resized.  We want to let the streaming
   preview know we've been resized so it can reposition itself accordingly.

 *****************************************************************************/

LRESULT
CVideoPreview::OnSize(UINT , WPARAM , LPARAM lParam, BOOL& )
{
    WIA_PUSHFUNCTION((TEXT("CVideoPreview::OnSize")));

    if (m_pWiaVideo)
    {
        m_pWiaVideo->ResizeVideo(FALSE);
    }
    else
    {
        WIA_ERROR((TEXT("m_pWiaVideo is NULL!")));
    }

    return 0;
}




LRESULT
CVideoPreview::OnCreate(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    HRESULT hr = S_OK;
    WIA_PUSHFUNCTION(TEXT("CVideoPreview::OnCreate"));
    WIA_ASSERT(::IsWindow(m_hWnd));
    if (m_pDevice.p && m_pWiaVideo.p)
    {

        HANDLE hThread = NULL;
        DWORD  dwId    = 0;
        PREVIEW_INFO_STRUCT pis;

        //
        // Creating the graph can be quite time consuming, so put up
        // a dialog if it takes more than a couple of seconds.  We start
        // a thread so that the UI doesn't hang, and that thread
        // puts up UI saying the device may take a while to initialize.
        //

        pis.hDlg   = NULL;
        pis.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        hThread = CreateThread( NULL, 0, PreviewThreadProc, reinterpret_cast<LPVOID>(&pis), 0, &dwId );


        //
        // Tell the device to build the DShow graph
        //

        BOOL            bSuccess  = TRUE;
        HWND            hwndFore  = ::GetForegroundWindow();
        HWND            hwndFocus = ::GetFocus();
        CSimpleString   strDeviceID;
        CSimpleString   strImagesDirectory;
        CComQIPtr<IWiaItem, &IID_IWiaItem> pRootDevice(m_pDevice);

        if (pRootDevice == NULL)
        {
            hr = E_FAIL;
            bSuccess = FALSE;
        }

        //
        // Get the WIA Device ID
        //

        if (bSuccess)
        {
            bSuccess = PropStorageHelpers::GetProperty(pRootDevice, 
                                                       WIA_DIP_DEV_ID, 
                                                       strDeviceID);
        }

        //
        // Get the directory the images will be stored in.
        //
        if (bSuccess)
        {
            bSuccess = PropStorageHelpers::GetProperty(pRootDevice, 
                                                       WIA_DPV_IMAGES_DIRECTORY, 
                                                       strImagesDirectory);
        }

        //
        // Create the Video if it isn't already created.
        if (bSuccess)
        {
            if (hr == S_OK)
            {
                WIAVIDEO_STATE VideoState = WIAVIDEO_NO_VIDEO;

                //
                // Get the current state of the WiaVideo object.  If we 
                // just created it then the state will be NO_VIDEO, 
                // otherwise, it could already be previewing video,
                // in which case we shouldn't do anything.
                //
                hr = m_pWiaVideo->GetCurrentState(&VideoState);

                if (VideoState == WIAVIDEO_NO_VIDEO)
                {
                    //
                    // Set the directory we want to save our images to.  
                    // We got the image directory from the Wia Video Driver 
                    // IMAGES_DIRECTORY property
                    //
                    if (hr == S_OK)
                    {
                        hr = m_pWiaVideo->put_ImagesDirectory(CSimpleBStr(strImagesDirectory));
                    }

                    //
                    // Create the video preview as a child of the hwnd 
                    // and automatically begin playback after creating the preview.
                    //
                    if (hr == S_OK)
                    {
                        hr = m_pWiaVideo->CreateVideoByWiaDevID(CSimpleBStr(strDeviceID),
                                                                m_hWnd,
                                                                FALSE,
                                                                TRUE);
                    }
                }
            }
        }

        if (!bSuccess)
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            //
            // Let the user know that the graph is most likely already
            // in use...
            //

            ::MessageBox( NULL,
                          CSimpleString(IDS_VIDEO_BUSY_TEXT,  _Module.m_hInst),
                          CSimpleString(IDS_VIDEO_BUSY_TITLE, _Module.m_hInst ),
                          MB_OK | MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND
                         );


        }

        //
        // Restore foreground window & focus, as it seems the
        // active movie window does not preserve these things...
        //

        if (hwndFore)
        {
            ::SetForegroundWindow( hwndFore );
        }

        if (hwndFocus)
        {
            ::SetFocus(hwndFocus);
        }

        //
        // Tell the dialog to go away
        //

        if (hThread)
        {
            if (pis.hEvent)
            {
                //
                // Wait for 45 seconds
                //

                WaitForSingleObject( pis.hEvent, 45 * 1000 );
                if (pis.hDlg)
                {
                    ::PostMessage( pis.hDlg, PM_GOAWAY, 0, 0 );
                }

                CloseHandle( pis.hEvent );
                pis.hEvent = NULL;

            }

            CloseHandle( hThread );
            hThread = NULL;
        }
    }
    bHandled = TRUE;
    m_bCreated = TRUE;
    return 0;
}

LRESULT
CVideoPreview::OnEraseBkgnd(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    HDC hdc = (HDC)wp;
    RECT rc;
    GetClientRect(&rc);
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    bHandled = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by camocx.rc
//
#define IDS_PROJNAME                    100
#define IDR_PREVIEW                     109



// Video strings
#define IDS_VIDEO_BUSY_TEXT             430
#define IDS_VIDEO_BUSY_TITLE            431

// dialogs
#define IDD_INIT_DEVICE                 510
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\preview.h ===
// Preview.h : Declaration of the CVideoPreview

#ifndef __VIDEOPREVIEW_H_
#define __VIDEOPREVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


#define PM_CREATEGRAPH      (WM_USER+1)
#define PM_GOAWAY           (WM_USER+2)

#define TIMER_SHOW_DIALOG   1
#define TIMER_CLOSE_DIALOG  2

typedef struct {
    HWND   hDlg;
    HANDLE hEvent;
} PREVIEW_INFO_STRUCT;


/////////////////////////////////////////////////////////////////////////////
// CVideoPreview
class ATL_NO_VTABLE CVideoPreview :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CVideoPreview, IVideoPreview, &IID_IVideoPreview, &LIBID_WIAVIEWLib>,
    public CComControl<CVideoPreview>,
    public IPersistStreamInitImpl<CVideoPreview>,
    public IOleControlImpl<CVideoPreview>,
    public IOleObjectImpl<CVideoPreview>,
    public IOleInPlaceActiveObjectImpl<CVideoPreview>,
    public IViewObjectExImpl<CVideoPreview>,
    public IOleInPlaceObjectWindowlessImpl<CVideoPreview>,
    public IPersistStorageImpl<CVideoPreview>,
    public ISpecifyPropertyPagesImpl<CVideoPreview>,
    public IQuickActivateImpl<CVideoPreview>,
    public IDataObjectImpl<CVideoPreview>,
    public IProvideClassInfo2Impl<&CLSID_VideoPreview, NULL, &LIBID_WIAVIEWLib>,
    public CComCoClass<CVideoPreview, &CLSID_VideoPreview>

{
public:
    CVideoPreview()
    {
        m_bWindowOnly = TRUE;
        m_bAutoSize = FALSE;
        //m_bUsingWindowRegion = TRUE;
        m_bCreated = FALSE;
        WIA_PUSHFUNCTION((TEXT("CVideoPreview::CVideoPreview")));
    }

    ~CVideoPreview()
    {
        WIA_PUSHFUNCTION((TEXT("CVideoPreview::~CVideoPreview")));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PREVIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

// Mark this interface as safe
BEGIN_CATEGORY_MAP(CVideoPreview)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()


BEGIN_COM_MAP(CVideoPreview)
    COM_INTERFACE_ENTRY(IVideoPreview)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CVideoPreview)
    PROP_ENTRY("HWND", DISPID_HWND, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CVideoPreview)
    CHAIN_MSG_MAP(CComControl<CVideoPreview>)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CREATE,OnCreate)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
//    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IOleInPlaceObject
    STDMETHOD(InPlaceDeactivate)();



// IVideoPreview
public:
    STDMETHOD(Device)(IUnknown * pDevice);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        return S_OK;
    }

private:
    CComPtr<IUnknown>  m_pDevice;
    CComPtr<IWiaVideo> m_pWiaVideo;
    BOOL               m_bCreated;

};

#endif //__PREVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED_)
#define AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\acqmgr.cpp ===
// acqmgr.cpp : Implementation of CAcquisitionManager
#include "precomp.h"
#include "Wiaacmgr.h"
#include "acqmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CAcquisitionManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\webview\camocx\sources.inc ===
#
# Include common build settings for WIA project
#


!include          $(PROJECT_ROOT)\ui\uienv.inc
NO_BROWSER_FILE = 1
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc
VIEW_DIR        = $(PROJECT_ROOT)\ui\webview
TARGETNAME      = camocx
TARGETTYPE      = DYNLINK
TARGETPATH      = obj
TARGETEXT       = dll
DLLDEF          = ..\camocx.def
DLLENTRY        = _DllMainCRTStartup
DLLBASE         = 0x10040000
USE_MSVCRT      = 1

!IF $(ALPHA)
USE_NTDLL=1
!ELSE
USE_NOLIBS=1
!ENDIF

PASS0_PUBLISH={$(O)\wiaview.h=$(PRINTSCAN_INC_PATH)\wiaview.h}

ATL_VER=30
USE_STATIC_ATL=1

INCLUDES=$(INCLUDES); \
        $(PROJECT_ROOT)\ui\shellext\inc; \
        $(BASEDIR)\public\sdk\inc\mfc42; \
        $(PROJECT_ROOT)\ui\prevwnd; \
        $(PROJECT_ROOT)\ui\uicommon; \
        $(VIEW_DIR)\inc;\
        $(VIEW_DIR)\uuid;\
        $(VIEW_DIR)\idl;\
        $(VIEW_DIR)\proxy;\
        $(PROJECT_ROOT)\ui\shellext\src;\
        $(O)

SOURCES=  ..\wiaview.idl\
          ..\camocx.cpp \
          ..\StdAfx.cpp\
          ..\preview.cpp\
          ..\camocx.rc

TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                           \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\wiashext.lib \
        $(PROJECT_ROOT)\ui\shellext\lib\$(PLATFORM_SUFFIX)\$(O)\common.lib



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=camocx.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\acqmgr.h ===
// acqmgr.h : Declaration of the CAcquisitionManager

#ifndef __AcquisitionManager_H_INCLUDED
#define __AcquisitionManager_H_INCLUDED

#include "resource.h"       // main symbols
#include "acqthrd.h"
#include "shmemsec.h"
#include "mintrans.h"
#include "stievent.h"

//
// Number of times we will spin before giving up on
// getting the window of the previous wizard's instance
//
const int c_nMaxActivationRetryCount = 40;

//
// Amount of time to wait between efforts to obtain the previous
// wizard's instance
//
const DWORD c_nActivationRetryWait   = 500;

/////////////////////////////////////////////////////////////////////////////
// CAcquisitionManager
class ATL_NO_VTABLE CAcquisitionManager :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAcquisitionManager, &CLSID_AcquisitionManager>,
    public IWiaEventCallback
{
public:
    CAcquisitionManager()
    {
    }

    ~CAcquisitionManager()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ACQUISITIONMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAcquisitionManager)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    // IManager
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        WIA_PUSHFUNCTION((TEXT("CAcquisitionManager::ImageEventCallback")));

        //
        // Don't want to run if this is a scanner connection event
        //
        if (pEventGUID && *pEventGUID==WIA_EVENT_DEVICE_CONNECTED && GET_STIDEVICE_TYPE(dwDeviceType)==StiDeviceTypeScanner)
        {
            return S_FALSE;
        }

        //
        // Try to create or open the shared memory section.
        //
        CSharedMemorySection<HWND> *pWizardSharedMemory = new CSharedMemorySection<HWND>;
        if (pWizardSharedMemory)
        {
            //
            // Assume we'll be running the wizard.
            //
            bool bRun = true;

            //
            // Create the shared section name
            //
            CSimpleString strSharedSectionName( ACQUISITION_MANAGER_DEVICE_MUTEX_ROOT_NAME );
            strSharedSectionName += CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrDeviceID));

            //
            // If we were able to open the memory section
            //
            if (CSharedMemorySection<HWND>::SmsOpened == pWizardSharedMemory->Open( strSharedSectionName, true ))
            {
                //
                // Try to get the previous instance
                //
                for (int i=0;i<c_nMaxActivationRetryCount;i++)
                {
                    //
                    // if we were able to open the shared memory section, there is already one running.
                    // so get a mutex'ed pointer to the shared memory.
                    //
                    HWND *pHwnd = pWizardSharedMemory->Lock();
                    if (pHwnd)
                    {
                        //
                        // If we were able to get the pointer, get the window handle stored in it.
                        // Set bRun to false, so we don't start up a new wizard
                        //
                        bRun = false;
                        if (*pHwnd && IsWindow(*pHwnd))
                        {
                            //
                            // If it is a valid window, bring it to the foreground.
                            //
                            SetForegroundWindow(*pHwnd);
                        }
                        //
                        // Release the mutex
                        //
                        pWizardSharedMemory->Release();

                        //
                        // We found the window the window handle, so we can exit the loop now.
                        //
                        break;
                    }

                    //
                    // Wait a while for the previous instance to be created
                    //
                    Sleep(c_nActivationRetryWait);
                }
            }

            //
            // We only do this if we need to open a new instance
            //
            if (bRun)
            {
                //
                // Prepare the event data
                //
                CEventParameters EventParameters;
                EventParameters.EventGUID = *pEventGUID;
                EventParameters.strEventDescription = static_cast<LPCWSTR>(bstrEventDescription);
                EventParameters.strDeviceID = static_cast<LPCWSTR>(bstrDeviceID);
                EventParameters.strDeviceDescription = static_cast<LPCWSTR>(bstrDeviceDescription);
                EventParameters.ulReserved = ulReserved;
                EventParameters.ulEventType = *pulEventType;
                EventParameters.hwndParent = NULL;
                EventParameters.pWizardSharedMemory = pWizardSharedMemory;

                //
                // If we are started manually, it will be with the IID_NULL event
                // If this is the case, we are going to treat the number stored as text as
                // the "parent" window handle, over which all windows will be centered
                //
                if (pEventGUID && *pEventGUID==IID_NULL)
                {
                    EventParameters.hwndParent = reinterpret_cast<HWND>(static_cast<UINT_PTR>(WiaUiUtil::StringToLong(CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrEventDescription)))));
                }

                //
                // Start up the thread that actually displays the wizard
                //
                HANDLE hThread = CAcquisitionThread::Create( EventParameters );
                if (hThread)
                {
                    //
                    // Prevent deletion of this structure later
                    //
                    pWizardSharedMemory = NULL;

                    //
                    // Don't need this anymore
                    //
                    CloseHandle(hThread);
                }
            }
            else
            {
                WIA_TRACE((TEXT("There is already an instance of %ws running"), bstrDeviceID ));
            }

            //
            // Delete this memory mapped file, to prevent leaks
            //
            if (pWizardSharedMemory)
            {
                delete pWizardSharedMemory;
            }
        }
        return S_OK;
    }
};


class ATL_NO_VTABLE CMinimalTransfer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMinimalTransfer, &CLSID_MinimalTransfer>,
    public IWiaEventCallback
{
public:
    CMinimalTransfer()
    {
    }

    ~CMinimalTransfer()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MINIMALTRANSFER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMinimalTransfer)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    // IManager
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        if (pEventGUID && *pEventGUID==WIA_EVENT_DEVICE_CONNECTED && GET_STIDEVICE_TYPE(dwDeviceType)==StiDeviceTypeScanner)
        {
            return S_FALSE;
        }
        DWORD dwThreadId;
        _Module.Lock();
        HANDLE hThread = CreateThread( NULL, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(MinimalTransferThreadProc), SysAllocString(bstrDeviceID), 0, &dwThreadId );
        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            _Module.Unlock();
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
};


class ATL_NO_VTABLE CStiEventHandler :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CStiEventHandler, &CLSID_StiEventHandler>,
    public IWiaEventCallback
{
public:
    CStiEventHandler()
    {
    }

    ~CStiEventHandler()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_STIEVENTHANDLER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStiEventHandler)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        //
        // Package the event data for the handler
        //
        CStiEventData StiEventData( pEventGUID, bstrEventDescription, bstrDeviceID, bstrDeviceDescription, dwDeviceType, bstrFullItemName, pulEventType, ulReserved );

        //
        // Just call the handler and return it.
        //
        return StiEventHandler( StiEventData );
    }
};


#endif //__AcquisitionManager_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\acqmgrcw.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       ACQMGRCW.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <simcrack.h>
#include <commctrl.h>
#include <wiatextc.h>
#include <pviewids.h>
#include <commctrl.h>
#include "resource.h"
#include "acqmgrcw.h"
#include "wia.h"
#include "wiadevdp.h"
#include "evntparm.h"
#include "itranhlp.h"
#include "bkthread.h"
#include "wiaitem.h"
#include "errors.h"
#include "isuppfmt.h"
#include "uiexthlp.h"
#include "gphelper.h"
#include "svselfil.h"
#include "gwiaevnt.h"
#include "modlock.h"
#include "comfin.h"
#include "comprog.h"
#include "upquery.h"
#include "comdelp.h"
#include "devprop.h"
#include "mboxex.h"
#include "dumpprop.h"
#include "psutil.h"

#undef TRY_SMALLER_THUMBNAILS

#if defined(TRY_SMALLER_THUMBNAILS)

static const int c_nDefaultThumbnailWidth   =  80;
static const int c_nDefaultThumbnailHeight  =  80;

static const int c_nMaxThumbnailWidth       = 80;
static const int c_nMaxThumbnailHeight      = 80;

static const int c_nMinThumbnailWidth       = 80;
static const int c_nMinThumbnailHeight      = 80;

#else

static const int c_nDefaultThumbnailWidth   =  90;
static const int c_nDefaultThumbnailHeight  =  90;

static const int c_nMaxThumbnailWidth       = 120;
static const int c_nMaxThumbnailHeight      = 120;

static const int c_nMinThumbnailWidth       = 80;
static const int c_nMinThumbnailHeight      = 80;


#endif

//
// Property sheet pages' window class declarations
//
#include "comfirst.h"
#include "camsel.h"
#include "comtrans.h"
#include "scansel.h"

// -------------------------------------------------
// CAcquisitionManagerControllerWindow
// -------------------------------------------------
CAcquisitionManagerControllerWindow::CAcquisitionManagerControllerWindow( HWND hWnd )
  : m_hWnd(hWnd),
    m_pEventParameters(NULL),
    m_DeviceTypeMode(UnknownMode),
    m_hWizardIconSmall(NULL),
    m_hWizardIconBig(NULL),
    m_guidOutputFormat(IID_NULL),
    m_bDeletePicturesIfSuccessful(false),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_bDisconnected(false),
    m_pThreadMessageQueue(NULL),
    m_bStampTimeOnSavedFiles(true),
    m_bOpenShellAfterDownload(true),
    m_bSuppressFirstPage(false),
    m_nFailedImagesCount(0),
    m_nDestinationPageIndex(-1),
    m_nFinishPageIndex(-1),
    m_nDeleteProgressPageIndex(-1),
    m_nSelectionPageIndex(-1),
    m_hWndWizard(NULL),
    m_bTakePictureIsSupported(false),
    m_nWiaWizardPageCount(0),
    m_nUploadWizardPageCount(0),
    m_bUploadToWeb(false),
    m_cRef(1),
    m_nScannerType(ScannerTypeUnknown),
    m_OnDisconnect(0),
    m_dwLastEnumerationTickCount(0)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::CAcquisitionManagerControllerWindow"));

    // This sets up the map that maps thread messages to message handlers, which are declared to be static
    // member functions.
    static CThreadMessageMap s_MsgMap[] =
    {
        { TQ_DESTROY, OnThreadDestroy},
        { TQ_DOWNLOADIMAGE, OnThreadDownloadImage},
        { TQ_DOWNLOADTHUMBNAIL, OnThreadDownloadThumbnail},
        { TQ_SCANPREVIEW, OnThreadPreviewScan},
        { TQ_DELETEIMAGES, OnThreadDeleteImages},
        { 0, NULL}
    };

    // Assume the default thumbnail size, in case we aren't able to calculate it
    m_sizeThumbnails.cx = c_nDefaultThumbnailWidth;
    m_sizeThumbnails.cy = c_nDefaultThumbnailHeight;

    //
    // Read the initial settings
    //
    CSimpleReg reg( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, false, KEY_READ );
    m_bOpenShellAfterDownload = (reg.Query( REG_STR_OPENSHELL, m_bOpenShellAfterDownload ) != FALSE);
    m_bSuppressFirstPage = (reg.Query( REG_STR_SUPRESSFIRSTPAGE, m_bSuppressFirstPage ) != FALSE);

    //
    // Initialize the background thread queue, which will handle all of our background requests
    //
    m_pThreadMessageQueue = new CThreadMessageQueue;
    if (m_pThreadMessageQueue)
    {
        //
        // Note that CBackgroundThread takes ownership of m_pThreadMessageQueue, and it doesn't have to be deleted in this thread
        //
        m_hBackgroundThread = CBackgroundThread::Create( m_pThreadMessageQueue, s_MsgMap, m_CancelEvent.Event(), NULL );
    }

    ZeroMemory( m_PublishWizardPages, sizeof(m_PublishWizardPages) );
}

CAcquisitionManagerControllerWindow::~CAcquisitionManagerControllerWindow(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::~CAcquisitionManagerControllerWindow"));
    if (m_pEventParameters)
    {
        if (m_pEventParameters->pWizardSharedMemory)
        {
            delete m_pEventParameters->pWizardSharedMemory;
        }
        m_pEventParameters = NULL;
    }

}

LRESULT CAcquisitionManagerControllerWindow::OnDestroy( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnDestroy"));

    //
    // Tell the publishing wizard to release us
    //
    if (m_pPublishingWizard)
    {
        IUnknown_SetSite( m_pPublishingWizard, NULL );
    }

    //
    // Release the publishing wizard and its data
    //
    m_pPublishingWizard = NULL;

    //
    // Stop downloading thumbnails
    //
    m_EventThumbnailCancel.Signal();

    //
    // Unpause the background thread
    //
    m_EventPauseBackgroundThread.Signal();

    //
    // Tell the background thread to destroy itself
    //
    m_pThreadMessageQueue->Enqueue( new CThreadMessage(TQ_DESTROY),CThreadMessageQueue::PriorityUrgent);

    //
    // Issue a cancel io command for this item
    //
    WiaUiUtil::IssueWiaCancelIO(m_pWiaItemRoot);

    //
    // Tell other instances we are done before the background thread is finished,
    // so we can immediately start again
    //
    if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
    {
        m_pEventParameters->pWizardSharedMemory->Close();
    }

    //
    // Wait for the thread to exit
    //
    WiaUiUtil::MsgWaitForSingleObject( m_hBackgroundThread, INFINITE );
    CloseHandle( m_hBackgroundThread );

    //
    // Clean up the icons
    //
    if (m_hWizardIconSmall)
    {
        DestroyIcon( m_hWizardIconSmall );
        m_hWizardIconSmall = NULL;
    }
    if (m_hWizardIconBig)
    {
        DestroyIcon( m_hWizardIconBig );
        m_hWizardIconBig = NULL;
    }

    return 0;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDestroy( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnThreadDestroy"));
    // Return false to close the queue
    return FALSE;
}


BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDownloadImage( CThreadMessage *pMsg )
{
    CDownloadImagesThreadMessage *pDownloadImageThreadMessage = dynamic_cast<CDownloadImagesThreadMessage*>(pMsg);
    if (pDownloadImageThreadMessage)
    {
        pDownloadImageThreadMessage->Download();
    }
    else
    {
        WIA_ERROR((TEXT("pDownloadImageThreadMessage was NULL")));
    }
    return TRUE;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDownloadThumbnail( CThreadMessage *pMsg )
{
    CDownloadThumbnailsThreadMessage *pDownloadThumnailsThreadMessage = dynamic_cast<CDownloadThumbnailsThreadMessage*>(pMsg);
    if (pDownloadThumnailsThreadMessage)
    {
        pDownloadThumnailsThreadMessage->Download();
    }
    else
    {
        WIA_ERROR((TEXT("pDownloadThumnailThreadMessage was NULL")));
    }
    return TRUE;
}


BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadPreviewScan( CThreadMessage *pMsg )
{
    CPreviewScanThreadMessage *pPreviewScanThreadMessage = dynamic_cast<CPreviewScanThreadMessage*>(pMsg);
    if (pPreviewScanThreadMessage)
    {
        pPreviewScanThreadMessage->Scan();
    }
    else
    {
        WIA_ERROR((TEXT("pPreviewScanThreadMessage was NULL")));
    }
    return TRUE;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDeleteImages( CThreadMessage *pMsg )
{
    CDeleteImagesThreadMessage *pDeleteImagesThreadMessage = dynamic_cast<CDeleteImagesThreadMessage*>(pMsg);
    if (pDeleteImagesThreadMessage)
    {
        pDeleteImagesThreadMessage->DeleteImages();
    }
    else
    {
        WIA_ERROR((TEXT("pPreviewScanThreadMessage was NULL")));
    }
    return TRUE;
}

HRESULT CAcquisitionManagerControllerWindow::CreateDevice(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::CreateDevice"));
    CComPtr<IWiaDevMgr> pWiaDevMgr;
    HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
    if (SUCCEEDED(hr))
    {
        bool bRetry = true;
        for (DWORD dwRetryCount = 0;dwRetryCount < CREATE_DEVICE_RETRY_MAX_COUNT && bRetry;dwRetryCount++)
        {
            hr = pWiaDevMgr->CreateDevice( CSimpleBStr(m_pEventParameters->strDeviceID), &m_pWiaItemRoot );
            WIA_PRINTHRESULT((hr,TEXT("pWiaDevMgr->CreateDevice returned")));
            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = false;

                //
                // Register for events
                //
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_DEVICE_DISCONNECTED, &m_pDisconnectEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_ITEM_DELETED, &m_pDeleteItemEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_DEVICE_CONNECTED, &m_pConnectEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_ITEM_CREATED, &m_pCreateItemEventObject, m_hWnd, m_nWiaEventMessage );
            }
            else if (WIA_ERROR_BUSY == hr)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(CREATE_DEVICE_RETRY_WAIT);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = false;
            }
        }
    }
    return hr;
}

void CAcquisitionManagerControllerWindow::GetCookiesOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies )
{
    while (pCurr)
    {
        GetCookiesOfSelectedImages(pCurr->Children(),Cookies);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::MarkAllItemsUnselected( CWiaItem *pCurrItem )
{
    while (pCurrItem)
    {
        pCurrItem->SelectedForDownload(false);
        MarkAllItemsUnselected( pCurrItem->Children() );
        pCurrItem = pCurrItem->Next();
    }
}

void CAcquisitionManagerControllerWindow::MarkItemSelected( CWiaItem *pItem, CWiaItem *pCurrItem )
{
    while (pCurrItem)
    {
        if (pItem == pCurrItem && !pCurrItem->Deleted())
        {
            pCurrItem->SelectedForDownload(true);
        }
        MarkItemSelected( pItem, pCurrItem->Children() );
        pCurrItem = pCurrItem->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetSelectedItems( CWiaItem *pCurr, CSimpleDynamicArray<CWiaItem*> &Items )
{
    while (pCurr)
    {
        GetSelectedItems(pCurr->Children(),Items);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Items.Append(pCurr);
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetRotationOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<int> &Rotation )
{
    while (pCurr)
    {
        GetRotationOfSelectedImages(pCurr->Children(),Rotation);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Rotation.Append(pCurr->Rotation());
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetCookiesOfAllImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies )
{
    while (pCurr)
    {
        GetCookiesOfAllImages(pCurr->Children(),Cookies);
        if (pCurr->IsDownloadableItemType())
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
}


int CAcquisitionManagerControllerWindow::GetSelectedImageCount( void )
{
    CSimpleDynamicArray<DWORD> Cookies;
    CSimpleDynamicArray<int> Rotation;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );
    GetRotationOfSelectedImages( m_WiaItemList.Root(), Rotation );
    if (Rotation.Size() != Cookies.Size())
    {
        return 0;
    }
    return Cookies.Size();
}

bool CAcquisitionManagerControllerWindow::DeleteDownloadedImages( HANDLE hCancelDeleteEvent )
{
    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    CSimpleDynamicArray<DWORD> Cookies;
    for (int i=0;i<m_DownloadedFileInformationList.Size();i++)
    {
        Cookies.Append(m_DownloadedFileInformationList[i].Cookie());
    }
    if (Cookies.Size())
    {
        CDeleteImagesThreadMessage *pDeleteImageThreadMessage = new CDeleteImagesThreadMessage(
                                                                                                m_hWnd,
                                                                                                Cookies,
                                                                                                hCancelDeleteEvent,
                                                                                                m_EventPauseBackgroundThread.Event(),
                                                                                                true
                                                                                                );
        if (pDeleteImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDeleteImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d"), Cookies.Size()));
        return false;
    }
    return true;
}

bool CAcquisitionManagerControllerWindow::DeleteSelectedImages(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::DeleteSelectedImages"));
    CSimpleDynamicArray<DWORD> Cookies;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );

    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    if (Cookies.Size())
    {
        CDeleteImagesThreadMessage *pDeleteImageThreadMessage = new CDeleteImagesThreadMessage(
                                                                                                m_hWnd,
                                                                                                Cookies,
                                                                                                NULL,
                                                                                                m_EventPauseBackgroundThread.Event(),
                                                                                                false
                                                                                                );
        if (pDeleteImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDeleteImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d"), Cookies.Size()));
        return false;
    }
    return true;
}

bool CAcquisitionManagerControllerWindow::DownloadSelectedImages( HANDLE hCancelDownloadEvent )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::DownloadSelectedImages"));
    CSimpleDynamicArray<DWORD> Cookies;
    CSimpleDynamicArray<int> Rotation;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );
    GetRotationOfSelectedImages( m_WiaItemList.Root(), Rotation );

    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    if (Cookies.Size() && Rotation.Size() == Cookies.Size())
    {
        CDownloadImagesThreadMessage *pDownloadImageThreadMessage = new CDownloadImagesThreadMessage(
                                                                                                    m_hWnd,
                                                                                                    Cookies,
                                                                                                    Rotation,
                                                                                                    m_szDestinationDirectory,
                                                                                                    m_szRootFileName,
                                                                                                    m_guidOutputFormat,
                                                                                                    hCancelDownloadEvent,
                                                                                                    m_bStampTimeOnSavedFiles,
                                                                                                    m_EventPauseBackgroundThread.Event()
                                                                                                    );
        if (pDownloadImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDownloadImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d, Rotation.Size() = %d"), Cookies.Size(), Rotation.Size()));
        return false;
    }
    return true;
}


bool CAcquisitionManagerControllerWindow::DirectoryExists( LPCTSTR pszDirectoryName )
{
    // Try to determine if this directory exists
    DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    if (dwFileAttributes == 0xFFFFFFFF || !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        return false;
    else return true;
}

bool CAcquisitionManagerControllerWindow::RecursiveCreateDirectory( CSimpleString strDirectoryName )
{
    // If this directory already exists, return true.
    if (DirectoryExists(strDirectoryName))
        return true;
    // Otherwise try to create it.
    CreateDirectory(strDirectoryName,NULL);
    // If it now exists, return true
    if (DirectoryExists(strDirectoryName))
        return true;
    else
    {
        // Remove the last subdir and try again
        int nFind = strDirectoryName.ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory( strDirectoryName.Left(nFind) );
            // Now try to create it.
            CreateDirectory(strDirectoryName,NULL);
        }
    }
    //Does it exist now?
    return DirectoryExists(strDirectoryName);
}

bool CAcquisitionManagerControllerWindow::IsCameraThumbnailDownloaded( const CWiaItem &WiaItem, LPARAM lParam )
{
    CAcquisitionManagerControllerWindow *pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(lParam);
    if (pControllerWindow &&
        (pControllerWindow->m_DeviceTypeMode==CameraMode || pControllerWindow->m_DeviceTypeMode==VideoMode) &&
        WiaItem.IsDownloadableItemType() &&
        !WiaItem.BitmapData())
    {
        return true;
    }
    else
    {
        return false;
    }
}

int CAcquisitionManagerControllerWindow::GetCookies( CSimpleDynamicArray<DWORD> &Cookies, CWiaItem *pCurr, ComparisonCallbackFuntion pfnCallback, LPARAM lParam )
{
    while (pCurr)
    {
        GetCookies(Cookies, pCurr->Children(), pfnCallback, lParam );
        if (pfnCallback && pfnCallback(*pCurr,lParam))
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
    return Cookies.Size();
}

// Download all of the camera's thumbnails that haven't been downloaded yet
void CAcquisitionManagerControllerWindow::DownloadAllThumbnails()
{
    //
    // Get all of the images in the device
    //
    CSimpleDynamicArray<DWORD> Cookies;
    GetCookies( Cookies, m_WiaItemList.Root(), IsCameraThumbnailDownloaded, reinterpret_cast<LPARAM>(this) );
    if (Cookies.Size())
    {
        m_EventThumbnailCancel.Reset();
        CDownloadThumbnailsThreadMessage *pDownloadThumbnailsThreadMessage = new CDownloadThumbnailsThreadMessage( m_hWnd, Cookies, m_EventThumbnailCancel.Event() );
        if (pDownloadThumbnailsThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDownloadThumbnailsThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
    }
}

bool CAcquisitionManagerControllerWindow::PerformPreviewScan( CWiaItem *pWiaItem, HANDLE hCancelPreviewEvent )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::PerformPreviewScan"));
    if (pWiaItem)
    {
        CPreviewScanThreadMessage *pPreviewScanThreadMessage = new CPreviewScanThreadMessage( m_hWnd, pWiaItem->GlobalInterfaceTableCookie(), hCancelPreviewEvent );
        if (pPreviewScanThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pPreviewScanThreadMessage, CThreadMessageQueue::PriorityNormal );
            return true;
        }
    }
    return false;
}

void CAcquisitionManagerControllerWindow::DisplayDisconnectMessageAndExit(void)
{
    //
    // Make sure we are not doing this more than once
    //
    if (!m_bDisconnected)
    {
        //
        // Don't do this again
        //
        m_bDisconnected = true;

        //
        // Close the shared memory section so another instance can start up
        //
        if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
        {
            m_pEventParameters->pWizardSharedMemory->Close();
        }

        if (m_OnDisconnect & OnDisconnectFailDownload)
        {
            //
            // Set an appropriate error message
            //
            m_hrDownloadResult = WIA_ERROR_OFFLINE;
            m_strErrorMessage.LoadString( IDS_DEVICE_DISCONNECTED, g_hInstance );
        }

        if ((m_OnDisconnect & OnDisconnectGotoLastpage) && m_hWndWizard)
        {
            //
            // Find any active dialogs and close them
            //
            HWND hWndLastActive = GetLastActivePopup(m_hWndWizard);
            if (hWndLastActive && hWndLastActive != m_hWndWizard)
            {
                SendMessage( hWndLastActive, WM_CLOSE, 0, 0 );
            }

            //
            // Go to the finish page
            //
            PropSheet_SetCurSelByID( m_hWndWizard, IDD_COMMON_FINISH );
        }
    }
}

void CAcquisitionManagerControllerWindow::SetMainWindowInSharedMemory( HWND hWnd )
{
    //
    // Try to grab the mutex
    //
    if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
    {
        HWND *pHwnd = m_pEventParameters->pWizardSharedMemory->Lock();
        if (pHwnd)
        {
            //
            // Save the hWnd
            //
            *pHwnd = hWnd;

            //
            // Release the mutex
            //
            m_pEventParameters->pWizardSharedMemory->Release();
        }

        m_hWndWizard = hWnd;
    }
}

bool CAcquisitionManagerControllerWindow::GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items, CWiaItem *pCurr )
{
    while (pCurr)
    {
        if (pCurr->IsDownloadableItemType())
        {
            Items.Append( pCurr );
        }
        GetAllImageItems( Items, pCurr->Children() );
        pCurr = pCurr->Next();
    }
    return(Items.Size() != 0);
}

bool CAcquisitionManagerControllerWindow::GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items )
{
    return GetAllImageItems( Items, m_WiaItemList.Root() );
}

bool CAcquisitionManagerControllerWindow::CanSomeSelectedImagesBeDeleted(void)
{
    CSimpleDynamicArray<CWiaItem*> Items;
    GetSelectedItems( m_WiaItemList.Root(), Items );
    //
    // Since we get these access flags in the background, if we don't actually have any yet,
    // we will assume some images CAN be deleted
    //
    bool bNoneAreInitialized = true;
    for (int i=0;i<Items.Size();i++)
    {
        if (Items[i])
        {
            if (Items[i]->AccessRights())
            {
                // At least one of the selected images has been initialized
                bNoneAreInitialized = false;

                // If at least one can be deleted, return true immediately
                if (Items[i]->AccessRights() & WIA_ITEM_CAN_BE_DELETED)
                {
                    return true;
                }
            }
        }
    }
    // If none of the images have been initialized, then we will report true
    if (bNoneAreInitialized)
    {
        return true;
    }
    else
    {
        return false;
    }
}

CWiaItem *CAcquisitionManagerControllerWindow::FindItemByName( LPCWSTR pwszItemName )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::FindItemByName( %ws )"), pwszItemName ));
    if (!pwszItemName)
        return NULL;
    if (!m_pWiaItemRoot)
        return NULL;
    return m_WiaItemList.Find(pwszItemName);
}

BOOL CAcquisitionManagerControllerWindow::ConfirmWizardCancel( HWND hWndParent )
{
    //
    // Always let it exit, for now.
    //
    return FALSE;
}

int CALLBACK CAcquisitionManagerControllerWindow::PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::PropSheetCallback"));
    if (PSCB_INITIALIZED == uMsg)
    {
        //
        // Try to bring the window to the foreground.
        //
        SetForegroundWindow(hWnd);

    }
    return 0;
}

void CAcquisitionManagerControllerWindow::DetermineScannerType(void)
{
    LONG nProps = ScannerProperties::GetDeviceProps( m_pWiaItemRoot );

    m_nScannerType = ScannerTypeUnknown;

    //
    // Determine which scanner type we have, based on which properties the scanner has, as follows:
    //
    // HasFlatBed         HasDocumentFeeder   SupportsPreview     SupportsPageSize
    // 1                  1                   1                   1                   ScannerTypeFlatbedAdf
    // 1                  0                   1                   0                   ScannerTypeFlatbed
    // 0                  1                   1                   1                   ScannerTypeFlatbedAdf
    // 0                  1                   0                   0                   ScannerTypeScrollFed
    //
    // otherwise it is ScannerTypeUnknown
    //
    const int nMaxControllingProps = 4;
    static struct
    {
        LONG ControllingProps[nMaxControllingProps];
        int nScannerType;
    }
    s_DialogResourceData[] =
    {
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, NULL },
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { ScannerProperties::HasFlatBed, 0,                                    ScannerProperties::SupportsPreview, 0,                                   ScannerTypeFlatbed },
        { 0,                             ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  0,                                   ScannerTypeScrollFed },
        { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
    };

    //
    // Find the set of flags that match this device.  If they match, use this scanner type.
    // Loop through each type description.
    //
    for (int nCurrentResourceFlags=1;nCurrentResourceFlags<ARRAYSIZE(s_DialogResourceData) && (ScannerTypeUnknown == m_nScannerType);nCurrentResourceFlags++)
    {
        //
        // Loop through each controlling property
        //
        for (int nControllingProp=0;nControllingProp<nMaxControllingProps;nControllingProp++)
        {
            //
            // If this property DOESN'T match, break out prematurely
            //
            if ((nProps & s_DialogResourceData[0].ControllingProps[nControllingProp]) != s_DialogResourceData[nCurrentResourceFlags].ControllingProps[nControllingProp])
            {
                break;
            }
        }
        //
        // If the current controlling property is equal to the maximum controlling property,
        // we had matches all the way through, so use this type
        //
        if (nControllingProp == nMaxControllingProps)
        {
            m_nScannerType = s_DialogResourceData[nCurrentResourceFlags].nScannerType;
        }
    }
}

CSimpleString CAcquisitionManagerControllerWindow::GetCurrentDate(void)
{
    SYSTEMTIME SystemTime;
    TCHAR szText[MAX_PATH] = TEXT("");

    GetLocalTime( &SystemTime );
    GetDateFormat( LOCALE_USER_DEFAULT, 0, &SystemTime, CSimpleString(IDS_DATEFORMAT,g_hInstance), szText, ARRAYSIZE(szText) );
    return szText;
}


bool CAcquisitionManagerControllerWindow::SuppressFirstPage(void)
{
    return m_bSuppressFirstPage;
}

bool CAcquisitionManagerControllerWindow::IsSerialCamera(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::IsSerialCamera"));

    //
    // Only check for serial devices if we are a camera
    //
    if (m_DeviceTypeMode==CameraMode)
    {
#if defined(WIA_DIP_HW_CONFIG)
        //
        // Get the hardware configuration information
        //
        LONG nHardwareConfig = 0;
        if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_HW_CONFIG, nHardwareConfig ))
        {
            //
            // If this is a serial device, return true
            //
            if (nHardwareConfig & STI_HW_CONFIG_SERIAL)
            {
                return true;
            }
        }
#else
        CSimpleStringWide strwPortName;
        if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_PORT_NAME, strwPortName ))
        {
            //
            // Compare the leftmost 3 characters to the word COM (as in COM1, COM2, ... )
            //
            if (strwPortName.Left(3).CompareNoCase(CSimpleStringWide(L"COM"))==0)
            {
                WIA_TRACE((TEXT("A comparison of %ws and COM succeeded"), strwPortName.Left(3).String() ));
                return true;
            }
            //
            // Compare the portname to the word AUTO
            //
            else if (strwPortName.CompareNoCase(CSimpleStringWide(L"AUTO"))==0)
            {
                WIA_TRACE((TEXT("A comparison of %ws and AUTO succeeded"), strwPortName.String() ));
                return true;
            }
        }
#endif
    }
    //
    // Not a serial camera
    //
    return false;
}

HRESULT CAcquisitionManagerControllerWindow::CreateAndExecuteWizard(void)
{
    //
    // Structure used to setup our data-driven property sheet factory
    //
    enum CPageType
    {
        NormalPage = 0,
        FirstPage  = 1,
        LastPage   = 2
    };
    struct CPropertyPageInfo
    {
        LPCTSTR   pszTemplate;
        DLGPROC   pfnDlgProc;
        int       nIdTitle;
        int       nIdSubTitle;
        TCHAR     szTitle[256];
        TCHAR     szSubTitle[1024];
        CPageType PageType;
        bool     *pbDisplay;
        int      *pnPageIndex;
    };

    //
    // Maximum number of statically created wizard pages
    //
    const int c_nMaxWizardPages = 7;


    HRESULT hr = S_OK;

    //
    // Register common controls
    //
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC  = ICC_WIN95_CLASSES | ICC_LISTVIEW_CLASSES | ICC_USEREX_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
    InitCommonControlsEx( &icce );

    //
    // Register custom window classes
    //
    CWiaTextControl::RegisterClass( g_hInstance );
    RegisterWiaPreviewClasses( g_hInstance );

    //
    // These are the pages we'll use for the scanner wizard, if it doesn't have an ADF
    //
    CPropertyPageInfo ScannerPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_SELECT),     CScannerSelectionPage::DialogProc,     IDS_SCANNER_SELECT_TITLE,   IDS_SCANNER_SELECT_SUBTITLE,   TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the scanner wizard, if it is a scroll-fed scanner
    //
    CPropertyPageInfo ScannerScrollFedPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_SELECT),     CScannerSelectionPage::DialogProc,     IDS_SCROLLFED_SELECT_TITLE, IDS_SCROLLFED_SELECT_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the scanner wizard, if it does have an ADF
    //
    CPropertyPageInfo ScannerADFPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_ADF_SELECT), CScannerSelectionPage::DialogProc,     IDS_SCANNER_SELECT_TITLE,   IDS_SCANNER_SELECT_SUBTITLE,   TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the camera wizard
    //
    CPropertyPageInfo CameraPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_CAMERA_FIRST),       CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_CAMERA_SELECT),      CCameraSelectionPage::DialogProc,      IDS_CAMERA_SELECT_TITLE,    IDS_CAMERA_SELECT_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_CAMERA_TRANSFER),    CCommonTransferPage::DialogProc,       IDS_CAMERA_TRANSFER_TITLE,  IDS_CAMERA_TRANSFER_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_CAMERA_PROGRESS_TITLE,  IDS_CAMERA_PROGRESS_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the video wizard
    //
    CPropertyPageInfo VideoPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_VIDEO_FIRST),        CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_VIDEO_SELECT),       CCameraSelectionPage::DialogProc,      IDS_VIDEO_SELECT_TITLE,     IDS_VIDEO_SELECT_SUBTITLE,     TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_CAMERA_TRANSFER),    CCommonTransferPage::DialogProc,       IDS_CAMERA_TRANSFER_TITLE,  IDS_CAMERA_TRANSFER_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_CAMERA_PROGRESS_TITLE,  IDS_CAMERA_PROGRESS_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // Initialize all of these variables, which differ depending on which type of device we are loading
    //
    LPTSTR pszbmWatermark                 = NULL;
    LPTSTR pszbmHeader                    = NULL;
    CPropertyPageInfo *pPropSheetPageInfo = NULL;
    int nPropPageCount                    = 0;
    int nWizardIconId                     = 0;
    CSimpleString strDownloadManagerTitle = TEXT("");

    //
    // Decide which pages to use.
    //
    switch (m_DeviceTypeMode)
    {
    case CameraMode:
        pszbmWatermark     = MAKEINTRESOURCE(IDB_CAMERA_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_CAMERA_HEADER);
        pPropSheetPageInfo = CameraPropSheetPageInfo;
        nPropPageCount     = ARRAYSIZE(CameraPropSheetPageInfo);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_CAMERA_WIZARD;
        break;

    case VideoMode:
        pszbmWatermark     = MAKEINTRESOURCE(IDB_VIDEO_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_VIDEO_HEADER);
        pPropSheetPageInfo = VideoPropSheetPageInfo;
        nPropPageCount     = ARRAYSIZE(VideoPropSheetPageInfo);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_VIDEO_WIZARD;
        break;

    case ScannerMode:
        DetermineScannerType();
        pszbmWatermark     = MAKEINTRESOURCE(IDB_SCANNER_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_SCANNER_HEADER);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_SCANNER_WIZARD;
        if (m_nScannerType == ScannerTypeFlatbedAdf)
        {
            pPropSheetPageInfo = ScannerADFPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerADFPropSheetPageInfo);
        }
        else if (m_nScannerType == ScannerTypeFlatbed)
        {
            pPropSheetPageInfo = ScannerPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerPropSheetPageInfo);
        }
        else if (m_nScannerType == ScannerTypeScrollFed)
        {
            pPropSheetPageInfo = ScannerScrollFedPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerScrollFedPropSheetPageInfo);
        }
        else
        {
            //
            // Unknown scanner type
            //
        }

        break;

    default:
        return E_INVALIDARG;
    }

    HICON hIconSmall=NULL, hIconBig=NULL;
    if (!SUCCEEDED(WiaUiExtensionHelper::GetDeviceIcons( CSimpleBStr(m_strwDeviceUiClassId), m_nDeviceType, &hIconSmall, &hIconBig )))
    {
        //
        // Load the icons.  They will be set using WM_SETICON in the first pages.
        //
        hIconSmall = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(nWizardIconId), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR ));
        hIconBig = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(nWizardIconId), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR ));
    }
    
    //
    // Make copies of these icons to work around NTBUG 351806
    //
    if (hIconSmall)
    {
        m_hWizardIconSmall = CopyIcon(hIconSmall);
        DestroyIcon(hIconSmall);
    }
    if (hIconBig)
    {
        m_hWizardIconBig = CopyIcon(hIconBig);
        DestroyIcon(hIconBig);
    }


    //
    // Make sure we have a valid set of data
    //
    if (pszbmWatermark && pszbmHeader && pPropSheetPageInfo && nPropPageCount)
    {
        const int c_MaxPageCount = 20;
        HPROPSHEETPAGE PropSheetPages[c_MaxPageCount] = {0};

        //
        // We might not be adding all of the pages.
        //
        int nTotalPageCount = 0;

        for (int nCurrPage=0;nCurrPage<nPropPageCount && nCurrPage<c_MaxPageCount;nCurrPage++)
        {
            //
            // Only add the page if the controlling pbDisplay variable is NULL or points to a non-FALSE value
            //
            if (!pPropSheetPageInfo[nCurrPage].pbDisplay || *(pPropSheetPageInfo[nCurrPage].pbDisplay))
            {
                PROPSHEETPAGE CurrentPropSheetPage = {0};

                //
                // Set up all of the required fields from out static info.
                //
                CurrentPropSheetPage.dwSize      = sizeof(PROPSHEETPAGE);
                CurrentPropSheetPage.hInstance   = g_hInstance;
                CurrentPropSheetPage.lParam      = reinterpret_cast<LPARAM>(this);
                CurrentPropSheetPage.pfnDlgProc  = pPropSheetPageInfo[nCurrPage].pfnDlgProc;
                CurrentPropSheetPage.pszTemplate = pPropSheetPageInfo[nCurrPage].pszTemplate;
                CurrentPropSheetPage.pszTitle    = strDownloadManagerTitle.String();
                CurrentPropSheetPage.dwFlags     = PSP_DEFAULT;

                //
                // Add in the fusion flags to get COMCTLV6
                //
                WiaUiUtil::PreparePropertyPageForFusion( &CurrentPropSheetPage  );

                //
                // If we want to save the index of this page, save it
                //
                if (pPropSheetPageInfo[nTotalPageCount].pnPageIndex)
                {
                    *(pPropSheetPageInfo[nTotalPageCount].pnPageIndex) = nTotalPageCount;
                }

                if (FirstPage == pPropSheetPageInfo[nCurrPage].PageType)
                {
                    //
                    // No title or subtitle needed for "first pages"
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_PREMATURE | PSP_HIDEHEADER | PSP_USETITLE;
                }
                else if (LastPage == pPropSheetPageInfo[nCurrPage].PageType)
                {
                    //
                    // No title or subtitle needed for "last pages"
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_HIDEHEADER | PSP_USETITLE;
                }
                else
                {
                    //
                    // Add header and subtitle
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_PREMATURE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USETITLE;

                    //
                    // Load the header and subtitle
                    //
                    LoadString( g_hInstance, pPropSheetPageInfo[nCurrPage].nIdTitle, pPropSheetPageInfo[nCurrPage].szTitle, ARRAYSIZE(pPropSheetPageInfo[nCurrPage].szTitle) );
                    LoadString( g_hInstance, pPropSheetPageInfo[nCurrPage].nIdSubTitle, pPropSheetPageInfo[nCurrPage].szSubTitle, ARRAYSIZE(pPropSheetPageInfo[nCurrPage].szSubTitle) );

                    //
                    // Assign the title and subtitle strings
                    //
                    CurrentPropSheetPage.pszHeaderTitle    = pPropSheetPageInfo[nCurrPage].szTitle;
                    CurrentPropSheetPage.pszHeaderSubTitle = pPropSheetPageInfo[nCurrPage].szSubTitle;
                }

                //
                // Create and add one more page
                //
                HPROPSHEETPAGE hPropSheetPage = CreatePropertySheetPage(&CurrentPropSheetPage);
                if (!hPropSheetPage)
                {
                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreatePropertySheetPage failed on page %d"), nCurrPage ));
                    return E_FAIL;
                }
                PropSheetPages[nTotalPageCount++] = hPropSheetPage;
            }
        }

        //
        // Save the count of our pages
        //
        m_nWiaWizardPageCount = nTotalPageCount;

        //
        // Create the property sheet header
        //
        PROPSHEETHEADER PropSheetHeader = {0};
        PropSheetHeader.hwndParent      = NULL;
        PropSheetHeader.dwSize          = sizeof(PROPSHEETHEADER);
        PropSheetHeader.dwFlags         = PSH_NOAPPLYNOW | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_USECALLBACK;
        PropSheetHeader.pszbmWatermark  = pszbmWatermark;
        PropSheetHeader.pszbmHeader     = pszbmHeader;
        PropSheetHeader.hInstance       = g_hInstance;
        PropSheetHeader.nPages          = m_nWiaWizardPageCount;
        PropSheetHeader.phpage          = PropSheetPages;
        PropSheetHeader.pfnCallback     = PropSheetCallback;
        PropSheetHeader.nStartPage      = SuppressFirstPage() ? 1 : 0;

        //
        // Display the property sheet
        //
        INT_PTR nResult = PropertySheet( &PropSheetHeader );

        //
        // Check for an error
        //
        if (nResult == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

    }
    else
    {
        //
        // Generic failure will have to do
        //
        hr = E_FAIL;

        //
        // Dismiss the wait dialog before we display the message box
        //
        if (m_pWiaProgressDialog)
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        //
        // Display an error message telling the user this is not a supported device
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString(IDS_UNSUPPORTED_DEVICE,g_hInstance), CSimpleString(IDS_ERROR_TITLE,g_hInstance), CMessageBoxEx::MBEX_ICONWARNING );

        WIA_ERROR((TEXT("Unknown device type")));
    }

    //
    // Make sure the status dialog has been dismissed by now
    //
    if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }
    return hr;
}

bool CAcquisitionManagerControllerWindow::EnumItemsCallback( CWiaItemList::CEnumEvent EnumEvent, UINT nData, LPARAM lParam, bool bForceUpdate )
{
    //
    // We would return false to cancel enumeration
    //
    bool bResult = true;

    //
    // Get the instance of the controller window
    //
    CAcquisitionManagerControllerWindow *pThis = reinterpret_cast<CAcquisitionManagerControllerWindow*>(lParam);
    if (pThis)
    {
        //
        // Which event are we being called for?
        //
        switch (EnumEvent)
        {
        case CWiaItemList::ReadingItemInfo:
            //
            // This is the event that is sent while the tree is being built
            //
            if (pThis->m_pWiaProgressDialog && pThis->m_bUpdateEnumerationCount && nData)
            {
                //
                // We don't want to update the status text any more often than this (minimizes flicker)
                //
                const DWORD dwMinDelta = 200;

                //
                // Get the current tick count and see if it has been more than dwMinDelta milliseconds since our last update
                //
                DWORD dwCurrentTickCount = GetTickCount();
                if (bForceUpdate || dwCurrentTickCount - pThis->m_dwLastEnumerationTickCount >= dwMinDelta)
                {
                    //
                    // Assume we haven't been cancelled
                    //
                    BOOL bCancelled = FALSE;

                    //
                    // Set the progress message
                    //
                    pThis->m_pWiaProgressDialog->SetMessage( CSimpleStringWide().Format( IDS_ENUMERATIONCOUNT, g_hInstance, nData ) );

                    //
                    // Find out if we've been cancelled
                    //
                    pThis->m_pWiaProgressDialog->Cancelled(&bCancelled);

                    //
                    // If we have been cancelled, we'll return false to stop the enumeration
                    //
                    if (bCancelled)
                    {
                        bResult = false;
                    }

                    //
                    // Save the current tick count for next time
                    //
                    pThis->m_dwLastEnumerationTickCount = dwCurrentTickCount;
                }
            }
            break;
        }
    }
    return bResult;
}

LRESULT CAcquisitionManagerControllerWindow::OnPostInitialize( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnInitialize"));

    //
    // Try to get the correct animation for this device type.  If we can't get the type,
    // just use the camera animation.  If there is a real error, it will get handled later
    //
    int nAnimationType = WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE;
    LONG nAnimationDeviceType = 0;

    //
    // We don't want to update our enumeration count in the progress dialog for scanners, but we do for cameras
    //
    m_bUpdateEnumerationCount = true;
    if (SUCCEEDED(WiaUiUtil::GetDeviceTypeFromId( CSimpleBStr(m_pEventParameters->strDeviceID), &nAnimationDeviceType )))
    {
        if (StiDeviceTypeScanner == GET_STIDEVICE_TYPE(nAnimationDeviceType))
        {
            nAnimationType = WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE;
            m_bUpdateEnumerationCount = false;
        }
        else if (StiDeviceTypeStreamingVideo == GET_STIDEVICE_TYPE(nAnimationDeviceType))
        {
            nAnimationType = WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE;
        }
    }

    //
    // Put up a wait dialog
    //
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog );
    if (SUCCEEDED(hr))
    {
        m_pWiaProgressDialog->Create( m_hWnd, nAnimationType|WIA_PROGRESSDLG_NO_PROGRESS );
        m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_DOWNLOADMANAGER_NAME,g_hInstance)));
        m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_PROGDLG_MESSAGE,g_hInstance)));

        //
        // Show the progress dialog
        //
        m_pWiaProgressDialog->Show();

        //
        // Create the global interface table
        //
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (VOID**)&m_pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            //
            // Create the device
            //
            hr = WIA_FORCE_ERROR(FE_WIAACMGR,100,CreateDevice());
            if (SUCCEEDED(hr))
            {
                //
                // Save a debug snapshot, if the entry is in the registry
                //
                WIA_SAVEITEMTREELOG(HKEY_CURRENT_USER,REGSTR_PATH_USER_SETTINGS_WIAACMGR,TEXT("CreateDeviceTreeSnapshot"),true,m_pWiaItemRoot);

                //
                // First, figure out what kind of device it is and get the UI class ID
                //
                if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_DEV_TYPE, m_nDeviceType ) &&
                    PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_UI_CLSID, m_strwDeviceUiClassId ))
                {
                    switch (GET_STIDEVICE_TYPE(m_nDeviceType))
                    {
                    case StiDeviceTypeScanner:
                        m_DeviceTypeMode = ScannerMode;
                        break;

                    case StiDeviceTypeDigitalCamera:
                        m_DeviceTypeMode = CameraMode;
                        break;

                    case StiDeviceTypeStreamingVideo:
                        m_DeviceTypeMode = VideoMode;
                        break;

                    default:
                        m_DeviceTypeMode = UnknownMode;
                        hr = E_FAIL;
                        break;
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_ERROR((TEXT("Unable to read the device type")));
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Get the device name
                    //
                    PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_DEV_NAME, m_strwDeviceName );

                    //
                    // Find out if Take Picture is supported
                    //
                    m_bTakePictureIsSupported = WiaUiUtil::IsDeviceCommandSupported( m_pWiaItemRoot, WIA_CMD_TAKE_PICTURE );

                    //
                    // Enumerate all the items in the device tree
                    //
                    hr = m_WiaItemList.EnumerateAllWiaItems(m_pWiaItemRoot,EnumItemsCallback,reinterpret_cast<LPARAM>(this));
                    if (S_OK == hr)
                    {
                        if (ScannerMode == m_DeviceTypeMode)
                        {
                            //
                            // Mark only one scanner item as selected, and save it as the current scanner item
                            //
                            MarkAllItemsUnselected( m_WiaItemList.Root() );
                            CSimpleDynamicArray<CWiaItem*>  Items;
                            GetAllImageItems( Items, m_WiaItemList.Root() );
                            if (Items.Size() && Items[0])
                            {
                                m_pCurrentScannerItem = Items[0];
                                MarkItemSelected(Items[0],m_WiaItemList.Root());

                                //
                                // Make sure we have all of the properties we need to construct the device
                                //
                                hr = WiaUiUtil::VerifyScannerProperties(Items[0]->WiaItem());
                            }
                            else
                            {
                                hr = E_FAIL;
                                WIA_ERROR((TEXT("There don't seem to be any transfer items on this scanner")));
                            }
                        }
                        else if (VideoMode == m_DeviceTypeMode || CameraMode == m_DeviceTypeMode)
                        {
                            //
                            // Get the thumbnail width
                            //
                            LONG nWidth, nHeight;
                            if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DPC_THUMB_WIDTH, nWidth ) &&
                                PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DPC_THUMB_HEIGHT, nHeight ))
                            {
                                int nMax = max(nWidth,nHeight); // Allow for rotation
                                m_sizeThumbnails.cx = max(c_nMinThumbnailWidth,min(nMax,c_nMaxThumbnailWidth));
                                m_sizeThumbnails.cy = max(c_nMinThumbnailHeight,min(nMax,c_nMaxThumbnailHeight));
                            }
                        }
                    }
                }
            }
        }
    }


    if (!SUCCEEDED(hr))
    {
        //
        // Dismiss the wait dialog
        //
        if (m_pWiaProgressDialog)
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        //
        // Choose an appropriate error message if we have a recognizable error.
        //
        CSimpleString strMessage;
        int nIconId = 0;
        switch (hr)
        {
        case WIA_ERROR_BUSY:
            strMessage.LoadString( IDS_DEVICE_BUSY, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;

        case WIA_S_NO_DEVICE_AVAILABLE:
            strMessage.LoadString( IDS_DEVICE_NOT_FOUND, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;

        case HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED):
            strMessage = WiaUiUtil::GetErrorTextFromHResult(HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED));
            nIconId = MB_ICONINFORMATION;
            break;

        default:
            strMessage.LoadString( IDS_UNABLETOCREATE, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;
        }

        //
        // Tell the user we had a problem creating the device
        //
        MessageBox( m_hWnd, strMessage, CSimpleString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance ), nIconId );
    }
    else if (S_OK == hr)
    {
        hr = CreateAndExecuteWizard();
    }
    //
    // If we were cancelled, shut down the progress UI
    //
    else if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }

    //
    // Make sure we kill this window, and thus, this thread.
    //
    PostMessage( m_hWnd, WM_CLOSE, 0, 0 );

    return 0;
}

LRESULT CAcquisitionManagerControllerWindow::OnCreate( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnCreate"));

    //
    // Ensure the background thread was started
    //
    if (!m_hBackgroundThread || !m_pThreadMessageQueue)
    {
        WIA_ERROR((TEXT("There was an error starting the background thread")));
        return -1;
    }

    //
    // Make sure we got a valid lParam
    //
    LPCREATESTRUCT pCreateStruct = reinterpret_cast<LPCREATESTRUCT>(lParam);
    if (!pCreateStruct)
    {
        WIA_ERROR((TEXT("pCreateStruct was NULL")));
        return -1;
    }

    //
    // Get the event parameters
    //
    m_pEventParameters = reinterpret_cast<CEventParameters*>(pCreateStruct->lpCreateParams);
    if (!m_pEventParameters)
    {
        WIA_ERROR((TEXT("m_pEventParameters was NULL")));
        return -1;
    }

    SetForegroundWindow(m_hWnd);

    //
    // Center ourselves on the parent window
    //
    WiaUiUtil::CenterWindow( m_hWnd, m_pEventParameters->hwndParent );

    PostMessage( m_hWnd, PWM_POSTINITIALIZE, 0, 0 );

    return 0;
}

void CAcquisitionManagerControllerWindow::OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    CDownloadImagesThreadNotifyMessage *pDownloadImageThreadNotifyMessage = dynamic_cast<CDownloadImagesThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadImageThreadNotifyMessage)
    {
        switch (pDownloadImageThreadNotifyMessage->Status())
        {
        case CDownloadImagesThreadNotifyMessage::End:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadImage:
                    {
                        if (S_OK != pDownloadImageThreadNotifyMessage->hr())
                        {
                            m_nFailedImagesCount++;
                        }
                    }
                    break;

                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        if (S_OK == pDownloadImageThreadNotifyMessage->hr())
                        {
                            m_DownloadedFileInformationList = pDownloadImageThreadNotifyMessage->DownloadedFileInformation();
                        }
                        else
                        {
                            m_DownloadedFileInformationList.Destroy();
                        }
                    }
                    break;
                }
            }
            break;

        case CDownloadImagesThreadNotifyMessage::Begin:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        m_nFailedImagesCount = 0;
                    }
                    break;
                }
            }
            break;
        }
    }
}

void CAcquisitionManagerControllerWindow::OnNotifyDownloadThumbnail( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::OnNotifyDownloadThumbnail( %d, %p )"), nMsg, pThreadNotificationMessage ));
    CDownloadThumbnailsThreadNotifyMessage *pDownloadThumbnailsThreadNotifyMessage= dynamic_cast<CDownloadThumbnailsThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadThumbnailsThreadNotifyMessage)
    {
        switch (pDownloadThumbnailsThreadNotifyMessage->Status())
        {
        case CDownloadThumbnailsThreadNotifyMessage::Begin:
            {
            }
            break;
        case CDownloadThumbnailsThreadNotifyMessage::Update:
            {
            }
            break;
        case CDownloadThumbnailsThreadNotifyMessage::End:
            {
                switch (pDownloadThumbnailsThreadNotifyMessage->Operation())
                {
                case CDownloadThumbnailsThreadNotifyMessage::DownloadThumbnail:
                    {
                        WIA_TRACE((TEXT("Handling CDownloadThumbnailsThreadNotifyMessage::DownloadThumbnail")));
                        //
                        // Find the item in the list
                        //
                        CWiaItem *pWiaItem = m_WiaItemList.Find( pDownloadThumbnailsThreadNotifyMessage->Cookie() );
                        if (pWiaItem)
                        {
                            //
                            // Set the flag that indicates we've tried this image already
                            //
                            pWiaItem->AttemptedThumbnailDownload(true);

                            //
                            // Make sure we have valid thumbnail data
                            //
                            if (pDownloadThumbnailsThreadNotifyMessage->BitmapData())
                            {
                                //
                                // Don't replace existing thumbnail data
                                //
                                if (!pWiaItem->BitmapData())
                                {
                                    //
                                    // Set the item's thumbnail data.  Take ownership of the thumbnail data
                                    //
                                    WIA_TRACE((TEXT("Found the thumbnail for the item with the GIT cookie %08X"), pDownloadThumbnailsThreadNotifyMessage->Cookie() ));
                                    pWiaItem->BitmapData(pDownloadThumbnailsThreadNotifyMessage->DetachBitmapData());
                                    pWiaItem->Width(pDownloadThumbnailsThreadNotifyMessage->Width());
                                    pWiaItem->Height(pDownloadThumbnailsThreadNotifyMessage->Height());
                                    pWiaItem->BitmapDataLength(pDownloadThumbnailsThreadNotifyMessage->BitmapDataLength());
                                    pWiaItem->ImageWidth(pDownloadThumbnailsThreadNotifyMessage->PictureWidth());
                                    pWiaItem->ImageHeight(pDownloadThumbnailsThreadNotifyMessage->PictureHeight());
                                    pWiaItem->AnnotationType(pDownloadThumbnailsThreadNotifyMessage->AnnotationType());
                                    pWiaItem->DefExt(pDownloadThumbnailsThreadNotifyMessage->DefExt());
                                }
                                else
                                {
                                    WIA_TRACE((TEXT("Already got the image data for item %08X!"), pDownloadThumbnailsThreadNotifyMessage->Cookie()));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("pDownloadThumbnailsThreadNotifyMessage->BitmapData was NULL!")));
                            }


                            //
                            // Assign the default format
                            //
                            pWiaItem->DefaultFormat(pDownloadThumbnailsThreadNotifyMessage->DefaultFormat());

                            //
                            // Assign the access flags
                            //
                            pWiaItem->AccessRights(pDownloadThumbnailsThreadNotifyMessage->AccessRights());

                            //
                            // Make sure we discard rotation angles if rotation is not possible
                            //
                            pWiaItem->DiscardRotationIfNecessary();
                        }
                        else
                        {
                            WIA_ERROR((TEXT("Can't find %08X in the item list"), pDownloadThumbnailsThreadNotifyMessage->Cookie() ));
                        }
                    }
                    break;
                }
            }
            break;
        }
    }
}

LRESULT CAcquisitionManagerControllerWindow::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::OnThreadNotification( %d, %08X )"), wParam, lParam ));
    CThreadNotificationMessage *pThreadNotificationMessage = reinterpret_cast<CThreadNotificationMessage*>(lParam);
    if (pThreadNotificationMessage)
    {
        switch (pThreadNotificationMessage->Message())
        {
        case TQ_DOWNLOADTHUMBNAIL:
            OnNotifyDownloadThumbnail( static_cast<UINT>(wParam), pThreadNotificationMessage );
            break;

        case TQ_DOWNLOADIMAGE:
            OnNotifyDownloadImage( static_cast<UINT>(wParam), pThreadNotificationMessage );
            break;
        }

        //
        // Notify all the registered windows
        //
        m_WindowList.SendMessage( m_nThreadNotificationMessage, wParam, lParam );

        //
        // Free the message structure
        //
        delete pThreadNotificationMessage;
    }

    return HANDLED_THREAD_MESSAGE;
}


void CAcquisitionManagerControllerWindow::AddNewItemToList( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    WIA_PUSHFUNCTION((TEXT("CAcquisitionManagerControllerWindow::AddNewItemToList")));

    //
    // Check to see if the item is already in our list
    //
    CWiaItem *pWiaItem = m_WiaItemList.Find(pEventMessage->FullItemName());
    if (pWiaItem)
    {
        //
        // If it is already in our list, just return.
        //
        return;
    }

    //
    // Get an IWiaItem interface pointer for this item
    //
    CComPtr<IWiaItem> pItem;
    HRESULT hr = m_pWiaItemRoot->FindItemByName( 0, CSimpleBStr(pEventMessage->FullItemName()).BString(), &pItem );
    if (SUCCEEDED(hr) && pItem)
    {
        //
        // Add it to the root of the item tree
        //
        m_WiaItemList.Add( NULL, new CWiaItem(pItem) );
    }
}


void CAcquisitionManagerControllerWindow::RequestThumbnailForNewItem( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    WIA_PUSHFUNCTION((TEXT("CAcquisitionManagerControllerWindow::RequestThumbnailForNewItem")));

    //
    // Find the item in our list
    //
    CWiaItem *pWiaItem = m_WiaItemList.Find(pEventMessage->FullItemName());
    if (pWiaItem)
    {
        //
        // Add this item's cookie to an empty list
        //
        CSimpleDynamicArray<DWORD> Cookies;
        Cookies.Append( pWiaItem->GlobalInterfaceTableCookie() );
        if (Cookies.Size())
        {
            //
            // Reset the cancel event
            //
            m_EventThumbnailCancel.Reset();

            //
            // Prepare and send the request
            //
            CDownloadThumbnailsThreadMessage *pDownloadThumbnailsThreadMessage = new CDownloadThumbnailsThreadMessage( m_hWnd, Cookies, m_EventThumbnailCancel.Event() );
            if (pDownloadThumbnailsThreadMessage)
            {
                m_pThreadMessageQueue->Enqueue( pDownloadThumbnailsThreadMessage, CThreadMessageQueue::PriorityNormal );
            }
        }
    }

}


LRESULT CAcquisitionManagerControllerWindow::OnEventNotification( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnEventNotification"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // If we got an item created message, add the item to the list
        //
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            AddNewItemToList( pEventMessage );
        }

        //
        // On Disconnect, perform disconnection operations
        //
        else if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            DisplayDisconnectMessageAndExit();
        }

        //
        // Propagate the message to all currently registered windows
        //
        m_WindowList.SendMessage( m_nWiaEventMessage, wParam, lParam );

        //
        // Make sure we ask for the new thumbnail *AFTER* we tell the views the item exists
        //
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            RequestThumbnailForNewItem( pEventMessage );
        }

        //
        // If this is a deleted item event, mark this item deleted
        //
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_DELETED)
        {
            CWiaItem *pWiaItem = m_WiaItemList.Find(pEventMessage->FullItemName());
            if (pWiaItem)
            {
                pWiaItem->MarkDeleted();
            }
        }

        //
        // On a connect event for this device, close the wizard
        //
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_CONNECTED)
        {
            if (m_bDisconnected && m_hWndWizard)
            {
                PropSheet_PressButton(m_hWndWizard,PSBTN_CANCEL);
            }
        }

        //
        // Free the event message
        //
        delete pEventMessage;
    }
    return HANDLED_EVENT_MESSAGE;
}

LRESULT CAcquisitionManagerControllerWindow::OnPowerBroadcast( WPARAM wParam, LPARAM lParam )
{
    if (PBT_APMQUERYSUSPEND == wParam)
    {
    }
    return TRUE;
}

LRESULT CALLBACK CAcquisitionManagerControllerWindow::WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_REFCOUNTED_MESSAGE_HANDLERS(CAcquisitionManagerControllerWindow)
    {
        SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
        SC_HANDLE_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_MESSAGE( PWM_POSTINITIALIZE, OnPostInitialize );
        SC_HANDLE_MESSAGE( WM_POWERBROADCAST, OnPowerBroadcast );
    }
    SC_HANDLE_REGISTERED_MESSAGE(m_nThreadNotificationMessage,OnThreadNotification);
    SC_HANDLE_REGISTERED_MESSAGE(m_nWiaEventMessage,OnEventNotification);
    SC_END_MESSAGE_HANDLERS();
}


bool CAcquisitionManagerControllerWindow::Register( HINSTANCE hInstance )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::Register"));
    WNDCLASSEX WndClassEx;
    memset( &WndClassEx, 0, sizeof(WndClassEx) );
    WndClassEx.cbSize = sizeof(WNDCLASSEX);
    WndClassEx.lpfnWndProc = WndProc;
    WndClassEx.hInstance = hInstance;
    WndClassEx.hCursor = LoadCursor(NULL,IDC_ARROW);
    WndClassEx.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    WndClassEx.lpszClassName = ACQUISITION_MANAGER_CONTROLLER_WINDOW_CLASSNAME;
    BOOL bResult = (::RegisterClassEx(&WndClassEx) != 0);
    DWORD dw = GetLastError();
    return(bResult != 0);
}


HWND CAcquisitionManagerControllerWindow::Create( HINSTANCE hInstance, CEventParameters *pEventParameters )
{
    return CreateWindowEx( 0, ACQUISITION_MANAGER_CONTROLLER_WINDOW_CLASSNAME,
                           TEXT("WIA Acquisition Manager Controller Window"),
                           WS_OVERLAPPEDWINDOW,
                           CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                           NULL, NULL, hInstance, pEventParameters );
}


//
// Reference counting for our object
//
STDMETHODIMP_(ULONG) CAcquisitionManagerControllerWindow::AddRef(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::AddRef"));
    ULONG nRes = InterlockedIncrement(&m_cRef);
    WIA_TRACE((TEXT("m_cRef: %d"),m_cRef));
    return nRes;
}


STDMETHODIMP_(ULONG) CAcquisitionManagerControllerWindow::Release(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::Release"));
    if (InterlockedDecrement(&m_cRef)==0)
    {
        WIA_TRACE((TEXT("m_cRef: 0")));

        //
        // Cause this thread to exit
        //
        PostQuitMessage(0);

        //
        // Delete this instance of the wizard
        //
        delete this;
        return 0;
    }
    WIA_TRACE((TEXT("m_cRef: %d"),m_cRef));
    return(m_cRef);
}

HRESULT CAcquisitionManagerControllerWindow::QueryInterface( REFIID riid, void **ppvObject )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::QueryInterface"));
    HRESULT hr = S_OK;
    *ppvObject = NULL;
    if (IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObject = static_cast<IWizardSite*>(this);
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    }
    else if (IsEqualIID( riid, IID_IWizardSite ))
    {
        *ppvObject = static_cast<IWizardSite*>(this);
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    }
    else if (IsEqualIID( riid, IID_IServiceProvider ))
    {
        *ppvObject = static_cast<IServiceProvider*>(this);
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    }
    else
    {
        WIA_PRINTGUID((riid,TEXT("Unknown interface")));
        *ppvObject = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;
}


//
// IWizardSite
//
HRESULT CAcquisitionManagerControllerWindow::GetPreviousPage(HPROPSHEETPAGE *phPage)
{
    if (!phPage)
    {
        return E_INVALIDARG;
    }
    *phPage = PropSheet_IndexToPage( m_hWndWizard, m_nUploadQueryPageIndex );
    if (*phPage)
    {
        return S_OK;
    }
    return E_FAIL;
}

HRESULT CAcquisitionManagerControllerWindow::GetNextPage(HPROPSHEETPAGE *phPage)
{
    if (!phPage)
    {
        return E_INVALIDARG;
    }
    *phPage = PropSheet_IndexToPage( m_hWndWizard, m_nFinishPageIndex );
    if (*phPage)
    {
        return S_OK;
    }
    return E_FAIL;
}


HRESULT CAcquisitionManagerControllerWindow::GetCancelledPage(HPROPSHEETPAGE *phPage)
{
    return GetNextPage(phPage);
}

//
// IServiceProvider
//
HRESULT CAcquisitionManagerControllerWindow::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::QueryService"));
    WIA_PRINTGUID((guidService,TEXT("guidService")));
    WIA_PRINTGUID((riid,TEXT("riid")));
    
    if (!ppv)
    {
        return E_INVALIDARG;
    }

    //
    // Initialize result
    //
    *ppv = NULL;

    if (guidService == SID_PublishingWizard)
    {
    }
    else
    {
    }

    return E_FAIL;
}


static CSimpleString GetDisplayName( IShellItem *pShellItem )
{
    CSimpleString strResult;
    if (pShellItem)
    {
        LPOLESTR pszStr = NULL;
        if (SUCCEEDED(pShellItem->GetDisplayName( SIGDN_FILESYSPATH, &pszStr )) && pszStr)
        {
            strResult = CSimpleStringConvert::NaturalString(CSimpleStringWide(pszStr));

            CComPtr<IMalloc> pMalloc;
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free( pszStr );
            }
        }
    }
    return strResult;
}

//
// These two functions are needed to use the generic event handler class
//
void DllAddRef(void)
{
#if !defined(DBG_GENERATE_PRETEND_EVENT)
    _Module.Lock();
#endif
}

void DllRelease(void)
{
#if !defined(DBG_GENERATE_PRETEND_EVENT)
    _Module.Unlock();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\acqmgrcw.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       ACQMGRCW.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __ACQMGRCW_H_INCLUDED
#define __ACQMGRCW_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "evntparm.h"
#include "bkthread.h"
#include "wiaitem.h"
#include "errors.h"
#include "thrdmsg.h"
#include "thrdntfy.h"
#include "wndlist.h"
#include "shmemsec.h"
#include "wiaregst.h"
#include "wiadevdp.h"
#include "destdata.h"
#include "gwiaevnt.h"

#define REGSTR_PATH_USER_SETTINGS_WIAACMGR         REGSTR_PATH_USER_SETTINGS TEXT("\\WiaAcquisitionManager")
#define REGSTR_KEYNAME_USER_SETTINGS_WIAACMGR      TEXT("AcquisitionManagerDialogCustomSettings")
#define REG_STR_ROOTNAME_MRU                       TEXT("RootFileNameMru")
#define REG_STR_DIRNAME_MRU                        TEXT("DirectoryNameMru")
#define REG_STR_EXIT_AFTER_DOWNLOAD                TEXT("ExitAfterDownload")
#define REG_STR_LASTFORMAT                         TEXT("LastSaveAsFormat")
#define REG_STR_OPENSHELL                          TEXT("OpenShellAfterDownload")
#define REG_STR_SUPRESSFIRSTPAGE                   TEXT("SuppressFirstPage")

#define CONNECT_SOUND                              TEXT("WiaDeviceConnect")
#define DISCONNECT_SOUND                           TEXT("WiaDeviceDisconnect")

//
// We use different advanced settings for scanners and cameras, thus we store them in different places
//
#define REG_STR_STORE_IN_SUBDIRECTORY_SCANNER      TEXT("StorePicturesInSubdirectoryScanner")
#define REG_STR_SUBDIRECTORY_DATED_SCANNER         TEXT("UseDatedSubdirectoryScanner")
#define REG_STR_STORE_IN_SUBDIRECTORY_CAMERA       TEXT("StorePicturesInSubdirectoryCamera")
#define REG_STR_SUBDIRECTORY_DATED_CAMERA          TEXT("UseDatedSubdirectoryCamera")

#define ACQUISITION_MANAGER_CONTROLLER_WINDOW_CLASSNAME TEXT("AcquisitionManagerControllerWindow")
#define ACQUISITION_MANAGER_DEVICE_MUTEX_ROOT_NAME      TEXT("AcquisitionManagerDevice:")

#define STR_UPLOAD_WIZARD_MESSAGE                  TEXT("WiaUploadWizardInternalMessage")

#ifndef StiDeviceTypeStreamingVideo
#define StiDeviceTypeStreamingVideo 3
#endif

#define FE_WIAACMGR TEXT("Scanner and Camera Wizard")

//
// For handling createdevice busy errors
//
#define CREATE_DEVICE_RETRY_MAX_COUNT 10   // 10 tries
#define CREATE_DEVICE_RETRY_WAIT      1000 // 1000 Milliseconds (1 second) wait between retries


#define MAX_WIZ_PAGES                 10
//
// Private user window messages
//
#define PWM_POSTINITIALIZE       (WM_USER+0x0001)


class CAcquisitionManagerControllerWindow : public IWizardSite, IServiceProvider
{
public:
    enum CDeviceTypeMode
    {
        UnknownMode,  // This would be an error
        CameraMode,
        ScannerMode,
        VideoMode
    };

    enum
    {
        ScannerTypeUnknown    = 0,
        ScannerTypeFlatbed    = 1,
        ScannerTypeScrollFed  = 2,
        ScannerTypeFlatbedAdf = 3,
    };

    enum
    {
        OnDisconnectGotoLastpage = 0x00000001,
        OnDisconnectFailDownload = 0x00000002,
        OnDisconnectFailUpload   = 0x00000004,
        OnDisconnectFailDelete   = 0x00000008,
        DontAllowSuspend         = 0x00000100
    };
    
    typedef bool (*ComparisonCallbackFuntion)( const CWiaItem &, LPARAM lParam );

private:
    //
    // Private data
    //

public:
    //
    // Public data
    //
    CComPtr<IGlobalInterfaceTable>  m_pGlobalInterfaceTable;            // Global interface table
    CComPtr<IUnknown>               m_pConnectEventObject;              // Event object
    CComPtr<IUnknown>               m_pCreateItemEventObject;           // Event object
    CComPtr<IUnknown>               m_pDeleteItemEventObject;           // Event object
    CComPtr<IUnknown>               m_pDisconnectEventObject;           // Event object
    CComPtr<IWiaItem>               m_pWiaItemRoot;                     // Root item
    CComPtr<IWiaProgressDialog>     m_pWiaProgressDialog;               // The progress dialog, used during initialization
    CComPtr<IPublishingWizard>      m_pPublishingWizard;                // Web upload wizard
    CDestinationData                m_CurrentDownloadDestination;       // Current download destination
    CDestinationData::CNameData     m_DestinationNameData;              // Current download destination data
    CDeviceTypeMode                 m_DeviceTypeMode;                   // Which kind of device are we?
    CEventParameters               *m_pEventParameters;                 // The parameters we were started with
    CDownloadedFileInformationList  m_DownloadedFileInformationList;    // A list of filenames we have downloaded
    CSimpleEvent                    m_CancelEvent;                      // Cancel event, which is set when we want to cancel a download
    CSimpleEvent                    m_EventThumbnailCancel;             // Event that is set to cancel thumbnail download
    CSimpleEvent                    m_EventPauseBackgroundThread;       // Event that is set pause the background thread
    CSimpleString                   m_strErrorMessage;                  // Error message to be displayed by the finish page
    CSimpleStringWide               m_strwDeviceName;                   // Device name
    CSimpleStringWide               m_strwDeviceUiClassId;              // Device name
    CThreadMessageQueue            *m_pThreadMessageQueue;              // The background queue
    CWiaItem                       *m_pCurrentScannerItem;              // The scanner item from which we are transferring data
    CWiaItemList                    m_WiaItemList;                      // list of all enumerated wia items
    CWindowList                     m_WindowList;                       // The list of all the windows which are subscribing to broadcast messages
    GUID                            m_guidOutputFormat;                 // Output format
    HANDLE                          m_hBackgroundThread;                // The background worker thread
    HICON                           m_hWizardIconBig;                   // The large icon used by the wizard
    HICON                           m_hWizardIconSmall;                 // The small icon used by the wizard
    HRESULT                         m_hrDownloadResult;                 // HRESULT for the entire download
    HRESULT                         m_hrUploadResult;                   // HRESULT for the entire upload
    HRESULT                         m_hrDeleteResult;                   // HRESULT for the entire deletion
    HWND                            m_hWndWizard;                       // HWND of the main wizard window
    LONG                            m_cRef;                             // Reference count
    LONG                            m_nDeviceType;                      // STI Device type
    SIZE                            m_sizeThumbnails;                   // The size of camera thumbnails
    TCHAR                           m_szDestinationDirectory[MAX_PATH]; // The directory to which we are going to download the images
    TCHAR                           m_szRootFileName[MAX_PATH];         // Base file name
    UINT                            m_nThreadNotificationMessage;       // Registered window message, used to identify worker thread notification messages
    UINT                            m_nUploadWizardPageCount;           // Number of pages in the web upload wizard
    UINT                            m_nWiaEventMessage;                 // Registered window message, used to identify event messages
    UINT                            m_nWiaWizardPageCount;              // Number of pages in the WIA wizard
    UINT                            m_OnDisconnect;                     // Flags which specify behavior on receipt of disconnect event
    bool                            m_bDeletePicturesIfSuccessful;      // Set to true if we should delete the pictures when we are done
    bool                            m_bDisconnected;                    // Set to true if the device has been disconnected
    bool                            m_bOpenShellAfterDownload;          // Set to true to open the shell after we download all of the pictures
    bool                            m_bStampTimeOnSavedFiles;           // Set to true to save the time on files
    bool                            m_bSuppressFirstPage;               // Set to true to suppress display of the welcome page
    bool                            m_bTakePictureIsSupported;          // Set to true if the device supports the TAKE PICTURE command
    bool                            m_bUploadToWeb;                     // Set to true to chain NETPLWIZ
    bool                            m_bDownloadCancelled;               // Set to true to cancel the web upload
    bool                            m_bUpdateEnumerationCount;          // Update the count of images during enumeration.  We suppress update for scanners.
    int                             m_nDestinationPageIndex;            // The index, in the HPROPSHEETPAGE array, of the destination page
    int                             m_nSelectionPageIndex;              // The index, in the HPROPSHEETPAGE array, of the selection page
    int                             m_nFailedImagesCount;               // Count of all download failures
    int                             m_nFinishPageIndex;                 // The index, in the HPROPSHEETPAGE array, of the finish page
    int                             m_nProgressPageIndex;               // The index, in the HPROPSHEETPAGE array, of the download progress page
    int                             m_nUploadQueryPageIndex;            // The index, in the HPROPSHEETPAGE array, of the upload progress page
    int                             m_nDeleteProgressPageIndex;         // The index, in the HPROPSHEETPAGE array, of the delete progress page
    int                             m_nScannerType;                     // What type of scanner are we dealing with?
    HWND                            m_hWnd;                             // Our hidden window
    DWORD                           m_dwLastEnumerationTickCount;       // To ensure we don't update the progress dialog too often
    HPROPSHEETPAGE                  m_PublishWizardPages[MAX_WIZ_PAGES];

private:
    //
    // No implementation
    //
    CAcquisitionManagerControllerWindow(void);
    CAcquisitionManagerControllerWindow( const CAcquisitionManagerControllerWindow & );
    CAcquisitionManagerControllerWindow &operator=( const CAcquisitionManagerControllerWindow & );

private:
    //
    // Constructor and destructor
    //
    explicit CAcquisitionManagerControllerWindow( HWND hWnd );
    virtual ~CAcquisitionManagerControllerWindow(void);

    //
    // Private helper functions
    //
    HRESULT CreateDevice(void);
    void GetCookiesOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies );
    void GetRotationOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<int> &Rotation );
    void GetCookiesOfAllImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies );
    void GetSelectedItems( CWiaItem *pCurr, CSimpleDynamicArray<CWiaItem*> &Items );
    void MarkAllItemsUnselected( CWiaItem *pCurrItem );
    void MarkItemSelected( CWiaItem *pItem, CWiaItem *pCurrItem );
    HRESULT CreateAndExecuteWizard(void);
    void DetermineScannerType(void);
    void AddNewItemToList( CGenericWiaEventHandler::CEventMessage *pEventMessage );
    void RequestThumbnailForNewItem( CGenericWiaEventHandler::CEventMessage *pEventMessage );
    static bool EnumItemsCallback( CWiaItemList::CEnumEvent EnumEvent, UINT nData, LPARAM lParam, bool bForceUpdate );

    //
    // Standard windows message handlers
    //
    LRESULT OnCreate( WPARAM, LPARAM lParam );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnPowerBroadcast( WPARAM, LPARAM );

    //
    // Custom windows message handlers
    //
    LRESULT OnPostInitialize( WPARAM, LPARAM );
    LRESULT OnOldThreadNotification( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );

    //
    // Thread notification handlers
    //
    void OnNotifyDownloadThumbnail( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    void OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    LRESULT OnEventNotification( WPARAM wParam, LPARAM lParam );

    //
    // Thread message handlers
    //
    static BOOL WINAPI OnThreadDestroy( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDownloadImage( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDownloadThumbnail( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadPreviewScan( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDeleteImages( CThreadMessage *pMsg );
private:
    //
    // Window procedure
    //
    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

    //
    // Property sheet callback
    //
    static int CALLBACK PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam );

public:

    //
    // Public functions
    //
    static bool IsCameraThumbnailDownloaded( const CWiaItem &WiaItem, LPARAM lParam );
    int GetCookies( CSimpleDynamicArray<DWORD> &Cookies, CWiaItem *pCurr, ComparisonCallbackFuntion pfnCallback, LPARAM lParam );
    bool DownloadSelectedImages( HANDLE hCancelDownloadEvent );
    bool DeleteDownloadedImages( HANDLE hCancelDeleteEvent );
    bool DeleteSelectedImages(void);
    void DownloadAllThumbnails(void);
    void SetMainWindowInSharedMemory( HWND hWnd );
    bool PerformPreviewScan( CWiaItem *pItem, HANDLE hCancelPreviewEvent );
    bool GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items, CWiaItem *pCurr );
    bool GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items );
    bool CanSomeSelectedImagesBeDeleted(void);
    BOOL ConfirmWizardCancel( HWND hWndParent );
    static bool DirectoryExists( LPCTSTR pszDirectoryName );
    static bool RecursiveCreateDirectory( CSimpleString strDirectoryName );
    static CSimpleString GetCurrentDate(void);
    void DisplayDisconnectMessageAndExit(void);
    CWiaItem *FindItemByName( LPCWSTR pwszItemName );
    int GetSelectedImageCount(void);
    bool SuppressFirstPage(void);
    bool IsSerialCamera(void);

public:

    //
    // Public creation functions
    //
    static bool Register( HINSTANCE hInstance );
    static HWND Create( HINSTANCE hInstance, CEventParameters *pEventParameters );

    //
    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    //
    // IWizardSite
    //
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage);
    
    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);
};


#endif //__ACQMGRCW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\acqthrd.h ===
#ifndef __ACQTHRD_H_INCLUDED
#define __ACQTHRD_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "evntparm.h"

class CAcquisitionThread
{
private:
    CEventParameters m_EventParameters;

private:
    explicit CAcquisitionThread( const CEventParameters &EventParameters )
    : m_EventParameters( EventParameters )
    {
    }

    ~CAcquisitionThread(void)
    {
    }

    HRESULT Run(void)
    {
        WIA_PUSHFUNCTION(TEXT("CAcquisitionThread::Run"));
        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            CAcquisitionManagerControllerWindow::Register( g_hInstance );
            HWND hWnd = CAcquisitionManagerControllerWindow::Create( g_hInstance, &m_EventParameters );
            if (!hWnd)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                if (!SUCCEEDED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("CAcquisitionManagerControllerWindow::Create failed")));
                }
            }
            MSG msg;
            while (GetMessage(&msg,0,0,0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            CoUninitialize();
        }
        return hr;
    }

    static DWORD ThreadProc( LPVOID pvParam )
    {
        WIA_PUSHFUNCTION(TEXT("CAcquisitionThread::ThreadProc"));
#if !defined(DBG_GENERATE_PRETEND_EVENT)
        _Module.Lock();
#endif
        DWORD dwResult = static_cast<DWORD>(E_FAIL);
        CAcquisitionThread *pAcquisitionThread = reinterpret_cast<CAcquisitionThread*>(pvParam);
        if (pAcquisitionThread)
        {
            dwResult = static_cast<DWORD>(pAcquisitionThread->Run());
            delete pAcquisitionThread;
        }
#if !defined(DBG_GENERATE_PRETEND_EVENT)
        _Module.Unlock();
#endif
        return dwResult;
    }

public:
    static HANDLE Create( const CEventParameters &EventParameters )
    {
        WIA_PUSHFUNCTION(TEXT("CAcquisitionThread::Create"));
        HANDLE hThreadResult = NULL;
        CAcquisitionThread *pAcquisitionThread = new CAcquisitionThread(EventParameters);
        if (pAcquisitionThread)
        {
            DWORD dwThreadId;
            hThreadResult = CreateThread( NULL, 0, ThreadProc, pAcquisitionThread, 0, &dwThreadId );
            if (!hThreadResult)
            {
                delete pAcquisitionThread;
            }
        }
        return hThreadResult;
    }
};

#endif // __ACQTHRD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\atl.cpp ===
// atl.cpp : source file that includes just the standard includes
// precomp.pch will be the pre-compiled header
// precomp.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comdelp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMDELP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Delete progress page.  Displays the thumbnail and download progress.
 *
 *******************************************************************************/
#ifndef __COMDELP_H_INCLUDED
#define __COMDELP_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "gphelper.h"

class CCommonDeleteProgressPage
{
private:
    // Private data
    HWND                                 m_hWnd;
    CAcquisitionManagerControllerWindow *m_pControllerWindow;
    int                                  m_nPictureCount;
    HANDLE                               m_hCancelDeleteEvent;
    CGdiPlusHelper                       m_GdiPlusHelper;
    UINT                                 m_nThreadNotificationMessage;
    HPROPSHEETPAGE                       m_hSwitchToNextPage;
    bool                                 m_bQueryingUser;
    bool                                 m_bDeleteCancelled;

private:
    // No implementation
    CCommonDeleteProgressPage(void);
    CCommonDeleteProgressPage( const CCommonDeleteProgressPage & );
    CCommonDeleteProgressPage &operator=( const CCommonDeleteProgressPage & );

private:
    // Constructor and destructor
    explicit CCommonDeleteProgressPage( HWND hWnd );
    ~CCommonDeleteProgressPage(void);

private:
    // Helpers
    void UpdatePercentComplete( int nPercent, bool bUploading );
    void UpdateCurrentPicture( int nPicture );
    void UpdateThumbnail( HBITMAP hBitmap, CWiaItem *pWiaItem );
    bool QueryCancel(void);

private:
    // WM_COMMAND handlers

    // Thread Message handlers
    void OnNotifyDeleteImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );

    // WM_NOTIFY handlers
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnKillActive( WPARAM, LPARAM );
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnReset( WPARAM, LPARAM );
    LRESULT OnQueryCancel( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );
    LRESULT OnEventNotification( WPARAM, LPARAM );
    LRESULT OnQueryEndSession( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __COMDELP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\camsel.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       CAMSEL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Camera selection page.  Displays thumbnails, and lets the user select which
 *               ones to download.
 *
 *******************************************************************************/
#ifndef __CAMSEL_H_INCLUDED
#define __CAMSEL_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "simarray.h"
#include "gphelper.h"
#include "itranhlp.h"
#include "createtb.h"
#include "wiavideo.h"

class CCameraSelectionPage
{
private:
    //
    // Used for icon grouping
    //
    class CListviewGroupInfo
    {
    private:
        CSimpleStringWide m_strGroupName;
        int               m_nGroupId;

    public:
        CListviewGroupInfo(void)
          : m_strGroupName(TEXT("")),
            m_nGroupId(-1)
        {
        }
        CListviewGroupInfo( const CListviewGroupInfo &other )
          : m_strGroupName(other.GroupName()),
            m_nGroupId(other.GroupId())
        {
        }
        CListviewGroupInfo( const CSimpleStringWide &strGroupName, int nGroupId=-1 )
          : m_strGroupName(strGroupName),
            m_nGroupId(nGroupId)
        {
        }
        ~CListviewGroupInfo(void)
        {
        }
        CListviewGroupInfo &operator=( const CListviewGroupInfo &other )
        {
            if (this != &other)
            {
                m_strGroupName = other.GroupName();
                m_nGroupId = other.GroupId();
            }
            return *this;
        }
        bool operator==( const CListviewGroupInfo &other )
        {
            return (other.GroupName() == m_strGroupName);
        }
        bool operator==( const CSimpleStringWide &strGroupName )
        {
            return (strGroupName == m_strGroupName);
        }
        CSimpleStringWide GroupName(void) const
        {
            return m_strGroupName;
        }
        int GroupId(void) const
        {
            return m_nGroupId;
        }
    };

    class CIconGroupList : public CSimpleDynamicArray<CListviewGroupInfo>
    {
    private:
        CIconGroupList( const CIconGroupList & );
        CIconGroupList& operator=( const CIconGroupList & );

    public:
        CIconGroupList(void)
        {
        }
        ~CIconGroupList(void)
        {
        }
        int Add( HWND hwndList, const CSimpleStringWide &strwGroupName )
        {
            int nResult = -1;
            CSimpleString strGroupName = CSimpleStringConvert::NaturalString(strwGroupName);
            if (strGroupName.Length())
            {
                LVGROUP LvGroup = {0};
                LvGroup.cbSize = sizeof(LvGroup);
                LvGroup.pszHeader = const_cast<LPTSTR>(strGroupName.String());
                LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                LvGroup.uAlign = LVGA_HEADER_LEFT;
                LvGroup.iGroupId = Size();
                LvGroup.state = LVGS_NORMAL;
                nResult = static_cast<int>(ListView_InsertGroup( hwndList, Size(), &LvGroup ));
                WIA_TRACE((TEXT("ListView_InsertGroup on %s returned %d"), strGroupName.String(), nResult ));
                if (nResult >= 0)
                {
                    Append( CListviewGroupInfo( strwGroupName, nResult ) );
                }
            }
            return nResult;
        }
        int GetGroupId( CWiaItem *pWiaItem, HWND hwndList )
        {
            WIA_PUSH_FUNCTION((TEXT("GetGroupId(%ws)"),pWiaItem->ItemName().String()));
            int nResult = -1;
            if (Size())
            {
                nResult = (*this)[0].GroupId();
                if (pWiaItem)
                {
                    CWiaItem *pWiaItemParent = pWiaItem->Parent();
                    if (pWiaItemParent)
                    {
                        CSimpleStringWide strwFolderName = pWiaItemParent->ItemName();
                        if (strwFolderName.Length())
                        {
                            int nIndex = Find(strwFolderName);
                            if (nIndex < 0)
                            {
                                CSimpleString strFolderName = CSimpleStringConvert::NaturalString(strwFolderName);
                                if (strFolderName.Length())
                                {
                                    LVGROUP LvGroup = {0};
                                    LvGroup.cbSize = sizeof(LvGroup);
                                    LvGroup.pszHeader = const_cast<LPTSTR>(strFolderName.String());
                                    LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                                    LvGroup.uAlign = LVGA_HEADER_LEFT;
                                    LvGroup.iGroupId = Size();
                                    LvGroup.state = LVGS_NORMAL;
                                    nResult = static_cast<int>(ListView_InsertGroup( hwndList, Size(), &LvGroup ));
                                    WIA_TRACE((TEXT("ListView_InsertGroup on %s returned %d"), strFolderName.String(), nResult ));
                                    if (nResult >= 0)
                                    {
                                        Append( CListviewGroupInfo( strwFolderName, nResult ) );
                                    }
                                }
                            }
                            else
                            {
                                nResult = (*this)[nIndex].GroupId();
                            }
                        }
                    }
                }
            }
            return nResult;
        }
    };

    CIconGroupList m_GroupInfoList;

    // Private data
    HWND                                 m_hWnd;
    CAcquisitionManagerControllerWindow *m_pControllerWindow;
    int                                  m_nDefaultThumbnailImageListIndex;
    int                                  m_nProgrammaticSetting;
    CGdiPlusHelper                       m_GdiPlusHelper;
    UINT                                 m_nThreadNotificationMessage;
    UINT                                 m_nWiaEventMessage;
    bool                                 m_bThumbnailsRequested;
    HICON                                m_hIconAudioAnnotation;
    HICON                                m_hIconMiscellaneousAnnotation;
    CComPtr<IWiaAnnotationHelpers>       m_pWiaAnnotationHelpers;
    CComPtr<IWiaVideo>                   m_pWiaVideo;
    ToolbarHelper::CToolbarBitmapInfo    m_CameraSelectionButtonBarBitmapInfo;
    ToolbarHelper::CToolbarBitmapInfo    m_CameraTakePictureButtonBarBitmapInfo;
    ToolbarHelper::CToolbarBitmapInfo    m_CameraActionButtonBarBitmapInfo;
    HACCEL                               m_hAccelerators;

private:
    // No implementation
    CCameraSelectionPage(void);
    CCameraSelectionPage( const CCameraSelectionPage & );
    CCameraSelectionPage &operator=( const CCameraSelectionPage & );

private:
    // Constructor and destructor
    explicit CCameraSelectionPage( HWND hWnd );
    ~CCameraSelectionPage(void);

private:
    int AddItem( HWND hwndList, CWiaItem *pWiaItem, bool bEnsureVisible=false );
    void AddEnumeratedItems( HWND hwndList, CWiaItem *pFirstItem );
    void PopulateListView(void);
    CWiaItem *GetItemFromListByIndex( HWND hwndList, int nItem );
    int FindItemListIndex( HWND hwndList, CWiaItem *pWiaItem );
    int AddThumbnailToListViewImageList( HWND hwndList, CWiaItem *pWiaItem, int nIndex );
    int GetSelectionIndices( CSimpleDynamicArray<int> &aIndices );
    void UpdateControls(void);
    void InitializeVideoCamera(void);
    void DrawAnnotationIcons( HDC hDC, CWiaItem *pWiaItem, HBITMAP hBitmap );
    void MyEnableToolbarButton( int nButtonId, bool bEnable );
    void RepaintAllThumbnails();

private:
    // WM_COMMAND handlers
    void OnSelectAll( WPARAM, LPARAM );
    void OnClearAll( WPARAM, LPARAM );
    void OnProperties( WPARAM, LPARAM );
    void OnRotate( WPARAM, LPARAM );
    void OnTakePicture( WPARAM, LPARAM );
    void OnDelete( WPARAM, LPARAM );

    // WM_NOTIFY handlers
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnTranslateAccelerator( WPARAM, LPARAM );
    LRESULT OnGetToolTipDispInfo( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );
    LRESULT OnEventNotification( WPARAM, LPARAM );
    LRESULT OnThumbnailListSelChange( WPARAM, LPARAM );
    LRESULT OnThumbnailListKeyDown( WPARAM, LPARAM );
    LRESULT OnShowWindow( WPARAM, LPARAM );
    LRESULT OnTimer( WPARAM wParam, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );
    LRESULT OnThemeChanged( WPARAM, LPARAM );
    LRESULT OnSettingChange( WPARAM, LPARAM );

    // Thread notification message handlers
    void OnNotifyDownloadThumbnail( UINT, CThreadNotificationMessage * );
    void OnNotifyDownloadImage( UINT, CThreadNotificationMessage * );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __CAMSEL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comdelp.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMDELP.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Delete progress dialog.  Displays the thumbnail and download progress.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <commctrl.h>
#include "comdelp.h"
#include "resource.h"
#include "pviewids.h"
#include "simcrack.h"
#include "mboxex.h"
#include "runnpwiz.h"

CCommonDeleteProgressPage::CCommonDeleteProgressPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_pControllerWindow(NULL),
    m_hCancelDeleteEvent(CreateEvent(NULL,TRUE,FALSE,TEXT(""))),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_hSwitchToNextPage(NULL),
    m_bQueryingUser(false),
    m_nPictureCount(0),
    m_bDeleteCancelled(false)
{
}

CCommonDeleteProgressPage::~CCommonDeleteProgressPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
    if (m_hCancelDeleteEvent)
    {
        CloseHandle(m_hCancelDeleteEvent);
        m_hCancelDeleteEvent = NULL;
    }
}


void CCommonDeleteProgressPage::UpdateCurrentPicture( int nPicture )
{
    if (nPicture >= 0)
    {
        SendDlgItemMessage( m_hWnd, IDC_COMDEL_CURRENTIMAGE, PBM_SETPOS, nPicture+1, 0 );
        CSimpleString().Format( IDS_DELETING_FILEN_OF_M, g_hInstance, nPicture+1, m_nPictureCount ).SetWindowText( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTIMAGE_TEXT ) );
    }
    else
    {
        SendDlgItemMessage( m_hWnd, IDC_COMDEL_CURRENTIMAGE, PBM_SETPOS, 0, 0 );
        SendDlgItemMessage( m_hWnd, IDC_COMDEL_CURRENTIMAGE_TEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>("") );
    }
}

void CCommonDeleteProgressPage::UpdateThumbnail( HBITMAP hBitmap, CWiaItem *pWiaItem )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonDeleteProgressPage::UpdateThumbnail( HBITMAP hBitmap=0x%08X, CWiaItem *pWiaItem=0x%08X )"), hBitmap, pWiaItem ));


    HWND hWndPreview = GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL );
    if (hWndPreview)
    {
        if (pWiaItem && m_pControllerWindow && hBitmap)
        {
            switch (m_pControllerWindow->m_DeviceTypeMode)
            {
            case CAcquisitionManagerControllerWindow::ScannerMode:
                {
                    //
                    // If the item has a bitmap image, it already has a preview scan available
                    //
                    WIA_TRACE((TEXT("pWiaItem->BitmapImage() = %08X"), pWiaItem->BitmapImage() ));
                    if (pWiaItem->BitmapImage())
                    {
                        //
                        // Hide the preview window while we are futzing with it
                        //
                        ShowWindow( hWndPreview, SW_HIDE );

                        //
                        // Crop the image to the selected region
                        //
                        WiaPreviewControl_SetResolution( hWndPreview, &pWiaItem->ScanRegionSettings().sizeResolution );
                        WiaPreviewControl_SetSelOrigin( hWndPreview, 0, FALSE, &pWiaItem->ScanRegionSettings().ptOrigin );
                        WiaPreviewControl_SetSelExtent( hWndPreview, 0, FALSE, &pWiaItem->ScanRegionSettings().sizeExtent );

                        //
                        // Set the control to preview mode
                        //
                        WiaPreviewControl_SetPreviewMode( hWndPreview, TRUE );

                        //
                        // If this is a scanner item, we don't want to let the preview control take ownership of the bitmap.
                        // We don't want it to be deleted
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, hBitmap );

                        //
                        // Show the preview window
                        //
                        ShowWindow( hWndPreview, SW_SHOW );
                    }
                    else
                    {
                        //
                        // This means we are getting a preview image from the driver
                        // We don't want to delete this image
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, hBitmap );

                        //
                        // Make sure the window is visible
                        //
                        ShowWindow( hWndPreview, SW_SHOW );
                    }
                }
                break;

            default:
                {
                    //
                    // Go ahead and rotate the bitmap, even if it isn't necessary.
                    //
                    HBITMAP hRotatedThumbnail = NULL;
                    if (SUCCEEDED(m_GdiPlusHelper.Rotate( hBitmap, hRotatedThumbnail, pWiaItem->Rotation())))
                    {
                        //
                        // Set it to the rotated bitmap, and ALLOW this bitmap to be deleted
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, FALSE, hRotatedThumbnail );
                    }

                    //
                    // Make sure the window is visible
                    //
                    ShowWindow( hWndPreview, SW_SHOW );

                    //
                    // Delete the source bitmap
                    //
                    DeleteObject(hBitmap);
                }
            }
        }
        else
        {
            ShowWindow( hWndPreview, SW_HIDE );
            WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, NULL );
        }
    }
}


LRESULT CCommonDeleteProgressPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;


    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    //
    // Prepare the preview control
    //
    HWND hWndThumbnail = GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL );
    if (hWndThumbnail)
    {
        //
        // We only want to set the preview mode for scanners
        //
        if (CAcquisitionManagerControllerWindow::ScannerMode==m_pControllerWindow->m_DeviceTypeMode)
        {
            WiaPreviewControl_SetPreviewMode( hWndThumbnail, TRUE );
        }
        else
        {
            WiaPreviewControl_AllowNullSelection( hWndThumbnail, TRUE );
            WiaPreviewControl_ClearSelection( hWndThumbnail );
        }
        WiaPreviewControl_SetBgAlpha( hWndThumbnail, FALSE, 0xFF );
        WiaPreviewControl_DisableSelection( hWndThumbnail, TRUE );
        WiaPreviewControl_SetEnableStretch( hWndThumbnail, FALSE );
        WiaPreviewControl_SetBkColor( hWndThumbnail, FALSE, TRUE, GetSysColor(COLOR_WINDOW) );
        WiaPreviewControl_HideEmptyPreview( hWndThumbnail, TRUE );
        WiaPreviewControl_SetPreviewAlignment( hWndThumbnail, PREVIEW_WINDOW_CENTER, PREVIEW_WINDOW_CENTER, FALSE );

    }

    return 0;
}

void CCommonDeleteProgressPage::OnNotifyDeleteImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    WIA_PUSHFUNCTION(TEXT("CCommonDeleteProgressPage::OnNotifyDeleteImage()"));

    //
    // Don't handle delete messages if we are not on this page
    //
    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) != m_hWnd)
    {
        return;
    }

    CDeleteImagesThreadNotifyMessage *pDeleteImageThreadNotifyMessage = dynamic_cast<CDeleteImagesThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDeleteImageThreadNotifyMessage && m_pControllerWindow)
    {
        switch (pDeleteImageThreadNotifyMessage->Status())
        {
        case CDeleteImagesThreadNotifyMessage::Begin:
            {
                switch (pDeleteImageThreadNotifyMessage->Operation())
                {
                case CDeleteImagesThreadNotifyMessage::DeleteAll:
                    {
                        //
                        // Store the number of images we'll be deleting
                        //
                        m_nPictureCount = pDeleteImageThreadNotifyMessage->PictureCount();

                        //
                        // Initialize current image count progress bar
                        //
                        SendDlgItemMessage( m_hWnd, IDC_COMDEL_CURRENTIMAGE, PBM_SETRANGE32, 0, m_nPictureCount);
                        UpdateCurrentPicture(0);
                    }
                    break;

                case CDeleteImagesThreadNotifyMessage::DeleteImage:
                    {
                        HBITMAP hBitmapThumbnail = NULL;
                        CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDeleteImageThreadNotifyMessage->Cookie() );
                        if (pWiaItem)
                        {
                            //
                            // This will only work if it is a scanner item
                            //
                            hBitmapThumbnail = pWiaItem->BitmapImage();
                            if (!hBitmapThumbnail)
                            {
                                //
                                // Since it didn't work, this is a camera item, so create a thumbnail.
                                // We have to make sure we nuke this bitmap or it is a leak!
                                //
                                HDC hDC = GetDC(NULL);
                                if (hDC)
                                {
                                    hBitmapThumbnail = pWiaItem->CreateThumbnailBitmap(hDC);
                                    ReleaseDC(NULL,hDC);
                                }
                            }
                        }
                        //
                        // Update the thumbnail in the progress window
                        //
                        UpdateThumbnail( hBitmapThumbnail, pWiaItem );

                        //
                        // Increment file queue progress
                        //
                        UpdateCurrentPicture(pDeleteImageThreadNotifyMessage->CurrentPicture());
                    }
                }
            }
            break;

        case CDeleteImagesThreadNotifyMessage::End:
            {
                switch (pDeleteImageThreadNotifyMessage->Operation())
                {
                case CDeleteImagesThreadNotifyMessage::DeleteAll:
                    {
                        //
                        // Save the delete result
                        //
                        m_pControllerWindow->m_hrDeleteResult = pDeleteImageThreadNotifyMessage->hr();
                        WIA_PRINTHRESULT((m_pControllerWindow->m_hrDeleteResult,TEXT("m_pControllerWindow->m_hrDeleteResult")));

                        //
                        // Assume the upload query page
                        //
                        HPROPSHEETPAGE hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nUploadQueryPageIndex );

                        //
                        // If there is a message box active, save this page till the message box is dismissed
                        //
                        if (m_bQueryingUser)
                        {
                            m_hSwitchToNextPage = hNextPage;
                        }
                        else
                        {
                            //
                            // Set the next page
                            //
                            PropSheet_SetCurSel( GetParent(m_hWnd), hNextPage, -1 );
                        }
                    }
                    break;
                }
            }
        }
    }
}

LRESULT CCommonDeleteProgressPage::OnSetActive( WPARAM, LPARAM )
{
    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    //
    // Make sure we are actually supposed to delete the images
    //
    if (!m_pControllerWindow->m_bDeletePicturesIfSuccessful)
    {
        return -1;
    }

    //
    // Initialize the download error message
    //
    m_pControllerWindow->m_strErrorMessage = TEXT("");

    //
    // Initialize the delete result
    //
    m_pControllerWindow->m_hrDeleteResult = S_OK;

    //
    // Reset the cancelled flag
    //
    m_bDeleteCancelled = false;

    //
    // Clear all of the controls
    //
    UpdateCurrentPicture(-1);
    UpdateThumbnail(NULL,NULL);

    //
    // Reset the selected region, in case this is a scanner
    //
    WiaPreviewControl_SetResolution( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), NULL );
    WiaPreviewControl_SetSelOrigin( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), 0, FALSE, NULL );
    WiaPreviewControl_SetSelExtent( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), 0, FALSE, NULL );

    //
    // Set the control to preview mode
    //
    WiaPreviewControl_SetPreviewMode( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), TRUE );

    //
    // Reset the download event cancel
    //
    if (m_hCancelDeleteEvent)
    {
        ResetEvent(m_hCancelDeleteEvent);
    }

    //
    // Cancel thumbnail downloading
    //
    m_pControllerWindow->m_EventThumbnailCancel.Signal();

    //
    // We don't want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectFailDelete|CAcquisitionManagerControllerWindow::DontAllowSuspend;


    //
    //  Start the download
    //
    if (!m_pControllerWindow->DeleteDownloadedImages(m_hCancelDeleteEvent))
    {
        WIA_ERROR((TEXT("m_pControllerWindow->DeleteDownloadedImages FAILED!")));
        return -1;
    }

    //
    // No next, back or finish
    //
    PropSheet_SetWizButtons( GetParent(m_hWnd), 0 );

    return 0;
}


LRESULT CCommonDeleteProgressPage::OnWizNext( WPARAM, LPARAM )
{
    return 0;
}


LRESULT CCommonDeleteProgressPage::OnWizBack( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CCommonDeleteProgressPage::OnReset( WPARAM, LPARAM )
{
    //
    // Cancel the current download
    //
    if (m_hCancelDeleteEvent)
    {
        SetEvent(m_hCancelDeleteEvent);
    }
    return 0;
}

bool CCommonDeleteProgressPage::QueryCancel(void)
{
    //
    //  Make sure this is the current page
    //
    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) != m_hWnd)
    {
        return true;
    }

    //
    // Pause the background thread
    //
    m_pControllerWindow->m_EventPauseBackgroundThread.Reset();


    //
    // Assume the user doesn't want to cancel
    //
    bool bResult = false;

    //
    // Set the querying user flag so the event handler won't change pages
    //
    m_bQueryingUser = true;

    //
    // We may be called on to switch pages when we are done here.  If so, this will be non-NULL then.
    //
    m_hSwitchToNextPage = NULL;

    //
    // Don't ask again if we've already asked
    //
    if (!m_bDeleteCancelled)
    {
        //
        // Ask the user if they want to cancel
        //
        if (CMessageBoxEx::IDMBEX_YES == CMessageBoxEx::MessageBox( m_hWnd, CSimpleString(IDS_CONFIRM_CANCEL_DELETE,g_hInstance), CSimpleString(IDS_ERROR_TITLE,g_hInstance), CMessageBoxEx::MBEX_YESNO|CMessageBoxEx::MBEX_ICONQUESTION ))
        {
            //
            // The user does want to cancel, so set the cancel event
            //
            if (m_hCancelDeleteEvent)
            {
                SetEvent(m_hCancelDeleteEvent);
            }

            //
            // Ensure we are cancelled so we don't get here again
            //
            m_bDeleteCancelled = true;

            //
            // Make sure the cancel button is disabled
            //
            EnableWindow( GetDlgItem( GetParent(m_hWnd), IDCANCEL ), FALSE );

            //
            // return true
            //
            bResult = true;
        }
    }

    //
    // If we are supposed to switch pages, switch now
    //
    if (m_hSwitchToNextPage)
    {
        PropSheet_SetCurSel( GetParent(m_hWnd), m_hSwitchToNextPage, -1 );
    }

    //
    // Reset the querying user flag so the event handler can change pages as needed
    //
    m_bQueryingUser = false;

    //
    // Unpause the background thread
    //
    m_pControllerWindow->m_EventPauseBackgroundThread.Signal();

    return bResult;
}

LRESULT CCommonDeleteProgressPage::OnQueryCancel( WPARAM, LPARAM )
{
    //
    // The user is not allowed to cancel out of this page
    //
    BOOL bResult = TRUE;

    //
    // Since we don't let them cancel in this page, just ignore the result
    //
    QueryCancel();


    return bResult;
}


LRESULT CCommonDeleteProgressPage::OnKillActive( WPARAM, LPARAM )
{
    //
    // Make sure the cancel button is enabled
    //
    EnableWindow( GetDlgItem( GetParent(m_hWnd), IDCANCEL ), TRUE );

    return 0;
}


LRESULT CCommonDeleteProgressPage::OnQueryEndSession( WPARAM, LPARAM )
{
    bool bCancel = QueryCancel();
    if (bCancel)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

LRESULT CCommonDeleteProgressPage::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_COMDEL_CURRENTTHUMBNAIL ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    return 0;
}

LRESULT CCommonDeleteProgressPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CCommonDeleteProgressPage::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WTM_BEGIN_THREAD_NOTIFY_MESSAGE_HANDLERS()
    {
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_DOWNLOADIMAGE, OnNotifyDeleteImage );
    }
    WTM_END_THREAD_NOTIFY_MESSAGE_HANDLERS();
}

LRESULT CCommonDeleteProgressPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_KILLACTIVE,OnKillActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_RESET,OnReset);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_QUERYCANCEL,OnQueryCancel);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCommonDeleteProgressPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCommonDeleteProgressPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_QUERYENDSESSION, OnQueryEndSession );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nThreadNotificationMessage, OnThreadNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comfin.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMFIN.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Transfer page.  Gets the destination path and filename.
 *
 *******************************************************************************/
#ifndef __COMFIN_H_INCLUDED
#define __COMFIN_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"

class CCommonFinishPage
{
private:
    // Private data
    HWND                                  m_hWnd;
    CAcquisitionManagerControllerWindow  *m_pControllerWindow;
    HFONT                                 m_hBigTitleFont;
    UINT                                  m_nWiaEventMessage;
    CSimpleString                         m_strSiteUrl;

private:
    // No implementation
    CCommonFinishPage(void);
    CCommonFinishPage( const CCommonFinishPage & );
    CCommonFinishPage &operator=( const CCommonFinishPage & );

private:
    // Constructor and destructor
    explicit CCommonFinishPage( HWND hWnd );
    ~CCommonFinishPage(void);

    void OpenLocalStorage();
    void OpenRemoteStorage();
    HRESULT GetManifestInfo( IXMLDOMDocument *pXMLDOMDocumentManifest, CSimpleString &strSiteName, CSimpleString &strSiteURL );

private:
    LRESULT OnEventNotification( WPARAM, LPARAM );

    // WM_NOTIFY handlers
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnWizFinish( WPARAM, LPARAM );
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnHyperlinkClick( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __COMFIN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comfin.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMFIN.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Transfer page.  Gets the destination path and filename.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "comfin.h"
#include "simcrack.h"
#include "resource.h"
#include "svselfil.h"
#include "simrect.h"
#include "movewnd.h"
#include "runnpwiz.h"
#include "mboxex.h"
#include <wininet.h>

#define STR_LOCAL_LINK_ID     TEXT("LocalLinkId")
#define STR_REMOTE_LINK_ID    TEXT("RemoteLinkId")
#define STR_DETAILED_DOWNLOAD_ERROR_ID TEXT("DetailedDownloadErrorId")
#define STR_DETAILED_UPLOAD_ERROR_ID TEXT("DetailedUploadErrorId")

#define ID_FINISHBUTTON 0x3025

//
// Sole constructor
//
CCommonFinishPage::CCommonFinishPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_pControllerWindow(NULL),
    m_hBigTitleFont(NULL)
{
}

//
// Destructor
//
CCommonFinishPage::~CCommonFinishPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
}


HRESULT CCommonFinishPage::GetManifestInfo( IXMLDOMDocument *pXMLDOMDocumentManifest, CSimpleString &strSiteName, CSimpleString &strSiteURL )
{
    WCHAR wszSiteName[MAX_PATH] = {0};
    WCHAR wszSiteURL[INTERNET_MAX_URL_LENGTH] = {0};
    
    HRESULT hr;
    if (pXMLDOMDocumentManifest)
    {
        //
        // lets crack the manifest and work out whats what with the publish that
        // we just performed.
        //
        CComPtr<IXMLDOMNode> pXMLDOMNodeUploadInfo;
        hr = pXMLDOMDocumentManifest->selectSingleNode( CSimpleBStr(L"transfermanifest/uploadinfo"), &pXMLDOMNodeUploadInfo );
        if (S_OK == hr)
        {
            //
            // lets pick up the site name from the manifest, this will be an attribute on the
            // upload info element.
            //
            CComPtr<IXMLDOMElement> pXMLDOMElement;
            hr = pXMLDOMNodeUploadInfo->QueryInterface( IID_IXMLDOMElement, (void**)&pXMLDOMElement );
            if (SUCCEEDED(hr))
            {
                VARIANT var = {0};
                hr = pXMLDOMElement->getAttribute( CSimpleBStr(L"friendlyname"), &var );
                if (S_OK == hr)
                {
                    StrCpyNW( wszSiteName, var.bstrVal, ARRAYSIZE(wszSiteName) );
                    VariantClear(&var);
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("pXMLDOMElement->getAttribute( \"friendlyname\" ) failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pXMLDOMNodeUploadInfo->QueryInterface( IID_IXMLDOMElement ) failed on line %d"), __LINE__ ));
            }

            //
            // lets now try and pick up the site URL node, this is going to either
            // be the file target, or HTML UI element.
            //
            CComPtr<IXMLDOMNode> pXMLDOMNodeURL;
            hr = pXMLDOMNodeUploadInfo->selectSingleNode( CSimpleBStr(L"htmlui"), &pXMLDOMNodeURL);

            if (S_FALSE == hr)
            {
                WIA_PRINTHRESULT((hr,TEXT("pXMLDOMDocumentManifest->selectSingleNode \"htmlui\" failed")));
                hr = pXMLDOMNodeUploadInfo->selectSingleNode( CSimpleBStr(L"netplace"), &pXMLDOMNodeURL);
            }

            if (S_FALSE == hr)
            {
                WIA_PRINTHRESULT((hr,TEXT("pXMLDOMDocumentManifest->selectSingleNode \"target\" failed")));
                hr = pXMLDOMNodeUploadInfo->selectSingleNode( CSimpleBStr(L"target"), &pXMLDOMNodeURL);
            }

            if (S_OK == hr)
            {
                CComPtr<IXMLDOMElement> pXMLDOMElement;
                hr = pXMLDOMNodeURL->QueryInterface( IID_IXMLDOMElement, (void**)&pXMLDOMElement );
                if (SUCCEEDED(hr))
                {                                                           
                    
                    //
                    // attempt to read the HREF attribute, if that is defined
                    // the we use it, otherwise (for compatibility with B2, we need
                    // to get the node text and use that instead).
                    //
                    VARIANT var = {0};
                    hr = pXMLDOMElement->getAttribute( CSimpleBStr(L"href"), &var );
                    if (hr != S_OK)
                    {
                        hr = pXMLDOMElement->get_nodeTypedValue( &var );
                    }

                    if (S_OK == hr)
                    {
                        StrCpyNW(wszSiteURL, var.bstrVal, ARRAYSIZE(wszSiteURL) );
                        VariantClear(&var);
                    }
                    else
                    {
                        WIA_PRINTHRESULT((hr,TEXT("pXMLDOMElement->getAttribute or pXMLDOMElement->get_nodeTypedValue failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("pXMLDOMNodeUploadInfo->QueryInterface( IID_IXMLDOMElement ) failed on line %d"), __LINE__ ));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pXMLDOMDocumentManifest->selectSingleNode \"target\" failed")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("pXMLDOMDocumentManifest->selectSingleNode \"transfermanifest\\uploadinfo\" failed")));
        }
    }
    else
    {
        WIA_ERROR((TEXT("pXMLDOMDocumentManifest is NULL")));
        hr = E_INVALIDARG;
    }

    strSiteName = CSimpleStringConvert::NaturalString( CSimpleStringWide( wszSiteName ) );
    strSiteURL = CSimpleStringConvert::NaturalString( CSimpleStringWide( wszSiteURL ) );

    return hr;
}


LRESULT CCommonFinishPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    //
    // Set the font size for the title
    //
    m_hBigTitleFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_FINISH_TITLE), 14, false, false );
    if (m_hBigTitleFont)
    {
        SendDlgItemMessage( m_hWnd, IDC_FINISH_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigTitleFont), MAKELPARAM(TRUE,0));
    }


    return 0;
}


LRESULT CCommonFinishPage::OnWizFinish( WPARAM, LPARAM )
{
    LRESULT nResult = FALSE;

    //
    // Open the shell folder containing the images
    //
    OpenLocalStorage();
    return nResult;
}

/*

 From finish page:
 
 if (error_occurred)
 {
    if (no_images)
    {
        goto SelectionPage
    }
    else
    {
        goto DestinationPage
    }
 }
 else
 {
    goto UploadQueryPage
 }

*/

//
// handler for PSN_WIZBACK
//
LRESULT CCommonFinishPage::OnWizBack( WPARAM, LPARAM )
{
    //
    // If no errors occurred, go to the upload query page
    //
    HPROPSHEETPAGE hNextPage = NULL;
    if (S_OK==m_pControllerWindow->m_hrDownloadResult && !m_pControllerWindow->m_bDownloadCancelled)
    {
        hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nUploadQueryPageIndex );
    }
    else
    {
        if (m_pControllerWindow->GetSelectedImageCount())
        {
            hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nDestinationPageIndex );
        }
        else
        {
            hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nSelectionPageIndex );
        }
    }
    PropSheet_SetCurSel( GetParent(m_hWnd), hNextPage, -1 );
    return -1;
}

//
// handler for PSN_SETACTIVE
//
LRESULT CCommonFinishPage::OnSetActive( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CCommonFinishPage::OnSetActive"));

    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    //
    // Assume we are displaying a success message
    //
    int nPageTitle = IDS_FINISH_SUCCESS_TITLE;

    //
    // Assume we failed for this message
    //
    int nFinishPrompt = IDS_FINISH_PROMPT_FAILURE;

    //
    // Only disable the back button if (a) we are disconnected and (b) we hit an error or were cancelled
    //
    if (m_pControllerWindow->m_bDisconnected && (S_OK != m_pControllerWindow->m_hrDownloadResult || m_pControllerWindow->m_bDownloadCancelled))
    {
        //
        // Basically, this disables the Cancel button.
        //
        PropSheet_CancelToClose( GetParent(m_hWnd) );
        
        //
        // Change the finish button to a close button
        //
        PropSheet_SetFinishText( GetParent(m_hWnd), CSimpleString( IDS_FINISH_TO_CLOSE_TITLE, g_hInstance ).String() );
        
        //
        // Disable back
        //
        PropSheet_SetWizButtons( GetParent(m_hWnd), PSWIZB_FINISH );

        //
        // Tell the user to use Close to close the wizard.
        //
        nFinishPrompt = IDS_FINISH_PROMPT_FAILURE_DISCONNECT;
    }
    else
    {
        //
        // Allow finish and back
        //
        PropSheet_SetWizButtons( GetParent(m_hWnd), PSWIZB_FINISH|PSWIZB_BACK );

    }


#if defined(DBG)
    //
    // Display statistics for debugging
    //
    WIA_TRACE((TEXT("m_pControllerWindow->m_DownloadedFileList.Size(): %d"), m_pControllerWindow->m_DownloadedFileInformationList.Size()));
    for (int i=0;i<m_pControllerWindow->m_DownloadedFileInformationList.Size();i++)
    {
        WIA_TRACE((TEXT("    m_pControllerWindow->m_DownloadedFileList[%d]==%s"), i, m_pControllerWindow->m_DownloadedFileInformationList[i].Filename().String()));
    }
    WIA_TRACE((TEXT("m_pControllerWindow->m_nFailedImagesCount: %d"), m_pControllerWindow->m_nFailedImagesCount ));
    WIA_TRACE((TEXT("m_pControllerWindow->m_strErrorMessage: %s"), m_pControllerWindow->m_strErrorMessage.String()));
    WIA_PRINTHRESULT((m_pControllerWindow->m_hrDownloadResult,TEXT("m_pControllerWindow->m_hrDownloadResult")));
    WIA_PRINTHRESULT((m_pControllerWindow->m_hrUploadResult,TEXT("m_pControllerWindow->m_hrUploadResult")));
    WIA_PRINTHRESULT((m_pControllerWindow->m_hrDeleteResult,TEXT("m_pControllerWindow->m_hrDeleteResult")));
#endif
    
    CSimpleString strStatusMessage;

    //
    // If the transfer succeeded, and the user didn't cancel
    //
    if (S_OK==m_pControllerWindow->m_hrDownloadResult && !m_pControllerWindow->m_bDownloadCancelled)
    {

        CSimpleString strSuccessfullyDownloaded;
        CSimpleString strSuccessfullyUploaded;
        CSimpleString strSuccessfullyDeleted;
        CSimpleString strHyperlinks;

        CSimpleString strLocalHyperlink;
        CSimpleString strRemoteHyperlink;

        int nSuccessCount = 0;


        //
        // If we have successfully transferred images, display the count and show the associated controls
        //
        if (m_pControllerWindow->m_DownloadedFileInformationList.Size())
        {
            //
            // Count up all of the "countable" files (we don't include attachments in the count)
            //
            for (int i=0;i<m_pControllerWindow->m_DownloadedFileInformationList.Size();i++)
            {
                if (m_pControllerWindow->m_DownloadedFileInformationList[i].IncludeInFileCount())
                {
                    nSuccessCount++;
                }
            }
            
            //
            // If we had any errors while deleting images, let the user know
            //
            if (m_pControllerWindow->m_bDeletePicturesIfSuccessful && FAILED(m_pControllerWindow->m_hrDeleteResult))
            {
                strSuccessfullyDeleted.LoadString( IDS_DELETION_FAILED, g_hInstance );
            }

            //
            // If we uploaded to the web, set the destination text
            //
            if (m_pControllerWindow->m_bUploadToWeb)
            {
                //
                // If we have a valid publishing wizard, get the manifest and hresult
                //
                if (m_pControllerWindow->m_pPublishingWizard)
                {
                    //
                    // Get the transfer manifest
                    //
                    CComPtr<IXMLDOMDocument> pXMLDOMDocumentManifest;
                    if (SUCCEEDED(m_pControllerWindow->m_pPublishingWizard->GetTransferManifest( &m_pControllerWindow->m_hrUploadResult, &pXMLDOMDocumentManifest )))
                    {
                        WIA_PRINTHRESULT((m_pControllerWindow->m_hrUploadResult,TEXT("m_pControllerWindow->m_hrUploadResult")));
                        
                        //
                        // Get the destination URL and friendly name out of the manifest
                        //
                        CSimpleString strUploadDestination;
                        if (S_OK==m_pControllerWindow->m_hrUploadResult && SUCCEEDED(CCommonFinishPage::GetManifestInfo( pXMLDOMDocumentManifest, strUploadDestination, m_strSiteUrl )))
                        {
                            //
                            // If we have a friendly name, use it.  Otherwise, use the URL
                            //
                            strRemoteHyperlink = strUploadDestination;
                            if (!strRemoteHyperlink.Length())
                            {
                                strRemoteHyperlink = m_strSiteUrl;
                            }
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_CANCELLED) == m_pControllerWindow->m_hrUploadResult)
                {
                    strSuccessfullyUploaded.LoadString( IDS_FINISH_UPLOAD_CANCELLED, g_hInstance );
                }
                else if (FAILED(m_pControllerWindow->m_hrUploadResult))
                {
                    strSuccessfullyUploaded.LoadString( IDS_FINISH_UPLOAD_FAILED, g_hInstance );
                }
            }

            if (nSuccessCount)
            {
                strLocalHyperlink = m_pControllerWindow->m_CurrentDownloadDestination.DisplayName(m_pControllerWindow->m_DestinationNameData).String();

                nFinishPrompt = IDS_FINISH_PROMPT_SUCCESS;
            }
        }


        int nCountOfSuccessfulDestinations = 0;

        if (strLocalHyperlink.Length() || strRemoteHyperlink.Length())
        {
            strHyperlinks += TEXT("\n");
        }

        //
        // Get the client rect for calculating the allowable size of the hyperlink string
        //
        RECT rcControl;
        GetClientRect( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ), &rcControl );

        if (strLocalHyperlink.Length())
        {
            nCountOfSuccessfulDestinations++;
            strHyperlinks += CSimpleString( IDS_FINISH_LOCAL_LINK_PROMPT, g_hInstance );
            strHyperlinks += TEXT("\n");
            strHyperlinks += TEXT("<a id=\"") STR_LOCAL_LINK_ID TEXT("\">");
            strHyperlinks += WiaUiUtil::TruncateTextToFitInRect( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ), strLocalHyperlink, rcControl, DT_END_ELLIPSIS|DT_NOPREFIX );
            strHyperlinks += TEXT("</a>");
        }
        if (strRemoteHyperlink.Length())
        {
            nCountOfSuccessfulDestinations++;
            strHyperlinks += TEXT("\n\n");
            strHyperlinks += CSimpleString( IDS_FINISH_REMOTE_LINK_PROMPT, g_hInstance );
            strHyperlinks += TEXT("\n");
            strHyperlinks += TEXT("<a id=\"")  STR_REMOTE_LINK_ID TEXT("\">");
            strHyperlinks += WiaUiUtil::TruncateTextToFitInRect( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ), strRemoteHyperlink, rcControl, DT_END_ELLIPSIS|DT_NOPREFIX );
            strHyperlinks += TEXT("</a>");
        }

        if (strHyperlinks.Length())
        {
            strHyperlinks += TEXT("\n");
        }

        //
        // Format the success string
        //
        if (nCountOfSuccessfulDestinations)
        {
            strSuccessfullyDownloaded.Format( IDS_SUCCESSFUL_DOWNLOAD, g_hInstance, nSuccessCount );
        }


        //
        // Append the individual status messages to the main status message
        //
        if (strSuccessfullyDownloaded.Length())
        {
            if (strStatusMessage.Length())
            {
                strStatusMessage += TEXT("\n");
            }
            strStatusMessage += strSuccessfullyDownloaded;
        }
        if (strHyperlinks.Length())
        {
            if (strStatusMessage.Length())
            {
                strStatusMessage += TEXT("\n");
            }
            strStatusMessage += strHyperlinks;
        }
        if (strSuccessfullyUploaded.Length())
        {
            if (strStatusMessage.Length())
            {
                strStatusMessage += TEXT("\n");
            }
            strStatusMessage += strSuccessfullyUploaded;
        }
        if (strSuccessfullyDeleted.Length())
        {
            if (strStatusMessage.Length())
            {
                strStatusMessage += TEXT("\n");
            }
            strStatusMessage += strSuccessfullyDeleted;
        }


        strStatusMessage.SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ) );
    }

    //
    // Else if there was an offline error
    //
    else if (WIA_ERROR_OFFLINE == m_pControllerWindow->m_hrDownloadResult || m_pControllerWindow->m_bDisconnected)
    {
        nPageTitle = IDS_FINISH_FAILURE_TITLE;

        (CSimpleString( IDS_DEVICE_DISCONNECTED, g_hInstance )).SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ) );
    }

    //
    // Else, if the user cancelled
    //
    else if (m_pControllerWindow->m_bDownloadCancelled)
    {
        nPageTitle = IDS_FINISH_FAILURE_TITLE;

        CSimpleString( IDS_USER_CANCELLED, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ) );
    }

    //
    // Otherwise there was an error
    //
    else
    {
        nPageTitle = IDS_FINISH_FAILURE_TITLE;

        CSimpleString( IDS_FINISH_ERROR_MESSAGE, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_STATUS ) );
    }

    //
    // Display the finish title message
    //
    CSimpleString( nPageTitle, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_TITLE ) );

    //
    // Display the finish prompt.
    //
    CSimpleString( nFinishPrompt, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_FINISH_PROMPT ) );
    

    //
    // Don't do anything on disconnect messages
    //
    m_pControllerWindow->m_OnDisconnect = 0;

    //
    // Get the focus off the stinkin' hyperlink control
    //
    PostMessage( m_hWnd, WM_NEXTDLGCTL, reinterpret_cast<WPARAM>(GetDlgItem(GetParent(m_hWnd),ID_FINISHBUTTON)), MAKELPARAM(TRUE,0));

    return 0;
}

LRESULT CCommonFinishPage::OnDestroy( WPARAM, LPARAM )
{
    if (m_hBigTitleFont)
    {
        DeleteObject(m_hBigTitleFont);
        m_hBigTitleFont = NULL;
    }
    return 0;
}

void CCommonFinishPage::OpenLocalStorage()
{
    CWaitCursor wc;

    //
    // Assume we do need to open the shell folder
    //
    bool bNeedToOpenShellFolder = true;

    //
    // Special case for CD burning--attempt to open the CD burner folder
    //
    if (CDestinationData( CSIDL_CDBURN_AREA ) == m_pControllerWindow->m_CurrentDownloadDestination)
    {
        //
        // Create the CD burner interface, so we can get the drive letter
        //
        CComPtr<ICDBurn> pCDBurn;
        HRESULT hr = CoCreateInstance( CLSID_CDBurn, NULL, CLSCTX_SERVER, IID_ICDBurn, (void**)&pCDBurn );
        if (SUCCEEDED(hr))
        {
            //
            // Get the drive letter of the available CD burner
            //
            WCHAR szDriveLetter[MAX_PATH];
            hr = pCDBurn->GetRecorderDriveLetter( szDriveLetter, ARRAYSIZE(szDriveLetter) );

            //
            // Make sure the function returned success and that we have a string
            //
            if (S_OK == hr && szDriveLetter[0] != L'\0')
            {
                //
                // Convert the drive to a TCHAR string
                //
                CSimpleString strShellLocation = CSimpleStringConvert::NaturalString(CSimpleStringWide(szDriveLetter));
                if (strShellLocation.Length())
                {
                    //
                    // Attempt to open the CD drive.  If we can't, we will fail gracefully and open the staging area
                    //
                    SHELLEXECUTEINFO ShellExecuteInfo = {0};
                    ShellExecuteInfo.cbSize = sizeof(ShellExecuteInfo);
                    ShellExecuteInfo.hwnd = m_hWnd;
                    ShellExecuteInfo.nShow = SW_SHOW;
                    ShellExecuteInfo.lpVerb = TEXT("open");
                    ShellExecuteInfo.lpFile = const_cast<LPTSTR>(strShellLocation.String());
                    if (ShellExecuteEx( &ShellExecuteInfo ))
                    {
                        bNeedToOpenShellFolder = false;
                    }
                    else
                    {
                        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("ShellExecuteEx failed")));
                    }
                }
            }
        }
    }

    //
    // If we still need to open the shell folder, do so.
    //
    if (bNeedToOpenShellFolder)
    {
        CSimpleDynamicArray<CSimpleString> DownloadedFiles;
        if (SUCCEEDED(m_pControllerWindow->m_DownloadedFileInformationList.GetUniqueFiles(DownloadedFiles)))
        {
            OpenShellFolder::OpenShellFolderAndSelectFile( GetParent(m_hWnd), DownloadedFiles );
        }
    }
}


void CCommonFinishPage::OpenRemoteStorage()
{
    CWaitCursor wc;
    if (m_strSiteUrl.Length())
    {
        SHELLEXECUTEINFO ShellExecuteInfo = {0};
        ShellExecuteInfo.cbSize = sizeof(ShellExecuteInfo);
        ShellExecuteInfo.fMask = SEE_MASK_FLAG_NO_UI;
        ShellExecuteInfo.nShow = SW_SHOWNORMAL;
        ShellExecuteInfo.lpFile = const_cast<LPTSTR>(m_strSiteUrl.String());
        ShellExecuteInfo.lpVerb = TEXT("open");
        ShellExecuteEx(&ShellExecuteInfo);
    }
}


LRESULT CCommonFinishPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonFinishPage::OnEventNotification") ));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
            {
                //
                // If there were any errors, disable back, since we can't upload
                //
                if (S_OK != m_pControllerWindow->m_hrDownloadResult || m_pControllerWindow->m_bDownloadCancelled)
                {
                    //
                    // Disable "back"
                    //
                    PropSheet_SetWizButtons( GetParent(m_hWnd), PSWIZB_FINISH );
                }
            }
        }

        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}

LRESULT CCommonFinishPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
    }
    SC_END_COMMAND_HANDLERS();
}



LRESULT CCommonFinishPage::OnHyperlinkClick( WPARAM, LPARAM lParam )
{
    LRESULT lResult = FALSE;
    NMLINK *pNmLink = reinterpret_cast<NMLINK*>(lParam);
    if (pNmLink)
    {
        WIA_TRACE((TEXT("ID: %s"),pNmLink->item.szID));
        switch (pNmLink->hdr.idFrom)
        {
        case IDC_FINISH_STATUS:
            {
                if (!lstrcmp(pNmLink->item.szID,STR_DETAILED_DOWNLOAD_ERROR_ID))
                {
                    CSimpleString strMessage( IDS_TRANSFER_ERROR, g_hInstance );
                    strMessage += m_pControllerWindow->m_strErrorMessage;
                    CMessageBoxEx::MessageBox( m_hWnd, strMessage, CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );
                    lResult = TRUE;
                }
                else if (!lstrcmp(pNmLink->item.szID,STR_DETAILED_UPLOAD_ERROR_ID))
                {
                    CSimpleString strMessage( IDS_UPLOAD_ERROR, g_hInstance );
                    CSimpleString strError = WiaUiUtil::GetErrorTextFromHResult(m_pControllerWindow->m_hrUploadResult);
                    if (!strError.Length())
                    {
                        strError.Format( CSimpleString( IDS_TRANSFER_ERROR_OCCURRED, g_hInstance ), m_pControllerWindow->m_hrUploadResult );
                    }
                    strMessage += strError;
                    CMessageBoxEx::MessageBox( m_hWnd, strMessage, CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );
                    lResult = TRUE;
                }
                else if (!lstrcmp(pNmLink->item.szID,STR_LOCAL_LINK_ID))
                {
                    OpenLocalStorage();
                    lResult = TRUE;
                }
                else if (!lstrcmp(pNmLink->item.szID,STR_REMOTE_LINK_ID))
                {
                    OpenRemoteStorage();
                    lResult = TRUE;
                }
            }
            break;
        }
    }
    return lResult;
}

LRESULT CCommonFinishPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(NM_RETURN,IDC_FINISH_STATUS,OnHyperlinkClick);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(NM_CLICK,IDC_FINISH_STATUS,OnHyperlinkClick);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZFINISH,OnWizFinish);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCommonFinishPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCommonFinishPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nWiaEventMessage, OnEventNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comfirst.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMFIRST.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: First wizard page for cameras
 *
 *******************************************************************************/
#ifndef __COMFIRST_H_INCLUDED
#define __COMFIRST_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"

class CCommonFirstPage
{
private:
    // Private data
    HWND                                 m_hWnd;
    CAcquisitionManagerControllerWindow *m_pControllerWindow;
    bool                                 m_bThumbnailsRequested;  // Used to initiate thumbnail download
    HFONT                                m_hBigTitleFont;
    HFONT                                m_hBigDeviceFont;
    UINT                                 m_nWiaEventMessage;

private:
    // No implementation
    CCommonFirstPage(void);
    CCommonFirstPage( const CCommonFirstPage & );
    CCommonFirstPage &operator=( const CCommonFirstPage & );

private:
    // Constructor and destructor
    explicit CCommonFirstPage( HWND hWnd );
    ~CCommonFirstPage(void);

private:
    void HandleImageCountChange( bool bUpdateWizButtons );

private:

    // WM_NOTIFY handlers
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnSetActive( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnShowWindow( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );
    LRESULT OnEventNotification( WPARAM, LPARAM );
    LRESULT OnActivate( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );
    LRESULT OnHyperlinkClick( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __COMFIRST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\camsel.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       CAMSEL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Camera selection page.  Displays thumbnails, and lets the user select which
 *               ones to download.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <vcamprop.h>
#include <psutil.h>
#include "camsel.h"
#include "resource.h"
#include "simcrack.h"
#include "waitcurs.h"
#include "mboxex.h"
#include "wiatextc.h"
#include <commctrl.h>
#include <comctrlp.h>
#include "gwiaevnt.h"
#include <itranhlp.h>
#include "createtb.h"
#include <simrect.h>

//
// We use this instead of GetSystemMetrics(SM_CXSMICON)/GetSystemMetrics(SM_CYSMICON) because
// large "small" icons wreak havoc with dialog layout
//
#define SMALL_ICON_SIZE 16

//
// Quickly check a listview state flag to see if it is selected or not
//
static inline bool IsStateChecked( UINT nState )
{
    //
    // State image indices are stored in bits 12 through 15 of the listview
    // item state, so we shift the state right 12 bits.  We subtract 1, because
    // the selected image is stored as index 2, an unselected image is stored as index 1.
    //
    return (((nState >> 12) - 1) != 0);
}

#undef VAISHALEE_LETS_ME_PUT_DELETE_IN


#define IDC_ACTION_BUTTON_BAR      1200
#define IDC_SELECTION_BUTTON_BAR   1201
#define IDC_TAKEPICTURE_BUTTON_BAR 1202


//
// Delete item command, doesn't appear in resource header, because there is no UI for it
//
#define IDC_CAMSEL_DELETE 1113

//
// Timer ID for updating the status line
//
#define IDT_UPDATESTATUS 1

//
// Amount of time to wait to update the status line
//
static const UINT c_UpdateStatusTimeout = 200;

// Thumbnail whitespace: the space in between images and their selection rectangles
// These values were discovered by trail and error.  For instance, if you reduce
// c_nAdditionalMarginY to 20, you get really bizarre spacing problems in the list view
// in vertical mode.  These values could become invalid in future versions of the listview.
static const int c_nAdditionalMarginX       = 9;
static const int c_nAdditionalMarginY       = 21;


CCameraSelectionPage::CCameraSelectionPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_pControllerWindow(NULL),
    m_nDefaultThumbnailImageListIndex(-1),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_bThumbnailsRequested(false),
    m_hIconAudioAnnotation(NULL),
    m_hIconMiscellaneousAnnotation(NULL),
    m_nProgrammaticSetting(0),
    m_CameraSelectionButtonBarBitmapInfo( g_hInstance, IDB_CAMSEL_TOOLBAR ),
    m_CameraTakePictureButtonBarBitmapInfo( g_hInstance, IDB_CAMSEL_TOOLBAR ),
    m_CameraActionButtonBarBitmapInfo( g_hInstance, IDB_CAMSEL_TOOLBAR ),
    m_hAccelerators(NULL)
{
}

CCameraSelectionPage::~CCameraSelectionPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
    if (m_hIconAudioAnnotation)
    {
        DestroyIcon(m_hIconAudioAnnotation);
        m_hIconAudioAnnotation = NULL;
    }
    if (m_hIconMiscellaneousAnnotation)
    {
        DestroyIcon(m_hIconMiscellaneousAnnotation);
        m_hIconMiscellaneousAnnotation = NULL;
    }
    if (m_hAccelerators)
    {
        DestroyAcceleratorTable(m_hAccelerators);
        m_hAccelerators = NULL;
    }
}


LRESULT CCameraSelectionPage::OnWizNext( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CCameraSelectionPage::OnWizBack( WPARAM, LPARAM )
{
    return 0;
}

//
// Slightly optimized version of EnableWindow
//
static void MyEnableWindow( HWND hWnd, BOOL bEnable )
{
    if (IsWindowEnabled(hWnd) != bEnable)
    {
        EnableWindow( hWnd, bEnable );
    }
}

void CCameraSelectionPage::MyEnableToolbarButton( int nButtonId, bool bEnable )
{
    ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_ACTION_BUTTON_BAR ), nButtonId, bEnable );
    ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_SELECTION_BUTTON_BAR ), nButtonId, bEnable );
    ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_TAKEPICTURE_BUTTON_BAR ), nButtonId, bEnable );
}

LRESULT CCameraSelectionPage::OnTimer( WPARAM wParam, LPARAM )
{
    //
    // Update the status line
    //
    if (wParam == IDT_UPDATESTATUS)
    {
        KillTimer( m_hWnd, IDT_UPDATESTATUS );

        //
        // Get the item count and selected count
        //
        int nItemCount = ListView_GetItemCount( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ) );
        int nCheckedCount = m_pControllerWindow->GetSelectedImageCount();

        if (!nItemCount)
        {
            //
            // If there are no items, tell the user there are no items on the device
            //
            CSimpleString( IDS_SELECTED_NO_PICTURES, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );
        }
        else if (!nCheckedCount)
        {
            //
            // If none of the items are selected, tell the user there are none selected
            //
            CSimpleString( IDS_SELECTED_NO_IMAGES_SELECTED, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );
        }
        else
        {
            //
            // Just tell them how many selected items there are
            //
            CSimpleString().Format( IDS_CAMERA_SELECT_NUMSEL, g_hInstance, nCheckedCount, nItemCount ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );
        }
    }
    return 0;
}

void CCameraSelectionPage::UpdateControls(void)
{
    int nItemCount = ListView_GetItemCount( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ) );
    int nSelCount = ListView_GetSelectedCount( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ) );
    int nCheckedCount = m_pControllerWindow->GetSelectedImageCount();

    //
    // Figure out which wizard buttons to enable
    //
    int nWizButtons = 0;

    //
    // Only enable "back" if the first page is available
    //
    if (!m_pControllerWindow->SuppressFirstPage())
    {
        nWizButtons |= PSWIZB_BACK;
    }

    //
    // Only enable "next" if there are selected images
    //
    if (nCheckedCount)
    {
        nWizButtons |= PSWIZB_NEXT;
    }

    //
    // Set the buttons
    //
    PropSheet_SetWizButtons( GetParent(m_hWnd), nWizButtons );

    //
    // Properties are only available for one item at a time
    //
    MyEnableToolbarButton( IDC_CAMSEL_PROPERTIES, nSelCount == 1 );
    

    //
    // Select All is only available if there are images
    //
    MyEnableToolbarButton( IDC_CAMSEL_SELECT_ALL, (nItemCount != 0) && (nItemCount != nCheckedCount) );

    //
    // Clear all is only available if there are selected images
    //
    MyEnableToolbarButton( IDC_CAMSEL_CLEAR_ALL, nCheckedCount != 0 );

    //
    // Rotate is only available if there are selected images
    //
    MyEnableToolbarButton( IDC_CAMSEL_ROTATE_RIGHT, nSelCount != 0 );
    MyEnableToolbarButton( IDC_CAMSEL_ROTATE_LEFT, nSelCount != 0 );
    
    //
    // Set a timer to tell the user how many images are selected.  We don't do this
    // here because it is kind of slow, and the static control flickers a bit.
    //
    KillTimer( m_hWnd, IDT_UPDATESTATUS );
    SetTimer( m_hWnd, IDT_UPDATESTATUS, c_UpdateStatusTimeout, NULL );

    //
    // Disable capture if we can't create the dshow graph
    //
    if (m_pControllerWindow->m_DeviceTypeMode == CAcquisitionManagerControllerWindow::VideoMode)
    {
        WIAVIDEO_STATE  VideoState = WIAVIDEO_NO_VIDEO;

        if (m_pWiaVideo)
        {
            m_pWiaVideo->GetCurrentState(&VideoState);
        }

        if (VideoState == WIAVIDEO_NO_VIDEO)
        {
            MyEnableToolbarButton( IDC_CAMSEL_TAKE_PICTURE, FALSE );
        }
        else
        {
            MyEnableToolbarButton( IDC_CAMSEL_TAKE_PICTURE, TRUE );
        }
    }
    else
    {
        if (!m_pControllerWindow->m_bTakePictureIsSupported)
        {
            MyEnableToolbarButton( IDC_CAMSEL_TAKE_PICTURE, FALSE );
        }
        else
        {
            MyEnableToolbarButton( IDC_CAMSEL_TAKE_PICTURE, TRUE );
        }
    }
}


LRESULT CCameraSelectionPage::OnSetActive( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCameraSelectionPage::OnSetActive")));
    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    //
    // In case it failed the first time, try creating the graph again
    //
    InitializeVideoCamera();
    
    //
    // Update the enabled state for all affected controls
    //
    UpdateControls();

    //
    // We do want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectGotoLastpage|CAcquisitionManagerControllerWindow::OnDisconnectFailDownload|CAcquisitionManagerControllerWindow::OnDisconnectFailUpload|CAcquisitionManagerControllerWindow::OnDisconnectFailDelete;

    return 0;
}


LRESULT CCameraSelectionPage::OnShowWindow( WPARAM, LPARAM )
{
    if (!m_bThumbnailsRequested)
    {
        //
        // Request the thumbnails
        //
        m_pControllerWindow->DownloadAllThumbnails();

        //
        // Make sure we don't ask for the thumbnails again
        //
        m_bThumbnailsRequested = true;
    }

    return 0;
}


LRESULT CCameraSelectionPage::OnDestroy( WPARAM, LPARAM )
{
    m_pControllerWindow->m_WindowList.Remove(m_hWnd);

    //
    // Nuke the imagelists
    //
    HIMAGELIST hImageList = ListView_SetImageList( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), NULL, LVSIL_NORMAL );
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }

    hImageList = ListView_SetImageList( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), NULL, LVSIL_SMALL );
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }

    if (m_pWiaVideo)
    {
        HRESULT hr = m_pWiaVideo->DestroyVideo();
    }

    return 0;
}


LRESULT CCameraSelectionPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraSelectionPage::OnInitDialog"));
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    
    //
    // Get the annotation helper interface and initialize the annotation icon
    //
    if (SUCCEEDED(CoCreateInstance( CLSID_WiaDefaultUi, NULL,CLSCTX_INPROC_SERVER, IID_IWiaAnnotationHelpers,(void**)&m_pWiaAnnotationHelpers )))
    {
        m_pWiaAnnotationHelpers->GetAnnotationOverlayIcon( AnnotationAudio, &m_hIconAudioAnnotation, SMALL_ICON_SIZE );
        m_pWiaAnnotationHelpers->GetAnnotationOverlayIcon( AnnotationUnknown, &m_hIconMiscellaneousAnnotation, SMALL_ICON_SIZE );
    }

    //
    // Initialize Thumbnail Listview control
    //
    HWND hwndList = GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS );
    if (hwndList)
    {
        //
        // Get the device name for the root folder group
        //
        if (m_pControllerWindow->m_strwDeviceName.Length())
        {
            m_GroupInfoList.Add( hwndList, m_pControllerWindow->m_strwDeviceName );
        }

        //
        // Get the number of items
        //
        LONG nItemCount = m_pControllerWindow->m_WiaItemList.Count();

        //
        // Hide the labels and use border selection
        //
        ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_SIMPLESELECT|LVS_EX_CHECKBOXES, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|LVS_EX_SIMPLESELECT|LVS_EX_CHECKBOXES );

        //
        // Create the image list
        //
        HIMAGELIST hImageList = ImageList_Create( m_pControllerWindow->m_sizeThumbnails.cx, m_pControllerWindow->m_sizeThumbnails.cy, ILC_COLOR24|ILC_MIRROR, nItemCount, 50 );
        if (hImageList)
        {
            //
            // Create the default thumbnail
            //
            HBITMAP hBmpDefaultThumbnail = WiaUiUtil::CreateIconThumbnail( hwndList, m_pControllerWindow->m_sizeThumbnails.cx, m_pControllerWindow->m_sizeThumbnails.cy, g_hInstance, IDI_UNAVAILABLE, CSimpleString( IDS_DOWNLOADINGTHUMBNAIL, g_hInstance ));
            if (hBmpDefaultThumbnail)
            {
                m_nDefaultThumbnailImageListIndex = ImageList_Add( hImageList, hBmpDefaultThumbnail, NULL );
                DeleteObject( hBmpDefaultThumbnail );
            }

            //
            // Set the image list
            //
            ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );

            //
            // Set the spacing
            //
            ListView_SetIconSpacing( hwndList, m_pControllerWindow->m_sizeThumbnails.cx + c_nAdditionalMarginX, m_pControllerWindow->m_sizeThumbnails.cy + c_nAdditionalMarginY );

            //
            // Set the item count, to minimize recomputing the list size
            //
            ListView_SetItemCount( hwndList, nItemCount );

        }

        //
        // Create a small image list, to prevent the checkbox state images from being resized in WM_SYSCOLORCHANGE
        //
        HIMAGELIST hImageListSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLOR24|ILC_MASK, 1, 1 );
        if (hImageListSmall)
        {
            ListView_SetImageList( hwndList, hImageListSmall, LVSIL_SMALL );
        }
    }


    //
    // Populate the list view
    //
    PopulateListView();

    //
    // Initialize the video camera
    //
    InitializeVideoCamera();

    //
    // Dismiss the progress dialog if it is still up
    //
    if (m_pControllerWindow->m_pWiaProgressDialog)
    {
        m_pControllerWindow->m_pWiaProgressDialog->Destroy();
        m_pControllerWindow->m_pWiaProgressDialog = NULL;
    }
    
    //
    // Make sure the wizard still has the focus.  This weird hack is necessary
    // because user seems to think the wizard is already the foreground window,
    // so the second call doesn't do anything
    //
    SetForegroundWindow( m_pControllerWindow->m_hWnd );
    SetForegroundWindow( GetParent(m_hWnd) );
    

    if (m_pControllerWindow->m_DeviceTypeMode == CAcquisitionManagerControllerWindow::CameraMode)
    {
        
        bool bShowTakePicture = m_pControllerWindow->m_bTakePictureIsSupported;
        
        ToolbarHelper::CButtonDescriptor ActionButtonDescriptors[] =
        {
            { 0, IDC_CAMSEL_ROTATE_RIGHT, TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, 0 },
            { 1, IDC_CAMSEL_ROTATE_LEFT,  TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, 0 },
            { 2, IDC_CAMSEL_PROPERTIES,   TBSTATE_ENABLED, BTNS_BUTTON, bShowTakePicture,  NULL, 0 },
            { 3, IDC_CAMSEL_TAKE_PICTURE, TBSTATE_ENABLED, BTNS_BUTTON, false, &bShowTakePicture, 0 }
        };
    
        HWND hWndActionToolbar = ToolbarHelper::CreateToolbar( 
            m_hWnd, 
            GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS),
            GetDlgItem(m_hWnd,IDC_CAMSEL_CAMERA_BUTTON_BAR_GUIDE),
            ToolbarHelper::AlignLeft|ToolbarHelper::AlignTop,
            IDC_ACTION_BUTTON_BAR,
            m_CameraActionButtonBarBitmapInfo, 
            ActionButtonDescriptors, 
            ARRAYSIZE(ActionButtonDescriptors) );

        ToolbarHelper::CButtonDescriptor SelectionButtonDescriptors[] =
        {
            { -1, IDC_CAMSEL_CLEAR_ALL,    TBSTATE_ENABLED, BTNS_BUTTON, true, NULL, IDS_CAMSEL_CLEAR_ALL },
            { -1, IDC_CAMSEL_SELECT_ALL,   TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, IDS_CAMSEL_SELECT_ALL }
        };
    
        HWND hWndSelectionToolbar = ToolbarHelper::CreateToolbar( 
            m_hWnd, 
            hWndActionToolbar,
            GetDlgItem(m_hWnd,IDC_CAMSEL_CAMERA_BUTTON_BAR_GUIDE),
            ToolbarHelper::AlignRight|ToolbarHelper::AlignTop,
            IDC_SELECTION_BUTTON_BAR,
            m_CameraSelectionButtonBarBitmapInfo, 
            SelectionButtonDescriptors, 
            ARRAYSIZE(SelectionButtonDescriptors) );
        
        //
        // Nuke the guide window
        //
        DestroyWindow( GetDlgItem(m_hWnd,IDC_CAMSEL_CAMERA_BUTTON_BAR_GUIDE) );
        
        //
        // Make sure the toolbars are visible
        //
        ShowWindow( hWndActionToolbar, SW_SHOW );
        UpdateWindow( hWndActionToolbar );
        ShowWindow( hWndSelectionToolbar, SW_SHOW );
        UpdateWindow( hWndSelectionToolbar );
    }
    else
    {
        ToolbarHelper::CButtonDescriptor TakePictureButtonDescriptors[] =
        {
            { 3, IDC_CAMSEL_TAKE_PICTURE, TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, IDS_CAMSEL_TAKE_PICTURE }
        };
    
        HWND hWndTakePictureToolbar = ToolbarHelper::CreateToolbar( 
            m_hWnd, 
            GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS),
            GetDlgItem(m_hWnd,IDC_CAMSEL_VIDEO_PREVIEW_BUTTON_BAR_GUIDE),
            ToolbarHelper::AlignHCenter|ToolbarHelper::AlignTop,
            IDC_TAKEPICTURE_BUTTON_BAR,
            m_CameraTakePictureButtonBarBitmapInfo, 
            TakePictureButtonDescriptors, 
            ARRAYSIZE(TakePictureButtonDescriptors) );

        ToolbarHelper::CButtonDescriptor ActionButtonDescriptors[] =
        {
            { 0, IDC_CAMSEL_ROTATE_RIGHT, TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, 0 },
            { 1, IDC_CAMSEL_ROTATE_LEFT,  TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, 0 },
            { 2, IDC_CAMSEL_PROPERTIES,   TBSTATE_ENABLED, BTNS_BUTTON, true,  NULL, 0 }
        };
    
        HWND hWndActionToolbar = ToolbarHelper::CreateToolbar( 
            m_hWnd, 
            hWndTakePictureToolbar,
            GetDlgItem(m_hWnd,IDC_CAMSEL_VIDEO_SELECTION_BUTTON_BAR_GUIDE),
            ToolbarHelper::AlignLeft|ToolbarHelper::AlignTop,
            IDC_ACTION_BUTTON_BAR,
            m_CameraActionButtonBarBitmapInfo, 
            ActionButtonDescriptors, 
            ARRAYSIZE(ActionButtonDescriptors) );

        ToolbarHelper::CButtonDescriptor SelectionButtonDescriptors[] =
        {
            { -1, IDC_CAMSEL_CLEAR_ALL,    TBSTATE_ENABLED, BTNS_BUTTON, true, NULL, IDS_CAMSEL_CLEAR_ALL },
            { -1, IDC_CAMSEL_SELECT_ALL,   TBSTATE_ENABLED, BTNS_BUTTON, false, NULL, IDS_CAMSEL_SELECT_ALL }
        };
    
        HWND hWndSelectionToolbar = ToolbarHelper::CreateToolbar( 
            m_hWnd, 
            hWndActionToolbar,
            GetDlgItem(m_hWnd,IDC_CAMSEL_VIDEO_SELECTION_BUTTON_BAR_GUIDE),
            ToolbarHelper::AlignRight|ToolbarHelper::AlignTop,
            IDC_SELECTION_BUTTON_BAR,
            m_CameraSelectionButtonBarBitmapInfo, 
            SelectionButtonDescriptors, 
            ARRAYSIZE(SelectionButtonDescriptors) );

        //
        // Nuke the guide windows
        //
        DestroyWindow( GetDlgItem(m_hWnd,IDC_CAMSEL_VIDEO_PREVIEW_BUTTON_BAR_GUIDE) );
        DestroyWindow( GetDlgItem(m_hWnd,IDC_CAMSEL_VIDEO_SELECTION_BUTTON_BAR_GUIDE) );
        
        //
        // Make sure the toolbars are visible
        //
        ShowWindow( hWndTakePictureToolbar, SW_SHOW );
        UpdateWindow( hWndTakePictureToolbar );
        ShowWindow( hWndActionToolbar, SW_SHOW );
        UpdateWindow( hWndActionToolbar );
        ShowWindow( hWndSelectionToolbar, SW_SHOW );
        UpdateWindow( hWndSelectionToolbar );
    }

    m_hAccelerators = LoadAccelerators( g_hInstance, MAKEINTRESOURCE(IDR_CAMERASELECTIONACCEL) );
    
    return 0;
}


LRESULT CCameraSelectionPage::OnTranslateAccelerator( WPARAM, LPARAM lParam )
{
    //
    // Assume we won't be handling this message
    //
    LRESULT lResult = PSNRET_NOERROR;

    //
    // Make sure this is the current window
    //
    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
    {
        //
        // Make sure we have a valid accelerator table
        //
        if (m_hAccelerators)
        {
            //
            // Get the WM_NOTIFY message goo for this message
            //
            PSHNOTIFY *pPropSheetNotify = reinterpret_cast<PSHNOTIFY*>(lParam);
            if (pPropSheetNotify)
            {
                //
                // Get the MSG
                //
                MSG *pMsg = reinterpret_cast<MSG*>(pPropSheetNotify->lParam);
                if (pMsg)
                {
                    //
                    // Try to translate the accelerator
                    //
                    if (TranslateAccelerator( m_hWnd, m_hAccelerators, pMsg ))
                    {
                        //
                        // If we were able to 
                        //
                        lResult = PSNRET_MESSAGEHANDLED;
                    }
                }
            }
        }
    }
    return lResult;
}

void CCameraSelectionPage::InitializeVideoCamera(void)
{
    //
    // Make sure this is a video camera
    //
    if (m_pControllerWindow->m_DeviceTypeMode != CAcquisitionManagerControllerWindow::VideoMode)
    {
        return;
    }

    HRESULT             hr = S_OK;
    WIAVIDEO_STATE      VideoState = WIAVIDEO_NO_VIDEO;
    CSimpleStringWide   strImagesDirectory;

    if (m_pWiaVideo == NULL)
    {
        hr = CoCreateInstance(CLSID_WiaVideo, 
                              NULL, 
                              CLSCTX_INPROC_SERVER, 
                              IID_IWiaVideo,
                              (void**) &m_pWiaVideo);
    }

    //
    // No point continuing if we can't create the video interface
    //
    if (!m_pWiaVideo)
    {
        return;
    }

    if (hr == S_OK)
    {
        BOOL bSuccess = FALSE;
        
        //
        // Get the IMAGES_DIRECTORY property from the Wia Video Driver.
        //
        bSuccess = PropStorageHelpers::GetProperty(m_pControllerWindow->m_pWiaItemRoot, 
                                                   WIA_DPV_IMAGES_DIRECTORY, 
                                                   strImagesDirectory);

        if (!bSuccess)
        {
            hr = E_FAIL;
        }
    }

    if (hr == S_OK)
    {
        //
        // Get the current state of the WiaVideo object.  If we just created it
        // then the state will be NO_VIDEO, otherwise, it could already be previewing video,
        // in which case we shouldn't do anything.
        //
        hr = m_pWiaVideo->GetCurrentState(&VideoState);

        if (VideoState == WIAVIDEO_NO_VIDEO)
        {
            //
            // Set the directory we want to save our images to.  We got the image directory
            // from the Wia Video Driver IMAGES_DIRECTORY property
            //
            if (hr == S_OK)
            {
                hr = m_pWiaVideo->put_ImagesDirectory(CSimpleBStr(strImagesDirectory));
            }
    
            //
            // Create the video preview as a child of the IDC_VIDSEL_PREVIEW dialog item
            // and automatically begin playback after creating the preview.
            //
            if (hr == S_OK)
            {
                hr = m_pWiaVideo->CreateVideoByWiaDevID(
                                CSimpleBStr(m_pControllerWindow->m_pEventParameters->strDeviceID),
                                GetDlgItem(m_hWnd, IDC_VIDSEL_PREVIEW),
                                FALSE,
                                TRUE);
            }
        }
    }

    //
    // If there was a failure, tell the user
    //
    if (hr != S_OK)
    {
        CSimpleString( IDS_VIDEOPREVIEWUNAVAILABLE, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_VIDSEL_PREVIEW ) );

    }
    else
    {
        SetWindowText( GetDlgItem( m_hWnd, IDC_VIDSEL_PREVIEW ), TEXT("") );
    }
}


CWiaItem *CCameraSelectionPage::GetItemFromListByIndex( HWND hwndList, int nItem )
{
    LVITEM LvItem;
    ZeroMemory( &LvItem, sizeof(LvItem) );
    LvItem.iItem = nItem;
    LvItem.mask = LVIF_PARAM;
    if (ListView_GetItem( hwndList, &LvItem ))
    {
        return reinterpret_cast<CWiaItem*>(LvItem.lParam);
    }
    return NULL;
}

int CCameraSelectionPage::FindItemListIndex( HWND hwndList, CWiaItem *pWiaItem )
{
    for (int i=0;i<ListView_GetItemCount(hwndList);i++)
    {
        CWiaItem *pItem = GetItemFromListByIndex( hwndList, i );
        if (pWiaItem && pWiaItem == pItem)
            return i;
    }
    return -1;
}

void CCameraSelectionPage::DrawAnnotationIcons( HDC hDC, CWiaItem *pWiaItem, HBITMAP hBitmap )
{
    if (hDC && hBitmap && pWiaItem)
    {
        //
        // Create a memory DC
        //
        HDC hMemDC = CreateCompatibleDC( hDC );
        if (hMemDC)
        {
            //
            // Select the bitmap into the memory DC
            //
            HBITMAP hOldBitmap = SelectBitmap( hMemDC, hBitmap );

            //
            // Assume we will not neen an annotation icon
            //
            HICON hIcon = NULL;

            //
            // Figure out which icon to use
            //
            CAnnotationType AnnotationType = pWiaItem->AnnotationType();
            if (AnnotationAudio == AnnotationType)
            {
                hIcon = m_hIconAudioAnnotation;
            }
            else if (AnnotationUnknown == AnnotationType)
            {
                hIcon = m_hIconMiscellaneousAnnotation;
            }
            

            //
            // If we need an annotation icon
            //
            if (hIcon)
            {
                //
                // Get the icon's dimensions
                //
                SIZE sizeIcon = {0};
                if (PrintScanUtil::GetIconSize( hIcon, sizeIcon ))
                {
                    //
                    // Get the bitmap's dimensions
                    //
                    SIZE sizeBitmap = {0};
                    if (PrintScanUtil::GetBitmapSize( hBitmap, sizeBitmap ))
                    {
                        //
                        // Set up a good margin for this icon, so it isn't right up against the edge
                        //
                        const int nMargin = 3;

                        //
                        // Draw the icon
                        //
                        DrawIconEx( hMemDC, sizeBitmap.cx-sizeIcon.cx-nMargin, sizeBitmap.cy-sizeIcon.cy-nMargin, hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, DI_NORMAL );
                    }

                }

            }

            //
            // Restore the old bitmap and delete the DC
            //
            SelectBitmap( hMemDC, hOldBitmap );
            DeleteDC(hMemDC);
        }
    }
}

int CCameraSelectionPage::AddThumbnailToListViewImageList( HWND hwndList, CWiaItem *pWiaItem, int nIndex )
{
    WIA_PUSH_FUNCTION((TEXT("CCameraSelectionPage::AddThumbnailToListViewImageList")));

    //
    // Assume we have the default thumbnail.  If there are any problems, this is what we will use.
    //
    int nImageListIndex = m_nDefaultThumbnailImageListIndex;

    //
    // Make sure we have a valid item
    //
    if (pWiaItem)
    {
        //
        // We need a DC to create and scale the thumbnail
        //
        HDC hDC = GetDC(m_hWnd);
        if (hDC)
        {
            //
            // Is there a valid thumbnail for this image?  If so, prepare it.
            //
            HBITMAP hThumbnail = pWiaItem->CreateThumbnailBitmap( m_hWnd, m_GdiPlusHelper, m_pControllerWindow->m_sizeThumbnails.cx, m_pControllerWindow->m_sizeThumbnails.cy );
            if (hThumbnail)
            {
                //
                // Draw any annotation icons
                //
                DrawAnnotationIcons( hDC, pWiaItem, hThumbnail );

                //
                // Find out if we already have a thumbnail in the list
                // If we do have a thumbnail, we want to replace it in the image list
                //
                LVITEM LvItem = {0};
                LvItem.mask = LVIF_IMAGE;
                LvItem.iItem = nIndex;
                if (ListView_GetItem( hwndList, &LvItem ) && LvItem.iImage != m_nDefaultThumbnailImageListIndex)
                {
                    //
                    // Get the image list
                    //
                    HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
                    if (hImageList)
                    {
                        //
                        // Replace the image and save the index
                        //
                        if (ImageList_Replace( hImageList, LvItem.iImage, hThumbnail, NULL ))
                        {
                            nImageListIndex = LvItem.iImage;
                        }
                    }
                }
                else
                {
                    //
                    // Get the image list
                    //
                    HIMAGELIST hImageList = ListView_GetImageList( hwndList, LVSIL_NORMAL );
                    if (hImageList)
                    {
                        //
                        // Add this image to the listview's imagelist and save the index
                        //
                        nImageListIndex = ImageList_Add( hImageList, hThumbnail, NULL );
                    }
                }

                //
                // Delete the thumbnail to prevent a leak
                //
                DeleteBitmap(hThumbnail);
            }

            //
            // Release the client DC
            //
            ReleaseDC( m_hWnd, hDC );
        }
    }

    //
    // Return the index of the image in the imagelist
    //
    return nImageListIndex;
}

int CCameraSelectionPage::AddItem( HWND hwndList, CWiaItem *pWiaItem, bool bEnsureVisible )
{
    //
    // Prevent handling of change notifications while we do this.
    //
    m_nProgrammaticSetting++;
    int nResult = -1;
    if (pWiaItem && hwndList)
    {
        //
        // Find out where we are going to insert this image
        //
        int nIndex = ListView_GetItemCount( hwndList );

        //
        // Add or replace the thumbnail
        //
        int nImageListIndex = AddThumbnailToListViewImageList( hwndList, pWiaItem, nIndex );
        if (nImageListIndex >= 0)
        {
            //
            // Get the item ready to insert and insert it
            //
            LVITEM lvItem = {0};
            lvItem.iItem = nIndex;
            lvItem.mask = LVIF_IMAGE|LVIF_PARAM|LVIF_STATE|LVIF_GROUPID;
            lvItem.iImage = nImageListIndex;
            lvItem.lParam = reinterpret_cast<LPARAM>(pWiaItem);
            lvItem.state = !nIndex ? LVIS_SELECTED|LVIS_FOCUSED : 0;
            lvItem.iGroupId = m_GroupInfoList.GetGroupId(pWiaItem,hwndList);
            nResult = ListView_InsertItem( hwndList, &lvItem );
            if (nResult >= 0)
            {
                //
                // Set the check if the item is selected
                //
                ListView_SetCheckState( hwndList, nIndex, pWiaItem->SelectedForDownload() );

                //
                // Ensure the item is visible, if necessary
                //
                if (bEnsureVisible)
                {
                    ListView_EnsureVisible( hwndList, nResult, FALSE );
                }
            }
        }
    }
    //
    // Enable handling of change notifications
    //
    m_nProgrammaticSetting--;
    return nResult;
}

void CCameraSelectionPage::AddEnumeratedItems( HWND hwndList, CWiaItem *pFirstItem )
{
    //
    // First, enumerate all of the images on this level and add them
    //
    CWiaItem *pCurrItem = pFirstItem;
    while (pCurrItem)
    {
        if (pCurrItem->IsDownloadableItemType())
        {
            AddItem( hwndList, pCurrItem );
        }
        pCurrItem = pCurrItem->Next();
    }

    //
    // Now look for children, and recursively add them
    //
    pCurrItem = pFirstItem;
    while (pCurrItem)
    {
        AddEnumeratedItems( hwndList, pCurrItem->Children() );
        pCurrItem = pCurrItem->Next();
    }
}

void CCameraSelectionPage::PopulateListView(void)
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS );
    if (hwndList)
    {
        //
        // Tell the window not to redraw while we add these items
        //
        SendMessage( hwndList, WM_SETREDRAW, FALSE, 0 );

        //
        // Begin recursively adding all of the items
        //
        AddEnumeratedItems( hwndList, m_pControllerWindow->m_WiaItemList.Root() );

        //
        // If we have any folders, allow group view
        //
        if (m_GroupInfoList.Size() > 1)
        {
            ListView_EnableGroupView( hwndList, TRUE );
        }

        //
        // Tell the window to redraw now, because we are done.  Invalidate the window, in case it is visible
        //
        SendMessage( hwndList, WM_SETREDRAW, TRUE, 0 );
        InvalidateRect( hwndList, NULL, FALSE );
    }
}


int CCameraSelectionPage::GetSelectionIndices( CSimpleDynamicArray<int> &aIndices )
{
    HWND hwndList = GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS );
    if (!hwndList)
        return(0);
    int iCount = ListView_GetItemCount(hwndList);
    for (int i=0;i<iCount;i++)
        if (ListView_GetItemState(hwndList,i,LVIS_SELECTED) & LVIS_SELECTED)
            aIndices.Append(i);
    return(aIndices.Size());
}

// This function gets called in response to an image downloading.  We're only interested in items being deleted.
void CCameraSelectionPage::OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    CDownloadImagesThreadNotifyMessage *pDownloadImageThreadNotifyMessage = dynamic_cast<CDownloadImagesThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadImageThreadNotifyMessage && m_pControllerWindow)
    {
        switch (pDownloadImageThreadNotifyMessage->Status())
        {
        case CDownloadImagesThreadNotifyMessage::End:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {

                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        //
                        // Make sure the download was successful, and not cancelled
                        //
                        if (S_OK == pDownloadImageThreadNotifyMessage->hr())
                        {
                            //
                            // Mark each successfully downloaded image as not-downloadable, and clear its selection state
                            //
                            for (int i=0;i<pDownloadImageThreadNotifyMessage->DownloadedFileInformation().Size();i++)
                            {
                                CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadImageThreadNotifyMessage->DownloadedFileInformation()[i].Cookie() );
                                if (pWiaItem)
                                {
                                    pWiaItem->SelectedForDownload( false );
                                    int nItem = FindItemListIndex( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem );
                                    if (nItem >= 0)
                                    {
                                        ListView_SetCheckState( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), nItem, FALSE );
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
            break;
        }
    }
}


// This function gets called in response to a thumbnail download finishing.
void CCameraSelectionPage::OnNotifyDownloadThumbnail( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    CDownloadThumbnailsThreadNotifyMessage *pDownloadThumbnailsThreadNotifyMessage= dynamic_cast<CDownloadThumbnailsThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadThumbnailsThreadNotifyMessage)
    {
        switch (pDownloadThumbnailsThreadNotifyMessage->Status())
        {
        case CDownloadThumbnailsThreadNotifyMessage::End:
            {
                switch (pDownloadThumbnailsThreadNotifyMessage->Operation())
                {
                case CDownloadThumbnailsThreadNotifyMessage::DownloadThumbnail:
                    {
                        // Find the item in the list
                        CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadThumbnailsThreadNotifyMessage->Cookie() );
                        if (pWiaItem)
                        {
                            int nItem = FindItemListIndex( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem );
                            if (nItem >= 0)
                            {
                                int nImageListIndex = AddThumbnailToListViewImageList( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem, nItem );
                                if (nImageListIndex >= 0)
                                {
                                    LVITEM LvItem;
                                    ZeroMemory( &LvItem, sizeof(LvItem) );
                                    LvItem.iItem = nItem;
                                    LvItem.mask = LVIF_IMAGE;
                                    LvItem.iImage = nImageListIndex;
                                    ListView_SetItem( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), &LvItem );

                                    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
                                    {
                                        UpdateControls();
                                    }
                                }
                            }
                        }
                    }
                    break;
                }
            }
            break;
        }
    }
}

LRESULT CCameraSelectionPage::OnThumbnailListSelChange( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCameraSelectionPage::OnThumbnailListSelChange"));
    if (!m_nProgrammaticSetting)
    {
        NMLISTVIEW *pNmListView = reinterpret_cast<NMLISTVIEW*>(lParam);
        if (pNmListView)
        {
            WIA_TRACE((TEXT("pNmListView->uChanged: %08X, pNmListView->uOldState: %08X, pNmListView->uNewState: %08X"), pNmListView->uChanged, pNmListView->uOldState, pNmListView->uNewState ));
            //
            // If this is a check state change
            //
            if ((pNmListView->uChanged & LVIF_STATE) && ((pNmListView->uOldState&LVIS_STATEIMAGEMASK) ^ (pNmListView->uNewState&LVIS_STATEIMAGEMASK)))
            {
                //
                // Get the item * from the LVITEM structure
                //
                CWiaItem *pWiaItem = reinterpret_cast<CWiaItem *>(pNmListView->lParam);
                if (pWiaItem)
                {
                    //
                    // Set selected flag in the item
                    //
                    pWiaItem->SelectedForDownload( IsStateChecked(pNmListView->uNewState) );

                    //
                    // If this is the current page, update the control state
                    //
                    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
                    {
                        UpdateControls();
                    }
                }
            }
            else if ((pNmListView->uChanged & LVIF_STATE) && ((pNmListView->uOldState&LVIS_SELECTED) ^ (pNmListView->uNewState&LVIS_SELECTED)))
            {
                //
                // If this is the current page, update the control state
                //
                if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
                {
                    UpdateControls();
                }
            }
        }
    }
    return 0;
}

void CCameraSelectionPage::OnProperties( WPARAM, LPARAM )
{
    CSimpleDynamicArray<int> aSelIndices;
    if (GetSelectionIndices( aSelIndices ))
    {
        if (aSelIndices.Size() == 1)
        {
            CWiaItem *pWiaItem = GetItemFromListByIndex( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), aSelIndices[0]);
            if (pWiaItem && pWiaItem->WiaItem())
            {
                m_pControllerWindow->m_pThreadMessageQueue->Pause();
                HRESULT hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pWiaItem->WiaItem(), CSimpleString(IDS_ADVANCEDPROPERTIES, g_hInstance) );
                m_pControllerWindow->m_pThreadMessageQueue->Resume();

                if (FAILED(hr))
                {
                    CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_PROPERTY_SHEET_ERROR, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONINFORMATION );
                }
            }
        }
    }
}

void CCameraSelectionPage::OnSelectAll( WPARAM, LPARAM )
{
    HWND hwndList = GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS);
    if (hwndList)
    {
        ListView_SetCheckState( hwndList, -1, TRUE );
    }
}

void CCameraSelectionPage::OnClearAll( WPARAM, LPARAM )
{
    HWND hwndList = GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS);
    if (hwndList)
    {
        ListView_SetCheckState( hwndList, -1, FALSE );
    }
}

LRESULT CCameraSelectionPage::OnThumbnailListKeyDown( WPARAM, LPARAM lParam )
{
    NMLVKEYDOWN *pNmLvKeyDown = reinterpret_cast<NMLVKEYDOWN*>(lParam);
    bool bControl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
    bool bShift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
    bool bAlt = (GetKeyState(VK_MENU) & 0x8000) != 0;
    if (pNmLvKeyDown->wVKey == TEXT('A') && bControl && !bShift && !bAlt)
    {
        SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDC_CAMSEL_SELECT_ALL,0), 0 );
    }
#if defined(VAISHALEE_LETS_ME_PUT_DELETE_IN)
    else if (VK_DELETE == pNmLvKeyDown->wVKey && !bAlt && !bControl && !bShift)
    {
        SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDC_CAMSEL_DELETE,0), 0 );
    }
#endif
    return 0;
}


void CCameraSelectionPage::OnTakePicture( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCameraSelectionPage::OnTakePicture")));

    if (m_pControllerWindow->m_bTakePictureIsSupported)
    {
        CWaitCursor wc;

        //
        // Tell the user we are taking a picture
        //
        CSimpleString( IDS_TAKING_PICTURE, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );

        HRESULT hr = S_OK;

        //
        // If we are not a video camera, just tell the device to snap a picture
        //
        if (m_pControllerWindow->m_DeviceTypeMode == CAcquisitionManagerControllerWindow::CameraMode)
        {
            CComPtr<IWiaItem> pNewWiaItem;
            hr = m_pControllerWindow->m_pWiaItemRoot->DeviceCommand(0,&WIA_CMD_TAKE_PICTURE,&pNewWiaItem);
        }
        else if (m_pWiaVideo)
        {
            //
            // Take the picture
            //
            BSTR bstrNewImageFileName = NULL;
            hr = m_pWiaVideo->TakePicture(&bstrNewImageFileName);
            if (hr == S_OK)
            {
                //
                // Succeeded in taking the picture, setting the LAST_PICTURE_TAKEN property
                // on the video driver to create a new item.
                //
                PROPVARIANT pv = {0};
                PropVariantInit(&pv);

                pv.vt       = VT_BSTR;
                pv.bstrVal  = bstrNewImageFileName;
                BOOL bSuccess = PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPV_LAST_PICTURE_TAKEN, pv );
                if (!bSuccess)
                {
                    hr = E_FAIL;
                    WIA_PRINTHRESULT((hr,TEXT("PropStorageHelpers::SetProperty failed")));
                }

                //
                // Note that this will free the bstrNewImageFileName returned to
                // us by WiaVideo
                //
                PropVariantClear(&pv);
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("m_pWiaVideo->TakePicture failed")));
            }
        }

        //
        // Clear the status
        //
        if (SUCCEEDED(hr))
        {
            SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ), TEXT("") );
        }
        else
        {
            MessageBeep(MB_ICONEXCLAMATION);
            CSimpleString( IDS_UNABLE_TO_TAKE_PICTURE, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );
            WIA_PRINTHRESULT((hr,TEXT("Take picture failed")));
        }
    }
}


void CCameraSelectionPage::OnRotate( WPARAM wParam, LPARAM )
{
    //
    // This could take a while for a lot of images, especially since we don't cache DIBs,
    // so we'll display an hourglass cursor here.
    //
    CWaitCursor wc;

    bool bAtLeastOneWasSuccessful = false;
    bool bAtLeastOneWasInitialized = false;
    CSimpleDynamicArray<int> aIndices;
    if (CCameraSelectionPage::GetSelectionIndices( aIndices ))
    {
        for (int i=0;i<aIndices.Size();i++)
        {
            CWiaItem *pWiaItem = GetItemFromListByIndex( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), aIndices[i] );
            if (pWiaItem)
            {
                if (pWiaItem->RotationEnabled(true))
                {
                    bool bRotateRight = true;
                    if (IDC_CAMSEL_ROTATE_LEFT == LOWORD(wParam))
                    {
                        bRotateRight = false;
                    }
                    pWiaItem->Rotate(bRotateRight);
                    int nImageListIndex = AddThumbnailToListViewImageList( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), pWiaItem, aIndices[i] );

                    LVITEM LvItem;
                    ZeroMemory( &LvItem, sizeof(LvItem) );
                    LvItem.iItem = aIndices[i];
                    LvItem.mask = LVIF_IMAGE;
                    LvItem.iImage = nImageListIndex;
                    ListView_SetItem( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), &LvItem );
                    bAtLeastOneWasSuccessful = true;
                }
                //
                // We don't want to warn the user about failure to rotate images for which we haven't downloaded the preferred format
                //
                else if (pWiaItem->DefaultFormat() == IID_NULL)
                {
                    bAtLeastOneWasSuccessful = true;
                }
                else
                {
                    bAtLeastOneWasInitialized = true;
                }
            }
        }
        //
        // If not one picture could be rotated AND at least one had already been initialized, warn the user
        //
        if (!bAtLeastOneWasSuccessful && bAtLeastOneWasInitialized)
        {
            //
            // Beep and tell the user
            //
            MessageBeep(MB_ICONEXCLAMATION);
            CSimpleString( IDS_UNABLETOROTATE, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_CAMSEL_STATUS ) );
        }
        //
        // Repaint the items
        //
        ListView_RedrawItems( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), aIndices[0], aIndices[aIndices.Size()-1] );

        //
        // Force an immediate update
        //
        UpdateWindow( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS) );
    }
}

LRESULT CCameraSelectionPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonFirstPage::OnEventNotification") ));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // Handle the deleted item event
        //
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_DELETED)
        {
            //
            // Try to find this item in the item list
            //
            CWiaItem *pWiaItem = m_pControllerWindow->FindItemByName( pEventMessage->FullItemName() );
            if (pWiaItem)
            {
                //
                // Find the item in the listview and delete it from the listview
                //
                int nItem = FindItemListIndex( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem );
                if (nItem >= 0)
                {
                    ListView_DeleteItem( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), nItem );
                }
            }

            if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
            {
                UpdateControls();
            }
        }
        else if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            //
            // Make sure we have a valid controller window
            //
            //
            // Find the new item
            //
            CWiaItem *pWiaItem = m_pControllerWindow->FindItemByName( pEventMessage->FullItemName() );
            if (pWiaItem)
            {
                //
                // If this is the current page, select the image.
                //
                if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
                {
                    pWiaItem->SelectedForDownload(true);
                }

                //
                // Make sure it isn't already in the list
                //
                if (FindItemListIndex( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem ) < 0)
                {
                    //
                    // Add it to the list view
                    //
                    AddItem( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), pWiaItem, true );
                }
            }

            if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
            {
                UpdateControls();
            }
        }

        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}


void CCameraSelectionPage::OnDelete( WPARAM, LPARAM )
{
    int nSelCount = ListView_GetSelectedCount( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ) );
    if (nSelCount)
    {
        if (m_pControllerWindow->CanSomeSelectedImagesBeDeleted())
        {
            if (CMessageBoxEx::IDMBEX_YES == CMessageBoxEx::MessageBox( m_hWnd, CSimpleString(IDS_CONFIRMDELETE,g_hInstance), CSimpleString(IDS_ERROR_TITLE,g_hInstance), CMessageBoxEx::MBEX_ICONQUESTION|CMessageBoxEx::MBEX_YESNO|CMessageBoxEx::MBEX_DEFBUTTON2))
            {
                m_pControllerWindow->DeleteSelectedImages();
            }
        }
    }
}

LRESULT CCameraSelectionPage::OnGetToolTipDispInfo( WPARAM wParam, LPARAM lParam )
{
    TOOLTIPTEXT *pToolTipText = reinterpret_cast<TOOLTIPTEXT*>(lParam);
    if (pToolTipText)
    {

        switch (pToolTipText->hdr.idFrom)
        {
        case IDC_CAMSEL_ROTATE_RIGHT:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_ROTATE_RIGHT);
            break;
        case IDC_CAMSEL_ROTATE_LEFT:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_ROTATE_LEFT);
            break;
        case IDC_CAMSEL_PROPERTIES:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_PROPERTIES);
            break;
        case IDC_CAMSEL_TAKE_PICTURE:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_TAKE_PICTURE);
                break;
        case IDC_CAMSEL_CLEAR_ALL:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_CLEAR_ALL);
            break;
        case IDC_CAMSEL_SELECT_ALL:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_CAMSEL_TOOLTIP_SELECT_ALL);
            break;
        }
    }
    return 0;
}

void CCameraSelectionPage::RepaintAllThumbnails()
{
    //
    // This could take a while for a lot of images, especially since we don't cache DIBs,
    // so we'll display an hourglass cursor here.
    //
    CWaitCursor wc;
    for (int i=0;i<ListView_GetItemCount(GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS));i++)
    {
        CWiaItem *pWiaItem = GetItemFromListByIndex( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), i );
        if (pWiaItem)
        {
            int nImageListIndex = AddThumbnailToListViewImageList( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), pWiaItem, i );
            if (nImageListIndex >= 0)
            {
                LVITEM LvItem = {0};
                LvItem.iItem = i;
                LvItem.mask = LVIF_IMAGE;
                LvItem.iImage = nImageListIndex;
                ListView_SetItem( GetDlgItem(m_hWnd,IDC_CAMSEL_THUMBNAILS), &LvItem );
            }
        }
    }
    UpdateWindow( m_hWnd );
}


LRESULT CCameraSelectionPage::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    SendDlgItemMessage( m_hWnd, IDC_CAMSEL_THUMBNAILS, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_ACTION_BUTTON_BAR, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_SELECTION_BUTTON_BAR, WM_SYSCOLORCHANGE, wParam, lParam );
    SendDlgItemMessage( m_hWnd, IDC_TAKEPICTURE_BUTTON_BAR, WM_SYSCOLORCHANGE, wParam, lParam );
    m_CameraSelectionButtonBarBitmapInfo.ReloadAndReplaceBitmap();
    m_CameraTakePictureButtonBarBitmapInfo.ReloadAndReplaceBitmap();
    m_CameraActionButtonBarBitmapInfo.ReloadAndReplaceBitmap();
    RepaintAllThumbnails();
    return 0;
}

LRESULT CCameraSelectionPage::OnThemeChanged( WPARAM wParam, LPARAM lParam )
{
    SendDlgItemMessage( m_hWnd, IDC_CAMSEL_THUMBNAILS, WM_THEMECHANGED, wParam, lParam );
    return 0;
}

LRESULT CCameraSelectionPage::OnSettingChange( WPARAM wParam, LPARAM lParam )
{
    //
    // Create a small image list, to prevent the checkbox state images from being resized in WM_SYSCOLORCHANGE
    //
    HIMAGELIST hImageListSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLOR24|ILC_MASK, 1, 1 );
    if (hImageListSmall)
    {
        HIMAGELIST hImgListOld = ListView_SetImageList( GetDlgItem( m_hWnd, IDC_CAMSEL_THUMBNAILS ), hImageListSmall, LVSIL_SMALL );
        if (hImgListOld)
        {
            ImageList_Destroy(hImgListOld);
        }
    }

    SendDlgItemMessage( m_hWnd, IDC_CAMSEL_THUMBNAILS, WM_SETTINGCHANGE, wParam, lParam );
    return 0;
}

LRESULT CCameraSelectionPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND( IDC_CAMSEL_SELECT_ALL, OnSelectAll );
        SC_HANDLE_COMMAND( IDC_CAMSEL_CLEAR_ALL, OnClearAll );
        SC_HANDLE_COMMAND( IDC_CAMSEL_PROPERTIES, OnProperties );
        SC_HANDLE_COMMAND( IDC_CAMSEL_ROTATE_RIGHT, OnRotate );
        SC_HANDLE_COMMAND( IDC_CAMSEL_ROTATE_LEFT, OnRotate );
        SC_HANDLE_COMMAND( IDC_CAMSEL_TAKE_PICTURE, OnTakePicture );
        SC_HANDLE_COMMAND( IDC_CAMSEL_DELETE, OnDelete );
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CCameraSelectionPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_TRANSLATEACCELERATOR,OnTranslateAccelerator);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(TTN_GETDISPINFO,OnGetToolTipDispInfo);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(LVN_ITEMCHANGED,IDC_CAMSEL_THUMBNAILS,OnThumbnailListSelChange);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(LVN_KEYDOWN,IDC_CAMSEL_THUMBNAILS,OnThumbnailListKeyDown);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

LRESULT CCameraSelectionPage::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WTM_BEGIN_THREAD_NOTIFY_MESSAGE_HANDLERS()
    {
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_DOWNLOADTHUMBNAIL, OnNotifyDownloadThumbnail );
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_DOWNLOADIMAGE, OnNotifyDownloadImage );
    }
    WTM_END_THREAD_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCameraSelectionPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCameraSelectionPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_SHOWWINDOW, OnShowWindow );
        SC_HANDLE_DIALOG_MESSAGE( WM_TIMER, OnTimer );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
        SC_HANDLE_DIALOG_MESSAGE( WM_THEMECHANGED, OnThemeChanged );
        SC_HANDLE_DIALOG_MESSAGE( WM_SETTINGCHANGE, OnSettingChange );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nThreadNotificationMessage, OnThreadNotification );
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nWiaEventMessage, OnEventNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comfirst.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMFIRST.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: First wizard page for cameras
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "comfirst.h"
#include <shlobj.h>
#include "resource.h"
#include "shellext.h"
#include "wiatextc.h"
#include "simcrack.h"
#include "gwiaevnt.h"

static int c_nMaxThumbnailWidth  = 120;
static int c_nMaxThumbnailHeight = 120;

CCommonFirstPage::CCommonFirstPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_pControllerWindow(NULL),
    m_bThumbnailsRequested(false),
    m_hBigTitleFont(NULL),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE))
{
}

CCommonFirstPage::~CCommonFirstPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
}


LRESULT CCommonFirstPage::OnWizNext( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CCommonFirstPage::OnActivate( WPARAM wParam, LPARAM )
{
    //
    // We also update on activate messages, because we can't set
    // wizard buttons when we are not the active process
    //
    if (WA_INACTIVE != wParam)
    {
        HandleImageCountChange(true);
    }
    return 0;
}

void CCommonFirstPage::HandleImageCountChange( bool bUpdateWizButtons )
{
    //
    // How many items are available?
    //
    int nCount = m_pControllerWindow->m_WiaItemList.Count();

    //
    // Figure out which message and buttons to display
    //
    int nMessageResourceId = 0;
    int nButtons = 0;
    switch (m_pControllerWindow->m_DeviceTypeMode)
    {
    case CAcquisitionManagerControllerWindow::ScannerMode:
        nMessageResourceId = nCount ? IDS_FIRST_PAGE_INSTRUCTIONS_SCANNER : IDS_SCANNER_NO_IMAGES;
        nButtons = nCount ? PSWIZB_NEXT : 0;
        break;

    case CAcquisitionManagerControllerWindow::CameraMode:
        //
        // If we can take pictures, enable the next button and don't tell the user there are no images.
        //
        if (m_pControllerWindow->m_bTakePictureIsSupported)
        {
            nButtons = PSWIZB_NEXT;
            nMessageResourceId = IDS_FIRST_PAGE_INSTRUCTIONS_CAMERA;
        }
        else
        {
            nButtons = nCount ? PSWIZB_NEXT : 0;
            nMessageResourceId = nCount ? IDS_FIRST_PAGE_INSTRUCTIONS_CAMERA : IDS_CAMERA_NO_IMAGES;
        }
        break;

    case CAcquisitionManagerControllerWindow::VideoMode:
        nMessageResourceId = IDS_FIRST_PAGE_INSTRUCTIONS_VIDEO;
        nButtons = PSWIZB_NEXT;
        break;
    };

    //
    // Set the buttons
    //
    if (bUpdateWizButtons)
    {
        PropSheet_SetWizButtons( GetParent(m_hWnd), nButtons );
    }

    //
    // Set the message
    //
    CSimpleString( nMessageResourceId, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, IDC_FIRST_INSTRUCTIONS ) );
}

LRESULT CCommonFirstPage::OnSetActive( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CCommonFirstPage::OnSetActive"));
    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    HandleImageCountChange(true);
    
    //
    // We do want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectGotoLastpage|CAcquisitionManagerControllerWindow::OnDisconnectFailDownload|CAcquisitionManagerControllerWindow::OnDisconnectFailUpload|CAcquisitionManagerControllerWindow::OnDisconnectFailDelete;

    //
    // Get the focus off the hyperlink control
    //
    if (GetDlgItem( m_hWnd, IDC_CAMFIRST_EXPLORE ))
    {
        PostMessage( m_hWnd, WM_NEXTDLGCTL, 0, 0 );
    }

    return 0;
}


LRESULT CCommonFirstPage::OnShowWindow( WPARAM, LPARAM )
{
    if (!m_bThumbnailsRequested)
    {
        //
        // Request the thumbnails
        //
        m_pControllerWindow->DownloadAllThumbnails();

        //
        // Make sure we don't ask for the thumbnails again
        //
        m_bThumbnailsRequested = true;
    }

    return 0;
}


LRESULT CCommonFirstPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCommonFirstPage::OnInitDialog"));
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    //
    // Hide the explore camera link and label if this is one of those icky serial cameras or dv cameras
    //
    if (m_pControllerWindow->IsSerialCamera() || m_pControllerWindow->m_DeviceTypeMode==CAcquisitionManagerControllerWindow::VideoMode)
    {
        //
        // Hide the link
        //
        if (GetDlgItem( m_hWnd, IDC_CAMFIRST_EXPLORE ))
        {
            ShowWindow( GetDlgItem( m_hWnd, IDC_CAMFIRST_EXPLORE ), SW_HIDE );
            EnableWindow( GetDlgItem( m_hWnd, IDC_CAMFIRST_EXPLORE ), FALSE );
        }
    }

    //
    // Set the font size for the title and device name
    //
    m_hBigTitleFont = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem(m_hWnd,IDC_FIRST_TITLE), 14, false, false );
    if (m_hBigTitleFont)
    {
        SendDlgItemMessage( m_hWnd, IDC_FIRST_TITLE, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigTitleFont), MAKELPARAM(TRUE,0));
    }

    m_hBigDeviceFont = WiaUiUtil::ChangeFontFromWindow( GetDlgItem(m_hWnd,IDC_FIRST_DEVICE_NAME), 2 );
    if (m_hBigDeviceFont)
    {
        SendDlgItemMessage( m_hWnd, IDC_FIRST_DEVICE_NAME, WM_SETFONT, reinterpret_cast<WPARAM>(m_hBigDeviceFont), MAKELPARAM(TRUE,0));
    }


    WiaUiUtil::CenterWindow( GetParent(m_hWnd), NULL );

    //
    // Set the wizard's icon
    //
    if (m_pControllerWindow->m_hWizardIconSmall && m_pControllerWindow->m_hWizardIconBig)
    {
        SendMessage( GetParent(m_hWnd), WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(m_pControllerWindow->m_hWizardIconSmall) );
        SendMessage( GetParent(m_hWnd), WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(m_pControllerWindow->m_hWizardIconBig) );
    }

    //
    // Get the device name and truncate it to fit in the static control
    //
    CSimpleString strDeviceName = CSimpleStringConvert::NaturalString(m_pControllerWindow->m_strwDeviceName);
    strDeviceName = WiaUiUtil::FitTextInStaticWithEllipsis( strDeviceName, GetDlgItem( m_hWnd, IDC_FIRST_DEVICE_NAME ), DT_END_ELLIPSIS|DT_NOPREFIX );

    //
    // Set the text in the "device name" box
    //
    strDeviceName.SetWindowText( GetDlgItem( m_hWnd, IDC_FIRST_DEVICE_NAME ) );

    //
    // This only has to be done in one page.
    //
    m_pControllerWindow->SetMainWindowInSharedMemory( GetParent(m_hWnd) );

    //
    // If we have a parent window, center the wizard on it.
    //
    if (m_pControllerWindow->m_pEventParameters->hwndParent)
    {
        WiaUiUtil::CenterWindow( GetParent(m_hWnd), m_pControllerWindow->m_pEventParameters->hwndParent );
    }

    return 0;
}


LRESULT CCommonFirstPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCommonFirstPage::OnEventNotification"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED || pEventMessage->EventId() == WIA_EVENT_ITEM_DELETED)
        {
            //
            // Only update controls if we are the active page
            //
            if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
            {
                //
                // Because of some weirdness in prsht.c when calling PSM_SETWIZBUTTONS,
                // we only want to call PSM_SETWIZBUTTONS when we are the foreground app,
                // so I try to figure out if our process owns the foreground window.
                // Assume we won't be updating the buttons
                //
                bool bUpdateWizButtons = false;

                //
                // Get the foreground window
                //
                HWND hForegroundWnd = GetForegroundWindow();
                if (hForegroundWnd)
                {
                    //
                    // Get the process id of the foreground window.  If it is the
                    // same process ID as ours, we will update the wizard buttons
                    //
                    DWORD dwProcessId = 0;
                    GetWindowThreadProcessId(hForegroundWnd,&dwProcessId);
                    if (dwProcessId == GetCurrentProcessId())
                    {
                        bUpdateWizButtons = true;
                    }
                }

                //
                // Update the controls
                //
                HandleImageCountChange(bUpdateWizButtons);
            }
        }
        
        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}


LRESULT CCommonFirstPage::OnDestroy( WPARAM, LPARAM )
{
    if (m_hBigTitleFont)
    {
        DeleteObject(m_hBigTitleFont);
        m_hBigTitleFont = NULL;
    }
    if (m_hBigDeviceFont)
    {
        DeleteObject(m_hBigDeviceFont);
        m_hBigDeviceFont = NULL;
    }
    return 0;
}


LRESULT CCommonFirstPage::OnHyperlinkClick( WPARAM, LPARAM lParam )
{
    LRESULT lResult = FALSE;
    NMLINK *pNmLink = reinterpret_cast<NMLINK*>(lParam);
    if (pNmLink)
    {
        CWaitCursor wc;
        HRESULT hr = E_FAIL;
        CSimpleStringWide strwShellLocation;
        if (PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPF_MOUNT_POINT, strwShellLocation ))
        {
            CSimpleString strShellLocation = CSimpleStringConvert::NaturalString(strwShellLocation);
            if (strShellLocation.Length())
            {
                SHELLEXECUTEINFO ShellExecuteInfo = {0};
                ShellExecuteInfo.cbSize = sizeof(ShellExecuteInfo);
                ShellExecuteInfo.hwnd = m_hWnd;
                ShellExecuteInfo.nShow = SW_SHOW;
                ShellExecuteInfo.lpVerb = TEXT("open");
                ShellExecuteInfo.lpFile = const_cast<LPTSTR>(strShellLocation.String());
                if (ShellExecuteEx( &ShellExecuteInfo ))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    WIA_PRINTHRESULT((hr,TEXT("ShellExecuteEx failed")));
                }
            }
        }
        else if (PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DIP_DEV_ID, strwShellLocation ) && strwShellLocation.Length())
        {
            hr = WiaUiUtil::ExploreWiaDevice(strwShellLocation);
        }
        if (!SUCCEEDED(hr))
        {
            MessageBox( m_hWnd, CSimpleString( IDS_UNABLE_OPEN_EXPLORER, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), MB_ICONHAND );
        }
    }
    return lResult;
}

LRESULT CCommonFirstPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(NM_RETURN,IDC_CAMFIRST_EXPLORE,OnHyperlinkClick);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(NM_CLICK,IDC_CAMFIRST_EXPLORE,OnHyperlinkClick);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCommonFirstPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCommonFirstPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_SHOWWINDOW, OnShowWindow );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_ACTIVATE, OnActivate );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nWiaEventMessage, OnEventNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comprog.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMPROG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Download page.  Displays the thumbnail and download progress.
 *
 *******************************************************************************/
#ifndef __COMPROG_H_INCLUDED
#define __COMPROG_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "gphelper.h"

class CCommonProgressPage
{
private:
    // Private data
    HWND                                 m_hWnd;
    CAcquisitionManagerControllerWindow *m_pControllerWindow;
    int                                  m_nPictureCount;
    HANDLE                               m_hCancelDownloadEvent;
    CGdiPlusHelper                       m_GdiPlusHelper;
    UINT                                 m_nThreadNotificationMessage;
    UINT                                 m_nWiaEventMessage;
    HPROPSHEETPAGE                       m_hSwitchToNextPage;
    bool                                 m_bQueryingUser;

private:
    // No implementation
    CCommonProgressPage(void);
    CCommonProgressPage( const CCommonProgressPage & );
    CCommonProgressPage &operator=( const CCommonProgressPage & );

private:
    // Constructor and destructor
    explicit CCommonProgressPage( HWND hWnd );
    ~CCommonProgressPage(void);

private:
    // Helpers
    void UpdatePercentComplete( int nPercent, bool bUploading );
    void UpdateCurrentPicture( int nPicture );
    void UpdateThumbnail( HBITMAP hBitmap, CWiaItem *pWiaItem );
    bool QueryCancel(void);

private:
    // WM_COMMAND handlers

    // Thread Message handlers
    void OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    void OnNotifyDownloadError( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );

    // WM_NOTIFY handlers
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnKillActive( WPARAM, LPARAM );
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnReset( WPARAM, LPARAM );
    LRESULT OnQueryCancel( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );
    LRESULT OnEventNotification( WPARAM, LPARAM );
    LRESULT OnQueryEndSession( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __COMPROG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comprog.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMPROG.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Download progress dialog.  Displays the thumbnail and download progress.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <commctrl.h>
#include "comprog.h"
#include "resource.h"
#include "pviewids.h"
#include "simcrack.h"
#include "gwiaevnt.h"
#include "mboxex.h"
#include "runnpwiz.h"

#define PWM_SETDEFBUTTON (WM_USER+1)

CCommonProgressPage::CCommonProgressPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_pControllerWindow(NULL),
    m_hCancelDownloadEvent(CreateEvent(NULL,TRUE,FALSE,TEXT(""))),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_hSwitchToNextPage(NULL),
    m_bQueryingUser(false)
{
}

CCommonProgressPage::~CCommonProgressPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
    if (m_hCancelDownloadEvent)
    {
        CloseHandle(m_hCancelDownloadEvent);
        m_hCancelDownloadEvent = NULL;
    }
}


void CCommonProgressPage::UpdatePercentComplete( int nPercent, bool bUploading )
{
    if (nPercent >= 0)
    {
        int nPercentStringResId;
        if (bUploading)
        {
            nPercentStringResId = IDS_PERCENT_COMPLETE_UPLOADING;
        }
        else
        {
            // Assume copying is the appropropriate description
            nPercentStringResId = IDS_PERCENT_COMPLETE_COPYING;
            switch (m_pControllerWindow->m_DeviceTypeMode)
            {
            case CAcquisitionManagerControllerWindow::ScannerMode:
                nPercentStringResId = IDS_PERCENT_COMPLETE_SCANNING;
                break;
            };
        }

        SendDlgItemMessage( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS, PBM_SETPOS, nPercent, 0 );
        CSimpleString().Format( nPercentStringResId, g_hInstance, nPercent ).SetWindowText( GetDlgItem( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS_TEXT ) );
    }
    else
    {
        SendDlgItemMessage( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS, PBM_SETPOS, 0, 0 );
        SendDlgItemMessage( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS_TEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>("") );
    }
}

void CCommonProgressPage::UpdateCurrentPicture( int nPicture )
{
    if (nPicture >= 0)
    {
        SendDlgItemMessage( m_hWnd, IDC_COMPROG_CURRENTIMAGE, PBM_SETPOS, nPicture, 0 );
        CSimpleString().Format( IDS_FILEN_OF_M, g_hInstance, nPicture+1, m_nPictureCount ).SetWindowText( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTIMAGE_TEXT ) );
    }
    else
    {
        SendDlgItemMessage( m_hWnd, IDC_COMPROG_CURRENTIMAGE, PBM_SETPOS, 0, 0 );
        SendDlgItemMessage( m_hWnd, IDC_COMPROG_CURRENTIMAGE_TEXT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>("") );
    }
}

void CCommonProgressPage::UpdateThumbnail( HBITMAP hBitmap, CWiaItem *pWiaItem )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonProgressPage::UpdateThumbnail( HBITMAP hBitmap=0x%08X, CWiaItem *pWiaItem=0x%08X )"), hBitmap, pWiaItem ));


    HWND hWndPreview = GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL );
    if (hWndPreview)
    {
        if (pWiaItem && m_pControllerWindow && hBitmap)
        {
            switch (m_pControllerWindow->m_DeviceTypeMode)
            {
            case CAcquisitionManagerControllerWindow::ScannerMode:
                {
                    //
                    // If the item has a bitmap image, it already has a preview scan available
                    //
                    WIA_TRACE((TEXT("pWiaItem->BitmapImage() = %08X"), pWiaItem->BitmapImage() ));
                    if (pWiaItem->BitmapImage())
                    {
                        //
                        // Hide the preview window while we are futzing with it
                        //
                        ShowWindow( hWndPreview, SW_HIDE );

                        //
                        // Crop the image to the selected region
                        //
                        WiaPreviewControl_SetResolution( hWndPreview, &pWiaItem->ScanRegionSettings().sizeResolution );
                        WiaPreviewControl_SetSelOrigin( hWndPreview, 0, FALSE, &pWiaItem->ScanRegionSettings().ptOrigin );
                        WiaPreviewControl_SetSelExtent( hWndPreview, 0, FALSE, &pWiaItem->ScanRegionSettings().sizeExtent );

                        //
                        // Set the control to preview mode
                        //
                        WiaPreviewControl_SetPreviewMode( hWndPreview, TRUE );

                        //
                        // If this is a scanner item, we don't want to let the preview control take ownership of the bitmap.
                        // We don't want it to be deleted
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, hBitmap );

                        //
                        // Show the preview window
                        //
                        ShowWindow( hWndPreview, SW_SHOW );
                    }
                    else
                    {
                        //
                        // This means we are getting a preview image from the driver
                        // We don't want to delete this image
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, hBitmap );

                        //
                        // Make sure the window is visible
                        //
                        ShowWindow( hWndPreview, SW_SHOW );
                    }
                }
                break;

            default:
                {
                    //
                    // Go ahead and rotate the bitmap, even if it isn't necessary.
                    //
                    HBITMAP hRotatedThumbnail = NULL;
                    if (SUCCEEDED(m_GdiPlusHelper.Rotate( hBitmap, hRotatedThumbnail, pWiaItem->Rotation())))
                    {
                        //
                        // Set it to the rotated bitmap, and ALLOW this bitmap to be deleted
                        //
                        WiaPreviewControl_SetBitmap( hWndPreview, TRUE, FALSE, hRotatedThumbnail );
                    }

                    //
                    // Make sure the window is visible
                    //
                    ShowWindow( hWndPreview, SW_SHOW );

                    //
                    // Delete the source bitmap
                    //
                    DeleteObject(hBitmap);
                }
            }
        }
        else
        {
            ShowWindow( hWndPreview, SW_HIDE );
            WiaPreviewControl_SetBitmap( hWndPreview, TRUE, TRUE, NULL );
        }
    }
}


LRESULT CCommonProgressPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }


    //
    // Prepare the preview control
    //
    HWND hWndThumbnail = GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL );
    if (hWndThumbnail)
    {
        //
        // We only want to set the preview mode for scanners
        //
        if (CAcquisitionManagerControllerWindow::ScannerMode==m_pControllerWindow->m_DeviceTypeMode)
        {
            WiaPreviewControl_SetPreviewMode( hWndThumbnail, TRUE );
        }
        else
        {
            WiaPreviewControl_AllowNullSelection( hWndThumbnail, TRUE );
            WiaPreviewControl_ClearSelection( hWndThumbnail );
        }
        WiaPreviewControl_SetBgAlpha( hWndThumbnail, FALSE, 0xFF );
        WiaPreviewControl_DisableSelection( hWndThumbnail, TRUE );
        WiaPreviewControl_SetEnableStretch( hWndThumbnail, FALSE );
        WiaPreviewControl_SetBkColor( hWndThumbnail, FALSE, TRUE, GetSysColor(COLOR_WINDOW) );
        WiaPreviewControl_HideEmptyPreview( hWndThumbnail, TRUE );
        WiaPreviewControl_SetPreviewAlignment( hWndThumbnail, PREVIEW_WINDOW_CENTER, PREVIEW_WINDOW_CENTER, FALSE );

    }

    return 0;
}

void CCommonProgressPage::OnNotifyDownloadError( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonProgressPage::OnNotifyDownloadError")));
    CDownloadErrorNotificationMessage *pDownloadErrorNotificationMessage = dynamic_cast<CDownloadErrorNotificationMessage*>(pThreadNotificationMessage);
    if (pDownloadErrorNotificationMessage && m_pControllerWindow)
    {
        pDownloadErrorNotificationMessage->Handled();
        if (m_pControllerWindow->m_bDisconnected)
        {
            pDownloadErrorNotificationMessage->Response( IDCANCEL );
        }
        else
        {
            WIA_TRACE((TEXT("MessageBox flags: %08X"), pDownloadErrorNotificationMessage->MessageBoxFlags() ));
            int nResponse = CMessageBoxEx::MessageBox( m_hWnd, pDownloadErrorNotificationMessage->Message(), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), pDownloadErrorNotificationMessage->MessageBoxFlags() );
            pDownloadErrorNotificationMessage->Response( nResponse );
        }
    }
}

void CCommonProgressPage::OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    WIA_PUSHFUNCTION(TEXT("CCommonProgressPage::OnNotifyDownloadImage"));
    CDownloadImagesThreadNotifyMessage *pDownloadImageThreadNotifyMessage = dynamic_cast<CDownloadImagesThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadImageThreadNotifyMessage && m_pControllerWindow)
    {
        switch (pDownloadImageThreadNotifyMessage->Status())
        {
        case CDownloadImagesThreadNotifyMessage::Begin:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        //
                        // Store the number of images we'll be downloading
                        //
                        m_nPictureCount = pDownloadImageThreadNotifyMessage->PictureCount();

                        //
                        // Show the current picture controls if there are multiple pictures being downloaded
                        //
                        if (m_nPictureCount > 1)
                        {
                            ShowWindow( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTIMAGE_TEXT ), SW_SHOW );
                            ShowWindow( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTIMAGE ), SW_SHOW );
                        }

                        //
                        // Initialize current image count progress bar
                        //
                        SendDlgItemMessage( m_hWnd, IDC_COMPROG_CURRENTIMAGE, PBM_SETRANGE32, 0, m_nPictureCount);
                        UpdateCurrentPicture(0);

                        //
                        // Enable the file download progress controls
                        //
                        EnableWindow( GetDlgItem( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS_TEXT ), TRUE );
                        EnableWindow( GetDlgItem( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS ), TRUE );

                        //
                        // Initialize download progress bar
                        //
                        SendDlgItemMessage( m_hWnd, IDC_COMPROG_DOWNLOADPROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0,100));
                        UpdatePercentComplete(0,false);
                    }
                    break;

                case CDownloadImagesThreadNotifyMessage::DownloadImage:
                    {
                        //
                        // Display thumbnail
                        //
                        HBITMAP hBitmapThumbnail = NULL;
                        CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadImageThreadNotifyMessage->Cookie() );
                        if (pWiaItem)
                        {
                            //
                            // This will only work if it is a scanner item
                            //
                            hBitmapThumbnail = pWiaItem->BitmapImage();
                            if (!hBitmapThumbnail)
                            {
                                //
                                // Since it didn't work, this is a camera item, so create a thumbnail.
                                // We have to make sure we nuke this bitmap or it is a leak!
                                //
                                HDC hDC = GetDC(NULL);
                                if (hDC)
                                {
                                    hBitmapThumbnail = pWiaItem->CreateThumbnailBitmap(hDC);
                                    ReleaseDC( NULL, hDC );
                                }
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("Unable to find the item with the cookie %08X"), pDownloadImageThreadNotifyMessage->Cookie() ));
                        }

                        //
                        // Update the thumbnail in the progress window
                        //
                        UpdateThumbnail( hBitmapThumbnail, pWiaItem );

                        //
                        // Increment file queue progress
                        //
                        UpdateCurrentPicture(pDownloadImageThreadNotifyMessage->CurrentPicture());

                        //
                        // Clear file download progress
                        //
                        UpdatePercentComplete(0,false);

                        //
                        // Display the filename we are downloading
                        //
                        TCHAR szFileTitle[MAX_PATH] = TEXT("");
                        GetFileTitle( pDownloadImageThreadNotifyMessage->Filename(), szFileTitle, ARRAYSIZE(szFileTitle) );
                        SetDlgItemText( m_hWnd, IDC_COMPROG_IMAGENAME, szFileTitle );
                    }
                    break;

                case CDownloadImagesThreadNotifyMessage::PreviewImage:
                    {
                        CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadImageThreadNotifyMessage->Cookie() );
                        if (pWiaItem && !pWiaItem->BitmapImage() && !pWiaItem->BitmapData())
                        {
                            UpdateThumbnail( pDownloadImageThreadNotifyMessage->PreviewBitmap(), pWiaItem );
                        }
                    }
                    break;
                }
            }
            break;

        case CDownloadImagesThreadNotifyMessage::Update:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadImage:
                    {
                        //
                        // Update file download progress
                        //
                        UpdatePercentComplete(pDownloadImageThreadNotifyMessage->PercentComplete(),false);
                    }
                    break;
                case CDownloadImagesThreadNotifyMessage::PreviewImage:
                    {
                        CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadImageThreadNotifyMessage->Cookie() );
                        if (pWiaItem && !pWiaItem->BitmapImage() && !pWiaItem->BitmapData())
                        {
                            WiaPreviewControl_RefreshBitmap( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ) );
                        }
                    }
                    break;
                }
            }
            break;

        case CDownloadImagesThreadNotifyMessage::End:
            switch (pDownloadImageThreadNotifyMessage->Operation())
            {
            case CDownloadImagesThreadNotifyMessage::DownloadImage:
                {
                    if (!SUCCEEDED(pDownloadImageThreadNotifyMessage->hr()))
                    {
                        //
                        // Clear the thumbnail in the progress window
                        //
                        UpdateThumbnail( NULL, NULL );
                        
                        //
                        // Clear file download progress
                        //
                        UpdatePercentComplete(0,false);

                        //
                        // Increment file queue progress
                        //
                        UpdateCurrentPicture(pDownloadImageThreadNotifyMessage->CurrentPicture());

                        //
                        // Clear the filename
                        //
                        SetDlgItemText( m_hWnd, IDC_COMPROG_IMAGENAME, TEXT("") );
                    }
                    else
                    {
                        //
                        // Update file download progress
                        //
                        UpdatePercentComplete(100,false);
                    }
                }
                break;

            case CDownloadImagesThreadNotifyMessage::DownloadAll:
                {
                    //
                    // Clear the filename when we are all done
                    //
                    SetDlgItemText( m_hWnd, IDC_COMPROG_IMAGENAME, TEXT("") );
                    
                    CSimpleString strMessage;

                    if (FAILED(pDownloadImageThreadNotifyMessage->hr()))
                    {
                        WIA_PRINTHRESULT((pDownloadImageThreadNotifyMessage->hr(),TEXT("CDownloadImagesThreadNotifyMessage::DownloadAll (%s)"), pDownloadImageThreadNotifyMessage->ExtendedErrorInformation().String()));
                        
                        //
                        // If we already have a good error message, let's use it
                        //
                        if (pDownloadImageThreadNotifyMessage->ExtendedErrorInformation().Length())
                        {
                            strMessage = pDownloadImageThreadNotifyMessage->ExtendedErrorInformation();
                        }
                        else
                        {
                            //
                            // If we haven't already created a good error message, and we think we can here, let's do it
                            //
                            switch (pDownloadImageThreadNotifyMessage->hr())
                            {
                            case HRESULT_FROM_WIN32(ERROR_DISK_FULL):
                                strMessage.LoadString( IDS_DISKFULL, g_hInstance );
                                break;

                            case HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE):
                                strMessage.LoadString( IDS_UNABLETOTRANSFER, g_hInstance );
                                break;

                            case WIA_ERROR_PAPER_JAM:
                                strMessage.LoadString( IDS_WIA_ERROR_PAPER_JAM, g_hInstance );
                                break;

                            case WIA_ERROR_PAPER_EMPTY:
                                strMessage.LoadString( IDS_WIA_ERROR_PAPER_EMPTY, g_hInstance );
                                break;

                            case WIA_ERROR_PAPER_PROBLEM:
                                strMessage.LoadString( IDS_WIA_ERROR_PAPER_PROBLEM, g_hInstance );
                                break;

                            case WIA_ERROR_OFFLINE:
                                strMessage.LoadString( IDS_WIA_ERROR_OFFLINE, g_hInstance );
                                break;

                            case WIA_ERROR_BUSY:
                                strMessage.LoadString( IDS_WIA_ERROR_BUSY, g_hInstance );
                                break;

                            case WIA_ERROR_WARMING_UP:
                                strMessage.LoadString( IDS_WIA_ERROR_WARMING_UP, g_hInstance );
                                break;

                            case WIA_ERROR_USER_INTERVENTION:
                                strMessage.LoadString( IDS_WIA_ERROR_USER_INTERVENTION, g_hInstance );
                                break;

                            case WIA_ERROR_ITEM_DELETED:
                                strMessage.LoadString( IDS_WIA_ERROR_ITEM_DELETED, g_hInstance );
                                break;

                            case WIA_ERROR_DEVICE_COMMUNICATION:
                                strMessage.LoadString( IDS_WIA_ERROR_DEVICE_COMMUNICATION, g_hInstance );
                                break;

                            case WIA_ERROR_INVALID_COMMAND:
                                strMessage.LoadString( IDS_WIA_ERROR_INVALID_COMMAND, g_hInstance );
                                break;

                            case WIA_ERROR_INCORRECT_HARDWARE_SETTING:
                                strMessage.LoadString( IDS_WIA_ERROR_INCORRECT_HARDWARE_SETTING, g_hInstance );
                                break;

                            case WIA_ERROR_DEVICE_LOCKED:
                                strMessage.LoadString( IDS_WIA_ERROR_DEVICE_LOCKED, g_hInstance );
                                break;

                            default:
                                strMessage = WiaUiUtil::GetErrorTextFromHResult(pDownloadImageThreadNotifyMessage->hr());
                                if (!strMessage.Length())
                                {
                                    strMessage.Format( CSimpleString( IDS_TRANSFER_ERROR_OCCURRED, g_hInstance ), pDownloadImageThreadNotifyMessage->hr() );
                                }
                                break;
                            }
                        }
                        WIA_TRACE((TEXT("strMessage: (%s)"), strMessage.String()));

                        //
                        // Tell the user something bad happened.  Save the error message.
                        //
                        m_pControllerWindow->m_strErrorMessage = strMessage;
                    }

                    //
                    // Save the hresult
                    //
                    m_pControllerWindow->m_hrDownloadResult = pDownloadImageThreadNotifyMessage->hr();

                    //
                    // Just to be sure we catch cancels
                    //
                    if (S_FALSE == m_pControllerWindow->m_hrDownloadResult)
                    {
                        m_pControllerWindow->m_bDownloadCancelled = true;
                    }

                    //
                    // Continue downloading thumbnails, in case it was paused
                    //
                    m_pControllerWindow->DownloadAllThumbnails();

                    //
                    // Go to the next page.  Assume it will be the upload query page.
                    //
                    HPROPSHEETPAGE hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nFinishPageIndex );

                    //
                    // If the transfer was successful
                    //
                    if (!m_pControllerWindow->m_bDownloadCancelled && S_OK==m_pControllerWindow->m_hrDownloadResult)
                    {
                        //
                        // If we are deleting from the device, send us to the delete progress page
                        //
                        if (m_pControllerWindow->m_bDeletePicturesIfSuccessful)
                        {
                            hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nDeleteProgressPageIndex );
                        }

                        //
                        // Otherwise, go to the upload query page
                        //
                        else
                        {
                            hNextPage = PropSheet_IndexToPage( GetParent(m_hWnd), m_pControllerWindow->m_nUploadQueryPageIndex );
                        }
                    }

                    //
                    // If there is a message box active, save this page till the message box is dismissed
                    //
                    if (m_bQueryingUser)
                    {
                        m_hSwitchToNextPage = hNextPage;
                    }
                    else
                    {
                        //
                        // Set the next page
                        //
                        PropSheet_SetCurSel( GetParent(m_hWnd), hNextPage, -1 );
                    }

                }
                break;

            case CDownloadImagesThreadNotifyMessage::PreviewImage:
                {
                    CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pDownloadImageThreadNotifyMessage->Cookie() );
                    UpdateThumbnail( NULL, pWiaItem );
                }
                break;
            }
        }
    }
}

LRESULT CCommonProgressPage::OnSetActive( WPARAM, LPARAM )
{
    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    //
    // Initialize the download error message
    //
    m_pControllerWindow->m_strErrorMessage = TEXT("");

    //
    // Initialize the download result
    //
    m_pControllerWindow->m_hrDownloadResult = S_OK;

    //
    // Initialize upload result to S_OK
    //
    m_pControllerWindow->m_hrUploadResult = S_OK;

    //
    // Initialize delete result to E_FAIL
    //
    m_pControllerWindow->m_hrDeleteResult = E_FAIL;

    //
    // Reset the cancelled flag
    //
    m_pControllerWindow->m_bDownloadCancelled = false;

    //
    // Clear the downloaded file list
    //
    m_pControllerWindow->m_DownloadedFileInformationList.Destroy();

    //
    // Clear all of the controls
    //
    UpdatePercentComplete(-1,false);
    UpdateCurrentPicture(-1);
    UpdateThumbnail(NULL,NULL);

    //
    // Reset the selected region, in case this is a scanner
    //
    WiaPreviewControl_SetResolution( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), NULL );
    WiaPreviewControl_SetSelOrigin( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), 0, FALSE, NULL );
    WiaPreviewControl_SetSelExtent( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), 0, FALSE, NULL );

    //
    // Set the control to preview mode
    //
    WiaPreviewControl_SetPreviewMode( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), TRUE );

    //
    // Reset the download event cancel
    //
    if (m_hCancelDownloadEvent)
    {
        ResetEvent(m_hCancelDownloadEvent);
    }

    //
    // Cancel thumbnail downloading
    //
    m_pControllerWindow->m_EventThumbnailCancel.Signal();


    //
    //  Start the download
    //
    if (!m_pControllerWindow->DownloadSelectedImages(m_hCancelDownloadEvent))
    {
        WIA_ERROR((TEXT("m_pControllerWindow->DownloadSelectedImages FAILED!")));
        MessageBox( m_hWnd, CSimpleString( IDS_UNABLETOTRANSFER, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), MB_ICONHAND );
        return -1;
    }

    //
    // Tell the user where the pictures are going
    //
    CSimpleString strDestinationDisplayName = m_pControllerWindow->m_CurrentDownloadDestination.DisplayName(m_pControllerWindow->m_DestinationNameData);
    strDestinationDisplayName.SetWindowText( GetDlgItem( m_hWnd, IDC_COMPROG_DESTNAME) );
    SendDlgItemMessage( m_hWnd, IDC_COMPROG_DESTNAME, EM_SETSEL, strDestinationDisplayName.Length(), strDestinationDisplayName.Length() );
    SendDlgItemMessage( m_hWnd, IDC_COMPROG_DESTNAME, EM_SCROLLCARET, 0, 0 );

    //
    // Hide the current image controls in case there is only one image
    //
    ShowWindow( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTIMAGE_TEXT ), SW_HIDE );
    ShowWindow( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTIMAGE ), SW_HIDE );

    //
    // No next, back or finish
    //
    PropSheet_SetWizButtons( GetParent(m_hWnd), 0 );

    //
    // We do want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectGotoLastpage|CAcquisitionManagerControllerWindow::OnDisconnectFailDownload|CAcquisitionManagerControllerWindow::OnDisconnectFailUpload|CAcquisitionManagerControllerWindow::OnDisconnectFailDelete|CAcquisitionManagerControllerWindow::DontAllowSuspend;

    return 0;
}


LRESULT CCommonProgressPage::OnWizNext( WPARAM, LPARAM )
{
    return 0;
}


LRESULT CCommonProgressPage::OnWizBack( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CCommonProgressPage::OnReset( WPARAM, LPARAM )
{
    //
    // Cancel the current download
    //
    if (m_hCancelDownloadEvent)
    {
        SetEvent(m_hCancelDownloadEvent);
    }
    return 0;
}

LRESULT CCommonProgressPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CCommonFirstPage::OnEventNotification"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}

bool CCommonProgressPage::QueryCancel(void)
{
    //
    //  Make sure this is the current page
    //
    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) != m_hWnd)
    {
        return true;
    }

    //
    // Pause the background thread
    //
    m_pControllerWindow->m_EventPauseBackgroundThread.Reset();

    //
    // Assume the user doesn't want to cancel
    //
    bool bResult = false;

    //
    // Set the querying user flag so the event handler won't change pages
    //
    m_bQueryingUser = true;

    //
    // We may be called on to switch pages when we are done here.  If so, this will be non-NULL then.
    //
    m_hSwitchToNextPage = NULL;

    //
    // Don't ask again if we've already asked
    //
    if (!m_pControllerWindow->m_bDownloadCancelled)
    {
        //
        // Ask the user if they want to cancel
        //
        if (CMessageBoxEx::IDMBEX_YES == CMessageBoxEx::MessageBox( m_hWnd, CSimpleString(IDS_CONFIRM_CANCEL_DOWNLOAD,g_hInstance), CSimpleString(IDS_ERROR_TITLE,g_hInstance), CMessageBoxEx::MBEX_YESNO|CMessageBoxEx::MBEX_ICONQUESTION ))
        {
            //
            // The user does want to cancel, so set the cancel event, set the cancel flag and return false
            //
            m_pControllerWindow->m_bDownloadCancelled = true;

            //
            // Tell the device to cancel the current operation
            //
            WiaUiUtil::IssueWiaCancelIO(m_pControllerWindow->m_pWiaItemRoot);
            
            //
            // Make sure the cancel button is disabled
            //
            EnableWindow( GetDlgItem( GetParent(m_hWnd), IDCANCEL ), FALSE );

            //
            // Set the event that tells the background thread to stop transferring images
            //
            if (m_hCancelDownloadEvent)
            {
                SetEvent(m_hCancelDownloadEvent);
            }

            //
            // Return true to indicate we are cancelling
            //
            bResult = true;
        }
    }

    //
    // If we are supposed to switch pages, switch now
    //
    if (m_hSwitchToNextPage)
    {
        PropSheet_SetCurSel( GetParent(m_hWnd), m_hSwitchToNextPage, -1 );
    }

    //
    // Reset the querying user flag so the event handler can change pages as needed
    //
    m_bQueryingUser = false;

    //
    // Unpause the background thread
    //
    m_pControllerWindow->m_EventPauseBackgroundThread.Signal();

    return bResult;
}

LRESULT CCommonProgressPage::OnQueryCancel( WPARAM, LPARAM )
{
    //
    // The user is not allowed to cancel out of this page
    //
    BOOL bResult = TRUE;

    //
    // Since we don't let them cancel in this page, just ignore the result
    //
    QueryCancel();


    return bResult;
}


LRESULT CCommonProgressPage::OnKillActive( WPARAM, LPARAM )
{
    //
    // If we cancelled, make sure we delete any already downloaded files here.
    //
    if (m_pControllerWindow->m_bDownloadCancelled)
    {
        m_pControllerWindow->m_DownloadedFileInformationList.DeleteAllFiles();
    }

    //
    // Make sure the cancel button is enabled
    //
    EnableWindow( GetDlgItem( GetParent(m_hWnd), IDCANCEL ), TRUE );

    return 0;
}


LRESULT CCommonProgressPage::OnQueryEndSession( WPARAM, LPARAM )
{
    bool bCancel = QueryCancel();
    if (bCancel)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

LRESULT CCommonProgressPage::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_COMPROG_CURRENTTHUMBNAIL ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    return 0;
}

LRESULT CCommonProgressPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CCommonProgressPage::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WTM_BEGIN_THREAD_NOTIFY_MESSAGE_HANDLERS()
    {
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_DOWNLOADIMAGE, OnNotifyDownloadImage );
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_DOWNLOADERROR, OnNotifyDownloadError );
    }
    WTM_END_THREAD_NOTIFY_MESSAGE_HANDLERS();
}

LRESULT CCommonProgressPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_KILLACTIVE,OnKillActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_RESET,OnReset);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_QUERYCANCEL,OnQueryCancel);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCommonProgressPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCommonProgressPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_QUERYENDSESSION, OnQueryEndSession );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nThreadNotificationMessage, OnThreadNotification );
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nWiaEventMessage, OnEventNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comtrans.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMTRANS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Transfer page.  Gets the destination path and filename.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <psutil.h>
#include "mboxex.h"
#include "comtrans.h"
#include "simcrack.h"
#include "waitcurs.h"
#include "resource.h"
#include "wiatextc.h"
#include "flnfile.h"
#include "itranhlp.h"
#include "itranspl.h"
#include "isuppfmt.h"
#include "wiadevdp.h"
#include "destdata.h"
#include "simrect.h"
#include "wiaffmt.h"

//
// We use this instead of GetSystemMetrics(SM_CXSMICON)/GetSystemMetrics(SM_CYSMICON) because
// large "small" icons wreak havoc with dialog layout
//
#define SMALL_ICON_SIZE 16

//
// Maximum length of the filename we allow
//
#define MAXIMUM_ALLOWED_FILENAME_LENGTH 64

//
// These are the formats we will put in the save as list
//
static const GUID *g_pSupportedOutputFormats[] =
{
    &WiaImgFmt_JPEG,
    &WiaImgFmt_BMP,
    &WiaImgFmt_TIFF,
    &WiaImgFmt_PNG
};

//
// Sole constructor
//
CCommonTransferPage::CCommonTransferPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_pControllerWindow(NULL),
    m_bUseSubdirectory(true),
    m_hFontBold(NULL)
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::CCommonTransferPage")));
}

//
// Destructor
//
CCommonTransferPage::~CCommonTransferPage(void)
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::~CCommonTransferPage")));
    m_hWnd = NULL;
    m_pControllerWindow = NULL;
    m_hFontBold = NULL;
}

LRESULT CCommonTransferPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnInitDialog")));
    //
    // Open the registry key where we store various things
    //
    CSimpleReg reg( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, false );

    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    //
    // Get the right color-depth flag for this display
    //
    int nImageListColorDepth = PrintScanUtil::CalculateImageListColorDepth();

    //
    // Set the path control's image list
    //
    HIMAGELIST hDestImageList = ImageList_Create( SMALL_ICON_SIZE, SMALL_ICON_SIZE, nImageListColorDepth|ILC_MASK, 30, 10 );
    if (hDestImageList)
    {
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(hDestImageList) );
    }


    //
    // Only create the file type image list if this control exists
    //
    if (GetDlgItem(m_hWnd,IDC_TRANSFER_IMAGETYPE))
    {
        //
        // Set the file type's image list
        //
        HIMAGELIST hFileTypeImageList = ImageList_Create( SMALL_ICON_SIZE, SMALL_ICON_SIZE, nImageListColorDepth|ILC_MASK, 3, 3 );
        if (hFileTypeImageList)
        {
            SendDlgItemMessage( m_hWnd, IDC_TRANSFER_IMAGETYPE, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(hFileTypeImageList) );
        }
    }


    //
    // Get the last selected type
    // Assume JPEG if nothing is defined
    //
    GUID guidResult;
    if (sizeof(GUID) == reg.QueryBin( REG_STR_LASTFORMAT, (PBYTE)&guidResult, sizeof(GUID) ))
    {
        m_guidLastSelectedType = guidResult;
    }
    else
    {
        m_guidLastSelectedType = WiaImgFmt_JPEG;
    }

    //
    // Add the file types if we are dealing with a scanner
    //
    if (m_pControllerWindow->m_DeviceTypeMode == CAcquisitionManagerControllerWindow::ScannerMode && m_pControllerWindow->m_pCurrentScannerItem)
    {
        PopulateSaveAsTypeList(m_pControllerWindow->m_pCurrentScannerItem->WiaItem());
    }


    //
    // Read the MRU lists from the registry
    //
    m_MruDirectory.Read( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REG_STR_DIRNAME_MRU );
    m_MruRootFilename.Read( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REG_STR_ROOTNAME_MRU );

    //
    // Make sure we have a default filename
    //
    if (m_MruRootFilename.Empty())
    {
        m_MruRootFilename.Add( CSimpleString( IDS_DEFAULT_BASE_NAME, g_hInstance ) );
    }

    //
    // Populate the rootname list
    //
    m_MruRootFilename.PopulateComboBox(GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ));
    
    //
    // Ensure the first item in the rootname combobox is selected
    //
    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_SETCURSEL, 0, 0 );

    //
    // Make sure we have My Pictures+topic in the list, even if it has fallen off the end
    //
    CDestinationData DestDataMyPicturesTopic( CSIDL_MYPICTURES, CDestinationData::APPEND_TOPIC_TO_PATH );
    if (m_MruDirectory.Find(DestDataMyPicturesTopic) == m_MruDirectory.End())
    {
        m_MruDirectory.Append(DestDataMyPicturesTopic);
    }

    //
    // Make sure we have My Pictures+date+topic in the list, even if it has fallen off the end
    //
    CDestinationData DestDataMyPicturesDateTopic( CSIDL_MYPICTURES, CDestinationData::APPEND_DATE_TO_PATH|CDestinationData::APPEND_TOPIC_TO_PATH );
    if (m_MruDirectory.Find(DestDataMyPicturesDateTopic) == m_MruDirectory.End())
    {
        m_MruDirectory.Append(DestDataMyPicturesDateTopic);
    }


    //
    // Make sure we have My Pictures+date in the list, even if it has fallen off the end
    //
    CDestinationData DestDataMyPicturesDate( CSIDL_MYPICTURES, CDestinationData::APPEND_DATE_TO_PATH );
    if (m_MruDirectory.Find(DestDataMyPicturesDate) == m_MruDirectory.End())
    {
        m_MruDirectory.Append(DestDataMyPicturesDate);
    }

    //
    // Make sure we have My Pictures in the list, even if it has fallen off the end
    //
    CDestinationData DestDataMyPictures( CSIDL_MYPICTURES );
    if (m_MruDirectory.Find(DestDataMyPictures) == m_MruDirectory.End())
    {
        m_MruDirectory.Append(DestDataMyPictures);
    }

    //
    // Make sure we have Common Pictures in the list, even if it has fallen off the end
    //
    CDestinationData DestDataCommonPicturesTopic( CSIDL_COMMON_PICTURES );
    if (m_MruDirectory.Find(DestDataCommonPicturesTopic) == m_MruDirectory.End())
    {
        m_MruDirectory.Append(DestDataCommonPicturesTopic);
    }

    bool bCdBurnerAvailable = false;

    //
    // Try to instantiate the CD burner helper interface
    //
    CComPtr<ICDBurn> pCDBurn;
    HRESULT hr = CoCreateInstance( CLSID_CDBurn, NULL, CLSCTX_SERVER, IID_ICDBurn, (void**)&pCDBurn );
    if (SUCCEEDED(hr))
    {
        //
        // Get the drive letter of the available CD burner
        //
        WCHAR szDriveLetter[MAX_PATH];
        hr = pCDBurn->GetRecorderDriveLetter( szDriveLetter, ARRAYSIZE(szDriveLetter) );
        if (S_OK == hr && lstrlenW(szDriveLetter))
        {
            //
            // Make sure we have CD Burning in the list, even if it has fallen off the end
            //
            CDestinationData DestDataCDBurningArea( CSIDL_CDBURN_AREA );
            WIA_TRACE((TEXT("Adding DestDataCDBurningArea (%s)"),CSimpleIdList().GetSpecialFolder(m_hWnd,CSIDL_CDBURN_AREA).Name().String()));
            if (m_MruDirectory.Find(DestDataCDBurningArea) == m_MruDirectory.End())
            {
                m_MruDirectory.Append(DestDataCDBurningArea);
            }
            bCdBurnerAvailable = true;
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("pCDBurn->GetRecorderDriveLetter failed")));
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("CoCreateInstance on CLSID_CDBurn failed")));
    }

    //
    // If there is no CD available, remove CD burner from the list
    //
    if (!bCdBurnerAvailable)
    {
        m_MruDirectory.Remove(CDestinationData( CSIDL_CDBURN_AREA ));
    }

    //
    // Populate the controls with the MRU data
    //
    PopulateDestinationList();
    
    //
    // Limit the length of the filename
    //
    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_LIMITTEXT, MAXIMUM_ALLOWED_FILENAME_LENGTH, 0 );

    //
    // Figure out where we are storing per-device-type data
    //
    LPTSTR pszStoreInSubDirectory, pszSubdirectoryDated;
    bool bDefaultUseSubdirectory;
    switch (m_pControllerWindow->m_DeviceTypeMode)
    {
    case CAcquisitionManagerControllerWindow::ScannerMode:
        //
        // Scanners
        //
        pszStoreInSubDirectory = REG_STR_STORE_IN_SUBDIRECTORY_SCANNER;
        pszSubdirectoryDated = REG_STR_SUBDIRECTORY_DATED_SCANNER;
        bDefaultUseSubdirectory = false;
        break;

    default:
        //
        // Cameras and video cameras
        //
        pszStoreInSubDirectory = REG_STR_STORE_IN_SUBDIRECTORY_CAMERA;
        pszSubdirectoryDated = REG_STR_SUBDIRECTORY_DATED_CAMERA;
        bDefaultUseSubdirectory = true;
        break;
    };

    UpdateDynamicPaths();

    //
    // Fix up the behavior of ComboBoxEx32s
    //
    WiaUiUtil::SubclassComboBoxEx( GetDlgItem( m_hWnd, IDC_TRANSFER_DESTINATION ) );
    WiaUiUtil::SubclassComboBoxEx( GetDlgItem( m_hWnd, IDC_TRANSFER_IMAGETYPE ) );

    //
    // Bold the number prompts
    //
    m_hFontBold = WiaUiUtil::CreateFontWithPointSizeFromWindow( GetDlgItem( m_hWnd, IDC_TRANSFER_1 ), 0, true, false );
    if (m_hFontBold)
    {
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_1, WM_SETFONT, reinterpret_cast<WPARAM>(m_hFontBold), FALSE );
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_2, WM_SETFONT, reinterpret_cast<WPARAM>(m_hFontBold), FALSE );
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_3, WM_SETFONT, reinterpret_cast<WPARAM>(m_hFontBold), FALSE );
    }

    //
    // Use the nifty balloon help to warn the user about invalid characters
    //
    CComPtr<IShellFolder> pShellFolder;
    hr = SHGetDesktopFolder( &pShellFolder );
    if (SUCCEEDED(hr))
    {
        SHLimitInputCombo( GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ), pShellFolder );
    }

    return 0;
}

//
// Validate a pathname and print a message if it is invalid
//
bool CCommonTransferPage::ValidatePathname( LPCTSTR pszPath )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::ValidatePathname")));
    //
    // Check if the path is valid
    //
    if (!CAcquisitionManagerControllerWindow::DirectoryExists(pszPath))
    {
        //
        // Get the reason why it was invalid
        //
        DWORD dwLastError = GetLastError();
        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(dwLastError),TEXT("error from DirectoryExists")));

        if (!CAcquisitionManagerControllerWindow::DirectoryExists(pszPath))
        {
            //
            // If it isn't valid, display a message box explaining why not
            //
            bool bRetry;
            switch (dwLastError)
            {
            case ERROR_NOT_READY:
                {
                    bRetry = (CMessageBoxEx::IDMBEX_OK == CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format( IDS_REPLACE_REMOVEABLE_MEDIA, g_hInstance, pszPath ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OKCANCEL|CMessageBoxEx::MBEX_ICONWARNING ));
                }
                break;

            default:
                {
                    bRetry = (CMessageBoxEx::IDMBEX_YES == CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format( IDS_COMTRANS_BAD_DIRECTORY, g_hInstance, pszPath ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_YESNO|CMessageBoxEx::MBEX_ICONQUESTION ));
                }
                break;
            }

            if (bRetry)
            {
                //
                // Try to create the directory
                //
                CAcquisitionManagerControllerWindow::RecursiveCreateDirectory( pszPath );

                //
                // Check now if it exists
                //
                if (!CAcquisitionManagerControllerWindow::DirectoryExists(pszPath))
                {
                    //
                    // If it doesn't, give up
                    //
                    CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format( IDS_COMTRANS_BAD_DIRECTORY_2ND_TRY, g_hInstance, pszPath ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );
                    return false;
                }
            }
            else return false;
        }
    }
    return true;
}

bool CCommonTransferPage::StorePathAndFilename(void)
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::StorePathAndFilename")));
    bool bResult = true;
    //
    // Get the base file name
    //
    CSimpleString strRootName;
    strRootName.GetWindowText( GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ) );

    //
    // Store the base name
    //
    lstrcpyn( m_pControllerWindow->m_szRootFileName, strRootName, ARRAYSIZE(m_pControllerWindow->m_szRootFileName) );

    //
    // Store the currently selected path
    //
    GetCurrentDestinationFolder( true );

    return bResult;
}


//
// We return an HWND in case of error, and the property sheet code will set the focus
// to that control.  If nothing bad happens, return NULL
//
HWND CCommonTransferPage::ValidatePathAndFilename(void)
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::ValidatePathAndFilename")));
    //
    // Get the base file name
    //
    CSimpleString strRootName;
    strRootName.GetWindowText( GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ) );
    strRootName.Trim();

    //
    // Get the default base name if none was entered
    //
    if (!strRootName.Length())
    {
        //
        // Display a message box to the user telling them their lovely filename is invalid,
        // then set the focus on the combobox edit control and select the text in the control
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_EMPTYFILENAME, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );

        //
        // Return the window handle of the invalid control
        //
        return GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME );
    }

    if (ValidateFilename(strRootName))
    {
        //
        // Store the base name
        //
        lstrcpyn( m_pControllerWindow->m_szRootFileName, strRootName, ARRAYSIZE(m_pControllerWindow->m_szRootFileName) );

        //
        // Add this base filename to the filename MRU
        //
        m_MruRootFilename.Add(strRootName);

        //
        // If the string is already in the list, remove it
        //
        LRESULT lRes = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_FINDSTRINGEXACT, -1, reinterpret_cast<LPARAM>(strRootName.String() ));
        if (lRes != CB_ERR)
        {
            SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_DELETESTRING, lRes, 0 );
        }

        //
        // Add the new string and make sure it is selected.
        //
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_INSERTSTRING, 0, reinterpret_cast<LPARAM>(strRootName.String() ));
        SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_SETCURSEL, 0, 0 );

        //
        // Get the currently selected path, and save it for the output code
        //
        CDestinationData *pDestinationData = GetCurrentDestinationFolder( true );
        if (pDestinationData)
        {
            //
            // Validate path.  We don't validate special folders, because if they don't exist, we will create them.
            //
            if (!pDestinationData->IsSpecialFolder() && !ValidatePathname(m_pControllerWindow->m_szDestinationDirectory))
            {
                // Return the window handle of the invalid control
                return GetDlgItem( m_hWnd, IDC_TRANSFER_DESTINATION );
            }

            //
            // Save the current destination
            //
            m_pControllerWindow->m_CurrentDownloadDestination = *pDestinationData;
        }
        //
        // Make sure this is the first pDestinationData in the list next time
        // Store the destination MRU
        //
        if (pDestinationData)
        {
            m_MruDirectory.Add( *pDestinationData );
            PopulateDestinationList();
        }
    }
    else
    {
        //
        // Display a message box to the user telling them their lovely filename is invalid,
        // then set the focus on the combobox edit control and select the text in the control
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format( IDS_INVALIDFILENAME, g_hInstance, strRootName.String() ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );

        //
        // Return the window handle of the invalid control
        //
        return GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME );
    }
    //
    // NULL means OK
    //
    return NULL;
}


LRESULT CCommonTransferPage::OnWizNext( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnWizNext")));
    //
    // Make sure everything is OK.  If it isn't, return the offending window handle to prevent closing the wizard.
    //
    HWND hWndFocus = ValidatePathAndFilename();
    if (hWndFocus)
    {
        SetFocus(hWndFocus);
        return -1;
    }

    //
    // Make sure there are selected images
    //
    if (!m_pControllerWindow || !m_pControllerWindow->GetSelectedImageCount())
    {
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_NO_IMAGES_SELECTED, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONINFORMATION );
        return -1;
    }

    //
    // Check the length of the generated filename, in case they chose a really deeply nested directory
    //
    int nPathLength = lstrlen(m_pControllerWindow->m_szDestinationDirectory)            +  // Directory
                      lstrlen(m_pControllerWindow->m_szRootFileName)                    +  // Filename
                      CSimpleString().Format( IDS_NUMBER_MASK,g_hInstance, 0 ).Length() +  // Number
                      5                                                                 +  // Extension + dot
                      4                                                                 +  // .tmp file
                      10;                                                                  // Extra digits in number mask
    if (nPathLength >= MAX_PATH)
    {
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_PATH_TOO_LONG, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONINFORMATION );
        return reinterpret_cast<LRESULT>(GetDlgItem( m_hWnd, IDC_TRANSFER_DESTINATION ));
    }

    //
    // Store the information needed to do the download
    //
    GUID *pCurrFormat = GetCurrentOutputFormat();
    if (pCurrFormat)
    {
        m_pControllerWindow->m_guidOutputFormat = *pCurrFormat;
    }
    else
    {
        m_pControllerWindow->m_guidOutputFormat = IID_NULL;
    }

    //
    // Decide if we should delete the pictures after we download them
    //
    m_pControllerWindow->m_bDeletePicturesIfSuccessful = (SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DELETEAFTERDOWNLOAD, BM_GETCHECK, 0, 0 )==BST_CHECKED);

    //
    // Prepare the name data we will be using for this transfer
    //
    m_pControllerWindow->m_DestinationNameData = PrepareNameDecorationData(false);

    //
    // Return
    //
    return 0;
}

//
// handler for PSN_WIZBACK
//
LRESULT CCommonTransferPage::OnWizBack( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnWizBack")));
    return 0;
}


CDestinationData::CNameData CCommonTransferPage::PrepareNameDecorationData( bool bUseCurrentSelection )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::PrepareNameDecorationData")));
    CDestinationData::CNameData NameData;
    //
    // If bUseCurrentSelection is true, we need to use CB_GETLBTEXT, because we don't get a CBN_EDITCHANGE message
    // when the user changes the selection
    //
    if (bUseCurrentSelection)
    {
        //
        // Find the currently selected item
        //
        LRESULT nCurSel = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_GETCURSEL, 0, 0 );
        if (nCurSel != CB_ERR)
        {
            //
            // Figure out the length of this item
            //
            LRESULT nTextLen = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_GETLBTEXTLEN, nCurSel, 0 );
            if (CB_ERR != nTextLen)
            {
                //
                // Allocate enough space to hold the string
                //
                LPTSTR pszText = new TCHAR[nTextLen+1];
                if (pszText)
                {
                    //
                    // Get the string
                    //
                    if (CB_ERR != SendDlgItemMessage( m_hWnd, IDC_TRANSFER_ROOTNAME, CB_GETLBTEXT, nCurSel, reinterpret_cast<LPARAM>(pszText)))
                    {
                        //
                        // Save the string
                        //
                        NameData.strTopic = pszText;
                    }
                    //
                    // Free the string
                    //
                    delete[] pszText;
                }
            }
        }
    }
    //
    // If the topic string length is still zero, just get the window text from the edit control
    //
    if (!NameData.strTopic.Length())
    {
        NameData.strTopic.GetWindowText( GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ) );
    }
    NameData.strDate = CAcquisitionManagerControllerWindow::GetCurrentDate();
    NameData.strDateAndTopic = CSimpleString().Format( IDS_DATEANDTOPIC, g_hInstance, NameData.strDate.String(), NameData.strTopic.String() );
    return NameData;
}

//
// handler for PSN_SETACTIVE
//
LRESULT CCommonTransferPage::OnSetActive( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CCommonTransferPage::OnSetActive"));

    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    //
    // Put up a wait cursor.  It can take a while to find out if any images can be deleted
    //
    CWaitCursor wc;

    //
    // Disable the delete button if none of the images can be deleted
    //
    if (!m_pControllerWindow->CanSomeSelectedImagesBeDeleted())
    {
        EnableWindow( GetDlgItem( m_hWnd, IDC_TRANSFER_DELETEAFTERDOWNLOAD ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( m_hWnd, IDC_TRANSFER_DELETEAFTERDOWNLOAD ), TRUE );
    }

    //
    // Clear the delete check box
    //
    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DELETEAFTERDOWNLOAD, BM_SETCHECK, BST_UNCHECKED, 0 );

    //
    // Allow next and back
    //
    PropSheet_SetWizButtons( GetParent(m_hWnd), PSWIZB_NEXT|PSWIZB_BACK );

    //
    // We do want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectGotoLastpage|CAcquisitionManagerControllerWindow::OnDisconnectFailDownload|CAcquisitionManagerControllerWindow::OnDisconnectFailUpload|CAcquisitionManagerControllerWindow::OnDisconnectFailDelete;

    //
    // Make sure all of the strings fit
    //
    WiaUiUtil::ModifyComboBoxDropWidth(GetDlgItem( m_hWnd, IDC_TRANSFER_ROOTNAME ));

    //
    // Make sure the paths are updated
    //
    UpdateDynamicPaths();

    return 0;
}


void CCommonTransferPage::PopulateSaveAsTypeList( IWiaItem *pWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CCommonTransferPage::PopulateSaveAsTypeList"));
    //
    // Get the list control
    //
    HWND hWndList = GetDlgItem( m_hWnd, IDC_TRANSFER_IMAGETYPE );
    if (hWndList)
    {
        //
        // Clear the combo box
        //
        SendMessage( hWndList, CB_RESETCONTENT, 0, 0 );

        //
        // Get the list control's image list
        //
        HIMAGELIST hComboBoxExImageList = reinterpret_cast<HIMAGELIST>(SendMessage( hWndList, CBEM_GETIMAGELIST, 0, 0 ));
        if (hComboBoxExImageList)
        {
            //
            // Get the default icon, in case we run into an unknown type
            //
            HICON hDefaultImageTypeIcon = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_DEFTYPE), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR ));

            //
            // Get the GDI Plus types we can convert to
            //
            CWiaFileFormatList GdiPlusFileFormatList(g_pSupportedOutputFormats,ARRAYSIZE(g_pSupportedOutputFormats), hDefaultImageTypeIcon );

            //
            // Debug output
            //
            GdiPlusFileFormatList.Dump();

            //
            // Get the formats this object supports directly
            //
            CWiaFileFormatList WiaItemFileFormatList( pWiaItem, hDefaultImageTypeIcon );

            //
            // Debug output
            //
            WiaItemFileFormatList.Dump();

            //
            // Merge the GDI+ and native format lists
            //
            WiaItemFileFormatList.Union(GdiPlusFileFormatList);

            //
            // Loop through the merged list of formats and add each one to the list
            //
            for (int i=0;i<WiaItemFileFormatList.FormatList().Size();i++)
            {
                //
                // Make sure we have a valid format
                //
                if (WiaItemFileFormatList.FormatList()[i].IsValid() && WiaItemFileFormatList.FormatList()[i].Icon())
                {
                    //
                    // Add the icon to the image list
                    //
                    int nIconIndex = ImageList_AddIcon( hComboBoxExImageList, WiaItemFileFormatList.FormatList()[i].Icon() );

                    //
                    // Get the description string.  Like "BMP File"
                    //
                    CSimpleString strFormatDescription = WiaItemFileFormatList.FormatList()[i].Description();

                    //
                    // If we didn't get a description string, make one
                    //
                    if (!strFormatDescription.Length())
                    {
                        strFormatDescription.Format( IDS_BLANKFILETYPENAME, g_hInstance, WiaItemFileFormatList.FormatList()[i].Extension().ToUpper().String() );
                    }

                    //
                    // Create the full string description, like "BMP (BMP File)"
                    //
                    CSimpleString strFormatName;
                    strFormatName.Format( IDS_FILETYPE, g_hInstance, WiaItemFileFormatList.FormatList()[i].Extension().ToUpper().String(), strFormatDescription.String() );

                    //
                    // If we have a valid name
                    //
                    if (strFormatName.Length())
                    {
                        //
                        // Allocate a GUID to store the guid in as an LPARAM
                        //
                        GUID *pGuid = new GUID;
                        if (pGuid)
                        {
                            //
                            // Save the GUID
                            //
                            *pGuid = WiaItemFileFormatList.FormatList()[i].Format();

                            //
                            // Get the cbex item ready for an insert (really an append)
                            //
                            COMBOBOXEXITEM cbex = {0};
                            ZeroMemory( &cbex, sizeof(cbex) );
                            cbex.mask           = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_LPARAM;
                            cbex.iItem          = -1;
                            cbex.pszText        = const_cast<LPTSTR>(strFormatName.String());
                            cbex.iImage         = nIconIndex;
                            cbex.iSelectedImage = nIconIndex;
                            cbex.lParam         = reinterpret_cast<LPARAM>(pGuid);

                            //
                            // Insert the item
                            //
                            SendMessage( hWndList, CBEM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&cbex) );
                        }
                    }
                }
            }

            if (hDefaultImageTypeIcon)
            {
                DestroyIcon(hDefaultImageTypeIcon);
            }
        }

        //
        // Now set the current selection to the last selected type
        //
        int nSelectedItem = 0;

        //
        // Search the combo box for a match for this type
        //
        for (int i=0;i<SendMessage(hWndList,CB_GETCOUNT,0,0);i++)
        {
            //
            // Get an item from the combo box
            //
            COMBOBOXEXITEM ComboBoxExItem = {0};
            ComboBoxExItem.iItem = i;
            ComboBoxExItem.mask = CBEIF_LPARAM;
            if (SendMessage( hWndList, CBEM_GETITEM, 0, reinterpret_cast<LPARAM>(&ComboBoxExItem)))
            {
                //
                // Compare its guid with the MRU type
                //
                GUID *pGuid = reinterpret_cast<GUID*>(ComboBoxExItem.lParam);
                if (pGuid && *pGuid == m_guidLastSelectedType)
                {
                    //
                    // Save the index and exit the loop
                    //
                    nSelectedItem = i;
                    break;
                }
            }
        }

        //
        // Set the current selection
        //
        SendMessage(hWndList,CB_SETCURSEL,nSelectedItem,0);

        //
        // Make sure all of the strings fit
        //
        WiaUiUtil::ModifyComboBoxDropWidth(hWndList);
    }
}


GUID *CCommonTransferPage::GetCurrentOutputFormat(void)
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::GetCurrentOutputFormat")));
    HWND hWndList = GetDlgItem( m_hWnd, IDC_TRANSFER_IMAGETYPE );
    if (hWndList)
    {
        LRESULT lResult = SendMessage( hWndList, CB_GETCURSEL, 0, 0 );
        if (lResult != CB_ERR)
        {
            COMBOBOXEXITEM ComboBoxExItem;
            ZeroMemory( &ComboBoxExItem, sizeof(ComboBoxExItem) );
            ComboBoxExItem.mask = CBEIF_LPARAM;
            ComboBoxExItem.iItem = lResult;

            lResult = SendMessage( hWndList, CBEM_GETITEM, 0, reinterpret_cast<LPARAM>(&ComboBoxExItem) );
            if (lResult && ComboBoxExItem.lParam)
            {
                //
                // There's a GUID
                //
                return reinterpret_cast<GUID*>(ComboBoxExItem.lParam);
            }
        }
    }
    return NULL;
}

LRESULT CCommonTransferPage::OnDestroy( WPARAM, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnDestroy")));
    //
    // Save the MRU lists to the registry
    //
    m_MruDirectory.Write( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REG_STR_DIRNAME_MRU );
    m_MruRootFilename.Write( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REG_STR_ROOTNAME_MRU );

    //
    // Save page settings
    //
    CSimpleReg reg( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, true, KEY_WRITE );

    //
    // Save current format
    //
    GUID *pCurrFormat = GetCurrentOutputFormat();
    if (pCurrFormat)
    {
        reg.SetBin( REG_STR_LASTFORMAT, (PBYTE)pCurrFormat, sizeof(GUID), REG_BINARY );
    }

    //
    //  Destroy the image lists
    //
    HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CBEM_SETIMAGELIST, 0, NULL ));
    if (hImageList)
    {
        ImageList_Destroy(hImageList);
    }
    if (GetDlgItem(m_hWnd,IDC_TRANSFER_IMAGETYPE))
    {
        hImageList = reinterpret_cast<HIMAGELIST>(SendDlgItemMessage( m_hWnd,  IDC_TRANSFER_IMAGETYPE, CBEM_SETIMAGELIST, 0, NULL ));
        if (hImageList)
        {
            ImageList_Destroy(hImageList);
        }
    }

    if (m_hFontBold)
    {
        DeleteFont(m_hFontBold);
        m_hFontBold = NULL;
    }

    return 0;
}

CSimpleString CCommonTransferPage::GetFolderName( LPCITEMIDLIST pidl )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::GetFolderName")));
    if (!pidl)
    {
        return CSimpleString(TEXT(""));
    }
    if (CSimpleIdList().GetSpecialFolder( NULL, CSIDL_MYPICTURES|CSIDL_FLAG_CREATE ) == pidl)
    {
        SHFILEINFO shfi;
        ZeroMemory( &shfi, sizeof(shfi) );
        if (SHGetFileInfo( reinterpret_cast<LPCTSTR>(pidl), 0, &shfi, sizeof(shfi), SHGFI_PIDL | SHGFI_DISPLAYNAME ))
        {
            return(shfi.szDisplayName);
        }
    }
    else if (CSimpleIdList().GetSpecialFolder( NULL, CSIDL_PERSONAL|CSIDL_FLAG_CREATE ) == pidl)
    {
        SHFILEINFO shfi;
        ZeroMemory( &shfi, sizeof(shfi) );
        if (SHGetFileInfo( reinterpret_cast<LPCTSTR>(pidl), 0, &shfi, sizeof(shfi), SHGFI_PIDL | SHGFI_DISPLAYNAME ))
        {
            return(shfi.szDisplayName);
        }
    }
    TCHAR szPath[MAX_PATH];
    if (SHGetPathFromIDList( pidl, szPath ))
    {
        return(szPath);
    }
    return(CSimpleString(TEXT("")));
}


LRESULT CCommonTransferPage::AddPathToComboBoxExOrListView( HWND hWnd, CDestinationData &Path, bool bComboBoxEx )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::AddPathToComboBoxExOrListView")));
    if (!IsWindow(hWnd))
    {
        return(-1);
    }

    if (Path.IsValid())
    {
        //
        // Make sure this path can be used in a folder name
        //
        if (Path.IsValidFileSystemPath(PrepareNameDecorationData()))
        {
            //
            // Get the name of the folder
            //
            CSimpleString strName = Path.DisplayName(PrepareNameDecorationData());
            if (!strName.Length())
            {
                return(CB_ERR);
            }

            //
            // Get the combobox's image list and add the shell's icon to it.
            //
            int nIconIndex = 0;
            HICON hIcon = Path.SmallIcon();
            if (hIcon)
            {
                if (bComboBoxEx)
                {
                    HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendMessage( hWnd, CBEM_GETIMAGELIST, 0, 0 ));
                    if (hImageList)
                    {
                        nIconIndex = ImageList_AddIcon( hImageList, hIcon );
                    }
                }
                else
                {
                    HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendMessage( hWnd, LVM_GETIMAGELIST, LVSIL_SMALL, 0 ));
                    if (hImageList)
                    {
                        nIconIndex = ImageList_AddIcon( hImageList, hIcon );
                    }
                }
            }

            //
            // If it already exists, don't add it
            //
            if (bComboBoxEx)
            {
                LRESULT nFind = SendMessage( hWnd, CB_FINDSTRINGEXACT, 0, reinterpret_cast<LPARAM>(strName.String()));
                if (nFind != CB_ERR)
                {
                    return(nFind);
                }
            }


            if (bComboBoxEx)
            {
                //
                // Prepare the cbex struct
                //
                COMBOBOXEXITEM cbex = {0};
                cbex.mask           = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_LPARAM;
                cbex.iItem          = -1;
                cbex.pszText        = const_cast<LPTSTR>(strName.String());
                cbex.iImage         = nIconIndex;
                cbex.iSelectedImage = nIconIndex;
                cbex.lParam         = reinterpret_cast<LPARAM>(&Path);

                //
                // Add the item
                //
                LRESULT lRes = SendMessage( hWnd, CBEM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&cbex) );

                //
                // Make sure all of the strings fit
                //
                WiaUiUtil::ModifyComboBoxDropWidth(hWnd);

                return lRes;

            }
            else
            {
                LVITEM lvItem  = {0};
                lvItem.mask    = LVIF_TEXT|LVIF_IMAGE|LVIF_PARAM;
                lvItem.iItem   = 0;
                lvItem.pszText = const_cast<LPTSTR>(strName.String());
                lvItem.iImage  = nIconIndex;
                lvItem.lParam  = reinterpret_cast<LPARAM>(&Path);

                //
                // Add the item
                //
                return SendMessage( hWnd, LVM_INSERTITEM, 0, reinterpret_cast<LPARAM>(&lvItem) );
            }
        }
    }
    return -1;
}


/*****************************************************************************

   PopulateDestinationList

   Fills in the destinatin drop down list w/the info from the MRU
   saved in the registry.

 *****************************************************************************/
void CCommonTransferPage::PopulateDestinationList(void)
{
    WIA_PUSHFUNCTION((TEXT("CCommonTransferPage::PopulateDestinationList")));

    //
    // Empty the list controls
    //
    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CB_RESETCONTENT, 0, 0 );

    //
    // Remove all of the images from the image list
    //
    HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendDlgItemMessage( m_hWnd,IDC_TRANSFER_DESTINATION, CBEM_GETIMAGELIST, 0, 0 ));
    if (hImageList)
    {
        ImageList_RemoveAll(hImageList);
    }

    //
    // Add all of the paths in the MRU list.  Dupes will be ignored.
    //
    CMruDestinationData::Iterator ListIter = m_MruDirectory.Begin();
    while (ListIter != m_MruDirectory.End())
    {
        AddPathToComboBoxExOrListView( GetDlgItem(m_hWnd,IDC_TRANSFER_DESTINATION), *ListIter, true );
        ++ListIter;
    }

    //
    // Set the current selection to item 0, since the MRU should have taken care of ordering
    //
    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CB_SETCURSEL, 0, 0 );

    WiaUiUtil::ModifyComboBoxDropWidth(GetDlgItem(m_hWnd,IDC_TRANSFER_DESTINATION));
}



/*****************************************************************************

   GetCurrentDestinationFolder

   Given a handle to the dialog, return the path to the directory that
   the user has selected.

   pszPath is assumed to point to a MAX_PATH (or greater) character buffer

   Pass a NULL pszPath to get just the pidl

 *****************************************************************************/
CDestinationData *CCommonTransferPage::GetCurrentDestinationFolder( bool bStore )
{
    WIA_PUSHFUNCTION((TEXT("CCommonTransferPage::GetCurrentDestinationFolder")));

    //
    // Assume failure
    //
    CDestinationData *pResult = NULL;

    //
    // Saving to a folder?
    //
    LRESULT lResult = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CB_GETCURSEL, 0, 0 );
    if (lResult != CB_ERR)
    {
        //
        // Get the item
        //
        COMBOBOXEXITEM ComboBoxExItem = {0};
        ComboBoxExItem.mask = CBEIF_LPARAM;
        ComboBoxExItem.iItem = lResult;
        lResult = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CBEM_GETITEM, 0, reinterpret_cast<LPARAM>(&ComboBoxExItem) );

        //
        // If this message succeeded, and it has an lParam
        //
        if (lResult && ComboBoxExItem.lParam)
        {
            //
            // Get the data
            //
            pResult = reinterpret_cast<CDestinationData*>(ComboBoxExItem.lParam);
        }
    }

    if (pResult)
    {
        //
        // If this is an idlist, set the path and return an idlist
        //
        if (bStore && m_pControllerWindow)
        {
            //
            // Get the pathname, if requested
            //
            CSimpleString strPath = pResult->Path(PrepareNameDecorationData());
            if (strPath.Length())
            {
                lstrcpyn( m_pControllerWindow->m_szDestinationDirectory, strPath, MAX_PATH );
            }
        }
    }

    return pResult;
}


bool CCommonTransferPage::ValidateFilename( LPCTSTR pszFilename )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::ValidateFilename")));
    //
    // if the filename is NULL or empty, it is invalid
    //
    if (!pszFilename || !*pszFilename)
    {
        return false;
    }
    for (LPCTSTR pszCurr = pszFilename;*pszCurr;pszCurr=CharNext(pszCurr))
    {
        if (*pszCurr == TEXT(':') ||
            *pszCurr == TEXT('\\') ||
            *pszCurr == TEXT('/') ||
            *pszCurr == TEXT('?') ||
            *pszCurr == TEXT('"') ||
            *pszCurr == TEXT('<') ||
            *pszCurr == TEXT('>') ||
            *pszCurr == TEXT('|') ||
            *pszCurr == TEXT('*'))
        {
            return false;
        }
    }
    return true;
}

int CALLBACK CCommonTransferPage::BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::BrowseCallbackProc")));
    if (BFFM_INITIALIZED == uMsg && lpData)
    {
        SendMessage( hWnd, BFFM_SETSELECTION, FALSE, lpData );
        WIA_TRACE((TEXT("CSimpleIdList(reinterpret_cast<LPITEMIDLIST>(lpData)).Name().String(): %s"), CSimpleIdList(reinterpret_cast<LPITEMIDLIST>(lpData)).Name().String() ));
    }
    return(0);
}

void CCommonTransferPage::OnBrowseDestination( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION((TEXT("CCommonTransferPage::OnBrowseDestination")));

    TCHAR szDisplay[MAX_PATH];

    //
    // Get the initial ID list
    //
    CSimpleIdList InitialIdList;
    CDestinationData *pResult = GetCurrentDestinationFolder( false );

    if (pResult)
    {
        CSimpleIdList InitialIdList;
        if (pResult->IsSpecialFolder())
        {
            InitialIdList.GetSpecialFolder( m_hWnd, pResult->Csidl() );
        }
        else
        {
            InitialIdList = pResult->IdList();
        }

        //
        // Load the title string
        //
        CSimpleString strBrowseTitle( IDS_BROWSE_TITLE, g_hInstance );

        //
        // Prepare the folder browsing structure
        //
        BROWSEINFO BrowseInfo;
        ZeroMemory( &BrowseInfo, sizeof(BrowseInfo) );
        BrowseInfo.hwndOwner = m_hWnd;
        BrowseInfo.pidlRoot  = NULL;
        BrowseInfo.pszDisplayName = szDisplay;
        BrowseInfo.lpszTitle = const_cast<LPTSTR>(strBrowseTitle.String());
        BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_EDITBOX;
        BrowseInfo.lParam = reinterpret_cast<LPARAM>(InitialIdList.IdList());
        BrowseInfo.lpfn = BrowseCallbackProc;

        //
        // Open the folder browser
        //
        LPITEMIDLIST pidl = SHBrowseForFolder( &BrowseInfo );
        if (pidl)
        {
            //
            // Create a destination data for this PIDL
            //
            CDestinationData DestinationData(pidl);
            if (DestinationData.IsValid())
            {
                //
                // Add this pidl to the directory mru
                //
                m_MruDirectory.Add( DestinationData );

                //
                // Add this pidl to the destination list too, by repopulating the list
                //
                PopulateDestinationList();
            }

            //
            // Free pidl
            //
            LPMALLOC pMalloc = NULL;
            if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
            {
                pMalloc->Free(pidl);
                pMalloc->Release();
            }
        }
    }
}


void CCommonTransferPage::UpdateDynamicPaths( bool bSelectionChanged )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::UpdateDynamicPaths")));
    CDestinationData::CNameData NameData = PrepareNameDecorationData( bSelectionChanged != false );

    //
    // Get the current selection
    //
    LRESULT nCurSel = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CB_GETCURSEL, 0, 0 );

    //
    // We will only redraw if a dynamic item is selected
    //
    bool bRedrawNeeded = false;

    //
    // Loop through all of the items in the list
    //
    LRESULT nCount = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CB_GETCOUNT, 0, 0 );
    for (LRESULT i=0;i<nCount;i++)
    {
        //
        // Get the item
        //
        COMBOBOXEXITEM ComboBoxExItem = {0};
        ComboBoxExItem.mask = CBEIF_LPARAM;
        ComboBoxExItem.iItem = i;
        LRESULT lResult = SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CBEM_GETITEM, 0, reinterpret_cast<LPARAM>(&ComboBoxExItem) );

        //
        // If this message succeeded, and it has an lParam
        //
        if (lResult && ComboBoxExItem.lParam)
        {
            //
            // Get the data
            //
            CDestinationData *pDestinationData = reinterpret_cast<CDestinationData*>(ComboBoxExItem.lParam);

            //
            // If this item has any dynamic decorations
            //
            if (pDestinationData && (pDestinationData->Flags() & CDestinationData::DECORATION_MASK))
            {
                //
                // Get the display name for this item.
                //
                CSimpleString strDisplayName = pDestinationData->DisplayName( NameData );

                //
                // Make sure we have a valid display name
                //
                if (strDisplayName.Length())
                {
                    //
                    // Set the data
                    //
                    COMBOBOXEXITEM ComboBoxExItem = {0};
                    ComboBoxExItem.mask = CBEIF_TEXT;
                    ComboBoxExItem.iItem = i;
                    ComboBoxExItem.pszText = const_cast<LPTSTR>(strDisplayName.String());
                    SendDlgItemMessage( m_hWnd, IDC_TRANSFER_DESTINATION, CBEM_SETITEM, 0, reinterpret_cast<LPARAM>(&ComboBoxExItem) );

                    //
                    // If this item is currently selected, force a redraw
                    //
                    if (nCurSel == i)
                    {
                        bRedrawNeeded = true;
                    }
                }
            }
        }
    }

    //
    // Update the control, if necessary
    //
    if (bRedrawNeeded)
    {
        InvalidateRect( GetDlgItem( m_hWnd, IDC_TRANSFER_DESTINATION ), NULL, FALSE );
    }
}

void CCommonTransferPage::OnRootNameChange( WPARAM wParam, LPARAM )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnRootNameChange")));
    UpdateDynamicPaths(HIWORD(wParam) == CBN_SELCHANGE);
}

LRESULT CCommonTransferPage::OnImageTypeDeleteItem( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnImageTypeDeleteItem")));
    PNMCOMBOBOXEX pNmComboBoxEx = reinterpret_cast<PNMCOMBOBOXEX>(lParam);
    if (pNmComboBoxEx)
    {
        GUID *pGuid = reinterpret_cast<GUID*>(pNmComboBoxEx->ceItem.lParam);
        if (pGuid)
        {
            delete pGuid;
        }
    }
    return 0;
}

LRESULT CCommonTransferPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonTransferPage::OnEventNotification") ));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}

LRESULT CCommonTransferPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND( IDC_TRANSFER_BROWSE, OnBrowseDestination );
        SC_HANDLE_COMMAND_NOTIFY(CBN_EDITCHANGE,IDC_TRANSFER_ROOTNAME,OnRootNameChange);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_TRANSFER_ROOTNAME,OnRootNameChange);
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CCommonTransferPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CONTROL(CBEN_DELETEITEM,IDC_TRANSFER_IMAGETYPE,OnImageTypeDeleteItem);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

INT_PTR CALLBACK CCommonTransferPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CCommonTransferPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\comtrans.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       COMTRANS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Transfer page.  Gets the destination path and filename.
 *
 *******************************************************************************/
#ifndef __COMTRANS_H_INCLUDED
#define __COMTRANS_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "mru.h"

class CCommonTransferPage
{
private:
    // Private data
    HWND                                               m_hWnd;
    UINT                                               m_nWiaEventMessage;
    CAcquisitionManagerControllerWindow               *m_pControllerWindow;
    CMruStringList                                     m_MruRootFilename;
    CMruDestinationData                                m_MruDirectory;
    bool                                               m_bUseSubdirectory;
    GUID                                               m_guidLastSelectedType;
    HFONT                                              m_hFontBold;

private:
    // No implementation
    CCommonTransferPage(void);
    CCommonTransferPage( const CCommonTransferPage & );
    CCommonTransferPage &operator=( const CCommonTransferPage & );

private:
    // Constructor and destructor
    explicit CCommonTransferPage( HWND hWnd );
    ~CCommonTransferPage(void);

private:
    // Miscellaneous functions
    CSimpleString GetFolderName( LPCITEMIDLIST pidl );
    LRESULT AddPathToComboBoxExOrListView( HWND hwndCombo, CDestinationData &Path, bool bComboBoxEx );
    void PopulateDestinationList(void);
    CDestinationData *GetCurrentDestinationFolder( bool bStore );
    bool ValidateFilename( LPCTSTR pszFilename );
    void DisplayProposedFilenames(void);
    void RestartFilenameInfoTimer(void);
    HWND ValidatePathAndFilename(void);
    bool StorePathAndFilename(void);
    bool ValidatePathname( LPCTSTR pszPath );
    void PopulateSaveAsTypeList( IWiaItem *pWiaItem );
    GUID *GetCurrentOutputFormat(void);
    void UpdateDynamicPaths( bool bSelectionChanged = false );
    CDestinationData::CNameData PrepareNameDecorationData( bool bUseCurrentSelection=false );

    // SHBrowseForFolder callback
    static int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData );

private:
    LRESULT OnEventNotification( WPARAM, LPARAM );

    // WM_COMMAND handlers
    void OnBrowseDestination( WPARAM, LPARAM );
    void OnCreateTopicalDirectory( WPARAM, LPARAM );
    void OnAdvanced( WPARAM, LPARAM );
    void OnRootNameChange( WPARAM, LPARAM );

    // WM_NOTIFY handlers
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnDestinationEndEdit( WPARAM, LPARAM );
    LRESULT OnImageTypeDeleteItem( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __COMTRANS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\destdata.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DESTDATA.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        4/6/2000
 *
 *  DESCRIPTION: wrapper class to encapsulate plugins and directories
 *
 *******************************************************************************/

#ifndef __DESTDATA_H_INCLUDED
#define __DESTDATA_H_INCLUDED

#include <windows.h>
#include <uicommon.h>
#include "simidlst.h"
#include "simstr.h"



class CDestinationData
{
public:
    enum
    {
        APPEND_DATE_TO_PATH  = 0x00000001,
        APPEND_TOPIC_TO_PATH = 0x00000002,
        DECORATION_MASK      = 0x0000000F,
        SPECIAL_FOLDER       = 0x00000020
    };

    struct CNameData
    {
    public:
        CSimpleString strDate;
        CSimpleString strTopic;
        CSimpleString strDateAndTopic;
    };

private:
    CSimpleIdList    m_IdList;
    DWORD            m_dwFlags;
    CNameData        m_NameData;
    DWORD            m_dwCsidl;
    HICON            m_hSmallIcon;

public:
    CDestinationData(void)
      : m_dwFlags(0),
        m_dwCsidl(0),
        m_hSmallIcon(NULL)
    {
    }
    CDestinationData( const CDestinationData &other )
      : m_IdList(other.IdList()),
        m_dwFlags(other.Flags()),
        m_dwCsidl(other.Csidl()),
        m_hSmallIcon(NULL)
    {
    }
    void AssignFromIdList( const CSimpleIdList &idList, DWORD dwDecorationFlags )
    {
        Destroy();

        //
        // Here is the list of special folders we want to display
        // with their short names.  Others will be stored as full paths
        // in PIDLs.
        //
        static const DWORD cs_SpecialFolders[] =
        {
            CSIDL_MYPICTURES,
            CSIDL_PERSONAL,
            CSIDL_COMMON_PICTURES
        };

        //
        // Try to find a matching PIDL in the list.
        //
        for (int i=0;i<ARRAYSIZE(cs_SpecialFolders);i++)
        {
            //
            // If we've found one, store the CSIDL and mark this one as a special folder.
            // Then exit the loop.
            //
            if (CSimpleIdList().GetSpecialFolder(NULL,cs_SpecialFolders[i]|CSIDL_FLAG_CREATE) == idList)
            {
                m_dwFlags |= SPECIAL_FOLDER;
                m_dwCsidl = cs_SpecialFolders[i];
                break;
            }
        }

        //
        // If we didn't find a special pidl, store it as a full path
        //
        if (!m_dwCsidl)
        {
            m_IdList = idList;
        }

        //
        // Add in any decoration flags
        //
        m_dwFlags |= dwDecorationFlags;
    }
    CDestinationData( LPITEMIDLIST pidl, DWORD dwDecorationFlags=0)
      : m_dwFlags(0),
        m_dwCsidl(0)
    {
        AssignFromIdList( pidl, dwDecorationFlags );
    }
    CDestinationData( CSimpleIdList idList, DWORD dwDecorationFlags=0 )
      : m_dwFlags(0),
        m_dwCsidl(0)
    {
        AssignFromIdList( idList, dwDecorationFlags );
    }
    CDestinationData( int nCsidl, DWORD dwDecorationFlags=0 )
      : m_dwFlags(dwDecorationFlags | SPECIAL_FOLDER),
        m_dwCsidl(static_cast<DWORD>(nCsidl))
    {
    }

    DWORD Flags(void) const
    {
        return m_dwFlags;
    }

    DWORD Csidl(void) const
    {
        return m_dwCsidl;
    }
    CDestinationData &operator=( const CDestinationData &other )
    {
        if (this != &other)
        {
            Destroy();
            m_IdList = other.IdList();
            m_dwFlags = other.Flags();
            m_dwCsidl = other.Csidl();
        }
        return *this;
    }
    ~CDestinationData(void)
    {
        Destroy();
    }
    void Destroy(void)
    {
        m_IdList.Destroy();
        m_dwFlags = 0;
        m_dwCsidl = 0;
        if (m_hSmallIcon)
        {
            DestroyIcon(m_hSmallIcon);
            m_hSmallIcon = NULL;
        }
    }

    const CSimpleIdList &IdList(void) const
    {
        return m_IdList;
    }
    bool IsSpecialFolder(void) const
    {
        if (m_dwFlags & SPECIAL_FOLDER)
        {
            return true;
        }
        return false;
    }
    bool operator==( const CDestinationData &other ) const
    {
        if (IsSpecialFolder() && other.IsSpecialFolder())
        {
            if (Csidl() == other.Csidl())
            {
                if ((Flags() & DECORATION_MASK) == (other.Flags() & DECORATION_MASK))
                {
                    return true;
                }
            }
            return false;
        }
        else if (m_IdList.Name() == other.IdList().Name())
        {
            if ((Flags() & DECORATION_MASK) == (other.Flags() & DECORATION_MASK))
            {
                return true;
            }
        }
        return false;
    }
    bool GetDecoration( CSimpleString &strResult, const CNameData &NameData ) const
    {
        if ((Flags() & DECORATION_MASK)==(APPEND_TOPIC_TO_PATH|APPEND_DATE_TO_PATH))
        {
            strResult = NameData.strDateAndTopic;
        }
        else if ((Flags() & DECORATION_MASK)==APPEND_DATE_TO_PATH)
        {
            strResult = NameData.strDate;
        }
        else if ((Flags() & DECORATION_MASK)==APPEND_TOPIC_TO_PATH)
        {
            strResult = NameData.strTopic;
        }
        return (strResult.Length() != 0);
    }
    void AppendDecoration( CSimpleString &strResult, const CNameData &NameData ) const
    {
        if ((Flags() & DECORATION_MASK)==(APPEND_TOPIC_TO_PATH|APPEND_DATE_TO_PATH))
        {
            strResult += TEXT("\\");
            strResult += NameData.strDateAndTopic;
        }
        else if ((Flags() & DECORATION_MASK)==APPEND_DATE_TO_PATH)
        {
            strResult += TEXT("\\");
            strResult += NameData.strDate;
        }
        else if ((Flags() & DECORATION_MASK)==APPEND_TOPIC_TO_PATH)
        {
            strResult += TEXT("\\");
            strResult += NameData.strTopic;
        }
    }
    CSimpleString Path( const CNameData &NameData ) const
    {
        CSimpleString strResult;

        if (IsSpecialFolder())
        {
            strResult = CSimpleIdList().GetSpecialFolder(NULL,m_dwCsidl|CSIDL_FLAG_CREATE).Name();
            AppendDecoration( strResult, NameData );
        }
        else
        {
            strResult = m_IdList.Name();
            AppendDecoration( strResult, NameData );
        }
        return strResult;
    }
    bool IsValidFileSystemPath( const CNameData &NameData ) const
    {
        bool bResult = true;
        CSimpleString strDecoration;
        if (GetDecoration( strDecoration, NameData ))
        {
            for (LPCTSTR pszCurr = strDecoration.String();pszCurr && *pszCurr && bResult;pszCurr = CharNext(pszCurr))
            {
                if (*pszCurr == TEXT(':') ||
                    *pszCurr == TEXT('\\') ||
                    *pszCurr == TEXT('/') ||
                    *pszCurr == TEXT('?') ||
                    *pszCurr == TEXT('"') ||
                    *pszCurr == TEXT('<') ||
                    *pszCurr == TEXT('>') ||
                    *pszCurr == TEXT('|') ||
                    *pszCurr == TEXT('*'))
                {
                    bResult = false;
                }
            }
        }
        return bResult;
    }
    bool operator!=( const CDestinationData &other ) const
    {
        return ((*this == other) == false);
    }
    bool IsValid(void) const
    {
        if (IsSpecialFolder())
        {
            return true;
        }
        else
        {
            return m_IdList.IsValid();
        }
    }
    HICON SmallIcon()
    {
        if (m_hSmallIcon)
        {
            return m_hSmallIcon;
        }

        if (IsValid())
        {
            if (IsSpecialFolder())
            {
                //
                // Get the folder's small icon
                //
                SHFILEINFO shfi = {0};
                HIMAGELIST hShellImageList = reinterpret_cast<HIMAGELIST>(SHGetFileInfo( reinterpret_cast<LPCTSTR>(CSimpleIdList().GetSpecialFolder(NULL,m_dwCsidl|CSIDL_FLAG_CREATE).IdList()), 0, &shfi, sizeof(shfi), SHGFI_SMALLICON | SHGFI_ICON | SHGFI_PIDL ));
                if (hShellImageList)
                {
                    m_hSmallIcon = shfi.hIcon;
                }
            }
            else
            {
                //
                // Get the folder's small icon
                //
                SHFILEINFO shfi = {0};
                HIMAGELIST hShellImageList = reinterpret_cast<HIMAGELIST>(SHGetFileInfo( reinterpret_cast<LPCTSTR>(m_IdList.IdList()), 0, &shfi, sizeof(shfi), SHGFI_SMALLICON | SHGFI_ICON | SHGFI_PIDL ));
                if (hShellImageList)
                {
                    m_hSmallIcon = shfi.hIcon;
                }
            }
        }
        return m_hSmallIcon;
    }
    CSimpleString DisplayName( const CNameData &NameData )
    {
        CSimpleString strDisplayName;

        //
        // Get the folder's display name
        //
        if (IsSpecialFolder())
        {
            SHFILEINFO shfi = {0};
            if (SHGetFileInfo( reinterpret_cast<LPCTSTR>(CSimpleIdList().GetSpecialFolder(NULL,m_dwCsidl|CSIDL_FLAG_CREATE).IdList()), 0, &shfi, sizeof(shfi), SHGFI_PIDL | SHGFI_DISPLAYNAME ))
            {
                strDisplayName = shfi.szDisplayName;
            }
            AppendDecoration( strDisplayName, NameData );
        }
        else if (m_IdList.IsValid())
        {
            TCHAR szPath[MAX_PATH];
            if (SHGetPathFromIDList( m_IdList.IdList(), szPath ))
            {
                strDisplayName = szPath;
            }
            AppendDecoration( strDisplayName, NameData );
        }
        return strDisplayName;
    }
    UINT RegistryDataSize(void) const
    {
        if (m_dwCsidl)
        {
            return sizeof(DWORD) + sizeof(DWORD);
        }
        else
        {
            return sizeof(DWORD) + sizeof(DWORD) + m_IdList.Size();
        }
    }
    UINT GetRegistryData( PBYTE pData, UINT nLength ) const
    {
        UINT nResult = 0;
        if (pData)
        {
            if (nLength >= RegistryDataSize())
            {
                if (IsSpecialFolder())
                {
                    CopyMemory(pData,&m_dwFlags,sizeof(DWORD));
                    pData += sizeof(DWORD);

                    CopyMemory( pData, &m_dwCsidl, sizeof(DWORD));
                }
                else
                {
                    CopyMemory(pData,&m_dwFlags,sizeof(DWORD));
                    pData += sizeof(DWORD);

                    DWORD dwSize = m_IdList.Size();
                    CopyMemory(pData,&dwSize,sizeof(DWORD));
                    pData += sizeof(DWORD);

                    CopyMemory(pData,m_IdList.IdList(),dwSize);
                }
                nResult = RegistryDataSize();
            }
        }
        return nResult;
    }
    UINT SetRegistryData( PBYTE pData, UINT nLength )
    {
        UINT nResult = 0;

        Destroy();

        if (pData)
        {
            //
            // Copy the flags
            //
            CopyMemory( &m_dwFlags, pData, sizeof(DWORD) );
            pData += sizeof(DWORD);
            nLength -= sizeof(DWORD);

            //
            // If this is a web destination, we already have what we need
            //
            if (m_dwFlags & SPECIAL_FOLDER)
            {
                CopyMemory(&m_dwCsidl,pData,sizeof(DWORD));
                nLength -= sizeof(DWORD);
                nResult = nLength;
            }
            else
            {
                DWORD dwPidlLength = 0;
                CopyMemory(&dwPidlLength,pData,sizeof(DWORD));
                pData += sizeof(DWORD);
                nLength -= sizeof(DWORD);
                if (nLength >= dwPidlLength)
                {
                    m_IdList = CSimpleIdList(pData,dwPidlLength);
                    if (m_IdList.IsValid())
                    {
                        nResult = nLength;
                    }
                }
            }
        }
        return nResult;
    }
};

#endif // __DESTDATA_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\eventprompt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       eventprompt.h
//
//--------------------------------------------------------------------------

#ifndef _EVENTPROMPT_H_
#define _EVENTPROMPT_H_
#include <windows.h>
#include "wiaacmgr.h"
#include "acqmgrcw.h"
#include "evntparm.h"
#include "resource.h"
#include <commctrl.h>
// CHandlerList does all our comboboxex operations for the list of event handlers
class CHandlerList
{
private:
    HWND m_hwnd;

public:
    CHandlerList (HWND hwnd)
    : m_hwnd(hwnd)
    {
    }

    ~CHandlerList ()
    {
    }

    UINT FillList (const CSimpleStringWide &strDeviceId, GUID &guidEvent);
    WIA_EVENT_HANDLER *GetSelectedHandler ();
};

// CEventPromptDlg does the work of asking the user which handler to run
// and invoking the specified handler
class CEventPromptDlg
{
private:
    CHandlerList *m_pList;
    HWND m_hwnd;

    CSharedMemorySection<HWND> *m_PromptData;
    CEventParameters *m_pEventParameters;
    CEventPromptDlg (CEventParameters *pEventParameters)
    : m_pEventParameters (pEventParameters), m_hwnd(NULL), m_PromptData(NULL),
      m_pList(NULL)
    {
    }
    ~CEventPromptDlg ()
    {
        if (m_PromptData)
        {
            delete m_PromptData;
        }
        if (m_pList)
        {
            delete m_pList;
        }
    }

    static INT_PTR CALLBACK DlgProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    void OnInit ();
    INT_PTR OnCommand (WORD wCode, WORD widItem);
    INT_PTR OnOK ();
    void SetDefaultHandler (WIA_EVENT_HANDLER *pHandler);
    bool InvokeHandler (WIA_EVENT_HANDLER *pHandler);

public:
    static HRESULT Invoke (HINSTANCE hInst, CEventParameters *pEventParameters)
    {
        WIA_PUSHFUNCTION(TEXT("CEventPromptDlg::Invoke"));
        
        HRESULT hr = S_OK;
        // Register common controls
        INITCOMMONCONTROLSEX icce;
        icce.dwSize = sizeof(icce);
        icce.dwICC  = ICC_USEREX_CLASSES ;
        InitCommonControlsEx( &icce );
        CEventPromptDlg *pDlg = new CEventPromptDlg (pEventParameters);
        if (!pDlg)
        {
            hr = E_OUTOFMEMORY;
        }
        else if (-1 == DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_EVENTPROMPT), NULL, DlgProc,reinterpret_cast<LPARAM>(pDlg)))
        {
            DWORD dw = GetLastError();
            hr =  HRESULT_FROM_WIN32(dw);
        }
        if (pDlg)
        {
            delete pDlg;
        }
        return hr;
    }
}; //CEventPromptDlg

// CPromptThread invokes the event handler prompt dialog
class CPromptThread
{
private:
    CEventParameters m_EventParameters;

    CPromptThread (const CEventParameters &EventParameters)
    : m_EventParameters (EventParameters)
    {
    }

    ~CPromptThread ()
    {
    }

    HRESULT Run(void)
    {
        WIA_PUSHFUNCTION(TEXT("CPromptThread::Run"));
        HRESULT hr = CoInitialize (NULL);
        if (SUCCEEDED(hr))
        {
            hr = CEventPromptDlg::Invoke (g_hInstance, &m_EventParameters);
            CoUninitialize();
        }
        return hr;
    }

    static DWORD ThreadProc( LPVOID pvParam )
    {
        WIA_PUSHFUNCTION(TEXT("CPromptThread::ThreadProc"));
#if !defined(DBG_GENERATE_PRETEND_EVENT)
        _Module.Lock();
#endif
        DWORD dwResult = static_cast<DWORD>(E_FAIL);
        CPromptThread *pThread = reinterpret_cast<CPromptThread*>(pvParam);
        if (pThread)
        {
            dwResult = static_cast<DWORD>(pThread->Run());
            delete pThread;
        }
#if !defined(DBG_GENERATE_PRETEND_EVENT)
        _Module.Unlock();
#endif
        return dwResult;
    }

public:
    static HANDLE Create( const CEventParameters &EventParameters )
    {
        WIA_PUSHFUNCTION(TEXT("CPromptThread::Create"));
        HANDLE hThreadResult = NULL;
        CPromptThread *pThread = new CPromptThread(EventParameters);
        if (pThread)
        {
            DWORD dwThreadId;
            hThreadResult = CreateThread( NULL, 0, ThreadProc, pThread, 0, &dwThreadId );
            if (!hThreadResult)
            {
                delete pThread;
            }
        }
        return hThreadResult;
    }
}; // CPromptThread

// CEventPrompt responds to the event by asking the user which event handler
// to run
class ATL_NO_VTABLE CEventPrompt :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CEventPrompt, &CLSID_EventPrompter>,
    public IWiaEventCallback
{
public:
    CEventPrompt()
    {
    }
    ~CEventPrompt()
    {
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_EVENTPROMPT)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CEventPrompt)
        COM_INTERFACE_ENTRY(IWiaEventCallback)
    END_COM_MAP()


public:
    // IWiaEventCallback
    STDMETHODIMP ImageEventCallback (const GUID __RPC_FAR *pEventGUID,
                                      BSTR bstrEventDescription,
                                      BSTR bstrDeviceID,
                                      BSTR bstrDeviceDescription,
                                      DWORD dwDeviceType,
                                      BSTR  bstrFullItemName,
                                      ULONG *pulEventType,
                                      ULONG ulReserved)
    {
        WIA_PUSHFUNCTION(TEXT("CEventPrompt::ImageEventCallback"));
        bool bRun = true;

        // Find out if we already have a prompt for this event open.
        // If the user just keeps pressing the same button we ignore
        // successive presses until the choice is made.
        CSharedMemorySection<HWND> PromptSharedMemory;
        LPWSTR wszGuid;
        StringFromCLSID (*pEventGUID, &wszGuid);
        // use a unique name for  the shared memory
        CSimpleStringWide strSection(wszGuid);
        strSection.Concat (CSimpleStringWide(bstrDeviceID));
        CoTaskMemFree (wszGuid);
        if (CSharedMemorySection<HWND>::SmsOpened == PromptSharedMemory.Open(CSimpleStringConvert::NaturalString(strSection), false))
        {
            HWND *pHwnd = PromptSharedMemory.Lock();
            if (pHwnd)
            {
                bRun = false;
                if (*pHwnd && IsWindow(*pHwnd))
                {
                    SetForegroundWindow(*pHwnd);
                }
                PromptSharedMemory.Release();
            }
        }
        if (bRun)
        {
            CEventParameters EventParameters;
            EventParameters.EventGUID = *pEventGUID;
            EventParameters.strEventDescription = static_cast<LPCWSTR>(bstrEventDescription);
            EventParameters.strDeviceID = static_cast<LPCWSTR>(bstrDeviceID);
            EventParameters.strDeviceDescription = static_cast<LPCWSTR>(bstrDeviceDescription);
            EventParameters.ulEventType = *pulEventType;
            EventParameters.ulReserved = ulReserved;
            EventParameters.strFullItemName = bstrFullItemName;

            HANDLE hThread = CPromptThread::Create (EventParameters);
            if (hThread)
            {
                CloseHandle(hThread);
            }
        }
        return S_OK;
    }
}; // CEventPrompt

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\evntparm.h ===
#ifndef __EVNTPARM_H_INCLUDED
#define __EVNTPARM_H_INCLUDED

#include <windows.h>
#include <uicommon.h>
#include "shmemsec.h"

struct CEventParameters
{
public:
    GUID                        EventGUID;
    CSimpleStringWide           strFullItemName;
    CSimpleStringWide           strEventDescription;
    CSimpleStringWide           strDeviceID;
    CSimpleStringWide           strDeviceDescription;
    DWORD                       dwDeviceType;
    ULONG                       ulEventType;
    ULONG                       ulReserved;
    HWND                        hwndParent;
    CSharedMemorySection<HWND> *pWizardSharedMemory;

public:

    CEventParameters( const CEventParameters &other )
      : EventGUID(other.EventGUID),
        strFullItemName(other.strFullItemName),
        strDeviceID(other.strDeviceID),
        strDeviceDescription(other.strDeviceDescription),
        dwDeviceType(other.dwDeviceType),
        ulEventType(other.ulEventType),
        ulReserved(other.ulReserved),
        hwndParent(other.hwndParent),
        pWizardSharedMemory(other.pWizardSharedMemory),
        strEventDescription(other.strEventDescription)
    {
    }

    CEventParameters &operator=( const CEventParameters &other )
    {
        if (this != &other)
        {
            EventGUID = other.EventGUID;
            strFullItemName = other.strFullItemName;
            strDeviceID = other.strDeviceID;
            strDeviceDescription = other.strDeviceDescription;
            dwDeviceType = other.dwDeviceType;
            ulEventType = other.ulEventType;
            ulReserved = other.ulReserved;
            hwndParent = other.hwndParent;
            pWizardSharedMemory = other.pWizardSharedMemory;
        }
        return *this;
    }

    CEventParameters()
      : EventGUID(IID_NULL),
        dwDeviceType(0),
        ulEventType(0),
        ulReserved(0),
        pWizardSharedMemory(NULL)
    {
    }

    ~CEventParameters()
    {
        if (pWizardSharedMemory)
        {
            pWizardSharedMemory = NULL;
        }
    }
};


class CStiEventData
{
public:
    
    class CStiEventHandler
    {
    private:
        CSimpleStringWide m_strApplicationName;
        CSimpleStringWide m_strCommandLine;

    public:
        CStiEventHandler()
        {
        }
        CStiEventHandler( const CSimpleStringWide &strApplicationName, const CSimpleStringWide &strCommandLine )
          : m_strApplicationName(strApplicationName),
            m_strCommandLine(strCommandLine)
        {
        }
        CStiEventHandler( const CStiEventHandler &other )
          : m_strApplicationName(other.ApplicationName()),
            m_strCommandLine(other.CommandLine())
        {
        }
        ~CStiEventHandler()
        {
        }
        CStiEventHandler &operator=( const CStiEventHandler &other )
        {
            if (this != &other)
            {
                m_strApplicationName = other.ApplicationName();
                m_strCommandLine = other.CommandLine();
            }
            return *this;
        }
        bool IsValid() const
        {
            return (m_strApplicationName.Length() && m_strCommandLine.Length());
        }
        CSimpleStringWide ApplicationName() const
        {
            return m_strApplicationName;
        }
        CSimpleStringWide CommandLine() const
        {
            return m_strCommandLine;
        }
    };

    typedef CSimpleDynamicArray<CStiEventHandler> CStiEventHandlerArray;

private:    
    GUID                  m_guidEvent;
    CSimpleStringWide     m_strEventDescription;
    CSimpleStringWide     m_strDeviceId;
    CSimpleStringWide     m_strDeviceDescription;
    DWORD                 m_dwDeviceType;
    ULONG                 m_ulEventType;
    ULONG                 m_ulReserved;
    CStiEventHandlerArray m_EventHandlers;

public:
    CStiEventData()
      : m_guidEvent(IID_NULL),
        m_dwDeviceType(0),
        m_ulEventType(0),
        m_ulReserved(0)
    {
    }

    CStiEventData( const GUID *pguidEvent, 
                   LPCWSTR     pwszEventDescription, 
                   LPCWSTR     pwszDeviceId, 
                   LPCWSTR     pwszDeviceDescription,
                   DWORD       dwDeviceType,
                   LPCWSTR     pwszFullItemName,
                   ULONG      *pulEventType,
                   ULONG       ulReserved
                   )
      : m_guidEvent(pguidEvent ? *pguidEvent : IID_NULL),
        m_strEventDescription(pwszEventDescription),
        m_strDeviceId(pwszDeviceId),
        m_strDeviceDescription(pwszDeviceDescription),
        m_dwDeviceType(dwDeviceType),
        m_ulEventType(pulEventType ? *pulEventType : 0),
        m_ulReserved(ulReserved)
    {
        //
        // Crack event handlers.
        //
        // Walk the string until we come to the end, marked by double \0 characters
        //
        LPCWSTR pwszCurr = pwszFullItemName;
        while (pwszCurr && *pwszCurr)
        {
            //
            // Save the application name
            //
            CSimpleStringWide strApplication = pwszCurr;

            //
            // Advance to the command line
            //
            pwszCurr += lstrlen(pwszCurr) + 1;
            
            //
            // Save the command line
            //
            CSimpleStringWide strCommandLine = pwszCurr;

            //
            // Advance to the next token
            //
            pwszCurr += lstrlen(pwszCurr) + 1;

            //
            // If both application and command line are valid strings, add them to the list
            //
            if (strApplication.Length() && strCommandLine.Length())
            {
                m_EventHandlers.Append( CStiEventHandler( strApplication, strCommandLine ) );
            }
        }
    }
    CStiEventData( const CStiEventData &other )
      : m_guidEvent(other.Event()),
        m_strEventDescription(other.EventDescription()),
        m_strDeviceId(other.DeviceId()),
        m_strDeviceDescription(other.DeviceDescription()),
        m_dwDeviceType(other.DeviceType()),
        m_ulEventType(other.EventType()),
        m_ulReserved(other.Reserved()),
        m_EventHandlers(other.EventHandlers())
    {
    }
    ~CStiEventData()
    {
    }
    CStiEventData &operator=( const CStiEventData &other )
    {
        if (this != &other)
        {
            m_guidEvent = other.Event();
            m_strEventDescription = other.EventDescription();
            m_strDeviceId = other.DeviceId();
            m_strDeviceDescription = other.DeviceDescription();
            m_dwDeviceType = other.DeviceType();
            m_ulEventType = other.EventType();
            m_ulReserved = other.Reserved();
            m_EventHandlers = other.EventHandlers();
        }
        return *this;
    }
    GUID Event() const
    {
        return m_guidEvent;
    }
    CSimpleStringWide EventDescription() const
    {
        return m_strEventDescription;
    }
    CSimpleStringWide DeviceId() const
    {
        return m_strDeviceId;
    }
    CSimpleStringWide DeviceDescription() const
    {
        return m_strDeviceDescription;
    }
    DWORD DeviceType() const
    {
        return m_dwDeviceType;
    }
    ULONG EventType() const
    {
        return m_ulEventType;
    }
    ULONG Reserved() const
    {
        return m_ulReserved;
    }
    const CStiEventHandlerArray &EventHandlers() const
    {
        return m_EventHandlers;
    }
};

#endif __EVNTPARM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\eventprompt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       eventprompt.cpp
//
//--------------------------------------------------------------------------
#include <precomp.h>
#pragma hdrstop
#include "eventprompt.h"
#include "resource.h"
#include "wiacsh.h"
#include "psutil.h"
//


#define COL_NAME           0
#define COL_DESCRIPTION    1

const UINT c_auTileColumns[] = {COL_NAME, COL_DESCRIPTION};
const UINT c_auTileSubItems[] = {COL_DESCRIPTION};

static const DWORD HelpIds [] =
{
    IDC_EVENTNAME, IDH_WIA_EVENT_OCCURRED,
    IDC_HANDLERLIST, IDH_WIA_PROGRAM_LIST,
    IDC_NOPROMPT, IDH_WIA_ALWAYS_USE,
    IDOK, IDH_OK,
    IDCANCEL, IDH_CANCEL,
    0,0
};

INT_PTR CALLBACK
CEventPromptDlg::DlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    CEventPromptDlg *pThis;
    pThis = reinterpret_cast<CEventPromptDlg*>(GetWindowLongPtr(hwnd,DWLP_USER));
    switch (msg)
    {
        case WM_INITDIALOG:

            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            pThis = reinterpret_cast<CEventPromptDlg*>(lp);
            pThis->m_hwnd = hwnd;
            pThis->OnInit ();
            
            //
            // Initially disable the OK button, unless there is something selected
            //
            EnableWindow(GetDlgItem(hwnd,IDOK),(0!=ListView_GetSelectedCount(GetDlgItem(hwnd,IDC_HANDLERLIST))));

            return TRUE;

        case WM_COMMAND:
            if (pThis)
            {
                return pThis->OnCommand(HIWORD(wp), LOWORD(wp));
            }
            break;

        case WM_DESTROY:
            {
                //
                // Delete the listview's image list
                //
                HIMAGELIST hImageList = ListView_SetImageList(GetDlgItem(hwnd,IDC_HANDLERLIST), NULL, LVSIL_NORMAL);
                if (hImageList)
                {
                    ImageList_Destroy(hImageList);
                }

                if (pThis)
                {
                    pThis->m_PromptData->Close();
                }

                SetWindowLongPtr(hwnd, DWLP_USER, NULL);
            }
            return TRUE;

        case WM_HELP:
            WiaHelp::HandleWmHelp( wp, lp, HelpIds );
            return TRUE;

        case WM_CONTEXTMENU:
            WiaHelp::HandleWmContextMenu( wp, lp, HelpIds );
            return TRUE;

        case WM_NOTIFY:
             {
                 //
                 // Get the notification struct
                 //
                 NMHDR *pNmHdr = reinterpret_cast<NMHDR*>(lp);
                 if (pNmHdr)
                 {
                     //
                     // Is this the handler listview?
                     //
                     if (IDC_HANDLERLIST == pNmHdr->idFrom)
                     {
                         //
                         // Get the listview notification stuff
                         //
                         NMLISTVIEW *pNmListView = reinterpret_cast<NMLISTVIEW*>(lp);

                         //
                         // If this is an item changed notification message
                         //
                         if (LVN_ITEMCHANGED == pNmHdr->code)
                         {
                             //
                             // If the state changed
                             //
                             if (pNmListView->uChanged & LVIF_STATE)
                             {
                                 //
                                 // Enable the OK button iff there is a selected item
                                 //
                                 EnableWindow(GetDlgItem(hwnd,IDOK),(0!=ListView_GetSelectedCount(GetDlgItem(hwnd,IDC_HANDLERLIST))));
                                 return TRUE;
                             }
                         }
                         //
                         // Double click?
                         //
                         else if (NM_DBLCLK == pNmHdr->code)
                         {
                             //
                             // Check to make sure something is selected
                             //
                             if (ListView_GetSelectedCount(GetDlgItem(hwnd,IDC_HANDLERLIST)))
                             {
                                 //
                                 // Simulate an OK message
                                 //
                                 SendMessage( hwnd, WM_COMMAND, MAKEWPARAM(IDOK,BN_CLICKED), 0 );
                                 return TRUE;
                             }
                         }

                         //
                         // Deleting an item
                         //
                         else if (LVN_DELETEITEM == pNmHdr->code)
                         {
                             //
                             // Get the event data
                             //
                             WIA_EVENT_HANDLER *peh = reinterpret_cast<WIA_EVENT_HANDLER*>(pNmListView->lParam);
                             if (peh)
                             {
                                 //
                                 // Free the bstrings
                                 //
                                 if (peh->bstrDescription)
                                 {
                                     SysFreeString (peh->bstrDescription);
                                 }
                                 if (peh->bstrIcon)
                                 {
                                     SysFreeString (peh->bstrIcon);
                                 }
                                 if (peh->bstrName)
                                 {
                                     SysFreeString (peh->bstrName);
                                 }

                                 //
                                 // Free the structure
                                 //
                                 delete peh;
                             }
                             return TRUE;
                         }
                     }
                 }
             }
             break;

        default:
            break;
    }
    return FALSE;
}

void
CEventPromptDlg::OnInit ()
{
    WIA_PUSHFUNCTION(TEXT("CEventPromptDlg::OnInit"));
    // update the shared memory section indicating we exist
    // use a unique name for  the shared memory
    LPWSTR wszGuid;
    StringFromCLSID (m_pEventParameters->EventGUID, &wszGuid);
    CSimpleStringWide strSection(wszGuid);
    strSection.Concat (m_pEventParameters->strDeviceID);
    CoTaskMemFree (wszGuid);
    m_PromptData = new CSharedMemorySection<HWND>(CSimpleStringConvert::NaturalString(strSection), true);
    if (m_PromptData)
    {
        HWND *pData = m_PromptData->Lock();
        if (pData)
        {
            *pData = m_hwnd;
            m_PromptData->Release();
        }
    }
    // fill in the list of handlers
    m_pList = new CHandlerList (GetDlgItem(m_hwnd, IDC_HANDLERLIST));
    if (m_pList)
    {
        m_pList->FillList (m_pEventParameters->strDeviceID,
                           m_pEventParameters->EventGUID);

    }
    // Set the dialog's caption to be the name of the device
    SetWindowText (m_hwnd, CSimpleStringConvert::NaturalString(m_pEventParameters->strDeviceDescription));

    // Set the event description text
    SetDlgItemText (m_hwnd, IDC_EVENTNAME, CSimpleStringConvert::NaturalString(m_pEventParameters->strEventDescription));

    //
    // Disable the "always make this the handler" checkbox for low privilege users
    SC_HANDLE hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

    if (!hSCM) 
    {
        EnableWindow(GetDlgItem(m_hwnd, IDC_NOPROMPT), FALSE);
    }
    else
    {
        CloseServiceHandle(hSCM);
    }
}


INT_PTR
CEventPromptDlg::OnCommand (WORD wCode, WORD widItem)
{
    INT_PTR iRet = TRUE;
    // we only care about IDOK or IDCANCEL

    switch (widItem)
    {
        case IDOK:
            iRet = OnOK ();
            if (!iRet)
            {
                break;;
            }
            // fall through
        case IDCANCEL:
            EndDialog (m_hwnd, 1);
            break;
    }
    return iRet;
}


// When the user presses OK, invoke the selected application and make it
// the default if requested
INT_PTR
CEventPromptDlg::OnOK ()
{
    WIA_PUSHFUNCTION(TEXT("CEventPromptDlg::OnOK"));
    WIA_EVENT_HANDLER *pSelHandler = NULL;
    if (m_pList)
    {
        pSelHandler = m_pList->GetSelectedHandler ();
    }
    if (pSelHandler)
    {
        if (IsDlgButtonChecked (m_hwnd, IDC_NOPROMPT))
        {
            // Set this handler as the default
            SetDefaultHandler (pSelHandler);
        }
        if (!InvokeHandler(pSelHandler))
        {
            WIA_ERROR((TEXT("InvokeHandler failed")));
            return FALSE;
        }
    }
    return TRUE;
}


void
CEventPromptDlg::SetDefaultHandler (WIA_EVENT_HANDLER *pHandler)
{
    WIA_PUSHFUNCTION(TEXT("CEventPromptDlg::SetDefaultHandler"));
    CComPtr<IWiaDevMgr> pDevMgr;


    if (SUCCEEDED(CoCreateInstance (CLSID_WiaDevMgr,
                                    NULL,
                                    CLSCTX_LOCAL_SERVER,
                                    IID_IWiaDevMgr,
                                    reinterpret_cast<LPVOID*>(&pDevMgr))))
    {


            pDevMgr->RegisterEventCallbackCLSID (WIA_SET_DEFAULT_HANDLER,
                                                 CComBSTR(m_pEventParameters->strDeviceID),
                                                 &m_pEventParameters->EventGUID,
                                                 &pHandler->guid,
                                                 pHandler->bstrName,
                                                 pHandler->bstrDescription,
                                                 pHandler->bstrIcon);


    }
}

bool
CEventPromptDlg::InvokeHandler(WIA_EVENT_HANDLER *pHandler)
{
    WIA_PUSHFUNCTION(TEXT("CEventPromptDlg::InvokeHandler"));
    CComPtr<IWiaEventCallback> pCallback;

    if (pHandler->bstrCommandline) {

        PROCESS_INFORMATION pi = {0};
        
        STARTUPINFO si = {0};
        si.cb = sizeof(si);
        si.wShowWindow = SW_SHOW;

        TCHAR szCommand[MAX_PATH*2] = {0};
        

        #ifdef UNICODE
        lstrcpynW( szCommand, pHandler->bstrCommandline, ARRAYSIZE(szCommand) );
        #else
        WideCharToMultiByte (CP_ACP, 0,
                             pHandler->bstrCommandline, -1,
                             szCommand, ARRAYSIZE(szCommand),
                             NULL, NULL);
        #endif

        // Trace(TEXT("Command line for STI app is %s"), szCommand);
        if (CreateProcess (NULL,
                           szCommand,
                           NULL,
                           NULL,
                           FALSE,
                           0,
                           NULL,
                           NULL,
                           &si,
                           &pi))
        {
            CloseHandle (pi.hProcess);
            CloseHandle (pi.hThread);

            return true;
        }
        else
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("Execution of pHandler->bstrCommandline [%ws] FAILED"),pHandler->bstrCommandline));
        }
    }
    else
    {

        HRESULT hr = CoCreateInstance(pHandler->guid,
                                       NULL,
                                       CLSCTX_LOCAL_SERVER,
                                       IID_IWiaEventCallback,
                                       reinterpret_cast<LPVOID*>(&pCallback));
        if (SUCCEEDED(hr))
        {
            hr = pCallback->ImageEventCallback (&m_pEventParameters->EventGUID,
                                                CComBSTR(m_pEventParameters->strEventDescription),
                                                CComBSTR(m_pEventParameters->strDeviceID),
                                                CComBSTR(m_pEventParameters->strDeviceDescription),
                                                m_pEventParameters->dwDeviceType,
                                                CComBSTR(m_pEventParameters->strFullItemName),
                                                &m_pEventParameters->ulEventType,
                                                m_pEventParameters->ulReserved);

        }
        if (FAILED(hr))
        {
            // inform the user something went wrong
            UIErrors::ReportMessage(m_hwnd,g_hInstance,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_HANDLERERR_CAPTION),
                                    MAKEINTRESOURCE(IDS_HANDLERERR),
                                    MB_OK);

        }
        else
        {
            return true;
        }
    }

    return false;

}


// Parse the bstrIconPath to get the image name and resource id
// Note that -1 is not a valid id for ExtractIconEx
int
AddIconToImageList (HIMAGELIST himl, BSTR bstrIconPath)
{
    if (!bstrIconPath)
    {
        return 0;
    }

    int iRet = 0;

    //
    // Convert the bstr to a normal string
    //
    CSimpleString strIconPath = CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrIconPath));
    if (strIconPath.Length())
    {
        //
        // Find the last comma in the string
        //
        int nComma = strIconPath.ReverseFind(TEXT(","));
        if (nComma != -1)
        {
            //
            // Convert whatever comes after the comma to a LONG
            //
            LONG nIcon = _tcstol( strIconPath.SubStr( nComma + 1 ), NULL, 10 );

            //
            // Get the path
            //
            CSimpleString strPath = strIconPath.Left( nComma );
            if (strPath.Length())
            {
                //
                // Get the icon
                //
                HICON hIcon = NULL;
                ExtractIconEx( strPath, nIcon, &hIcon, NULL, 1);

                //
                // Add it to the image list and nuke the icon
                //
                if (hIcon)
                {
                    iRet = ImageList_AddIcon (himl, hIcon);
                    DestroyIcon (hIcon);
                }
            }
        }
    }
    return iRet;
}

static int CALLBACK HandlerListCompareFunction( LPARAM lParam1, LPARAM lParam2, LPARAM )
{
    int nResult = 0;
    LVITEM *pItem1 = reinterpret_cast<LVITEM*>(lParam1);
    LVITEM *pItem2 = reinterpret_cast<LVITEM*>(lParam2);
    if (pItem1 && pItem2 && pItem1->pszText && pItem2->pszText)
    {
        int nCompareResult = CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, pItem1->pszText, -1, pItem2->pszText, -1 );
        switch (nCompareResult)
        {
        case CSTR_LESS_THAN:
            nResult = -1;
            break;
        case CSTR_GREATER_THAN:
            nResult = 1;
            break;
        }
    }
    return nResult;
}

// Enumerate the installed handlers for the event and add them to the listview
// return the number of handlers we added
UINT
CHandlerList::FillList (const CSimpleStringWide &strDeviceId, GUID &guidEvent)
{
    WIA_PUSHFUNCTION(TEXT("CHandlerList::FillList"));
    CComPtr<IWiaDevMgr> pDevMgr;
    CComPtr<IWiaItem> pItem;
    UINT uRet = 0;
    //
    // Remove all existing items
    //
    ListView_DeleteAllItems(m_hwnd);
    if (SUCCEEDED(CoCreateInstance( CLSID_WiaDevMgr,
                                    NULL,
                                    CLSCTX_LOCAL_SERVER,
                                    IID_IWiaDevMgr,
                                    reinterpret_cast<LPVOID*>(&pDevMgr))))
    {
        if (SUCCEEDED(pDevMgr->CreateDevice(CComBSTR(strDeviceId.String()),
                                            &pItem)))
        {
            RECT rc = {0};
            LVTILEVIEWINFO lvtvi = {0};
            // set up the listview style
            ListView_SetView(m_hwnd, LV_VIEW_TILE);
            for (int i = 0; i < ARRAYSIZE(c_auTileColumns); ++i)
            {
                LVCOLUMN lvcolumn = {0};

                lvcolumn.mask = LVCF_SUBITEM;
                lvcolumn.iSubItem = c_auTileColumns[i];
                ListView_InsertColumn(m_hwnd, i, &lvcolumn);
            }

            GetClientRect(m_hwnd, &rc);

            lvtvi.cbSize = sizeof(lvtvi);
            lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS;
            lvtvi.dwFlags = LVTVIF_FIXEDWIDTH;
    
            // Leave room for the scroll bar when setting tile sizes or listview gets screwed up.
            lvtvi.sizeTile.cx = ((rc.right - rc.left) - GetSystemMetrics(SM_CXVSCROLL));
            lvtvi.cLines = ARRAYSIZE(c_auTileSubItems);
            ListView_SetTileViewInfo(m_hwnd, &lvtvi);

            CComPtr<IEnumWIA_DEV_CAPS> pEnum;
            if (SUCCEEDED(pItem->EnumRegisterEventInfo(0,
                                                       &guidEvent,
                                                       &pEnum)) )
            {

                WIA_EVENT_HANDLER *pHandler;
                ULONG ul;
                LVITEM lvi = {0};
                HICON hicon;
                HRESULT hr = NOERROR;
                CSimpleString strText;
                // Create a new imagelist
                HIMAGELIST hImageList = ImageList_Create (GetSystemMetrics(SM_CXICON),
                                           GetSystemMetrics(SM_CYICON),
                                           PrintScanUtil::CalculateImageListColorDepth() | ILC_MASK,
                                           2,
                                           2);
                // Add the "default" icon
                hicon =reinterpret_cast<HICON>(LoadImage (g_hInstance,
                                                          MAKEINTRESOURCE(IDI_SCANCAM),
                                                          IMAGE_ICON,
                                                          GetSystemMetrics(SM_CXICON),
                                                          GetSystemMetrics(SM_CYICON),
                                                          LR_SHARED | LR_DEFAULTCOLOR));
                ImageList_AddIcon (hImageList, hicon);
                SendMessage (m_hwnd, LVM_SETIMAGELIST, LVSIL_NORMAL,
                             reinterpret_cast<LPARAM>(hImageList));
                // enum the items and add them to the listview
                
                lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;

                while (S_OK == hr)
                {
                    pHandler = new WIA_EVENT_HANDLER;
                    if (!pHandler)
                    {
                        break;
                    }
                    hr = pEnum->Next (1, pHandler, &ul);

                    if (IsEqualCLSID(pHandler->guid, CLSID_EventPrompter) ||
                        IsEqualCLSID(pHandler->guid, WIA_EVENT_HANDLER_NO_ACTION) ||
                        IsEqualCLSID(pHandler->guid, WIA_EVENT_HANDLER_PROMPT) ||
                        !CSimpleStringWide(pHandler->bstrName).CompareNoCase(L"Internal"))
                    {
                        delete pHandler;
                        continue;
                    }

                    if (S_OK == hr)
                    {
                        // get the string
                        strText = CSimpleStringConvert::NaturalString (CSimpleStringWide(pHandler->bstrName));
                        lvi.pszText = const_cast<LPTSTR>(strText.String());
                        lvi.lParam = reinterpret_cast<LPARAM>(pHandler);
                        // get the icon
                        lvi.iImage = AddIconToImageList (hImageList, pHandler->bstrIcon);
                        // get the index
                        lvi.iItem = ListView_GetItemCount(m_hwnd);
                        // add the item
                        int nIndex = ListView_InsertItem(m_hwnd, &lvi);
                        if (-1 != nIndex)
                        {   
                            // add the description subitem
                            strText = CSimpleStringConvert::NaturalString (CSimpleStringWide(pHandler->bstrDescription));
                            LVTILEINFO lvti = {0};
                            lvti.cbSize = sizeof(LVTILEINFO);
                            lvti.iItem = nIndex;
                            lvti.cColumns = 1;
                            lvti.puColumns = (UINT*)c_auTileSubItems;
                            ListView_SetTileInfo(m_hwnd, &lvti);
                            ListView_SetItemText(m_hwnd, nIndex, 1, (LPTSTR)strText.String());
                            uRet++;
                        }
                    }
                    else
                    {
                        if (pHandler)
                        {
                            delete pHandler;
                        }
                    }
                }

                // Sort the list
                ListView_SortItems( m_hwnd, HandlerListCompareFunction, 0 );

                // set the default to the first item
                lvi.iItem = 0;
                lvi.mask = LVIF_STATE;
                lvi.stateMask = LVIS_FOCUSED|LVIS_SELECTED;
                lvi.state = LVIS_FOCUSED|LVIS_SELECTED;
                ListView_SetItem(m_hwnd, &lvi);
                ListView_EnsureVisible(m_hwnd, lvi.iItem, FALSE);
            }
        }
    }
    return uRet;
}

WIA_EVENT_HANDLER *
CHandlerList::GetSelectedHandler ()
{
    WIA_PUSHFUNCTION(TEXT("CHandlerList::GetSelectedHandler"));
    WIA_EVENT_HANDLER *pRet = NULL;

    int nIndex = ListView_GetNextItem( m_hwnd, -1, LVNI_SELECTED );
    if (-1 != nIndex)
    {
        LVITEM lvi = {0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = nIndex;
        if (ListView_GetItem(m_hwnd, &lvi))
        {
            pRet = reinterpret_cast<WIA_EVENT_HANDLER*>(lvi.lParam);
        }
    }
    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\flnfile.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "flnfile.h"

bool NumberedFileName::DoesFileExist( LPCTSTR pszFilename )
{
    WIA_PUSH_FUNCTION((TEXT("NumberedFileName::DoesFileExist(%s"), pszFilename ));
    bool bExists = false;
    WIN32_FIND_DATA FindFileData;
    ZeroMemory( &FindFileData, sizeof(FindFileData));
    HANDLE hFindFiles = FindFirstFile( pszFilename, &FindFileData );
    if (hFindFiles != INVALID_HANDLE_VALUE)
    {
        bExists = true;
        FindClose(hFindFiles);
    }
    return bExists;
}

bool NumberedFileName::ConstructFilename( LPTSTR szFile, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension )
{
    *szFile = TEXT('\0');

    if (pszDirectory && *pszDirectory)
    {
        //
        // Start with the directory name
        //
        lstrcpyn( szFile + lstrlen(szFile), pszDirectory, MAX_PATH-lstrlen(szFile) );

        //
        // Ensure there is a trailing slash on the filename
        //
        if (!CSimpleString(szFile).MatchLastCharacter(TEXT('\\')))
        {
            lstrcpyn( szFile + lstrlen(szFile), TEXT("\\"), MAX_PATH-lstrlen(szFile) );
        }
    }

    if (pszFilename && *pszFilename)
    {
        // Append the filename
        lstrcpyn( szFile + lstrlen(szFile), pszFilename, MAX_PATH-lstrlen(szFile) );
    }

    if (pszNumberFormat && *pszNumberFormat)
    {
        // Append a space
        lstrcpyn( szFile + lstrlen(szFile), TEXT(" "), MAX_PATH-lstrlen(szFile) );

        // Append the printf-style number format string
        lstrcpyn( szFile + lstrlen(szFile), pszNumberFormat, MAX_PATH-lstrlen(szFile) );

    }

    if (pszExtension && *pszExtension)
    {
        // Append the extension's . if necessary
        if (*pszExtension != TEXT('.'))
        {
            lstrcpyn( szFile + lstrlen(szFile), TEXT("."), MAX_PATH-lstrlen(szFile) );
        }

        // Append the extension
        lstrcpyn( szFile + lstrlen(szFile), pszExtension, MAX_PATH-lstrlen(szFile) );
    }

    return(lstrlen(szFile) != 0);
}

int NumberedFileName::FindLowestAvailableFileSequence( LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, bool bAllowUnnumberedFile, int nCount, int nStart )
{
    WIA_PUSH_FUNCTION((TEXT("NumberedFileName::FindLowestAvailableFileSequence(%s, %s, %s, %d, %d, %d"), pszDirectory, pszFilename, pszNumberFormat, bAllowUnnumberedFile, nCount, nStart ));
    if (!pszDirectory || !pszFilename || !pszNumberFormat || !nCount || !*pszDirectory || !*pszFilename || !*pszNumberFormat)
        return -1;

    TCHAR szFile[MAX_PATH + 10]=TEXT("");

    if (nCount == 1 && bAllowUnnumberedFile)
    {
        if (ConstructFilename(szFile,pszDirectory,pszFilename,NULL,TEXT("*")))
        {
            if (!DoesFileExist(szFile))
            {
                // 0 is a special return value that says "Don't put a number on this file"
                return 0;
            }
        }
    }

    int i=nStart;
    //
    // Make sure i is a valid number
    //
    if (i <= 0)
    {
        i = 1;
    }
    while (i<0x7FFFFFFF)
    {
        //
        // Assume we'll be able to store the sequence
        //
        bool bEnoughRoom = true;
        for (int j=0;j<nCount && bEnoughRoom;j++)
        {
            TCHAR szNumber[24];
            if (wnsprintf( szNumber, ARRAYSIZE(szNumber), pszNumberFormat, i+j ) >= 0)
            {
                if (ConstructFilename(szFile,pszDirectory,pszFilename,szNumber,TEXT("*")))
                {
                    if (DoesFileExist(szFile))
                    {
                        //
                        // Didn't make it
                        //
                        bEnoughRoom = false;

                        //
                        // Skip this series.  No need to start at the bottom.
                        //
                        i += j;
                    }
                }
            }
        }

        //
        // If we made it through, return the base number, otherwise increment by one
        //
        if (bEnoughRoom)
        {
            return i;
        }
        else i++;
    }

    return -1;
}

bool NumberedFileName::CreateNumberedFileName( DWORD dwFlags, LPTSTR pszPathName, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension, int nNumber )
{
    if (nNumber == 0)
    {
        return ConstructFilename(pszPathName,
                                 (dwFlags&FlagOmitDirectory) ? NULL : pszDirectory,
                                 pszFilename,
                                 NULL,
                                 (dwFlags&FlagOmitExtension) ? NULL : pszExtension);
    }
    else
    {
        TCHAR szNumber[24];
        if (wnsprintf( szNumber, ARRAYSIZE(szNumber), pszNumberFormat, nNumber ) >= 0)
        {
            return ConstructFilename(pszPathName,
                                     (dwFlags&FlagOmitDirectory) ? NULL : pszDirectory,
                                     pszFilename,
                                     szNumber,
                                     (dwFlags&FlagOmitExtension) ? NULL : pszExtension);
        }
    }
    return false;
}

int NumberedFileName::GenerateLowestAvailableNumberedFileName( DWORD dwFlags, LPTSTR pszPathName, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension, bool bAllowUnnumberedFile, int nStart )
{
    //
    // -1 is an error.  Default to failure
    //
    int nResult = -1;

    //
    // Find the lowest available file number
    //
    int nLowest = FindLowestAvailableFileSequence( pszDirectory, pszFilename, pszNumberFormat, bAllowUnnumberedFile, 1, nStart );
    if (nLowest >= 0)
    {
        //
        // If we can create the filename, return the number of the file
        //
        if (CreateNumberedFileName( dwFlags, pszPathName, pszDirectory, pszFilename, pszNumberFormat, pszExtension, nLowest ))
        {
            //
            // Return the file's number
            //
            nResult = nLowest;
        }
    }
    return nResult;
}

int NumberedFileName::FindHighestNumberedFile( LPCTSTR pszDirectory, LPCTSTR pszFilename )
{
    WIA_PUSH_FUNCTION((TEXT("NumberedFileName::FindHighestNumberedFile( %s, %s )"), pszDirectory, pszFilename ));
    //
    // Make sure we have reasonable args
    //
    if (!pszFilename || !pszDirectory || !*pszFilename || !*pszDirectory)
    {
        return -1;
    }

    //
    // Assume we won't be finding any files
    //
    int nHighest = 0;

    //
    // Construct a filename that looks like this: c:\path\file*.*
    //
    TCHAR szFile[MAX_PATH*2] = TEXT("");
    if (ConstructFilename(szFile,pszDirectory,pszFilename,TEXT("*"),TEXT("*")))
    {

        //
        // Find the first file which matches the path and wildcards
        //
        WIN32_FIND_DATA FindFileData = {0};
        HANDLE hFindFiles = FindFirstFile( szFile, &FindFileData );
        if (hFindFiles != INVALID_HANDLE_VALUE)
        {
            //
            // Loop while there are more matching files
            //
            BOOL bSuccess = TRUE;
            while (bSuccess)
            {
                //
                // Make sure the filename is long enough
                //
                WIA_TRACE((TEXT("FindFileData.cFileName: %s"), FindFileData.cFileName ));
                if (lstrlen(FindFileData.cFileName) >= lstrlen(pszFilename))
                {
                    //
                    // Copy the filename to a temp buffer MINUS the filename portion,
                    // so "c:\path\file 001.jpg" becomes " 001.jpg"
                    //
                    TCHAR szFoundFile[MAX_PATH] = TEXT("");
                    if (lstrcpyn( szFoundFile, FindFileData.cFileName+lstrlen(pszFilename), ARRAYSIZE(szFoundFile)-lstrlen(pszFilename)))
                    {
                        //
                        // Remove the extension, so
                        // " 001.jpg" becomes " 001"
                        //
                        PathRemoveExtension(szFoundFile);

                        //
                        // Remove spaces, so " 001" becomes "001"
                        //
                        StrTrim(szFoundFile,TEXT(" "));
                        WIA_TRACE((TEXT("szFoundFile: %s"), szFoundFile ));

                        //
                        // Convert the string to a number
                        //
                        int nCurrNumber = 0;
                        if (StrToIntEx(szFoundFile,STIF_DEFAULT,&nCurrNumber))
                        {
                            //
                            // Replace our current high if this one exceeds it
                            //
                            if (nCurrNumber > nHighest)
                            {
                                nHighest = nCurrNumber;
                            }
                        }
                    }
                }

                //
                // Continue finding files
                //
                bSuccess = FindNextFile( hFindFiles, &FindFileData );

            }

            //
            // Prevent handle leaks
            //
            FindClose(hFindFiles);
        }
    }

    WIA_TRACE((TEXT("nHighest: %d"), nHighest ));
    return nHighest+1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\flnfile.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       FLNFILE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/13/1999
 *
 *  DESCRIPTION: Find the lowest numbered files in a given directory with a given
 *               root filename.
 *
 *******************************************************************************/
#ifndef __FLNFILE_H_INCLUDED
#define __FLNFILE_H_INCLUDED

#include <windows.h>

namespace NumberedFileName
{
    enum
    {
        FlagOmitDirectory = 0x0000001,
        FlagOmitExtension = 0x0000002
    };
    bool DoesFileExist( LPCTSTR pszFilename );
    bool ConstructFilename( LPTSTR szFile, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension );
    int FindLowestAvailableFileSequence( LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, bool bAllowUnnumberedFile, int nCount, int nStart=1 );
    bool CreateNumberedFileName( DWORD dwFlags, LPTSTR pszPathName, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension, int nNumber );
    int GenerateLowestAvailableNumberedFileName( DWORD dwFlags, LPTSTR pszPathName, LPCTSTR pszDirectory, LPCTSTR pszFilename, LPCTSTR pszNumberFormat, LPCTSTR pszExtension, bool bAllowUnnumberedFile, int nStart=1 );
    int FindHighestNumberedFile( LPCTSTR pszDirectory, LPCTSTR pszFilename );
}

#endif __FLNFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\mintrans.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MINTRANS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/6/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
// mintrans.h : Declaration of the minimal transfer component

#ifndef __MINTRANS_H_INCLUDED
#define __MINTRANS_H_INCLUDED

#include <windows.h>

extern LRESULT MinimalTransferThreadProc( BSTR bstrDeviceId );

#endif //__MINTRANS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\precomp.h ===
// precomp.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#if !defined(AFX_precomp_H__29EDE425_AA9D_4D61_885A_F8A87EBFE078__INCLUDED_)
#define AFX_precomp_H__29EDE425_AA9D_4D61_885A_F8A87EBFE078__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <uicommon.h>
#include <commctrl.h>
#include <wia.h>
#include <sti.h>
#include <wiavideo.h>
#include <shfusion.h>
#include <shpriv.h>
#include <shlwapi.h>
#include <shlwapip.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
    LONG Unlock();
    DWORD dwThreadID;
    HANDLE hEventShutdown;
    void MonitorShutdown();
    bool StartMonitor();
    bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>


extern HINSTANCE g_hInstance;


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_precomp_H__29EDE425_AA9D_4D61_885A_F8A87EBFE078__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\mru.h ===
#ifndef __MRU_H_INCLUDED
#define __MRU_H_INCLUDED

#include <windows.h>
#include <shlobj.h>
#include <wiacrc32.h>
#include "simstr.h"
#include "simidlst.h"
#include "destdata.h"

#define CURRENT_REGISTRY_DATA_FORMAT_VERSION 3

class CMruStringList : public CSimpleLinkedList<CSimpleString>
{
private:
    int m_nNumToWrite;
    enum
    {
        DefaultNumToWrite=20
    };
private:
    CMruStringList( const CMruStringList & );
    CMruStringList &operator=( const CMruStringList & );
public:
    CMruStringList( int nNumToWrite=DefaultNumToWrite )
    : m_nNumToWrite(nNumToWrite)
    {
    }
    bool Read( HKEY hRoot, LPCTSTR pszKey, LPCTSTR pszValueName )
    {
        CSimpleReg reg( hRoot, pszKey, false, KEY_READ );
        if (reg.OK())
        {
            if (REG_MULTI_SZ==reg.Type(pszValueName))
            {
                int nSize = reg.Size(pszValueName);
                if (nSize)
                {
                    PBYTE pData = new BYTE[nSize];
                    if (pData)
                    {
                        if (reg.QueryBin( pszValueName, pData, nSize ))
                        {
                            for (LPTSTR pszCurr=reinterpret_cast<LPTSTR>(pData);*pszCurr;pszCurr+=lstrlen(pszCurr)+1)
                            {
                                Append( pszCurr );
                            }
                        }
                        delete[] pData;
                    }
                }
            }
        }
        return(true);
    }
    bool Write( HKEY hRoot, LPCTSTR pszKey, LPCTSTR pszValueName )
    {
        CSimpleReg reg( hRoot, pszKey, true, KEY_WRITE );
        if (reg.OK())
        {
            int nLengthInChars = 0, nCount;
            Iterator i;
            for (i=Begin(),nCount=0;i != End() && nCount < m_nNumToWrite;++i,++nCount)
                nLengthInChars += (*i).Length() + 1;
            if (nLengthInChars)
            {
                ++nLengthInChars;
                LPTSTR pszMultiStr = new TCHAR[nLengthInChars];
                if (pszMultiStr)
                {
                    LPTSTR pszCurr = pszMultiStr;
                    for (i = Begin(), nCount=0;i != End() && nCount < m_nNumToWrite;++i,++nCount)
                    {
                        lstrcpy(pszCurr,(*i).String());
                        pszCurr += (*i).Length() + 1;
                    }
                    *pszCurr = TEXT('\0');
                    reg.SetBin( pszValueName, reinterpret_cast<PBYTE>(pszMultiStr), nLengthInChars*sizeof(TCHAR), REG_MULTI_SZ );
                    delete[] pszMultiStr;
                }
            }
        }
        return(true);
    }
    void Add( CSimpleString str )
    {
        if (str.Length())
        {
            Remove(str);
            Prepend(str);
        }
    }
    void PopulateComboBox( HWND hWnd )
    {
        SendMessage( hWnd, CB_RESETCONTENT, 0, 0 );
        for (Iterator i = Begin();i != End();++i)
        {
            SendMessage( hWnd, CB_ADDSTRING, 0, (LPARAM)((*i).String()));
        }
    }
};


class CMruDestinationData : public CSimpleLinkedList<CDestinationData>
{
private:
    int m_nNumToWrite;
    enum
    {
        DefaultNumToWrite=20
    };
    struct REGISTRY_SIGNATURE
    {
        DWORD dwSize;
        DWORD dwVersion;
        DWORD dwCount;
        DWORD dwCrc;
    };
private:
    CMruDestinationData( const CMruDestinationData & );
    CMruDestinationData &operator=( const CMruDestinationData & );
public:
    CMruDestinationData( int nNumToWrite=DefaultNumToWrite )
      : m_nNumToWrite(nNumToWrite)
    {
    }
    bool Read( HKEY hRoot, LPCTSTR pszKey, LPCTSTR pszValueName )
    {
        //
        // Open the registry
        //
        CSimpleReg reg( hRoot, pszKey, false, KEY_READ );
        if (reg.OK())
        {
            //
            //  Make sure the type is correct
            //
            if (REG_BINARY==reg.Type(pszValueName))
            {
                //
                // Get the size and make sure it is at least as large as the signature structure
                //
                DWORD nSize = reg.Size(pszValueName);
                if (nSize >= sizeof(REGISTRY_SIGNATURE))
                {
                    //
                    // Allocate a block to hold the data
                    //
                    PBYTE pData = new BYTE[nSize];
                    if (pData)
                    {
                        //
                        // Get the data
                        //
                        if (reg.QueryBin( pszValueName, pData, nSize ))
                        {
                            //
                            // Copy the blob to a registry signature structure
                            //
                            REGISTRY_SIGNATURE RegistrySignature = {0};
                            CopyMemory( &RegistrySignature, pData, sizeof(REGISTRY_SIGNATURE) );

                            //
                            // Make sure the version and struct size are correct, and the count is non-zero.  Just ignore it if it isn't.
                            //
                            if (RegistrySignature.dwSize == sizeof(REGISTRY_SIGNATURE) && RegistrySignature.dwVersion == CURRENT_REGISTRY_DATA_FORMAT_VERSION && RegistrySignature.dwCount)
                            {
                                //
                                // Raw data starts at the end of the structure
                                //
                                PBYTE pCurr = pData + sizeof(REGISTRY_SIGNATURE);

                                //
                                // Get the CRC for this blob and make sure it matches
                                //
                                DWORD dwCrc = WiaCrc32::GenerateCrc32( nSize - sizeof(REGISTRY_SIGNATURE), pCurr );
                                if (dwCrc == RegistrySignature.dwCrc)
                                {
                                    //
                                    // Loop through all of the entries
                                    //
                                    for (int i=0;i<static_cast<int>(RegistrySignature.dwCount);i++)
                                    {
                                        //
                                        // Copy the item size
                                        //
                                        DWORD dwItemSize = 0;
                                        CopyMemory( &dwItemSize, pCurr, sizeof(DWORD) );

                                        //
                                        // Increment the current pointer beyond the size
                                        //
                                        pCurr += sizeof(DWORD);

                                        //
                                        // Make sure the item size is non-zero
                                        //
                                        if (dwItemSize)
                                        {
                                            //
                                            // Create a CDestinationData with this blob
                                            //
                                            CDestinationData DestinationData;
                                            DestinationData.SetRegistryData(pCurr,dwItemSize);

                                            //
                                            // Add it to the list
                                            //
                                            Append( DestinationData );
                                        }

                                        //
                                        // Increment the current pointer to the end of the blob
                                        //
                                        pCurr += dwItemSize;
                                    }
                                }
                            }
                        }

                        //
                        // Delete the registry data blob
                        //
                        delete[] pData;
                    }
                }
            }
        }
        
        return true;
    }
    bool Write( HKEY hRoot, LPCTSTR pszKey, LPCTSTR pszValueName )
    {
        CSimpleReg reg( hRoot, pszKey, true, KEY_WRITE );
        if (reg.OK())
        {
            //
            // Find the size needed for the data.  Initialize to the size of the registry signature struct.
            //
            DWORD nLengthInBytes = sizeof(REGISTRY_SIGNATURE);
            DWORD dwCount=0;
            
            //
            // Loop through each item and add up the number of bytes required to store it as a blob
            //
            Iterator ListIter=Begin();
            while (ListIter != End() && dwCount < static_cast<DWORD>(m_nNumToWrite))
            {
                nLengthInBytes += (*ListIter).RegistryDataSize() + sizeof(DWORD);
                ++dwCount;
                ++ListIter;
            }
            
            //
            // Allocate some memory to hold the blob
            //
            PBYTE pItems = new BYTE[nLengthInBytes];
            if (pItems)
            {
                //
                // Start at the end of the registry signature struct
                //
                PBYTE pCurr = pItems + sizeof(REGISTRY_SIGNATURE);
                
                //
                // Initialize the length remaining to the total length minus the size of the registry signature struct
                //
                DWORD nLengthRemaining = nLengthInBytes - sizeof(REGISTRY_SIGNATURE);
                
                //
                // Loop through the list, stopping when we get to the max number of items to write
                //
                ListIter=Begin();
                DWORD dwCurr = 0;
                while (ListIter != End() && dwCurr < dwCount)
                {
                    //
                    // Get the size of this blob
                    //
                    DWORD dwSize = (*ListIter).RegistryDataSize();
                    if (dwSize)
                    {
                        //
                        // Copy the size to our buffer, and increment the current pointer
                        //
                        CopyMemory( pCurr, &dwSize, sizeof(DWORD) );
                        pCurr += sizeof(DWORD);

                        //
                        // Get the blob for this item
                        //
                        (*ListIter).GetRegistryData( pCurr, nLengthRemaining );

                        //
                        // Increment the current pointer
                        //
                        pCurr += (*ListIter).RegistryDataSize();
                    }

                    ++dwCurr;
                    ++ListIter;
                }
                
                //
                // Initialize the registry signature struct
                //
                REGISTRY_SIGNATURE RegistrySignature = {0};
                RegistrySignature.dwSize = sizeof(REGISTRY_SIGNATURE);
                RegistrySignature.dwVersion = CURRENT_REGISTRY_DATA_FORMAT_VERSION;
                RegistrySignature.dwCount = dwCount;
                RegistrySignature.dwCrc = WiaCrc32::GenerateCrc32( nLengthInBytes - sizeof(REGISTRY_SIGNATURE), pItems + sizeof(REGISTRY_SIGNATURE) );
                
                //
                // Copy the registry signature struct to the buffer
                //
                CopyMemory( pItems, &RegistrySignature, sizeof(REGISTRY_SIGNATURE) );

                //
                // Save the data to the registry
                //
                reg.SetBin( pszValueName, pItems, nLengthInBytes, REG_BINARY );
                
                //
                // Free the temp buffer
                //
                delete[] pItems;
            }
        }
        return(true);
    }
    Iterator Add( CDestinationData item )
    {
        if (item.IsValid())
        {
            Remove(item);
            return Prepend(item);
        }
        return End();
    }
};


#endif //__MRU_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\mintrans.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       MINTRANS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/6/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <initguid.h>
#include <wiaregst.h>
#include <shlguid.h>
#include "shellext.h"
#include "shlobj.h"
#include "resource.h"       // resource ids
#include "itranhlp.h"
#include "mintrans.h"
#include "comctrlp.h"
#include "shlwapip.h"
#include "acqmgrcw.h"

namespace
{

//
// Define constants for dwords stored in the registry
#define ACTION_RUNAPP    0
#define ACTION_AUTOSAVE  1
#define ACTION_NOTHING   2
#define ACTION_MAX       2

static const TCHAR c_szConnectionSettings[] = TEXT("OnConnect\\%ls");

struct CMinimalTransferSettings
{
    DWORD dwAction;
    BOOL bDeleteImages;
    CSimpleString strFolderPath;
    CComPtr<IWiaTransferHelper> pXfer;
    BOOL bSaveInDatedDir;
};


#ifndef REGSTR_VALUE_USEDATE
#define REGSTR_VALUE_USEDATE     TEXT("UseDate")
#endif

/*******************************************************************************

ConstructDatedFolderPath

Concatenate the date to an existing folder name

*******************************************************************************/
static
CSimpleString
ConstructDatedFolderPath(
                        const CSimpleString &strOriginal
                        )
{
    CSimpleString strPath = strOriginal;

    //
    // Get the current date and format it as a string
    //
    SYSTEMTIME SystemTime;
    TCHAR szDate[MAX_PATH] = TEXT("");
    GetLocalTime( &SystemTime );
    GetDateFormat( LOCALE_USER_DEFAULT, 0, &SystemTime, CSimpleString(IDS_DATEFORMAT,g_hInstance), szDate, ARRAYSIZE(szDate) );

    //
    // Make sure there is a trailing backslash
    //
    if (!strPath.MatchLastCharacter( TEXT('\\')))
    {
        strPath += CSimpleString(TEXT("\\"));
    }

    //
    // Append the date
    //
    strPath += szDate;

    return strPath;
}


/////////////////////////////////////////////////////////////////////////////
// CPersistCallback and helpers

/*******************************************************************************
CheckAndCreateFolder

Make sure the target path exists or can be created. Failing that, prompt the
user for a folder.

*******************************************************************************/
void
CheckAndCreateFolder (CSimpleString &strFolderPath)
{

    // Convert to a full path name. If strFolderPath is not a full path,
    // we want it to be a subfolder of My Pictures

    TCHAR szFullPath[MAX_PATH] = TEXT("");
    SHGetFolderPath (NULL, CSIDL_MYPICTURES, NULL, 0, szFullPath);
    LPTSTR szUnused;
    BOOL bPrompt = false;
    if (*szFullPath)
    {
        SetCurrentDirectory (szFullPath);
    }
    GetFullPathName (strFolderPath, ARRAYSIZE(szFullPath), szFullPath, &szUnused);
    strFolderPath = szFullPath;
    // make sure the folder exists
    DWORD dw = GetFileAttributes(strFolderPath);

    if (dw == 0xffffffff)
    {
        bPrompt = !CAcquisitionManagerControllerWindow::RecursiveCreateDirectory( strFolderPath );
    }
    else if (!(dw & FILE_ATTRIBUTE_DIRECTORY))
    {
        bPrompt = TRUE;
    }

    // Ask the user for a valid folder
    if (bPrompt)
    {
        BROWSEINFO bi;
        TCHAR szPath[MAX_PATH] = TEXT("\0");
        LPITEMIDLIST pidl;
        TCHAR szTitle[200];
        LoadString (g_hInstance,
                    IDS_MINTRANS_FOLDERPATH_CAPTION,
                    szTitle,
                    200);
        ZeroMemory (&bi, sizeof(bi));
        bi.hwndOwner = NULL;
        bi.lpszTitle = szTitle;
        bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;
        pidl = SHBrowseForFolder (&bi);
        if (pidl)
        {
            SHGetPathFromIDList (pidl, szPath);
        }
        strFolderPath = szPath;
    }
}

/*******************************************************************************
GetSaveSettings

Find out what the user configured us to do with the images

*******************************************************************************/

void
GetSaveSettings (CMinimalTransferSettings &settings, BSTR bstrDeviceId)
{

    CSimpleReg regSettings(HKEY_CURRENT_USER,
                           REGSTR_PATH_USER_SETTINGS,
                           true,
                           KEY_READ);


    // Default to My Pictures/no delete if registry settings not there
    TCHAR szMyPictures[MAX_PATH];
    SHGetFolderPath (NULL, CSIDL_MYPICTURES, NULL, 0, szMyPictures);
    settings.bDeleteImages = 0;
    settings.strFolderPath = const_cast<LPCTSTR>(szMyPictures);
    settings.dwAction = ACTION_RUNAPP;
    settings.bSaveInDatedDir = FALSE;

    // BUGBUG: Should we prompt the user if the registry path
    // isn't set?
    if (regSettings.OK())
    {

        CSimpleString strSubKey;
        strSubKey.Format (c_szConnectionSettings, bstrDeviceId);
        CSimpleReg regActions (regSettings, strSubKey, true, KEY_READ);
        settings.bDeleteImages = regActions.Query (REGSTR_VALUE_AUTODELETE, 0);
        settings.strFolderPath = regActions.Query (REGSTR_VALUE_SAVEFOLDER,
                                                   CSimpleString(szMyPictures));
        settings.dwAction = regActions.Query (REGSTR_VALUE_CONNECTACT,
                                              ACTION_AUTOSAVE);
        settings.bSaveInDatedDir = (regActions.Query(REGSTR_VALUE_USEDATE,0) != 0);
        if (settings.bSaveInDatedDir)
        {
            settings.strFolderPath = ConstructDatedFolderPath( settings.strFolderPath );
        }
    }

}

// For the short term, have an array of format/extension pairs
struct MYFMTS
{
    const GUID *pFmt;
    LPCWSTR pszExt;
} FMTS [] =
{
    {&WiaImgFmt_BMP, L".bmp"},
    {&WiaImgFmt_JPEG, L".jpg"},
    {&WiaImgFmt_FLASHPIX, L".fpx"},
    {&WiaImgFmt_TIFF, L".tif"},
    {NULL, L""}
};


/*******************************************************************************

GetDropTarget

Get an IDropTarget interface for the given folder


*******************************************************************************/
HRESULT
GetDropTarget (IShellFolder *pDesktop, LPCTSTR szPath, IDropTarget **ppDrop)
{
    HRESULT hr;
    LPITEMIDLIST pidl;
    CSimpleStringWide strPath = CSimpleStringConvert::WideString (CSimpleString(szPath));
    CComPtr<IShellFolder> psf;
    hr = pDesktop->ParseDisplayName(NULL,
                                    NULL,
                                    const_cast<LPWSTR>(static_cast<LPCWSTR>(strPath)),
                                    NULL,
                                    &pidl,
                                    NULL);
    if (SUCCEEDED(hr))
    {
        hr = pDesktop->BindToObject(const_cast<LPCITEMIDLIST>(pidl),
                                    NULL,
                                    IID_IShellFolder,
                                    reinterpret_cast<LPVOID*>(&psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->CreateViewObject (NULL,
                                        IID_IDropTarget,
                                        reinterpret_cast<LPVOID*>(ppDrop));
        }
    }
    return hr;
}


/*******************************************************************************
FreePidl
Called when the array of pidls is destroyed, to free the pidls
*******************************************************************************/
INT
FreePidl (LPITEMIDLIST pidl, IMalloc *pMalloc)
{
    pMalloc->Free (pidl);
    return 1;
}


HRESULT
SaveItemsFromFolder (IShellFolder *pRoot, CSimpleString &strPath, BOOL bDelete)
{
    CComPtr<IEnumIDList> pEnum;
    LPITEMIDLIST pidl;
    HRESULT hr = S_FALSE;

    CComPtr<IMalloc> pMalloc;
    if (SUCCEEDED(SHGetMalloc (&pMalloc)))
    {

        CComPtr<IShellFolder> pDesktop;
        if (SUCCEEDED(SHGetDesktopFolder (&pDesktop)))
        {
            // enum the non-folder objects first
            if (SUCCEEDED(pRoot->EnumObjects (NULL,
                                              SHCONTF_FOLDERS | SHCONTF_NONFOLDERS ,
                                              &pEnum)))
            {
                HDPA         dpaItems;

                dpaItems = DPA_Create(10);
                while (NOERROR == pEnum->Next(1, &pidl, NULL))
                {
                    DPA_AppendPtr (dpaItems, pidl);

                }
                //
                // Now create the array of pidls and get the IDataObject
                //
                INT nSize = DPA_GetPtrCount (dpaItems);
                if (nSize > 0)
                {
                    LPITEMIDLIST *aidl = new LPITEMIDLIST[nSize];
                    if (aidl)
                    {
                        CComPtr<IDataObject> pdo;
                        for (INT i=0;i<nSize;i++)
                        {
                            aidl[i] = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(dpaItems, i));
                        }
                        hr = pRoot->GetUIObjectOf (NULL,
                                                   nSize,
                                                   const_cast<LPCITEMIDLIST*>(aidl),
                                                   IID_IDataObject,
                                                   NULL,
                                                   reinterpret_cast<LPVOID*>(&pdo));
                        if (SUCCEEDED(hr))
                        {
                            CComPtr<IDropTarget> pDrop;
                            CComQIPtr<IAsyncOperation, &IID_IAsyncOperation> pasync(pdo);
                            if (pasync.p)
                            {
                                pasync->SetAsyncMode(FALSE);
                            }
                            CheckAndCreateFolder (strPath);
                            if (strPath.Length())
                            {

                                //
                                // Get an IDropTarget for the destination folder
                                // and do the drag/drop
                                //

                                hr = GetDropTarget (pDesktop,
                                                    strPath,
                                                    &pDrop);
                            }
                            else
                            {
                                hr = S_FALSE;
                            }
                            if (S_OK == hr)
                            {
                                DWORD dwKeyState;
                                if (bDelete)
                                {
                                    // the "move" keys
                                    dwKeyState = MK_SHIFT | MK_LBUTTON;
                                }
                                else
                                {   // the copy keys
                                    dwKeyState = MK_CONTROL|MK_LBUTTON;
                                }
                                hr = SHSimulateDrop (pDrop,
                                                     pdo,
                                                     dwKeyState,
                                                     NULL,
                                                     NULL);
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = S_FALSE; // no images to download
                }
                DPA_DestroyCallback (dpaItems,
                                     reinterpret_cast<PFNDPAENUMCALLBACK>(FreePidl),
                                     reinterpret_cast<LPVOID>(pMalloc.p));
            }
        }
    }
    return hr;
}


/*******************************************************************************

SaveItems

This function uses IShellFolder and IDataObject interfaces to simulate
a drag/drop operation from the WIA virtual folder for the given device.

*******************************************************************************/

#define STR_WIASHEXT TEXT("wiashext.dll")

static
HRESULT
SaveItems (BSTR strDeviceId, CMinimalTransferSettings &settings)
{
    WIA_PUSH_FUNCTION((TEXT("SaveItems( %ws, ... )"), strDeviceId ));
    
    CComPtr<IShellFolder>pRoot;
    HRESULT hr = SHGetDesktopFolder (&pRoot);
    if (SUCCEEDED(hr))
    {
        //
        // Get the system directory, which is where wiashext.dll lives
        //
        TCHAR szShellExtensionPath[MAX_PATH] = {0};
        if (GetSystemDirectory( szShellExtensionPath, ARRAYSIZE(szShellExtensionPath)))
        {
            //
            // Make sure the path variable is long enough to hold this path
            //
            if (lstrlen(szShellExtensionPath) + lstrlen(STR_WIASHEXT) + lstrlen(TEXT("\\")) < ARRAYSIZE(szShellExtensionPath))
            {
                //
                // Concatenate the backslash and module name to the system path
                //
                lstrcat( szShellExtensionPath, TEXT("\\") );
                lstrcat( szShellExtensionPath, STR_WIASHEXT );

                //
                // Load the DLL
                //
                HINSTANCE hInstanceShellExt = LoadLibrary(szShellExtensionPath);
                if (hInstanceShellExt)
                {
                    //
                    // Get the pidl making function
                    //
                    WIAMAKEFULLPIDLFORDEVICE pfnMakeFullPidlForDevice = reinterpret_cast<WIAMAKEFULLPIDLFORDEVICE>(GetProcAddress(hInstanceShellExt, "MakeFullPidlForDevice"));
                    if (pfnMakeFullPidlForDevice)
                    {
                        //
                        // Get the pidl
                        //
                        LPITEMIDLIST pidlDevice = NULL;
                        hr = pfnMakeFullPidlForDevice( strDeviceId, &pidlDevice );
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Bind to the folder for this device
                            //
                            CComPtr<IShellFolder> pDevice;
                            hr = pRoot->BindToObject (const_cast<LPCITEMIDLIST> (pidlDevice), NULL, IID_IShellFolder, reinterpret_cast<LPVOID*>(&pDevice));
                            if (SUCCEEDED(hr))
                            {

                                hr = SaveItemsFromFolder (pDevice, settings.strFolderPath, settings.bDeleteImages);
                                if (S_OK == hr && settings.bDeleteImages)
                                {
                                    //
                                    // DoDeleteAllItems will pop up a dialog to confirm the delete.
                                    //
                                    DoDeleteAllItems (strDeviceId, NULL);
                                }
                            }
                            else
                            {
                                WIA_PRINTHRESULT((hr,TEXT("BindToObject failed!")));
                            }

                            CComPtr<IMalloc> pMalloc;
                            if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
                            {
                                pMalloc->Free(pidlDevice);
                            }
                        }
                        else
                        {
                            WIA_PRINTHRESULT((hr,TEXT("MakeFullPidlForDevice failed!")));
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        WIA_PRINTHRESULT((hr,TEXT("GetProcAddress for MakeFullPidlForDevice failed!")));
                    }
                    FreeLibrary(hInstanceShellExt);
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    WIA_PRINTHRESULT((hr,TEXT("Unable to load wiashext.dll!")));
                }
            }
            else
            {
                hr = E_FAIL;
                WIA_PRINTHRESULT((hr,TEXT("Buffer size was too small")));
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            WIA_PRINTHRESULT((hr,TEXT("Unable to get system folder!")));
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("SHGetDesktopFolder failed!")));
    }
    return hr;
}

} // End namespace MinimalTransfer

LRESULT
MinimalTransferThreadProc (BSTR bstrDeviceId)
{
    if (bstrDeviceId)
    {
        CMinimalTransferSettings settings;

        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            GetSaveSettings (settings, bstrDeviceId);
            // Bail if the default action is donothing or if the user cancelled
            // the browse for folder
            if (settings.dwAction == ACTION_AUTOSAVE)
            {
                hr = SaveItems (bstrDeviceId, settings);
                // Show the folder the user saved to
                if (NOERROR == hr)
                {
                    SHELLEXECUTEINFO sei;
                    ZeroMemory (&sei, sizeof(sei));
                    sei.cbSize = sizeof(sei);
                    sei.lpDirectory = settings.strFolderPath;
                    sei.nShow = SW_SHOW;
                    ShellExecuteEx (&sei);
                }
                else if (FAILED(hr))
                {
                    WIA_PRINTHRESULT((hr,TEXT("SaveItems failed!")));
                    // we can rely on SaveItems reporting errors to the user

                }
            }
            CoUninitialize();
        }
#ifndef DBG_GENERATE_PRETEND_EVENT
        WIA_TRACE((TEXT("Module::m_nLockCnt: %d"),_Module.m_nLockCnt));
        _Module.Unlock();
#endif
        SysFreeString(bstrDeviceId);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiaacmgr.rc
//
#define IDI_SCANCAM                     2
#define IDS_PROJNAME                    100
#define IDR_ACQUISITIONMANAGER          101
#define IDS_DOWNLOADMANAGER_NAME        101
#define IDI_TRANSFER_ERROR              101
#define IDS_DOWNLOADMANAGER_DESC        102
#define IDI_SCANNER_WIZARD              102
#define IDR_MINIMALTRANSFER             102
#define IDS_DOWNLOADMANAGER_ICON        103
#define IDI_TRANSFER_WARN               103
#define IDD_CHOOSE_STI_APPLICATION      103
#define IDS_CAMERA_SELECT_NUMSEL        104
#define IDS_UNABLE_OPEN_EXPLORER        105
#define IDS_CAMERA_SELECT_TITLE         106
#define IDS_CAMERA_SELECT_SUBTITLE      107
#define IDS_CAMERA_DOWNLOAD_TITLE       108
#define IDI_UNAVAILABLE                 109
#define IDS_CAMERA_DOWNLOAD_SUBTITLE    109
#define IDS_CAMERA_TRANSFER_TITLE       110
#define IDS_CAMERA_TRANSFER_SUBTITLE    111
#define IDS_SCANNER_TRANSFER_TITLE      112
#define IDS_SCANNER_TRANSFER_SUBTITLE   113
#define IDS_SCANNER_SELECT_TITLE        114
#define IDS_SCANNER_SELECT_SUBTITLE     115
#define IDS_DOWNLOADINGTHUMBNAIL        116
#define IDS_DOWNLOAD_MANAGER_TITLE      117
#define IDS_CAMSEL_CLEAR_ALL            118
#define IDS_DEFAULT_BASE_NAME           119
#define IDS_INVALIDFILENAME             120
#define IDS_ERROR_TITLE                 121
#define IDS_EMPTYFILENAME               122
#define IDS_BROWSE_TITLE                123
#define IDS_NUMBER_MASK                 124
#define IDS_CAMSEL_SELECT_ALL           125
#define IDS_CAMSEL_TAKE_PICTURE         126
#define IDS_FILEN_OF_M                  127
#define IDS_PERCENT_COMPLETE_COPYING    128
#define IDS_DEVICE_DISCONNECTED         129
#define IDS_SCANSEL_COLORPHOTO          130
#define IDS_SCANSEL_BW                  131
#define IDS_SCANSEL_TEXT                132
#define IDS_SCANSEL_CUSTOM              133
#define IDS_COMTRANS_BAD_DIRECTORY      134
#define IDS_COMTRANS_BAD_DIRECTORY_2ND_TRY 135
#define IDS_CONNECTED_TO                136
#define IDS_PERCENT_COMPLETE_SCANNING   137
#define IDS_CANCELWIZARDCONFIRM         138
#define IDS_SCANNER_DOWNLOAD_TITLE      139
#define IDS_SCANNER_DOWNLOAD_SUBTITLE   140
#define IDS_ADVANCEDPROPERTIES          141
#define IDS_UNABLETOCREATE              142
#define IDS_TRANSFER_ERROR_OCCURRED     143
#define IDS_INVALIDFILENAME_SHORT       144
#define IDS_UNABLETOROTATE              145
#define IDS_GETTINGSTARTED              146
#define IDS_WAIT                        147
#define IDS_CAMERA_NO_IMAGES            148
#define IDS_DELETINGPICTURE             149
#define IDS_DELETING                    150
#define IDS_DEVICE_OFFLINE              151
#define IDS_NO_DEVICE_TEXT              152
#define IDS_FILETYPE                    153
#define IDS_REPLACE_REMOVEABLE_MEDIA    154
#define IDS_UNABLE_TO_CREATE_FILE       155
#define IDS_UNABLE_TO_ROTATE_FILE       156
#define IDS_UNABLE_TO_SAVE_FILE         157
#define IDS_TRANSFER_ERROR              158
#define IDS_ITEM_WAS_DELETED            159
#define IDS_DEVICE_BUSY                 160
#define IDS_BLANKFILETYPENAME           161
#define IDS_MINIMALTRANSFER_NAME        162
#define IDS_MINIMALTRANSFER_DESC        163
#define IDS_MINIMALTRANSFER_ICON        164
#define IDS_DATEFORMAT                  165
#define IDS_UNABLETOTRANSFER            166
#define IDS_DISKFULL                    167
#define IDS_PREVIEWSCAN_ERROR           168
#define IDS_PATH_TOO_LONG               169
#define IDS_MINTRANS_FOLDERPATH_CAPTION 170
#define IDS_MINTRANS_DOCREATE_CAPTION   171
#define IDS_MINTRANS_DOCREATE_FOLDER    172
#define IDS_HANDLERERR_CAPTION          173
#define IDS_HANDLERERR                  174
#define IDS_SCANSEL_SCANNINGPREVIEW     175
#define IDS_SCANNER_NO_IMAGES           176
#define IDS_NO_IMAGES_SELECTED          177
#define IDS_ERROR_SETTING_PROPS         178
#define IDS_UPLOADINGPICTURE            179
#define IDS_UPLOADING                   180
#define IDS_UNABLE_TO_CREATE_PLUGIN     181
#define IDS_PERCENT_COMPLETE_UPLOADING  182
#define IDS_UPLOADED_STRING             183
#define IDS_PROGDLG_MESSAGE             184
#define IDS_TRANSFER_GENERICFAILURE     185
#define IDS_TRANSFER_DEVICEBUSY         186
#define IDS_FINISH_SCANNER              187
#define IDS_FINISH_CAMERA               188
#define IDS_FINISH_VIDEO                189
#define IDS_SUCCESSFUL_DOWNLOAD         190
#define IDS_SUCCESSFUL_UPLOAD           191
#define IDS_CAMERA_PROGRESS_TITLE       192
#define IDS_CAMERA_PROGRESS_SUBTITLE    193
#define IDS_UPLOADTOWEBITEMNAME         194
#define IDS_ELLIPSIS                    195
#define IDS_DATEANDTOPIC                196
#define IDS_SKIPPED_IMAGES              197
#define IDS_STOP_BUTTON                 198
#define IDS_USER_CANCELLED              199
#define IDS_FIRST_PAGE_INSTRUCTIONS_CAMERA 200
#define IDS_FIRST_PAGE_INSTRUCTIONS_SCANNER 201
#define IDI_TEXT                        202
#define IDS_FIRST_PAGE_INSTRUCTIONS_VIDEO 202
#define IDD_CAMERA_FIRST                203
#define IDI_CPHOTO                      203
#define IDS_VIDEO_NO_IMAGES             203
#define IDD_CAMERA_SELECT               204
#define IDI_CUSTOM                      204
#define IDS_DUPLICATE_FILE_WARNING      204
#define IDI_BWPHOTO                     205
#define IDS_TRANSFER_GENERICFAILURE_NO_CONTINUE 205
#define IDI_VIDEO_WIZARD                206
#define IDS_VIDEOPREVIEWUNAVAILABLE     206
#define IDB_VIDEO_HEADER                207
#define IDS_PREVIEWOUTOFPAPER           207
#define IDD_SCANNER_FIRST               208
#define IDS_ERROR_WRITE_PROTECT         208
#define IDD_SCANNER_SELECT              209
#define IDS_TRANSFER_PAPEREMPTY         209
#define IDC_SCANSEL_INTENT_1            210
#define IDD_EVENTPROMPT                 210
#define IDS_COMMON_UPLOAD_TITLE         210
#define IDC_SCANSEL_ICON_1              211
#define IDR_EVENTPROMPT                 211
#define IDS_COMMON_UPLOAD_SUBTITLE      211
#define IDC_SCANSEL_ICON_2              212
#define IDI_UPLOADTOWEB                 212
#define IDS_CONFIRM_CANCEL_DOWNLOAD     212
#define IDC_SCANSEL_INTENT_2            213
#define IDS_CONFIRM_CANCEL_UPLOAD       213
#define IDC_SCANSEL_INTENT_3            214
#define IDS_CONFIRM_SAVE_DOWNLOADED     214
#define IDC_SCANSEL_INTENT_4            215
#define IDS_SCANSEL_INITIALIZING_SCANNER 215
#define IDC_SCANSEL_ICON_3              216
#define IDS_CONFIRM_CANCEL_DELETE       216
#define IDC_SCANSEL_ICON_4              217
#define IDD_SCANNER_TRANSFER            217
#define IDS_COMMON_DELETE_TITLE         217
#define IDC_SCANSEL_PROPERTIES          218
#define IDD_VIDEO_FIRST                 218
#define IDS_COMMON_DELETE_SUBTITLE      218
#define IDD_SCANNER_ADF_SELECT          219
#define IDS_UNSUPPORTED_DEVICE          219
#define IDB_CAMSEL_TOOLBAR              219
#define IDC_TRANSFER_DELETEAFTERDOWNLOAD 220
#define IDS_ERROR_ACCESS_DENIED         220
#define IDC_CAMFIRST_EXPLORE            221
#define IDD_COMMON_FINISH               221
#define IDS_SCROLLFED_SELECT_SUBTITLE   221
#define IDB_SCANSEL_TOOLBAR             221
#define IDD_COMMON_PROGRESS             222
#define IDS_SCROLLFED_SELECT_TITLE      222
#define IDD_VIDEO_SELECT                223
#define IDS_ENUMERATIONCOUNT            223
#define IDR_STIEVENTHANDLER             223
#define IDS_CONFIRMDELETE               224
#define IDR_CAMERASELECTIONACCEL        224
#define IDD_COMMON_DELETE               225
#define IDS_SOUNDS_APPLICATION_NAME     225
#define IDS_SOUNDS_CONNECT_SOUND        226
#define IDD_CAMERA_TRANSFER             226
#define IDS_SOUNDS_DISCONNECT_SOUND     227
#define IDD_UPLOAD_QUERY                227
#define IDS_SOUNDS_CONNECT_LABEL        228
#define IDS_SOUNDS_DISCONNECT_LABEL     229
#define IDS_DUPLICATE_FILENAME_MASK     230
#define IDS_UNABLE_TO_OPEN_UPLOAD_WIZARD 231
#define IDC_TRANSFER_IMAGETYPE          232
#define IDS_CAMSEL_TOOLTIP_ROTATE_RIGHT 232
#define IDS_CAMSEL_TOOLTIP_ROTATE_LEFT  233
#define IDS_CAMSEL_TOOLTIP_PROPERTIES   234
#define IDS_CAMSEL_TOOLTIP_TAKE_PICTURE 235
#define IDC_FIRST_INSTRUCTIONS          236
#define IDS_CAMSEL_TOOLTIP_CLEAR_ALL    236
#define IDC_HANDLERLIST                 237
#define IDS_CAMSEL_TOOLTIP_SELECT_ALL   237
#define IDC_NOPROMPT                    238
#define IDS_SCANSEL_SHOW_SELECTION      238
#define IDC_EVENTNAME                   239
#define IDS_SCANSEL_SHOW_BED            239
#define IDS_VIDEO_SELECT_TITLE          240
#define IDS_VIDEO_SELECT_SUBTITLE       241
#define IDS_SCANNER_SELECT_SUBTITLE_NO_PREVIEW 242
#define IDS_SCANNER_PROGRESS_TITLE      243
#define IDS_SCANNER_PROGRESS_SUBTITLE   244
#define IDS_IMAGE_UPLOAD_PROGRESS       245
#define IDS_OVERALL_UPLOAD_PROGRESS     246
#define IDS_DELETING_FILEN_OF_M         247
#define IDS_FINISH_SHOW_ME_MY_PICTURES  248
#define IDS_FINISH_IN_A_FOLDER          249
#define IDS_FINISH_ON_A_SITE            250
#define IDC_FINISH_STATUS               251
#define IDS_FINISH_SUCCESS_TITLE        251
#define IDC_FINISH_TITLE                252
#define IDS_FINISH_FAILURE_TITLE        252
#define IDC_COMPROG_CURRENTIMAGE        253
#define IDS_PROPERTY_SHEET_ERROR        253
#define IDC_COMPROG_CURRENTIMAGE_TEXT   254
#define IDS_FINISH_ERROR_MESSAGE        254
#define IDC_COMPROG_DOWNLOADPROGRESS_TEXT 255
#define IDS_UNABLE_TO_PUBLISH           255
#define IDC_COMPROG_DOWNLOADPROGRESS    256
#define IDS_UPLOAD_ERROR                256
#define IDS_FINISH_UPLOAD_FAILED        257
#define IDC_COMPROG_CURRENTTHUMBNAIL    258
#define IDS_FINISH_UPLOAD_CANCELLED     258
#define IDC_COMPROG_DESTNAME            259
#define IDS_FINISH_UPLOAD_SUCCEEDED     259
#define IDC_COMPROG_IMAGENAME           260
#define IDS_FINISH_PROMPT_FAILURE       260
#define IDS_TAKING_PICTURE              261
#define IDS_TRANSFER_SCANNEDITEMMAYBETOOLARGE 262
#define IDS_UNABLE_TO_TAKE_PICTURE      263
#define IDS_SELECTED_NO_IMAGES_SELECTED 264
#define IDS_SELECTED_NO_PICTURES        265
#define IDS_FINISH_LOCAL_LINK_PROMPT    266
#define IDS_FINISH_REMOTE_LINK_PROMPT   267
#define IDS_DELETION_FAILED             268
#define IDS_FINISH_PROMPT_SUCCESS       269
#define IDS_STI_EVENT_ERROR_TITLE       270
#define IDS_STI_EVENT_ERROR_WITH_EXPLANATION 271
#define IDS_STI_EVENT_ERROR_NO_EXPLANATION 272
#define IDS_STI_EVENT_ERROR_APP_NAME    273
#define IDS_FINISH_TO_CLOSE_TITLE       274
#define IDS_FINISH_PROMPT_FAILURE_DISCONNECT 275
#define IDS_DOWNLOADMANAGER_AUTOPLAY    276
#define IDS_DEVICE_NOT_FOUND            277
#define IDS_MULTIPAGE_PAPER_PROBLEM     278
#define IDS_MULTIPAGE_FATAL_ERROR       279
#define IDC_COMDEL_CURRENTIMAGE_TEXT    289
#define IDC_COMDEL_CURRENTIMAGE         290
#define IDC_COMDEL_CURRENTTHUMBNAIL     293
#define IDC_TRANSFER_UPLOAD_TO_WEB      295
#define IDC_TRANSFER_UPLOAD_NO          296
#define IDC_TRANSFER_1                  297
#define IDC_TRANSFER_UPLOAD_TO_PRINT    297
#define IDC_TRANSFER_2                  298
#define IDC_TRANSFER_3                  299
#define IDC_TRANSFER_NAME_PROMPT        301
#define IDC_TRANSFER_FOLDER_PROMPT      302
#define IDC_TRANSFER_UPLOAD_PROMPT      303
#define IDC_TRANSFER_UPLOAD_SUCCESS     304
#define IDC_TRANSFER_FORMAT_PROMPT      305
#define IDC_CAMSEL_CAMERA_BUTTON_BAR_GUIDE 306
#define IDC_CAMSEL_VIDEO_PREVIEW_BUTTON_BAR_GUIDE 307
#define IDC_CAMSEL_VIDEO_SELECTION_BUTTON_BAR_GUIDE 308
#define IDC_SCANSEL_BUTTON_BAR_GUIDE    309
#define IDC_FINISH_PROMPT               317
#define IDC_STI_APPS_LIST_PROMPT        319
#define IDC_TRANSFER_UPLOAD_HELP        320
#define IDB_CAMERA_WATERMARK            400
#define IDC_TRANSFER_ROOTNAME           507
#define IDC_TRANSFER_DESTINATION        513
#define IDC_TRANSFER_BROWSE             514
#define IDC_CAMSEL_STATUS               526
#define IDC_FIRST_TITLE                 531
#define IDC_FIRST_DEVICE_NAME           533
#define IDB_CAMERA_HEADER               602
#define IDB_SCANNER_WATERMARK           603
#define IDB_SCANNER_HEADER              604
#define IDI_LITTLE_I                    604
#define IDI_CAMERA_WIZARD               605
#define IDB_VIDEO_WATERMARK             605
#define IDI_TRANSFER_OK                 606
#define IDI_DEFTYPE                     607
#define IDC_CAMSEL_THUMBNAILS           1000
#define IDC_STI_APPS_LIST               1002
#define IDC_VIDSEL_PREVIEW              1003
#define IDC_STI_APPS_SUB_TITLE          1005
#define IDC_STI_APPS_ICON               1006
#define IDC_SCANSEL_PREVIEW             1013
#define IDC_SCANSEL_RESCAN              1014
#define IDS_CONFIRM_DELETE              1017
#define IDS_CONFIRM_DELETE_CAPTION      1018
#define IDC_SCANSEL_PAPERSOURCE         1031
#define IDC_SCANSEL_PAPERSIZE           1032
#define IDC_SCANSEL_PAPERSIZE_STATIC    1033
#define IDC_SCANSEL_PAPERSOURCE_STATIC  1034
#define IDC_CAMSEL_ROTATE_RIGHT         1035
#define IDC_CAMSEL_ROTATE_LEFT          1036
#define IDC_CAMSEL_SELECT_ALL           1037
#define IDC_CAMSEL_CLEAR_ALL            1038
#define IDC_CAMSEL_PROPERTIES           1039
#define IDC_CAMSEL_TAKE_PICTURE         1040
#define IDS_SCANSEL_FLATBED             1100
#define IDS_SCANSEL_ADF                 1101
#define IDB_DEFAULT_SCANNER_BITMAP      4001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        225
#define _APS_NEXT_COMMAND_VALUE         1041
#define _APS_NEXT_CONTROL_VALUE         322
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\scansel.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANSEL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Scanner region selection (preview) page
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "scansel.h"
#include "simcrack.h"
#include "resource.h"
#include "simstr.h"
#include "mboxex.h"
#include "createtb.h"
#include <vwiaset.h>

#define IDC_SCANSEL_SELECTION_BUTTON_BAR 1100
#define IDC_SCANSEL_SHOW_SELECTION       1200
#define IDC_SCANSEL_SHOW_BED             1201

//
// Associate a document handling flag with a string resource
//
static const struct
{
    int nFlag;
    int nStringId;
}
g_SupportedDocumentHandlingTypes[] =
{
    { FLATBED, IDS_SCANSEL_FLATBED },
    { FEEDER,  IDS_SCANSEL_ADF }
};
static const int g_SupportedDocumentHandlingTypesCount = ARRAYSIZE(g_SupportedDocumentHandlingTypes);

//
// Associate an icon control's resource id with a radio button's resource id
//
static const struct
{
    int nIconId;
    int nRadioId;
}
gs_IntentRadioButtonIconPairs[] =
{
    { IDC_SCANSEL_ICON_1, IDC_SCANSEL_INTENT_1 },
    { IDC_SCANSEL_ICON_2, IDC_SCANSEL_INTENT_2 },
    { IDC_SCANSEL_ICON_3, IDC_SCANSEL_INTENT_3 },
    { IDC_SCANSEL_ICON_4, IDC_SCANSEL_INTENT_4 }
};
static const int gs_nCountIntentRadioButtonIconPairs = ARRAYSIZE(gs_IntentRadioButtonIconPairs);


//
// Sole constructor
//
CScannerSelectionPage::CScannerSelectionPage( HWND hWnd )
  : m_hWnd(hWnd),
    m_pControllerWindow(NULL),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_hBitmapDefaultPreviewBitmap(NULL),
    m_bAllowRegionPreview(false),
    m_hwndPreview(NULL),
    m_hwndSelectionToolbar(NULL),
    m_hwndRescan(NULL),
    m_ScannerSelectionButtonBarBitmapInfo( g_hInstance, IDB_SCANSEL_TOOLBAR )
{
    ZeroMemory( &m_sizeDocfeed, sizeof(m_sizeDocfeed) );
    ZeroMemory( &m_sizeFlatbed, sizeof(m_sizeFlatbed) );
}

//
// Destructor
//
CScannerSelectionPage::~CScannerSelectionPage(void)
{
    m_hWnd = NULL;
    m_pControllerWindow = NULL;

    //
    // Free the paper sizes
    //
    if (m_pPaperSizes)
    {
        CComPtr<IWiaScannerPaperSizes> pWiaScannerPaperSizes;
        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaScannerPaperSizes, (void**)&pWiaScannerPaperSizes );
        if (SUCCEEDED(hr))
        {
            hr = pWiaScannerPaperSizes->FreePaperSizes( &m_pPaperSizes, &m_nPaperSizeCount );
        }
    }
}

//
// Calculate the maximum scan size using the give DPI
//
static bool GetFullResolution( IWiaItem *pWiaItem, LONG nResX, LONG nResY, LONG &nExtX, LONG &nExtY )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::GetFullResolution"));
    CComPtr<IWiaItem> pRootItem;
    if (SUCCEEDED(pWiaItem->GetRootItem(&pRootItem)) && pRootItem)
    {
        LONG lBedSizeX, lBedSizeY;
        if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_HORIZONTAL_BED_SIZE, lBedSizeX ) &&
            PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_VERTICAL_BED_SIZE, lBedSizeY ))
        {
            nExtX = WiaUiUtil::MulDivNoRound( nResX, lBedSizeX, 1000 );
            nExtY = WiaUiUtil::MulDivNoRound( nResY, lBedSizeY, 1000 );
            return(true);
        }
    }
    return(false);
}

//
// Calculate the maximum scan size using the give DPI
//
static bool GetBedAspectRatio( IWiaItem *pWiaItem, LONG &nResX, LONG &nResY )
{
    WIA_PUSHFUNCTION(TEXT("CScannerItem::GetFullResolution"));
    nResX = nResY = 0;
    if (pWiaItem)
    {
        CComPtr<IWiaItem> pRootItem;
        if (SUCCEEDED(pWiaItem->GetRootItem(&pRootItem)) && pRootItem)
        {
            if (PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_HORIZONTAL_BED_SIZE, nResX ) &&
                PropStorageHelpers::GetProperty( pRootItem, WIA_DPS_VERTICAL_BED_SIZE, nResY ))
            {
                return true;
            }
        }
    }
    return(false);
}


bool CScannerSelectionPage::ApplyCurrentPreviewWindowSettings(void)
{
    WIA_PUSHFUNCTION(TEXT("CScannerSelectionPage::ApplyCurrentPreviewWindowSettings"));
    CWiaItem *pWiaItem = GetActiveScannerItem();
    if (pWiaItem)
    {
        CWiaItem::CScanRegionSettings &ScanRegionSettings = pWiaItem->ScanRegionSettings();

        //
        // m_hwndPreview will be NULL if the preview control is not active
        //
        if (m_hwndPreview)
        {
            //
            // Get the current resolution
            //
            SIZE sizeCurrentResolution;
            if (PropStorageHelpers::GetProperty( pWiaItem->WiaItem(), WIA_IPS_XRES, sizeCurrentResolution.cx ) &&
                PropStorageHelpers::GetProperty( pWiaItem->WiaItem(), WIA_IPS_YRES, sizeCurrentResolution.cy ))
            {
                //
                // Compute the full page resolution of the item
                //
                if (GetFullResolution( pWiaItem->WiaItem(), sizeCurrentResolution.cx, sizeCurrentResolution.cy, ScanRegionSettings.sizeResolution.cx, ScanRegionSettings.sizeResolution.cy ))
                {
                    //
                    // Set the resolution in the preview control
                    //
                    WiaPreviewControl_SetResolution( m_hwndPreview, &ScanRegionSettings.sizeResolution );

                    //
                    // Save the origin and extents
                    //
                    WiaPreviewControl_GetSelOrigin( m_hwndPreview, 0, FALSE, &ScanRegionSettings.ptOrigin );
                    WiaPreviewControl_GetSelExtent( m_hwndPreview, 0, FALSE, &ScanRegionSettings.sizeExtent );

                    WIA_TRACE((TEXT("ScanRegionSettings.sizeExtent: (%d,%d)"), ScanRegionSettings.sizeExtent.cx, ScanRegionSettings.sizeExtent.cy ));

                    //
                    // Set the origin and extents.  We don't set them directly, because they might not be a correct multiple
                    //
                    if (CValidWiaSettings::SetNumericPropertyOnBoundary( pWiaItem->WiaItem(), WIA_IPS_XPOS, ScanRegionSettings.ptOrigin.x ))
                    {
                        if (CValidWiaSettings::SetNumericPropertyOnBoundary( pWiaItem->WiaItem(), WIA_IPS_YPOS, ScanRegionSettings.ptOrigin.y ))
                        {
                            if (CValidWiaSettings::SetNumericPropertyOnBoundary( pWiaItem->WiaItem(), WIA_IPS_XEXTENT, ScanRegionSettings.sizeExtent.cx ))
                            {
                                if (CValidWiaSettings::SetNumericPropertyOnBoundary( pWiaItem->WiaItem(), WIA_IPS_YEXTENT, ScanRegionSettings.sizeExtent.cy ))
                                {
                                    return true;
                                }
                                else
                                {
                                    WIA_ERROR((TEXT("PropStorageHelpers::SetProperty on WIA_IPS_YEXTENT failed")));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("PropStorageHelpers::SetProperty on WIA_IPS_XEXTENT failed")));
                            }
                        }
                        else
                        {
                            WIA_ERROR((TEXT("PropStorageHelpers::SetProperty on WIA_IPS_YPOS failed")));
                        }
                    }
                    else
                    {
                        WIA_ERROR((TEXT("PropStorageHelpers::SetProperty on WIA_IPS_XPOS failed")));
                    }
                }
            }
        }
    }
    return false;
}


//
// PSN_WIZNEXT
//
LRESULT CScannerSelectionPage::OnWizNext( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CScannerSelectionPage::OnWizNext"));
    CWiaItem *pWiaItem = GetActiveScannerItem();
    if (pWiaItem)
    {
        pWiaItem->CustomPropertyStream().WriteToRegistry( pWiaItem->WiaItem(), HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REGSTR_KEYNAME_USER_SETTINGS_WIAACMGR );
    }

    //
    // Assume we'll use the preview window's settings, instead of the page size
    //
    bool bUsePreviewSettings = true;

    //
    // Assume there has been a problem
    //
    bool bSucceeded = false;

    //
    // Make sure we have all valid data
    //
    if (m_pControllerWindow->m_pWiaItemRoot && pWiaItem && pWiaItem->WiaItem())
    {
        //
        // Apply the current intent
        //
        if (ApplyCurrentIntent())
        {
            //
            // Find out if we're in the ADF capable dialog
            //
            HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSIZE );
            if (hWndPaperSize)
            {
                WIA_TRACE((TEXT("ADF Mode")));
                //
                // See if we are in document feeder mode
                //
                if (InDocFeedMode())
                {
                    //
                    // Get the selected paper size
                    //
                    LRESULT nCurSel = SendMessage( hWndPaperSize, CB_GETCURSEL, 0, 0 );
                    if (CB_ERR != nCurSel)
                    {
                        //
                        // Which entry in the global paper size table is it?
                        //
                        LRESULT nPaperSizeIndex = SendMessage( hWndPaperSize, CB_GETITEMDATA, nCurSel, 0 );
                        if (CB_ERR != nPaperSizeIndex)
                        {
                            //
                            // If we have a valid page size
                            //
                            if (m_pPaperSizes[nPaperSizeIndex].nWidth && m_pPaperSizes[nPaperSizeIndex].nHeight)
                            {
                                //
                                // We won't be using the preview window
                                //
                                bUsePreviewSettings = false;

                                //
                                // Assume upper-left registration
                                //
                                POINT ptOrigin = { 0, 0 };
                                SIZE sizeExtent = { m_pPaperSizes[nPaperSizeIndex].nWidth, m_pPaperSizes[nPaperSizeIndex].nHeight };

                                //
                                // Get the registration, and shift the coordinates as necessary
                                //
                                LONG nSheetFeederRegistration;
                                if (!PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_SHEET_FEEDER_REGISTRATION, nSheetFeederRegistration ))
                                {
                                    nSheetFeederRegistration = LEFT_JUSTIFIED;
                                }
                                if (nSheetFeederRegistration == CENTERED)
                                {
                                    ptOrigin.x = (m_sizeDocfeed.cx - sizeExtent.cx) / 2;
                                }
                                else if (nSheetFeederRegistration == RIGHT_JUSTIFIED)
                                {
                                    ptOrigin.x = m_sizeDocfeed.cx - sizeExtent.cx;
                                }

                                //
                                // Get the current resolution, so we can calculate the full-bed resolution in terms of the current DPI
                                //
                                LONG nXRes = 0, nYRes = 0;
                                if (PropStorageHelpers::GetProperty( pWiaItem->WiaItem(), WIA_IPS_XRES, nXRes ) &&
                                    PropStorageHelpers::GetProperty( pWiaItem->WiaItem(), WIA_IPS_YRES, nYRes ))
                                {
                                    //
                                    // Make sure these are valid resolution settings
                                    //
                                    if (nXRes && nYRes)
                                    {
                                        //
                                        //  Calculate the full bed resolution in the current DPI
                                        //
                                        SIZE sizeFullBedResolution = { 0, 0 };
                                        sizeFullBedResolution.cx = WiaUiUtil::MulDivNoRound( nXRes, m_sizeDocfeed.cx, 1000 );
                                        sizeFullBedResolution.cy = WiaUiUtil::MulDivNoRound( nYRes, m_sizeDocfeed.cy, 1000 );

                                        //
                                        // Make sure these resolution numbers are valid
                                        //
                                        if (sizeFullBedResolution.cx && sizeFullBedResolution.cy)
                                        {
                                            //
                                            // Calculate the origin and extent in terms of the current DPI
                                            //
                                            ptOrigin.x = WiaUiUtil::MulDivNoRound( ptOrigin.x, sizeFullBedResolution.cx, m_sizeDocfeed.cx );
                                            ptOrigin.y = WiaUiUtil::MulDivNoRound( ptOrigin.y, sizeFullBedResolution.cy, m_sizeDocfeed.cy );

                                            sizeExtent.cx = WiaUiUtil::MulDivNoRound( sizeExtent.cx, sizeFullBedResolution.cx, m_sizeDocfeed.cx );
                                            sizeExtent.cy = WiaUiUtil::MulDivNoRound( sizeExtent.cy, sizeFullBedResolution.cy, m_sizeDocfeed.cy );

                                            //
                                            // Write the properties
                                            //
                                            if (PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_XPOS, ptOrigin.x ) &&
                                                PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_YPOS, ptOrigin.y ) &&
                                                PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_XEXTENT, sizeExtent.cx ) &&
                                                PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_YEXTENT, sizeExtent.cy ))
                                            {
                                                //
                                                // Tell the scanner to scan from the ADF and to scan one page only
                                                //
                                                if (PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, FEEDER ) &&
                                                    PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_PAGES, 1 ))
                                                {

                                                    //
                                                    // Everything seemed to work.  This item is ready for transfer.
                                                    //
                                                    bSucceeded = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //
            // m_hwndPreview will be NULL if the preview control is not active
            //
            else if (!m_hwndPreview)
            {
                WIA_TRACE((TEXT("Scrollfed scanner")));
                //
                // Set the origin to 0,0 and the extent to max,0
                //

                //
                // Get the current x resolution, so we can calculate the full-bed width in terms of the current DPI
                //
                LONG nXRes = 0;
                if (PropStorageHelpers::GetProperty( pWiaItem->WiaItem(), WIA_IPS_XRES, nXRes ))
                {
                    //
                    // Make sure this is a valid resolution
                    //
                    if (nXRes)
                    {
                        //
                        //  Calculate the full bed resolution in the current DPI
                        //
                        LONG nWidth = WiaUiUtil::MulDivNoRound( nXRes, m_sizeDocfeed.cx, 1000 );
                        if (nWidth)
                        {
                            PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_XPOS, 0 );
                            PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_YPOS, 0 );
                            PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_XEXTENT, nWidth );
                            PropStorageHelpers::SetProperty( pWiaItem->WiaItem(), WIA_IPS_YEXTENT, 0 );
                            PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_PAGES, 1 );
                            bUsePreviewSettings = false;
                            bSucceeded = true;
                        }
                    }
                }
            }

            //
            // If we are scanning from the flatbed, apply the preview window settings
            //
            if (bUsePreviewSettings)
            {
                //
                // Tell the scanner to scan from the flatbed and and clear the page count
                //
                PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, FLATBED );
                PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_PAGES, 0 );

                //
                // Get the origin and extent from the preview control
                //
                if (ApplyCurrentPreviewWindowSettings())
                {
                    //
                    // Everything seemed to work.  This item is ready for transfer.
                    //
                    bSucceeded = true;
                }
            }
            else
            {
                //
                // Clear the preview bitmap.  It won't be doing us any good anyway.
                //
                pWiaItem->BitmapImage(NULL);
            }
        }
    }

    if (!bSucceeded)
    {
        //
        // If that icky code above failed, tell the user and let them try again
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONINFORMATION );
        return -1;
    }

    return 0;
}


//
// PSN_WIZBACK
//
LRESULT CScannerSelectionPage::OnWizBack( WPARAM, LPARAM )
{
    return 0;
}

//
// PSN_SETACTIVE
//
LRESULT CScannerSelectionPage::OnSetActive( WPARAM, LPARAM )
{
    //
    // Make sure we have a valid controller window
    //
    if (!m_pControllerWindow)
    {
        return -1;
    }

    int nWizButtons = PSWIZB_NEXT;

    //
    // Only enable "back" if the first page is available
    //
    if (!m_pControllerWindow->SuppressFirstPage())
    {
        nWizButtons |= PSWIZB_BACK;
    }

    //
    // Set the buttons
    //
    PropSheet_SetWizButtons( GetParent(m_hWnd), nWizButtons );

    //
    // We do want to exit on disconnect if we are on this page
    //
    m_pControllerWindow->m_OnDisconnect = CAcquisitionManagerControllerWindow::OnDisconnectGotoLastpage|CAcquisitionManagerControllerWindow::OnDisconnectFailDownload|CAcquisitionManagerControllerWindow::OnDisconnectFailUpload|CAcquisitionManagerControllerWindow::OnDisconnectFailDelete;

    //
    // Make sure the preview related controls accurately reflect the current settings
    //
    UpdateControlState();

    return 0;
}

CWiaItem *CScannerSelectionPage::GetActiveScannerItem(void)
{
    // Return (for now) the first image in the list
    if (m_pControllerWindow->m_pCurrentScannerItem)
    {
        return m_pControllerWindow->m_pCurrentScannerItem;
    }
    return NULL;
}

bool CScannerSelectionPage::InPreviewMode(void)
{
    bool bResult = false;
    if (m_hwndSelectionToolbar)
    {
        bResult = (SendMessage(m_hwndSelectionToolbar,TB_GETSTATE,IDC_SCANSEL_SHOW_SELECTION,0) & TBSTATE_CHECKED);
    }
    return bResult;
}

void CScannerSelectionPage::OnRescan( WPARAM, LPARAM )
{
    if (!ApplyCurrentIntent())
    {
        //
        // Tell the user it failed, and to try again
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONINFORMATION );
        return;
    }
    CWiaItem *pWiaItem = GetActiveScannerItem();
    if (pWiaItem)
    {
        //
        // Turn off preview mode and disable all the controls
        //
        if (m_hwndPreview)
        {
            WiaPreviewControl_SetPreviewMode( m_hwndPreview, FALSE );
        }
        EnableControls(FALSE);

        //
        // Clear the cancel event
        //
        m_PreviewScanCancelEvent.Reset();

        //
        // If PerformPreviewScan fails, we won't get any messages, so return all controls to their normal state
        //
        if (!m_pControllerWindow->PerformPreviewScan( pWiaItem, m_PreviewScanCancelEvent.Event() ))
        {

            //
            // Restore the preview mode and re-enable the controls
            //
            if (m_hwndPreview && m_hwndSelectionToolbar)
            {
                WiaPreviewControl_SetPreviewMode( m_hwndPreview, InPreviewMode() );
            }
            EnableControls(TRUE);
        }
    }
}

bool CScannerSelectionPage::ApplyCurrentIntent(void)
{
    CWaitCursor wc;
    CWiaItem *pCurItem = GetActiveScannerItem();
    if (pCurItem)
    {
        for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
        {
            if (SendDlgItemMessage( m_hWnd, gs_IntentRadioButtonIconPairs[i].nRadioId, BM_GETCHECK, 0, 0 )==BST_CHECKED)
            {
                LONG lIntent = static_cast<LONG>(GetWindowLongPtr( GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[i].nRadioId ), GWLP_USERDATA ) );
                if (lIntent) // This is a normal intent
                {
                    if (pCurItem->SavedPropertyStream().IsValid())
                    {
                        if (!SUCCEEDED(pCurItem->SavedPropertyStream().ApplyToWiaItem( pCurItem->WiaItem())))
                        {
                            return false;
                        }
                    }

                    if (PropStorageHelpers::SetProperty( pCurItem->WiaItem(), WIA_IPS_CUR_INTENT, lIntent ) &&
                        PropStorageHelpers::SetProperty( pCurItem->WiaItem(), WIA_IPS_CUR_INTENT, 0 ))
                    {
                        return true;
                    }
                }
                else if (pCurItem->CustomPropertyStream().IsValid()) // This is the "custom" intent
                {
                    return(SUCCEEDED(pCurItem->CustomPropertyStream().ApplyToWiaItem(pCurItem->WiaItem())));
                }
                break;
            }
        }
    }
    return false;
}

void CScannerSelectionPage::InitializeIntents(void)
{
    static const struct
    {
        int      nIconId;
        int      nStringId;
        LONG_PTR nIntent;
    }
    s_Intents[] =
    {
        { IDI_CPHOTO,  IDS_SCANSEL_COLORPHOTO, WIA_INTENT_IMAGE_TYPE_COLOR},
        { IDI_BWPHOTO, IDS_SCANSEL_BW,         WIA_INTENT_IMAGE_TYPE_GRAYSCALE},
        { IDI_TEXT,    IDS_SCANSEL_TEXT,       WIA_INTENT_IMAGE_TYPE_TEXT},
        { IDI_CUSTOM,  IDS_SCANSEL_CUSTOM,     0}
    };
    static const int s_nIntents = ARRAYSIZE(s_Intents);

    //
    // We are going to hide all of the controls we don't use
    //
    int nCurControlSet = 0;

    CWiaItem *pCurItem = GetActiveScannerItem();
    if (pCurItem)
    {
        LONG nIntents;
        if (PropStorageHelpers::GetPropertyFlags( pCurItem->WiaItem(), WIA_IPS_CUR_INTENT, nIntents ))
        {
            for (int i=0;i<s_nIntents;i++)
            {
                //
                // Make sure it is the special custom intent, OR it is a supported intent
                //
                if (!s_Intents[i].nIntent || (nIntents & s_Intents[i].nIntent))
                {
                    HICON hIcon = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(s_Intents[i].nIconId), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR ));
                    SendDlgItemMessage( m_hWnd, gs_IntentRadioButtonIconPairs[nCurControlSet].nIconId, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0 );
                    CSimpleString( s_Intents[i].nStringId, g_hInstance ).SetWindowText( GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[nCurControlSet].nRadioId ) );
                    //
                    // Only add the intent if there is one.  If we don't add it, it will be 0, signifying that we should use the custom settings
                    //
                    if (s_Intents[i].nIntent)
                    {
                        //
                        // Add in the WIA_INTENT_MINIMIZE_SIZE flag, to ensure the size is not too large
                        //
                        SetWindowLongPtr( GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[nCurControlSet].nRadioId ), GWLP_USERDATA, (s_Intents[i].nIntent|WIA_INTENT_MINIMIZE_SIZE));
                    }
                    nCurControlSet++;
                }
            }
        }
        //
        // Set the default intent to be the first in the list
        //
        SetIntentCheck(static_cast<LONG>(GetWindowLongPtr(GetDlgItem(m_hWnd, gs_IntentRadioButtonIconPairs[0].nRadioId ), GWLP_USERDATA )));

        //
        // Get the saved property stream
        //
        pCurItem->SavedPropertyStream().AssignFromWiaItem(pCurItem->WiaItem());

        //
        // Try to get our persisted settings and set them.  If an error occurs, we will get new custom settings.
        //
        if (!pCurItem->CustomPropertyStream().ReadFromRegistry( pCurItem->WiaItem(), HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, REGSTR_KEYNAME_USER_SETTINGS_WIAACMGR ) ||
            FAILED(pCurItem->CustomPropertyStream().ApplyToWiaItem(pCurItem->WiaItem())))
        {
            //
            // Apply the current intent before getting the new custom intent
            //
            ApplyCurrentIntent();

            //
            // Get the default custom property stream
            //
            pCurItem->CustomPropertyStream().AssignFromWiaItem(pCurItem->WiaItem());
        }
    }

    //
    // Hide the controls we didn't use
    //
    for (int i=nCurControlSet;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        ShowWindow( GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[i].nRadioId ), SW_HIDE );
        ShowWindow( GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[i].nIconId ), SW_HIDE );
    }
}

static void MyEnableWindow( HWND hWndControl, BOOL bEnable )
{
    if (hWndControl)
    {
        BOOL bEnabled = (IsWindowEnabled( hWndControl ) != FALSE);
        if (bEnable != bEnabled)
        {
            EnableWindow( hWndControl, bEnable );
        }
    }
}

void CScannerSelectionPage::EnableControl( int nControl, BOOL bEnable )
{
    HWND hWndControl = GetDlgItem( m_hWnd, nControl );
    if (hWndControl)
    {
        BOOL bEnabled = (IsWindowEnabled( hWndControl ) != FALSE);
        if (bEnable != bEnabled)
        {
            EnableWindow( hWndControl, bEnable );
        }
    }
}

void CScannerSelectionPage::ShowControl( int nControl, BOOL bShow )
{
    HWND hWndControl = GetDlgItem( m_hWnd, nControl );
    if (hWndControl)
    {
        ShowWindow( hWndControl, bShow ? SW_SHOW : SW_HIDE );
        if (!bShow)
        {
            EnableControl( nControl, FALSE );
        }
    }
}

//
// Update the preview-related controls' states
//
void CScannerSelectionPage::UpdateControlState(void)
{
    WIA_PUSH_FUNCTION((TEXT("CScannerSelectionPage::UpdateControlState") ));
    //
    // Assume we will be showing the preview control
    //
    BOOL bShowPreview = TRUE;

    //
    // First of all, we know we don't allow preview on scroll-fed scanners
    //
    if (m_pControllerWindow->m_nScannerType == CAcquisitionManagerControllerWindow::ScannerTypeScrollFed)
    {
        bShowPreview = FALSE;
    }

    else
    {
        //
        // If we are in feeder mode, we won't show the preview UNLESS the driver explicitly tells us to do so.
        //
        LONG nCurrentPaperSource = 0;
        if (PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, static_cast<LONG>(nCurrentPaperSource)))
        {
            if (FEEDER & nCurrentPaperSource)
            {
                WIA_TRACE((TEXT("FEEDER == nCurrentPaperSource")));

                m_bAllowRegionPreview = false;

                //
                // Remove the tabstop setting from the preview control if we are in feeder mode
                //
                SetWindowLongPtr( m_hwndPreview, GWL_STYLE, GetWindowLongPtr( m_hwndPreview, GWL_STYLE ) & ~WS_TABSTOP );

                LONG nShowPreviewControl = WIA_DONT_SHOW_PREVIEW_CONTROL;
                if (PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_SHOW_PREVIEW_CONTROL, static_cast<LONG>(nShowPreviewControl)))
                {
                    WIA_TRACE((TEXT("WIA_DPS_SHOW_PREVIEW_CONTROL = %d"),nShowPreviewControl));
                    if (WIA_DONT_SHOW_PREVIEW_CONTROL == nShowPreviewControl)
                    {
                        bShowPreview = FALSE;
                    }
                }
                else
                {
                    WIA_TRACE((TEXT("WIA_DPS_SHOW_PREVIEW_CONTROL was not available")));
                    bShowPreview = FALSE;
                }
            }
            else
            {
                //
                // Enable preview in flatbed mode
                //
                m_bAllowRegionPreview = false;
                CWiaItem *pWiaItem = GetActiveScannerItem();
                if (pWiaItem && pWiaItem->BitmapImage())
                {
                    m_bAllowRegionPreview = true;
                }

                //
                // Add the tabstop setting to the preview control if we are in flatbed mode
                //
                SetWindowLongPtr( m_hwndPreview, GWL_STYLE, GetWindowLongPtr( m_hwndPreview, GWL_STYLE ) | WS_TABSTOP );
            }
        }
        else
        {
            WIA_TRACE((TEXT("WIA_DPS_DOCUMENT_HANDLING_SELECT is not available")));
        }
    }

    //
    // Update the preview related controls
    //

    WIA_TRACE((TEXT("bShowPreview = %d"), bShowPreview ));
    if (bShowPreview)
    {
        ShowControl( IDC_SCANSEL_PREVIEW, TRUE );
        ShowControl( IDC_SCANSEL_SELECTION_BUTTON_BAR, TRUE );
        ShowControl( IDC_SCANSEL_RESCAN, TRUE );
        EnableControl( IDC_SCANSEL_PREVIEW, TRUE );
        if (m_bAllowRegionPreview)
        {
            ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR ), IDC_SCANSEL_SHOW_SELECTION, true );
            ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR ), IDC_SCANSEL_SHOW_BED, true );
        }
        else
        {
            ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR ), IDC_SCANSEL_SHOW_SELECTION, false );
            ToolbarHelper::EnableToolbarButton( GetDlgItem( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR ), IDC_SCANSEL_SHOW_BED, false );
        }
        EnableControl( IDC_SCANSEL_RESCAN, TRUE );
        m_hwndPreview = GetDlgItem( m_hWnd, IDC_SCANSEL_PREVIEW );
        m_hwndSelectionToolbar = GetDlgItem( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR );
        m_hwndRescan = GetDlgItem( m_hWnd, IDC_SCANSEL_RESCAN );
        PropSheet_SetHeaderSubTitle( GetParent(m_hWnd), PropSheet_HwndToIndex( GetParent(m_hWnd), m_hWnd ), CSimpleString( IDS_SCANNER_SELECT_SUBTITLE, g_hInstance ).String() );
    }
    else
    {
        ShowControl( IDC_SCANSEL_PREVIEW, FALSE );
        ShowControl( IDC_SCANSEL_SELECTION_BUTTON_BAR, FALSE );
        ShowControl( IDC_SCANSEL_RESCAN, FALSE );
        m_hwndPreview = NULL;
        m_hwndSelectionToolbar = NULL;
        m_hwndRescan = NULL;
        PropSheet_SetHeaderSubTitle( GetParent(m_hWnd), PropSheet_HwndToIndex( GetParent(m_hWnd), m_hWnd ), CSimpleString( IDS_SCANNER_SELECT_SUBTITLE_NO_PREVIEW, g_hInstance ).String() );
    }
}

LRESULT CScannerSelectionPage::OnInitDialog( WPARAM, LPARAM lParam )
{
    //
    // Make sure this starts out NULL
    //
    m_pControllerWindow = NULL;

    //
    // Get the PROPSHEETPAGE.lParam
    //
    PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE*>(lParam);
    if (pPropSheetPage)
    {
        m_pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(pPropSheetPage->lParam);
        if (m_pControllerWindow)
        {
            m_pControllerWindow->m_WindowList.Add(m_hWnd);
        }
    }

    //
    // Bail out
    //
    if (!m_pControllerWindow)
    {
        EndDialog(m_hWnd,IDCANCEL);
        return -1;
    }

    //
    // Dismiss the progress dialog if it is still up
    //
    if (m_pControllerWindow->m_pWiaProgressDialog)
    {
        m_pControllerWindow->m_pWiaProgressDialog->Destroy();
        m_pControllerWindow->m_pWiaProgressDialog = NULL;
    }

    if (m_pControllerWindow->m_pWiaItemRoot)
    {
        //
        // Get the flatbed aspect ratio
        //
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_HORIZONTAL_BED_SIZE, m_sizeFlatbed.cx );
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_VERTICAL_BED_SIZE, m_sizeFlatbed.cy );

        //
        // Get the sheet feeder aspect ratio
        //
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, m_sizeDocfeed.cx );
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, m_sizeDocfeed.cy );

    }

    UpdateControlState();

    if (m_hwndPreview)
    {
        //
        // Set a bitmap, so we can select stuff even if the user doesn't do a preview scan
        //
        m_hBitmapDefaultPreviewBitmap = reinterpret_cast<HBITMAP>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_DEFAULT_SCANNER_BITMAP), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION|LR_DEFAULTCOLOR ));
        if (m_hBitmapDefaultPreviewBitmap)
        {
            WiaPreviewControl_SetBitmap( m_hwndPreview, TRUE, TRUE, m_hBitmapDefaultPreviewBitmap );
        }

        //
        // Initialize the selection rectangle
        //
        WiaPreviewControl_ClearSelection( m_hwndPreview );

        //
        // Ensure that the aspect ratio is correct
        //
        WiaPreviewControl_SetDefAspectRatio( m_hwndPreview, &m_sizeFlatbed );
    }

    ToolbarHelper::CButtonDescriptor SelectionButtonDescriptors[] =
    {
        { 0, IDC_SCANSEL_SHOW_SELECTION, 0, BTNS_BUTTON|BTNS_CHECK, false, NULL, 0 },
        { 1, IDC_SCANSEL_SHOW_BED,  TBSTATE_CHECKED, BTNS_BUTTON|BTNS_CHECK, false, NULL, 0 }
    };

    HWND hWndSelectionToolbar = ToolbarHelper::CreateToolbar(
        m_hWnd,
        GetDlgItem(m_hWnd,IDC_SCANSEL_RESCAN),
        GetDlgItem(m_hWnd,IDC_SCANSEL_BUTTON_BAR_GUIDE),
        ToolbarHelper::AlignRight|ToolbarHelper::AlignTop,
        IDC_SCANSEL_SELECTION_BUTTON_BAR,
        m_ScannerSelectionButtonBarBitmapInfo,
        SelectionButtonDescriptors,
        ARRAYSIZE(SelectionButtonDescriptors) );

    //
    // Nuke the guide window
    //
    DestroyWindow( GetDlgItem(m_hWnd,IDC_SCANSEL_BUTTON_BAR_GUIDE) );

    //
    // Make sure the toolbars are visible
    //
    ShowWindow( hWndSelectionToolbar, SW_SHOW );
    UpdateWindow( hWndSelectionToolbar );

    //
    // Get the page sizes
    //
    CComPtr<IWiaScannerPaperSizes> pWiaScannerPaperSizes;
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaScannerPaperSizes, (void**)&pWiaScannerPaperSizes );
    if (SUCCEEDED(hr))
    {
        hr = pWiaScannerPaperSizes->GetPaperSizes( &m_pPaperSizes, &m_nPaperSizeCount );
        if (FAILED(hr))
        {
            EndDialog( m_hWnd, hr );
        }
    }


    //
    // Initialize the intent controls, set the initial intent, etc.
    //
    InitializeIntents();

    PopulateDocumentHandling();

    PopulatePageSize();

    HandlePaperSourceSelChange();

    HandlePaperSizeSelChange();

    return 0;
}

void CScannerSelectionPage::PopulateDocumentHandling(void)
{
    HWND hWndDocumentHandling = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSOURCE );
    if (m_pControllerWindow->m_pWiaItemRoot &&
        m_pControllerWindow->m_nScannerType == CAcquisitionManagerControllerWindow::ScannerTypeFlatbedAdf &&
        hWndDocumentHandling)
    {
        LONG nDocumentHandlingSelectFlags = 0;
        PropStorageHelpers::GetPropertyFlags( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelectFlags );

        LONG nDocumentHandlingSelect = 0;
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelect );

        if (!nDocumentHandlingSelectFlags)
        {
            nDocumentHandlingSelectFlags = FLATBED;
        }
        if (!nDocumentHandlingSelect)
        {
            nDocumentHandlingSelect = FLATBED;
        }

        int nSelectIndex = 0;
        for (int i=0;i<g_SupportedDocumentHandlingTypesCount;i++)
        {
            if (nDocumentHandlingSelectFlags & g_SupportedDocumentHandlingTypes[i].nFlag)
            {
                CSimpleString strDocumentHandlingName( g_SupportedDocumentHandlingTypes[i].nStringId, g_hInstance );
                if (strDocumentHandlingName.Length())
                {
                    LRESULT nIndex = SendMessage( hWndDocumentHandling, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strDocumentHandlingName.String()));
                    if (nIndex != CB_ERR)
                    {
                        SendMessage( hWndDocumentHandling, CB_SETITEMDATA, nIndex, g_SupportedDocumentHandlingTypes[i].nFlag );
                        if (nDocumentHandlingSelect == g_SupportedDocumentHandlingTypes[i].nFlag)
                        {
                            nSelectIndex = (int)nIndex;
                        }
                    }
                }
            }
        }

        WIA_TRACE((TEXT("Selecting index %d"), nSelectIndex ));
        SendMessage( hWndDocumentHandling, CB_SETCURSEL, nSelectIndex, 0 );

        //
        // Make sure all of the strings fit
        //
        WiaUiUtil::ModifyComboBoxDropWidth(hWndDocumentHandling);
    }
}

void CScannerSelectionPage::PopulatePageSize(void)
{
    HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSIZE );
    if (m_pControllerWindow->m_pWiaItemRoot &&
        m_pControllerWindow->m_nScannerType == CAcquisitionManagerControllerWindow::ScannerTypeFlatbedAdf &&
        hWndPaperSize)
    {
        LONG nWidth=0, nHeight=0;
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, nWidth );
        PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, nHeight );

        //
        // Which index will initially be selected?
        //
        LRESULT nSelectIndex = 0;

        //
        // Save the largest sheet as our initially selected size
        //
        __int64 nMaximumArea = 0;
        for (UINT i=0;i<m_nPaperSizeCount;i++)
        {
            //
            // If this page will fit in the scanner...
            //
            if (m_pPaperSizes[i].nWidth <= static_cast<UINT>(nWidth) && m_pPaperSizes[i].nHeight <= static_cast<UINT>(nHeight))
            {
                //
                // Get the string name for this paper size
                //
                CSimpleString strPaperSizeName( CSimpleStringConvert::NaturalString(CSimpleStringWide(m_pPaperSizes[i].pszName)) );
                if (strPaperSizeName.Length())
                {
                    //
                    // Add the string to the combobox
                    //
                    LRESULT nIndex = SendMessage( hWndPaperSize, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strPaperSizeName.String()));
                    if (nIndex != CB_ERR)
                    {
                        //
                        // Save the index into our global array
                        //
                        SendMessage( hWndPaperSize, CB_SETITEMDATA, nIndex, i );

                        //
                        // Check to see if this is the largest page, if it is, save the area and the index
                        //
                        if (((__int64)m_pPaperSizes[i].nWidth * m_pPaperSizes[i].nHeight) > nMaximumArea)
                        {
                            nMaximumArea = m_pPaperSizes[i].nWidth * m_pPaperSizes[i].nHeight;
                            nSelectIndex = nIndex;
                        }
                    }
                }
            }
        }
        //
        // Select the default size
        //
        SendMessage( hWndPaperSize, CB_SETCURSEL, nSelectIndex, 0 );

        //
        // Make sure all of the strings fit
        //
        WiaUiUtil::ModifyComboBoxDropWidth(hWndPaperSize);
    }
}

void CScannerSelectionPage::HandlePaperSourceSelChange(void)
{
    //
    // Make sure we have a valid root item
    //
    if (m_pControllerWindow->m_pWiaItemRoot)
    {
        //
        // Get the paper source combobox and make sure it exists
        //
        HWND hWndPaperSource = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSOURCE );
        if (hWndPaperSource)
        {
            //
            // Get the currently selected paper source
            //
            LRESULT nCurSel = SendMessage( hWndPaperSource, CB_GETCURSEL, 0, 0 );
            if (nCurSel != CB_ERR)
            {
                //
                // Get the paper source
                //
                LRESULT nPaperSource = SendMessage( hWndPaperSource, CB_GETITEMDATA, nCurSel, 0 );
                if (nPaperSource)
                {
                    //
                    // Set the paper source on the actual item
                    //
                    PropStorageHelpers::SetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_DOCUMENT_HANDLING_SELECT, static_cast<LONG>(nPaperSource) );

                    if (nPaperSource & FLATBED)
                    {
                        //
                        // Make sure all of the preview-related controls are visible and enabled
                        //
                        UpdateControlState();

                        if (m_hwndPreview)
                        {
                            //
                            // Adjust the preview control settings for allowing region selection
                            //
                            WiaPreviewControl_SetDefAspectRatio( m_hwndPreview, &m_sizeFlatbed );
                            WiaPreviewControl_DisableSelection( m_hwndPreview, FALSE );
                            WiaPreviewControl_SetBorderStyle( m_hwndPreview, TRUE, PS_DOT, 0 );
                            WiaPreviewControl_SetHandleSize( m_hwndPreview, TRUE, 6 );
                        }

                        //
                        // Disable the paper size controls
                        //
                        EnableControl( IDC_SCANSEL_PAPERSIZE, FALSE );
                        EnableControl( IDC_SCANSEL_PAPERSIZE_STATIC, FALSE );
                    }
                    else
                    {
                        //
                        // Make sure all of the preview-related controls are NOT visible
                        //
                        UpdateControlState();

                        if (m_hwndPreview)
                        {
                            //
                            // Adjust the preview control settings for displaying paper selection
                            //
                            WiaPreviewControl_SetDefAspectRatio( m_hwndPreview, &m_sizeDocfeed );
                            WiaPreviewControl_DisableSelection( m_hwndPreview, TRUE );
                            WiaPreviewControl_SetBorderStyle( m_hwndPreview, TRUE, PS_SOLID, 0 );
                            WiaPreviewControl_SetHandleSize( m_hwndPreview, TRUE, 0 );
                        }

                        //
                        // Enable the paper size controls
                        //
                        EnableControl( IDC_SCANSEL_PAPERSIZE, TRUE );
                        EnableControl( IDC_SCANSEL_PAPERSIZE_STATIC, TRUE );

                        //
                        // Update the region selection feedback
                        //
                        HandlePaperSizeSelChange();
                    }

                    //
                    // Reset the preview selection setting
                    //
                    WiaPreviewControl_SetPreviewMode( m_hwndPreview, FALSE );
                    ToolbarHelper::CheckToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_SELECTION, false );
                    ToolbarHelper::CheckToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_BED, true );
                }
            }
        }
    }
}


void CScannerSelectionPage::HandlePaperSizeSelChange(void)
{
    if (m_pControllerWindow->m_pWiaItemRoot)
    {
        HWND hWndPaperSize = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSIZE );
        if (InDocFeedMode() && hWndPaperSize)
        {
            LRESULT nCurSel = SendMessage( hWndPaperSize, CB_GETCURSEL, 0, 0 );
            if (nCurSel != CB_ERR)
            {
                LRESULT nPaperSizeIndex = SendMessage( hWndPaperSize, CB_GETITEMDATA, nCurSel, 0 );
                POINT ptOrigin = { 0, 0 };
                SIZE sizeExtent = { m_pPaperSizes[nPaperSizeIndex].nWidth, m_pPaperSizes[nPaperSizeIndex].nHeight };

                if (!sizeExtent.cx)
                {
                    sizeExtent.cx = m_sizeDocfeed.cx;
                }
                if (!sizeExtent.cy)
                {
                    sizeExtent.cy = m_sizeDocfeed.cy;
                }

                LONG nSheetFeederRegistration;
                if (!PropStorageHelpers::GetProperty( m_pControllerWindow->m_pWiaItemRoot, WIA_DPS_SHEET_FEEDER_REGISTRATION, nSheetFeederRegistration ))
                {
                    nSheetFeederRegistration = LEFT_JUSTIFIED;
                }
                if (nSheetFeederRegistration == CENTERED)
                {
                    ptOrigin.x = (m_sizeDocfeed.cx - sizeExtent.cx) / 2;
                }
                else if (nSheetFeederRegistration == RIGHT_JUSTIFIED)
                {
                    ptOrigin.x = m_sizeDocfeed.cx - sizeExtent.cx;
                }
                if (m_hwndPreview)
                {
                    WiaPreviewControl_SetResolution( m_hwndPreview, &m_sizeDocfeed );
                    WiaPreviewControl_SetSelOrigin( m_hwndPreview, 0, FALSE, &ptOrigin );
                    WiaPreviewControl_SetSelExtent( m_hwndPreview, 0, FALSE, &sizeExtent );
                }
            }
        }
    }
}


void CScannerSelectionPage::OnPaperSourceSelChange( WPARAM, LPARAM )
{
    HandlePaperSourceSelChange();
}

void CScannerSelectionPage::OnPaperSizeSelChange( WPARAM, LPARAM )
{
    HandlePaperSizeSelChange();
}


bool CScannerSelectionPage::InDocFeedMode(void)
{
    HWND hWndPaperSource = GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSOURCE );
    if (hWndPaperSource)
    {
        LRESULT nCurSel = SendMessage( hWndPaperSource, CB_GETCURSEL, 0, 0 );
        if (nCurSel != CB_ERR)
        {
            LRESULT nPaperSource = SendMessage( hWndPaperSource, CB_GETITEMDATA, nCurSel, 0 );
            if (nPaperSource)
            {
                if (nPaperSource & FEEDER)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

void CScannerSelectionPage::EnableControls( BOOL bEnable )
{
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_INTENT_1 ), bEnable );
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_INTENT_2 ), bEnable );
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_INTENT_3 ), bEnable );
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_INTENT_4 ), bEnable );
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_PROPERTIES ), bEnable );

    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSOURCE_STATIC ), bEnable );
    MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSOURCE ), bEnable );

    if (m_hwndPreview)
    {
        MyEnableWindow( m_hwndPreview, bEnable );
    }

    if (m_hwndRescan)
    {
        MyEnableWindow( m_hwndRescan, bEnable );
    }

    //
    // Only disable/enable this control if we are in document feeder mode
    //
    if (InDocFeedMode())
    {
        MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSIZE_STATIC ), bEnable );
        MyEnableWindow( GetDlgItem( m_hWnd, IDC_SCANSEL_PAPERSIZE ), bEnable );
    }

    //
    // Only disable/enable this control if there is an image in it.
    //
    if (m_bAllowRegionPreview && m_hwndSelectionToolbar)
    {
        MyEnableWindow( m_hwndSelectionToolbar, bEnable );
        ToolbarHelper::EnableToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_SELECTION, bEnable != FALSE );
        ToolbarHelper::EnableToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_BED, bEnable != FALSE );
    }

    if (PropSheet_GetCurrentPageHwnd(GetParent(m_hWnd)) == m_hWnd)
    {
        if (bEnable)
        {
            PropSheet_SetWizButtons( GetParent(m_hWnd), PSWIZB_NEXT|PSWIZB_BACK );
        }
        else
        {
            PropSheet_SetWizButtons( GetParent(m_hWnd), 0 );
        }
    }
}

void CScannerSelectionPage::OnNotifyScanPreview( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    //
    // If we don't have a preview window, we can't do previews
    //
    if (m_hwndPreview)
    {
        CPreviewScanThreadNotifyMessage *pPreviewScanThreadNotifyMessage = dynamic_cast<CPreviewScanThreadNotifyMessage*>(pThreadNotificationMessage);
        if (pPreviewScanThreadNotifyMessage)
        {
            switch (pPreviewScanThreadNotifyMessage->Status())
            {
            case CPreviewScanThreadNotifyMessage::Begin:
                {
                    //
                    // Erase the old bitmap
                    //
                    WiaPreviewControl_SetBitmap( m_hwndPreview, TRUE, TRUE, m_hBitmapDefaultPreviewBitmap );

                    //
                    // Tell the user we are initializing the device
                    //
                    CSimpleString( IDS_SCANSEL_INITIALIZING_SCANNER, g_hInstance ).SetWindowText( m_hwndPreview );

                    //
                    // Start the warming up progress bar
                    //
                    WiaPreviewControl_SetProgress( m_hwndPreview, TRUE );

                    //
                    // Don't allow zooming the selected region in case there are any problems
                    //
                    m_bAllowRegionPreview = false;
                }
                break;
            case CPreviewScanThreadNotifyMessage::Update:
                {
                    //
                    // Update the bitmap
                    //
                    if (WiaPreviewControl_GetBitmap(m_hwndPreview) && WiaPreviewControl_GetBitmap(m_hwndPreview) != m_hBitmapDefaultPreviewBitmap)
                    {
                        WiaPreviewControl_RefreshBitmap( m_hwndPreview );
                    }
                    else
                    {
                        WiaPreviewControl_SetBitmap( m_hwndPreview, TRUE, TRUE, pPreviewScanThreadNotifyMessage->Bitmap() );
                    }

                    //
                    // Tell the user we are scanning
                    //
                    CSimpleString( IDS_SCANSEL_SCANNINGPREVIEW, g_hInstance ).SetWindowText( m_hwndPreview );

                    //
                    // Hide the progress control
                    //
                    WiaPreviewControl_SetProgress( m_hwndPreview, FALSE );
                }
                break;
            case CPreviewScanThreadNotifyMessage::End:
                {
                    WIA_PRINTHRESULT((pPreviewScanThreadNotifyMessage->hr(),TEXT("Handling CPreviewScanThreadNotifyMessage::End")));

                    //
                    // Set the bitmap in the preview control
                    //
                    WiaPreviewControl_SetBitmap( m_hwndPreview, TRUE, TRUE, pPreviewScanThreadNotifyMessage->Bitmap() ? pPreviewScanThreadNotifyMessage->Bitmap() : m_hBitmapDefaultPreviewBitmap );

                    UpdateWindow( m_hwndPreview );

                    //
                    // Store the bitmap for later
                    //
                    CWiaItem *pWiaItem = m_pControllerWindow->m_WiaItemList.Find( pPreviewScanThreadNotifyMessage->Cookie() );
                    if (pWiaItem)
                    {
                        //
                        // Set the bitmap, whether it is NULL or not.
                        //
                        pWiaItem->BitmapImage(pPreviewScanThreadNotifyMessage->Bitmap());
                    }

                    if (SUCCEEDED(pPreviewScanThreadNotifyMessage->hr()))
                    {
                        //
                        // Only do the region detection if the user hasn't changed it manually,
                        // and only if we are not in document feeder mode.
                        //
                        if (!WiaPreviewControl_GetUserChangedSelection( m_hwndPreview ) && !InDocFeedMode())
                        {
                            WiaPreviewControl_DetectRegions( m_hwndPreview );
                        }
                        //
                        // Allow the user to zoom the selected region if there is a bitmap
                        //
                        if (pPreviewScanThreadNotifyMessage->Bitmap())
                        {
                            m_bAllowRegionPreview = true;
                        }
                    }
                    else if (m_pControllerWindow->m_bDisconnected || WIA_ERROR_OFFLINE == pPreviewScanThreadNotifyMessage->hr())
                    {
                        //
                        // Do nothing.
                        //
                    }
                    else
                    {
                        //
                        // Tell the user something bad happened
                        //
                        CSimpleString strMessage;
                        switch (pPreviewScanThreadNotifyMessage->hr())
                        {
                        case WIA_ERROR_PAPER_EMPTY:
                            strMessage.LoadString( IDS_PREVIEWOUTOFPAPER, g_hInstance );
                            break;

                        default:
                            strMessage.LoadString( IDS_PREVIEWSCAN_ERROR, g_hInstance );
                            break;
                        }

                        CMessageBoxEx::MessageBox( m_hWnd, strMessage, CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONWARNING );
                        WIA_PRINTHRESULT((pPreviewScanThreadNotifyMessage->hr(),TEXT("The preview scan FAILED!")));
                    }

                    //
                    // Re-enable all of the controls
                    //
                    EnableControls(TRUE);

                    //
                    // Update the preview-related controls
                    //
                    UpdateControlState();

                    //
                    // remove the status text
                    //
                    SetWindowText( m_hwndPreview, TEXT("") );

                    //
                    // Restore the preview mode
                    //
                    WiaPreviewControl_SetPreviewMode( m_hwndPreview, InPreviewMode() );

                    //
                    // Hide the animation
                    //
                    WiaPreviewControl_SetProgress( m_hwndPreview, FALSE );
                }
                break;
            }
        }
    }
}

void CScannerSelectionPage::SetIntentCheck( LONG nIntent )
{
    for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        HWND hWndBtn = GetDlgItem( m_hWnd, gs_IntentRadioButtonIconPairs[i].nRadioId );
        if (hWndBtn)
        {
            // If this intent is the same as the one we've been asked to set, check it
            if (static_cast<LONG>(GetWindowLongPtr(hWndBtn,GWLP_USERDATA)) == nIntent)
            {
                SendMessage( hWndBtn, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                // Uncheck all others
                SendMessage( hWndBtn, BM_SETCHECK, BST_UNCHECKED, 0 );
            }
        }
    }
}


void CScannerSelectionPage::OnProperties( WPARAM, LPARAM )
{
    CWaitCursor wc;
    CWiaItem *pCurItem = GetActiveScannerItem();
    if (pCurItem && pCurItem->WiaItem())
    {
        if (!ApplyCurrentIntent())
        {
            //
            // Tell the user it failed, and to try again
            //
            CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_ERROR_SETTING_PROPS, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONINFORMATION );
            return;
        }

        HRESULT hr = WiaUiUtil::SystemPropertySheet( g_hInstance, m_hWnd, pCurItem->WiaItem(), CSimpleString(IDS_ADVANCEDPROPERTIES, g_hInstance) );
        if (SUCCEEDED(hr))
        {
            if (S_OK == hr)
            {
                pCurItem->CustomPropertyStream().AssignFromWiaItem(pCurItem->WiaItem());
                if (pCurItem->CustomPropertyStream().IsValid())
                {
                    SetIntentCheck(0);
                }
                else WIA_ERROR((TEXT("Unknown error: m_CustomPropertyStream is not valid")));
            }
            else WIA_TRACE((TEXT("User cancelled")));
        }
        else
        {
            CMessageBoxEx::MessageBox( m_hWnd, CSimpleString( IDS_PROPERTY_SHEET_ERROR, g_hInstance ), CSimpleString( IDS_ERROR_TITLE, g_hInstance ), CMessageBoxEx::MBEX_ICONINFORMATION );
            WIA_PRINTHRESULT((hr,TEXT("SystemPropertySheet failed")));
        }
    }
    else WIA_TRACE((TEXT("No current item")));
}

void CScannerSelectionPage::OnPreviewSelection( WPARAM wParam, LPARAM )
{
    if (m_hwndPreview && m_hwndSelectionToolbar)
    {

        bool bNewPreviewSetting = (LOWORD(wParam) == IDC_SCANSEL_SHOW_SELECTION);
        bool bOldPreviewSetting = WiaPreviewControl_GetPreviewMode( m_hwndPreview ) != FALSE;
        ToolbarHelper::CheckToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_SELECTION, LOWORD(wParam) == IDC_SCANSEL_SHOW_SELECTION );
        ToolbarHelper::CheckToolbarButton( m_hwndSelectionToolbar, IDC_SCANSEL_SHOW_BED, LOWORD(wParam) == IDC_SCANSEL_SHOW_BED );
        if (bNewPreviewSetting != bOldPreviewSetting)
        {
            WiaPreviewControl_SetPreviewMode( m_hwndPreview, LOWORD(wParam) == IDC_SCANSEL_SHOW_SELECTION );
        }
    }
}

LRESULT CScannerSelectionPage::OnReset( WPARAM, LPARAM )
{
    m_PreviewScanCancelEvent.Signal();
    return 0;
}

LRESULT CScannerSelectionPage::OnGetToolTipDispInfo( WPARAM wParam, LPARAM lParam )
{
    TOOLTIPTEXT *pToolTipText = reinterpret_cast<TOOLTIPTEXT*>(lParam);
    if (pToolTipText)
    {

        switch (pToolTipText->hdr.idFrom)
        {
        case IDC_SCANSEL_SHOW_SELECTION:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_SCANSEL_SHOW_SELECTION);
            break;
        case IDC_SCANSEL_SHOW_BED:
            pToolTipText->hinst = g_hInstance;
            pToolTipText->lpszText = MAKEINTRESOURCE(IDS_SCANSEL_SHOW_BED);
            break;
        }
    }
    return 0;
}

LRESULT CScannerSelectionPage::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDC_SCANSEL_RESCAN,OnRescan);
        SC_HANDLE_COMMAND(IDC_SCANSEL_PROPERTIES,OnProperties);
        SC_HANDLE_COMMAND(IDC_SCANSEL_SHOW_SELECTION,OnPreviewSelection);
        SC_HANDLE_COMMAND(IDC_SCANSEL_SHOW_BED,OnPreviewSelection);
        SC_HANDLE_COMMAND_NOTIFY( CBN_SELCHANGE, IDC_SCANSEL_PAPERSOURCE, OnPaperSourceSelChange );
        SC_HANDLE_COMMAND_NOTIFY( CBN_SELCHANGE, IDC_SCANSEL_PAPERSIZE, OnPaperSizeSelChange );
    }
    SC_END_COMMAND_HANDLERS();
}

LRESULT CScannerSelectionPage::OnNotify( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
    {
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZNEXT,OnWizNext);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_WIZBACK,OnWizBack);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_SETACTIVE,OnSetActive);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(PSN_RESET,OnReset);
        SC_HANDLE_NOTIFY_MESSAGE_CODE(TTN_GETDISPINFO,OnGetToolTipDispInfo);
    }
    SC_END_NOTIFY_MESSAGE_HANDLERS();
}

LRESULT CScannerSelectionPage::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WTM_BEGIN_THREAD_NOTIFY_MESSAGE_HANDLERS()
    {
        WTM_HANDLE_NOTIFY_MESSAGE( TQ_SCANPREVIEW, OnNotifyScanPreview );
    }
    WTM_END_THREAD_NOTIFY_MESSAGE_HANDLERS();
}

LRESULT CScannerSelectionPage::OnEventNotification( WPARAM, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CCommonFirstPage::OnEventNotification") ));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // Don't delete the message, it is deleted in the controller window
        //
    }
    return 0;
}

LRESULT CScannerSelectionPage::OnDestroy( WPARAM, LPARAM )
{
    //
    // Nuke all of the intent icons we loaded
    //
    for (int i=0;i<gs_nCountIntentRadioButtonIconPairs;i++)
    {
        HICON hIcon = reinterpret_cast<HICON>(SendDlgItemMessage( m_hWnd, gs_IntentRadioButtonIconPairs[i].nIconId, STM_SETICON, 0, 0 ));
        if (hIcon)
        {
            DestroyIcon(hIcon);
        }
    }
    return 0;
}

LRESULT CScannerSelectionPage::OnSysColorChange( WPARAM wParam, LPARAM lParam )
{
    m_ScannerSelectionButtonBarBitmapInfo.ReloadAndReplaceBitmap();
    SendDlgItemMessage( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR, WM_SYSCOLORCHANGE, wParam, lParam );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_SCANSEL_PREVIEW ), TRUE, TRUE, GetSysColor(COLOR_WINDOW) );
    WiaPreviewControl_SetBkColor( GetDlgItem( m_hWnd, IDC_SCANSEL_PREVIEW ), TRUE, FALSE, GetSysColor(COLOR_WINDOW) );
    return 0;
}

LRESULT CScannerSelectionPage::OnThemeChanged( WPARAM wParam, LPARAM lParam )
{
    SendDlgItemMessage( m_hWnd, IDC_SCANSEL_SELECTION_BUTTON_BAR, WM_THEMECHANGED, wParam, lParam );
    return 0;
}

INT_PTR CALLBACK CScannerSelectionPage::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CScannerSelectionPage)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
        SC_HANDLE_DIALOG_MESSAGE( WM_THEMECHANGED, OnThemeChanged );
    }
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nThreadNotificationMessage, OnThreadNotification );
    SC_HANDLE_REGISTERED_DIALOG_MESSAGE( m_nWiaEventMessage, OnEventNotification );
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\scansel.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SCANSEL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Scanner region selection (preview) page
 *
 *******************************************************************************/
#ifndef __SCANSEL_H_INCLUDED
#define __SCANSEL_H_INCLUDED

#include <windows.h>
#include "acqmgrcw.h"
#include "createtb.h"
#include "pviewids.h"

class CScannerSelectionPage
{
private:
    // Private data
    HWND                                 m_hWnd;
    CAcquisitionManagerControllerWindow *m_pControllerWindow;
    UINT                                 m_nThreadNotificationMessage;
    UINT                                 m_nWiaEventMessage;
    HBITMAP                              m_hBitmapDefaultPreviewBitmap;
    SIZE                                 m_sizeFlatbed;
    SIZE                                 m_sizeDocfeed;
    bool                                 m_bAllowRegionPreview;
    HWND                                 m_hwndPreview;
    HWND                                 m_hwndSelectionToolbar;
    HWND                                 m_hwndRescan;
    CWiaPaperSize                       *m_pPaperSizes;
    UINT                                 m_nPaperSizeCount;
    ToolbarHelper::CToolbarBitmapInfo    m_ScannerSelectionButtonBarBitmapInfo;
    CSimpleEvent                         m_PreviewScanCancelEvent;

private:
    // No implementation
    CScannerSelectionPage(void);
    CScannerSelectionPage( const CScannerSelectionPage & );
    CScannerSelectionPage &operator=( const CScannerSelectionPage & );

private:
    // Constructor and destructor
    explicit CScannerSelectionPage( HWND hWnd );
    ~CScannerSelectionPage(void);

private:
    // Helpers
    CWiaItem *GetActiveScannerItem(void);
    void InitializeIntents(void);
    void EnableControls( BOOL bEnable );
    bool ApplyCurrentPreviewWindowSettings(void);
    bool ApplyCurrentIntent(void);
    void SetIntentCheck( LONG nIntent );
    void PopulateDocumentHandling(void);
    void PopulatePageSize(void);
    void HandlePaperSourceSelChange(void);
    void HandlePaperSizeSelChange(void);
    bool InDocFeedMode(void);
    void EnableControl( int nControl, BOOL bEnable );
    void ShowControl( int nControl, BOOL bShow );
    void UpdateControlState(void);
    bool InPreviewMode(void);

private:
    // Thread messages
    void OnNotifyScanPreview( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    LRESULT OnEventNotification( WPARAM, LPARAM );
    
    // WM_COMMAND handlers
    void OnRescan( WPARAM, LPARAM );
    void OnProperties( WPARAM, LPARAM );
    void OnPreviewSelection( WPARAM, LPARAM );
    void OnPaperSourceSelChange( WPARAM, LPARAM );
    void OnPaperSizeSelChange( WPARAM, LPARAM );

    // WM_NOTIFY handlers
    LRESULT OnWizNext( WPARAM, LPARAM );
    LRESULT OnWizBack( WPARAM, LPARAM );
    LRESULT OnSetActive( WPARAM, LPARAM );
    LRESULT OnGetToolTipDispInfo( WPARAM, LPARAM );
    LRESULT OnReset( WPARAM, LPARAM );

    // Message handlers
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnCommand( WPARAM, LPARAM );
    LRESULT OnNotify( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );
    LRESULT OnSysColorChange( WPARAM, LPARAM );
    LRESULT OnThemeChanged( WPARAM, LPARAM );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam );
};

#endif __SCANSEL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\stievent.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       STIEVENT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/6/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
// mintrans.h : Declaration of the minimal transfer component

#ifndef __STIEVENT_H_INCLUDED
#define __STIEVENT_H_INCLUDED

#include <windows.h>
#include "evntparm.h"

extern HRESULT StiEventHandler( CStiEventData &StiEventData );

#endif //__STIEVENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\stievent.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2001
 *
 *  TITLE:       STIEVENT.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        4-6-2001
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <wiaregst.h>
#include "simcrack.h"
#include "resource.h"
#include "stievent.h"
#include "evntparm.h"
#include "shmemsec.h"

//
// This dialog displays the sti application list and lets the user choose one.
//
class CStiEventHandlerDialog
{
public:
    struct CData
    { 
        //
        // This will contain the event information, including the application list,
        // which is really what we are interested in.
        //
        CStiEventData                   *pStiEventData;

        //
        // The OUT member is intended to contain the selected handler, which will
        // be copied from the list contained in the CStiEventData class
        //
        CStiEventData::CStiEventHandler  EventHandler;

        //
        // We will set the window handle in this shared memory section,
        // so we can activate ourselves.
        //
        CSharedMemorySection<HWND> *pStiEventHandlerSharedMemory;
    };

private:
    //
    // Not implemented
    //
    CStiEventHandlerDialog();
    CStiEventHandlerDialog( const CStiEventHandlerDialog & );
    CStiEventHandlerDialog &operator=( const CStiEventHandlerDialog & );

private:
    HWND   m_hWnd;
    CData *m_pData;

private:
    //
    // Sole constructor
    //
    explicit CStiEventHandlerDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }

    //
    // Destructor
    //
    ~CStiEventHandlerDialog()
    {
        m_hWnd = NULL;
        m_pData = NULL;
    }

    //
    // WM_INITDIALOG handler.
    //
    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        //
        // Get the dialog's data
        //
        m_pData = reinterpret_cast<CData*>(lParam);

        //
        // Make sure we have valid data
        //
        if (!m_pData || !m_pData->pStiEventData)
        {
            EndDialog( m_hWnd, -1 );
            SetLastError( ERROR_INVALID_PARAMETER );
            return 0;
        }

        //
        // Make sure we were supplied with a memory section
        //
        if (m_pData->pStiEventHandlerSharedMemory)
        {
            //
            // Get a pointer to the shared memory
            //
            HWND *phWnd = m_pData->pStiEventHandlerSharedMemory->Lock();
            if (phWnd)
            {
                //
                // Store our window handle
                //
                *phWnd = m_hWnd;

                //
                // Release the mutex
                //
                m_pData->pStiEventHandlerSharedMemory->Release();
            }
        }

        //
        // Add the handlers to the list
        //
        for (int i=0;i<m_pData->pStiEventData->EventHandlers().Size();++i)
        {
            //
            // Get the program name and make sure it is valid
            //
            CSimpleString strAppName = CSimpleStringConvert::NaturalString(m_pData->pStiEventData->EventHandlers()[i].ApplicationName());
            if (strAppName.Length())
            {
                //
                // Add the string and save the item id
                //
                LRESULT nIndex = SendDlgItemMessage( m_hWnd, IDC_STI_APPS_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strAppName.String()) );
                if (LB_ERR != nIndex)
                {
                    //
                    // Set the item data to the index in our handler array 
                    //
                    SendDlgItemMessage( m_hWnd, IDC_STI_APPS_LIST, LB_SETITEMDATA, nIndex, i );
                }
            }
        }

        //
        // Select the first item
        //
        SendDlgItemMessage( m_hWnd, IDC_STI_APPS_LIST, LB_SETCURSEL, 0, 0 );

        //
        // Enable the OK button if we have a valid selected item
        //
        EnableWindow( GetDlgItem( m_hWnd, IDOK ), GetHandlerIndexOfCurrentSelection() != -1 );

        return 0;
    }

    void OnCancel( WPARAM, LPARAM )
    {
        //
        // Just close the dialog on cancel
        //
        EndDialog( m_hWnd, IDCANCEL );
    }

    int GetHandlerIndexOfCurrentSelection()
    {
        //
        // Assume failure
        //
        int nResult = -1;

        //
        // Make sure we have valid pointers still
        //
        if (m_pData && m_pData->pStiEventData)
        {
            //
            // Get the current selection index and make sure it is valid
            //
            LRESULT nCurIndex = SendDlgItemMessage( m_hWnd, IDC_STI_APPS_LIST, LB_GETCURSEL, 0, 0 );
            if (LB_ERR != nCurIndex)
            {
                //
                // Get the index into our event handler array from the item data for the current item
                //
                LRESULT nEventItemIndex = SendDlgItemMessage( m_hWnd, IDC_STI_APPS_LIST, LB_GETITEMDATA, nCurIndex, 0 );

                //
                // Make sure the index is valid
                //
                if (nEventItemIndex >= 0 && nEventItemIndex < m_pData->pStiEventData->EventHandlers().Size())
                {
                    nResult = static_cast<int>(nEventItemIndex);
                }
            }
        }

        return nResult;
    }

    void OnOK( WPARAM, LPARAM )
    {
        //
        // Make sure we have valid parameters
        //
        int nEventItemIndex = GetHandlerIndexOfCurrentSelection();
        if (-1 != nEventItemIndex)
        {
            //
            // Copy the event handler to our OUT parameter
            //
            m_pData->EventHandler = m_pData->pStiEventData->EventHandlers()[nEventItemIndex];

            //
            // Close the dialog
            //
            EndDialog( m_hWnd, IDOK );
        }
    }

    void OnAppsListDblClk( WPARAM, LPARAM )
    {
        //
        // Simulate the user pressing the OK button
        //
        SendMessage( m_hWnd, WM_COMMAND, MAKEWPARAM(IDOK,0), 0 );
    }

    void OnAppsListSelChange( WPARAM, LPARAM )
    {
        //
        // Enable the OK button if we have a valid selected item
        //
        EnableWindow( GetDlgItem( m_hWnd, IDOK ), GetHandlerIndexOfCurrentSelection() != -1 );
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
            SC_HANDLE_COMMAND(IDOK,OnOK);
            SC_HANDLE_COMMAND_NOTIFY(LBN_DBLCLK,IDC_STI_APPS_LIST,OnAppsListDblClk);
            SC_HANDLE_COMMAND_NOTIFY(LBN_SELCHANGE,IDC_STI_APPS_LIST,OnAppsListSelChange);
        }
        SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR __stdcall DlgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CStiEventHandlerDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};


HRESULT StiEventHandler( CStiEventData &StiEventData )
{
    HRESULT hr = S_OK;

#if defined(DBG)
    //
    // Dump the parameters
    //
    WIA_PUSH_FUNCTION((TEXT("StiEventHandler")));
    WIA_PRINTGUID((StiEventData.Event(),TEXT("  Event")));
    WIA_TRACE((TEXT("  EventDescription: %ws"), StiEventData.EventDescription().String()));
    WIA_TRACE((TEXT("  DeviceDescription: %ws"), StiEventData.DeviceDescription().String()));
    WIA_TRACE((TEXT("  DeviceId: %ws"), StiEventData.DeviceId().String()));
    WIA_TRACE((TEXT("  EventType: %08X"), StiEventData.EventType()));
    WIA_TRACE((TEXT("  Reserved: %08X"), StiEventData.Reserved()));
    for (int i=0;i<StiEventData.EventHandlers().Size();++i)
    {
        WIA_TRACE((TEXT("  Handler %d: [%ws] CommandLine: [%ws]"), i, StiEventData.EventHandlers()[i].ApplicationName().String(), StiEventData.EventHandlers()[i].CommandLine().String()));
    }
#endif // defined(DBG)

    //
    // Make sure we have some handlers
    //
    if (0 == StiEventData.EventHandlers().Size())
    {
        return E_INVALIDARG;
    }
    
    
    //
    // Create the mutex name
    //
    CSimpleStringWide strMutexName = StiEventData.DeviceId();

    //
    // Append the event ID
    //
    LPOLESTR pwszEventGuid = NULL;
    if (SUCCEEDED(StringFromIID( StiEventData.Event(), &pwszEventGuid )) && pwszEventGuid)
    {
        strMutexName += CSimpleStringWide(pwszEventGuid);
        CoTaskMemFree( pwszEventGuid );
    }

    WIA_TRACE((TEXT("strMutexName: %ws"), strMutexName.String() ));
    
    //
    // Create the shared memory section for excluding multiple instances
    //
    CSharedMemorySection<HWND> StiEventHandlerSharedMemory;
    
    //
    // If we were able to open the memory section
    //
    if (CSharedMemorySection<HWND>::SmsOpened == StiEventHandlerSharedMemory.Open( CSimpleStringConvert::NaturalString(CSimpleStringWide(strMutexName)), true ))
    {
        HWND *phWnd = StiEventHandlerSharedMemory.Lock();
        if (phWnd)
        {
            //
            // Make sure we have a valid window handle
            //
            if (*phWnd && IsWindow(*phWnd))
            {
                //
                // If it is a valid window, bring it to the foreground.
                //
                SetForegroundWindow(*phWnd);
            }
            
            //
            // Release the mutex
            //
            StiEventHandlerSharedMemory.Release();
        }
    }

    else
    {
        //
        // We will execute this handler below, after we decide which one to use
        //
        CStiEventData::CStiEventHandler EventHandler;

        //
        // If there is only one handler, save that handler
        //
        if (1 == StiEventData.EventHandlers().Size())
        {
            EventHandler = StiEventData.EventHandlers()[0];
        }

        //
        // Otherwise, if there is more than one handler, display the handler prompt dialog
        //
        else
        {
            //
            // Prepare the dialog data
            //
            CStiEventHandlerDialog::CData DialogData;
            DialogData.pStiEventData = &StiEventData;
            DialogData.pStiEventHandlerSharedMemory = &StiEventHandlerSharedMemory;

            //
            // Display the dialog
            //
            INT_PTR nDialogResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_CHOOSE_STI_APPLICATION), NULL, CStiEventHandlerDialog::DlgProc, reinterpret_cast<LPARAM>(&DialogData) );

            //
            // If the user selected a program and hit OK, save the handler
            //
            if (IDOK == nDialogResult)
            {
                EventHandler = DialogData.EventHandler;
            }

            //
            // If the user cancelled, just return S_FALSE immediately (premature return)
            //
            else if (IDCANCEL == nDialogResult)
            {
                return S_FALSE;
            }

            //
            // If there was an internal error, save the correct error
            //
            else if (-1 == nDialogResult)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            //
            // For all other return values, save a generic error
            //
            else
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            //
            // Make sure we have a valid handler
            //
            if (EventHandler.IsValid())
            {
                //
                // Prepare the process information
                //
                STARTUPINFO StartupInfo = {0};
                StartupInfo.cb = sizeof(StartupInfo);

                //
                // Convert the command line to a TCHAR string
                //
                CSimpleString CommandLine = CSimpleStringConvert::NaturalString(EventHandler.CommandLine());

                //
                // Make sure we actually have a command line
                //
                if (CommandLine.Length())
                {
                    //
                    // Execute the program
                    //
                    PROCESS_INFORMATION ProcessInformation = {0};
                    if (CreateProcess( NULL, const_cast<LPTSTR>(CommandLine.String()), NULL, NULL, FALSE, 0, NULL, NULL, &StartupInfo, &ProcessInformation ))
                    {
                        //
                        // If the program succeeded, close the handles to prevent leaks
                        //
                        CloseHandle( ProcessInformation.hProcess );
                        CloseHandle( ProcessInformation.hThread );
                    }
                    else
                    {
                        //
                        // Save the error from CreateProcess
                        //
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    //
                    // Assume out of memory error if we couldn't create the string
                    //
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                //
                // Who knows what went wrong?
                //
                hr = E_FAIL;
            }
        }

        //
        // If we've failed, display an error message
        //
        if (FAILED(hr))
        {
            //
            // We will display this string, after we've constructed it
            //
            CSimpleString strMessage;

            //
            // Get the error text
            //
            CSimpleString strError = WiaUiUtil::GetErrorTextFromHResult(hr);

            //
            // Get the application name
            //
            CSimpleString strApplication = CSimpleStringConvert::NaturalString(EventHandler.ApplicationName());

            //
            // If we don't have an application name, use some default
            //
            if (!strApplication.Length())
            {
                strApplication.LoadString( IDS_STI_EVENT_ERROR_APP_NAME, g_hInstance );
            }

            //
            // If we have a specific error message, use it.
            //
            if (strError.Length())
            {
                strMessage.Format( IDS_STI_EVENT_ERROR_WITH_EXPLANATION, g_hInstance, strApplication.String(), strError.String() );
            }

            //
            // Otherwise, use a generic error message.
            //
            else
            {
                strMessage.Format( IDS_STI_EVENT_ERROR_NO_EXPLANATION, g_hInstance, strApplication.String() );
            }

            //
            // Display the error message.
            //
            MessageBox( NULL, strMessage, CSimpleString( IDS_STI_EVENT_ERROR_TITLE, g_hInstance ), MB_ICONHAND );
        }
    }
    
    //
    // We're done here
    //
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\sources.inc ===
#
# include the WIA global build settings
#

USE_SHFUSION=1

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#
TARGETNAME=wiaacmgr
TARGETTYPE=PROGRAM
TARGETPATH=obj

USE_MSVCRT      = 1
NO_BROWSER_FILE = 1
USE_RTTI        = 1

ATL_VER         = 30
USE_STATIC_ATL  = 1

!IF $(ALPHA)
USE_NTDLL=1
!ELSE
USE_NOLIBS=1
!ENDIF

#
# if you set DBG_GENERATE_PRETEND_EVENT=1 in your environment, you can get a version of
# the download manager that runs without ATL at all.  Also, it doesn't CoCreateInstance
# IID_IWiaEventCallback which makes it easier to run under boundschecker or another
# debugger.
#
!IF "$(DBG_GENERATE_PRETEND_EVENT)"=="1"
C_DEFINES=$(C_DEFINES) -DDBG_GENERATE_PRETEND_EVENT
!ENDIF


!IF "$(WINHEC_DEMO)"=="1"
C_DEFINES=$(C_DEFINES) -DWINHEC_DEMO
!ENDIF

INCLUDES=\
        $(INCLUDES);                \
        $(PROJECT_ROOT)\ui\prevwnd; \
        $(O)

SOURCES=\
        ..\acqmgr.cpp      \
        ..\acqmgrcw.cpp    \
        ..\atl.cpp         \
        ..\camsel.cpp      \
        ..\comdelp.cpp     \
        ..\comfin.cpp      \
        ..\comprog.cpp     \
        ..\comfirst.cpp    \
        ..\comtrans.cpp    \
        ..\flnfile.cpp     \
        ..\scansel.cpp     \
        ..\thrdmsg.cpp     \
        ..\thrdntfy.cpp    \
        ..\wiaacmgr.cpp    \
        ..\mintrans.cpp    \
        ..\eventprompt.cpp \
        ..\stievent.cpp    \
        ..\upquery.cpp     \
        ..\wiaacmgr.idl    \
        ..\wiaacmgr.rc

TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                           \
        $(SHELL_LIB_PATH)\shguidp.lib                            \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\wiashext.lib \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\$(O)\prevwnd.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=wiaacmgr.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\thrdntfy.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       THRDNTFY.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Class definitions for a class that is sent from the background
 *               thread to the UI thread.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "thrdntfy.h"

UINT CThreadNotificationMessage::s_nThreadNotificationMessage = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\ui\wiaacmgr\thrdntfy.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       THRDNTFY.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/28/1999
 *
 *  DESCRIPTION: Class declarations for a class that is sent from the background
 *               thread to the UI thread.
 *
 *******************************************************************************/
#ifndef __THRDNTFY_H_INCLUDED
#define __THRDNTFY_H_INCLUDED

#include <windows.h>

#define STR_THREAD_NOTIFICATION_MESSAGE   TEXT("WiaDowloadManagerThreadNotificationMessage")
#define STR_WIAEVENT_NOTIFICATION_MESSAGE T